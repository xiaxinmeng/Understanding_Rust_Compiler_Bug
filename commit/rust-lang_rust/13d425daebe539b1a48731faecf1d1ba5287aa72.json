{"sha": "13d425daebe539b1a48731faecf1d1ba5287aa72", "node_id": "C_kwDOAAsO6NoAKDEzZDQyNWRhZWJlNTM5YjFhNDg3MzFmYWVjZjFkMWJhNTI4N2FhNzI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-27T01:14:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-27T01:14:42Z"}, "message": "make permissive provenance and raw-ptr tagging the default", "tree": {"sha": "b9a18c1af82186576692d1b9d4538c5313df8319", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9a18c1af82186576692d1b9d4538c5313df8319"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13d425daebe539b1a48731faecf1d1ba5287aa72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13d425daebe539b1a48731faecf1d1ba5287aa72", "html_url": "https://github.com/rust-lang/rust/commit/13d425daebe539b1a48731faecf1d1ba5287aa72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13d425daebe539b1a48731faecf1d1ba5287aa72/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60570a39c7b0e3a8ed55e934eb7a18792f436bbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/60570a39c7b0e3a8ed55e934eb7a18792f436bbe", "html_url": "https://github.com/rust-lang/rust/commit/60570a39c7b0e3a8ed55e934eb7a18792f436bbe"}], "stats": {"total": 737, "additions": 491, "deletions": 246}, "files": [{"sha": "efdbf5143d9f7fbfbef7e5ee748d9e9a902cbfeb", "filename": "README.md", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -306,7 +306,7 @@ environment variable. We first document the most relevant and most commonly used\n * `-Zmiri-strict-provenance` enables [strict\n   provenance](https://github.com/rust-lang/rust/issues/95228) checking in Miri. This means that\n   casting an integer to a pointer yields a result with 'invalid' provenance, i.e., with provenance\n-  that cannot be used for any memory access. Also implies `-Zmiri-tag-raw-pointers`.\n+  that cannot be used for any memory access.\n \n The remaining flags are for advanced use only, and more likely to change or be removed.\n Some of these are **unsound**, which means they can lead\n@@ -321,7 +321,7 @@ to Miri failing to detect cases of undefined behavior in a program.\n   integers via `mem::transmute` or union/pointer type punning. This has two effects: it disables the\n   check against integers storing a pointer (i.e., data with provenance), thus allowing\n   pointer-to-integer transmutation, and it treats integer-to-pointer transmutation as equivalent to\n-  a cast. Using this flag is **unsound** and\n+  a cast. Implies `-Zmiri-permissive-provenance`. Using this flag is **unsound** and\n   [deprecated](https://github.com/rust-lang/miri/issues/2188).\n * `-Zmiri-disable-abi-check` disables checking [function ABI]. Using this flag\n   is **unsound**.\n@@ -354,15 +354,11 @@ to Miri failing to detect cases of undefined behavior in a program.\n   application instead of raising an error within the context of Miri (and halting\n   execution). Note that code might not expect these operations to ever panic, so\n   this flag can lead to strange (mis)behavior.\n-* `-Zmiri-permissive-provenance` is **experimental**. This will make Miri do a\n-  best-effort attempt to implement the semantics of\n-  [`expose_addr`](https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.expose_addr)\n-  and\n-  [`ptr::from_exposed_addr`](https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html)\n-  for pointer-to-int and int-to-pointer casts, respectively. This will\n-  necessarily miss some bugs as those semantics are not efficiently\n-  implementable in a sanitizer, but it will only miss bugs that concerns\n-  memory/pointers which is subject to these operations.\n+* `-Zmiri-permissive-provenance` disables the warning for integer-to-pointer casts and\n+  [`ptr::from_exposed_addr`](https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html).\n+  This will necessarily miss some bugs as those operations are not efficiently and accurately\n+  implementable in a sanitizer, but it will only miss bugs that concern memory/pointers which is\n+  subject to these operations.\n * `-Zmiri-symbolic-alignment-check` makes the alignment check more strict.  By\n   default, alignment is checked by casting the pointer to an integer, and making\n   sure that is a multiple of the alignment.  This can lead to cases where a\n@@ -389,13 +385,6 @@ to Miri failing to detect cases of undefined behavior in a program.\n   happening and where in your code would be a good place to look for it.\n   Specifying this argument multiple times does not overwrite the previous\n   values, instead it appends its values to the list. Listing a tag multiple times has no effect.\n-* `-Zmiri-tag-raw-pointers` makes Stacked Borrows assign proper tags even for raw pointers. This can\n-  make valid code using int-to-ptr casts fail to pass the checks, but also can help identify latent\n-  aliasing issues in code that Miri accepts by default. You can recognize false positives by\n-  `<untagged>` occurring in the message -- this indicates a pointer that was cast from an integer,\n-  so Miri was unable to track this pointer. Note that it is not currently guaranteed that code that\n-  works with `-Zmiri-tag-raw-pointers` also works without `-Zmiri-tag-raw-pointers`, but for the\n-  vast majority of code, this will be the case.\n \n [function ABI]: https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier\n "}, {"sha": "7bced912645db4e6eef00054d68268e45196ad70", "filename": "src/bin/miri.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -340,6 +340,7 @@ fn main() {\n                 Please let us know at <https://github.com/rust-lang/miri/issues/2188> if you rely on this flag.\"\n             );\n             miri_config.allow_ptr_int_transmute = true;\n+            miri_config.provenance_mode = ProvenanceMode::Permissive;\n         } else if arg == \"-Zmiri-disable-abi-check\" {\n             miri_config.check_abi = false;\n         } else if arg == \"-Zmiri-disable-isolation\" {\n@@ -374,20 +375,18 @@ fn main() {\n         } else if arg == \"-Zmiri-panic-on-unsupported\" {\n             miri_config.panic_on_unsupported = true;\n         } else if arg == \"-Zmiri-tag-raw-pointers\" {\n-            miri_config.tag_raw = true;\n+            eprintln!(\"WARNING: `-Zmiri-tag-raw-pointers` has no effect; it is enabled by default\");\n         } else if arg == \"-Zmiri-strict-provenance\" {\n             miri_config.provenance_mode = ProvenanceMode::Strict;\n-            miri_config.tag_raw = true;\n+            miri_config.allow_ptr_int_transmute = false;\n         } else if arg == \"-Zmiri-permissive-provenance\" {\n             miri_config.provenance_mode = ProvenanceMode::Permissive;\n-            miri_config.tag_raw = true;\n         } else if arg == \"-Zmiri-mute-stdout-stderr\" {\n             miri_config.mute_stdout_stderr = true;\n         } else if arg == \"-Zmiri-track-raw-pointers\" {\n             eprintln!(\n                 \"WARNING: -Zmiri-track-raw-pointers has been renamed to -Zmiri-tag-raw-pointers, the old name is deprecated.\"\n             );\n-            miri_config.tag_raw = true;\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-seed=\") {\n             if miri_config.seed.is_some() {\n                 panic!(\"Cannot specify -Zmiri-seed multiple times!\");"}, {"sha": "d17d1e6ed4c879628e089f39f2969de41941e661", "filename": "src/diagnostics.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -69,6 +69,7 @@ pub enum NonHaltingDiagnostic {\n     FreedAlloc(AllocId),\n     RejectedIsolatedOp(String),\n     ProgressReport,\n+    Int2Ptr,\n }\n \n /// Level of Miri specific diagnostics\n@@ -468,15 +469,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         format!(\"{op} was made to return an error due to isolation\"),\n                     ProgressReport =>\n                         format!(\"progress report: current operation being executed is here\"),\n+                    Int2Ptr => format!(\"pointer-to-integer cast\"),\n                 };\n \n                 let (title, diag_level) = match e {\n                     RejectedIsolatedOp(_) =>\n                         (\"operation rejected by isolation\", DiagLevel::Warning),\n-                    _ => (\"tracking was triggered\", DiagLevel::Note),\n+                    Int2Ptr => (\"pointer-to-integer cast\", DiagLevel::Warning),\n+                    CreatedPointerTag(..)\n+                    | PoppedPointerTag(..)\n+                    | CreatedCallId(..)\n+                    | CreatedAlloc(..)\n+                    | FreedAlloc(..)\n+                    | ProgressReport => (\"tracking was triggered\", DiagLevel::Note),\n                 };\n \n-                report_msg(this, diag_level, title, vec![msg], vec![], &stacktrace);\n+                let helps = match e {\n+                    Int2Ptr =>\n+                        vec![\n+                            (None, format!(\"this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\")),\n+                            (None, format!(\"which means that Miri might miss pointer bugs in this program\")),\n+                            (None, format!(\"see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\")),\n+                            (None, format!(\"to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\")),\n+                            (None, format!(\"you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\")),\n+                            (None, format!(\"alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\")),\n+                        ],\n+                    _ => vec![],\n+                };\n+\n+                report_msg(this, diag_level, title, vec![msg], helps, &stacktrace);\n             }\n         });\n     }"}, {"sha": "fa252953fe6e4e7fc252573fb72e081b2760b86e", "filename": "src/eval.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -101,8 +101,6 @@ pub struct MiriConfig {\n     pub tracked_call_ids: HashSet<CallId>,\n     /// The allocation ids to report about.\n     pub tracked_alloc_ids: HashSet<AllocId>,\n-    /// Whether to track raw pointers in stacked borrows.\n-    pub tag_raw: bool,\n     /// Determine if data race detection should be enabled\n     pub data_race_detector: bool,\n     /// Determine if weak memory emulation should be enabled. Requires data race detection to be enabled\n@@ -146,14 +144,13 @@ impl Default for MiriConfig {\n             tracked_pointer_tags: HashSet::default(),\n             tracked_call_ids: HashSet::default(),\n             tracked_alloc_ids: HashSet::default(),\n-            tag_raw: false,\n             data_race_detector: true,\n             weak_memory_emulation: true,\n             cmpxchg_weak_failure_rate: 0.8, // 80%\n             measureme_out: None,\n             panic_on_unsupported: false,\n             backtrace_style: BacktraceStyle::Short,\n-            provenance_mode: ProvenanceMode::Legacy,\n+            provenance_mode: ProvenanceMode::Default,\n             mute_stdout_stderr: false,\n             preemption_rate: 0.01, // 1%\n             report_progress: None,"}, {"sha": "c92954a218ca2dbfad50bd7232757390bd452a99", "filename": "src/intptrcast.rs", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -11,16 +11,13 @@ use crate::*;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum ProvenanceMode {\n-    /// Int2ptr casts return pointers with \"wildcard\" provenance\n-    /// that basically matches that of all exposed pointers\n-    /// (and SB tags, if enabled).\n+    /// We support `expose_addr`/`from_exposed_addr` via \"wildcard\" provenance.\n+    /// However, we want on `from_exposed_addr` to alert the user of the precision loss.\n+    Default,\n+    /// Like `Default`, but without the warning.\n     Permissive,\n-    /// Int2ptr casts return pointers with an invalid provenance,\n-    /// i.e., not valid for any memory access.\n+    /// We error on `from_exposed_addr`, ensuring no precision loss.\n     Strict,\n-    /// Int2ptr casts determine the allocation they point to at cast time.\n-    /// All allocations are considered exposed.\n-    Legacy,\n }\n \n pub type GlobalState = RefCell<GlobalStateInner>;\n@@ -66,6 +63,8 @@ impl<'mir, 'tcx> GlobalStateInner {\n \n         let pos = global_state.int_to_ptr_map.binary_search_by_key(&addr, |(addr, _)| *addr);\n \n+        // Determine the in-bounds provenance for this pointer.\n+        // (This is only called on an actual access, so in-bounds is the only possible kind of provenance.)\n         let alloc_id = match pos {\n             Ok(pos) => Some(global_state.int_to_ptr_map[pos].1),\n             Err(0) => None,\n@@ -91,21 +90,14 @@ impl<'mir, 'tcx> GlobalStateInner {\n             }\n         }?;\n \n-        // In legacy mode, we consider all allocations exposed.\n-        if global_state.provenance_mode == ProvenanceMode::Legacy\n-            || global_state.exposed.contains(&alloc_id)\n-        {\n-            Some(alloc_id)\n-        } else {\n-            None\n-        }\n+        // We only use this provenance if it has been exposed.\n+        if global_state.exposed.contains(&alloc_id) { Some(alloc_id) } else { None }\n     }\n \n     pub fn expose_ptr(ecx: &mut MiriEvalContext<'mir, 'tcx>, alloc_id: AllocId, sb: SbTag) {\n         let global_state = ecx.machine.intptrcast.get_mut();\n-        // In legacy and strict mode, we don't need this, so we can save some cycles\n-        // by not tracking it.\n-        if global_state.provenance_mode == ProvenanceMode::Permissive {\n+        // In strict mode, we don't need this, so we can save some cycles by not tracking it.\n+        if global_state.provenance_mode != ProvenanceMode::Strict {\n             trace!(\"Exposing allocation id {alloc_id:?}\");\n             global_state.exposed.insert(alloc_id);\n             if ecx.machine.stacked_borrows.is_some() {\n@@ -120,42 +112,43 @@ impl<'mir, 'tcx> GlobalStateInner {\n     ) -> Pointer<Option<Tag>> {\n         trace!(\"Transmuting 0x{:x} to a pointer\", addr);\n \n-        if ecx.machine.allow_ptr_int_transmute {\n-            // When we allow transmutes, treat them like casts.\n-            Self::ptr_from_addr_cast(ecx, addr)\n+        let provenance = if ecx.machine.allow_ptr_int_transmute {\n+            // When we allow transmutes, treat them like casts: generating a wildcard pointer.\n+            Some(Tag::Wildcard)\n         } else {\n-            // We consider transmuted pointers to be \"invalid\" (`None` provenance).\n-            Pointer::new(None, Size::from_bytes(addr))\n-        }\n+            // Usually, we consider transmuted pointers to be \"invalid\" (`None` provenance).\n+            None\n+        };\n+        Pointer::new(provenance, Size::from_bytes(addr))\n     }\n \n     pub fn ptr_from_addr_cast(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         addr: u64,\n-    ) -> Pointer<Option<Tag>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n         trace!(\"Casting 0x{:x} to a pointer\", addr);\n \n         let global_state = ecx.machine.intptrcast.borrow();\n \n         match global_state.provenance_mode {\n-            ProvenanceMode::Legacy => {\n-                // Determine the allocation this points to at cast time.\n-                let alloc_id = Self::alloc_id_from_addr(ecx, addr);\n-                Pointer::new(\n-                    alloc_id.map(|alloc_id| Tag::Concrete { alloc_id, sb: SbTag::Untagged }),\n-                    Size::from_bytes(addr),\n-                )\n+            ProvenanceMode::Default => {\n+                // The first time this happens, print a warning.\n+                use std::sync::atomic::{AtomicBool, Ordering};\n+                static FIRST_WARNING: AtomicBool = AtomicBool::new(true);\n+                if FIRST_WARNING.swap(false, Ordering::Relaxed) {\n+                    register_diagnostic(NonHaltingDiagnostic::Int2Ptr);\n+                }\n             }\n             ProvenanceMode::Strict => {\n-                // We don't support int2ptr casts in this mode (i.e., we treat them like\n-                // transmutes).\n-                Pointer::new(None, Size::from_bytes(addr))\n-            }\n-            ProvenanceMode::Permissive => {\n-                // This is how wildcard pointers are born.\n-                Pointer::new(Some(Tag::Wildcard), Size::from_bytes(addr))\n+                throw_unsup_format!(\n+                    \"integer-to-pointer casts and `from_exposed_addr` are not supported with `-Zmiri-strict-provenance`; use `with_addr` instead\"\n+                )\n             }\n+            ProvenanceMode::Permissive => {}\n         }\n+\n+        // This is how wildcard pointers are born.\n+        Ok(Pointer::new(Some(Tag::Wildcard), Size::from_bytes(addr)))\n     }\n \n     fn alloc_base_addr(ecx: &MiriEvalContext<'mir, 'tcx>, alloc_id: AllocId) -> u64 {\n@@ -214,6 +207,8 @@ impl<'mir, 'tcx> GlobalStateInner {\n         dl.overflowing_offset(base_addr, offset.bytes()).0\n     }\n \n+    /// Whena  pointer is used for a memory access, this computes where in which allocation the\n+    /// access is going.\n     pub fn abs_ptr_to_rel(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         ptr: Pointer<Tag>,\n@@ -224,7 +219,6 @@ impl<'mir, 'tcx> GlobalStateInner {\n             alloc_id\n         } else {\n             // A wildcard pointer.\n-            assert_eq!(ecx.machine.intptrcast.borrow().provenance_mode, ProvenanceMode::Permissive);\n             GlobalStateInner::alloc_id_from_addr(ecx, addr.bytes())?\n         };\n "}, {"sha": "d6a65a2a44c8c26799d82cecd5d7a834f4b72452", "filename": "src/machine.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -353,7 +353,6 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             Some(RefCell::new(stacked_borrows::GlobalStateInner::new(\n                 config.tracked_pointer_tags.clone(),\n                 config.tracked_call_ids.clone(),\n-                config.tag_raw,\n             )))\n         } else {\n             None\n@@ -696,7 +695,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         addr: u64,\n     ) -> InterpResult<'tcx, Pointer<Option<Self::PointerTag>>> {\n-        Ok(intptrcast::GlobalStateInner::ptr_from_addr_cast(ecx, addr))\n+        intptrcast::GlobalStateInner::ptr_from_addr_cast(ecx, addr)\n     }\n \n     #[inline(always)]"}, {"sha": "23408027626c62e2eae6947372e9f36e65230d70", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -219,19 +219,15 @@ impl fmt::Display for RefKind {\n \n /// Utilities for initialization and ID generation\n impl GlobalStateInner {\n-    pub fn new(\n-        tracked_pointer_tags: HashSet<PtrId>,\n-        tracked_call_ids: HashSet<CallId>,\n-        tag_raw: bool,\n-    ) -> Self {\n+    pub fn new(tracked_pointer_tags: HashSet<PtrId>, tracked_call_ids: HashSet<CallId>) -> Self {\n         GlobalStateInner {\n             next_ptr_id: NonZeroU64::new(1).unwrap(),\n             base_ptr_ids: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n             active_calls: FxHashSet::default(),\n             tracked_pointer_tags,\n             tracked_call_ids,\n-            tag_raw,\n+            tag_raw: true,\n         }\n     }\n "}, {"sha": "42978c481bff9eb7809da8f6091afc9f08e865ac", "filename": "test-cargo-miri/run-test.py", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/test-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/test-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Frun-test.py?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -124,11 +124,6 @@ def test_cargo_miri_test():\n         \"test.cross-target.stdout.ref\", \"test.stderr-empty.ref\",\n         env={'MIRIFLAGS': \"-Zmiri-disable-isolation\"},\n     )\n-    test(\"`cargo miri test` (raw-ptr tracking)\",\n-        cargo_miri(\"test\"),\n-        default_ref, \"test.stderr-empty.ref\",\n-        env={'MIRIFLAGS': \"-Zmiri-tag-raw-pointers\"},\n-    )\n     test(\"`cargo miri test` (with filter)\",\n         cargo_miri(\"test\") + [\"--\", \"--format=pretty\", \"le1\"],\n         filter_ref, \"test.stderr-empty.ref\","}, {"sha": "ba16335fce3a71dd651f58610edf9545eac17941", "filename": "tests/fail/backtrace/bad-backtrace-flags.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-flags.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-flags.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-flags.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,18 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/bad-backtrace-flags.rs:LL:CC\n+   |\n+LL |         miri_get_backtrace(2, 0 as *mut _);\n+   |                               ^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/bad-backtrace-flags.rs:LL:CC\n+\n error: unsupported operation: unknown `miri_get_backtrace` flags 2\n   --> $DIR/bad-backtrace-flags.rs:LL:CC\n    |\n@@ -10,5 +25,5 @@ LL |         miri_get_backtrace(2, 0 as *mut _);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "75268b6671421bb1b5cdb1a40071acb2741b382a", "filename": "tests/fail/backtrace/bad-backtrace-ptr.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-ptr.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,18 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/bad-backtrace-ptr.rs:LL:CC\n+   |\n+LL |         miri_resolve_frame(0 as *mut _, 0);\n+   |                            ^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/bad-backtrace-ptr.rs:LL:CC\n+\n error: Undefined Behavior: null pointer is not a valid pointer for this operation\n   --> $DIR/bad-backtrace-ptr.rs:LL:CC\n    |\n@@ -11,5 +26,5 @@ LL |         miri_resolve_frame(0 as *mut _, 0);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "fad9ffe1192097301875e9a7ad6505166239b873", "filename": "tests/fail/backtrace/bad-backtrace-resolve-flags.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-flags.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-flags.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-flags.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,18 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/bad-backtrace-resolve-flags.rs:LL:CC\n+   |\n+LL |         let mut buf = vec![0 as *mut _; miri_backtrace_size(0)];\n+   |                            ^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/bad-backtrace-resolve-flags.rs:LL:CC\n+\n error: unsupported operation: unknown `miri_resolve_frame` flags 2\n   --> $DIR/bad-backtrace-resolve-flags.rs:LL:CC\n    |\n@@ -10,5 +25,5 @@ LL |         miri_resolve_frame(buf[0], 2);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "18b03df21c6f686155efe18e603cfc5b0160b207", "filename": "tests/fail/backtrace/bad-backtrace-resolve-names-flags.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-names-flags.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-names-flags.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-names-flags.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,18 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/bad-backtrace-resolve-names-flags.rs:LL:CC\n+   |\n+LL |         let mut buf = vec![0 as *mut _; miri_backtrace_size(0)];\n+   |                            ^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/bad-backtrace-resolve-names-flags.rs:LL:CC\n+\n error: unsupported operation: unknown `miri_resolve_frame_names` flags 2\n   --> $DIR/bad-backtrace-resolve-names-flags.rs:LL:CC\n    |\n@@ -10,5 +25,5 @@ LL | ...   miri_resolve_frame_names(buf[0], 2, 0 as *mut _, 0 as *mut _);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "31a64eec36858baf055fdc6954bccf94c352679f", "filename": "tests/fail/concurrency/thread_local_static_dealloc.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,18 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/thread_local_static_dealloc.rs:LL:CC\n+   |\n+LL |         let _val = *(dangling_ptr as *const u8);\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/thread_local_static_dealloc.rs:LL:CC\n+\n error: Undefined Behavior: pointer to ALLOC was dereferenced after this allocation got freed\n   --> $DIR/thread_local_static_dealloc.rs:LL:CC\n    |\n@@ -11,5 +26,5 @@ LL |         let _val = *(dangling_ptr as *const u8);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "ffd7fb1980dc42369ae40c8771629ede81c79040", "filename": "tests/fail/dangling_pointers/deref-invalid-ptr.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fdangling_pointers%2Fderef-invalid-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fdangling_pointers%2Fderef-invalid-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdangling_pointers%2Fderef-invalid-ptr.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,18 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/deref-invalid-ptr.rs:LL:CC\n+   |\n+LL |     let x = 16usize as *const u32;\n+   |             ^^^^^^^^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/deref-invalid-ptr.rs:LL:CC\n+\n error: Undefined Behavior: dereferencing pointer failed: 0x10 is not a valid pointer\n   --> $DIR/deref-invalid-ptr.rs:LL:CC\n    |\n@@ -11,5 +26,5 @@ LL |     let _y = unsafe { &*x as *const u32 };\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "3a94a7fa58ee99e57bc4bc328204307377ed2721", "filename": "tests/fail/dangling_pointers/storage_dead_dangling.stderr", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,23 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/storage_dead_dangling.rs:LL:CC\n+   |\n+LL |     unsafe { &mut *(LEAK as *mut i32) };\n+   |                    ^^^^^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `evil` at $DIR/storage_dead_dangling.rs:LL:CC\n+note: inside `main` at $DIR/storage_dead_dangling.rs:LL:CC\n+  --> $DIR/storage_dead_dangling.rs:LL:CC\n+   |\n+LL |     evil();\n+   |     ^^^^^^\n+\n error: Undefined Behavior: pointer to ALLOC was dereferenced after this allocation got freed\n   --> $DIR/storage_dead_dangling.rs:LL:CC\n    |\n@@ -16,5 +36,5 @@ LL |     evil();\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "960f9c9ce3e9c2707d9bfa29e4d52db538a2bbe6", "filename": "tests/fail/dangling_pointers/wild_pointer_deref.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fdangling_pointers%2Fwild_pointer_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fdangling_pointers%2Fwild_pointer_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdangling_pointers%2Fwild_pointer_deref.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,18 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/wild_pointer_deref.rs:LL:CC\n+   |\n+LL |     let p = 44 as *const i32;\n+   |             ^^^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/wild_pointer_deref.rs:LL:CC\n+\n error: Undefined Behavior: dereferencing pointer failed: 0x2c is not a valid pointer\n   --> $DIR/wild_pointer_deref.rs:LL:CC\n    |\n@@ -11,5 +26,5 @@ LL |     let x = unsafe { *p };\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "2474820545d246702ed94c571702041cc447d354", "filename": "tests/fail/intrinsics/ptr_offset_0_plus_0.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fintrinsics%2Fptr_offset_0_plus_0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fintrinsics%2Fptr_offset_0_plus_0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fptr_offset_0_plus_0.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,18 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/ptr_offset_0_plus_0.rs:LL:CC\n+   |\n+LL |     let x = 0 as *mut i32;\n+   |             ^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/ptr_offset_0_plus_0.rs:LL:CC\n+\n error: Undefined Behavior: pointer arithmetic failed: null pointer is not a valid pointer\n   --> RUSTLIB/core/src/ptr/mut_ptr.rs:LL:CC\n    |\n@@ -16,5 +31,5 @@ LL |     let _x = unsafe { x.offset(0) }; // UB despite offset 0, NULL is never\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "f5cbd4bbbf73145ed0aac15332130c85bbf0b10a", "filename": "tests/fail/intrinsics/ptr_offset_int_plus_int.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fintrinsics%2Fptr_offset_int_plus_int.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fintrinsics%2Fptr_offset_int_plus_int.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fptr_offset_int_plus_int.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,18 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/ptr_offset_int_plus_int.rs:LL:CC\n+   |\n+LL |         let _val = (1 as *mut u8).offset(1);\n+   |                    ^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/ptr_offset_int_plus_int.rs:LL:CC\n+\n error: Undefined Behavior: pointer arithmetic failed: 0x1 is not a valid pointer\n   --> RUSTLIB/core/src/ptr/mut_ptr.rs:LL:CC\n    |\n@@ -16,5 +31,5 @@ LL |         let _val = (1 as *mut u8).offset(1);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "577a377f076e7a6b5c7f8a721affca8e742d84b4", "filename": "tests/fail/intrinsics/ptr_offset_int_plus_ptr.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fintrinsics%2Fptr_offset_int_plus_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fintrinsics%2Fptr_offset_int_plus_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fptr_offset_int_plus_ptr.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,18 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/ptr_offset_int_plus_ptr.rs:LL:CC\n+   |\n+LL |         let _val = (1 as *mut u8).offset(ptr as isize);\n+   |                    ^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/ptr_offset_int_plus_ptr.rs:LL:CC\n+\n error: Undefined Behavior: pointer arithmetic failed: 0x1 is not a valid pointer\n   --> RUSTLIB/core/src/ptr/mut_ptr.rs:LL:CC\n    |\n@@ -16,5 +31,5 @@ LL |         let _val = (1 as *mut u8).offset(ptr as isize);\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "538ec4484edb9282b09c5512ff2b3282f8ed1750", "filename": "tests/fail/provenance/ptr_legacy_provenance.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/60570a39c7b0e3a8ed55e934eb7a18792f436bbe/tests%2Ffail%2Fprovenance%2Fptr_legacy_provenance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60570a39c7b0e3a8ed55e934eb7a18792f436bbe/tests%2Ffail%2Fprovenance%2Fptr_legacy_provenance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fptr_legacy_provenance.rs?ref=60570a39c7b0e3a8ed55e934eb7a18792f436bbe", "patch": "@@ -1,22 +0,0 @@\n-// compile-flags: -Zmiri-disable-stacked-borrows\n-// normalize-stderr-test: \"offset -[0-9]+\" -> \"offset -XX\"\n-#![feature(strict_provenance)]\n-\n-use std::ptr;\n-\n-// Make sure that with legacy provenance, the allocation id of\n-// a casted pointer is determined at cast-time\n-fn main() {\n-    let x: i32 = 0;\n-    let y: i32 = 1;\n-\n-    let x_ptr = &x as *const i32;\n-    let y_ptr = &y as *const i32;\n-\n-    let x_usize = x_ptr.expose_addr();\n-    let y_usize = y_ptr.expose_addr();\n-\n-    let ptr = ptr::from_exposed_addr::<i32>(y_usize);\n-    let ptr = ptr.with_addr(x_usize);\n-    assert_eq!(unsafe { *ptr }, 0); //~ ERROR is out-of-bounds\n-}"}, {"sha": "4552be08145d4a9654927238cf8572f07b310117", "filename": "tests/fail/provenance/ptr_legacy_provenance.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/60570a39c7b0e3a8ed55e934eb7a18792f436bbe/tests%2Ffail%2Fprovenance%2Fptr_legacy_provenance.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60570a39c7b0e3a8ed55e934eb7a18792f436bbe/tests%2Ffail%2Fprovenance%2Fptr_legacy_provenance.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fptr_legacy_provenance.stderr?ref=60570a39c7b0e3a8ed55e934eb7a18792f436bbe", "patch": "@@ -1,15 +0,0 @@\n-error: Undefined Behavior: dereferencing pointer failed: ALLOC has size 4, so pointer to 4 bytes starting at offset -XX is out-of-bounds\n-  --> $DIR/ptr_legacy_provenance.rs:LL:CC\n-   |\n-LL |     assert_eq!(unsafe { *ptr }, 0);\n-   |                         ^^^^ dereferencing pointer failed: ALLOC has size 4, so pointer to 4 bytes starting at offset -XX is out-of-bounds\n-   |\n-   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n-   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-           \n-   = note: inside `main` at $DIR/ptr_legacy_provenance.rs:LL:CC\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "66220cfbfc4d3c43363130903a895ea2cfe0ddf8", "filename": "tests/fail/stacked_borrows/aliasing_mut3.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow <untagged> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to reborrow <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/aliasing_mut3.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &i32) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    | |\n-   | trying to reborrow <untagged> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   | trying to reborrow <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    | this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/aliasing_mut3.rs:LL:CC\n    |\n LL |     safe_raw(xraw, xshr);\n    |                    ^^^^\n-help: tag was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/aliasing_mut3.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &i32) {}"}, {"sha": "66d092d6277c8b1912f491e751f8ec6a659ee688", "filename": "tests/fail/stacked_borrows/box_exclusive_violation1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -8,7 +8,7 @@ fn demo_mut_advanced_unique(mut our: Box<i32>) -> i32 {\n     unknown_code_2();\n \n     // We know this will return 5\n-    *our //~ ERROR borrow stack\n+    *our\n }\n \n // Now comes the evil context\n@@ -24,7 +24,7 @@ fn unknown_code_1(x: &i32) {\n \n fn unknown_code_2() {\n     unsafe {\n-        *LEAK = 7;\n+        *LEAK = 7; //~ ERROR borrow stack\n     }\n }\n "}, {"sha": "06c2dc340b7bac6321fa9799a1daef01d4d903ec", "filename": "tests/fail/stacked_borrows/box_exclusive_violation1.stderr", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,31 +1,30 @@\n-error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |\n-LL |     *our\n-   |     ^^^^\n-   |     |\n-   |     attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |     this error occurs as part of an access at ALLOC[0x0..0x4]\n+LL |         *LEAK = 7;\n+   |         ^^^^^^^^^\n+   |         |\n+   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |\n-LL | / fn demo_mut_advanced_unique(mut our: Box<i32>) -> i32 {\n-LL | |     unknown_code_1(&*our);\n-LL | |\n-LL | |     // This \"re-asserts\" uniqueness of the reference: After writing, we know\n-...  |\n-LL | |     *our\n-LL | | }\n-   | |_^\n+LL |         LEAK = x as *const _ as *mut _;\n+   |                ^\n help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |\n-LL |         *LEAK = 7;\n-   |         ^^^^^^^^^\n-   = note: inside `demo_mut_advanced_unique` at $DIR/box_exclusive_violation1.rs:LL:CC\n+LL |     *our = 5;\n+   |     ^^^^^^^^\n+   = note: inside `unknown_code_2` at $DIR/box_exclusive_violation1.rs:LL:CC\n+note: inside `demo_mut_advanced_unique` at $DIR/box_exclusive_violation1.rs:LL:CC\n+  --> $DIR/box_exclusive_violation1.rs:LL:CC\n+   |\n+LL |     unknown_code_2();\n+   |     ^^^^^^^^^^^^^^^^\n note: inside `main` at $DIR/box_exclusive_violation1.rs:LL:CC\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |"}, {"sha": "0173ca14b22dad143227305bd6b7e6681ebd70ea", "filename": "tests/fail/stacked_borrows/illegal_read3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_read3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_read3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read3.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -5,7 +5,7 @@\n use std::mem;\n \n union HiddenRef {\n-    // We avoid retagging at this type, so shared vs mutable does not matter.\n+    // We avoid retagging at this type, and we only read, so shared vs mutable does not matter.\n     r: &'static i32,\n }\n "}, {"sha": "2098dbdc6a492ee8f1dee9d5ea3c5bba6df82739", "filename": "tests/fail/stacked_borrows/illegal_read6.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/illegal_read6.rs:LL:CC\n    |\n LL |         let _val = *raw;\n    |                    ^^^^\n    |                    |\n-   |                    attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                    attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    |                    this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/illegal_read6.rs:LL:CC\n    |\n LL |         let raw = x as *mut _;\n    |                   ^\n-help: tag was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/illegal_read6.rs:LL:CC\n    |\n LL |         let x = &mut *x; // kill `raw`"}, {"sha": "58600402e4edd1558b81ce856d3edbfc1744f8f2", "filename": "tests/fail/stacked_borrows/illegal_write1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -3,7 +3,7 @@ fn main() {\n     let xref = &*target;\n     {\n         let x: *mut u32 = xref as *const _ as *mut _;\n-        unsafe { *x = 42 }; // invalidates shared ref, activates raw\n+        unsafe { *x = 42 }; //~ ERROR only grants SharedReadOnly permission\n     }\n-    let _x = *xref; //~ ERROR borrow stack\n+    let _x = *xref;\n }"}, {"sha": "b2084da862fe08082566d380714c7d320b8c0435", "filename": "tests/fail/stacked_borrows/illegal_write1.stderr", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,24 +1,19 @@\n-error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n   --> $DIR/illegal_write1.rs:LL:CC\n    |\n-LL |     let _x = *xref;\n-   |              ^^^^^\n-   |              |\n-   |              attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |              this error occurs as part of an access at ALLOC[0x0..0x4]\n+LL |         unsafe { *x = 42 };\n+   |                  ^^^^^^^\n+   |                  |\n+   |                  attempting a write access using <TAG> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n+   |                  this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write1.rs:LL:CC\n    |\n-LL |     let xref = &*target;\n-   |                ^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n-  --> $DIR/illegal_write1.rs:LL:CC\n-   |\n-LL |         unsafe { *x = 42 }; // invalidates shared ref, activates raw\n-   |                  ^^^^^^^\n+LL |         let x: *mut u32 = xref as *const _ as *mut _;\n+   |                           ^^^^\n    = note: inside `main` at $DIR/illegal_write1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "09784bd79a18884b6c42e6e9f33e30f8baf5b46a", "filename": "tests/fail/stacked_borrows/illegal_write2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write2.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/illegal_write2.rs:LL:CC\n    |\n LL |     unsafe { *target2 = 13 };\n    |              ^^^^^^^^^^^^^\n    |              |\n-   |              attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |              attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    |              this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write2.rs:LL:CC\n    |\n LL |     let target2 = target as *mut _;\n    |                   ^^^^^^\n-help: tag was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/illegal_write2.rs:LL:CC\n    |\n LL |     drop(&mut *target); // reborrow"}, {"sha": "983894dad065c68295d9fabec8652640214e381d", "filename": "tests/fail/stacked_borrows/illegal_write3.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write3.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,15 +1,15 @@\n-error: Undefined Behavior: attempting a write access using <untagged> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n   --> $DIR/illegal_write3.rs:LL:CC\n    |\n LL |     unsafe { *ptr = 42 };\n    |              ^^^^^^^^^\n    |              |\n-   |              attempting a write access using <untagged> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n+   |              attempting a write access using <TAG> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n    |              this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write3.rs:LL:CC\n    |\n LL |     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag"}, {"sha": "654a23d382b8d25509540d1bcc3e002125e0e6de", "filename": "tests/fail/stacked_borrows/illegal_write4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -6,8 +6,8 @@ fn main() {\n     // Even just creating it unfreezes.\n     let raw = &mut target as *mut _; // let this leak to raw\n     let reference = unsafe { &*raw }; // freeze\n-    let ptr = reference as *const _ as *mut i32; // raw ptr, with raw tag\n-    let _mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n+    let _ptr = reference as *const _ as *mut i32; // raw ptr, with raw tag\n+    let _mut_ref: &mut i32 = unsafe { mem::transmute(raw) }; // &mut, with raw tag\n     // Now we retag, making our ref top-of-stack -- and, in particular, unfreezing.\n     let _val = *reference; //~ ERROR borrow stack\n }"}, {"sha": "ac4dd68bbc7e48215bdeec50fa7c2e32871e9648", "filename": "tests/fail/stacked_borrows/illegal_write4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -17,7 +17,7 @@ LL |     let reference = unsafe { &*raw }; // freeze\n help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/illegal_write4.rs:LL:CC\n    |\n-LL |     let _mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n+LL |     let _mut_ref: &mut i32 = unsafe { mem::transmute(raw) }; // &mut, with raw tag\n    |                                       ^^^^^^^^^^^^^^^^^^^\n    = note: inside `main` at $DIR/illegal_write4.rs:LL:CC\n "}, {"sha": "563397e062d59e65a3f1c539817e64af1ba3a874", "filename": "tests/fail/stacked_borrows/illegal_write6.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,17 +1,17 @@\n-error: Undefined Behavior: not granting access to tag <untagged> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     unsafe { *y = 2 };\n-   |              ^^^^^^ not granting access to tag <untagged> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   |              ^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     let p = x as *mut u32;\n    |             ^\n-help: <TAG> was protected due to a tag which was created here\n+help: <TAG> was protected due to <TAG> which was created here\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     foo(x, p);"}, {"sha": "826cdc9b5f8e649832eba72a53b1f9efc5d6010e", "filename": "tests/fail/stacked_borrows/invalidate_against_barrier1.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,17 +1,17 @@\n-error: Undefined Behavior: not granting access to tag <untagged> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n   --> $DIR/invalidate_against_barrier1.rs:LL:CC\n    |\n LL |     let _val = unsafe { *x };\n-   |                         ^^ not granting access to tag <untagged> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   |                         ^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/invalidate_against_barrier1.rs:LL:CC\n    |\n LL |     let xraw = &mut x as *mut _;\n    |                ^^^^^^\n-help: <TAG> was protected due to a tag which was created here\n+help: <TAG> was protected due to <TAG> which was created here\n   --> $DIR/invalidate_against_barrier1.rs:LL:CC\n    |\n LL |     inner(xraw, xref);"}, {"sha": "1cf90f91db02bfe1afc4e5b3eb553807ea568774", "filename": "tests/fail/stacked_borrows/invalidate_against_barrier2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,17 +1,17 @@\n-error: Undefined Behavior: not granting access to tag <untagged> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n   --> $DIR/invalidate_against_barrier2.rs:LL:CC\n    |\n LL |     unsafe { *x = 0 };\n-   |              ^^^^^^ not granting access to tag <untagged> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+   |              ^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/invalidate_against_barrier2.rs:LL:CC\n    |\n LL |     let xraw = &mut x as *mut _;\n    |                ^^^^^^\n-help: <TAG> was protected due to a tag which was created here\n+help: <TAG> was protected due to <TAG> which was created here\n   --> $DIR/invalidate_against_barrier2.rs:LL:CC\n    |\n LL |     inner(xraw, xref);"}, {"sha": "8afb4fee18b5168aa7bbd997d4ebcbf1e0968192", "filename": "tests/fail/stacked_borrows/mut_exclusive_violation1.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation1.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/mut_exclusive_violation1.rs:LL:CC\n    |\n LL |         *LEAK = 7;\n    |         ^^^^^^^^^\n    |         |\n-   |         attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    |         this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/mut_exclusive_violation1.rs:LL:CC\n    |\n LL |         LEAK = x as *const _ as *mut _;\n    |                ^\n-help: tag was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/mut_exclusive_violation1.rs:LL:CC\n    |\n LL |     *our = 5;"}, {"sha": "c218d500cf8b84ba712e31201a92e734703a6c52", "filename": "tests/fail/stacked_borrows/outdated_local.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Foutdated_local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Foutdated_local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Foutdated_local.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/outdated_local.rs:LL:CC\n    |\n LL |     assert_eq!(unsafe { *y }, 1);\n    |                         ^^\n    |                         |\n-   |                         attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                         attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    |                         this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/outdated_local.rs:LL:CC\n    |\n LL |     let y: *const i32 = &x;\n    |                         ^^\n-help: tag was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/outdated_local.rs:LL:CC\n    |\n LL |     x = 1; // this invalidates y by reactivating the lowermost uniq borrow for this local"}, {"sha": "a3ab1b9fc5e5c2282fbe56de1f12e6159277e43a", "filename": "tests/fail/stacked_borrows/pointer_smuggling.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fpointer_smuggling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fpointer_smuggling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fpointer_smuggling.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/pointer_smuggling.rs:LL:CC\n    |\n LL |     let _x = unsafe { *PTR };\n    |                       ^^^^\n    |                       |\n-   |                       attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                       attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    |                       this error occurs as part of an access at ALLOC[0x0..0x1]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x1]\n+help: <TAG> was created by a retag at offsets [0x0..0x1]\n   --> $DIR/pointer_smuggling.rs:LL:CC\n    |\n LL |         PTR = x;\n    |               ^\n-help: tag was later invalidated at offsets [0x0..0x1]\n+help: <TAG> was later invalidated at offsets [0x0..0x1]\n   --> $DIR/pointer_smuggling.rs:LL:CC\n    |\n LL |     *val = 2; // this invalidates any raw ptrs `fun1` might have created."}, {"sha": "49fe983125500e9fc205be93e3bfe2c9f4ab28a7", "filename": "tests/fail/stacked_borrows/raw_tracking.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fraw_tracking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fraw_tracking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fraw_tracking.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags: -Zmiri-tag-raw-pointers\n //! This demonstrates a provenance problem that requires tracking of raw pointers to be detected.\n \n fn main() {"}, {"sha": "55872300713a291e348a5d0989f5b5a5c2f03127", "filename": "tests/fail/stacked_borrows/shr_frozen_violation1.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,15 +1,15 @@\n-error: Undefined Behavior: attempting a write access using <untagged> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n   --> $DIR/shr_frozen_violation1.rs:LL:CC\n    |\n LL |         *(x as *const i32 as *mut i32) = 7;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         attempting a write access using <untagged> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n+   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n    |         this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/shr_frozen_violation1.rs:LL:CC\n    |\n LL |         *(x as *const i32 as *mut i32) = 7;"}, {"sha": "91c3ff9f8634a592a9c1c54187b3417cdc7a5df9", "filename": "tests/fail/stacked_borrows/transmute-is-no-escape.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Ftransmute-is-no-escape.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Ftransmute-is-no-escape.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Ftransmute-is-no-escape.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,15 +1,19 @@\n-error: Undefined Behavior: attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/transmute-is-no-escape.rs:LL:CC\n    |\n LL |     unsafe { *raw = 13 };\n    |              ^^^^^^^^^\n    |              |\n-   |              attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |              attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    |              this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-           \n+help: <TAG> was created by a retag at offsets [0x4..0x8]\n+  --> $DIR/transmute-is-no-escape.rs:LL:CC\n+   |\n+LL |     let raw = (&mut x[1] as *mut i32).wrapping_offset(-1);\n+   |                ^^^^^^^^^\n    = note: inside `main` at $DIR/transmute-is-no-escape.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "2f6605c058b2d4716baeccf49a5bba2bdc8f9bca", "filename": "tests/fail/stacked_borrows/unescaped_local.stderr", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Funescaped_local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Funescaped_local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Funescaped_local.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,27 +1,33 @@\n-error: Undefined Behavior: attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+warning: pointer-to-integer cast\n+  --> $DIR/unescaped_local.rs:LL:CC\n+   |\n+LL |     let raw = &mut x as *mut i32 as usize as *mut i32;\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/unescaped_local.rs:LL:CC\n+\n+error: Undefined Behavior: attempting a write access using <wildcard> at ALLOC[0x0], but no exposed tags have suitable permission in the borrow stack for this location\n   --> $DIR/unescaped_local.rs:LL:CC\n    |\n LL |         *raw = 13;\n    |         ^^^^^^^^^\n    |         |\n-   |         attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         attempting a write access using <wildcard> at ALLOC[0x0], but no exposed tags have suitable permission in the borrow stack for this location\n    |         this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n-  --> $DIR/unescaped_local.rs:LL:CC\n-   |\n-LL |     let raw = &mut x as *mut i32 as usize as *mut i32;\n-   |               ^^^^^^\n-help: tag was later invalidated at offsets [0x0..0x4]\n-  --> $DIR/unescaped_local.rs:LL:CC\n-   |\n-LL |     let _ptr = &mut x;\n-   |                ^^^^^^\n+           \n    = note: inside `main` at $DIR/unescaped_local.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "621e9617fdfcc68618e0f19f4de08234e76a33ec", "filename": "tests/fail/stacked_borrows/unescaped_static.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Funescaped_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fstacked_borrows%2Funescaped_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Funescaped_static.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,15 +1,19 @@\n-error: Undefined Behavior: attempting a read access using <untagged> at ALLOC[0x1], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x1], but that tag does not exist in the borrow stack for this location\n   --> $DIR/unescaped_static.rs:LL:CC\n    |\n LL |     let _val = unsafe { *ptr_to_first.add(1) };\n    |                         ^^^^^^^^^^^^^^^^^^^^\n    |                         |\n-   |                         attempting a read access using <untagged> at ALLOC[0x1], but that tag does not exist in the borrow stack for this location\n+   |                         attempting a read access using <TAG> at ALLOC[0x1], but that tag does not exist in the borrow stack for this location\n    |                         this error occurs as part of an access at ALLOC[0x1..0x2]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-           \n+help: <TAG> was created by a retag at offsets [0x0..0x1]\n+  --> $DIR/unescaped_static.rs:LL:CC\n+   |\n+LL |     let ptr_to_first = &ARRAY[0] as *const u8;\n+   |                        ^^^^^^^^^\n    = note: inside `main` at $DIR/unescaped_static.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "bd8d161de8327ccabbaed892eae7175198b1bf35", "filename": "tests/fail/unaligned_pointers/intptrcast_alignment_check.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Funaligned_pointers%2Fintptrcast_alignment_check.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Funaligned_pointers%2Fintptrcast_alignment_check.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Fintptrcast_alignment_check.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,18 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/intptrcast_alignment_check.rs:LL:CC\n+   |\n+LL |     let u16_ptr = base_addr_aligned as *mut u16;\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/intptrcast_alignment_check.rs:LL:CC\n+\n error: Undefined Behavior: accessing memory with alignment ALIGN, but alignment ALIGN is required\n   --> $DIR/intptrcast_alignment_check.rs:LL:CC\n    |\n@@ -11,5 +26,5 @@ LL |     unsafe { *u16_ptr = 2 };\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "683088e78bffb517c1533d780c1c78c76e38fde7", "filename": "tests/fail/uninit_byte_read.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Funinit_byte_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Funinit_byte_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funinit_byte_read.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-disable-stacked-borrows\n fn main() {\n     let v: Vec<u8> = Vec::with_capacity(10);\n     let undef = unsafe { *v.get_unchecked(5) }; //~ ERROR uninitialized"}, {"sha": "d75857900052e6f3087627c69c18214473114756", "filename": "tests/fail/validity/cast_fn_ptr1.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fvalidity%2Fcast_fn_ptr1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fvalidity%2Fcast_fn_ptr1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Fcast_fn_ptr1.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,18 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/cast_fn_ptr1.rs:LL:CC\n+   |\n+LL |     g(0usize as *const i32)\n+   |       ^^^^^^^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/cast_fn_ptr1.rs:LL:CC\n+\n error: Undefined Behavior: type validation failed: encountered a null reference\n   --> $DIR/cast_fn_ptr1.rs:LL:CC\n    |\n@@ -11,5 +26,5 @@ LL |     g(0usize as *const i32)\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "d47b39356ffcde3c9df313ffce8b8b4f8d69b0d1", "filename": "tests/fail/validity/cast_fn_ptr2.stderr", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fvalidity%2Fcast_fn_ptr2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Ffail%2Fvalidity%2Fcast_fn_ptr2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Fcast_fn_ptr2.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,23 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/cast_fn_ptr2.rs:LL:CC\n+   |\n+LL |         0usize as *const i32\n+   |         ^^^^^^^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main::f` at $DIR/cast_fn_ptr2.rs:LL:CC\n+note: inside `main` at $DIR/cast_fn_ptr2.rs:LL:CC\n+  --> $DIR/cast_fn_ptr2.rs:LL:CC\n+   |\n+LL |     let _x = g();\n+   |              ^^^\n+\n error: Undefined Behavior: type validation failed: encountered a null reference\n   --> $DIR/cast_fn_ptr2.rs:LL:CC\n    |\n@@ -11,5 +31,5 @@ LL |     let _x = g();\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-error: aborting due to previous error\n+error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "925430ae203093e52a105d4f85c8129b5388440b", "filename": "tests/pass/adjacent-allocs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fadjacent-allocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fadjacent-allocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fadjacent-allocs.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n fn main() {\n     // The slack between allocations is random.\n     // Loop a few times to hit the zero-slack case."}, {"sha": "9a15ec2cda6cd26113f881ba39a277a0761b993e", "filename": "tests/pass/align.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Falign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Falign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Falign.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -0,0 +1,20 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/align.rs:LL:CC\n+   |\n+LL |     let u16_ptr = base_addr_aligned as *mut u16;\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `manual_alignment` at $DIR/align.rs:LL:CC\n+note: inside `main` at $DIR/align.rs:LL:CC\n+  --> $DIR/align.rs:LL:CC\n+   |\n+LL |         manual_alignment();\n+   |         ^^^^^^^^^^^^^^^^^^\n+"}, {"sha": "7bbe7be516b9a5b9e593c429a1081e3808558909", "filename": "tests/pass/box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbox.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -47,7 +47,7 @@ fn boxed_pair_to_vec() {\n     struct Foo(u64);\n     fn reinterstruct(box_pair: Box<PairFoo>) -> Vec<Foo> {\n         let ref_pair = Box::leak(box_pair) as *mut PairFoo;\n-        let ptr_foo = unsafe { &mut (*ref_pair).fst as *mut Foo };\n+        let ptr_foo = unsafe { std::ptr::addr_of_mut!((*ref_pair).fst) };\n         unsafe { Vec::from_raw_parts(ptr_foo, 2, 2) }\n     }\n "}, {"sha": "eac98bf2d124f874da9cb7bf0a40b9902786e4ae", "filename": "tests/pass/box.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fbox.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fbox.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbox.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -0,0 +1,20 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/box.rs:LL:CC\n+   |\n+LL |         let r2 = ((r as usize) + 0) as *mut i32;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `into_raw` at $DIR/box.rs:LL:CC\n+note: inside `main` at $DIR/box.rs:LL:CC\n+  --> $DIR/box.rs:LL:CC\n+   |\n+LL |     into_raw();\n+   |     ^^^^^^^^^^\n+"}, {"sha": "29c57bf49a3384af4266dc1208ccc33ec8f09608", "filename": "tests/pass/concurrency/tls_pthread_drop_order.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fconcurrency%2Ftls_pthread_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fconcurrency%2Ftls_pthread_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_pthread_drop_order.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -4,14 +4,15 @@\n extern crate libc;\n \n use std::mem;\n+use std::ptr;\n \n pub type Key = libc::pthread_key_t;\n \n static mut RECORD: usize = 0;\n static mut KEYS: [Key; 2] = [0; 2];\n static mut GLOBALS: [u64; 2] = [1, 0];\n \n-static mut CANNARY: *mut u64 = 0 as *mut _; // this serves as a cannary: if TLS dtors are not run properly, this will not get deallocated, making the test fail.\n+static mut CANNARY: *mut u64 = ptr::null_mut(); // this serves as a cannary: if TLS dtors are not run properly, this will not get deallocated, making the test fail.\n \n pub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     let mut key = 0;\n@@ -30,7 +31,7 @@ pub fn record(r: usize) {\n }\n \n unsafe extern \"C\" fn dtor(ptr: *mut u64) {\n-    assert!(CANNARY != 0 as *mut _); // make sure we do not get run too often\n+    assert!(CANNARY != ptr::null_mut()); // make sure we do not get run too often\n     let val = *ptr;\n \n     let which_key =\n@@ -48,7 +49,7 @@ unsafe extern \"C\" fn dtor(ptr: *mut u64) {\n     // The correct sequence is: First key 0, then key 1, then key 0.\n     if RECORD == 0_1_0 {\n         drop(Box::from_raw(CANNARY));\n-        CANNARY = 0 as *mut _;\n+        CANNARY = ptr::null_mut();\n     }\n }\n "}, {"sha": "730a4304253560ad1d98e7a061a50385dfbdaedb", "filename": "tests/pass/extern_types.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fextern_types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fextern_types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fextern_types.stderr?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -0,0 +1,15 @@\n+warning: pointer-to-integer cast\n+  --> $DIR/extern_types.rs:LL:CC\n+   |\n+LL |     let x: &Foo = unsafe { &*(16 as *const Foo) };\n+   |                              ^^^^^^^^^^^^^^^^^^ pointer-to-integer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/extern_types.rs:LL:CC\n+"}, {"sha": "a5e1d196529ef7e9b4c2e8cdc9726314661f2a7b", "filename": "tests/pass/intptrcast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fintptrcast.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n // This strips provenance\n fn transmute_ptr_to_int<T>(x: *const T) -> usize {\n     unsafe { std::mem::transmute(x) }"}, {"sha": "0042872a3b45b9e6e04928654ccabe10164cb497", "filename": "tests/pass/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fintrinsics.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-permissive-provenance\n #![feature(core_intrinsics, const_raw_ptr_comparison)]\n #![feature(layout_for_ptr)]\n "}, {"sha": "56a53699477e816022ea27b2d41dc7085f153f76", "filename": "tests/pass/linux-getrandom-without-isolation.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Flinux-getrandom-without-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Flinux-getrandom-without-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flinux-getrandom-without-isolation.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -3,13 +3,15 @@\n #![feature(rustc_private)]\n extern crate libc;\n \n+use std::ptr;\n+\n fn main() {\n     let mut buf = [0u8; 5];\n     unsafe {\n         assert_eq!(\n             libc::syscall(\n                 libc::SYS_getrandom,\n-                0 as *mut libc::c_void,\n+                ptr::null_mut::<libc::c_void>(),\n                 0 as libc::size_t,\n                 0 as libc::c_uint,\n             ),\n@@ -26,7 +28,7 @@ fn main() {\n         );\n \n         assert_eq!(\n-            libc::getrandom(0 as *mut libc::c_void, 0 as libc::size_t, 0 as libc::c_uint),\n+            libc::getrandom(ptr::null_mut::<libc::c_void>(), 0 as libc::size_t, 0 as libc::c_uint),\n             0,\n         );\n         assert_eq!("}, {"sha": "a3596e4c7a9c02c1de452d73aca6ba9775b37081", "filename": "tests/pass/linux-getrandom.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Flinux-getrandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Flinux-getrandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flinux-getrandom.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -2,13 +2,15 @@\n #![feature(rustc_private)]\n extern crate libc;\n \n+use std::ptr;\n+\n fn main() {\n     let mut buf = [0u8; 5];\n     unsafe {\n         assert_eq!(\n             libc::syscall(\n                 libc::SYS_getrandom,\n-                0 as *mut libc::c_void,\n+                ptr::null_mut::<libc::c_void>(),\n                 0 as libc::size_t,\n                 0 as libc::c_uint,\n             ),\n@@ -25,7 +27,7 @@ fn main() {\n         );\n \n         assert_eq!(\n-            libc::getrandom(0 as *mut libc::c_void, 0 as libc::size_t, 0 as libc::c_uint),\n+            libc::getrandom(ptr::null_mut::<libc::c_void>(), 0 as libc::size_t, 0 as libc::c_uint),\n             0,\n         );\n         assert_eq!("}, {"sha": "3979fb3b071465e59ec5c9f3f3e98c0a3c32fd46", "filename": "tests/pass/panic/catch_panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fpanic%2Fcatch_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fpanic%2Fcatch_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fpanic%2Fcatch_panic.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,5 +1,5 @@\n // We test the `align_offset` panic below, make sure we test the interpreter impl and not the \"real\" one.\n-// compile-flags: -Zmiri-symbolic-alignment-check\n+// compile-flags: -Zmiri-symbolic-alignment-check -Zmiri-permissive-provenance\n #![feature(never_type)]\n #![allow(unconditional_panic, non_fmt_panics)]\n "}, {"sha": "ffe6a114c66b367f8cc61b1020c40c2265c7ec67", "filename": "tests/pass/ptr_int_casts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fptr_int_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fptr_int_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fptr_int_casts.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-permissive-provenance\n use std::mem;\n use std::ptr;\n "}, {"sha": "b16a06a7260b3e45ebf09c1ee0dd3ff5ea2332e7", "filename": "tests/pass/ptr_offset.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fptr_offset.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-permissive-provenance\n use std::{mem, ptr};\n \n fn main() {"}, {"sha": "eb543d691e10be09d8abe09c0bebb6186ca44177", "filename": "tests/pass/stacked-borrows/2phase.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fstacked-borrows%2F2phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fstacked-borrows%2F2phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2F2phase.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,5 +1,3 @@\n-// compile-flags: -Zmiri-tag-raw-pointers\n-\n trait S: Sized {\n     fn tpb(&mut self, _s: Self) {}\n }"}, {"sha": "79958ab5539d4340cd877f7b18ad5be3e0b4675a", "filename": "tests/pass/stacked-borrows/interior_mutability.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags: -Zmiri-tag-raw-pointers\n use std::cell::{Cell, RefCell, UnsafeCell};\n use std::mem::{self, MaybeUninit};\n "}, {"sha": "eb0ff167eb123a07bdee9a8332f659094522d015", "filename": "tests/pass/stacked-borrows/stacked-borrows.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags: -Zmiri-tag-raw-pointers\n use std::ptr;\n \n // Test various stacked-borrows-related things."}, {"sha": "fade1e0dad88feffaae23abd57b72505d0da4b16", "filename": "tests/pass/zst.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d425daebe539b1a48731faecf1d1ba5287aa72/tests%2Fpass%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fzst.rs?ref=13d425daebe539b1a48731faecf1d1ba5287aa72", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-permissive-provenance\n #[derive(PartialEq, Debug)]\n struct A;\n "}]}