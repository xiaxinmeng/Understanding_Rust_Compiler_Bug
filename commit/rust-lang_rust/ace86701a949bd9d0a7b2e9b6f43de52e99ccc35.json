{"sha": "ace86701a949bd9d0a7b2e9b6f43de52e99ccc35", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZTg2NzAxYTk0OWJkOWQwYTdiMmU5YjZmNDNkZTUyZTk5Y2NjMzU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-06-30T15:25:06Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-07-04T11:08:09Z"}, "message": "Clean-up check_impl_items_against_trait", "tree": {"sha": "788b904953a31d38d25a65648ea66c30bc52c47f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/788b904953a31d38d25a65648ea66c30bc52c47f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ace86701a949bd9d0a7b2e9b6f43de52e99ccc35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ace86701a949bd9d0a7b2e9b6f43de52e99ccc35", "html_url": "https://github.com/rust-lang/rust/commit/ace86701a949bd9d0a7b2e9b6f43de52e99ccc35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ace86701a949bd9d0a7b2e9b6f43de52e99ccc35/comments", "author": null, "committer": null, "parents": [{"sha": "0dc08240ea755679e3daec3832a04b22a8fc90bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dc08240ea755679e3daec3832a04b22a8fc90bf", "html_url": "https://github.com/rust-lang/rust/commit/0dc08240ea755679e3daec3832a04b22a8fc90bf"}], "stats": {"total": 163, "additions": 57, "deletions": 106}, "files": [{"sha": "044ce87951b023d99ab854101fa10ecbe67cc89f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 57, "deletions": 106, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/ace86701a949bd9d0a7b2e9b6f43de52e99ccc35/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ace86701a949bd9d0a7b2e9b6f43de52e99ccc35/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ace86701a949bd9d0a7b2e9b6f43de52e99ccc35", "patch": "@@ -850,124 +850,75 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n+        let ty_impl_item = ccx.tcx.impl_or_trait_item(local_def(impl_item.id));\n+        let ty_trait_item = trait_items.iter()\n+            .find(|ac| ac.name() == ty_impl_item.name())\n+            .unwrap_or_else(|| {\n+                // This is checked by resolve\n+                tcx.sess.span_bug(impl_item.span,\n+                                  &format!(\"impl-item `{}` is not a member of `{:?}`\",\n+                                           token::get_name(ty_impl_item.name()),\n+                                           impl_trait_ref));\n+            });\n         match impl_item.node {\n             ast::ConstImplItem(..) => {\n-                let impl_const_def_id = local_def(impl_item.id);\n-                let impl_const_ty = ccx.tcx.impl_or_trait_item(impl_const_def_id);\n+                let impl_const = match ty_impl_item {\n+                    ty::ConstTraitItem(ref cti) => cti,\n+                    _ => tcx.sess.span_bug(impl_item.span, \"non-const impl-item for const\")\n+                };\n \n                 // Find associated const definition.\n-                let opt_associated_const =\n-                    trait_items.iter()\n-                               .find(|ac| ac.name() == impl_const_ty.name());\n-                match opt_associated_const {\n-                    Some(associated_const) => {\n-                        match (associated_const, &impl_const_ty) {\n-                            (&ty::ConstTraitItem(ref const_trait),\n-                             &ty::ConstTraitItem(ref const_impl)) => {\n-                                compare_const_impl(ccx.tcx,\n-                                                   &const_impl,\n-                                                   impl_item.span,\n-                                                   &const_trait,\n-                                                   &*impl_trait_ref);\n-                            }\n-                            _ => {\n-                                span_err!(tcx.sess, impl_item.span, E0323,\n-                                          \"item `{}` is an associated const, \\\n-                                          which doesn't match its trait `{:?}`\",\n-                                          token::get_name(impl_const_ty.name()),\n-                                          impl_trait_ref)\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        // This is `span_bug` as it should have already been\n-                        // caught in resolve.\n-                        tcx.sess.span_bug(\n-                            impl_item.span,\n-                            &format!(\n-                                \"associated const `{}` is not a member of \\\n-                                 trait `{:?}`\",\n-                                token::get_name(impl_const_ty.name()),\n-                                impl_trait_ref));\n-                    }\n+                if let &ty::ConstTraitItem(ref trait_const) = ty_trait_item {\n+                    compare_const_impl(ccx.tcx,\n+                                       &impl_const,\n+                                       impl_item.span,\n+                                       trait_const,\n+                                       &*impl_trait_ref);\n+                } else {\n+                    span_err!(tcx.sess, impl_item.span, E0323,\n+                              \"item `{}` is an associated const, \\\n+                              which doesn't match its trait `{:?}`\",\n+                              token::get_name(impl_const.name),\n+                              impl_trait_ref)\n                 }\n             }\n             ast::MethodImplItem(ref sig, ref body) => {\n                 check_trait_fn_not_const(ccx, impl_item.span, sig.constness);\n \n-                let impl_method_def_id = local_def(impl_item.id);\n-                let impl_item_ty = ccx.tcx.impl_or_trait_item(impl_method_def_id);\n-\n-                // If this is an impl of a trait method, find the\n-                // corresponding method definition in the trait.\n-                let opt_trait_method_ty =\n-                    trait_items.iter()\n-                               .find(|ti| ti.name() == impl_item_ty.name());\n-                match opt_trait_method_ty {\n-                    Some(trait_method_ty) => {\n-                        match (trait_method_ty, &impl_item_ty) {\n-                            (&ty::MethodTraitItem(ref trait_method_ty),\n-                             &ty::MethodTraitItem(ref impl_method_ty)) => {\n-                                compare_impl_method(ccx.tcx,\n-                                                    &**impl_method_ty,\n-                                                    impl_item.span,\n-                                                    body.id,\n-                                                    &**trait_method_ty,\n-                                                    &*impl_trait_ref);\n-                            }\n-                            _ => {\n-                                span_err!(tcx.sess, impl_item.span, E0324,\n-                                          \"item `{}` is an associated method, \\\n-                                          which doesn't match its trait `{:?}`\",\n-                                          token::get_name(impl_item_ty.name()),\n-                                          impl_trait_ref)\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        // This is span_bug as it should have already been\n-                        // caught in resolve.\n-                        tcx.sess.span_bug(\n-                            impl_item.span,\n-                            &format!(\"method `{}` is not a member of trait `{:?}`\",\n-                                     token::get_name(impl_item_ty.name()),\n-                                     impl_trait_ref));\n-                    }\n+                let impl_method = match ty_impl_item {\n+                    ty::MethodTraitItem(ref mti) => mti,\n+                    _ => tcx.sess.span_bug(impl_item.span, \"non-method impl-item for method\")\n+                };\n+\n+                if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n+                    compare_impl_method(ccx.tcx,\n+                                        &impl_method,\n+                                        impl_item.span,\n+                                        body.id,\n+                                        &trait_method,\n+                                        &impl_trait_ref);\n+                } else {\n+                    span_err!(tcx.sess, impl_item.span, E0324,\n+                              \"item `{}` is an associated method, \\\n+                              which doesn't match its trait `{:?}`\",\n+                              token::get_name(impl_method.name),\n+                              impl_trait_ref)\n                 }\n             }\n             ast::TypeImplItem(_) => {\n-                let typedef_def_id = local_def(impl_item.id);\n-                let typedef_ty = ccx.tcx.impl_or_trait_item(typedef_def_id);\n-\n-                // If this is an impl of an associated type, find the\n-                // corresponding type definition in the trait.\n-                let opt_associated_type =\n-                    trait_items.iter()\n-                               .find(|ti| ti.name() == typedef_ty.name());\n-                match opt_associated_type {\n-                    Some(associated_type) => {\n-                        match (associated_type, &typedef_ty) {\n-                            (&ty::TypeTraitItem(_), &ty::TypeTraitItem(_)) => {}\n-                            _ => {\n-                                span_err!(tcx.sess, impl_item.span, E0325,\n-                                          \"item `{}` is an associated type, \\\n-                                          which doesn't match its trait `{:?}`\",\n-                                          token::get_name(typedef_ty.name()),\n-                                          impl_trait_ref)\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        // This is `span_bug` as it should have already been\n-                        // caught in resolve.\n-                        tcx.sess.span_bug(\n-                            impl_item.span,\n-                            &format!(\n-                                \"associated type `{}` is not a member of \\\n-                                 trait `{:?}`\",\n-                                token::get_name(typedef_ty.name()),\n-                                impl_trait_ref));\n-                    }\n+                let impl_type = match ty_impl_item {\n+                    ty::TypeTraitItem(ref tti) => tti,\n+                    _ => tcx.sess.span_bug(impl_item.span, \"non-type impl-item for type\")\n+                };\n+\n+                if let &ty::TypeTraitItem(..) = ty_trait_item {\n+                    // ...\n+                } else {\n+                    span_err!(tcx.sess, impl_item.span, E0325,\n+                              \"item `{}` is an associated type, \\\n+                              which doesn't match its trait `{:?}`\",\n+                              token::get_name(impl_type.name),\n+                              impl_trait_ref)\n                 }\n             }\n             ast::MacImplItem(_) => tcx.sess.span_bug(impl_item.span,"}]}