{"sha": "a9d7642b5da8730039b7abad7750ac47cb965198", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZDc2NDJiNWRhODczMDAzOWI3YWJhZDc3NTBhYzQ3Y2I5NjUxOTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-25T18:24:02Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-25T21:01:49Z"}, "message": "Merge remote-tracking branch '14427/incoming'\n\nConflicts:\n\tsrc/libstd/sort.rs", "tree": {"sha": "bf2bc6a0a8378a4e0d10a70f92aa507865f1e7ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf2bc6a0a8378a4e0d10a70f92aa507865f1e7ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9d7642b5da8730039b7abad7750ac47cb965198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9d7642b5da8730039b7abad7750ac47cb965198", "html_url": "https://github.com/rust-lang/rust/commit/a9d7642b5da8730039b7abad7750ac47cb965198", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9d7642b5da8730039b7abad7750ac47cb965198/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5", "html_url": "https://github.com/rust-lang/rust/commit/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5"}, {"sha": "d4432a797450594ff78457fe3e516bb0aeaedfe0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4432a797450594ff78457fe3e516bb0aeaedfe0", "html_url": "https://github.com/rust-lang/rust/commit/d4432a797450594ff78457fe3e516bb0aeaedfe0"}], "stats": {"total": 895, "additions": 861, "deletions": 34}, "files": [{"sha": "6f4e54080ca75f2f3f1c4831f8e0abe3df5f8c03", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=a9d7642b5da8730039b7abad7750ac47cb965198", "patch": "@@ -1491,7 +1491,7 @@ fn print_pkg(s: @Source, p: &Package) {\n fn print_source(s: @Source) {\n     info(s.name + ~\" (\" + s.url + ~\")\");\n \n-    let pks = sort::merge_sort(sys::shape_lt, s.packages.get());\n+    let pks = sort::merge_sort(s.packages.get(), sys::shape_lt);\n     let l = vec::len(pks);\n \n     print(io::with_str_writer(|writer| {"}, {"sha": "514a47335e2efac3be0839c10bd7807be13ff3c9", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 851, "deletions": 24, "changes": 875, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=a9d7642b5da8730039b7abad7750ac47cb965198", "patch": "@@ -3,6 +3,7 @@\n \n use vec::{len, push};\n use core::cmp::{Eq, Ord};\n+use dvec::DVec;\n \n type Le<T> = pure fn(v1: &T, v2: &T) -> bool;\n \n@@ -12,12 +13,12 @@ type Le<T> = pure fn(v1: &T, v2: &T) -> bool;\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-pub fn merge_sort<T: Copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n+pub fn merge_sort<T: Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n-    return merge_sort_(le, v, (0, len(v)));\n+    return merge_sort_(v, (0u, len(v)), le);\n \n-    fn merge_sort_<T: Copy>(le: Le<T>, v: &[const T], slice: Slice)\n+    fn merge_sort_<T: Copy>(v: &[const T], slice: Slice, le: Le<T>)\n         -> ~[T] {\n         let begin = slice.first();\n         let end = slice.second();\n@@ -29,7 +30,7 @@ pub fn merge_sort<T: Copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n         let mid = v_len / 2 + begin;\n         let a = (begin, mid);\n         let b = (mid, end);\n-        return merge(le, merge_sort_(le, v, a), merge_sort_(le, v, b));\n+        return merge(le, merge_sort_(v, a, le), merge_sort_(v, b, le));\n     }\n \n     fn merge<T: Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n@@ -50,8 +51,8 @@ pub fn merge_sort<T: Copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n     }\n }\n \n-fn part<T: Copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n-                right: uint, pivot: uint) -> uint {\n+fn part<T: Copy>(arr: &[mut T], left: uint,\n+                right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n     let pivot_value = arr[pivot];\n     arr[pivot] <-> arr[right];\n     let mut storage_index: uint = left;\n@@ -67,16 +68,16 @@ fn part<T: Copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n     return storage_index;\n }\n \n-fn qsort<T: Copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n-             right: uint) {\n+fn qsort<T: Copy>(arr: &[mut T], left: uint,\n+             right: uint, compare_func: Le<T>) {\n     if right > left {\n-        let pivot = (left + right) / 2;\n-        let new_pivot = part::<T>(compare_func, arr, left, right, pivot);\n-        if new_pivot != 0 {\n+        let pivot = (left + right) / 2u;\n+        let new_pivot = part::<T>(arr, left, right, pivot, compare_func);\n+        if new_pivot != 0u {\n             // Need to do this check before recursing due to overflow\n-            qsort::<T>(compare_func, arr, left, new_pivot - 1);\n+            qsort::<T>(arr, left, new_pivot - 1u, compare_func);\n         }\n-        qsort::<T>(compare_func, arr, new_pivot + 1, right);\n+        qsort::<T>(arr, new_pivot + 1u, right, compare_func);\n     }\n }\n \n@@ -86,9 +87,9 @@ fn qsort<T: Copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n  * Has worst case O(n^2) performance, average case O(n log n).\n  * This is an unstable sort.\n  */\n-pub fn quick_sort<T: Copy>(compare_func: Le<T>, arr: &[mut T]) {\n-    if len::<T>(arr) == 0 { return; }\n-    qsort::<T>(compare_func, arr, 0, len::<T>(arr) - 1);\n+pub fn quick_sort<T: Copy>(arr: &[mut T], compare_func: Le<T>) {\n+    if len::<T>(arr) == 0u { return; }\n+    qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n }\n \n fn qsort3<T: Copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n@@ -161,6 +162,543 @@ impl<T: Copy Ord Eq> &[mut T] : Sort {\n     fn qsort(self) { quick_sort3(self); }\n }\n \n+const MIN_MERGE: uint = 64;\n+const MIN_GALLOP: uint = 7;\n+const INITIAL_TMP_STORAGE: uint = 128;\n+\n+pub fn tim_sort<T: Copy Ord>(array: &[mut T]) {\n+    let size = array.len();\n+    if size < 2 {\n+        return;\n+    }\n+\n+    if size < MIN_MERGE {\n+        let init_run_len = count_run_ascending(array);\n+        binarysort(array, init_run_len);\n+        return;\n+    }\n+\n+    let ms = &MergeState();\n+    let min_run = min_run_length(size);\n+\n+    let mut idx = 0;\n+    let mut remaining = size;\n+    loop {\n+        let arr = vec::mut_view(array, idx, size);\n+        let mut run_len: uint = count_run_ascending(arr);\n+\n+        if run_len < min_run {\n+            let force = if remaining <= min_run {remaining} else {min_run};\n+            let slice = vec::mut_view(arr, 0, force);\n+            binarysort(slice, run_len);\n+            run_len = force;\n+        }\n+\n+        ms.push_run(idx, run_len);\n+        ms.merge_collapse(array);\n+\n+        idx += run_len;\n+        remaining -= run_len;\n+        if remaining == 0 { break; }\n+    }\n+\n+    ms.merge_force_collapse(array);\n+}\n+\n+fn binarysort<T: Copy Ord>(array: &[mut T], start: uint) {\n+    let size = array.len();\n+    let mut start = start;\n+    assert start <= size;\n+\n+    if start == 0 { start += 1; }\n+\n+    while start < size {\n+        let pivot = array[start];\n+        let mut left = 0;\n+        let mut right = start;\n+        assert left <= right;\n+\n+        while left < right {\n+            let mid = (left + right) >> 1;\n+            if pivot < array[mid] {\n+                right = mid;\n+            } else {\n+                left = mid+1;\n+            }\n+        }\n+        assert left == right;\n+        let mut n = start-left;\n+\n+        copy_vec(array, left+1, array, left, n);\n+        array[left] = move pivot;\n+        start += 1;\n+    }\n+}\n+\n+// Reverse the order of elements in a slice, in place\n+fn reverse_slice<T>(v: &[mut T], start: uint, end:uint) {\n+    let mut i = start;\n+    while i < end / 2 {\n+        util::swap(&mut v[i], &mut v[end - i - 1]);\n+        i += 1;\n+    }\n+}\n+\n+pure fn min_run_length(n: uint) -> uint {\n+    let mut n = n;\n+    let mut r = 0;   // becomes 1 if any 1 bits are shifted off\n+\n+    while n >= MIN_MERGE {\n+        r |= n & 1;\n+        n >>= 1;\n+    }\n+    return n + r;\n+}\n+\n+fn count_run_ascending<T: Copy Ord>(array: &[mut T]) -> uint {\n+    let size = array.len();\n+    assert size > 0;\n+    if size == 1 { return 1; }\n+\n+    let mut run = 2;\n+    if array[1] < array[0] {\n+        while run < size && array[run] < array[run-1] {\n+            run += 1;\n+        }\n+        reverse_slice(array, 0, run);\n+    } else {\n+        while run < size && array[run] >= array[run-1] {\n+            run += 1;\n+        }\n+    }\n+\n+    return run;\n+}\n+\n+pure fn gallop_left<T: Copy Ord>(key: &const T, array: &[const T],\n+                            hint: uint) -> uint {\n+    let size = array.len();\n+    assert size != 0 && hint < size;\n+\n+    let mut last_ofs = 0;\n+    let mut ofs = 1;\n+\n+    if *key > array[hint] {\n+        // Gallop right until array[hint+last_ofs] < key <= array[hint+ofs]\n+        let max_ofs = size - hint;\n+        while ofs < max_ofs && *key > array[hint+ofs] {\n+            last_ofs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n+        }\n+        if ofs > max_ofs { ofs = max_ofs; }\n+\n+        last_ofs += hint;\n+        ofs += hint;\n+    } else {\n+        let max_ofs = hint + 1;\n+        while ofs < max_ofs && *key <= array[hint-ofs] {\n+            last_ofs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n+        }\n+\n+        if ofs > max_ofs { ofs = max_ofs; }\n+\n+        let tmp = last_ofs;\n+        last_ofs = hint - ofs;\n+        ofs = hint - tmp;\n+    }\n+    assert (last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size;\n+\n+    last_ofs += 1;\n+    while last_ofs < ofs {\n+        let m = last_ofs + ((ofs - last_ofs) >> 1);\n+        if *key > array[m] {\n+            last_ofs = m+1;\n+        } else {\n+            ofs = m;\n+        }\n+    }\n+    assert last_ofs == ofs;\n+    return ofs;\n+}\n+\n+pure fn gallop_right<T: Copy Ord>(key: &const T, array: &[const T],\n+                            hint: uint) -> uint {\n+    let size = array.len();\n+    assert size != 0 && hint < size;\n+\n+    let mut last_ofs = 0;\n+    let mut ofs = 1;\n+\n+    if *key >= array[hint] {\n+        // Gallop right until array[hint+last_ofs] <= key < array[hint+ofs]\n+        let max_ofs = size - hint;\n+        while ofs < max_ofs && *key >= array[hint+ofs] {\n+            last_ofs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < last_ofs { ofs = max_ofs; }\n+        }\n+        if ofs > max_ofs { ofs = max_ofs; }\n+\n+        last_ofs += hint;\n+        ofs += hint;\n+    } else {\n+        // Gallop left until array[hint-ofs] <= key < array[hint-last_ofs]\n+        let max_ofs = hint + 1;\n+        while ofs < max_ofs && *key < array[hint-ofs] {\n+            last_ofs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < last_ofs { ofs = max_ofs; }\n+        }\n+        if ofs > max_ofs { ofs = max_ofs; }\n+\n+        let tmp = last_ofs;\n+        last_ofs = hint - ofs;\n+        ofs = hint - tmp;\n+    }\n+\n+    assert (last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size;\n+\n+    last_ofs += 1;\n+    while last_ofs < ofs {\n+        let m = last_ofs + ((ofs - last_ofs) >> 1);\n+\n+        if *key >= array[m] {\n+            last_ofs = m + 1;\n+        } else {\n+            ofs = m;\n+        }\n+    }\n+    assert last_ofs == ofs;\n+    return ofs;\n+}\n+\n+struct RunState {\n+    base: uint,\n+    len: uint,\n+}\n+\n+struct MergeState<T> {\n+    mut min_gallop: uint,\n+    runs: DVec<RunState>,\n+}\n+\n+// Fixme (#3853) Move into MergeState\n+fn MergeState<T>() -> MergeState<T> {\n+    MergeState {\n+        min_gallop: MIN_GALLOP,\n+        runs: DVec(),\n+    }\n+}\n+\n+impl<T: Copy Ord> MergeState<T> {\n+    fn push_run(&self, run_base: uint, run_len: uint) {\n+        let tmp = RunState{base: run_base, len: run_len};\n+        self.runs.push(tmp);\n+    }\n+\n+    fn merge_at(&self, n: uint, array: &[mut T]) {\n+        let mut size = self.runs.len();\n+        assert size >= 2;\n+        assert n == size-2 || n == size-3;\n+\n+        do self.runs.borrow_mut |arr| {\n+\n+            let mut b1 = arr[n].base;\n+            let mut l1 = arr[n].len;\n+            let b2 = arr[n+1].base;\n+            let l2 = arr[n+1].len;\n+\n+            assert l1 > 0 && l2 > 0;\n+            assert b1 + l1 == b2;\n+\n+            arr[n].len = l1 + l2;\n+            if n == size-3 {\n+                arr[n+1].base = arr[n+2].base;\n+                arr[n+1].len = arr[n+2].len;\n+            }\n+\n+            let slice = vec::mut_view(array, b1, b1+l1);\n+            let k = gallop_right(&const array[b2], slice, 0);\n+            b1 += k;\n+            l1 -= k;\n+            if l1 != 0 {\n+                let slice = vec::mut_view(array, b2, b2+l2);\n+                let l2 = gallop_left(\n+                    &const array[b1+l1-1],slice,l2-1);\n+                if l2 > 0 {\n+                    if l1 <= l2 {\n+                        self.merge_lo(array, b1, l1, b2, l2);\n+                    } else {\n+                        self.merge_hi(array, b1, l1, b2, l2);\n+                    }\n+                }\n+            }\n+        }\n+        self.runs.pop();\n+    }\n+\n+    fn merge_lo(&self, array: &[mut T], base1: uint, len1: uint,\n+                base2: uint, len2: uint) {\n+        assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n+\n+        let tmp = vec::to_mut(vec::slice(array, base1, base1+len1));\n+\n+        let mut c1 = 0;\n+        let mut c2 = base2;\n+        let mut dest = base1;\n+        let mut len1 = len1;\n+        let mut len2 = len2;\n+\n+        array[dest] <-> array[c2];\n+        dest += 1; c2 += 1; len2 -= 1;\n+\n+        if len2 == 0 {\n+            copy_vec(array, dest, tmp, 0, len1);\n+            return;\n+        }\n+        if len1 == 1 {\n+            copy_vec(array, dest, array, c2, len2);\n+            array[dest+len2] <-> tmp[c1];\n+            return;\n+        }\n+\n+        let mut min_gallop = self.min_gallop;\n+        loop {\n+            let mut count1 = 0;\n+            let mut count2 = 0;\n+            let mut break_outer = false;\n+\n+            loop {\n+                assert len1 > 1 && len2 != 0;\n+                if array[c2] < tmp[c1] {\n+                    array[dest] <-> array[c2];\n+                    dest += 1; c2 += 1; len2 -= 1;\n+                    count2 += 1; count1 = 0;\n+                    if len2 == 0 {\n+                        break_outer = true;\n+                    }\n+                } else {\n+                    array[dest] <-> tmp[c1];\n+                    dest += 1; c1 += 1; len1 -= 1;\n+                    count1 += 1; count2 = 0;\n+                    if len1 == 1 {\n+                        break_outer = true;\n+                    }\n+                }\n+                if break_outer || ((count1 | count2) >= min_gallop) {\n+                    break;\n+                }\n+            }\n+            if break_outer { break; }\n+\n+            // Start to gallop\n+            loop {\n+                assert len1 > 1 && len2 != 0;\n+\n+                let tmp_view = vec::const_view(tmp, c1, c1+len1);\n+                count1 = gallop_right(&const array[c2], tmp_view, 0);\n+                if count1 != 0 {\n+                    copy_vec(array, dest, tmp, c1, count1);\n+                    dest += count1; c1 += count1; len1 -= count1;\n+                    if len1 <= 1 { break_outer = true; break; }\n+                }\n+                array[dest] <-> array[c2];\n+                dest += 1; c2 += 1; len2 -= 1;\n+                if len2 == 0 { break_outer = true; break; }\n+\n+                let tmp_view = vec::const_view(array, c2, c2+len2);\n+                count2 = gallop_left(&const tmp[c1], tmp_view, 0);\n+                if count2 != 0 {\n+                    copy_vec(array, dest, array, c2, count2);\n+                    dest += count2; c2 += count2; len2 -= count2;\n+                    if len2 == 0 { break_outer = true; break; }\n+                }\n+                array[dest] <-> tmp[c1];\n+                dest += 1; c1 += 1; len1 -= 1;\n+                if len1 == 1 { break_outer = true; break; }\n+                min_gallop -= 1;\n+                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n+                    break;\n+                }\n+            }\n+            if break_outer { break; }\n+            if min_gallop < 0 { min_gallop = 0; }\n+            min_gallop += 2; // Penalize for leaving gallop\n+        }\n+        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n+\n+        if len1 == 1 {\n+            assert len2 > 0;\n+            copy_vec(array, dest, array, c2, len2);\n+            array[dest+len2] <-> tmp[c1];\n+        } else if len1 == 0 {\n+            fail ~\"Comparison violates its contract!\";\n+        } else {\n+            assert len2 == 0;\n+            assert len1 > 1;\n+            copy_vec(array, dest, tmp, c1, len1);\n+        }\n+    }\n+\n+    fn merge_hi(&self, array: &[mut T], base1: uint, len1: uint,\n+                base2: uint, len2: uint) {\n+        assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n+\n+        let tmp = vec::to_mut(vec::slice(array, base2, base2+len2));\n+\n+        let mut c1 = base1 + len1 - 1;\n+        let mut c2 = len2 - 1;\n+        let mut dest = base2 + len2 - 1;\n+        let mut len1 = len1;\n+        let mut len2 = len2;\n+\n+        array[dest] <-> array[c1];\n+        dest -= 1; c1 -= 1; len1 -= 1;\n+\n+        if len1 == 0 {\n+            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n+            return;\n+        }\n+        if len2 == 1 {\n+            dest -= len1;\n+            c1 -= len1;\n+            copy_vec(array, dest+1, array, c1+1, len1);\n+            array[dest] <-> tmp[c2];\n+            return;\n+        }\n+\n+        let mut min_gallop = self.min_gallop;\n+        loop {\n+            let mut count1 = 0;\n+            let mut count2 = 0;\n+            let mut break_outer = false;\n+\n+            loop {\n+                assert len1 != 0 && len2 > 1;\n+                if tmp[c2] < array[c1] {\n+                    array[dest] <-> array[c1];\n+                    dest -= 1; c1 -= 1; len1 -= 1;\n+                    count1 += 1; count2 = 0;\n+                    if len1 == 0 {\n+                        break_outer = true;\n+                    }\n+                } else {\n+                    array[dest] <-> tmp[c2];\n+                    dest -= 1; c2 -= 1; len2 -= 1;\n+                    count2 += 1; count1 = 0;\n+                    if len2 == 1 {\n+                        break_outer = true;\n+                    }\n+                }\n+                if break_outer || ((count1 | count2) >= min_gallop) {\n+                    break;\n+                }\n+            }\n+            if break_outer { break; }\n+\n+            // Start to gallop\n+            loop {\n+                assert len2 > 1 && len1 != 0;\n+\n+                let tmp_view = vec::mut_view(array, base1, base1+len1);\n+                count1 = len1 - gallop_right(\n+                    &const tmp[c2], tmp_view, len1-1);\n+\n+                if count1 != 0 {\n+                    dest -= count1; c1 -= count1; len1 -= count1;\n+                    copy_vec(array, dest+1, array, c1+1, count1);\n+                    if len1 == 0 { break_outer = true; break; }\n+                }\n+\n+                array[dest] <-> tmp[c2];\n+                dest -= 1; c2 -= 1; len2 -= 1;\n+                if len2 == 1 { break_outer = true; break; }\n+\n+                let tmp_view = vec::mut_view(tmp, 0, len2);\n+                let count2 = len2 - gallop_left(&const array[c1],\n+                                                tmp_view, len2-1);\n+                if count2 != 0 {\n+                    dest -= count2; c2 -= count2; len2 -= count2;\n+                    copy_vec(array, dest+1, tmp, c2+1, count2);\n+                    if len2 <= 1 { break_outer = true; break; }\n+                }\n+                array[dest] <-> array[c1];\n+                dest -= 1; c1 -= 1; len1 -= 1;\n+                if len1 == 0 { break_outer = true; break; }\n+                min_gallop -= 1;\n+                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n+                    break;\n+                }\n+            }\n+\n+            if break_outer { break; }\n+            if min_gallop < 0 { min_gallop = 0; }\n+            min_gallop += 2; // Penalize for leaving gallop\n+        }\n+        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n+\n+        if len2 == 1 {\n+            assert len1 > 0;\n+            dest -= len1;\n+            c1 -= len1;\n+            copy_vec(array, dest+1, array, c1+1, len1);\n+            array[dest] <-> tmp[c2];\n+        } else if len2 == 0 {\n+            fail ~\"Comparison violates its contract!\";\n+        } else {\n+            assert len1 == 0;\n+            assert len2 != 0;\n+            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n+        }\n+    }\n+\n+    fn merge_collapse(&self, array: &[mut T]) {\n+        while self.runs.len() > 1 {\n+            let mut n = self.runs.len()-2;\n+            let chk = do self.runs.borrow |arr| {\n+                if n > 0 && arr[n-1].len <= arr[n].len + arr[n+1].len {\n+                    if arr[n-1].len < arr[n+1].len { n -= 1; }\n+                    true\n+                } else if arr[n].len <= arr[n+1].len {\n+                    true\n+                } else {\n+                    false\n+                }\n+            };\n+            if !chk { break; }\n+            self.merge_at(n, array);\n+        }\n+    }\n+\n+    fn merge_force_collapse(&self, array: &[mut T]) {\n+        while self.runs.len() > 1 {\n+            let mut n = self.runs.len()-2;\n+            if n > 0 {\n+                do self.runs.borrow |arr| {\n+                    if arr[n-1].len < arr[n+1].len {\n+                        n -= 1;\n+                    }\n+                }\n+            }\n+            self.merge_at(n, array);\n+        }\n+    }\n+}\n+\n+#[inline(always)]\n+fn copy_vec<T: Copy>(dest: &[mut T], s1: uint,\n+                    from: &[const T], s2: uint, len: uint) {\n+    assert s1+len <= dest.len() && s2+len <= from.len();\n+\n+    let slice = vec::slice(from, s2, s2+len);\n+    for slice.eachi |i, v| {\n+        dest[s1+i] = *v;\n+    }\n+}\n+\n #[cfg(test)]\n mod test_qsort3 {\n     #[legacy_exports];\n@@ -207,8 +745,8 @@ mod test_qsort {\n     fn check_sort(v1: &[mut int], v2: &[mut int]) {\n         let len = vec::len::<int>(v1);\n         pure fn leual(a: &int, b: &int) -> bool { *a <= *b }\n-        quick_sort::<int>(leual, v1);\n-        let mut i = 0;\n+        quick_sort::<int>(v1, leual);\n+        let mut i = 0u;\n         while i < len {\n             log(debug, v2[i]);\n             assert (v2[i] == v1[i]);\n@@ -248,7 +786,7 @@ mod test_qsort {\n \n         let expected = ~[1, 2, 3];\n \n-        sort::quick_sort(|x, y| { int::le(*x, *y) }, names);\n+        do sort::quick_sort(names) |x, y| { int::le(*x, *y) };\n \n         let immut_names = vec::from_mut(move names);\n \n@@ -269,8 +807,8 @@ mod tests {\n         let len = vec::len::<int>(v1);\n         pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let f = le;\n-        let v3 = merge_sort::<int>(f, v1);\n-        let mut i = 0;\n+        let v3 = merge_sort::<int>(v1, f);\n+        let mut i = 0u;\n         while i < len {\n             log(debug, v3[i]);\n             assert (v3[i] == v2[i]);\n@@ -299,7 +837,7 @@ mod tests {\n     fn test_merge_sort_mutable() {\n         pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let v1 = ~[mut 3, 2, 1];\n-        let v2 = merge_sort(le, v1);\n+        let v2 = merge_sort(v1, le);\n         assert v2 == ~[1, 2, 3];\n     }\n \n@@ -309,7 +847,7 @@ mod tests {\n         // tjc: funny that we have to use parens\n         pure fn ile(x: &(&static/str), y: &(&static/str)) -> bool\n         {\n-            unsafe            // to_lower is not pure...\n+            unsafe // to_lower is not pure...\n             {\n                 let x = x.to_lower();\n                 let y = y.to_lower();\n@@ -321,11 +859,300 @@ mod tests {\n                        \"Sally Mae\", \"JOE BOB\", \"Alex Andy\"];\n         let names2 = ~[\"Alex Andy\", \"Jack Brown\", \"joe bob\", \"Joe Bob\",\n                        \"JOE Bob\", \"JOE BOB\", \"Sally Mae\"];\n-        let names3 = merge_sort(ile, names1);\n+        let names3 = merge_sort(names1, ile);\n         assert names3 == names2;\n     }\n }\n \n+#[cfg(test)]\n+mod test_tim_sort {\n+    struct CVal {\n+        val: ~float,\n+    }\n+\n+    impl CVal: Ord {\n+        pure fn lt(other: &CVal) -> bool {\n+            unsafe {\n+                let rng = rand::Rng();\n+                if rng.gen_float() > 0.995 { fail ~\"It's happening!!!\"; }\n+            }\n+            self.val < other.val\n+        }\n+        pure fn le(other: &CVal) -> bool { self.val <= other.val }\n+        pure fn gt(other: &CVal) -> bool { self.val > other.val }\n+        pure fn ge(other: &CVal) -> bool { self.val >= other.val }\n+    }\n+\n+    fn check_sort(v1: &[mut int], v2: &[mut int]) {\n+        let len = vec::len::<int>(v1);\n+        tim_sort::<int>(v1);\n+        let mut i = 0u;\n+        while i < len {\n+            log(debug, v2[i]);\n+            assert (v2[i] == v1[i]);\n+            i += 1u;\n+        }\n+    }\n+\n+    #[test]\n+    fn test() {\n+        {\n+            let v1 = ~[mut 3, 7, 4, 5, 2, 9, 5, 8];\n+            let v2 = ~[mut 2, 3, 4, 5, 5, 7, 8, 9];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let v1 = ~[mut 1, 1, 1];\n+            let v2 = ~[mut 1, 1, 1];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let v1: ~[mut int] = ~[mut];\n+            let v2: ~[mut int] = ~[mut];\n+            check_sort(v1, v2);\n+        }\n+        { let v1 = ~[mut 9]; let v2 = ~[mut 9]; check_sort(v1, v2); }\n+        {\n+            let v1 = ~[mut 9, 3, 3, 3, 9];\n+            let v2 = ~[mut 3, 3, 3, 9, 9];\n+            check_sort(v1, v2);\n+        }\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn crash_test() {\n+        let rng = rand::Rng();\n+        let mut arr = do vec::from_fn(1000) |_i| {\n+            let randVal = rng.gen_float();\n+            CVal { val: ~randVal }\n+        };\n+\n+        tim_sort(arr);\n+        fail ~\"Guarantee the fail\";\n+    }\n+\n+    struct DVal { val: ~uint }\n+    impl DVal: Ord {\n+        pure fn lt(_x: &DVal) -> bool { true }\n+        pure fn le(_x: &DVal) -> bool { true }\n+        pure fn gt(_x: &DVal) -> bool { true }\n+        pure fn ge(_x: &DVal) -> bool { true }\n+    }\n+\n+    #[test]\n+    fn test_bad_Ord_impl() {\n+        let rng = rand::Rng();\n+        let mut arr = do vec::from_fn(500) |_i| {\n+            let randVal = rng.gen_uint();\n+            DVal { val: ~randVal }\n+        };\n+\n+        tim_sort(arr);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod big_tests {\n+\n+    #[test]\n+    fn test_unique() {\n+        let low = 5;\n+        let high = 10;\n+        tabulate_unique(low, high);\n+    }\n+\n+    #[test]\n+    fn test_managed() {\n+        let low = 5;\n+        let high = 10;\n+        tabulate_managed(low, high);\n+    }\n+\n+    fn multiplyVec<T: Copy>(arr: &[const T], num: uint) -> ~[mut T] {\n+        let size = arr.len();\n+        let res = do vec::from_fn(num) |i| {\n+            arr[i % size]\n+        };\n+        vec::to_mut(move res)\n+    }\n+\n+    fn makeRange(n: uint) -> ~[uint] {\n+        let one = do vec::from_fn(n) |i| { i };\n+        let mut two = copy one;\n+        vec::reverse(two);\n+        vec::append(move two, one)\n+    }\n+\n+    fn tabulate_unique(lo: uint, hi: uint) {\n+        fn isSorted<T: Ord>(arr: &[const T]) {\n+            for uint::range(0, arr.len()-1) |i| {\n+                if arr[i] > arr[i+1] {\n+                    fail ~\"Array not sorted\";\n+                }\n+            }\n+        }\n+\n+        let rng = rand::Rng();\n+\n+        for uint::range(lo, hi) |i| {\n+            let n = 1 << i;\n+            let arr = do vec::from_fn(n) |_i| {\n+                ~rng.gen_float()\n+            };\n+            let arr = vec::to_mut(move arr);\n+\n+            tim_sort(arr); // *sort\n+            isSorted(arr);\n+\n+            vec::reverse(arr);\n+            tim_sort(arr); // \\sort\n+            isSorted(arr);\n+\n+            tim_sort(arr); // /sort\n+            isSorted(arr);\n+\n+            for 3.times {\n+                let i1 = rng.gen_uint_range(0, n);\n+                let i2 = rng.gen_uint_range(0, n);\n+                arr[i1] <-> arr[i2];\n+            }\n+            tim_sort(arr); // 3sort\n+            isSorted(arr);\n+\n+            if n >= 10 {\n+                let size = arr.len();\n+                let mut idx = 1;\n+                while idx <= 10 {\n+                    arr[size-idx] = ~rng.gen_float();\n+                    idx += 1;\n+                }\n+            }\n+            tim_sort(arr); // +sort\n+            isSorted(arr);\n+\n+            for (n/100).times {\n+                let idx = rng.gen_uint_range(0, n);\n+                arr[idx] = ~rng.gen_float();\n+            }\n+            tim_sort(arr);\n+            isSorted(arr);\n+\n+            let arr = if n > 4 {\n+                let part = vec::view(arr, 0, 4);\n+                multiplyVec(part, n)\n+            } else { move arr };\n+            tim_sort(arr); // ~sort\n+            isSorted(arr);\n+\n+            let mut arr = vec::from_elem(n, ~(-0.5));\n+            tim_sort(arr); // =sort\n+            isSorted(arr);\n+\n+            let half = n / 2;\n+            let mut arr = makeRange(half).map(|i| ~(*i as float));\n+            tim_sort(arr); // !sort\n+            isSorted(arr);\n+        }\n+    }\n+\n+    fn tabulate_managed(lo: uint, hi: uint) {\n+        fn isSorted<T: Ord>(arr: &[const @T]) {\n+            for uint::range(0, arr.len()-1) |i| {\n+                if arr[i] > arr[i+1] {\n+                    fail ~\"Array not sorted\";\n+                }\n+            }\n+        }\n+\n+        let rng = rand::Rng();\n+\n+        for uint::range(lo, hi) |i| {\n+            let n = 1 << i;\n+            let arr = do vec::from_fn(n) |_i| {\n+                @rng.gen_float()\n+            };\n+            let arr = vec::to_mut(move arr);\n+\n+            tim_sort(arr); // *sort\n+            isSorted(arr);\n+\n+            vec::reverse(arr);\n+            tim_sort(arr); // \\sort\n+            isSorted(arr);\n+\n+            tim_sort(arr); // /sort\n+            isSorted(arr);\n+\n+            for 3.times {\n+                let i1 = rng.gen_uint_range(0, n);\n+                let i2 = rng.gen_uint_range(0, n);\n+                arr[i1] <-> arr[i2];\n+            }\n+            tim_sort(arr); // 3sort\n+            isSorted(arr);\n+\n+            if n >= 10 {\n+                let size = arr.len();\n+                let mut idx = 1;\n+                while idx <= 10 {\n+                    arr[size-idx] = @rng.gen_float();\n+                    idx += 1;\n+                }\n+            }\n+            tim_sort(arr); // +sort\n+            isSorted(arr);\n+\n+            for (n/100).times {\n+                let idx = rng.gen_uint_range(0, n);\n+                arr[idx] = @rng.gen_float();\n+            }\n+            tim_sort(arr);\n+            isSorted(arr);\n+\n+            let arr = if n > 4 {\n+                let part = vec::view(arr, 0, 4);\n+                multiplyVec(part, n)\n+            } else { move arr };\n+            tim_sort(arr); // ~sort\n+            isSorted(arr);\n+\n+            let mut arr = vec::from_elem(n, @(-0.5));\n+            tim_sort(arr); // =sort\n+            isSorted(arr);\n+\n+            let half = n / 2;\n+            let mut arr = makeRange(half).map(|i| @(*i as float));\n+            tim_sort(arr); // !sort\n+            isSorted(arr);\n+        }\n+    }\n+\n+    struct LVal {\n+        val: uint,\n+        key: fn(@uint),\n+\n+        drop {\n+            let x = unsafe { task::local_data::local_data_get(self.key) };\n+            match x {\n+                Some(@y) => {\n+                    unsafe {\n+                        task::local_data::local_data_set(self.key, @(y+1));\n+                    }\n+                }\n+                _ => fail ~\"Expected key to work\",\n+            }\n+        }\n+    }\n+\n+    impl LVal: Ord {\n+        pure fn lt(other: &LVal) -> bool { self.val < other.val }\n+        pure fn le(other: &LVal) -> bool { self.val <= other.val }\n+        pure fn gt(other: &LVal) -> bool { self.val > other.val }\n+        pure fn ge(other: &LVal) -> bool { self.val >= other.val }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "58366042fe988d8e2fddc4e7cb36d1892a71a145", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=a9d7642b5da8730039b7abad7750ac47cb965198", "patch": "@@ -218,7 +218,7 @@ fn print_failures(st: ConsoleTestState) {\n     st.out.write_line(~\"\\nfailures:\");\n     let failures = copy st.failures;\n     let failures = vec::map(failures, |test| test.name);\n-    let failures = sort::merge_sort(|x, y| str::le(*x, *y), failures);\n+    let failures = do sort::merge_sort(failures) |x, y| { str::le(*x, *y) };\n     for vec::each(failures) |name| {\n         st.out.write_line(fmt!(\"    %s\", *name));\n     }\n@@ -371,7 +371,7 @@ fn filter_tests(opts: &TestOpts,\n         pure fn lteq(t1: &TestDesc, t2: &TestDesc) -> bool {\n             str::le(t1.name, t2.name)\n         }\n-        sort::merge_sort(lteq, filtered)\n+        sort::merge_sort(filtered, lteq)\n     };\n \n     move filtered"}, {"sha": "8c19814350ca72cee6b300415df4b5b36cc3e448", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a9d7642b5da8730039b7abad7750ac47cb965198", "patch": "@@ -279,7 +279,7 @@ fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n     let v: ~[mut @ast::meta_item] = vec::to_mut(items);\n-    std::sort::quick_sort(lteq, v);\n+    std::sort::quick_sort(v, lteq);\n     vec::from_mut(move v)\n }\n "}, {"sha": "af7ffaa73f5bf03ec6b74d260dcf6089c9fff771", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=a9d7642b5da8730039b7abad7750ac47cb965198", "patch": "@@ -127,7 +127,7 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n         pure fn by_lo(a: &gather_item, b: &gather_item) -> bool {\n             a.lo < b.lo\n         }\n-        std::sort::merge_sort(by_lo, v)\n+        std::sort::merge_sort(v, by_lo)\n     };\n     return cx;\n }"}, {"sha": "6db3982297e554be938b580402aaf0297319c458", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=a9d7642b5da8730039b7abad7750ac47cb965198", "patch": "@@ -166,7 +166,7 @@ fn get_dep_hashes(cstore: CStore) -> ~[~str] {\n         result.push({name: cdata.name, hash: hash});\n     };\n     pure fn lteq(a: &crate_hash, b: &crate_hash) -> bool {a.name <= b.name}\n-    let sorted = std::sort::merge_sort(lteq, result);\n+    let sorted = std::sort::merge_sort(result, lteq);\n     debug!(\"sorted:\");\n     for sorted.each |x| {\n         debug!(\"  hash[%s]: %s\", x.name, x.hash);"}, {"sha": "f0a9677ab2f6d818ed733bc7307eaa6ad694a2b0", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=a9d7642b5da8730039b7abad7750ac47cb965198", "patch": "@@ -1079,7 +1079,7 @@ fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n         pure fn lteq(kv1: &numdep, kv2: &numdep) -> bool {\n             kv1.cnum <= kv2.cnum\n         }\n-        std::sort::quick_sort(lteq, deps);\n+        std::sort::quick_sort(deps, lteq);\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;"}, {"sha": "d4d9e7e5156688128bcaafde34e4ea41f6fb8cfa", "filename": "src/rustdoc/sort_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Frustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Frustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_pass.rs?ref=a9d7642b5da8730039b7abad7750ac47cb965198", "patch": "@@ -36,7 +36,7 @@ fn fold_mod(\n ) -> doc::ModDoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n     doc::ModDoc_({\n-        items: sort::merge_sort(fold.ctxt, doc.items),\n+        items: sort::merge_sort(doc.items, fold.ctxt),\n         .. *doc\n     })\n }"}, {"sha": "3a3c609853b37c7f3c9240b6185f00d7ff34abdd", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=a9d7642b5da8730039b7abad7750ac47cb965198", "patch": "@@ -34,7 +34,7 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n \n    // sort by key, then by value\n    fn sortKV<TT: Copy Ord, UU: Copy Ord>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n-      return sort::merge_sort(le_by_val, sort::merge_sort(le_by_key, orig));\n+      return sort::merge_sort(sort::merge_sort(orig, le_by_key), le_by_val);\n    }\n \n    let mut pairs = ~[];"}, {"sha": "e4373d55c1792ff066132be61aef1f4fef7fdcc6", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7642b5da8730039b7abad7750ac47cb965198/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=a9d7642b5da8730039b7abad7750ac47cb965198", "patch": "@@ -31,7 +31,7 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n \n    // sort by key, then by value\n    fn sortKV<TT: Copy Ord, UU: Copy Ord>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n-      return sort::merge_sort(le_by_val, sort::merge_sort(le_by_key, orig));\n+      return sort::merge_sort(sort::merge_sort(orig, le_by_key), le_by_val);\n    }\n \n    let mut pairs = ~[];"}]}