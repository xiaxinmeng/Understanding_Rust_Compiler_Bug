{"sha": "f90a4ff26c9743abf612f015c4398d7158b646b6", "node_id": "C_kwDOAAsO6NoAKGY5MGE0ZmYyNmM5NzQzYWJmNjEyZjAxNWM0Mzk4ZDcxNThiNjQ2YjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-14T03:15:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-14T03:15:03Z"}, "message": "Auto merge of #104188 - jyn514:download-config-only, r=Mark-Simulacrum\n\nMake all download functions need only Config, not Builder\n\nThis also adds a new `mod download` instead of scattering the download code across `config.rs` and `native.rs`.\n\nThis is the simplest and also most bit-rotty part of https://github.com/rust-lang/rust/pull/102282. Opening it earlier so it's not mixed in with behavior changes and to avoid rebase hell.\n\ncc https://github.com/rust-lang/rust/issues/94829 (which nows has the hackmd linked).\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "3648a20362a81bcf58ba072c5456096a22b88341", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3648a20362a81bcf58ba072c5456096a22b88341"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f90a4ff26c9743abf612f015c4398d7158b646b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f90a4ff26c9743abf612f015c4398d7158b646b6", "html_url": "https://github.com/rust-lang/rust/commit/f90a4ff26c9743abf612f015c4398d7158b646b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f90a4ff26c9743abf612f015c4398d7158b646b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "338cfd3cce448f576dbac48438018fc65cef8982", "url": "https://api.github.com/repos/rust-lang/rust/commits/338cfd3cce448f576dbac48438018fc65cef8982", "html_url": "https://github.com/rust-lang/rust/commit/338cfd3cce448f576dbac48438018fc65cef8982"}, {"sha": "fb471de5a91a3426872c654681a8e6330ae84aa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb471de5a91a3426872c654681a8e6330ae84aa4", "html_url": "https://github.com/rust-lang/rust/commit/fb471de5a91a3426872c654681a8e6330ae84aa4"}], "stats": {"total": 1300, "additions": 663, "deletions": 637}, "files": [{"sha": "8d999302a6d7b2240a8ef56eb10c52fc7714b67c", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 5, "deletions": 256, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=f90a4ff26c9743abf612f015c4398d7158b646b6", "patch": "@@ -2,14 +2,13 @@ use std::any::{type_name, Any};\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n use std::env;\n-use std::ffi::{OsStr, OsString};\n+use std::ffi::OsStr;\n use std::fmt::{Debug, Write};\n-use std::fs::{self, File};\n+use std::fs::{self};\n use std::hash::Hash;\n-use std::io::{BufRead, BufReader, ErrorKind};\n use std::ops::Deref;\n use std::path::{Component, Path, PathBuf};\n-use std::process::{Command, Stdio};\n+use std::process::Command;\n use std::time::{Duration, Instant};\n \n use crate::cache::{Cache, Interned, INTERNER};\n@@ -24,14 +23,12 @@ use crate::test;\n use crate::tool::{self, SourceType};\n use crate::util::{self, add_dylib_path, add_link_lib_path, exe, libdir, output, t};\n use crate::EXTRA_CHECK_CFGS;\n-use crate::{check, Config};\n-use crate::{compile, Crate};\n+use crate::{check, compile, Crate};\n use crate::{Build, CLang, DocTests, GitRepo, Mode};\n \n pub use crate::Compiler;\n // FIXME: replace with std::lazy after it gets stabilized and reaches beta\n-use once_cell::sync::{Lazy, OnceCell};\n-use xz2::bufread::XzDecoder;\n+use once_cell::sync::Lazy;\n \n pub struct Builder<'a> {\n     pub build: &'a Build,\n@@ -853,241 +850,6 @@ impl<'a> Builder<'a> {\n         StepDescription::run(v, self, paths);\n     }\n \n-    /// Modifies the interpreter section of 'fname' to fix the dynamic linker,\n-    /// or the RPATH section, to fix the dynamic library search path\n-    ///\n-    /// This is only required on NixOS and uses the PatchELF utility to\n-    /// change the interpreter/RPATH of ELF executables.\n-    ///\n-    /// Please see https://nixos.org/patchelf.html for more information\n-    pub(crate) fn fix_bin_or_dylib(&self, fname: &Path) {\n-        // FIXME: cache NixOS detection?\n-        match Command::new(\"uname\").arg(\"-s\").stderr(Stdio::inherit()).output() {\n-            Err(_) => return,\n-            Ok(output) if !output.status.success() => return,\n-            Ok(output) => {\n-                let mut s = output.stdout;\n-                if s.last() == Some(&b'\\n') {\n-                    s.pop();\n-                }\n-                if s != b\"Linux\" {\n-                    return;\n-                }\n-            }\n-        }\n-\n-        // If the user has asked binaries to be patched for Nix, then\n-        // don't check for NixOS or `/lib`, just continue to the patching.\n-        // NOTE: this intentionally comes after the Linux check:\n-        // - patchelf only works with ELF files, so no need to run it on Mac or Windows\n-        // - On other Unix systems, there is no stable syscall interface, so Nix doesn't manage the global libc.\n-        if !self.config.patch_binaries_for_nix {\n-            // Use `/etc/os-release` instead of `/etc/NIXOS`.\n-            // The latter one does not exist on NixOS when using tmpfs as root.\n-            const NIX_IDS: &[&str] = &[\"ID=nixos\", \"ID='nixos'\", \"ID=\\\"nixos\\\"\"];\n-            let os_release = match File::open(\"/etc/os-release\") {\n-                Err(e) if e.kind() == ErrorKind::NotFound => return,\n-                Err(e) => panic!(\"failed to access /etc/os-release: {}\", e),\n-                Ok(f) => f,\n-            };\n-            if !BufReader::new(os_release).lines().any(|l| NIX_IDS.contains(&t!(l).trim())) {\n-                return;\n-            }\n-            if Path::new(\"/lib\").exists() {\n-                return;\n-            }\n-        }\n-\n-        // At this point we're pretty sure the user is running NixOS or using Nix\n-        println!(\"info: you seem to be using Nix. Attempting to patch {}\", fname.display());\n-\n-        // Only build `.nix-deps` once.\n-        static NIX_DEPS_DIR: OnceCell<PathBuf> = OnceCell::new();\n-        let mut nix_build_succeeded = true;\n-        let nix_deps_dir = NIX_DEPS_DIR.get_or_init(|| {\n-            // Run `nix-build` to \"build\" each dependency (which will likely reuse\n-            // the existing `/nix/store` copy, or at most download a pre-built copy).\n-            //\n-            // Importantly, we create a gc-root called `.nix-deps` in the `build/`\n-            // directory, but still reference the actual `/nix/store` path in the rpath\n-            // as it makes it significantly more robust against changes to the location of\n-            // the `.nix-deps` location.\n-            //\n-            // bintools: Needed for the path of `ld-linux.so` (via `nix-support/dynamic-linker`).\n-            // zlib: Needed as a system dependency of `libLLVM-*.so`.\n-            // patchelf: Needed for patching ELF binaries (see doc comment above).\n-            let nix_deps_dir = self.out.join(\".nix-deps\");\n-            const NIX_EXPR: &str = \"\n-            with (import <nixpkgs> {});\n-            symlinkJoin {\n-                name = \\\"rust-stage0-dependencies\\\";\n-                paths = [\n-                    zlib\n-                    patchelf\n-                    stdenv.cc.bintools\n-                ];\n-            }\n-            \";\n-            nix_build_succeeded = self.try_run(Command::new(\"nix-build\").args(&[\n-                Path::new(\"-E\"),\n-                Path::new(NIX_EXPR),\n-                Path::new(\"-o\"),\n-                &nix_deps_dir,\n-            ]));\n-            nix_deps_dir\n-        });\n-        if !nix_build_succeeded {\n-            return;\n-        }\n-\n-        let mut patchelf = Command::new(nix_deps_dir.join(\"bin/patchelf\"));\n-        let rpath_entries = {\n-            // ORIGIN is a relative default, all binary and dynamic libraries we ship\n-            // appear to have this (even when `../lib` is redundant).\n-            // NOTE: there are only two paths here, delimited by a `:`\n-            let mut entries = OsString::from(\"$ORIGIN/../lib:\");\n-            entries.push(t!(fs::canonicalize(nix_deps_dir)));\n-            entries.push(\"/lib\");\n-            entries\n-        };\n-        patchelf.args(&[OsString::from(\"--set-rpath\"), rpath_entries]);\n-        if !fname.extension().map_or(false, |ext| ext == \"so\") {\n-            // Finally, set the correct .interp for binaries\n-            let dynamic_linker_path = nix_deps_dir.join(\"nix-support/dynamic-linker\");\n-            // FIXME: can we support utf8 here? `args` doesn't accept Vec<u8>, only OsString ...\n-            let dynamic_linker = t!(String::from_utf8(t!(fs::read(dynamic_linker_path))));\n-            patchelf.args(&[\"--set-interpreter\", dynamic_linker.trim_end()]);\n-        }\n-\n-        self.try_run(patchelf.arg(fname));\n-    }\n-\n-    pub(crate) fn download_component(&self, url: &str, dest_path: &Path, help_on_error: &str) {\n-        self.verbose(&format!(\"download {url}\"));\n-        // Use a temporary file in case we crash while downloading, to avoid a corrupt download in cache/.\n-        let tempfile = self.tempdir().join(dest_path.file_name().unwrap());\n-        // While bootstrap itself only supports http and https downloads, downstream forks might\n-        // need to download components from other protocols. The match allows them adding more\n-        // protocols without worrying about merge conflicts if we change the HTTP implementation.\n-        match url.split_once(\"://\").map(|(proto, _)| proto) {\n-            Some(\"http\") | Some(\"https\") => {\n-                self.download_http_with_retries(&tempfile, url, help_on_error)\n-            }\n-            Some(other) => panic!(\"unsupported protocol {other} in {url}\"),\n-            None => panic!(\"no protocol in {url}\"),\n-        }\n-        t!(std::fs::rename(&tempfile, dest_path));\n-    }\n-\n-    fn download_http_with_retries(&self, tempfile: &Path, url: &str, help_on_error: &str) {\n-        println!(\"downloading {}\", url);\n-        // Try curl. If that fails and we are on windows, fallback to PowerShell.\n-        let mut curl = Command::new(\"curl\");\n-        curl.args(&[\n-            \"-#\",\n-            \"-y\",\n-            \"30\",\n-            \"-Y\",\n-            \"10\", // timeout if speed is < 10 bytes/sec for > 30 seconds\n-            \"--connect-timeout\",\n-            \"30\", // timeout if cannot connect within 30 seconds\n-            \"--retry\",\n-            \"3\",\n-            \"-Sf\",\n-            \"-o\",\n-        ]);\n-        curl.arg(tempfile);\n-        curl.arg(url);\n-        if !self.check_run(&mut curl) {\n-            if self.build.build.contains(\"windows-msvc\") {\n-                println!(\"Fallback to PowerShell\");\n-                for _ in 0..3 {\n-                    if self.try_run(Command::new(\"PowerShell.exe\").args(&[\n-                        \"/nologo\",\n-                        \"-Command\",\n-                        \"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\",\n-                        &format!(\n-                            \"(New-Object System.Net.WebClient).DownloadFile('{}', '{}')\",\n-                            url, tempfile.to_str().expect(\"invalid UTF-8 not supported with powershell downloads\"),\n-                        ),\n-                    ])) {\n-                        return;\n-                    }\n-                    println!(\"\\nspurious failure, trying again\");\n-                }\n-            }\n-            if !help_on_error.is_empty() {\n-                eprintln!(\"{}\", help_on_error);\n-            }\n-            crate::detail_exit(1);\n-        }\n-    }\n-\n-    pub(crate) fn unpack(&self, tarball: &Path, dst: &Path, pattern: &str) {\n-        println!(\"extracting {} to {}\", tarball.display(), dst.display());\n-        if !dst.exists() {\n-            t!(fs::create_dir_all(dst));\n-        }\n-\n-        // `tarball` ends with `.tar.xz`; strip that suffix\n-        // example: `rust-dev-nightly-x86_64-unknown-linux-gnu`\n-        let uncompressed_filename =\n-            Path::new(tarball.file_name().expect(\"missing tarball filename\")).file_stem().unwrap();\n-        let directory_prefix = Path::new(Path::new(uncompressed_filename).file_stem().unwrap());\n-\n-        // decompress the file\n-        let data = t!(File::open(tarball));\n-        let decompressor = XzDecoder::new(BufReader::new(data));\n-\n-        let mut tar = tar::Archive::new(decompressor);\n-        for member in t!(tar.entries()) {\n-            let mut member = t!(member);\n-            let original_path = t!(member.path()).into_owned();\n-            // skip the top-level directory\n-            if original_path == directory_prefix {\n-                continue;\n-            }\n-            let mut short_path = t!(original_path.strip_prefix(directory_prefix));\n-            if !short_path.starts_with(pattern) {\n-                continue;\n-            }\n-            short_path = t!(short_path.strip_prefix(pattern));\n-            let dst_path = dst.join(short_path);\n-            self.verbose(&format!(\"extracting {} to {}\", original_path.display(), dst.display()));\n-            if !t!(member.unpack_in(dst)) {\n-                panic!(\"path traversal attack ??\");\n-            }\n-            let src_path = dst.join(original_path);\n-            if src_path.is_dir() && dst_path.exists() {\n-                continue;\n-            }\n-            t!(fs::rename(src_path, dst_path));\n-        }\n-        t!(fs::remove_dir_all(dst.join(directory_prefix)));\n-    }\n-\n-    /// Returns whether the SHA256 checksum of `path` matches `expected`.\n-    pub(crate) fn verify(&self, path: &Path, expected: &str) -> bool {\n-        use sha2::Digest;\n-\n-        self.verbose(&format!(\"verifying {}\", path.display()));\n-        let mut hasher = sha2::Sha256::new();\n-        // FIXME: this is ok for rustfmt (4.1 MB large at time of writing), but it seems memory-intensive for rustc and larger components.\n-        // Consider using streaming IO instead?\n-        let contents = if self.config.dry_run() { vec![] } else { t!(fs::read(path)) };\n-        hasher.update(&contents);\n-        let found = hex::encode(hasher.finalize().as_slice());\n-        let verified = found == expected;\n-        if !verified && !self.config.dry_run() {\n-            println!(\n-                \"invalid checksum: \\n\\\n-                found:    {found}\\n\\\n-                expected: {expected}\",\n-            );\n-        }\n-        return verified;\n-    }\n-\n     /// Obtain a compiler at a given stage and for a given host. Explicitly does\n     /// not take `Compiler` since all `Compiler` instances are meant to be\n     /// obtained through this function, since it ensures that they are valid\n@@ -1301,19 +1063,6 @@ impl<'a> Builder<'a> {\n         None\n     }\n \n-    /// Convenience wrapper to allow `builder.llvm_link_shared()` instead of `builder.config.llvm_link_shared(&builder)`.\n-    pub(crate) fn llvm_link_shared(&self) -> bool {\n-        Config::llvm_link_shared(self)\n-    }\n-\n-    pub(crate) fn download_rustc(&self) -> bool {\n-        Config::download_rustc(self)\n-    }\n-\n-    pub(crate) fn initial_rustfmt(&self) -> Option<PathBuf> {\n-        Config::initial_rustfmt(self)\n-    }\n-\n     /// Prepares an invocation of `cargo` to be run.\n     ///\n     /// This will create a `Command` that represents a pending execution of"}, {"sha": "eae81b9fc69c83c91919804bf18858b1ca66baed", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=f90a4ff26c9743abf612f015c4398d7158b646b6", "patch": "@@ -13,8 +13,10 @@ use crate::util::output;\n use crate::util::t;\n use crate::Build;\n \n+#[derive(Clone, Default)]\n pub enum GitInfo {\n     /// This is not a git repository.\n+    #[default]\n     Absent,\n     /// This is a git repository.\n     /// If the info should be used (`ignore_git` is false), this will be\n@@ -25,6 +27,7 @@ pub enum GitInfo {\n     RecordedForTarball(Info),\n }\n \n+#[derive(Clone)]\n pub struct Info {\n     pub commit_date: String,\n     pub sha: String,"}, {"sha": "54906a4918bc12b3d67d90853b38f97a511abe9d", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=f90a4ff26c9743abf612f015c4398d7158b646b6", "patch": "@@ -763,10 +763,10 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetS\n \n     cargo.env(\"CFG_LIBDIR_RELATIVE\", libdir_relative);\n \n-    if let Some(ref ver_date) = builder.rust_info.commit_date() {\n+    if let Some(ref ver_date) = builder.rust_info().commit_date() {\n         cargo.env(\"CFG_VER_DATE\", ver_date);\n     }\n-    if let Some(ref ver_hash) = builder.rust_info.sha() {\n+    if let Some(ref ver_hash) = builder.rust_info().sha() {\n         cargo.env(\"CFG_VER_HASH\", ver_hash);\n     }\n     if !builder.unstable_features() {"}, {"sha": "af004aa5098542a5d3bbc44af8ddd4382c72501f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 88, "deletions": 226, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=f90a4ff26c9743abf612f015c4398d7158b646b6", "patch": "@@ -7,19 +7,18 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::collections::{HashMap, HashSet};\n use std::env;\n-use std::ffi::OsStr;\n use std::fmt;\n use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::str::FromStr;\n \n-use crate::builder::{Builder, TaskPath};\n+use crate::builder::TaskPath;\n use crate::cache::{Interned, INTERNER};\n-use crate::channel::GitInfo;\n+use crate::channel::{self, GitInfo};\n pub use crate::flags::Subcommand;\n use crate::flags::{Color, Flags};\n-use crate::util::{exe, output, program_out_of_date, t};\n+use crate::util::{exe, output, t};\n use once_cell::sync::OnceCell;\n use serde::{Deserialize, Deserializer};\n \n@@ -224,6 +223,7 @@ pub struct Config {\n     #[cfg(test)]\n     pub initial_rustfmt: RefCell<RustfmtState>,\n     pub out: PathBuf,\n+    pub rust_info: channel::GitInfo,\n }\n \n #[derive(Default, Deserialize)]\n@@ -1204,7 +1204,7 @@ impl Config {\n             config.rust_codegen_units_std = rust.codegen_units_std.map(threads_from_config);\n             config.rust_profile_use = flags.rust_profile_use.or(rust.profile_use);\n             config.rust_profile_generate = flags.rust_profile_generate.or(rust.profile_generate);\n-            config.download_rustc_commit = download_ci_rustc_commit(&config, rust.download_rustc);\n+            config.download_rustc_commit = config.download_ci_rustc_commit(rust.download_rustc);\n \n             config.rust_lto = rust\n                 .lto\n@@ -1326,6 +1326,7 @@ impl Config {\n \n         let default = config.channel == \"dev\";\n         config.ignore_git = ignore_git.unwrap_or(default);\n+        config.rust_info = GitInfo::new(config.ignore_git, &config.src);\n \n         let download_rustc = config.download_rustc_commit.is_some();\n         // See https://github.com/rust-lang/compiler-team/issues/326\n@@ -1401,8 +1402,8 @@ impl Config {\n \n     /// Bootstrap embeds a version number into the name of shared libraries it uploads in CI.\n     /// Return the version it would have used for the given commit.\n-    pub(crate) fn artifact_version_part(&self, builder: &Builder<'_>, commit: &str) -> String {\n-        let (channel, version) = if builder.rust_info.is_managed_git_subrepository() {\n+    pub(crate) fn artifact_version_part(&self, commit: &str) -> String {\n+        let (channel, version) = if self.rust_info.is_managed_git_subrepository() {\n             let mut channel = self.git();\n             channel.arg(\"show\").arg(format!(\"{}:src/ci/channel\", commit));\n             let channel = output(&mut channel);\n@@ -1411,14 +1412,14 @@ impl Config {\n             let version = output(&mut version);\n             (channel.trim().to_owned(), version.trim().to_owned())\n         } else {\n-            let channel = fs::read_to_string(builder.src.join(\"src/ci/channel\"));\n-            let version = fs::read_to_string(builder.src.join(\"src/version\"));\n+            let channel = fs::read_to_string(self.src.join(\"src/ci/channel\"));\n+            let version = fs::read_to_string(self.src.join(\"src/version\"));\n             match (channel, version) {\n                 (Ok(channel), Ok(version)) => {\n                     (channel.trim().to_owned(), version.trim().to_owned())\n                 }\n                 (channel, version) => {\n-                    let src = builder.src.display();\n+                    let src = self.src.display();\n                     eprintln!(\"error: failed to determine artifact channel and/or version\");\n                     eprintln!(\n                         \"help: consider using a git checkout or ensure these files are readable\"\n@@ -1477,17 +1478,17 @@ impl Config {\n     ///\n     /// If `false`, llvm should be linked statically.\n     /// This is computed on demand since LLVM might have to first be downloaded from CI.\n-    pub(crate) fn llvm_link_shared(builder: &Builder<'_>) -> bool {\n-        let mut opt = builder.config.llvm_link_shared.get();\n-        if opt.is_none() && builder.config.dry_run() {\n+    pub(crate) fn llvm_link_shared(&self) -> bool {\n+        let mut opt = self.llvm_link_shared.get();\n+        if opt.is_none() && self.dry_run() {\n             // just assume static for now - dynamic linking isn't supported on all platforms\n             return false;\n         }\n \n         let llvm_link_shared = *opt.get_or_insert_with(|| {\n-            if builder.config.llvm_from_ci {\n-                crate::native::maybe_download_ci_llvm(builder);\n-                let ci_llvm = builder.config.ci_llvm_root();\n+            if self.llvm_from_ci {\n+                self.maybe_download_ci_llvm();\n+                let ci_llvm = self.ci_llvm_root();\n                 let link_type = t!(\n                     std::fs::read_to_string(ci_llvm.join(\"link-type.txt\")),\n                     format!(\"CI llvm missing: {}\", ci_llvm.display())\n@@ -1499,36 +1500,36 @@ impl Config {\n                 false\n             }\n         });\n-        builder.config.llvm_link_shared.set(opt);\n+        self.llvm_link_shared.set(opt);\n         llvm_link_shared\n     }\n \n     /// Return whether we will use a downloaded, pre-compiled version of rustc, or just build from source.\n-    pub(crate) fn download_rustc(builder: &Builder<'_>) -> bool {\n+    pub(crate) fn download_rustc(&self) -> bool {\n         static DOWNLOAD_RUSTC: OnceCell<bool> = OnceCell::new();\n-        if builder.config.dry_run() && DOWNLOAD_RUSTC.get().is_none() {\n+        if self.dry_run() && DOWNLOAD_RUSTC.get().is_none() {\n             // avoid trying to actually download the commit\n             return false;\n         }\n \n-        *DOWNLOAD_RUSTC.get_or_init(|| match &builder.config.download_rustc_commit {\n+        *DOWNLOAD_RUSTC.get_or_init(|| match &self.download_rustc_commit {\n             None => false,\n             Some(commit) => {\n-                download_ci_rustc(builder, commit);\n+                self.download_ci_rustc(commit);\n                 true\n             }\n         })\n     }\n \n-    pub(crate) fn initial_rustfmt(builder: &Builder<'_>) -> Option<PathBuf> {\n-        match &mut *builder.config.initial_rustfmt.borrow_mut() {\n+    pub(crate) fn initial_rustfmt(&self) -> Option<PathBuf> {\n+        match &mut *self.initial_rustfmt.borrow_mut() {\n             RustfmtState::SystemToolchain(p) | RustfmtState::Downloaded(p) => Some(p.clone()),\n             RustfmtState::Unavailable => None,\n             r @ RustfmtState::LazyEvaluated => {\n-                if builder.config.dry_run() {\n+                if self.dry_run() {\n                     return Some(PathBuf::new());\n                 }\n-                let path = maybe_download_rustfmt(builder);\n+                let path = self.maybe_download_rustfmt();\n                 *r = if let Some(p) = &path {\n                     RustfmtState::Downloaded(p.clone())\n                 } else {\n@@ -1539,8 +1540,10 @@ impl Config {\n         }\n     }\n \n-    pub fn verbose(&self) -> bool {\n-        self.verbose > 0\n+    pub fn verbose(&self, msg: &str) {\n+        if self.verbose > 0 {\n+            println!(\"{}\", msg);\n+        }\n     }\n \n     pub fn sanitizers_enabled(&self, target: TargetSelection) -> bool {\n@@ -1578,218 +1581,77 @@ impl Config {\n     pub fn submodules(&self, rust_info: &GitInfo) -> bool {\n         self.submodules.unwrap_or(rust_info.is_managed_git_subrepository())\n     }\n-}\n-\n-fn set<T>(field: &mut T, val: Option<T>) {\n-    if let Some(v) = val {\n-        *field = v;\n-    }\n-}\n \n-fn threads_from_config(v: u32) -> u32 {\n-    match v {\n-        0 => std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get) as u32,\n-        n => n,\n-    }\n-}\n+    /// Returns the commit to download, or `None` if we shouldn't download CI artifacts.\n+    fn download_ci_rustc_commit(&self, download_rustc: Option<StringOrBool>) -> Option<String> {\n+        // If `download-rustc` is not set, default to rebuilding.\n+        let if_unchanged = match download_rustc {\n+            None | Some(StringOrBool::Bool(false)) => return None,\n+            Some(StringOrBool::Bool(true)) => false,\n+            Some(StringOrBool::String(s)) if s == \"if-unchanged\" => true,\n+            Some(StringOrBool::String(other)) => {\n+                panic!(\"unrecognized option for download-rustc: {}\", other)\n+            }\n+        };\n \n-/// Returns the commit to download, or `None` if we shouldn't download CI artifacts.\n-fn download_ci_rustc_commit(\n-    config: &Config,\n-    download_rustc: Option<StringOrBool>,\n-) -> Option<String> {\n-    // If `download-rustc` is not set, default to rebuilding.\n-    let if_unchanged = match download_rustc {\n-        None | Some(StringOrBool::Bool(false)) => return None,\n-        Some(StringOrBool::Bool(true)) => false,\n-        Some(StringOrBool::String(s)) if s == \"if-unchanged\" => true,\n-        Some(StringOrBool::String(other)) => {\n-            panic!(\"unrecognized option for download-rustc: {}\", other)\n+        // Handle running from a directory other than the top level\n+        let top_level = output(self.git().args(&[\"rev-parse\", \"--show-toplevel\"]));\n+        let top_level = top_level.trim_end();\n+        let compiler = format!(\"{top_level}/compiler/\");\n+        let library = format!(\"{top_level}/library/\");\n+\n+        // Look for a version to compare to based on the current commit.\n+        // Only commits merged by bors will have CI artifacts.\n+        let merge_base = output(\n+            self.git()\n+                .arg(\"rev-list\")\n+                .arg(format!(\"--author={}\", self.stage0_metadata.config.git_merge_commit_email))\n+                .args(&[\"-n1\", \"--first-parent\", \"HEAD\"]),\n+        );\n+        let commit = merge_base.trim_end();\n+        if commit.is_empty() {\n+            println!(\"error: could not find commit hash for downloading rustc\");\n+            println!(\"help: maybe your repository history is too shallow?\");\n+            println!(\"help: consider disabling `download-rustc`\");\n+            println!(\"help: or fetch enough history to include one upstream commit\");\n+            crate::detail_exit(1);\n         }\n-    };\n-\n-    // Handle running from a directory other than the top level\n-    let top_level = output(config.git().args(&[\"rev-parse\", \"--show-toplevel\"]));\n-    let top_level = top_level.trim_end();\n-    let compiler = format!(\"{top_level}/compiler/\");\n-    let library = format!(\"{top_level}/library/\");\n \n-    // Look for a version to compare to based on the current commit.\n-    // Only commits merged by bors will have CI artifacts.\n-    let merge_base = output(\n-        config\n+        // Warn if there were changes to the compiler or standard library since the ancestor commit.\n+        let has_changes = !t!(self\n             .git()\n-            .arg(\"rev-list\")\n-            .arg(format!(\"--author={}\", config.stage0_metadata.config.git_merge_commit_email))\n-            .args(&[\"-n1\", \"--first-parent\", \"HEAD\"]),\n-    );\n-    let commit = merge_base.trim_end();\n-    if commit.is_empty() {\n-        println!(\"error: could not find commit hash for downloading rustc\");\n-        println!(\"help: maybe your repository history is too shallow?\");\n-        println!(\"help: consider disabling `download-rustc`\");\n-        println!(\"help: or fetch enough history to include one upstream commit\");\n-        crate::detail_exit(1);\n-    }\n-\n-    // Warn if there were changes to the compiler or standard library since the ancestor commit.\n-    let has_changes = !t!(config\n-        .git()\n-        .args(&[\"diff-index\", \"--quiet\", &commit, \"--\", &compiler, &library])\n-        .status())\n-    .success();\n-    if has_changes {\n-        if if_unchanged {\n-            if config.verbose > 0 {\n-                println!(\n-                    \"warning: saw changes to compiler/ or library/ since {commit}; \\\n-                          ignoring `download-rustc`\"\n-                );\n+            .args(&[\"diff-index\", \"--quiet\", &commit, \"--\", &compiler, &library])\n+            .status())\n+        .success();\n+        if has_changes {\n+            if if_unchanged {\n+                if self.verbose > 0 {\n+                    println!(\n+                        \"warning: saw changes to compiler/ or library/ since {commit}; \\\n+                            ignoring `download-rustc`\"\n+                    );\n+                }\n+                return None;\n             }\n-            return None;\n+            println!(\n+                \"warning: `download-rustc` is enabled, but there are changes to \\\n+                    compiler/ or library/\"\n+            );\n         }\n-        println!(\n-            \"warning: `download-rustc` is enabled, but there are changes to \\\n-                  compiler/ or library/\"\n-        );\n-    }\n-\n-    Some(commit.to_string())\n-}\n-\n-fn maybe_download_rustfmt(builder: &Builder<'_>) -> Option<PathBuf> {\n-    let RustfmtMetadata { date, version } = builder.config.stage0_metadata.rustfmt.as_ref()?;\n-    let channel = format!(\"{version}-{date}\");\n \n-    let host = builder.config.build;\n-    let rustfmt_path = builder.config.initial_rustc.with_file_name(exe(\"rustfmt\", host));\n-    let bin_root = builder.config.out.join(host.triple).join(\"stage0\");\n-    let rustfmt_stamp = bin_root.join(\".rustfmt-stamp\");\n-    if rustfmt_path.exists() && !program_out_of_date(&rustfmt_stamp, &channel) {\n-        return Some(rustfmt_path);\n+        Some(commit.to_string())\n     }\n-\n-    let filename = format!(\"rustfmt-{version}-{build}.tar.xz\", build = host.triple);\n-    download_component(builder, DownloadSource::Dist, filename, \"rustfmt-preview\", &date, \"stage0\");\n-\n-    builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustfmt\"));\n-    builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"cargo-fmt\"));\n-\n-    builder.create(&rustfmt_stamp, &channel);\n-    Some(rustfmt_path)\n }\n \n-fn download_ci_rustc(builder: &Builder<'_>, commit: &str) {\n-    builder.verbose(&format!(\"using downloaded stage2 artifacts from CI (commit {commit})\"));\n-    let version = builder.config.artifact_version_part(builder, commit);\n-    let host = builder.config.build.triple;\n-    let bin_root = builder.out.join(host).join(\"ci-rustc\");\n-    let rustc_stamp = bin_root.join(\".rustc-stamp\");\n-\n-    if !bin_root.join(\"bin\").join(\"rustc\").exists() || program_out_of_date(&rustc_stamp, commit) {\n-        if bin_root.exists() {\n-            t!(fs::remove_dir_all(&bin_root));\n-        }\n-        let filename = format!(\"rust-std-{version}-{host}.tar.xz\");\n-        let pattern = format!(\"rust-std-{host}\");\n-        download_ci_component(builder, filename, &pattern, commit);\n-        let filename = format!(\"rustc-{version}-{host}.tar.xz\");\n-        download_ci_component(builder, filename, \"rustc\", commit);\n-        // download-rustc doesn't need its own cargo, it can just use beta's.\n-        let filename = format!(\"rustc-dev-{version}-{host}.tar.xz\");\n-        download_ci_component(builder, filename, \"rustc-dev\", commit);\n-\n-        builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));\n-        builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustdoc\"));\n-        let lib_dir = bin_root.join(\"lib\");\n-        for lib in t!(fs::read_dir(&lib_dir), lib_dir.display().to_string()) {\n-            let lib = t!(lib);\n-            if lib.path().extension() == Some(OsStr::new(\"so\")) {\n-                builder.fix_bin_or_dylib(&lib.path());\n-            }\n-        }\n-        t!(fs::write(rustc_stamp, commit));\n+fn set<T>(field: &mut T, val: Option<T>) {\n+    if let Some(v) = val {\n+        *field = v;\n     }\n }\n \n-pub(crate) enum DownloadSource {\n-    CI,\n-    Dist,\n-}\n-\n-/// Download a single component of a CI-built toolchain (not necessarily a published nightly).\n-// NOTE: intentionally takes an owned string to avoid downloading multiple times by accident\n-fn download_ci_component(builder: &Builder<'_>, filename: String, prefix: &str, commit: &str) {\n-    download_component(builder, DownloadSource::CI, filename, prefix, commit, \"ci-rustc\")\n-}\n-\n-fn download_component(\n-    builder: &Builder<'_>,\n-    mode: DownloadSource,\n-    filename: String,\n-    prefix: &str,\n-    key: &str,\n-    destination: &str,\n-) {\n-    let cache_dst = builder.out.join(\"cache\");\n-    let cache_dir = cache_dst.join(key);\n-    if !cache_dir.exists() {\n-        t!(fs::create_dir_all(&cache_dir));\n-    }\n-\n-    let bin_root = builder.out.join(builder.config.build.triple).join(destination);\n-    let tarball = cache_dir.join(&filename);\n-    let (base_url, url, should_verify) = match mode {\n-        DownloadSource::CI => (\n-            builder.config.stage0_metadata.config.artifacts_server.clone(),\n-            format!(\"{key}/{filename}\"),\n-            false,\n-        ),\n-        DownloadSource::Dist => {\n-            let dist_server = env::var(\"RUSTUP_DIST_SERVER\")\n-                .unwrap_or(builder.config.stage0_metadata.config.dist_server.to_string());\n-            // NOTE: make `dist` part of the URL because that's how it's stored in src/stage0.json\n-            (dist_server, format!(\"dist/{key}/{filename}\"), true)\n-        }\n-    };\n-\n-    // For the beta compiler, put special effort into ensuring the checksums are valid.\n-    // FIXME: maybe we should do this for download-rustc as well? but it would be a pain to update\n-    // this on each and every nightly ...\n-    let checksum = if should_verify {\n-        let error = format!(\n-            \"src/stage0.json doesn't contain a checksum for {url}. \\\n-            Pre-built artifacts might not be available for this \\\n-            target at this time, see https://doc.rust-lang.org/nightly\\\n-            /rustc/platform-support.html for more information.\"\n-        );\n-        let sha256 = builder.config.stage0_metadata.checksums_sha256.get(&url).expect(&error);\n-        if tarball.exists() {\n-            if builder.verify(&tarball, sha256) {\n-                builder.unpack(&tarball, &bin_root, prefix);\n-                return;\n-            } else {\n-                builder.verbose(&format!(\n-                    \"ignoring cached file {} due to failed verification\",\n-                    tarball.display()\n-                ));\n-                builder.remove(&tarball);\n-            }\n-        }\n-        Some(sha256)\n-    } else if tarball.exists() {\n-        builder.unpack(&tarball, &bin_root, prefix);\n-        return;\n-    } else {\n-        None\n-    };\n-\n-    builder.download_component(&format!(\"{base_url}/{url}\"), &tarball, \"\");\n-    if let Some(sha256) = checksum {\n-        if !builder.verify(&tarball, sha256) {\n-            panic!(\"failed to verify {}\", tarball.display());\n-        }\n+fn threads_from_config(v: u32) -> u32 {\n+    match v {\n+        0 => std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get) as u32,\n+        n => n,\n     }\n-\n-    builder.unpack(&tarball, &bin_root, prefix);\n }"}, {"sha": "aacd2c7eab9814dc960f19ebaa2704e15a81c748", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=f90a4ff26c9743abf612f015c4398d7158b646b6", "patch": "@@ -924,13 +924,13 @@ impl Step for PlainSourceTarball {\n \n         // Create the version file\n         builder.create(&plain_dst_src.join(\"version\"), &builder.rust_version());\n-        if let Some(info) = builder.rust_info.info() {\n+        if let Some(info) = builder.rust_info().info() {\n             channel::write_commit_hash_file(&plain_dst_src, &info.sha);\n             channel::write_commit_info_file(&plain_dst_src, info);\n         }\n \n         // If we're building from git sources, we need to vendor a complete distribution.\n-        if builder.rust_info.is_managed_git_subrepository() {\n+        if builder.rust_info().is_managed_git_subrepository() {\n             // Ensure we have the submodules checked out.\n             builder.update_submodule(Path::new(\"src/tools/rust-analyzer\"));\n "}, {"sha": "3180a12c85be759984d013d5a5907127a4e0e373", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=f90a4ff26c9743abf612f015c4398d7158b646b6", "patch": "@@ -405,8 +405,8 @@ impl Step for SharedAssets {\n         if !builder.config.dry_run() && !up_to_date(&version_input, &version_info) {\n             let info = t!(fs::read_to_string(&version_input))\n                 .replace(\"VERSION\", &builder.rust_release())\n-                .replace(\"SHORT_HASH\", builder.rust_info.sha_short().unwrap_or(\"\"))\n-                .replace(\"STAMP\", builder.rust_info.sha().unwrap_or(\"\"));\n+                .replace(\"SHORT_HASH\", builder.rust_info().sha_short().unwrap_or(\"\"))\n+                .replace(\"STAMP\", builder.rust_info().sha().unwrap_or(\"\"));\n             t!(fs::write(&version_info, &info));\n         }\n \n@@ -965,7 +965,7 @@ impl Step for RustcBook {\n         cmd.arg(\"--rustc\");\n         cmd.arg(&rustc);\n         cmd.arg(\"--rustc-target\").arg(&self.target.rustc_target_arg());\n-        if builder.config.verbose() {\n+        if builder.is_verbose() {\n             cmd.arg(\"--verbose\");\n         }\n         if self.validate {"}, {"sha": "d0f389df973443346b452ddaa4415605c3efd011", "filename": "src/bootstrap/download.rs", "status": "added", "additions": 519, "deletions": 0, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=f90a4ff26c9743abf612f015c4398d7158b646b6", "patch": "@@ -0,0 +1,519 @@\n+use std::{\n+    env,\n+    ffi::{OsStr, OsString},\n+    fs::{self, File},\n+    io::{BufRead, BufReader, ErrorKind},\n+    path::{Path, PathBuf},\n+    process::{Command, Stdio},\n+};\n+\n+use once_cell::sync::OnceCell;\n+use xz2::bufread::XzDecoder;\n+\n+use crate::{\n+    config::RustfmtMetadata,\n+    native::detect_llvm_sha,\n+    t,\n+    util::{check_run, exe, program_out_of_date, try_run},\n+    Config,\n+};\n+\n+/// Generic helpers that are useful anywhere in bootstrap.\n+impl Config {\n+    pub fn is_verbose(&self) -> bool {\n+        self.verbose > 0\n+    }\n+\n+    pub(crate) fn create(&self, path: &Path, s: &str) {\n+        if self.dry_run() {\n+            return;\n+        }\n+        t!(fs::write(path, s));\n+    }\n+\n+    pub(crate) fn remove(&self, f: &Path) {\n+        if self.dry_run() {\n+            return;\n+        }\n+        fs::remove_file(f).unwrap_or_else(|_| panic!(\"failed to remove {:?}\", f));\n+    }\n+\n+    /// Create a temporary directory in `out` and return its path.\n+    ///\n+    /// NOTE: this temporary directory is shared between all steps;\n+    /// if you need an empty directory, create a new subdirectory inside it.\n+    pub(crate) fn tempdir(&self) -> PathBuf {\n+        let tmp = self.out.join(\"tmp\");\n+        t!(fs::create_dir_all(&tmp));\n+        tmp\n+    }\n+\n+    /// Runs a command, printing out nice contextual information if it fails.\n+    /// Exits if the command failed to execute at all, otherwise returns its\n+    /// `status.success()`.\n+    pub(crate) fn try_run(&self, cmd: &mut Command) -> bool {\n+        if self.dry_run() {\n+            return true;\n+        }\n+        self.verbose(&format!(\"running: {:?}\", cmd));\n+        try_run(cmd, self.is_verbose())\n+    }\n+\n+    /// Runs a command, printing out nice contextual information if it fails.\n+    /// Returns false if do not execute at all, otherwise returns its\n+    /// `status.success()`.\n+    pub(crate) fn check_run(&self, cmd: &mut Command) -> bool {\n+        if self.dry_run() {\n+            return true;\n+        }\n+        self.verbose(&format!(\"running: {:?}\", cmd));\n+        check_run(cmd, self.is_verbose())\n+    }\n+\n+    /// Modifies the interpreter section of 'fname' to fix the dynamic linker,\n+    /// or the RPATH section, to fix the dynamic library search path\n+    ///\n+    /// This is only required on NixOS and uses the PatchELF utility to\n+    /// change the interpreter/RPATH of ELF executables.\n+    ///\n+    /// Please see https://nixos.org/patchelf.html for more information\n+    fn fix_bin_or_dylib(&self, fname: &Path) {\n+        // FIXME: cache NixOS detection?\n+        match Command::new(\"uname\").arg(\"-s\").stderr(Stdio::inherit()).output() {\n+            Err(_) => return,\n+            Ok(output) if !output.status.success() => return,\n+            Ok(output) => {\n+                let mut s = output.stdout;\n+                if s.last() == Some(&b'\\n') {\n+                    s.pop();\n+                }\n+                if s != b\"Linux\" {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        // If the user has asked binaries to be patched for Nix, then\n+        // don't check for NixOS or `/lib`, just continue to the patching.\n+        // NOTE: this intentionally comes after the Linux check:\n+        // - patchelf only works with ELF files, so no need to run it on Mac or Windows\n+        // - On other Unix systems, there is no stable syscall interface, so Nix doesn't manage the global libc.\n+        if !self.patch_binaries_for_nix {\n+            // Use `/etc/os-release` instead of `/etc/NIXOS`.\n+            // The latter one does not exist on NixOS when using tmpfs as root.\n+            const NIX_IDS: &[&str] = &[\"ID=nixos\", \"ID='nixos'\", \"ID=\\\"nixos\\\"\"];\n+            let os_release = match File::open(\"/etc/os-release\") {\n+                Err(e) if e.kind() == ErrorKind::NotFound => return,\n+                Err(e) => panic!(\"failed to access /etc/os-release: {}\", e),\n+                Ok(f) => f,\n+            };\n+            if !BufReader::new(os_release).lines().any(|l| NIX_IDS.contains(&t!(l).trim())) {\n+                return;\n+            }\n+            if Path::new(\"/lib\").exists() {\n+                return;\n+            }\n+        }\n+\n+        // At this point we're pretty sure the user is running NixOS or using Nix\n+        println!(\"info: you seem to be using Nix. Attempting to patch {}\", fname.display());\n+\n+        // Only build `.nix-deps` once.\n+        static NIX_DEPS_DIR: OnceCell<PathBuf> = OnceCell::new();\n+        let mut nix_build_succeeded = true;\n+        let nix_deps_dir = NIX_DEPS_DIR.get_or_init(|| {\n+            // Run `nix-build` to \"build\" each dependency (which will likely reuse\n+            // the existing `/nix/store` copy, or at most download a pre-built copy).\n+            //\n+            // Importantly, we create a gc-root called `.nix-deps` in the `build/`\n+            // directory, but still reference the actual `/nix/store` path in the rpath\n+            // as it makes it significantly more robust against changes to the location of\n+            // the `.nix-deps` location.\n+            //\n+            // bintools: Needed for the path of `ld-linux.so` (via `nix-support/dynamic-linker`).\n+            // zlib: Needed as a system dependency of `libLLVM-*.so`.\n+            // patchelf: Needed for patching ELF binaries (see doc comment above).\n+            let nix_deps_dir = self.out.join(\".nix-deps\");\n+            const NIX_EXPR: &str = \"\n+            with (import <nixpkgs> {});\n+            symlinkJoin {\n+                name = \\\"rust-stage0-dependencies\\\";\n+                paths = [\n+                    zlib\n+                    patchelf\n+                    stdenv.cc.bintools\n+                ];\n+            }\n+            \";\n+            nix_build_succeeded = self.try_run(Command::new(\"nix-build\").args(&[\n+                Path::new(\"-E\"),\n+                Path::new(NIX_EXPR),\n+                Path::new(\"-o\"),\n+                &nix_deps_dir,\n+            ]));\n+            nix_deps_dir\n+        });\n+        if !nix_build_succeeded {\n+            return;\n+        }\n+\n+        let mut patchelf = Command::new(nix_deps_dir.join(\"bin/patchelf\"));\n+        let rpath_entries = {\n+            // ORIGIN is a relative default, all binary and dynamic libraries we ship\n+            // appear to have this (even when `../lib` is redundant).\n+            // NOTE: there are only two paths here, delimited by a `:`\n+            let mut entries = OsString::from(\"$ORIGIN/../lib:\");\n+            entries.push(t!(fs::canonicalize(nix_deps_dir)));\n+            entries.push(\"/lib\");\n+            entries\n+        };\n+        patchelf.args(&[OsString::from(\"--set-rpath\"), rpath_entries]);\n+        if !fname.extension().map_or(false, |ext| ext == \"so\") {\n+            // Finally, set the correct .interp for binaries\n+            let dynamic_linker_path = nix_deps_dir.join(\"nix-support/dynamic-linker\");\n+            // FIXME: can we support utf8 here? `args` doesn't accept Vec<u8>, only OsString ...\n+            let dynamic_linker = t!(String::from_utf8(t!(fs::read(dynamic_linker_path))));\n+            patchelf.args(&[\"--set-interpreter\", dynamic_linker.trim_end()]);\n+        }\n+\n+        self.try_run(patchelf.arg(fname));\n+    }\n+\n+    fn download_file(&self, url: &str, dest_path: &Path, help_on_error: &str) {\n+        self.verbose(&format!(\"download {url}\"));\n+        // Use a temporary file in case we crash while downloading, to avoid a corrupt download in cache/.\n+        let tempfile = self.tempdir().join(dest_path.file_name().unwrap());\n+        // While bootstrap itself only supports http and https downloads, downstream forks might\n+        // need to download components from other protocols. The match allows them adding more\n+        // protocols without worrying about merge conflicts if we change the HTTP implementation.\n+        match url.split_once(\"://\").map(|(proto, _)| proto) {\n+            Some(\"http\") | Some(\"https\") => {\n+                self.download_http_with_retries(&tempfile, url, help_on_error)\n+            }\n+            Some(other) => panic!(\"unsupported protocol {other} in {url}\"),\n+            None => panic!(\"no protocol in {url}\"),\n+        }\n+        t!(std::fs::rename(&tempfile, dest_path));\n+    }\n+\n+    fn download_http_with_retries(&self, tempfile: &Path, url: &str, help_on_error: &str) {\n+        println!(\"downloading {}\", url);\n+        // Try curl. If that fails and we are on windows, fallback to PowerShell.\n+        let mut curl = Command::new(\"curl\");\n+        curl.args(&[\n+            \"-#\",\n+            \"-y\",\n+            \"30\",\n+            \"-Y\",\n+            \"10\", // timeout if speed is < 10 bytes/sec for > 30 seconds\n+            \"--connect-timeout\",\n+            \"30\", // timeout if cannot connect within 30 seconds\n+            \"--retry\",\n+            \"3\",\n+            \"-Sf\",\n+            \"-o\",\n+        ]);\n+        curl.arg(tempfile);\n+        curl.arg(url);\n+        if !self.check_run(&mut curl) {\n+            if self.build.contains(\"windows-msvc\") {\n+                println!(\"Fallback to PowerShell\");\n+                for _ in 0..3 {\n+                    if self.try_run(Command::new(\"PowerShell.exe\").args(&[\n+                        \"/nologo\",\n+                        \"-Command\",\n+                        \"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\",\n+                        &format!(\n+                            \"(New-Object System.Net.WebClient).DownloadFile('{}', '{}')\",\n+                            url, tempfile.to_str().expect(\"invalid UTF-8 not supported with powershell downloads\"),\n+                        ),\n+                    ])) {\n+                        return;\n+                    }\n+                    println!(\"\\nspurious failure, trying again\");\n+                }\n+            }\n+            if !help_on_error.is_empty() {\n+                eprintln!(\"{}\", help_on_error);\n+            }\n+            crate::detail_exit(1);\n+        }\n+    }\n+\n+    fn unpack(&self, tarball: &Path, dst: &Path, pattern: &str) {\n+        println!(\"extracting {} to {}\", tarball.display(), dst.display());\n+        if !dst.exists() {\n+            t!(fs::create_dir_all(dst));\n+        }\n+\n+        // `tarball` ends with `.tar.xz`; strip that suffix\n+        // example: `rust-dev-nightly-x86_64-unknown-linux-gnu`\n+        let uncompressed_filename =\n+            Path::new(tarball.file_name().expect(\"missing tarball filename\")).file_stem().unwrap();\n+        let directory_prefix = Path::new(Path::new(uncompressed_filename).file_stem().unwrap());\n+\n+        // decompress the file\n+        let data = t!(File::open(tarball));\n+        let decompressor = XzDecoder::new(BufReader::new(data));\n+\n+        let mut tar = tar::Archive::new(decompressor);\n+        for member in t!(tar.entries()) {\n+            let mut member = t!(member);\n+            let original_path = t!(member.path()).into_owned();\n+            // skip the top-level directory\n+            if original_path == directory_prefix {\n+                continue;\n+            }\n+            let mut short_path = t!(original_path.strip_prefix(directory_prefix));\n+            if !short_path.starts_with(pattern) {\n+                continue;\n+            }\n+            short_path = t!(short_path.strip_prefix(pattern));\n+            let dst_path = dst.join(short_path);\n+            self.verbose(&format!(\"extracting {} to {}\", original_path.display(), dst.display()));\n+            if !t!(member.unpack_in(dst)) {\n+                panic!(\"path traversal attack ??\");\n+            }\n+            let src_path = dst.join(original_path);\n+            if src_path.is_dir() && dst_path.exists() {\n+                continue;\n+            }\n+            t!(fs::rename(src_path, dst_path));\n+        }\n+        t!(fs::remove_dir_all(dst.join(directory_prefix)));\n+    }\n+\n+    /// Returns whether the SHA256 checksum of `path` matches `expected`.\n+    fn verify(&self, path: &Path, expected: &str) -> bool {\n+        use sha2::Digest;\n+\n+        self.verbose(&format!(\"verifying {}\", path.display()));\n+        let mut hasher = sha2::Sha256::new();\n+        // FIXME: this is ok for rustfmt (4.1 MB large at time of writing), but it seems memory-intensive for rustc and larger components.\n+        // Consider using streaming IO instead?\n+        let contents = if self.dry_run() { vec![] } else { t!(fs::read(path)) };\n+        hasher.update(&contents);\n+        let found = hex::encode(hasher.finalize().as_slice());\n+        let verified = found == expected;\n+        if !verified && !self.dry_run() {\n+            println!(\n+                \"invalid checksum: \\n\\\n+                found:    {found}\\n\\\n+                expected: {expected}\",\n+            );\n+        }\n+        return verified;\n+    }\n+}\n+\n+enum DownloadSource {\n+    CI,\n+    Dist,\n+}\n+\n+/// Functions that are only ever called once, but named for clarify and to avoid thousand-line functions.\n+impl Config {\n+    pub(crate) fn maybe_download_rustfmt(&self) -> Option<PathBuf> {\n+        let RustfmtMetadata { date, version } = self.stage0_metadata.rustfmt.as_ref()?;\n+        let channel = format!(\"{version}-{date}\");\n+\n+        let host = self.build;\n+        let rustfmt_path = self.initial_rustc.with_file_name(exe(\"rustfmt\", host));\n+        let bin_root = self.out.join(host.triple).join(\"stage0\");\n+        let rustfmt_stamp = bin_root.join(\".rustfmt-stamp\");\n+        if rustfmt_path.exists() && !program_out_of_date(&rustfmt_stamp, &channel) {\n+            return Some(rustfmt_path);\n+        }\n+\n+        let filename = format!(\"rustfmt-{version}-{build}.tar.xz\", build = host.triple);\n+        self.download_component(DownloadSource::Dist, filename, \"rustfmt-preview\", &date, \"stage0\");\n+\n+        self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustfmt\"));\n+        self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"cargo-fmt\"));\n+\n+        self.create(&rustfmt_stamp, &channel);\n+        Some(rustfmt_path)\n+    }\n+\n+    pub(crate) fn download_ci_rustc(&self, commit: &str) {\n+        self.verbose(&format!(\"using downloaded stage2 artifacts from CI (commit {commit})\"));\n+        let version = self.artifact_version_part(commit);\n+        let host = self.build.triple;\n+        let bin_root = self.out.join(host).join(\"ci-rustc\");\n+        let rustc_stamp = bin_root.join(\".rustc-stamp\");\n+\n+        if !bin_root.join(\"bin\").join(\"rustc\").exists() || program_out_of_date(&rustc_stamp, commit)\n+        {\n+            if bin_root.exists() {\n+                t!(fs::remove_dir_all(&bin_root));\n+            }\n+            let filename = format!(\"rust-std-{version}-{host}.tar.xz\");\n+            let pattern = format!(\"rust-std-{host}\");\n+            self.download_ci_component(filename, &pattern, commit);\n+            let filename = format!(\"rustc-{version}-{host}.tar.xz\");\n+            self.download_ci_component(filename, \"rustc\", commit);\n+            // download-rustc doesn't need its own cargo, it can just use beta's.\n+            let filename = format!(\"rustc-dev-{version}-{host}.tar.xz\");\n+            self.download_ci_component(filename, \"rustc-dev\", commit);\n+            let filename = format!(\"rust-src-{version}.tar.xz\");\n+            self.download_ci_component(filename, \"rust-src\", commit);\n+\n+            self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));\n+            self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustdoc\"));\n+            let lib_dir = bin_root.join(\"lib\");\n+            for lib in t!(fs::read_dir(&lib_dir), lib_dir.display().to_string()) {\n+                let lib = t!(lib);\n+                if lib.path().extension() == Some(OsStr::new(\"so\")) {\n+                    self.fix_bin_or_dylib(&lib.path());\n+                }\n+            }\n+            t!(fs::write(rustc_stamp, commit));\n+        }\n+    }\n+\n+    /// Download a single component of a CI-built toolchain (not necessarily a published nightly).\n+    // NOTE: intentionally takes an owned string to avoid downloading multiple times by accident\n+    fn download_ci_component(&self, filename: String, prefix: &str, commit: &str) {\n+        Self::download_component(self, DownloadSource::CI, filename, prefix, commit, \"ci-rustc\")\n+    }\n+\n+    fn download_component(\n+        &self,\n+        mode: DownloadSource,\n+        filename: String,\n+        prefix: &str,\n+        key: &str,\n+        destination: &str,\n+    ) {\n+        let cache_dst = self.out.join(\"cache\");\n+        let cache_dir = cache_dst.join(key);\n+        if !cache_dir.exists() {\n+            t!(fs::create_dir_all(&cache_dir));\n+        }\n+\n+        let bin_root = self.out.join(self.build.triple).join(destination);\n+        let tarball = cache_dir.join(&filename);\n+        let (base_url, url, should_verify) = match mode {\n+            DownloadSource::CI => (\n+                self.stage0_metadata.config.artifacts_server.clone(),\n+                format!(\"{key}/{filename}\"),\n+                false,\n+            ),\n+            DownloadSource::Dist => {\n+                let dist_server = env::var(\"RUSTUP_DIST_SERVER\")\n+                    .unwrap_or(self.stage0_metadata.config.dist_server.to_string());\n+                // NOTE: make `dist` part of the URL because that's how it's stored in src/stage0.json\n+                (dist_server, format!(\"dist/{key}/{filename}\"), true)\n+            }\n+        };\n+\n+        // For the beta compiler, put special effort into ensuring the checksums are valid.\n+        // FIXME: maybe we should do this for download-rustc as well? but it would be a pain to update\n+        // this on each and every nightly ...\n+        let checksum = if should_verify {\n+            let error = format!(\n+                \"src/stage0.json doesn't contain a checksum for {url}. \\\n+                Pre-built artifacts might not be available for this \\\n+                target at this time, see https://doc.rust-lang.org/nightly\\\n+                /rustc/platform-support.html for more information.\"\n+            );\n+            let sha256 = self.stage0_metadata.checksums_sha256.get(&url).expect(&error);\n+            if tarball.exists() {\n+                if self.verify(&tarball, sha256) {\n+                    self.unpack(&tarball, &bin_root, prefix);\n+                    return;\n+                } else {\n+                    self.verbose(&format!(\n+                        \"ignoring cached file {} due to failed verification\",\n+                        tarball.display()\n+                    ));\n+                    self.remove(&tarball);\n+                }\n+            }\n+            Some(sha256)\n+        } else if tarball.exists() {\n+            self.unpack(&tarball, &bin_root, prefix);\n+            return;\n+        } else {\n+            None\n+        };\n+\n+        self.download_file(&format!(\"{base_url}/{url}\"), &tarball, \"\");\n+        if let Some(sha256) = checksum {\n+            if !self.verify(&tarball, sha256) {\n+                panic!(\"failed to verify {}\", tarball.display());\n+            }\n+        }\n+\n+        self.unpack(&tarball, &bin_root, prefix);\n+    }\n+\n+    pub(crate) fn maybe_download_ci_llvm(&self) {\n+        if !self.llvm_from_ci {\n+            return;\n+        }\n+        let llvm_root = self.ci_llvm_root();\n+        let llvm_stamp = llvm_root.join(\".llvm-stamp\");\n+        let llvm_sha = detect_llvm_sha(&self, self.rust_info.is_managed_git_subrepository());\n+        let key = format!(\"{}{}\", llvm_sha, self.llvm_assertions);\n+        if program_out_of_date(&llvm_stamp, &key) && !self.dry_run() {\n+            self.download_ci_llvm(&llvm_sha);\n+            for entry in t!(fs::read_dir(llvm_root.join(\"bin\"))) {\n+                self.fix_bin_or_dylib(&t!(entry).path());\n+            }\n+\n+            // Update the timestamp of llvm-config to force rustc_llvm to be\n+            // rebuilt. This is a hacky workaround for a deficiency in Cargo where\n+            // the rerun-if-changed directive doesn't handle changes very well.\n+            // https://github.com/rust-lang/cargo/issues/10791\n+            // Cargo only compares the timestamp of the file relative to the last\n+            // time `rustc_llvm` build script ran. However, the timestamps of the\n+            // files in the tarball are in the past, so it doesn't trigger a\n+            // rebuild.\n+            let now = filetime::FileTime::from_system_time(std::time::SystemTime::now());\n+            let llvm_config = llvm_root.join(\"bin\").join(exe(\"llvm-config\", self.build));\n+            t!(filetime::set_file_times(&llvm_config, now, now));\n+\n+            let llvm_lib = llvm_root.join(\"lib\");\n+            for entry in t!(fs::read_dir(&llvm_lib)) {\n+                let lib = t!(entry).path();\n+                if lib.extension().map_or(false, |ext| ext == \"so\") {\n+                    self.fix_bin_or_dylib(&lib);\n+                }\n+            }\n+            t!(fs::write(llvm_stamp, key));\n+        }\n+    }\n+\n+    fn download_ci_llvm(&self, llvm_sha: &str) {\n+        let llvm_assertions = self.llvm_assertions;\n+\n+        let cache_prefix = format!(\"llvm-{}-{}\", llvm_sha, llvm_assertions);\n+        let cache_dst = self.out.join(\"cache\");\n+        let rustc_cache = cache_dst.join(cache_prefix);\n+        if !rustc_cache.exists() {\n+            t!(fs::create_dir_all(&rustc_cache));\n+        }\n+        let base = if llvm_assertions {\n+            &self.stage0_metadata.config.artifacts_with_llvm_assertions_server\n+        } else {\n+            &self.stage0_metadata.config.artifacts_server\n+        };\n+        let version = self.artifact_version_part(llvm_sha);\n+        let filename = format!(\"rust-dev-{}-{}.tar.xz\", version, self.build.triple);\n+        let tarball = rustc_cache.join(&filename);\n+        if !tarball.exists() {\n+            let help_on_error = \"error: failed to download llvm from ci\n+\n+    help: old builds get deleted after a certain time\n+    help: if trying to compile an old commit of rustc, disable `download-ci-llvm` in config.toml:\n+\n+    [llvm]\n+    download-ci-llvm = false\n+    \";\n+            self.download_file(&format!(\"{base}/{llvm_sha}/{filename}\"), &tarball, help_on_error);\n+        }\n+        let llvm_root = self.ci_llvm_root();\n+        self.unpack(&tarball, &llvm_root, \"rust-dev\");\n+    }\n+}"}, {"sha": "f4fa556b97450e56fa4c979e45e74c4f73b89e3d", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 34, "deletions": 67, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=f90a4ff26c9743abf612f015c4398d7158b646b6", "patch": "@@ -112,15 +112,14 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::str;\n \n+use channel::GitInfo;\n use config::{DryRun, Target};\n use filetime::FileTime;\n use once_cell::sync::OnceCell;\n \n use crate::builder::Kind;\n use crate::config::{LlvmLibunwind, TargetSelection};\n-use crate::util::{\n-    check_run, exe, libdir, mtime, output, run, run_suppressed, try_run, try_run_suppressed, CiEnv,\n-};\n+use crate::util::{exe, libdir, mtime, output, run, run_suppressed, try_run_suppressed, CiEnv};\n \n mod bolt;\n mod builder;\n@@ -133,6 +132,7 @@ mod compile;\n mod config;\n mod dist;\n mod doc;\n+mod download;\n mod flags;\n mod format;\n mod install;\n@@ -281,7 +281,6 @@ pub struct Build {\n     src: PathBuf,\n     out: PathBuf,\n     bootstrap_out: PathBuf,\n-    rust_info: channel::GitInfo,\n     cargo_info: channel::GitInfo,\n     rust_analyzer_info: channel::GitInfo,\n     clippy_info: channel::GitInfo,\n@@ -396,6 +395,28 @@ pub enum CLang {\n     Cxx,\n }\n \n+macro_rules! forward {\n+    ( $( $fn:ident( $($param:ident: $ty:ty),* ) $( -> $ret:ty)? ),+ $(,)? ) => {\n+        impl Build {\n+            $( fn $fn(&self, $($param: $ty),* ) $( -> $ret)? {\n+                self.config.$fn( $($param),* )\n+            } )+\n+        }\n+    }\n+}\n+\n+forward! {\n+    verbose(msg: &str),\n+    is_verbose() -> bool,\n+    create(path: &Path, s: &str),\n+    remove(f: &Path),\n+    tempdir() -> PathBuf,\n+    try_run(cmd: &mut Command) -> bool,\n+    llvm_link_shared() -> bool,\n+    download_rustc() -> bool,\n+    initial_rustfmt() -> Option<PathBuf>,\n+}\n+\n impl Build {\n     /// Creates a new set of build configuration from the `flags` on the command\n     /// line and the filesystem `config`.\n@@ -499,7 +520,6 @@ impl Build {\n             out,\n             bootstrap_out,\n \n-            rust_info,\n             cargo_info,\n             rust_analyzer_info,\n             clippy_info,\n@@ -570,7 +590,7 @@ impl Build {\n             t!(std::fs::read_dir(dir)).next().is_none()\n         }\n \n-        if !self.config.submodules(&self.rust_info) {\n+        if !self.config.submodules(&self.rust_info()) {\n             return;\n         }\n \n@@ -636,7 +656,7 @@ impl Build {\n     /// This avoids contributors checking in a submodule change by accident.\n     pub fn maybe_update_submodules(&self) {\n         // Avoid running git when there isn't a git checkout.\n-        if !self.config.submodules(&self.rust_info) {\n+        if !self.config.submodules(&self.rust_info()) {\n             return;\n         }\n         let output = output(\n@@ -735,6 +755,10 @@ impl Build {\n         cleared\n     }\n \n+    fn rust_info(&self) -> &GitInfo {\n+        &self.config.rust_info\n+    }\n+\n     /// Gets the space-separated set of activated features for the standard\n     /// library.\n     fn std_features(&self, target: TargetSelection) -> String {\n@@ -963,17 +987,6 @@ impl Build {\n         run_suppressed(cmd)\n     }\n \n-    /// Runs a command, printing out nice contextual information if it fails.\n-    /// Exits if the command failed to execute at all, otherwise returns its\n-    /// `status.success()`.\n-    fn try_run(&self, cmd: &mut Command) -> bool {\n-        if self.config.dry_run() {\n-            return true;\n-        }\n-        self.verbose(&format!(\"running: {:?}\", cmd));\n-        try_run(cmd, self.is_verbose())\n-    }\n-\n     /// Runs a command, printing out nice contextual information if it fails.\n     /// Exits if the command failed to execute at all, otherwise returns its\n     /// `status.success()`.\n@@ -985,28 +998,6 @@ impl Build {\n         try_run_suppressed(cmd)\n     }\n \n-    /// Runs a command, printing out nice contextual information if it fails.\n-    /// Returns false if do not execute at all, otherwise returns its\n-    /// `status.success()`.\n-    fn check_run(&self, cmd: &mut Command) -> bool {\n-        if self.config.dry_run() {\n-            return true;\n-        }\n-        self.verbose(&format!(\"running: {:?}\", cmd));\n-        check_run(cmd, self.is_verbose())\n-    }\n-\n-    pub fn is_verbose(&self) -> bool {\n-        self.verbosity > 0\n-    }\n-\n-    /// Prints a message if this build is configured in verbose mode.\n-    fn verbose(&self, msg: &str) {\n-        if self.is_verbose() {\n-            println!(\"{}\", msg);\n-        }\n-    }\n-\n     pub fn is_verbose_than(&self, level: usize) -> bool {\n         self.verbosity > level\n     }\n@@ -1269,7 +1260,7 @@ impl Build {\n         match &self.config.channel[..] {\n             \"stable\" => num.to_string(),\n             \"beta\" => {\n-                if self.rust_info.is_managed_git_subrepository() && !self.config.ignore_git {\n+                if self.rust_info().is_managed_git_subrepository() && !self.config.ignore_git {\n                     format!(\"{}-beta.{}\", num, self.beta_prerelease_version())\n                 } else {\n                     format!(\"{}-beta\", num)\n@@ -1329,7 +1320,7 @@ impl Build {\n     /// Note that this is a descriptive string which includes the commit date,\n     /// sha, version, etc.\n     fn rust_version(&self) -> String {\n-        let mut version = self.rust_info.version(self, &self.version);\n+        let mut version = self.rust_info().version(self, &self.version);\n         if let Some(ref s) = self.config.description {\n             version.push_str(\" (\");\n             version.push_str(s);\n@@ -1340,7 +1331,7 @@ impl Build {\n \n     /// Returns the full commit hash.\n     fn rust_sha(&self) -> Option<&str> {\n-        self.rust_info.sha()\n+        self.rust_info().sha()\n     }\n \n     /// Returns the `a.b.c` version that the given package is at.\n@@ -1426,16 +1417,6 @@ impl Build {\n         paths\n     }\n \n-    /// Create a temporary directory in `out` and return its path.\n-    ///\n-    /// NOTE: this temporary directory is shared between all steps;\n-    /// if you need an empty directory, create a new subdirectory inside it.\n-    fn tempdir(&self) -> PathBuf {\n-        let tmp = self.out.join(\"tmp\");\n-        t!(fs::create_dir_all(&tmp));\n-        tmp\n-    }\n-\n     /// Copies a file from `src` to `dst`\n     pub fn copy(&self, src: &Path, dst: &Path) {\n         self.copy_internal(src, dst, false);\n@@ -1545,13 +1526,6 @@ impl Build {\n         chmod(&dst, perms);\n     }\n \n-    fn create(&self, path: &Path, s: &str) {\n-        if self.config.dry_run() {\n-            return;\n-        }\n-        t!(fs::write(path, s));\n-    }\n-\n     fn read(&self, path: &Path) -> String {\n         if self.config.dry_run() {\n             return String::new();\n@@ -1590,13 +1564,6 @@ impl Build {\n         if !self.config.dry_run() { symlink_file(src.as_ref(), link.as_ref()) } else { Ok(()) }\n     }\n \n-    fn remove(&self, f: &Path) {\n-        if self.config.dry_run() {\n-            return;\n-        }\n-        fs::remove_file(f).unwrap_or_else(|_| panic!(\"failed to remove {:?}\", f));\n-    }\n-\n     /// Returns if config.ninja is enabled, and checks for ninja existence,\n     /// exiting with a nicer error message if not.\n     fn ninja(&self) -> bool {"}, {"sha": "f6c453ebe107bd6f6f2309b42065d801528624e6", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 5, "deletions": 79, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=f90a4ff26c9743abf612f015c4398d7158b646b6", "patch": "@@ -19,9 +19,9 @@ use std::process::Command;\n use crate::bolt::{instrument_with_bolt_inplace, optimize_library_with_bolt_inplace};\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::channel;\n-use crate::config::TargetSelection;\n+use crate::config::{Config, TargetSelection};\n use crate::util::get_clang_cl_resource_dir;\n-use crate::util::{self, exe, output, program_out_of_date, t, up_to_date};\n+use crate::util::{self, exe, output, t, up_to_date};\n use crate::{CLang, GitRepo};\n \n pub struct Meta {\n@@ -65,7 +65,7 @@ pub fn prebuilt_llvm_config(\n     builder: &Builder<'_>,\n     target: TargetSelection,\n ) -> Result<PathBuf, Meta> {\n-    maybe_download_ci_llvm(builder);\n+    builder.config.maybe_download_ci_llvm();\n \n     // If we're using a custom LLVM bail out here, but we can only use a\n     // custom LLVM for the build triple.\n@@ -117,7 +117,7 @@ pub fn prebuilt_llvm_config(\n }\n \n /// This retrieves the LLVM sha we *want* to use, according to git history.\n-pub(crate) fn detect_llvm_sha(config: &crate::config::Config, is_git: bool) -> String {\n+pub(crate) fn detect_llvm_sha(config: &Config, is_git: bool) -> String {\n     let llvm_sha = if is_git {\n         let mut rev_list = config.git();\n         rev_list.args(&[\n@@ -155,7 +155,7 @@ pub(crate) fn detect_llvm_sha(config: &crate::config::Config, is_git: bool) -> S\n /// This checks both the build triple platform to confirm we're usable at all,\n /// and then verifies if the current HEAD matches the detected LLVM SHA head,\n /// in which case LLVM is indicated as not available.\n-pub(crate) fn is_ci_llvm_available(config: &crate::config::Config, asserts: bool) -> bool {\n+pub(crate) fn is_ci_llvm_available(config: &Config, asserts: bool) -> bool {\n     // This is currently all tier 1 targets and tier 2 targets with host tools\n     // (since others may not have CI artifacts)\n     // https://doc.rust-lang.org/rustc/platform-support.html#tier-1\n@@ -217,80 +217,6 @@ pub(crate) fn is_ci_llvm_available(config: &crate::config::Config, asserts: bool\n     true\n }\n \n-pub(crate) fn maybe_download_ci_llvm(builder: &Builder<'_>) {\n-    let config = &builder.config;\n-    if !config.llvm_from_ci {\n-        return;\n-    }\n-    let llvm_root = config.ci_llvm_root();\n-    let llvm_stamp = llvm_root.join(\".llvm-stamp\");\n-    let llvm_sha = detect_llvm_sha(&config, builder.rust_info.is_managed_git_subrepository());\n-    let key = format!(\"{}{}\", llvm_sha, config.llvm_assertions);\n-    if program_out_of_date(&llvm_stamp, &key) && !config.dry_run() {\n-        download_ci_llvm(builder, &llvm_sha);\n-        for entry in t!(fs::read_dir(llvm_root.join(\"bin\"))) {\n-            builder.fix_bin_or_dylib(&t!(entry).path());\n-        }\n-\n-        // Update the timestamp of llvm-config to force rustc_llvm to be\n-        // rebuilt. This is a hacky workaround for a deficiency in Cargo where\n-        // the rerun-if-changed directive doesn't handle changes very well.\n-        // https://github.com/rust-lang/cargo/issues/10791\n-        // Cargo only compares the timestamp of the file relative to the last\n-        // time `rustc_llvm` build script ran. However, the timestamps of the\n-        // files in the tarball are in the past, so it doesn't trigger a\n-        // rebuild.\n-        let now = filetime::FileTime::from_system_time(std::time::SystemTime::now());\n-        let llvm_config = llvm_root.join(\"bin\").join(exe(\"llvm-config\", builder.config.build));\n-        t!(filetime::set_file_times(&llvm_config, now, now));\n-\n-        let llvm_lib = llvm_root.join(\"lib\");\n-        for entry in t!(fs::read_dir(&llvm_lib)) {\n-            let lib = t!(entry).path();\n-            if lib.extension().map_or(false, |ext| ext == \"so\") {\n-                builder.fix_bin_or_dylib(&lib);\n-            }\n-        }\n-        t!(fs::write(llvm_stamp, key));\n-    }\n-}\n-\n-fn download_ci_llvm(builder: &Builder<'_>, llvm_sha: &str) {\n-    let llvm_assertions = builder.config.llvm_assertions;\n-\n-    let cache_prefix = format!(\"llvm-{}-{}\", llvm_sha, llvm_assertions);\n-    let cache_dst = builder.out.join(\"cache\");\n-    let rustc_cache = cache_dst.join(cache_prefix);\n-    if !rustc_cache.exists() {\n-        t!(fs::create_dir_all(&rustc_cache));\n-    }\n-    let base = if llvm_assertions {\n-        &builder.config.stage0_metadata.config.artifacts_with_llvm_assertions_server\n-    } else {\n-        &builder.config.stage0_metadata.config.artifacts_server\n-    };\n-    let version = builder.config.artifact_version_part(builder, llvm_sha);\n-    let filename = format!(\"rust-dev-{}-{}.tar.xz\", version, builder.build.build.triple);\n-    let tarball = rustc_cache.join(&filename);\n-    if !tarball.exists() {\n-        let help_on_error = \"error: failed to download llvm from ci\n-\n-help: old builds get deleted after a certain time\n-help: if trying to compile an old commit of rustc, disable `download-ci-llvm` in config.toml:\n-\n-[llvm]\n-download-ci-llvm = false\n-\";\n-        builder.download_component(\n-            &format!(\"{base}/{llvm_sha}/{filename}\"),\n-            &tarball,\n-            help_on_error,\n-        );\n-    }\n-    let llvm_root = builder.config.ci_llvm_root();\n-    builder.unpack(&tarball, &llvm_root, \"rust-dev\");\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n     pub target: TargetSelection,"}, {"sha": "631d42acb93fc3564093496169d0a9b4012a9166", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=f90a4ff26c9743abf612f015c4398d7158b646b6", "patch": "@@ -74,7 +74,7 @@ pub fn check(build: &mut Build) {\n     let mut cmd_finder = Finder::new();\n     // If we've got a git directory we're gonna need git to update\n     // submodules and learn about various other aspects.\n-    if build.rust_info.is_managed_git_subrepository() {\n+    if build.rust_info().is_managed_git_subrepository() {\n         cmd_finder.must_have(\"git\");\n     }\n "}, {"sha": "fc850a22b2f6fb689904765165bcb344c4cccdb7", "filename": "src/bootstrap/tarball.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Ftarball.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a4ff26c9743abf612f015c4398d7158b646b6/src%2Fbootstrap%2Ftarball.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftarball.rs?ref=f90a4ff26c9743abf612f015c4398d7158b646b6", "patch": "@@ -298,7 +298,7 @@ impl<'a> Tarball<'a> {\n     fn run(self, build_cli: impl FnOnce(&Tarball<'a>, &mut Command)) -> GeneratedTarball {\n         t!(std::fs::create_dir_all(&self.overlay_dir));\n         self.builder.create(&self.overlay_dir.join(\"version\"), &self.overlay.version(self.builder));\n-        if let Some(info) = self.builder.rust_info.info() {\n+        if let Some(info) = self.builder.rust_info().info() {\n             channel::write_commit_hash_file(&self.overlay_dir, &info.sha);\n             channel::write_commit_info_file(&self.overlay_dir, info);\n         }"}]}