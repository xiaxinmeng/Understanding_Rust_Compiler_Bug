{"sha": "5498367faff37704b22f77dcf1cc10c89d42faba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0OTgzNjdmYWZmMzc3MDRiMjJmNzdkY2YxY2MxMGM4OWQ0MmZhYmE=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-08-18T00:27:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-18T00:27:42Z"}, "message": "Rollup merge of #75392 - TimDiekmann:non-null-uninit-slice, r=RalfJung\n\nAdd `as_uninit`-like methods to pointer types and unify documentation of `as_ref` methods\n\nThis adds a convenient method to retrieve a `&(mut) [MaybeUninit<T>]` from slice pointers (`*const [T]`, `*mut [T]`, `NonNull<[T]>`). See also https://github.com/rust-lang/wg-allocators/issues/66#issuecomment-671789105.\n\n~I'll add a tracking issue as soon as it's reviewed and CI passed.~\nTracking Issue: #75402\n\nr? @RalfJung", "tree": {"sha": "05c37a126b754ed04e3fb2071f06969234811cad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05c37a126b754ed04e3fb2071f06969234811cad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5498367faff37704b22f77dcf1cc10c89d42faba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfOyB+CRBK7hj4Ov3rIwAAdHIIACY4itXFcQWj1F6+PetiXKWE\nSQVYqKE5KbHLw4HP8WoD8gEvY1DZxz787r/szZwTPl/LOjnl/cA4OpIXVNRFQPK8\n9+Dl+1ojpqnickdAmK+cyAZAVNG8KRdjwVIzb4815DgOgkrSY3ZM0UbHPlNaBCOq\naA5FgKVwAWg2A7gTppZlLQNWtYjDb6iJO99Yj2NRz/HhmDPtmGTtNBcBvtNtLbDw\nFfEerMEA8KsFcSC1Q00vHGFWYSyNLTiXa+kZA1E4FBWRf/yBTSw73slxT/dZposS\nM+oQDl4z6R7agZ+t2NroayeucHsI/WtrDGxxUAOxtju4gHuZpEezcKgKGbvmkRo=\n=nOSM\n-----END PGP SIGNATURE-----\n", "payload": "tree 05c37a126b754ed04e3fb2071f06969234811cad\nparent 381a841d8d44696358c77645f593997139ca80f3\nparent 93e074bc8a0766afbe3594f8663d702638ec0c35\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1597710462 +0900\ncommitter GitHub <noreply@github.com> 1597710462 +0900\n\nRollup merge of #75392 - TimDiekmann:non-null-uninit-slice, r=RalfJung\n\nAdd `as_uninit`-like methods to pointer types and unify documentation of `as_ref` methods\n\nThis adds a convenient method to retrieve a `&(mut) [MaybeUninit<T>]` from slice pointers (`*const [T]`, `*mut [T]`, `NonNull<[T]>`). See also https://github.com/rust-lang/wg-allocators/issues/66#issuecomment-671789105.\n\n~I'll add a tracking issue as soon as it's reviewed and CI passed.~\nTracking Issue: #75402\n\nr? @RalfJung\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5498367faff37704b22f77dcf1cc10c89d42faba", "html_url": "https://github.com/rust-lang/rust/commit/5498367faff37704b22f77dcf1cc10c89d42faba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5498367faff37704b22f77dcf1cc10c89d42faba/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "381a841d8d44696358c77645f593997139ca80f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/381a841d8d44696358c77645f593997139ca80f3", "html_url": "https://github.com/rust-lang/rust/commit/381a841d8d44696358c77645f593997139ca80f3"}, {"sha": "93e074bc8a0766afbe3594f8663d702638ec0c35", "url": "https://api.github.com/repos/rust-lang/rust/commits/93e074bc8a0766afbe3594f8663d702638ec0c35", "html_url": "https://github.com/rust-lang/rust/commit/93e074bc8a0766afbe3594f8663d702638ec0c35"}], "stats": {"total": 649, "additions": 568, "deletions": 81}, "files": [{"sha": "3838fcf74ccd6f849e0358b68573f5c8075d8948", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5498367faff37704b22f77dcf1cc10c89d42faba/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5498367faff37704b22f77dcf1cc10c89d42faba/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=5498367faff37704b22f77dcf1cc10c89d42faba", "patch": "@@ -114,6 +114,7 @@\n #![feature(optin_builtin_traits)]\n #![feature(or_patterns)]\n #![feature(prelude_import)]\n+#![feature(ptr_as_uninit)]\n #![feature(repr_simd, platform_intrinsics)]\n #![feature(rustc_attrs)]\n #![feature(simd_ffi)]"}, {"sha": "7d7306574a6e87f80cff7884f9637ff38e4aeb12", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 117, "deletions": 17, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/5498367faff37704b22f77dcf1cc10c89d42faba/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5498367faff37704b22f77dcf1cc10c89d42faba/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=5498367faff37704b22f77dcf1cc10c89d42faba", "patch": "@@ -2,7 +2,7 @@ use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics;\n use crate::mem;\n-use crate::slice::SliceIndex;\n+use crate::slice::{self, SliceIndex};\n \n #[lang = \"const_ptr\"]\n impl<T: ?Sized> *const T {\n@@ -48,32 +48,33 @@ impl<T: ?Sized> *const T {\n         self as _\n     }\n \n-    /// Returns `None` if the pointer is null, or else returns a reference to\n-    /// the value wrapped in `Some`.\n+    /// Returns `None` if the pointer is null, or else returns a shared reference to\n+    /// the value wrapped in `Some`. If the value may be uninitialized, [`as_uninit_ref`]\n+    /// must be used instead.\n     ///\n-    /// # Safety\n+    /// [`as_uninit_ref`]: #method.as_uninit_ref\n     ///\n-    /// While this method and its mutable counterpart are useful for\n-    /// null-safety, it is important to note that this is still an unsafe\n-    /// operation because the returned value could be pointing to invalid\n-    /// memory.\n+    /// # Safety\n     ///\n     /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n     /// all of the following is true:\n-    /// - it is properly aligned\n-    /// - it must point to an initialized instance of T; in particular, the pointer must be\n-    ///   \"dereferenceable\" in the sense defined [here].\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * The pointer must point to an initialized instance of `T`.\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n     ///\n     /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n     /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n-    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n-    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n-    /// the memory the pointer points to must not get mutated (except inside `UnsafeCell`).\n-    ///\n-    /// [here]: crate::ptr#safety\n+    /// [the module documentation]: crate::ptr#safety\n     ///\n     /// # Examples\n     ///\n@@ -111,6 +112,56 @@ impl<T: ?Sized> *const T {\n         if self.is_null() { None } else { unsafe { Some(&*self) } }\n     }\n \n+    /// Returns `None` if the pointer is null, or else returns a shared reference to\n+    /// the value wrapped in `Some`. In contrast to [`as_ref`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// [`as_ref`]: #method.as_ref\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// [the module documentation]: crate::ptr#safety\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_as_uninit)]\n+    ///\n+    /// let ptr: *const u8 = &10u8 as *const u8;\n+    ///\n+    /// unsafe {\n+    ///     if let Some(val_back) = ptr.as_uninit_ref() {\n+    ///         println!(\"We got back the value: {}!\", val_back.assume_init());\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_ref<'a>(self) -> Option<&'a MaybeUninit<T>>\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        if self.is_null() { None } else { Some(unsafe { &*(self as *const MaybeUninit<T>) }) }\n+    }\n+\n     /// Calculates the offset from a pointer.\n     ///\n     /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n@@ -925,6 +976,55 @@ impl<T> *const [T] {\n         // SAFETY: the caller ensures that `self` is dereferencable and `index` in-bounds.\n         unsafe { index.get_unchecked(self) }\n     }\n+\n+    /// Returns `None` if the pointer is null, or else returns a shared slice to\n+    /// the value wrapped in `Some`. In contrast to [`as_ref`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// [`as_ref`]: #method.as_ref\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    ///\n+    /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n+    ///   and it must be properly aligned. This means in particular:\n+    ///\n+    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///       Slices can never span across multiple allocated objects.\n+    ///\n+    ///     * The pointer must be aligned even for zero-length slices. One\n+    ///       reason for this is that enum layout optimizations may rely on references\n+    ///       (including slices of any length) being aligned and non-null to distinguish\n+    ///       them from other data. You can obtain a pointer that is usable as `data`\n+    ///       for zero-length slices using [`NonNull::dangling()`].\n+    ///\n+    /// * The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+    ///   See the safety documentation of [`pointer::offset`].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// See also [`slice::from_raw_parts`][].\n+    ///\n+    /// [valid]: crate::ptr#safety\n+    /// [`NonNull::dangling()`]: NonNull::dangling\n+    /// [`pointer::offset`]: ../std/primitive.pointer.html#method.offset\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {\n+        if self.is_null() {\n+            None\n+        } else {\n+            // SAFETY: the caller must uphold the safety contract for `as_uninit_slice`.\n+            Some(unsafe { slice::from_raw_parts(self as *const MaybeUninit<T>, self.len()) })\n+        }\n+    }\n }\n \n // Equality for pointers"}, {"sha": "3daeec3604185b1bfbece98b9649ce445b08cd4c", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 238, "deletions": 35, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/5498367faff37704b22f77dcf1cc10c89d42faba/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5498367faff37704b22f77dcf1cc10c89d42faba/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=5498367faff37704b22f77dcf1cc10c89d42faba", "patch": "@@ -1,7 +1,7 @@\n use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics;\n-use crate::slice::SliceIndex;\n+use crate::slice::{self, SliceIndex};\n \n #[lang = \"mut_ptr\"]\n impl<T: ?Sized> *mut T {\n@@ -47,32 +47,36 @@ impl<T: ?Sized> *mut T {\n         self as _\n     }\n \n-    /// Returns `None` if the pointer is null, or else returns a reference to\n-    /// the value wrapped in `Some`.\n+    /// Returns `None` if the pointer is null, or else returns a shared reference to\n+    /// the value wrapped in `Some`. If the value may be uninitialized, [`as_uninit_ref`]\n+    /// must be used instead.\n     ///\n-    /// # Safety\n+    /// For the mutable counterpart see [`as_mut`].\n+    ///\n+    /// [`as_uninit_ref`]: #method.as_uninit_ref-1\n+    /// [`as_mut`]: #method.as_mut\n     ///\n-    /// While this method and its mutable counterpart are useful for\n-    /// null-safety, it is important to note that this is still an unsafe\n-    /// operation because the returned value could be pointing to invalid\n-    /// memory.\n+    /// # Safety\n     ///\n     /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n     /// all of the following is true:\n-    /// - it is properly aligned\n-    /// - it must point to an initialized instance of T; in particular, the pointer must be\n-    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * The pointer must point to an initialized instance of `T`.\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n     ///\n     /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n     /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n-    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n-    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n-    /// the memory the pointer points to must not get mutated (except inside `UnsafeCell`).\n-    ///\n-    /// [here]: crate::ptr#safety\n+    /// [the module documentation]: crate::ptr#safety\n     ///\n     /// # Examples\n     ///\n@@ -110,6 +114,59 @@ impl<T: ?Sized> *mut T {\n         if self.is_null() { None } else { unsafe { Some(&*self) } }\n     }\n \n+    /// Returns `None` if the pointer is null, or else returns a shared reference to\n+    /// the value wrapped in `Some`. In contrast to [`as_ref`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// For the mutable counterpart see [`as_uninit_mut`].\n+    ///\n+    /// [`as_ref`]: #method.as_ref-1\n+    /// [`as_uninit_mut`]: #method.as_uninit_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// [the module documentation]: crate::ptr#safety\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_as_uninit)]\n+    ///\n+    /// let ptr: *mut u8 = &mut 10u8 as *mut u8;\n+    ///\n+    /// unsafe {\n+    ///     if let Some(val_back) = ptr.as_uninit_ref() {\n+    ///         println!(\"We got back the value: {}!\", val_back.assume_init());\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_ref<'a>(self) -> Option<&'a MaybeUninit<T>>\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        if self.is_null() { None } else { Some(unsafe { &*(self as *const MaybeUninit<T>) }) }\n+    }\n+\n     /// Calculates the offset from a pointer.\n     ///\n     /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n@@ -235,33 +292,36 @@ impl<T: ?Sized> *mut T {\n         unsafe { intrinsics::arith_offset(self, count) as *mut T }\n     }\n \n-    /// Returns `None` if the pointer is null, or else returns a mutable\n-    /// reference to the value wrapped in `Some`.\n+    /// Returns `None` if the pointer is null, or else returns a unique reference to\n+    /// the value wrapped in `Some`. If the value may be uninitialized, [`as_uninit_mut`]\n+    /// must be used instead.\n     ///\n-    /// # Safety\n+    /// For the shared counterpart see [`as_ref`].\n     ///\n-    /// As with [`as_ref`], this is unsafe because it cannot verify the validity\n-    /// of the returned pointer, nor can it ensure that the lifetime `'a`\n-    /// returned is indeed a valid lifetime for the contained data.\n+    /// [`as_uninit_mut`]: #method.as_uninit_mut\n+    /// [`as_ref`]: #method.as_ref-1\n+    ///\n+    /// # Safety\n     ///\n     /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n     /// all of the following is true:\n-    /// - it is properly aligned\n-    /// - it must point to an initialized instance of T; in particular, the pointer must be\n-    ///   \"dereferenceable\" in the sense defined [here].\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * The pointer must point to an initialized instance of `T`.\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get accessed (read or written) through any other pointer.\n     ///\n     /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n-    /// it is the only safe approach is to ensure that they are indeed initialized.)\n-    ///\n-    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n-    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n-    /// the memory this pointer points to must not get accessed (read or written)\n-    /// through any other pointer.\n+    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n-    /// [here]: crate::ptr#safety\n-    /// [`as_ref`]: #method.as_ref\n+    /// [the module documentation]: crate::ptr#safety\n     ///\n     /// # Examples\n     ///\n@@ -272,6 +332,7 @@ impl<T: ?Sized> *mut T {\n     /// let ptr: *mut u32 = s.as_mut_ptr();\n     /// let first_value = unsafe { ptr.as_mut().unwrap() };\n     /// *first_value = 4;\n+    /// # assert_eq!(s, [4, 2, 3]);\n     /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n     /// ```\n     ///\n@@ -286,6 +347,7 @@ impl<T: ?Sized> *mut T {\n     /// let ptr: *mut u32 = s.as_mut_ptr();\n     /// let first_value = unsafe { &mut *ptr };\n     /// *first_value = 4;\n+    /// # assert_eq!(s, [4, 2, 3]);\n     /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n     /// ```\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n@@ -296,6 +358,43 @@ impl<T: ?Sized> *mut T {\n         if self.is_null() { None } else { unsafe { Some(&mut *self) } }\n     }\n \n+    /// Returns `None` if the pointer is null, or else returns a unique reference to\n+    /// the value wrapped in `Some`. In contrast to [`as_mut`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// For the shared counterpart see [`as_uninit_ref`].\n+    ///\n+    /// [`as_mut`]: #method.as_mut\n+    /// [`as_uninit_ref`]: #method.as_uninit_ref-1\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get accessed (read or written) through any other pointer.\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// [the module documentation]: crate::ptr#safety\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_mut<'a>(self) -> Option<&'a mut MaybeUninit<T>>\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        if self.is_null() { None } else { Some(unsafe { &mut *(self as *mut MaybeUninit<T>) }) }\n+    }\n+\n     /// Returns whether two pointers are guaranteed to be equal.\n     ///\n     /// At runtime this function behaves like `self == other`.\n@@ -1131,6 +1230,110 @@ impl<T> *mut [T] {\n         // SAFETY: the caller ensures that `self` is dereferencable and `index` in-bounds.\n         unsafe { index.get_unchecked_mut(self) }\n     }\n+\n+    /// Returns `None` if the pointer is null, or else returns a shared slice to\n+    /// the value wrapped in `Some`. In contrast to [`as_ref`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// For the mutable counterpart see [`as_uninit_slice_mut`].\n+    ///\n+    /// [`as_ref`]: #method.as_ref-1\n+    /// [`as_uninit_slice_mut`]: #method.as_uninit_slice_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    ///\n+    /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n+    ///   and it must be properly aligned. This means in particular:\n+    ///\n+    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///       Slices can never span across multiple allocated objects.\n+    ///\n+    ///     * The pointer must be aligned even for zero-length slices. One\n+    ///       reason for this is that enum layout optimizations may rely on references\n+    ///       (including slices of any length) being aligned and non-null to distinguish\n+    ///       them from other data. You can obtain a pointer that is usable as `data`\n+    ///       for zero-length slices using [`NonNull::dangling()`].\n+    ///\n+    /// * The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+    ///   See the safety documentation of [`pointer::offset`].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// See also [`slice::from_raw_parts`][].\n+    ///\n+    /// [valid]: crate::ptr#safety\n+    /// [`NonNull::dangling()`]: NonNull::dangling\n+    /// [`pointer::offset`]: ../std/primitive.pointer.html#method.offset\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {\n+        if self.is_null() {\n+            None\n+        } else {\n+            // SAFETY: the caller must uphold the safety contract for `as_uninit_slice`.\n+            Some(unsafe { slice::from_raw_parts(self as *const MaybeUninit<T>, self.len()) })\n+        }\n+    }\n+\n+    /// Returns `None` if the pointer is null, or else returns a unique slice to\n+    /// the value wrapped in `Some`. In contrast to [`as_mut`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// For the shared counterpart see [`as_uninit_slice`].\n+    ///\n+    /// [`as_mut`]: #method.as_mut\n+    /// [`as_uninit_slice`]: #method.as_uninit_slice-1\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    ///\n+    /// * The pointer must be [valid] for reads and writes for `ptr.len() * mem::size_of::<T>()`\n+    ///   many bytes, and it must be properly aligned. This means in particular:\n+    ///\n+    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///       Slices can never span across multiple allocated objects.\n+    ///\n+    ///     * The pointer must be aligned even for zero-length slices. One\n+    ///       reason for this is that enum layout optimizations may rely on references\n+    ///       (including slices of any length) being aligned and non-null to distinguish\n+    ///       them from other data. You can obtain a pointer that is usable as `data`\n+    ///       for zero-length slices using [`NonNull::dangling()`].\n+    ///\n+    /// * The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+    ///   See the safety documentation of [`pointer::offset`].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get accessed (read or written) through any other pointer.\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// See also [`slice::from_raw_parts_mut`][].\n+    ///\n+    /// [valid]: crate::ptr#safety\n+    /// [`NonNull::dangling()`]: NonNull::dangling\n+    /// [`pointer::offset`]: ../std/primitive.pointer.html#method.offset\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_slice_mut<'a>(self) -> Option<&'a mut [MaybeUninit<T>]> {\n+        if self.is_null() {\n+            None\n+        } else {\n+            // SAFETY: the caller must uphold the safety contract for `as_uninit_slice_mut`.\n+            Some(unsafe { slice::from_raw_parts_mut(self as *mut MaybeUninit<T>, self.len()) })\n+        }\n+    }\n }\n \n // Equality for pointers"}, {"sha": "294a3173d0cbf7ee00a4a0b18c197339ca6cdc3c", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 212, "deletions": 29, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/5498367faff37704b22f77dcf1cc10c89d42faba/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5498367faff37704b22f77dcf1cc10c89d42faba/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=5498367faff37704b22f77dcf1cc10c89d42faba", "patch": "@@ -3,10 +3,10 @@ use crate::convert::From;\n use crate::fmt;\n use crate::hash;\n use crate::marker::Unsize;\n-use crate::mem;\n+use crate::mem::{self, MaybeUninit};\n use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::Unique;\n-use crate::slice::SliceIndex;\n+use crate::slice::{self, SliceIndex};\n \n /// `*mut T` but non-zero and covariant.\n ///\n@@ -76,6 +76,70 @@ impl<T: Sized> NonNull<T> {\n             NonNull::new_unchecked(ptr)\n         }\n     }\n+\n+    /// Returns a shared references to the value. In contrast to [`as_ref`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// For the mutable counterpart see [`as_uninit_mut`].\n+    ///\n+    /// [`as_ref`]: #method.as_ref\n+    /// [`as_uninit_mut`]: #method.as_uninit_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that all of the following is true:\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// [the module documentation]: crate::ptr#safety\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_ref(&self) -> &MaybeUninit<T> {\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        unsafe { &*self.cast().as_ptr() }\n+    }\n+\n+    /// Returns a unique references to the value. In contrast to [`as_mut`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// For the shared counterpart see [`as_uninit_ref`].\n+    ///\n+    /// [`as_mut`]: #method.as_mut\n+    /// [`as_uninit_ref`]: #method.as_uninit_ref\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that all of the following is true:\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get accessed (read or written) through any other pointer.\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// [the module documentation]: crate::ptr#safety\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_mut(&mut self) -> &mut MaybeUninit<T> {\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        unsafe { &mut *self.cast().as_ptr() }\n+    }\n }\n \n impl<T: ?Sized> NonNull<T> {\n@@ -112,29 +176,34 @@ impl<T: ?Sized> NonNull<T> {\n         self.pointer as *mut T\n     }\n \n-    /// Dereferences the content.\n+    /// Returns a shared reference to the value. If the value may be uninitialized, [`as_uninit_ref`]\n+    /// must be used instead.\n+    ///\n+    /// For the mutable counterpart see [`as_mut`].\n     ///\n-    /// The resulting lifetime is bound to self so this behaves \"as if\"\n-    /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n+    /// [`as_uninit_ref`]: #method.as_uninit_ref\n+    /// [`as_mut`]: #method.as_mut\n     ///\n     /// # Safety\n     ///\n     /// When calling this method, you have to ensure that all of the following is true:\n-    /// - `self` is properly aligned\n-    /// - `self` must point to an initialized instance of T; in particular, the pointer must be\n-    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * The pointer must point to an initialized instance of `T`.\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n     ///\n     /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n     /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n-    /// Additionally, the lifetime of `self` does not necessarily reflect the actual\n-    /// lifetime of the data. *You* must enforce Rust's aliasing rules. In particular,\n-    /// for the duration of this lifetime, the memory the pointer points to must not\n-    /// get mutated (except inside `UnsafeCell`).\n-    ///\n-    /// [here]: crate::ptr#safety\n+    /// [the module documentation]: crate::ptr#safety\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub unsafe fn as_ref(&self) -> &T {\n@@ -143,29 +212,34 @@ impl<T: ?Sized> NonNull<T> {\n         unsafe { &*self.as_ptr() }\n     }\n \n-    /// Mutably dereferences the content.\n+    /// Returns a unique reference to the value. If the value may be uninitialized, [`as_uninit_mut`]\n+    /// must be used instead.\n+    ///\n+    /// For the shared counterpart see [`as_ref`].\n     ///\n-    /// The resulting lifetime is bound to self so this behaves \"as if\"\n-    /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n+    /// [`as_uninit_mut`]: #method.as_uninit_mut\n+    /// [`as_ref`]: #method.as_ref\n     ///\n     /// # Safety\n     ///\n     /// When calling this method, you have to ensure that all of the following is true:\n-    /// - `self` is properly aligned\n-    /// - `self` must point to an initialized instance of T; in particular, the pointer must be\n-    ///   \"dereferenceable\" in the sense defined [here].\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * The pointer must point to an initialized instance of `T`.\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get accessed (read or written) through any other pointer.\n     ///\n     /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n-    /// it is the only safe approach is to ensure that they are indeed initialized.)\n-    ///\n-    /// Additionally, the lifetime of `self` does not necessarily reflect the actual\n-    /// lifetime of the data. *You* must enforce Rust's aliasing rules. In particular,\n-    /// for the duration of this lifetime, the memory this pointer points to must not\n-    /// get accessed (read or written) through any other pointer.\n+    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n-    /// [here]: crate::ptr#safety\n+    /// [the module documentation]: crate::ptr#safety\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n@@ -278,6 +352,115 @@ impl<T> NonNull<[T]> {\n         self.as_non_null_ptr().as_ptr()\n     }\n \n+    /// Returns a shared reference to a slice of possibly uninitialized values. In contrast to\n+    /// [`as_ref`], this does not require that the value has to be initialized.\n+    ///\n+    /// For the mutable counterpart see [`as_uninit_slice_mut`].\n+    ///\n+    /// [`as_ref`]: #method.as_ref\n+    /// [`as_uninit_slice_mut`]: #method.as_uninit_slice_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that all of the following is true:\n+    ///\n+    /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n+    ///   and it must be properly aligned. This means in particular:\n+    ///\n+    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///       Slices can never span across multiple allocated objects.\n+    ///\n+    ///     * The pointer must be aligned even for zero-length slices. One\n+    ///       reason for this is that enum layout optimizations may rely on references\n+    ///       (including slices of any length) being aligned and non-null to distinguish\n+    ///       them from other data. You can obtain a pointer that is usable as `data`\n+    ///       for zero-length slices using [`NonNull::dangling()`].\n+    ///\n+    /// * The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+    ///   See the safety documentation of [`pointer::offset`].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// See also [`slice::from_raw_parts`][].\n+    ///\n+    /// [valid]: crate::ptr#safety\n+    /// [`NonNull::dangling()`]: NonNull::dangling\n+    /// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_slice(&self) -> &[MaybeUninit<T>] {\n+        // SAFETY: the caller must uphold the safety contract for `as_uninit_slice`.\n+        unsafe { slice::from_raw_parts(self.cast().as_ptr(), self.len()) }\n+    }\n+\n+    /// Returns a unique reference to a slice of possibly uninitialized values. In contrast to\n+    /// [`as_mut`], this does not require that the value has to be initialized.\n+    ///\n+    /// For the shared counterpart see [`as_uninit_slice`].\n+    ///\n+    /// [`as_mut`]: #method.as_mut\n+    /// [`as_uninit_slice`]: #method.as_uninit_slice\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that all of the following is true:\n+    ///\n+    /// * The pointer must be [valid] for reads and writes for `ptr.len() * mem::size_of::<T>()`\n+    ///   many bytes, and it must be properly aligned. This means in particular:\n+    ///\n+    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///       Slices can never span across multiple allocated objects.\n+    ///\n+    ///     * The pointer must be aligned even for zero-length slices. One\n+    ///       reason for this is that enum layout optimizations may rely on references\n+    ///       (including slices of any length) being aligned and non-null to distinguish\n+    ///       them from other data. You can obtain a pointer that is usable as `data`\n+    ///       for zero-length slices using [`NonNull::dangling()`].\n+    ///\n+    /// * The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+    ///   See the safety documentation of [`pointer::offset`].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get accessed (read or written) through any other pointer.\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// See also [`slice::from_raw_parts_mut`][].\n+    ///\n+    /// [valid]: crate::ptr#safety\n+    /// [`NonNull::dangling()`]: NonNull::dangling\n+    /// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(allocator_api, ptr_as_uninit)]\n+    ///\n+    /// use std::alloc::{AllocRef, Layout, Global};\n+    /// use std::mem::MaybeUninit;\n+    /// use std::ptr::NonNull;\n+    ///\n+    /// let memory: NonNull<[u8]> = Global.alloc(Layout::new::<[u8; 32]>())?;\n+    /// // This is safe as `memory` is valid for reads and writes for `memory.len()` many bytes.\n+    /// // Note that calling `memory.as_mut()` is not allowed here as the content may be uninitialized.\n+    /// # #[allow(unused_variables)]\n+    /// let slice: &mut [MaybeUninit<u8>] = unsafe { memory.as_uninit_slice_mut() };\n+    /// # Ok::<_, std::alloc::AllocErr>(())\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_slice_mut(&self) -> &mut [MaybeUninit<T>] {\n+        // SAFETY: the caller must uphold the safety contract for `as_uninit_slice_mut`.\n+        unsafe { slice::from_raw_parts_mut(self.cast().as_ptr(), self.len()) }\n+    }\n+\n     /// Returns a raw pointer to an element or subslice, without doing bounds\n     /// checking.\n     ///"}]}