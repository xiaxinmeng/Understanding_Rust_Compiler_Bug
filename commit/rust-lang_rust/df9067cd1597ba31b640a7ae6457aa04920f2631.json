{"sha": "df9067cd1597ba31b640a7ae6457aa04920f2631", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmOTA2N2NkMTU5N2JhMzFiNjQwYTdhZTY0NTdhYTA0OTIwZjI2MzE=", "commit": {"author": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2014-01-10T04:12:59Z"}, "committer": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2014-01-22T18:03:55Z"}, "message": "rustpkg: Compute hash to find crate\n\nPreviously rustpkg tried to parse filenames to find crate. Now ue use\ndeterministic hashes, so it becomes possible to directly construct\nfilename and check if the file exists.", "tree": {"sha": "86bc70e6c2c56ad3ac5f0cb61a2dfa5fd3ea921f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86bc70e6c2c56ad3ac5f0cb61a2dfa5fd3ea921f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df9067cd1597ba31b640a7ae6457aa04920f2631", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df9067cd1597ba31b640a7ae6457aa04920f2631", "html_url": "https://github.com/rust-lang/rust/commit/df9067cd1597ba31b640a7ae6457aa04920f2631", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df9067cd1597ba31b640a7ae6457aa04920f2631/comments", "author": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c", "html_url": "https://github.com/rust-lang/rust/commit/655433e3343ab6f91ef8db9a7ce19345eb0a6a9c"}], "stats": {"total": 298, "additions": 99, "deletions": 199}, "files": [{"sha": "4a87bcb70f50a586364595ff42549dfe2dc8a7c9", "filename": "src/librustpkg/crate_id.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/df9067cd1597ba31b640a7ae6457aa04920f2631/src%2Flibrustpkg%2Fcrate_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9067cd1597ba31b640a7ae6457aa04920f2631/src%2Flibrustpkg%2Fcrate_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate_id.rs?ref=df9067cd1597ba31b640a7ae6457aa04920f2631", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n use std::hash::Streaming;\n-use std::hash;\n use syntax::crateid;\n+use extra::hex::ToHex;\n+use rustc::util::sha2::{Digest, Sha256};\n \n /// Path-fragment identifier of a package such as\n /// 'github.com/graydon/test'; path must be a relative\n@@ -41,7 +42,7 @@ impl Eq for CrateId {\n }\n \n impl CrateId {\n-    pub fn get_version<'a>(&'a self) -> &'a str {\n+    pub fn version_or_default<'a>(&'a self) -> &'a str {\n         match self.version {\n             Some(ref ver) => ver.as_slice(),\n             None => \"0.0\"\n@@ -66,16 +67,24 @@ impl CrateId {\n         }\n     }\n \n+    pub fn to_crate_id_str(&self) -> ~str {\n+        format!(\"{}\\\\#{}\", self.path.as_str().unwrap(), self.version_or_default())\n+    }\n+\n+    pub fn to_lib_name(&self) -> ~str {\n+        format!(\"{}-{}-{}\", self.short_name, self.hash(), self.version_or_default())\n+    }\n+\n     pub fn hash(&self) -> ~str {\n-        // FIXME (#9639): hash should take a &[u8] so we can hash the real path\n-        self.path.display().with_str(|s| {\n-            let vers = self.get_version();\n-            format!(\"{}-{}-{}\", s, hash(s + vers), vers)\n-        })\n+        let mut hasher = Sha256::new();\n+        hasher.reset();\n+        hasher.input_str(self.to_crate_id_str());\n+        let hash = hasher.result_bytes().to_hex();\n+        hash.slice_chars(0, 8).to_owned()\n     }\n \n     pub fn short_name_with_version(&self) -> ~str {\n-        format!(\"{}-{}\", self.short_name, self.get_version())\n+        format!(\"{}-{}\", self.short_name, self.version_or_default())\n     }\n \n     /// True if the ID has multiple components\n@@ -126,18 +135,10 @@ impl Iterator<(Path, Path)> for Prefixes {\n impl ToStr for CrateId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        format!(\"{}-{}\", self.path.as_str().unwrap(), self.get_version())\n+        format!(\"{}-{}\", self.path.as_str().unwrap(), self.version_or_default())\n     }\n }\n \n-\n pub fn write<W: Writer>(writer: &mut W, string: &str) {\n     writer.write(string.as_bytes());\n }\n-\n-pub fn hash(data: ~str) -> ~str {\n-    let hasher = &mut hash::default_state();\n-    write(hasher, data);\n-    hasher.result_str()\n-}\n-"}, {"sha": "2bc1966bff0e4873289cf12aa8adba7b29406e6b", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df9067cd1597ba31b640a7ae6457aa04920f2631/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9067cd1597ba31b640a7ae6457aa04920f2631/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=df9067cd1597ba31b640a7ae6457aa04920f2631", "patch": "@@ -287,7 +287,7 @@ impl PkgSrc {\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 let url = format!(\"https://{}\", crateid.path.as_str().unwrap());\n                 debug!(\"Fetching package: git clone {} {} [version={}]\",\n-                        url, clone_target.display(), crateid.get_version());\n+                        url, clone_target.display(), crateid.version_or_default());\n \n                 let mut failed = false;\n "}, {"sha": "1412b99d285f1b993eeceb489daea0993470a5ea", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 30, "deletions": 125, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/df9067cd1597ba31b640a7ae6457aa04920f2631/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9067cd1597ba31b640a7ae6457aa04920f2631/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=df9067cd1597ba31b640a7ae6457aa04920f2631", "patch": "@@ -14,17 +14,16 @@\n \n pub use crate_id::CrateId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n-pub use version::{Version, split_version, split_version_general,\n-    try_parsing_version};\n+pub use version::{Version, split_version, split_version_general, try_parsing_version};\n pub use rustc::metadata::filesearch::rust_path;\n-use rustc::metadata::filesearch::{libdir, relative_target_lib_path};\n-use rustc::driver::driver::host_triple;\n \n use std::libc;\n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::os;\n use std::io;\n use std::io::fs;\n+use rustc::metadata::filesearch::{libdir, relative_target_lib_path};\n+use rustc::driver::driver::host_triple;\n use messages::*;\n \n pub fn default_workspace() -> Path {\n@@ -173,151 +172,57 @@ fn output_in_workspace(crateid: &CrateId, workspace: &Path, what: OutputType) ->\n /// Figure out what the library name for <crateid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n pub fn built_library_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n-    library_in_workspace(&crateid.path, crateid.short_name, Build, workspace, \"build\",\n-                         &crateid.version)\n+    library_in_workspace(crateid, Build, workspace)\n }\n \n /// Does the actual searching stuff\n-pub fn installed_library_in_workspace(pkg_path: &Path, workspace: &Path) -> Option<Path> {\n+pub fn installed_library_in_workspace(crate_id: &CrateId, workspace: &Path) -> Option<Path> {\n     // This could break once we're handling multiple versions better -- I should add a test for it\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    match pkg_path.filename_str() {\n+    match crate_id.path.filename_str() {\n         None => None,\n-        Some(short_name) => library_in_workspace(pkg_path,\n-                                                 short_name,\n-                                                 Install,\n-                                                 workspace,\n-                                                 libdir(),\n-                                                 &None)\n+        Some(_short_name) => library_in_workspace(crate_id, Install, workspace)\n     }\n }\n \n /// `workspace` is used to figure out the directory to search.\n /// `short_name` is taken as the link name of the library.\n-pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n-                        workspace: &Path, prefix: &str, version: &Version) -> Option<Path> {\n+pub fn library_in_workspace(crate_id: &CrateId, where: Target, workspace: &Path) -> Option<Path> {\n     debug!(\"library_in_workspace: checking whether a library named {} exists\",\n-           short_name);\n-\n-    // We don't know what the hash is, so we have to search through the directory\n-    // contents\n-\n-    debug!(\"short_name = {} where = {:?} workspace = {} \\\n-            prefix = {}\", short_name, where, workspace.display(), prefix);\n+           crate_id.short_name);\n \n     let dir_to_search = match where {\n-        Build => target_build_dir(workspace).join(path),\n+        Build => target_build_dir(workspace).join(&crate_id.path),\n         Install => target_lib_dir(workspace)\n     };\n \n-    library_in(short_name, version, &dir_to_search)\n+    library_in(crate_id, &dir_to_search)\n }\n \n pub fn system_library(sysroot: &Path, crate_id: &str) -> Option<Path> {\n-    let (lib_name, version) = split_crate_id(crate_id);\n-    library_in(lib_name, &version, &sysroot.join(relative_target_lib_path(host_triple())))\n-}\n-\n-fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n-    debug!(\"Listing directory {}\", dir_to_search.display());\n-    let dir_contents = {\n-        let _guard = io::ignore_io_error();\n-        fs::readdir(dir_to_search)\n-    };\n-    debug!(\"dir has {:?} entries\", dir_contents.len());\n-\n-    let dll_prefix = format!(\"{}{}\", os::consts::DLL_PREFIX, short_name);\n-    let dll_filetype = os::consts::DLL_EXTENSION;\n-    let rlib_prefix = format!(\"{}{}\", \"lib\", short_name);\n-    let rlib_filetype = \"rlib\";\n-\n-    debug!(\"dll_prefix = {} and dll_filetype = {}\", dll_prefix, dll_filetype);\n-    debug!(\"rlib_prefix = {} and rlib_filetype = {}\", rlib_prefix, rlib_filetype);\n-\n-    // Find a filename that matches the pattern:\n-    // (lib_prefix)-hash-(version)(lib_suffix)\n-    let mut libraries = dir_contents.iter().filter(|p| {\n-        let extension = p.extension_str();\n-        debug!(\"p = {}, p's extension is {:?}\", p.display(), extension);\n-        match extension {\n-            None => false,\n-            Some(ref s) => dll_filetype == *s || rlib_filetype == *s,\n+    library_in(&CrateId::new(crate_id), &sysroot.join(relative_target_lib_path(host_triple())))\n+}\n+\n+fn library_in(crate_id: &CrateId, dir_to_search: &Path) -> Option<Path> {\n+    let lib_name = crate_id.to_lib_name();\n+    let filenames = [\n+        format!(\"{}{}.{}\", \"lib\", lib_name, \"rlib\"),\n+        format!(\"{}{}{}\", os::consts::DLL_PREFIX, lib_name, os::consts::DLL_SUFFIX),\n+    ];\n+\n+    for filename in filenames.iter() {\n+        debug!(\"filename = {}\", filename.as_slice());\n+        let path = dir_to_search.join(filename.as_slice());\n+        if path.exists() {\n+            debug!(\"found: {}\", path.display());\n+            return Some(path);\n         }\n-    });\n-\n-    let mut result_filename = None;\n-    for p_path in libraries {\n-        // Find a filename that matches the pattern: (lib_prefix)-hash-(version)(lib_suffix)\n-        // and remember what the hash was\n-        let mut f_name = match p_path.filestem_str() {\n-            Some(s) => s, None => continue\n-        };\n-        // Already checked the filetype above\n-\n-         // This is complicated because library names and versions can both contain dashes\n-         loop {\n-            if f_name.is_empty() { break; }\n-            match f_name.rfind('-') {\n-                Some(i) => {\n-                    debug!(\"Maybe {} is a version\", f_name.slice(i + 1, f_name.len()));\n-                    match try_parsing_version(f_name.slice(i + 1, f_name.len())) {\n-                        Some(ref found_vers) if version == &Some(found_vers.to_owned()) ||\n-                                                version == &None => {\n-                            match f_name.slice(0, i).rfind('-') {\n-                                Some(j) => {\n-                                    let lib_prefix = match p_path.extension_str() {\n-                                        Some(ref s) if dll_filetype == *s => &dll_prefix,\n-                                        _ => &rlib_prefix,\n-                                    };\n-                                    debug!(\"Maybe {} equals {}\", f_name.slice(0, j), *lib_prefix);\n-                                    if f_name.slice(0, j) == *lib_prefix {\n-                                        result_filename = Some(p_path.clone());\n-                                    }\n-                                    break;\n-                                }\n-                                None => break\n-                            }\n-                       }\n-                       _ => { f_name = f_name.slice(0, i); }\n-                 }\n-               }\n-               None => break\n-         } // match\n-       } // loop\n-    } // for\n-\n-    if result_filename.is_none() {\n-        debug!(\"warning: library_in_workspace didn't find a library in {} for {}\",\n-                  dir_to_search.display(), short_name);\n-    }\n-\n-    // Return the filename that matches, which we now know exists\n-    // (if result_filename != None)\n-    let abs_path = result_filename.map(|result_filename| {\n-        let absolute_path = dir_to_search.join(&result_filename);\n-        debug!(\"result_filename = {}\", absolute_path.display());\n-        absolute_path\n-    });\n-\n-    abs_path\n-}\n-\n-fn split_crate_id<'a>(crate_id: &'a str) -> (&'a str, Version) {\n-    match split_version(crate_id) {\n-        Some((name, vers)) =>\n-            match vers {\n-                Some(ref v) => match v.find('-') {\n-                    Some(pos) => (name, Some(v.slice(0, pos).to_owned())),\n-                    None => (name, Some(v.to_owned()))\n-                },\n-                _ => (name, vers)\n-            },\n-        None => (crate_id, None)\n     }\n+    debug!(\"warning: library_in_workspace didn't find a library in {} for {}\",\n+           dir_to_search.display(), crate_id.short_name);\n+    return None;\n }\n \n-\n-\n /// Returns the executable that would be installed for <crateid>\n /// in <workspace>\n /// As a side effect, creates the bin-dir if it doesn't exist"}, {"sha": "4bc9714fa2ac2bd4c6021382d3a8224dfeef5126", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 37, "deletions": 40, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/df9067cd1597ba31b640a7ae6457aa04920f2631/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9067cd1597ba31b640a7ae6457aa04920f2631/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=df9067cd1597ba31b640a7ae6457aa04920f2631", "patch": "@@ -343,13 +343,13 @@ fn create_local_package_with_custom_build_hook(crateid: &CrateId,\n \n }\n \n-fn assert_lib_exists(repo: &Path, pkg_path: &Path, v: Option<~str>) {\n-    assert!(lib_exists(repo, pkg_path, v));\n+fn assert_lib_exists(repo: &Path, crate_id: &CrateId) {\n+    assert!(lib_exists(repo, crate_id));\n }\n \n-fn lib_exists(repo: &Path, pkg_path: &Path, _v: Option<~str>) -> bool { // ??? version?\n-    debug!(\"assert_lib_exists: repo = {}, pkg_path = {}\", repo.display(), pkg_path.display());\n-    let lib = installed_library_in_workspace(pkg_path, repo);\n+fn lib_exists(repo: &Path, crate_id: &CrateId) -> bool {\n+    debug!(\"assert_lib_exists: repo = {}, crate_id = {}\", repo.display(), crate_id.to_str());\n+    let lib = installed_library_in_workspace(crate_id, repo);\n     debug!(\"assert_lib_exists: checking whether {:?} exists\", lib);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n@@ -465,12 +465,9 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n     debug!(\"lib_output_file_name: given {} and short name {}\",\n            workspace.display(), short_name);\n-    library_in_workspace(&Path::new(short_name),\n-                         short_name,\n+    library_in_workspace(&CrateId::new(short_name),\n                          Build,\n-                         workspace,\n-                         \"build\",\n-                         &None).expect(\"lib_output_file_name\")\n+                         workspace).expect(\"lib_output_file_name\")\n }\n \n #[cfg(target_os = \"linux\")]\n@@ -578,7 +575,7 @@ fn test_install_valid() {\n     assert!(exec.exists());\n     assert!(is_rwx(&exec));\n \n-    let lib = installed_library_in_workspace(&temp_pkg_id.path, temp_workspace);\n+    let lib = installed_library_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"lib = {:?}\", lib);\n     assert!(lib.as_ref().map_or(false, |l| l.exists()));\n     assert!(lib.as_ref().map_or(false, |l| is_rwx(l)));\n@@ -629,7 +626,7 @@ fn test_install_valid_external() {\n     assert!(exec.exists());\n     assert!(is_rwx(&exec));\n \n-    let lib = installed_library_in_workspace(&temp_pkg_id.path, temp_workspace);\n+    let lib = installed_library_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"lib = {:?}\", lib);\n     assert!(lib.as_ref().map_or(false, |l| l.exists()));\n     assert!(lib.as_ref().map_or(false, |l| is_rwx(l)));\n@@ -687,7 +684,7 @@ fn test_install_git() {\n     let _built_lib =\n         built_library_in_workspace(&temp_pkg_id,\n                                    &ws).expect(\"test_install_git: built lib should exist\");\n-    assert_lib_exists(&ws, &temp_pkg_id.path, temp_pkg_id.version.clone());\n+    assert_lib_exists(&ws, &temp_pkg_id);\n     let built_test = built_test_in_workspace(&temp_pkg_id,\n                          &ws).expect(\"test_install_git: built test should exist\");\n     assert!(built_test.exists());\n@@ -768,7 +765,7 @@ fn test_package_request_version() {\n \n     command_line_test([~\"install\", format!(\"{}\\\\#0.3\", local_path)], repo);\n \n-    assert!(match installed_library_in_workspace(&Path::new(\"test_pkg_version\"),\n+    assert!(match installed_library_in_workspace(&CrateId::new(format!(\"{}\\\\#0.3\", local_path)),\n                                                  &repo.join(\".rust\")) {\n         Some(p) => {\n             debug!(\"installed: {}\", p.display());\n@@ -812,10 +809,10 @@ fn rustpkg_library_target() {\n               \"#[test] pub fn f() { (); }\");\n     writeFile(&package_dir.join(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n+    add_git_tag(&package_dir, ~\"0.0\");\n \n-    add_git_tag(&package_dir, ~\"1.0\");\n     command_line_test([~\"install\", ~\"foo\"], foo_repo);\n-    assert_lib_exists(&foo_repo.join(\".rust\"), &Path::new(\"foo\"), Some(~\"1.0\"));\n+    assert_lib_exists(&foo_repo.join(\".rust\"), &CrateId::new(\"foo\"));\n }\n \n #[test]\n@@ -838,7 +835,7 @@ fn package_script_with_default_build() {\n     debug!(\"package_script_with_default_build: {}\", source.display());\n     fs::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.0\", \"pkg.rs\"]));\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n-    assert_lib_exists(dir, &Path::new(\"fancy-lib\"), None);\n+    assert_lib_exists(dir, &CrateId::new(\"fancy-lib\"));\n     assert!(target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]).exists());\n     let generated_path = target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]);\n     debug!(\"generated path = {}\", generated_path.display());\n@@ -869,7 +866,7 @@ fn rustpkg_install_no_arg() {\n               \"fn main() { let _x = (); }\");\n     debug!(\"install_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"install\"], &package_dir);\n-    assert_lib_exists(&tmp, &Path::new(\"foo\"), None);\n+    assert_lib_exists(&tmp, &CrateId::new(\"foo\"));\n }\n \n #[test]\n@@ -1047,7 +1044,7 @@ fn no_recopying() {\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     command_line_test([~\"install\", ~\"foo\"], workspace);\n-    let foo_lib = installed_library_in_workspace(&p_id.path, workspace);\n+    let foo_lib = installed_library_in_workspace(&p_id, workspace);\n     assert!(foo_lib.is_some());\n     // Now make `foo` read-only so that subsequent attempts to copy to it will fail\n     assert!(chmod_read_only(&foo_lib.unwrap()));\n@@ -1352,11 +1349,11 @@ fn rust_path_hack_test(hack_flag: bool) {\n                foo_path.as_str().unwrap()))]);\n    command_line_test_with_env(~[~\"install\"] + if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } +\n                                ~[~\"foo\"], dest_workspace, rust_path);\n-   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), None);\n+   assert_lib_exists(dest_workspace, &CrateId::new(\"foo\"));\n    assert_executable_exists(dest_workspace, \"foo\");\n    assert_built_library_exists(dest_workspace, \"foo\");\n    assert_built_executable_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(workspace, &Path::new(\"foo\"), None));\n+   assert!(!lib_exists(workspace, &CrateId::new(\"foo\")));\n    assert!(!executable_exists(workspace, \"foo\"));\n    assert!(!built_library_exists(workspace, \"foo\"));\n    assert!(!built_executable_exists(workspace, \"foo\"));\n@@ -1397,9 +1394,9 @@ fn rust_path_hack_cwd() {\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), None);\n+   assert_lib_exists(dest_workspace, &CrateId::new(\"foo\"));\n    assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&cwd, &Path::new(\"foo\"), None));\n+   assert!(!lib_exists(&cwd, &CrateId::new(\"foo\")));\n    assert!(!built_library_exists(&cwd, \"foo\"));\n }\n \n@@ -1418,9 +1415,9 @@ fn rust_path_hack_multi_path() {\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n    debug!(\"Checking that {} exists in {}\", name, dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::new(\"quux\"), None);\n+   assert_lib_exists(dest_workspace, &CrateId::new(\"foo/bar/quux\"));\n    assert_built_library_exists(dest_workspace, name);\n-   assert!(!lib_exists(&subdir, &Path::new(\"quux\"), None));\n+   assert!(!lib_exists(&subdir, &CrateId::new(\"foo/bar/quux\")));\n    assert!(!built_library_exists(&subdir, name));\n }\n \n@@ -1439,9 +1436,9 @@ fn rust_path_hack_install_no_arg() {\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), None);\n+   assert_lib_exists(dest_workspace, &CrateId::new(\"foo\"));\n    assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&source_dir, &Path::new(\"foo\"), None));\n+   assert!(!lib_exists(&source_dir, &CrateId::new(\"foo\")));\n    assert!(!built_library_exists(cwd, \"foo\"));\n }\n \n@@ -1603,7 +1600,7 @@ fn notrans_flag_fail() {\n                           workspace, None, BAD_FLAG_CODE);\n         assert!(!built_executable_exists(workspace, \"foo\"));\n         assert!(!object_file_exists(workspace, \"foo\"));\n-        assert!(!lib_exists(workspace, &Path::new(\"foo\"), None));\n+        assert!(!lib_exists(workspace, &CrateId::new(\"foo\")));\n     }\n }\n \n@@ -1834,10 +1831,10 @@ fn crateid_pointing_to_subdir() {\n     fs::mkdir_recursive(&foo_dir, io::UserRWX);\n     fs::mkdir_recursive(&bar_dir, io::UserRWX);\n     writeFile(&foo_dir.join(\"lib.rs\"),\n-              \"#[crate_id=\\\"mockgithub.com/mozilla/some_repo/extras/rust-foo#foo:0.0\\\"];\" +\n+              \"#[crate_id=\\\"mockgithub.com/mozilla/some_repo/extras/foo\\\"];\" +\n               \"pub fn f() {}\");\n     writeFile(&bar_dir.join(\"lib.rs\"),\n-              \"#[crate_id=\\\"mockgithub.com/mozilla/some_repo/extras/rust-bar#bar:0.0\\\"];\" +\n+              \"#[crate_id=\\\"mockgithub.com/mozilla/some_repo/extras/bar\\\"];\" +\n               \"pub fn g() {}\");\n \n     debug!(\"Creating a file in {}\", workspace.display());\n@@ -1875,9 +1872,9 @@ fn test_recursive_deps() {\n     command_line_test_with_env([~\"install\", ~\"a\"],\n                                a_workspace,\n                                environment);\n-    assert_lib_exists(a_workspace, &Path::new(\"a\"), None);\n-    assert_lib_exists(b_workspace, &Path::new(\"b\"), None);\n-    assert_lib_exists(b_workspace, &Path::new(\"c\"), None);\n+    assert_lib_exists(a_workspace, &CrateId::new(\"a\"));\n+    assert_lib_exists(b_workspace, &CrateId::new(\"b\"));\n+    assert_lib_exists(b_workspace, &CrateId::new(\"c\"));\n }\n \n #[test]\n@@ -1932,7 +1929,7 @@ fn test_target_specific_install_dir() {\n                        ~\"foo\"],\n                       workspace);\n     assert!(workspace.join_many([~\"lib\", host_triple()]).is_dir());\n-    assert_lib_exists(workspace, &Path::new(\"foo\"), None);\n+    assert_lib_exists(workspace, &CrateId::new(\"foo\"));\n     assert!(fs::readdir(&workspace.join(\"lib\")).len() == 1);\n     assert!(workspace.join(\"bin\").is_dir());\n     assert_executable_exists(workspace, \"foo\");\n@@ -1960,7 +1957,7 @@ fn install_after_build() {\n     command_line_test([~\"build\", ~\"b\"], workspace);\n     command_line_test([~\"install\", ~\"b\"], workspace);\n     assert_executable_exists(workspace, b_id.short_name);\n-    assert_lib_exists(workspace, &b_id.path, None);\n+    assert_lib_exists(workspace, &b_id);\n }\n \n #[test]\n@@ -1972,7 +1969,7 @@ fn reinstall() {\n     // and make sure executable was re-installed\n     command_line_test([~\"install\", ~\"b\"], workspace);\n     assert_executable_exists(workspace, b.short_name);\n-    assert_lib_exists(workspace, &b.path, None);\n+    assert_lib_exists(workspace, &b);\n     remove_executable_file(&b, workspace);\n     command_line_test([~\"install\", ~\"b\"], workspace);\n     assert_executable_exists(workspace, b.short_name);\n@@ -2023,13 +2020,13 @@ fn correct_package_name_with_rust_path_hack() {\n                                   // FIXME #3408: Should be NONEXISTENT_PACKAGE_CODE\n                                dest_workspace, rust_path, COPY_FAILED_CODE);\n     assert!(!executable_exists(dest_workspace, \"bar\"));\n-    assert!(!lib_exists(dest_workspace, &bar_id.path.clone(), bar_id.version.clone()));\n+    assert!(!lib_exists(dest_workspace, &bar_id));\n     assert!(!executable_exists(dest_workspace, \"foo\"));\n-    assert!(!lib_exists(dest_workspace, &foo_id.path.clone(), foo_id.version.clone()));\n+    assert!(!lib_exists(dest_workspace, &foo_id));\n     assert!(!executable_exists(foo_workspace, \"bar\"));\n-    assert!(!lib_exists(foo_workspace, &bar_id.path.clone(), bar_id.version.clone()));\n+    assert!(!lib_exists(foo_workspace, &bar_id));\n     assert!(!executable_exists(foo_workspace, \"foo\"));\n-    assert!(!lib_exists(foo_workspace, &foo_id.path.clone(), foo_id.version.clone()));\n+    assert!(!lib_exists(foo_workspace, &foo_id));\n }\n \n #[test]"}, {"sha": "4c2fc98a305a96f19c9c616674d5d03d799dc203", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/df9067cd1597ba31b640a7ae6457aa04920f2631/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9067cd1597ba31b640a7ae6457aa04920f2631/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=df9067cd1597ba31b640a7ae6457aa04920f2631", "patch": "@@ -135,7 +135,7 @@ struct CrateSetup<'a> {\n     ctx: &'a mut ReadyCtx<'a>,\n }\n \n-impl<'a> fold::Folder for CrateSetup<'a> {\n+impl<'a> Folder for CrateSetup<'a> {\n     fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n         fold_item(item, self)\n     }\n@@ -162,7 +162,7 @@ pub fn ready_crate(sess: session::Session,\n \n pub fn compile_input(context: &BuildContext,\n                      exec: &mut workcache::Exec,\n-                     pkg_id: &CrateId,\n+                     crate_id: &CrateId,\n                      in_file: &Path,\n                      workspace: &Path,\n                      deps: &mut DepMap,\n@@ -177,7 +177,7 @@ pub fn compile_input(context: &BuildContext,\n     // not sure if we should support anything else\n \n     let mut out_dir = target_build_dir(workspace);\n-    out_dir.push(&pkg_id.path);\n+    out_dir.push(&crate_id.path);\n     // Make the output directory if it doesn't exist already\n     fs::mkdir_recursive(&out_dir, io::UserRWX);\n \n@@ -276,7 +276,7 @@ pub fn compile_input(context: &BuildContext,\n     let (mut crate, ast_map) = {\n         let installer = CrateInstaller {\n             context: context,\n-            parent: pkg_id,\n+            parent: crate_id,\n             parent_crate: in_file,\n             sess: sess,\n             exec: exec,\n@@ -312,10 +312,7 @@ pub fn compile_input(context: &BuildContext,\n     if !attr::contains_name(crate.attrs, \"crate_id\") {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let crateid_attr =\n-            attr::mk_name_value_item_str(@\"crate_id\",\n-                                         format!(\"{}\\\\#{}\",\n-                                                 pkg_id.path.as_str().unwrap(),\n-                                                 pkg_id.get_version()).to_managed());\n+            attr::mk_name_value_item_str(@\"crate_id\", crate_id.to_crate_id_str().to_managed());\n \n         debug!(\"crateid attr: {:?}\", crateid_attr);\n         crate.attrs.push(attr::mk_attr(crateid_attr));\n@@ -333,7 +330,7 @@ pub fn compile_input(context: &BuildContext,\n                                           what);\n     // Discover the output\n     let discovered_output = if what == Lib  {\n-        built_library_in_workspace(pkg_id, workspace) // Huh???\n+        built_library_in_workspace(crate_id, workspace) // Huh???\n     }\n     else {\n         result\n@@ -435,7 +432,7 @@ pub fn exe_suffix() -> ~str { ~\"\" }\n // Called by build_crates\n pub fn compile_crate(ctxt: &BuildContext,\n                      exec: &mut workcache::Exec,\n-                     pkg_id: &CrateId,\n+                     crate_id: &CrateId,\n                      crate: &Path,\n                      workspace: &Path,\n                      deps: &mut DepMap,\n@@ -444,11 +441,11 @@ pub fn compile_crate(ctxt: &BuildContext,\n                      opt: session::OptLevel,\n                      what: OutputType) -> Option<Path> {\n     debug!(\"compile_crate: crate={}, workspace={}\", crate.display(), workspace.display());\n-    debug!(\"compile_crate: short_name = {}, flags =...\", pkg_id.to_str());\n+    debug!(\"compile_crate: short_name = {}, flags =...\", crate_id.to_str());\n     for fl in flags.iter() {\n         debug!(\"+++ {}\", *fl);\n     }\n-    compile_input(ctxt, exec, pkg_id, crate, workspace, deps, flags, cfgs, opt, what)\n+    compile_input(ctxt, exec, crate_id, crate, workspace, deps, flags, cfgs, opt, what)\n }\n \n struct CrateInstaller<'a> {\n@@ -497,10 +494,10 @@ impl<'a> CrateInstaller<'a> {\n                         debug!(\"Trying to install library {}, rebuilding it\",\n                                lib_name.to_str());\n                         // Try to install it\n-                        let pkg_id = CrateId::new(lib_name);\n+                        let crate_id = CrateId::new(lib_name);\n                         // Find all the workspaces in the RUST_PATH that contain this package.\n                         let workspaces = pkg_parent_workspaces(&self.context.context,\n-                                                               &pkg_id);\n+                                                               &crate_id);\n                         // Three cases:\n                         // (a) `workspaces` is empty. That means there's no local source\n                         // for this package. In that case, we pass the default workspace\n@@ -530,15 +527,15 @@ impl<'a> CrateInstaller<'a> {\n                                  error(format!(\"Package {} depends on {}, but I don't know \\\n                                                how to find it\",\n                                                self.parent.path.display(),\n-                                               pkg_id.path.display()));\n+                                               crate_id.path.display()));\n                                  fail!()\n                         }).inside(|| {\n                             PkgSrc::new(source_workspace.clone(),\n                                         dest_workspace.clone(),\n                                         // Use the rust_path_hack to search for dependencies iff\n                                         // we were already using it\n                                         self.context.context.use_rust_path_hack,\n-                                        pkg_id.clone())\n+                                        crate_id.clone())\n                         });\n                         let (outputs_disc, inputs_disc) =\n                             self.context.install("}]}