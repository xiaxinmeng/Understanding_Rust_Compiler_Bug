{"sha": "bf7a5c41540a4005eb0f8d66afda205691fbb14b", "node_id": "C_kwDOAAsO6NoAKGJmN2E1YzQxNTQwYTQwMDVlYjBmOGQ2NmFmZGEyMDU2OTFmYmIxNGI", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-05T20:48:07Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:16:02Z"}, "message": "Add more backgrounds on lazy store buffers\n\nCo-authored-by: Ralf Jung <post@ralfj.de>", "tree": {"sha": "cb1da03bb4fcfbeff165eabe6d9e8438b5e1648c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb1da03bb4fcfbeff165eabe6d9e8438b5e1648c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf7a5c41540a4005eb0f8d66afda205691fbb14b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRGIACgkQGBtJ+fOP\nM3RdsgwAmeYCP58664pD6hbGl4qnlcrcSXUYAyyUJwgLq0GziTmrZE1bdbg3skDY\nl2dQzBrFWtu+lnu983IK0hPpvuBIqtZiFeuR/OmpT0lC2RHuahtcM4GP5KnDvQeY\nZ57qPSqlsMvvcLIFQkTWIcpQJ8Y55Qt4Nxxe9WaNKgNBk4k5Y/5uc84FjSXPOfsv\nOySEQUeA5wmtyOGA3h6KUkL3TEiIcCg8C6jXMZbTvGI50a10E42p2Zw66C8N99K1\n72Z6X/RLO6Raicp2TWGSo1Tc3d8K1YNM99j7ixIbWifj3qcAG+BT9TJzx5e24sFo\n9ORfZntIHzfNciV7b6phpjnv80gXVW0/qX+0LQdOSzaSp+bwDgd/gncI9mm6wXR+\ngOHXMH0/ilqOBLIBrkx1NaMUu38G0tgJdfE+enpJTXBDRtL5ajcd95YqtD/axZhE\nGGv7pnOND/m1wkz2YrEepQtRuiqOZh9hK4rW68o0u+wvN8REGJsESzp0Vdam5quN\nRzgfgg/7\n=lXts\n-----END PGP SIGNATURE-----", "payload": "tree cb1da03bb4fcfbeff165eabe6d9e8438b5e1648c\nparent 6fb7c131ed48d33b8290ce2bf970c37fd9781828\nauthor Andy Wang <cbeuw.andy@gmail.com> 1654462087 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539362 +0100\n\nAdd more backgrounds on lazy store buffers\n\nCo-authored-by: Ralf Jung <post@ralfj.de>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf7a5c41540a4005eb0f8d66afda205691fbb14b", "html_url": "https://github.com/rust-lang/rust/commit/bf7a5c41540a4005eb0f8d66afda205691fbb14b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf7a5c41540a4005eb0f8d66afda205691fbb14b/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fb7c131ed48d33b8290ce2bf970c37fd9781828", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fb7c131ed48d33b8290ce2bf970c37fd9781828", "html_url": "https://github.com/rust-lang/rust/commit/6fb7c131ed48d33b8290ce2bf970c37fd9781828"}], "stats": {"total": 17, "additions": 14, "deletions": 3}, "files": [{"sha": "02af0efe9fa7f9a9f5eff69bac92049abb106786", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bf7a5c41540a4005eb0f8d66afda205691fbb14b/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf7a5c41540a4005eb0f8d66afda205691fbb14b/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=bf7a5c41540a4005eb0f8d66afda205691fbb14b", "patch": "@@ -30,7 +30,18 @@\n //! used to make sure a value in a thread's view is not overwritten by a write that occured earlier than the one in the existing view.\n //! In our implementation, this is detected using read information attached to store elements, as there is no data strucutre representing reads.\n //!\n-//! Safe/sound Rust allows for more operations on atomic locations than the C++20 atomic API was intended to allow, such as non-atomically accessing\n+//! The C++ memory model is built around the notion of an 'atomic object', so it would be natural\n+//! to attach store buffers to atomic objects. However, Rust follows LLVM in that it only has\n+//! 'atomic accesses'. Therefore Miri cannot know when and where atomic 'objects' are being\n+//! created or destroyed, to manage its store buffers. Instead, we hence lazily create an\n+//! atomic object on the first atomic access to a given region, and we destroy that object\n+//! on the next non-atomic or imperfectly overlapping atomic access to that region.\n+//! These lazy (de)allocations happen in memory_accessed() on non-atomic accesses, and\n+//! get_or_create_store_buffer() on atomic accesses. This mostly works well, but it does\n+//! lead to some issues (https://github.com/rust-lang/miri/issues/2164).\n+//!\n+//! One consequence of this difference is that safe/sound Rust allows for more operations on atomic locations\n+//! than the C++20 atomic API was intended to allow, such as non-atomically accessing\n //! a previously atomically accessed location, or accessing previously atomically accessed locations with a differently sized operation\n //! (such as accessing the top 16 bits of an AtomicU32). These senarios are generally undiscussed in formalisations of C++ memory model.\n //! In Rust, these operations can only be done through a `&mut AtomicFoo` reference or one derived from it, therefore these operations\n@@ -156,8 +167,8 @@ impl StoreBufferAlloc {\n         }\n     }\n \n-    /// Gets a store buffer associated with an atomic object in this allocation\n-    /// Or creates one with the specified initial value\n+    /// Gets a store buffer associated with an atomic object in this allocation,\n+    /// or creates one with the specified initial value if no atomic object exists yet.\n     fn get_or_create_store_buffer<'tcx>(\n         &self,\n         range: AllocRange,"}]}