{"sha": "3c3cf08e39064450a51ab156b6da5050e8f81476", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjM2NmMDhlMzkwNjQ0NTBhNTFhYjE1NmI2ZGE1MDUwZThmODE0NzY=", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-05-07T10:15:38Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-05-07T10:15:38Z"}, "message": "wfcheck fcx <-> tcx cleanup", "tree": {"sha": "e93bbe78e5a7d8e2843d65d087d74df5f9ec0ecf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e93bbe78e5a7d8e2843d65d087d74df5f9ec0ecf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c3cf08e39064450a51ab156b6da5050e8f81476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c3cf08e39064450a51ab156b6da5050e8f81476", "html_url": "https://github.com/rust-lang/rust/commit/3c3cf08e39064450a51ab156b6da5050e8f81476", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c3cf08e39064450a51ab156b6da5050e8f81476/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1773f14a24c49356b384e45ebb45643bc9bef2c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1773f14a24c49356b384e45ebb45643bc9bef2c4", "html_url": "https://github.com/rust-lang/rust/commit/1773f14a24c49356b384e45ebb45643bc9bef2c4"}], "stats": {"total": 98, "additions": 44, "deletions": 54}, "files": [{"sha": "7436edccf84bb3a84361f4f34604d9f02e9ad090", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 44, "deletions": 54, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3c3cf08e39064450a51ab156b6da5050e8f81476/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c3cf08e39064450a51ab156b6da5050e8f81476/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=3c3cf08e39064450a51ab156b6da5050e8f81476", "patch": "@@ -43,7 +43,7 @@ struct CheckWfFcxBuilder<'tcx> {\n impl<'tcx> CheckWfFcxBuilder<'tcx> {\n     fn with_fcx<F>(&mut self, f: F)\n     where\n-        F: for<'b> FnOnce(&FnCtxt<'b, 'tcx>, TyCtxt<'tcx>) -> Vec<Ty<'tcx>>,\n+        F: for<'b> FnOnce(&FnCtxt<'b, 'tcx>) -> Vec<Ty<'tcx>>,\n     {\n         let id = self.id;\n         let span = self.span;\n@@ -56,7 +56,7 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n                 // empty `param_env`.\n                 check_false_global_bounds(&fcx, span, id);\n             }\n-            let wf_tys = f(&fcx, fcx.tcx);\n+            let wf_tys = f(&fcx);\n             fcx.select_all_obligations_or_error();\n             fcx.regionck_item(id, span, &wf_tys);\n         });\n@@ -388,7 +388,7 @@ fn check_associated_item(\n     debug!(\"check_associated_item: {:?}\", item_id);\n \n     let code = ObligationCauseCode::MiscObligation;\n-    for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n+    for_id(tcx, item_id, span).with_fcx(|fcx| {\n         let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n@@ -409,7 +409,6 @@ fn check_associated_item(\n                 let sig = fcx.normalize_associated_types_in(span, sig);\n                 let hir_sig = sig_if_method.expect(\"bad signature for method\");\n                 check_fn_or_method(\n-                    tcx,\n                     fcx,\n                     item.ident.span,\n                     sig,\n@@ -467,25 +466,24 @@ fn check_type_defn<'tcx, F>(\n ) where\n     F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n {\n-    for_item(tcx, item).with_fcx(|fcx, fcx_tcx| {\n+    for_item(tcx, item).with_fcx(|fcx| {\n         let variants = lookup_fields(fcx);\n-        let packed = fcx.tcx.adt_def(item.def_id).repr.packed();\n+        let packed = tcx.adt_def(item.def_id).repr.packed();\n \n         for variant in &variants {\n             // For DST, or when drop needs to copy things around, all\n             // intermediate types must be sized.\n             let needs_drop_copy = || {\n                 packed && {\n                     let ty = variant.fields.last().unwrap().ty;\n-                    let ty = fcx.tcx.erase_regions(ty);\n+                    let ty = tcx.erase_regions(ty);\n                     if ty.needs_infer() {\n-                        fcx_tcx\n-                            .sess\n+                        tcx.sess\n                             .delay_span_bug(item.span, &format!(\"inference variables in {:?}\", ty));\n                         // Just treat unresolved type expression as if it needs drop.\n                         true\n                     } else {\n-                        ty.needs_drop(fcx_tcx, fcx_tcx.param_env(item.def_id))\n+                        ty.needs_drop(tcx, tcx.param_env(item.def_id))\n                     }\n                 }\n             };\n@@ -497,7 +495,7 @@ fn check_type_defn<'tcx, F>(\n                 let last = idx == variant.fields.len() - 1;\n                 fcx.register_bound(\n                     field.ty,\n-                    fcx.tcx.require_lang_item(LangItem::Sized, None),\n+                    tcx.require_lang_item(LangItem::Sized, None),\n                     traits::ObligationCause::new(\n                         field.span,\n                         fcx.body_id,\n@@ -524,11 +522,10 @@ fn check_type_defn<'tcx, F>(\n \n             // Explicit `enum` discriminant values must const-evaluate successfully.\n             if let Some(discr_def_id) = variant.explicit_discr {\n-                let discr_substs =\n-                    InternalSubsts::identity_for_item(fcx.tcx, discr_def_id.to_def_id());\n+                let discr_substs = InternalSubsts::identity_for_item(tcx, discr_def_id.to_def_id());\n \n                 let cause = traits::ObligationCause::new(\n-                    fcx.tcx.def_span(discr_def_id),\n+                    tcx.def_span(discr_def_id),\n                     fcx.body_id,\n                     traits::MiscObligation,\n                 );\n@@ -539,12 +536,12 @@ fn check_type_defn<'tcx, F>(\n                         ty::WithOptConstParam::unknown(discr_def_id.to_def_id()),\n                         discr_substs,\n                     )\n-                    .to_predicate(fcx.tcx),\n+                    .to_predicate(tcx),\n                 ));\n             }\n         }\n \n-        check_where_clauses(tcx, fcx, item.span, item.def_id.to_def_id(), None);\n+        check_where_clauses(fcx, item.span, item.def_id.to_def_id(), None);\n \n         // No implied bounds in a struct definition.\n         vec![]\n@@ -569,8 +566,9 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n         }\n     }\n \n-    for_item(tcx, item).with_fcx(|fcx, _| {\n-        check_where_clauses(tcx, fcx, item.span, item.def_id.to_def_id(), None);\n+    // FIXME: this shouldn't use an `FnCtxt` at all.\n+    for_item(tcx, item).with_fcx(|fcx| {\n+        check_where_clauses(fcx, item.span, item.def_id.to_def_id(), None);\n \n         vec![]\n     });\n@@ -610,28 +608,20 @@ fn check_item_fn(\n     span: Span,\n     decl: &hir::FnDecl<'_>,\n ) {\n-    for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n-        let def_id = fcx.tcx.hir().local_def_id(item_id);\n-        let sig = fcx.tcx.fn_sig(def_id);\n+    for_id(tcx, item_id, span).with_fcx(|fcx| {\n+        let def_id = tcx.hir().local_def_id(item_id);\n+        let sig = tcx.fn_sig(def_id);\n         let sig = fcx.normalize_associated_types_in(span, sig);\n         let mut implied_bounds = vec![];\n-        check_fn_or_method(\n-            tcx,\n-            fcx,\n-            ident.span,\n-            sig,\n-            decl,\n-            def_id.to_def_id(),\n-            &mut implied_bounds,\n-        );\n+        check_fn_or_method(fcx, ident.span, sig, decl, def_id.to_def_id(), &mut implied_bounds);\n         implied_bounds\n     })\n }\n \n fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_foreign_ty: bool) {\n     debug!(\"check_item_type: {:?}\", item_id);\n \n-    for_id(tcx, item_id, ty_span).with_fcx(|fcx, tcx| {\n+    for_id(tcx, item_id, ty_span).with_fcx(|fcx| {\n         let ty = tcx.type_of(tcx.hir().local_def_id(item_id));\n         let item_ty = fcx.normalize_associated_types_in(ty_span, ty);\n \n@@ -647,7 +637,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n         if forbid_unsized {\n             fcx.register_bound(\n                 item_ty,\n-                fcx.tcx.require_lang_item(LangItem::Sized, None),\n+                tcx.require_lang_item(LangItem::Sized, None),\n                 traits::ObligationCause::new(ty_span, fcx.body_id, traits::MiscObligation),\n             );\n         }\n@@ -665,13 +655,13 @@ fn check_impl<'tcx>(\n ) {\n     debug!(\"check_impl: {:?}\", item);\n \n-    for_item(tcx, item).with_fcx(|fcx, tcx| {\n+    for_item(tcx, item).with_fcx(|fcx| {\n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n-                let trait_ref = fcx.tcx.impl_trait_ref(item.def_id).unwrap();\n+                let trait_ref = tcx.impl_trait_ref(item.def_id).unwrap();\n                 let trait_ref =\n                     fcx.normalize_associated_types_in(ast_trait_ref.path.span, trait_ref);\n                 let obligations = traits::wf::trait_obligations(\n@@ -687,7 +677,7 @@ fn check_impl<'tcx>(\n                 }\n             }\n             None => {\n-                let self_ty = fcx.tcx.type_of(item.def_id);\n+                let self_ty = tcx.type_of(item.def_id);\n                 let self_ty = fcx.normalize_associated_types_in(item.span, self_ty);\n                 fcx.register_wf_obligation(\n                     self_ty.into(),\n@@ -697,23 +687,23 @@ fn check_impl<'tcx>(\n             }\n         }\n \n-        check_where_clauses(tcx, fcx, item.span, item.def_id.to_def_id(), None);\n+        check_where_clauses(fcx, item.span, item.def_id.to_def_id(), None);\n \n         fcx.impl_implied_bounds(item.def_id.to_def_id(), item.span)\n     });\n }\n \n /// Checks where-clauses and inline bounds that are declared on `def_id`.\n fn check_where_clauses<'tcx, 'fcx>(\n-    tcx: TyCtxt<'tcx>,\n     fcx: &FnCtxt<'fcx, 'tcx>,\n     span: Span,\n     def_id: DefId,\n     return_ty: Option<(Ty<'tcx>, Span)>,\n ) {\n     debug!(\"check_where_clauses(def_id={:?}, return_ty={:?})\", def_id, return_ty);\n+    let tcx = fcx.tcx;\n \n-    let predicates = fcx.tcx.predicates_of(def_id);\n+    let predicates = tcx.predicates_of(def_id);\n     let generics = tcx.generics_of(def_id);\n \n     let is_our_default = |def: &ty::GenericParamDef| match def.kind {\n@@ -734,14 +724,14 @@ fn check_where_clauses<'tcx, 'fcx>(\n         match param.kind {\n             GenericParamDefKind::Type { .. } => {\n                 if is_our_default(&param) {\n-                    let ty = fcx.tcx.type_of(param.def_id);\n+                    let ty = tcx.type_of(param.def_id);\n                     // Ignore dependent defaults -- that is, where the default of one type\n                     // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n                     // be sure if it will error or not as user might always specify the other.\n                     if !ty.needs_subst() {\n                         fcx.register_wf_obligation(\n                             ty.into(),\n-                            fcx.tcx.def_span(param.def_id),\n+                            tcx.def_span(param.def_id),\n                             ObligationCauseCode::MiscObligation,\n                         );\n                     }\n@@ -754,7 +744,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     let default_ct = tcx.const_param_default(param.def_id);\n                     fcx.register_wf_obligation(\n                         default_ct.into(),\n-                        fcx.tcx.def_span(param.def_id),\n+                        tcx.def_span(param.def_id),\n                         ObligationCauseCode::MiscObligation,\n                     );\n                 }\n@@ -772,25 +762,25 @@ fn check_where_clauses<'tcx, 'fcx>(\n     // For more examples see tests `defaults-well-formedness.rs` and `type-check-defaults.rs`.\n     //\n     // First we build the defaulted substitution.\n-    let substs = InternalSubsts::for_item(fcx.tcx, def_id, |param, _| {\n+    let substs = InternalSubsts::for_item(tcx, def_id, |param, _| {\n         match param.kind {\n             GenericParamDefKind::Lifetime => {\n                 // All regions are identity.\n-                fcx.tcx.mk_param_from_def(param)\n+                tcx.mk_param_from_def(param)\n             }\n \n             GenericParamDefKind::Type { .. } => {\n                 // If the param has a default, ...\n                 if is_our_default(param) {\n-                    let default_ty = fcx.tcx.type_of(param.def_id);\n+                    let default_ty = tcx.type_of(param.def_id);\n                     // ... and it's not a dependent default, ...\n                     if !default_ty.needs_subst() {\n                         // ... then substitute it with the default.\n                         return default_ty.into();\n                     }\n                 }\n \n-                fcx.tcx.mk_param_from_def(param)\n+                tcx.mk_param_from_def(param)\n             }\n             GenericParamDefKind::Const { .. } => {\n                 // FIXME(const_generics_defaults): I(@lcnr) feel like always\n@@ -811,7 +801,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     }\n                 }\n \n-                fcx.tcx.mk_param_from_def(param)\n+                tcx.mk_param_from_def(param)\n             }\n         }\n     });\n@@ -848,7 +838,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n             }\n             let mut param_count = CountParams::default();\n             let has_region = pred.visit_with(&mut param_count).is_break();\n-            let substituted_pred = pred.subst(fcx.tcx, substs);\n+            let substituted_pred = pred.subst(tcx, substs);\n             // Don't check non-defaulted params, dependent defaults (including lifetimes)\n             // or preds with multiple params.\n             if substituted_pred.has_param_types_or_consts()\n@@ -879,14 +869,14 @@ fn check_where_clauses<'tcx, 'fcx>(\n             traits::Obligation::new(cause, fcx.param_env, pred)\n         });\n \n-    let predicates = predicates.instantiate_identity(fcx.tcx);\n+    let predicates = predicates.instantiate_identity(tcx);\n \n     if let Some((mut return_ty, span)) = return_ty {\n         if return_ty.has_infer_types_or_consts() {\n             fcx.select_obligations_where_possible(false, |_| {});\n             return_ty = fcx.resolve_vars_if_possible(return_ty);\n         }\n-        check_opaque_types(tcx, fcx, def_id.expect_local(), span, return_ty);\n+        check_opaque_types(fcx, def_id.expect_local(), span, return_ty);\n     }\n \n     let predicates = fcx.normalize_associated_types_in(span, predicates);\n@@ -905,7 +895,6 @@ fn check_where_clauses<'tcx, 'fcx>(\n }\n \n fn check_fn_or_method<'fcx, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n     fcx: &FnCtxt<'fcx, 'tcx>,\n     span: Span,\n     sig: ty::PolyFnSig<'tcx>,\n@@ -930,7 +919,7 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     // FIXME(#25759) return types should not be implied bounds\n     implied_bounds.push(sig.output());\n \n-    check_where_clauses(tcx, fcx, span, def_id, Some((sig.output(), hir_decl.output.span())));\n+    check_where_clauses(fcx, span, def_id, Some((sig.output(), hir_decl.output.span())));\n }\n \n /// Checks \"defining uses\" of opaque `impl Trait` types to ensure that they meet the restrictions\n@@ -953,15 +942,16 @@ fn check_fn_or_method<'fcx, 'tcx>(\n /// ```\n ///\n fn check_opaque_types<'fcx, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n     fcx: &FnCtxt<'fcx, 'tcx>,\n     fn_def_id: LocalDefId,\n     span: Span,\n     ty: Ty<'tcx>,\n ) {\n-    trace!(\"check_opaque_types(ty={:?})\", ty);\n+    trace!(\"check_opaque_types(fn_def_id={:?}, ty={:?})\", fn_def_id, ty);\n+    let tcx = fcx.tcx;\n+\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n-        tcx: fcx.tcx,\n+        tcx,\n         ty_op: |ty| {\n             if let ty::Opaque(def_id, substs) = *ty.kind() {\n                 trace!(\"check_opaque_types: opaque_ty, {:?}, {:?}\", def_id, substs);"}]}