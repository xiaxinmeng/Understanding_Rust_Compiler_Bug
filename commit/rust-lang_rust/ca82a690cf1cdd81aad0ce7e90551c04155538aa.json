{"sha": "ca82a690cf1cdd81aad0ce7e90551c04155538aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhODJhNjkwY2YxY2RkODFhYWQwY2U3ZTkwNTUxYzA0MTU1NTM4YWE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-17T00:39:16Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-17T00:39:25Z"}, "message": "Move task/comm stuff from exprs to task in manual, change typarams from [] to <>.", "tree": {"sha": "8e570d8900b2b1e02cdad20f33e8d128f84f7081", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e570d8900b2b1e02cdad20f33e8d128f84f7081"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca82a690cf1cdd81aad0ce7e90551c04155538aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca82a690cf1cdd81aad0ce7e90551c04155538aa", "html_url": "https://github.com/rust-lang/rust/commit/ca82a690cf1cdd81aad0ce7e90551c04155538aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca82a690cf1cdd81aad0ce7e90551c04155538aa/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a209c8350de85303a1fe78900eca9dea7783e89", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a209c8350de85303a1fe78900eca9dea7783e89", "html_url": "https://github.com/rust-lang/rust/commit/5a209c8350de85303a1fe78900eca9dea7783e89"}], "stats": {"total": 262, "additions": 110, "deletions": 152}, "files": [{"sha": "b63a88ba3d211cf08dd9f3c1f4e525312c0ecbc4", "filename": "doc/rust.texi", "status": "modified", "additions": 110, "deletions": 152, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/ca82a690cf1cdd81aad0ce7e90551c04155538aa/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/ca82a690cf1cdd81aad0ce7e90551c04155538aa/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=ca82a690cf1cdd81aad0ce7e90551c04155538aa", "patch": "@@ -676,16 +676,12 @@ The keywords are:\n @tab @code{tag}\n @tab @code{vec}\n @tab @code{str}\n+@tab @code{with}\n @item @code{fn}\n @tab @code{iter}\n @tab @code{pred}\n @tab @code{obj}\n @tab @code{resource}\n-@item @code{task}\n-@tab @code{port}\n-@tab @code{chan}\n-@tab @code{spawn}\n-@tab @code{with}\n @item @code{if}\n @tab @code{else}\n @tab @code{alt}\n@@ -916,8 +912,6 @@ The special symbols are:\n @item @code{=}\n @tab @code{<-}\n @tab @code{<->}\n-@tab @code{<|}\n-@tab @code{|>}\n @tab @code{->}\n @item @code{+}\n @tab @code{++}\n@@ -995,7 +989,7 @@ reference in later passes. @xref{Ref.Gram}.\n \n An example of a path with type parameters:\n @example\n-m::map[int,str];\n+m::map<int,str>;\n @end example\n \n @page\n@@ -1422,6 +1416,9 @@ operating-system processes.\n * Ref.Task.Life::               Task lifecycle and state transitions.\n * Ref.Task.Dom::                Task domains.\n * Ref.Task.Sched::              Task scheduling model.\n+* Ref.Task.Spawn::              Library interface for making new tasks.\n+* Ref.Task.Send::               Library interface for sending messages.\n+* Ref.Task.Recv::               Library interface for receiving messages.\n @end menu\n \n @node       Ref.Task.Comm\n@@ -1477,8 +1474,8 @@ its memory budget, which causes a run-time signal. To help control this\n possibility, a semi-synchronous send operation is possible, which blocks until\n there is room in the existing queue before sending send.\n \n-The message-send operator is @code{<|}. @xref{Ref.Expr.Send}. The\n-message-receive operator is @code{|>}. @xref{Ref.Expr.Recv}.\n+Messages are sent on channels and received on ports using standard library\n+functions.\n \n @node       Ref.Task.Life\n @subsection Ref.Task.Life\n@@ -1581,6 +1578,82 @@ An executing task can @code{yield} control at any time, which deschedules it\n immediately. Entering any other non-executing state (blocked, dead) similarly\n deschedules the task.\n \n+\n+\n+@node       Ref.Task.Spawn\n+@subsection Ref.Task.Spawn\n+@c * Ref.Task.Spawn::               Calls for creating new tasks.\n+@cindex Spawn expression\n+\n+A call to @code{std::task::spawn}, passing a 0-argument function as its single\n+argument, causes the runtime to construct a new task executing the passed\n+function. The passed function is referred to as the @dfn{entry function} for\n+the spawned task, and any captured environment is carries is moved from the\n+spawning task to the spawned task before the spawned task begins execution.\n+\n+The result of a @code{spawn} call is a @code{std::task::task_id} value.\n+\n+An example of a @code{spawn} call:\n+@example\n+import std::task::*;\n+import std::comm::*;\n+\n+fn helper(c: chan<u8>) @{\n+    // do some work.\n+    let result = ...;\n+    send(c, result);\n+@}\n+\n+let p: port<u8>;\n+\n+spawn(bind helper(p.mk_chan()));\n+// let task run, do other things.\n+// ...\n+let result = p.recv();\n+\n+@end example\n+\n+@node       Ref.Task.Send\n+@subsection Ref.Task.Send\n+@c * Ref.Task.Send::            Calls for sending a value into a channel.\n+@cindex Send call\n+@cindex Messages\n+@cindex Communication\n+\n+Sending a value into a channel is done by a library call to\n+@code{std::comm::send}, which takes a channel and a value to send, and moves\n+the value into the channel's outgoing buffer.\n+\n+An example of a send:\n+@example\n+import std::comm::*;\n+let c: chan<str> = @dots{};\n+send(c, \"hello, world\");\n+@end example\n+\n+@node       Ref.Task.Recv\n+@subsection Ref.Task.Recv\n+@c * Ref.Task.Recv::           Calls for receiving a value from a channel.\n+@cindex Receive call\n+@cindex Messages\n+@cindex Communication\n+\n+Receiving a value is done by a call to the @code{recv} method, on an object of\n+type @code{std::comm::port}. This call causes the receiving task to enter the\n+@emph{blocked reading} state until a task is sending a value to the port, at\n+which point the runtime pseudo-randomly selects a sending task and moves a\n+value from the head of one of the task queues to the call's return value, and\n+un-blocks the receiving task. @xref{Ref.Run.Comm}.\n+\n+An example of a @emph{receive}:\n+@example\n+import std::comm::*;\n+let p: port<str> = @dots{};\n+let s: str = p.recv();\n+@end example\n+\n+\n+\n @page\n @node    Ref.Item\n @section Ref.Item\n@@ -1608,13 +1681,13 @@ declared is given by the grammar.  @xref{Ref.Gram}.\n \n Functions, iterators, objects and type definitions may be @emph{parametrized}\n by type. Type parameters are given as a comma-separated list of identifiers\n-enclosed in square brackets (@code{[]}), after the name of the item and before\n+enclosed in angle brackets (@code{<>}), after the name of the item and before\n its definition.  The type parameters of an item are part of the name, not the\n type of the item; in order to refer to the type-parametrized item, a\n referencing name must in general provide type arguments as a list of\n-comma-separated types enclosed within square brackets (though the\n-type-inference system can often infer such argument types from context). There\n-are no general parametric types.\n+comma-separated types enclosed within angle brackets. In practice, the\n+type-inference system can usually infer such argument types from\n+context. There are no general parametric types.\n \n @menu\n * Ref.Item.Mod::                Items defining modules.\n@@ -1978,12 +2051,12 @@ a = cat;\n \n An example of a @emph{recursive} @code{tag} item and its use:\n @example\n-tag list[T] @{\n+tag list<T> @{\n   nil;\n-  cons(T, @@list[T]);\n+  cons(T, @@list<T>);\n @}\n \n-let a: list[int] = cons(7, cons(13, nil));\n+let a: list<int> = cons(7, cons(13, nil));\n @end example\n \n \n@@ -2249,7 +2322,7 @@ vector. This behaviour supports idiomatic in-place ``growth'' of a mutable\n slot holding a vector:\n \n @example\n-let v: mutable vec[int] = [1, 2, 3];\n+let v: mutable [int] = [1, 2, 3];\n v += [4, 5, 6];\n @end example\n \n@@ -2341,10 +2414,9 @@ pinned values can pass over a port or channel.\n \n An example of a @code{port} type:\n @example\n-type port[vec[str]] svp;\n+type svp = port<[str]>;\n let p: svp = get_port();\n-let v: vec[str];\n-p |> v;\n+let v: [str] = p.recv();\n @end example\n \n @node       Ref.Type.Chan\n@@ -2380,10 +2452,10 @@ message is dropped.\n \n An example of a @code{chan} type:\n @example\n-type chan[vec[str]] svc;\n+type svc = chan<[str]>;\n let c: svc = get_chan();\n-let v: vec[str] = [\"hello\", \"world\"];\n-c <| v;\n+let v: [str] = [\"hello\", \"world\"];\n+std::comm::send(c, v);\n @end example\n \n @node       Ref.Type.Task\n@@ -2443,9 +2515,9 @@ obj adder(x: @@mutable int) @{\n     @}\n @}\n \n-obj sender(c: chan[int]) @{\n+obj sender(c: chan<int>) @{\n     fn take(z: int) @{\n-        c <| z;\n+        std::comm::send(c, z);\n     @}\n @}\n \n@@ -2455,10 +2527,10 @@ fn give_ints(t: taker) @{\n     t.take(3);\n @}\n \n-let p: port[int] = port();\n+let p: port<int> = std::comm::mk_port();\n \n let t1: taker = adder(@@mutable 0);\n-let t2: taker = sender(chan(p));\n+let t2: taker = sender(p.mk_chan());\n \n give_ints(t1);\n give_ints(t2);\n@@ -2864,9 +2936,6 @@ effects of the expression's evaluation.\n \n @menu\n * Ref.Expr.Copy::               Expression for copying a value.\n-* Ref.Expr.Spawn::              Expressions for creating new tasks.\n-* Ref.Expr.Send::               Expressions for sending a value into a channel.\n-* Ref.Expr.Recv::               Expression for receiving a value from a channel.\n * Ref.Expr.Call::               Expression for calling a function.\n * Ref.Expr.Bind::               Expression for binding arguments to functions.\n * Ref.Expr.Ret::                Expression for stopping and producing a value.\n@@ -2917,79 +2986,6 @@ x.y = z;\n x.y = z + 2;\n @end example\n \n-@node       Ref.Expr.Spawn\n-@subsection Ref.Expr.Spawn\n-@c * Ref.Expr.Spawn::               Expressions creating new tasks.\n-@cindex Spawn expression\n-\n-A @code{spawn} expression consists of keyword @code{spawn}, followed by\n-an optional literal string naming the new task and then a normal\n-@emph{call} expression (@pxref{Ref.Expr.Call}).  A @code{spawn}\n-expression causes the runtime to construct a new task executing the\n-called function with the given name.  The called function is referred\n-to as the @dfn{entry function} for the spawned task, and its arguments\n-are copied from the spawning task to the spawned task before the\n-spawned task begins execution.  If no explicit name is present, the\n-task is implicitly named with the string of the call expression.\n-\n-Functions taking alias-slot arguments, or returning non-nil values, cannot be\n-spawned. Iterators cannot be spawned.\n-\n-The result of a @code{spawn} expression is a @code{task} value.\n-\n-An example of a @code{spawn} expression:\n-@example\n-fn helper(out: chan[u8]) @{\n-    // do some work.\n-    out <| result;\n-@}\n-\n-let out: port[u8];\n-let p: task = spawn helper(chan(out));\n-let p2: task = spawn \"my_helper\" helper(chan(out));\n-// let task run, do other things.\n-let out |> result;\n-\n-@end example\n-\n-@node       Ref.Expr.Send\n-@subsection Ref.Expr.Send\n-@c * Ref.Expr.Send::            Expressions for sending a value into a channel.\n-@cindex Send expression\n-@cindex Communication\n-\n-Sending a value into a channel is done by the send operator @code{<|}, which\n-takes a channel and a value to send, and moves the value into the channel's\n-outgoing buffer.\n-\n-An example of a send:\n-@example\n-chan[str] c = @dots{};\n-c <| \"hello, world\";\n-@end example\n-\n-@node       Ref.Expr.Recv\n-@subsection Ref.Expr.Recv\n-@c * Ref.Expr.Recv::           Expression for receiving a value from a channel.\n-@cindex Receive expression\n-@cindex Communication\n-\n-The @dfn{receive expression} takes an @var{lval} to receive into and an\n-expression denoting a port, and applies the @emph{receive operator}\n-(@code{|>}) to the pair, moving a value out of the port and into the\n-@var{lval}. The expression causes the receiving task to enter the @emph{blocked\n-reading} state until a task is sending a value to the port, at which point the\n-runtime pseudo-randomly selects a sending task and copies a value from the\n-head of one of the task queues to the receiving location in memory, and\n-un-blocks the receiving task. @xref{Ref.Run.Comm}.\n-\n-An example of a @emph{receive}:\n-@example\n-port[str] p = @dots{};\n-let s: str;\n-p |> p;\n-@end example\n-\n @node       Ref.Expr.Call\n @subsection Ref.Expr.Call\n @c * Ref.Expr.Call::               Expression for calling a function.\n@@ -3182,9 +3178,9 @@ diagnostic buffer.\n \n An example of a @code{note} expression:\n @example\n-fn read_file_lines(path: &str) -> vec[str] @{\n+fn read_file_lines(path: &str) -> [str] @{\n     note path;\n-    let r: vec[str];\n+    let r: [str];\n     let f: file = open_read(path);\n     for each (s: str in lines(f)) @{\n         vec::append(r,s);\n@@ -3285,7 +3281,7 @@ run the loop over the slice.\n \n Example of 4 for loops, all identical:\n @example\n-let v: vec[foo] = [a, b, c];\n+let v: [foo] = [a, b, c];\n \n for (foo e in v.(0, vec::len(v))) @{\n     bar(e);\n@@ -3318,7 +3314,7 @@ the iterator.  When the iterator returns or fails, the loop terminates.\n Example of a foreach loop:\n @example\n let txt: str;\n-let lines: vec[str];\n+let lines: [str];\n for each (s: str in str::split(txt, \"\\n\")) @{\n     vec::push(lines, s);\n @}\n@@ -3350,8 +3346,8 @@ then any @code{else} block is executed.\n @cindex Switch expression, see @i{Alt expression}\n \n An @code{alt} expression is a multi-directional branch in program control.\n-There are three kinds of @code{alt} expression: communication @code{alt}\n-expressions, pattern @code{alt} expressions, and @code{alt type} expressions.\n+There are two kinds of @code{alt} expression: pattern @code{alt} expressions\n+and @code{alt type} expressions.\n \n The form of each kind of @code{alt} is similar: an initial @emph{head} that\n describes the criteria for branching, followed by a sequence of zero or more\n@@ -3362,48 +3358,10 @@ to the block associated with the chosen case, and then proceeds to the\n expression following the @code{alt} when the case block completes.\n \n @menu\n-* Ref.Expr.Alt.Comm::         Expression for branching on communication events.\n * Ref.Expr.Alt.Pat::          Expression for branching on pattern matches.\n * Ref.Expr.Alt.Type::         Expression for branching on types.\n @end menu\n \n-@node          Ref.Expr.Alt.Comm\n-@subsubsection Ref.Expr.Alt.Comm\n-@c * Ref.Expr.Alt.Comm::           Expression for branching on communication events.\n-@cindex Communication alt expression\n-@cindex Control-flow\n-@cindex Communication\n-@cindex Multiplexing\n-\n-The simplest form of @code{alt} expression is the a @emph{communication}\n-@code{alt}. The cases of a communication @code{alt}'s arms are send and\n-receive expressions. @xref{Ref.Task.Comm}.\n-\n-To execute a communication @code{alt}, the runtime checks all of the ports and\n-channels involved in the arms of the expression to see if any @code{case} can\n-execute without blocking.  If no @code{case} can execute, the task blocks, and\n-the runtime unblocks the task when a @code{case} @emph{can} execute. The\n-runtime then makes a pseudo-random choice from among the set of @code{case}\n-expressions that can execute, executes the expression of the @code{case} and\n-branches to the block of that arm.\n-\n-An example of a communication @code{alt} expression:\n-@example\n-let c: chan[int] = foo();\n-let p: port[str] = bar();\n-let x: int = 0;\n-let strs: vec[str];\n-\n-alt @{\n-    case (str s; p |> s) @{\n-        vec::append(strs, s);\n-    @}\n-    case (c <| x) @{\n-        x++;\n-    @}\n-@}\n-@end example\n-\n @node          Ref.Expr.Alt.Pat\n @subsubsection Ref.Expr.Alt.Pat\n @c * Ref.Expr.Alt.Pat::            Expression for branching on pattern matches.\n@@ -3427,9 +3385,9 @@ block.\n An example of a pattern @code{alt} expression:\n \n @example\n-type list[X] = tag(nil, cons(X, @@list[X]));\n+type list<X> = tag(nil, cons(X, @@list<X>));\n \n-let x: list[int] = cons(10, cons(11, nil));\n+let x: list<int> = cons(10, cons(11, nil));\n \n alt (x) @{\n     case (cons(a, cons(b, _))) @{\n@@ -3467,10 +3425,10 @@ alt type (x) @{\n     case (int i) @{\n         ret i;\n     @}\n-    case (list[int] li) @{\n+    case (list<int> li) @{\n         ret int_list_sum(li);\n     @}\n-    case (list[X] lx) @{\n+    case (list<X> lx) @{\n         ret list_len(lx);\n     @}\n     case (_) @{"}]}