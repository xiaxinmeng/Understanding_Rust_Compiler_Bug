{"sha": "7537b2036a472e80fce4295eb799a53f61f959c0", "node_id": "C_kwDOAAsO6NoAKDc1MzdiMjAzNmE0NzJlODBmY2U0Mjk1ZWI3OTlhNTNmNjFmOTU5YzA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-03-03T00:09:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-03T00:09:11Z"}, "message": "Rollup merge of #94375 - WaffleLapkin:copy-suggestion, r=estebank\n\nAdt copy suggestions\n\nPreviously we've only suggested adding `Copy` bounds when the type being moved/copied is a type parameter (generic). With this PR we also suggest adding bounds when a type\n- Can be copy\n- All predicates that need to be satisfied for that are based on type params\n\ni.e. we will suggest `T: Copy` for `Option<T>`, but won't suggest anything for `Option<String>`.\n\nAn example:\n```rust\nfn duplicate<T>(t: Option<T>) -> (Option<T>, Option<T>) {\n    (t, t)\n}\n```\nNew error (current compiler doesn't provide `help`:):\n```text\nerror[E0382]: use of moved value: `t`\n --> t.rs:2:9\n  |\n1 | fn duplicate<T>(t: Option<T>) -> (Option<T>, Option<T>) {\n  |                 - move occurs because `t` has type `Option<T>`, which does not implement the `Copy` trait\n2 |     (t, t)\n  |      -  ^ value used here after move\n  |      |\n  |      value moved here\n  |\nhelp: consider restricting type parameter `T`\n  |\n1 | fn duplicate<T: Copy>(t: Option<T>) -> (Option<T>, Option<T>) {\n  |               ++++++\n```\n\nFixes #93623\nr? ``````````@estebank``````````\n``````````@rustbot`````````` label +A-diagnostics +A-suggestion-diagnostics +C-enhancement\n\n----\n\nI'm not at all sure if this is the right implementation for this kind of suggestion, but it seems to work :')", "tree": {"sha": "ec75d349f3e5fc79f6f509bac6c229d3eebb6878", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec75d349f3e5fc79f6f509bac6c229d3eebb6878"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7537b2036a472e80fce4295eb799a53f61f959c0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiIAcnCRBK7hj4Ov3rIwAAz7EIAJMtDg/8PuvE7rINEi5rQ1Ed\ne8//zN/5vdalrN7jE/5HLPknRc0u67Bady/VhfDkZl2M1rf/TIV2mQZvSNDqT6Lp\nzlZznRi59G3x35C1OINBTw2ct2vGIykF7gLMEhYKJHjd0dANkN0diEspQxYWRUMf\nsDoJk4U9dUJYOw41soxARoQUViTyWRIh0qvrsGgm6JstnSjHNy0Txe6+dgltgcAf\nyJ5VHHtmMjyOajK9PPPxgGDq9ghCp+txUQbAvWGGJTsYqHJc4sMLpDUnOqgGa2Ac\nX5OI15c/hTOGRtLzLSuXCTAXHkIBgtCV/7S72iCPnwnnda5FRu4cADGwtTA1A60=\n=SSrp\n-----END PGP SIGNATURE-----\n", "payload": "tree ec75d349f3e5fc79f6f509bac6c229d3eebb6878\nparent c9dc44be24c58ff13ce46416c4b97ab5c1bd8429\nparent f0a16b856011c8e63fac98fd6c127c2a0bbd532e\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1646266151 +0100\ncommitter GitHub <noreply@github.com> 1646266151 +0100\n\nRollup merge of #94375 - WaffleLapkin:copy-suggestion, r=estebank\n\nAdt copy suggestions\n\nPreviously we've only suggested adding `Copy` bounds when the type being moved/copied is a type parameter (generic). With this PR we also suggest adding bounds when a type\n- Can be copy\n- All predicates that need to be satisfied for that are based on type params\n\ni.e. we will suggest `T: Copy` for `Option<T>`, but won't suggest anything for `Option<String>`.\n\nAn example:\n```rust\nfn duplicate<T>(t: Option<T>) -> (Option<T>, Option<T>) {\n    (t, t)\n}\n```\nNew error (current compiler doesn't provide `help`:):\n```text\nerror[E0382]: use of moved value: `t`\n --> t.rs:2:9\n  |\n1 | fn duplicate<T>(t: Option<T>) -> (Option<T>, Option<T>) {\n  |                 - move occurs because `t` has type `Option<T>`, which does not implement the `Copy` trait\n2 |     (t, t)\n  |      -  ^ value used here after move\n  |      |\n  |      value moved here\n  |\nhelp: consider restricting type parameter `T`\n  |\n1 | fn duplicate<T: Copy>(t: Option<T>) -> (Option<T>, Option<T>) {\n  |               ++++++\n```\n\nFixes #93623\nr? ``````````@estebank``````````\n``````````@rustbot`````````` label +A-diagnostics +A-suggestion-diagnostics +C-enhancement\n\n----\n\nI'm not at all sure if this is the right implementation for this kind of suggestion, but it seems to work :')\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7537b2036a472e80fce4295eb799a53f61f959c0", "html_url": "https://github.com/rust-lang/rust/commit/7537b2036a472e80fce4295eb799a53f61f959c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7537b2036a472e80fce4295eb799a53f61f959c0/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9dc44be24c58ff13ce46416c4b97ab5c1bd8429", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9dc44be24c58ff13ce46416c4b97ab5c1bd8429", "html_url": "https://github.com/rust-lang/rust/commit/c9dc44be24c58ff13ce46416c4b97ab5c1bd8429"}, {"sha": "f0a16b856011c8e63fac98fd6c127c2a0bbd532e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0a16b856011c8e63fac98fd6c127c2a0bbd532e", "html_url": "https://github.com/rust-lang/rust/commit/f0a16b856011c8e63fac98fd6c127c2a0bbd532e"}], "stats": {"total": 772, "additions": 608, "deletions": 164}, "files": [{"sha": "684a3ced5a0700725ab43d86dc20ce920cec2d3a", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7537b2036a472e80fce4295eb799a53f61f959c0/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7537b2036a472e80fce4295eb799a53f61f959c0/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=7537b2036a472e80fce4295eb799a53f61f959c0", "patch": "@@ -5,16 +5,21 @@ use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n     FakeReadCause, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, suggest_constraining_type_param, Ty};\n+use rustc_middle::ty::{\n+    self, suggest_constraining_type_param, suggest_constraining_type_params, PredicateKind, Ty,\n+};\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::TraitEngineExt as _;\n \n use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n@@ -423,7 +428,63 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             None,\n                         );\n                     }\n+                } else {\n+                    // Try to find predicates on *generic params* that would allow copying `ty`\n+\n+                    let tcx = self.infcx.tcx;\n+                    let generics = tcx.generics_of(self.mir_def_id());\n+                    if let Some(hir_generics) = tcx\n+                        .typeck_root_def_id(self.mir_def_id().to_def_id())\n+                        .as_local()\n+                        .and_then(|def_id| tcx.hir().get_generics(def_id))\n+                    {\n+                        let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n+                            let mut fulfill_cx =\n+                                <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n+\n+                            let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n+                            let cause = ObligationCause::new(\n+                                span,\n+                                self.mir_hir_id(),\n+                                rustc_infer::traits::ObligationCauseCode::MiscObligation,\n+                            );\n+                            fulfill_cx.register_bound(&infcx, self.param_env, ty, copy_did, cause);\n+                            let errors = fulfill_cx.select_where_possible(&infcx);\n+\n+                            // Only emit suggestion if all required predicates are on generic\n+                            errors\n+                                .into_iter()\n+                                .map(|err| match err.obligation.predicate.kind().skip_binder() {\n+                                    PredicateKind::Trait(predicate) => {\n+                                        match predicate.self_ty().kind() {\n+                                            ty::Param(param_ty) => Ok((\n+                                                generics.type_param(param_ty, tcx),\n+                                                predicate\n+                                                    .trait_ref\n+                                                    .print_only_trait_path()\n+                                                    .to_string(),\n+                                            )),\n+                                            _ => Err(()),\n+                                        }\n+                                    }\n+                                    _ => Err(()),\n+                                })\n+                                .collect()\n+                        });\n+\n+                        if let Ok(predicates) = predicates {\n+                            suggest_constraining_type_params(\n+                                tcx,\n+                                hir_generics,\n+                                &mut err,\n+                                predicates.iter().map(|(param, constraint)| {\n+                                    (param.name.as_str(), &**constraint, None)\n+                                }),\n+                            );\n+                        }\n+                    }\n                 }\n+\n                 let span = if let Some(local) = place.as_local() {\n                     let decl = &self.body.local_decls[local];\n                     Some(decl.source_info.span)"}, {"sha": "f977b0fffebb665cdf53258d9914e60abd15b297", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7537b2036a472e80fce4295eb799a53f61f959c0/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7537b2036a472e80fce4295eb799a53f61f959c0/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=7537b2036a472e80fce4295eb799a53f61f959c0", "patch": "@@ -56,6 +56,7 @@\n #![feature(nonzero_ops)]\n #![feature(unwrap_infallible)]\n #![feature(decl_macro)]\n+#![feature(drain_filter)]\n #![recursion_limit = \"512\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "99a3d4c7fe4f7c11f301e6e17621909103c4d343", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 235, "deletions": 163, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/7537b2036a472e80fce4295eb799a53f61f959c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7537b2036a472e80fce4295eb799a53f61f959c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=7537b2036a472e80fce4295eb799a53f61f959c0", "patch": "@@ -7,6 +7,7 @@ use crate::ty::{\n     ProjectionTy, Term, Ty, TyCtxt, TypeAndMut,\n };\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -157,9 +158,17 @@ pub fn suggest_arbitrary_trait_bound(\n     true\n }\n \n+#[derive(Debug)]\n+enum SuggestChangingConstraintsMessage<'a> {\n+    RestrictBoundFurther,\n+    RestrictType { ty: &'a str },\n+    RestrictTypeFurther { ty: &'a str },\n+    RemovingQSized,\n+}\n+\n fn suggest_removing_unsized_bound(\n     generics: &hir::Generics<'_>,\n-    err: &mut Diagnostic,\n+    suggestions: &mut Vec<(Span, String, SuggestChangingConstraintsMessage<'_>)>,\n     param_name: &str,\n     param: &hir::GenericParam<'_>,\n     def_id: Option<DefId>,\n@@ -221,13 +230,12 @@ fn suggest_removing_unsized_bound(\n                         //             ^^^^^^^^^\n                         (_, pos, _, _) => bounds[pos - 1].span().shrink_to_hi().to(bound.span()),\n                     };\n-                    err.span_suggestion_verbose(\n+\n+                    suggestions.push((\n                         sp,\n-                        \"consider removing the `?Sized` bound to make the \\\n-                            type parameter `Sized`\",\n                         String::new(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                        SuggestChangingConstraintsMessage::RemovingQSized,\n+                    ));\n                 }\n             }\n             _ => {}\n@@ -249,13 +257,12 @@ fn suggest_removing_unsized_bound(\n                     //       ^^^^^^^^^\n                     (_, pos) => param.bounds[pos - 1].span().shrink_to_hi().to(bound.span()),\n                 };\n-                err.span_suggestion_verbose(\n+\n+                suggestions.push((\n                     sp,\n-                    \"consider removing the `?Sized` bound to make the type parameter \\\n-                        `Sized`\",\n                     String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n+                    SuggestChangingConstraintsMessage::RemovingQSized,\n+                ));\n             }\n             _ => {}\n         }\n@@ -271,184 +278,249 @@ pub fn suggest_constraining_type_param(\n     constraint: &str,\n     def_id: Option<DefId>,\n ) -> bool {\n-    let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n+    suggest_constraining_type_params(\n+        tcx,\n+        generics,\n+        err,\n+        [(param_name, constraint, def_id)].into_iter(),\n+    )\n+}\n \n-    let Some(param) = param else {\n-        return false;\n-    };\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_params<'a>(\n+    tcx: TyCtxt<'_>,\n+    generics: &hir::Generics<'_>,\n+    err: &mut Diagnostic,\n+    param_names_and_constraints: impl Iterator<Item = (&'a str, &'a str, Option<DefId>)>,\n+) -> bool {\n+    let mut grouped = FxHashMap::default();\n+    param_names_and_constraints.for_each(|(param_name, constraint, def_id)| {\n+        grouped.entry(param_name).or_insert(Vec::new()).push((constraint, def_id))\n+    });\n \n-    const MSG_RESTRICT_BOUND_FURTHER: &str = \"consider further restricting this bound\";\n-    let msg_restrict_type = format!(\"consider restricting type parameter `{}`\", param_name);\n-    let msg_restrict_type_further =\n-        format!(\"consider further restricting type parameter `{}`\", param_name);\n+    let mut applicability = Applicability::MachineApplicable;\n+    let mut suggestions = Vec::new();\n \n-    if def_id == tcx.lang_items().sized_trait() {\n-        // Type parameters are already `Sized` by default.\n-        err.span_label(param.span, &format!(\"this type parameter needs to be `{}`\", constraint));\n-        suggest_removing_unsized_bound(generics, err, param_name, param, def_id);\n-        return true;\n-    }\n-    let mut suggest_restrict = |span| {\n-        err.span_suggestion_verbose(\n-            span,\n-            MSG_RESTRICT_BOUND_FURTHER,\n-            format!(\" + {}\", constraint),\n-            Applicability::MachineApplicable,\n-        );\n-    };\n+    for (param_name, mut constraints) in grouped {\n+        let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n+        let Some(param) = param else { return false };\n \n-    if param_name.starts_with(\"impl \") {\n-        // If there's an `impl Trait` used in argument position, suggest\n-        // restricting it:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             help: consider further restricting this bound with `+ Bar`\n-        //\n-        // Suggestion for tools in this case is:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             replace with: `impl Foo + Bar`\n-\n-        suggest_restrict(param.span.shrink_to_hi());\n-        return true;\n-    }\n+        {\n+            let mut sized_constraints =\n+                constraints.drain_filter(|(_, def_id)| *def_id == tcx.lang_items().sized_trait());\n+            if let Some((constraint, def_id)) = sized_constraints.next() {\n+                applicability = Applicability::MaybeIncorrect;\n \n-    if generics.where_clause.predicates.is_empty()\n-        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n-        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n-        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-    {\n-        if let Some(span) = param.bounds_span_for_suggestions() {\n-            // If user has provided some bounds, suggest restricting them:\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"this type parameter needs to be `{}`\", constraint),\n+                );\n+                suggest_removing_unsized_bound(\n+                    generics,\n+                    &mut suggestions,\n+                    param_name,\n+                    param,\n+                    def_id,\n+                );\n+            }\n+        }\n+\n+        if constraints.is_empty() {\n+            continue;\n+        }\n+\n+        let constraint = constraints.iter().map(|&(c, _)| c).collect::<Vec<_>>().join(\" + \");\n+        let mut suggest_restrict = |span| {\n+            suggestions.push((\n+                span,\n+                format!(\" + {}\", constraint),\n+                SuggestChangingConstraintsMessage::RestrictBoundFurther,\n+            ))\n+        };\n+\n+        if param_name.starts_with(\"impl \") {\n+            // If there's an `impl Trait` used in argument position, suggest\n+            // restricting it:\n             //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //             ---\n+            //   fn foo(t: impl Foo) { ... }\n+            //             --------\n             //             |\n             //             help: consider further restricting this bound with `+ Bar`\n             //\n             // Suggestion for tools in this case is:\n             //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //          --\n-            //          |\n-            //          replace with: `T: Bar +`\n-            suggest_restrict(span);\n-        } else {\n-            // If user hasn't provided any bounds, suggest adding a new one:\n-            //\n-            //   fn foo<T>(t: T) { ... }\n-            //          - help: consider restricting this type parameter with `T: Foo`\n-            err.span_suggestion_verbose(\n-                param.span.shrink_to_hi(),\n-                &msg_restrict_type,\n-                format!(\": {}\", constraint),\n-                Applicability::MachineApplicable,\n-            );\n+            //   fn foo(t: impl Foo) { ... }\n+            //             --------\n+            //             |\n+            //             replace with: `impl Foo + Bar`\n+\n+            suggest_restrict(param.span.shrink_to_hi());\n+            continue;\n         }\n \n-        true\n-    } else {\n-        // This part is a bit tricky, because using the `where` clause user can\n-        // provide zero, one or many bounds for the same type parameter, so we\n-        // have following cases to consider:\n-        //\n-        // 1) When the type parameter has been provided zero bounds\n-        //\n-        //    Message:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //             - help: consider restricting this type parameter with `where X: Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //                                           - insert: `, X: Bar`\n-        //\n-        //\n-        // 2) When the type parameter has been provided one bound\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^^^^^\n-        //                            |\n-        //                            help: consider further restricting this bound with `+ Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^\n-        //                            |\n-        //                            replace with: `T: Bar +`\n-        //\n-        //\n-        // 3) When the type parameter has been provided many bounds\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //             - help: consider further restricting this type parameter with `where T: Zar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //                                          - insert: `, T: Zar`\n-        //\n-        // Additionally, there may be no `where` clause whatsoever in the case that this was\n-        // reached because the generic parameter has a default:\n-        //\n-        //    Message:\n-        //      trait Foo<T=()> {... }\n-        //             - help: consider further restricting this type parameter with `where T: Zar`\n-        //\n-        //    Suggestion:\n-        //      trait Foo<T=()> where T: Zar {... }\n-        //                     - insert: `where T: Zar`\n-\n-        if matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-            && generics.where_clause.predicates.len() == 0\n+        if generics.where_clause.predicates.is_empty()\n+        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n+        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n+        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n         {\n-            // Suggest a bound, but there is no existing `where` clause *and* the type param has a\n-            // default (`<T=Foo>`), so we suggest adding `where T: Bar`.\n-            err.span_suggestion_verbose(\n-                generics.where_clause.tail_span_for_suggestion(),\n-                &msg_restrict_type_further,\n-                format!(\" where {}: {}\", param_name, constraint),\n-                Applicability::MachineApplicable,\n-            );\n+            if let Some(span) = param.bounds_span_for_suggestions() {\n+                // If user has provided some bounds, suggest restricting them:\n+                //\n+                //   fn foo<T: Foo>(t: T) { ... }\n+                //             ---\n+                //             |\n+                //             help: consider further restricting this bound with `+ Bar`\n+                //\n+                // Suggestion for tools in this case is:\n+                //\n+                //   fn foo<T: Foo>(t: T) { ... }\n+                //          --\n+                //          |\n+                //          replace with: `T: Bar +`\n+                suggest_restrict(span);\n+            } else {\n+                // If user hasn't provided any bounds, suggest adding a new one:\n+                //\n+                //   fn foo<T>(t: T) { ... }\n+                //          - help: consider restricting this type parameter with `T: Foo`\n+                suggestions.push((\n+                    param.span.shrink_to_hi(),\n+                    format!(\": {}\", constraint),\n+                    SuggestChangingConstraintsMessage::RestrictType { ty: param_name },\n+                ));\n+            }\n         } else {\n-            let mut param_spans = Vec::new();\n+            // This part is a bit tricky, because using the `where` clause user can\n+            // provide zero, one or many bounds for the same type parameter, so we\n+            // have following cases to consider:\n+            //\n+            // 1) When the type parameter has been provided zero bounds\n+            //\n+            //    Message:\n+            //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+            //             - help: consider restricting this type parameter with `where X: Bar`\n+            //\n+            //    Suggestion:\n+            //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+            //                                           - insert: `, X: Bar`\n+            //\n+            //\n+            // 2) When the type parameter has been provided one bound\n+            //\n+            //    Message:\n+            //      fn foo<T>(t: T) where T: Foo { ... }\n+            //                            ^^^^^^\n+            //                            |\n+            //                            help: consider further restricting this bound with `+ Bar`\n+            //\n+            //    Suggestion:\n+            //      fn foo<T>(t: T) where T: Foo { ... }\n+            //                            ^^\n+            //                            |\n+            //                            replace with: `T: Bar +`\n+            //\n+            //\n+            // 3) When the type parameter has been provided many bounds\n+            //\n+            //    Message:\n+            //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+            //             - help: consider further restricting this type parameter with `where T: Zar`\n+            //\n+            //    Suggestion:\n+            //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+            //                                          - insert: `, T: Zar`\n+            //\n+            // Additionally, there may be no `where` clause whatsoever in the case that this was\n+            // reached because the generic parameter has a default:\n+            //\n+            //    Message:\n+            //      trait Foo<T=()> {... }\n+            //             - help: consider further restricting this type parameter with `where T: Zar`\n+            //\n+            //    Suggestion:\n+            //      trait Foo<T=()> where T: Zar {... }\n+            //                     - insert: `where T: Zar`\n \n-            for predicate in generics.where_clause.predicates {\n-                if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                    span,\n-                    bounded_ty,\n-                    ..\n-                }) = predicate\n-                {\n-                    if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n-                        if let Some(segment) = path.segments.first() {\n-                            if segment.ident.to_string() == param_name {\n-                                param_spans.push(span);\n+            if matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n+                && generics.where_clause.predicates.len() == 0\n+            {\n+                // Suggest a bound, but there is no existing `where` clause *and* the type param has a\n+                // default (`<T=Foo>`), so we suggest adding `where T: Bar`.\n+                suggestions.push((\n+                    generics.where_clause.tail_span_for_suggestion(),\n+                    format!(\" where {}: {}\", param_name, constraint),\n+                    SuggestChangingConstraintsMessage::RestrictTypeFurther { ty: param_name },\n+                ));\n+            } else {\n+                let mut param_spans = Vec::new();\n+\n+                for predicate in generics.where_clause.predicates {\n+                    if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                        span,\n+                        bounded_ty,\n+                        ..\n+                    }) = predicate\n+                    {\n+                        if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n+                            if let Some(segment) = path.segments.first() {\n+                                if segment.ident.to_string() == param_name {\n+                                    param_spans.push(span);\n+                                }\n                             }\n                         }\n                     }\n                 }\n-            }\n \n-            match param_spans[..] {\n-                [&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n-                _ => {\n-                    err.span_suggestion_verbose(\n-                        generics.where_clause.tail_span_for_suggestion(),\n-                        &msg_restrict_type_further,\n-                        format!(\", {}: {}\", param_name, constraint),\n-                        Applicability::MachineApplicable,\n-                    );\n+                match param_spans[..] {\n+                    [&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n+                    _ => {\n+                        suggestions.push((\n+                            generics.where_clause.tail_span_for_suggestion(),\n+                            constraints\n+                                .iter()\n+                                .map(|&(constraint, _)| format!(\", {}: {}\", param_name, constraint))\n+                                .collect::<String>(),\n+                            SuggestChangingConstraintsMessage::RestrictTypeFurther {\n+                                ty: param_name,\n+                            },\n+                        ));\n+                    }\n                 }\n             }\n         }\n+    }\n \n-        true\n+    if suggestions.len() == 1 {\n+        let (span, suggestion, msg) = suggestions.pop().unwrap();\n+\n+        let s;\n+        let msg = match msg {\n+            SuggestChangingConstraintsMessage::RestrictBoundFurther => {\n+                \"consider further restricting this bound\"\n+            }\n+            SuggestChangingConstraintsMessage::RestrictType { ty } => {\n+                s = format!(\"consider restricting type parameter `{}`\", ty);\n+                &s\n+            }\n+            SuggestChangingConstraintsMessage::RestrictTypeFurther { ty } => {\n+                s = format!(\"consider further restricting type parameter `{}`\", ty);\n+                &s\n+            }\n+            SuggestChangingConstraintsMessage::RemovingQSized => {\n+                \"consider removing the `?Sized` bound to make the type parameter `Sized`\"\n+            }\n+        };\n+\n+        err.span_suggestion_verbose(span, msg, suggestion, applicability);\n+    } else {\n+        err.multipart_suggestion_verbose(\n+            \"consider restricting type parameters\",\n+            suggestions.into_iter().map(|(span, suggestion, _)| (span, suggestion)).collect(),\n+            applicability,\n+        );\n     }\n+\n+    true\n }\n \n /// Collect al types that have an implicit `'static` obligation that we could suggest `'_` for."}, {"sha": "d5c8d4e6bdf2b76852167e32974a089fc06f70ec", "filename": "src/test/ui/moves/use_of_moved_value_clone_suggestions.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7537b2036a472e80fce4295eb799a53f61f959c0/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7537b2036a472e80fce4295eb799a53f61f959c0/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.rs?ref=7537b2036a472e80fce4295eb799a53f61f959c0", "patch": "@@ -0,0 +1,6 @@\n+// `Rc` is not ever `Copy`, we should not suggest adding `T: Copy` constraint\n+fn duplicate_rc<T>(t: std::rc::Rc<T>) -> (std::rc::Rc<T>, std::rc::Rc<T>) {\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn main() {}"}, {"sha": "c25981e6f80634cc73dedb1d7996f1b9d65fe932", "filename": "src/test/ui/moves/use_of_moved_value_clone_suggestions.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7537b2036a472e80fce4295eb799a53f61f959c0/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7537b2036a472e80fce4295eb799a53f61f959c0/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.stderr?ref=7537b2036a472e80fce4295eb799a53f61f959c0", "patch": "@@ -0,0 +1,13 @@\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_clone_suggestions.rs:3:9\n+   |\n+LL | fn duplicate_rc<T>(t: std::rc::Rc<T>) -> (std::rc::Rc<T>, std::rc::Rc<T>) {\n+   |                    - move occurs because `t` has type `Rc<T>`, which does not implement the `Copy` trait\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "d31046c77006e1c68dfb8bf9d20edb08370fa996", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.fixed", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7537b2036a472e80fce4295eb799a53f61f959c0/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7537b2036a472e80fce4295eb799a53f61f959c0/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.fixed?ref=7537b2036a472e80fce4295eb799a53f61f959c0", "patch": "@@ -0,0 +1,72 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+fn duplicate_t<T: Copy>(t: T) -> (T, T) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_opt<T: Copy>(t: Option<T>) -> (Option<T>, Option<T>) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_tup1<T: Copy>(t: (T,)) -> ((T,), (T,)) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_tup2<A: Copy, B: Copy>(t: (A, B)) -> ((A, B), (A, B)) {\n+    //~^ HELP consider restricting type parameters\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom<T: Trait + Copy>(t: S<T>) -> (S<T>, S<T>) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+struct S<T>(T);\n+trait Trait {}\n+impl<T: Trait + Clone> Clone for S<T> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone())\n+    }\n+}\n+impl<T: Trait + Copy> Copy for S<T> {}\n+\n+trait A {}\n+trait B {}\n+\n+// Test where bounds are added with different bound placements\n+fn duplicate_custom_1<T: Trait + Copy>(t: S<T>) -> (S<T>, S<T>) where {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom_2<T>(t: S<T>) -> (S<T>, S<T>)\n+where\n+    T: A + Trait + Copy,\n+    //~^ HELP consider further restricting this bound\n+{\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom_3<T>(t: S<T>) -> (S<T>, S<T>)\n+where\n+    T: A,\n+    T: B, T: Trait, T: Copy\n+    //~^ HELP consider further restricting type parameter `T`\n+{\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom_4<T: A>(t: S<T>) -> (S<T>, S<T>)\n+where\n+    T: B + Trait + Copy,\n+    //~^ HELP consider further restricting this bound\n+{\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn main() {}"}, {"sha": "7cc5189fac017effed958a966bf67aa7c09d1a3e", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7537b2036a472e80fce4295eb799a53f61f959c0/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7537b2036a472e80fce4295eb799a53f61f959c0/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.rs?ref=7537b2036a472e80fce4295eb799a53f61f959c0", "patch": "@@ -0,0 +1,72 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+fn duplicate_t<T>(t: T) -> (T, T) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_opt<T>(t: Option<T>) -> (Option<T>, Option<T>) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_tup1<T>(t: (T,)) -> ((T,), (T,)) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_tup2<A, B>(t: (A, B)) -> ((A, B), (A, B)) {\n+    //~^ HELP consider restricting type parameters\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom<T>(t: S<T>) -> (S<T>, S<T>) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+struct S<T>(T);\n+trait Trait {}\n+impl<T: Trait + Clone> Clone for S<T> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone())\n+    }\n+}\n+impl<T: Trait + Copy> Copy for S<T> {}\n+\n+trait A {}\n+trait B {}\n+\n+// Test where bounds are added with different bound placements\n+fn duplicate_custom_1<T>(t: S<T>) -> (S<T>, S<T>) where {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom_2<T>(t: S<T>) -> (S<T>, S<T>)\n+where\n+    T: A,\n+    //~^ HELP consider further restricting this bound\n+{\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom_3<T>(t: S<T>) -> (S<T>, S<T>)\n+where\n+    T: A,\n+    T: B,\n+    //~^ HELP consider further restricting type parameter `T`\n+{\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom_4<T: A>(t: S<T>) -> (S<T>, S<T>)\n+where\n+    T: B,\n+    //~^ HELP consider further restricting this bound\n+{\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn main() {}"}, {"sha": "8e72697ca30bbafce9810285c8b6ad80c5f5f93b", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.stderr", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/7537b2036a472e80fce4295eb799a53f61f959c0/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7537b2036a472e80fce4295eb799a53f61f959c0/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr?ref=7537b2036a472e80fce4295eb799a53f61f959c0", "patch": "@@ -0,0 +1,147 @@\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:6:9\n+   |\n+LL | fn duplicate_t<T>(t: T) -> (T, T) {\n+   |                   - move occurs because `t` has type `T`, which does not implement the `Copy` trait\n+LL |\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn duplicate_t<T: Copy>(t: T) -> (T, T) {\n+   |                 ++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:11:9\n+   |\n+LL | fn duplicate_opt<T>(t: Option<T>) -> (Option<T>, Option<T>) {\n+   |                     - move occurs because `t` has type `Option<T>`, which does not implement the `Copy` trait\n+LL |\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn duplicate_opt<T: Copy>(t: Option<T>) -> (Option<T>, Option<T>) {\n+   |                   ++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:16:9\n+   |\n+LL | fn duplicate_tup1<T>(t: (T,)) -> ((T,), (T,)) {\n+   |                      - move occurs because `t` has type `(T,)`, which does not implement the `Copy` trait\n+LL |\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn duplicate_tup1<T: Copy>(t: (T,)) -> ((T,), (T,)) {\n+   |                    ++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:21:9\n+   |\n+LL | fn duplicate_tup2<A, B>(t: (A, B)) -> ((A, B), (A, B)) {\n+   |                         - move occurs because `t` has type `(A, B)`, which does not implement the `Copy` trait\n+LL |\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameters\n+   |\n+LL | fn duplicate_tup2<A: Copy, B: Copy>(t: (A, B)) -> ((A, B), (A, B)) {\n+   |                    ++++++   ++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:26:9\n+   |\n+LL | fn duplicate_custom<T>(t: S<T>) -> (S<T>, S<T>) {\n+   |                        - move occurs because `t` has type `S<T>`, which does not implement the `Copy` trait\n+LL |\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn duplicate_custom<T: Trait + Copy>(t: S<T>) -> (S<T>, S<T>) {\n+   |                      ++++++++++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:44:9\n+   |\n+LL | fn duplicate_custom_1<T>(t: S<T>) -> (S<T>, S<T>) where {\n+   |                          - move occurs because `t` has type `S<T>`, which does not implement the `Copy` trait\n+LL |\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn duplicate_custom_1<T: Trait + Copy>(t: S<T>) -> (S<T>, S<T>) where {\n+   |                        ++++++++++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:52:9\n+   |\n+LL | fn duplicate_custom_2<T>(t: S<T>) -> (S<T>, S<T>)\n+   |                          - move occurs because `t` has type `S<T>`, which does not implement the `Copy` trait\n+...\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider further restricting this bound\n+   |\n+LL |     T: A + Trait + Copy,\n+   |          ++++++++++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:61:9\n+   |\n+LL | fn duplicate_custom_3<T>(t: S<T>) -> (S<T>, S<T>)\n+   |                          - move occurs because `t` has type `S<T>`, which does not implement the `Copy` trait\n+...\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider further restricting type parameter `T`\n+   |\n+LL |     T: B, T: Trait, T: Copy\n+   |         ~~~~~~~~~~~~~~~~~~~\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:69:9\n+   |\n+LL | fn duplicate_custom_4<T: A>(t: S<T>) -> (S<T>, S<T>)\n+   |                             - move occurs because `t` has type `S<T>`, which does not implement the `Copy` trait\n+...\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider further restricting this bound\n+   |\n+LL |     T: B + Trait + Copy,\n+   |          ++++++++++++++\n+\n+error: aborting due to 9 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}]}