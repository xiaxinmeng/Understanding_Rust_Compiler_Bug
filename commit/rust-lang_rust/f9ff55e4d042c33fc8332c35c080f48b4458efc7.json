{"sha": "f9ff55e4d042c33fc8332c35c080f48b4458efc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZmY1NWU0ZDA0MmMzM2ZjODMzMmMzNWMwODBmNDhiNDQ1OGVmYzc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T16:34:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T19:50:25Z"}, "message": "rollup merge of #19827: japaric/clone-uc\n\ncloses #12677 (cc @Valloric)\ncc #15294\n\nr? @aturon / @alexcrichton\n\n(Because of #19358 I had to move the struct bounds from the `where` clause into the parameter list)", "tree": {"sha": "e6a4aae247e686ce97f78335f4cf101fe64d975b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6a4aae247e686ce97f78335f4cf101fe64d975b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9ff55e4d042c33fc8332c35c080f48b4458efc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9ff55e4d042c33fc8332c35c080f48b4458efc7", "html_url": "https://github.com/rust-lang/rust/commit/f9ff55e4d042c33fc8332c35c080f48b4458efc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9ff55e4d042c33fc8332c35c080f48b4458efc7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5302217f026ba00e9f0514992b5f8226f7cb541", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5302217f026ba00e9f0514992b5f8226f7cb541", "html_url": "https://github.com/rust-lang/rust/commit/b5302217f026ba00e9f0514992b5f8226f7cb541"}, {"sha": "2f7a5f49029279bd734ef87fd65ae992b2ad9f40", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f7a5f49029279bd734ef87fd65ae992b2ad9f40", "html_url": "https://github.com/rust-lang/rust/commit/2f7a5f49029279bd734ef87fd65ae992b2ad9f40"}], "stats": {"total": 152, "additions": 152, "deletions": 0}, "files": [{"sha": "11217f8dc791ebbe51973044aa1b77f2bdc9835d", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f9ff55e4d042c33fc8332c35c080f48b4458efc7/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ff55e4d042c33fc8332c35c080f48b4458efc7/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=f9ff55e4d042c33fc8332c35c080f48b4458efc7", "patch": "@@ -1388,6 +1388,19 @@ pub struct Map<A, B, I: Iterator<A>, F: FnMut(A) -> B> {\n     f: F,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, B, I, F> Clone for Map<A, B, I, F> where\n+    I: Clone + Iterator<A>,\n+    F: Clone + FnMut(A) -> B,\n+{\n+    fn clone(&self) -> Map<A, B, I, F> {\n+        Map {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+        }\n+    }\n+}\n+\n impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> B {\n     #[inline]\n     fn do_map(&mut self, elt: Option<A>) -> Option<B> {\n@@ -1449,6 +1462,19 @@ pub struct Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     predicate: P,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, I, P> Clone for Filter<A, I, P> where\n+    I: Clone + Iterator<A>,\n+    P: Clone + FnMut(&A) -> bool,\n+{\n+    fn clone(&self) -> Filter<A, I, P> {\n+        Filter {\n+            iter: self.iter.clone(),\n+            predicate: self.predicate.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, I, P> Iterator<A> for Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     #[inline]\n@@ -1494,6 +1520,19 @@ pub struct FilterMap<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> Option<B>\n     f: F,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n+    I: Clone + Iterator<A>,\n+    F: Clone + FnMut(A) -> Option<B>,\n+{\n+    fn clone(&self) -> FilterMap<A, B, I, F> {\n+        FilterMap {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, B, I, F> Iterator<B> for FilterMap<A, B, I, F> where\n     I: Iterator<A>,\n@@ -1657,6 +1696,20 @@ pub struct SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     predicate: P,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, I, P> Clone for SkipWhile<A, I, P> where\n+    I: Clone + Iterator<A>,\n+    P: Clone + FnMut(&A) -> bool,\n+{\n+    fn clone(&self) -> SkipWhile<A, I, P> {\n+        SkipWhile {\n+            iter: self.iter.clone(),\n+            flag: self.flag,\n+            predicate: self.predicate.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, I, P> Iterator<A> for SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     #[inline]\n@@ -1686,6 +1739,20 @@ pub struct TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     predicate: P,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, I, P> Clone for TakeWhile<A, I, P> where\n+    I: Clone + Iterator<A>,\n+    P: Clone + FnMut(&A) -> bool,\n+{\n+    fn clone(&self) -> TakeWhile<A, I, P> {\n+        TakeWhile {\n+            iter: self.iter.clone(),\n+            flag: self.flag,\n+            predicate: self.predicate.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, I, P> Iterator<A> for TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     #[inline]\n@@ -1847,6 +1914,21 @@ pub struct Scan<A, B, I, St, F> where I: Iterator<A>, F: FnMut(&mut St, A) -> Op\n     pub state: St,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n+    I: Clone + Iterator<A>,\n+    St: Clone,\n+    F: Clone + FnMut(&mut St, A) -> Option<B>,\n+{\n+    fn clone(&self) -> Scan<A, B, I, St, F> {\n+        Scan {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+            state: self.state.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, B, I, St, F> Iterator<B> for Scan<A, B, I, St, F> where\n     I: Iterator<A>,\n@@ -1876,6 +1958,22 @@ pub struct FlatMap<A, B, I, U, F> where I: Iterator<A>, U: Iterator<B>, F: FnMut\n     backiter: Option<U>,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n+    I: Clone + Iterator<A>,\n+    U: Clone + Iterator<B>,\n+    F: Clone + FnMut(A) -> U,\n+{\n+    fn clone(&self) -> FlatMap<A, B, I, U, F> {\n+        FlatMap {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+            frontiter: self.frontiter.clone(),\n+            backiter: self.backiter.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, B, I, U, F> Iterator<B> for FlatMap<A, B, I, U, F> where\n     I: Iterator<A>,\n@@ -2020,6 +2118,19 @@ pub struct Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n     f: F,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, I, F> Clone for Inspect<A, I, F> where\n+    I: Clone + Iterator<A>,\n+    F: Clone + FnMut(&A),\n+{\n+    fn clone(&self) -> Inspect<A, I, F> {\n+        Inspect {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+        }\n+    }\n+}\n+\n impl<A, I, F> Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n     #[inline]\n     fn do_inspect(&mut self, elt: Option<A>) -> Option<A> {\n@@ -2114,6 +2225,19 @@ pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     pub state: St,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, St, F> Clone for Unfold<A, St, F> where\n+    F: Clone + FnMut(&mut St) -> Option<A>,\n+    St: Clone,\n+{\n+    fn clone(&self) -> Unfold<A, St, F> {\n+        Unfold {\n+            f: self.f.clone(),\n+            state: self.state.clone(),\n+        }\n+    }\n+}\n+\n #[experimental]\n impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator"}, {"sha": "4d815f78c4618323f2e403b38a749bcc4ab086ed", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f9ff55e4d042c33fc8332c35c080f48b4458efc7/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ff55e4d042c33fc8332c35c080f48b4458efc7/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=f9ff55e4d042c33fc8332c35c080f48b4458efc7", "patch": "@@ -894,6 +894,17 @@ pub struct Splits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     finished: bool\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, T, P> Clone for Splits<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n+    fn clone(&self) -> Splits<'a, T, P> {\n+        Splits {\n+            v: self.v,\n+            pred: self.pred.clone(),\n+            finished: self.finished,\n+        }\n+    }\n+}\n+\n #[experimental = \"needs review\"]\n impl<'a, T, P> Iterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]"}, {"sha": "ef68daa8ce592a594d30e4b0b1fc1f5287b98024", "filename": "src/test/run-pass/issue-12677.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f9ff55e4d042c33fc8332c35c080f48b4458efc7/src%2Ftest%2Frun-pass%2Fissue-12677.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ff55e4d042c33fc8332c35c080f48b4458efc7/src%2Ftest%2Frun-pass%2Fissue-12677.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12677.rs?ref=f9ff55e4d042c33fc8332c35c080f48b4458efc7", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let s = \"Hello\";\n+    let first = s.bytes();\n+    let second = first.clone();\n+\n+    assert_eq!(first.collect::<Vec<u8>>(), second.collect::<Vec<u8>>())\n+}"}]}