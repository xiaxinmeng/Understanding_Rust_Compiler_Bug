{"sha": "63f9b43d36fe9d95d36c3d541c66df04c7c11618", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZjliNDNkMzZmZTlkOTVkMzZjM2Q1NDFjNjZkZjA0YzdjMTE2MTg=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-08-26T02:09:30Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-08-26T02:09:30Z"}, "message": "Docs for pure fn and unchecked", "tree": {"sha": "bbadf46ba031c2a5374270361963ceb1430b21fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbadf46ba031c2a5374270361963ceb1430b21fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63f9b43d36fe9d95d36c3d541c66df04c7c11618", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63f9b43d36fe9d95d36c3d541c66df04c7c11618", "html_url": "https://github.com/rust-lang/rust/commit/63f9b43d36fe9d95d36c3d541c66df04c7c11618", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63f9b43d36fe9d95d36c3d541c66df04c7c11618/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48c695300192a4475889009b41b8f0ff6dc596bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/48c695300192a4475889009b41b8f0ff6dc596bb", "html_url": "https://github.com/rust-lang/rust/commit/48c695300192a4475889009b41b8f0ff6dc596bb"}], "stats": {"total": 65, "additions": 60, "deletions": 5}, "files": [{"sha": "c1d6bba557a089eace4407701c5bafaf6e304b67", "filename": "doc/rust.texi", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/63f9b43d36fe9d95d36c3d541c66df04c7c11618/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/63f9b43d36fe9d95d36c3d541c66df04c7c11618/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=63f9b43d36fe9d95d36c3d541c66df04c7c11618", "patch": "@@ -642,6 +642,7 @@ The keywords are:\n @tab @code{syntax}\n @tab @code{mutable}\n @tab @code{native}\n+@tab @code{unchecked}\n @item @code{mod}\n @tab @code{import}\n @tab @code{export}\n@@ -679,7 +680,7 @@ The keywords are:\n @tab @code{with}\n @item @code{fn}\n @tab @code{iter}\n-@tab @code{pred}\n+@tab @code{pure}\n @tab @code{obj}\n @tab @code{resource}\n @item @code{if}\n@@ -1867,7 +1868,7 @@ control).\n Any pure boolean function is called a @emph{predicate}, and may be used\n as part of the static typestate system. @xref{Ref.Typestate.Constr}. A\n predicate declaration is identical to a function declaration, except that it\n-is declared with the keyword @code{pred} instead of @code{fn}. In addition,\n+is declared with the additional keyword @code{pure}. In addition,\n the typechecker checks the body of a predicate with a restricted set of\n typechecking rules. A predicate\n @itemize\n@@ -1878,11 +1879,65 @@ self-call expression; and\n \n An example of a predicate:\n @example\n-pred lt_42(int x) -> bool @{\n+pure fn lt_42(x: int) -> bool @{\n     ret (x < 42);\n @}\n @end example\n \n+A non-boolean function may also be declared with @code{pure fn}. This allows\n+predicates to call non-boolean functions as long as they are pure. For example:\n+@example\n+pure fn pure_length<@@T>(ls: &list<T>) -> uint @{ /* ... */ @}\n+\n+pure fn nonempty_list<@@T>(ls: &list<T>) -> bool @{ pure_length(ls) > 0u @}\n+@end example\n+\n+In this example, @code{nonempty_list} is a predicate---it can be used in a\n+typestate constraint---but the auxiliary function @code{pure_length}@ is\n+not.\n+\n+@emph{ToDo:} should actually define referential transparency.\n+\n+The effect checking rules previously enumerated are a restricted set of\n+typechecking rules meant to approximate the universe of observably\n+referentially transparent Rust procedures conservatively. Sometimes, these\n+rules are @emph{too} restrictive. Rust allows programmers to violate these\n+rules by writing predicates that the compiler cannot prove to be referentially\n+transparent, using an escape-hatch feature called ``unchecked blocks''. When\n+writing code that uses unchecked blocks, programmers should always be aware\n+that they have an obligation to show that the code @emph{behaves} referentially\n+transparently at all times, even if the compiler cannot @emph{prove}\n+automatically that the code is referentially transparent. In the presence of\n+unchecked blocks, the compiler provides no static guarantee that the code will\n+behave as expected at runtime. Rather, the programmer has an independent\n+obligation to verify the semantics of the predicates they write.\n+\n+@emph{ToDo:} last two sentences are vague.\n+\n+An example of a predicate that uses an unchecked block:\n+@example\n+fn pure_foldl<@@T, @@U>(ls: &list<T>, u: &U, f: &block(&T, &U) -> U) -> U @{\n+    alt ls @{\n+      nil. @{ u @}\n+      cons(hd, tl) @{ f(hd, pure_foldl(*tl, f(hd, u), f)) @}\n+    @}\n+@}\n+\n+pure fn pure_length<@@T>(ls: &list<T>) -> uint @{\n+    fn count<T>(_t: &T, u: &uint) -> uint @{ u + 1u @}\n+    unchecked @{\n+        pure_foldl(ls, 0u, count)\n+    @}\n+@}\n+@end example\n+\n+Despite its name, @code{pure_foldl} is a @code{fn}, not a @code{pure fn},\n+because there is no way in Rust to specify that the higher-order function\n+argument @code{f} is a pure function. So, to use @code{foldl} in a pure list\n+length function that a predicate could then use, we must use an\n+@code{unchecked} block wrapped around the call to @code{pure_foldl} in the\n+definition of @code{pure_length}.\n+ \n @node          Ref.Item.Iter\n @subsection    Ref.Item.Iter\n @c * Ref.Item.Iter::          Items defining iterators.\n@@ -2684,7 +2739,7 @@ A @dfn{constraint} is a predicate applied to specific slots.\n For example, consider the following code:\n \n @example\n-pred is_less_than(int a, int b) -> bool @{\n+pure fn is_less_than(int a, int b) -> bool @{\n      ret a < b;\n @}\n \n@@ -3461,7 +3516,7 @@ and statically comparing implied states and their\n specifications. @xref{Ref.Typestate}.\n \n @example\n-pred even(x: &int) -> bool @{\n+pure fn even(x: &int) -> bool @{\n     ret x & 1 == 0;\n @}\n "}]}