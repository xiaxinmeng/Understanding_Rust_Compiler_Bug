{"sha": "78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4YTRmOGM4Y2U2NmNkYTVmMTdhN2NiZjJiZDdkNzcyZDJmOGNmOGE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-26T12:17:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-26T12:17:43Z"}, "message": "Rollup merge of #65772 - mark-i-m:final-readmes, r=nikomatsakis\n\nRemove the last remaining READMEs\n\ncc https://github.com/rust-lang/rustc-guide/pull/481\n\ncloses #48478\n\nr? @nikomatsakis", "tree": {"sha": "faa9dd9a412c971535badd951ddfa584146ea398", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faa9dd9a412c971535badd951ddfa584146ea398"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdtDlnCRBK7hj4Ov3rIwAAdHIIAJt/AByYl8TT08spqgxW7VaK\nr0LMQbMejOiLlH5ILEJsw3leHG2oRKuDsmO4qduHuuMS04kQ81blcEZmIf768V+R\nBOL2p/opwICW/xPLChUpBI0WGpiEOurwEC82DR5DRFicNCPu0RfFjRuGi1PlxkWP\nrSbltKMjyt7i6n526DMgW5ZzHSBefuPJhMIxfE9oVDH9y5J36UBxjqGTNe+KpxV9\nAqvVfe25ZNzBNVcM52MdAZPxnbmGqe49o7P0lRSTysHwj2VTgA5EQncuckIp0CM+\nMxPtnqzKOQSgugh95+hn8i513PkVhufpm+E94tzBp5YU6ZvXwdH/AcmqtXeUX/k=\n=WvvJ\n-----END PGP SIGNATURE-----\n", "payload": "tree faa9dd9a412c971535badd951ddfa584146ea398\nparent d51a84259e796aba141e27b7811f2abc95363fca\nparent 1a93bc5c35126f318dd53ac5104879ca673f61b3\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1572092263 +0200\ncommitter GitHub <noreply@github.com> 1572092263 +0200\n\nRollup merge of #65772 - mark-i-m:final-readmes, r=nikomatsakis\n\nRemove the last remaining READMEs\n\ncc https://github.com/rust-lang/rustc-guide/pull/481\n\ncloses #48478\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a", "html_url": "https://github.com/rust-lang/rust/commit/78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d51a84259e796aba141e27b7811f2abc95363fca", "url": "https://api.github.com/repos/rust-lang/rust/commits/d51a84259e796aba141e27b7811f2abc95363fca", "html_url": "https://github.com/rust-lang/rust/commit/d51a84259e796aba141e27b7811f2abc95363fca"}, {"sha": "1a93bc5c35126f318dd53ac5104879ca673f61b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a93bc5c35126f318dd53ac5104879ca673f61b3", "html_url": "https://github.com/rust-lang/rust/commit/1a93bc5c35126f318dd53ac5104879ca673f61b3"}], "stats": {"total": 408, "additions": 8, "deletions": 400}, "files": [{"sha": "2f7cf90c5f0305b433880a533ed6fd26621255e7", "filename": "src/README.md", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a", "patch": "@@ -5,7 +5,4 @@ This directory contains the source code of the rust project, including:\n \n For more information on how various parts of the compiler work, see the [rustc guide].\n \n-There is also useful content in this README:\n-https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve.\n-\n [rustc guide]: https://rust-lang.github.io/rustc-guide/about-this-guide.html"}, {"sha": "c26b5625a90b636082a3c31001c0460cd040cd11", "filename": "src/librustc/infer/lexical_region_resolve/README.md", "status": "modified", "additions": 4, "deletions": 265, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md?ref=78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a", "patch": "@@ -1,268 +1,7 @@\n-# Region inference\n \n-> WARNING: This README is obsolete and will be removed soon! For\n-> more info on how the current borrowck works, see the [rustc guide].\n->\n-> As of edition 2018, region inference is done using Non-lexical lifetimes,\n-> which is described in the guide and [this RFC].\n+Lexical Region Resolution was removed in https://github.com/rust-lang/rust/pull/64790.\n \n-[rustc guide]: https://rust-lang.github.io/rustc-guide/borrow_check/region_inference.html\n-[this RFC]: https://github.com/rust-lang/rfcs/blob/master/text/2094-nll.md\n+Rust now uses Non-lexical lifetimes. For more info, please see the [borrowck\n+chapter][bc] in the rustc-guide.\n \n-## Terminology\n-\n-Note that we use the terms region and lifetime interchangeably.\n-\n-## Introduction\n-\n-Region inference uses a somewhat more involved algorithm than type\n-inference. It is not the most efficient thing ever written though it\n-seems to work well enough in practice (famous last words).  The reason\n-that we use a different algorithm is because, unlike with types, it is\n-impractical to hand-annotate with regions (in some cases, there aren't\n-even the requisite syntactic forms).  So we have to get it right, and\n-it's worth spending more time on a more involved analysis.  Moreover,\n-regions are a simpler case than types: they don't have aggregate\n-structure, for example.\n-\n-## The problem\n-\n-Basically our input is a directed graph where nodes can be divided\n-into two categories: region variables and concrete regions.  Each edge\n-`R -> S` in the graph represents a constraint that the region `R` is a\n-subregion of the region `S`.\n-\n-Region variable nodes can have arbitrary degree.  There is one region\n-variable node per region variable.\n-\n-Each concrete region node is associated with some, well, concrete\n-region: e.g., a free lifetime, or the region for a particular scope.\n-Note that there may be more than one concrete region node for a\n-particular region value.  Moreover, because of how the graph is built,\n-we know that all concrete region nodes have either in-degree 1 or\n-out-degree 1.\n-\n-Before resolution begins, we build up the constraints in a hashmap\n-that maps `Constraint` keys to spans.  During resolution, we construct\n-the actual `Graph` structure that we describe here.\n-\n-## Computing the values for region variables\n-\n-The algorithm is a simple dataflow algorithm. Each region variable\n-begins as empty. We iterate over the constraints, and for each constraint\n-we grow the relevant region variable to be as big as it must be to meet all the\n-constraints. This means the region variables can grow to be `'static` if\n-necessary.\n-\n-## Verification\n-\n-After all constraints are fully propoagated, we do a \"verification\"\n-step where we walk over the verify bounds and check that they are\n-satisfied. These bounds represent the \"maximal\" values that a region\n-variable can take on, basically.\n-\n-## The Region Hierarchy\n-\n-### Without closures\n-\n-Let's first consider the region hierarchy without thinking about\n-closures, because they add a lot of complications. The region\n-hierarchy *basically* mirrors the lexical structure of the code.\n-There is a region for every piece of 'evaluation' that occurs, meaning\n-every expression, block, and pattern (patterns are considered to\n-\"execute\" by testing the value they are applied to and creating any\n-relevant bindings).  So, for example:\n-\n-```rust\n-fn foo(x: isize, y: isize) { // -+\n-//  +------------+           //  |\n-//  |      +-----+           //  |\n-//  |  +-+ +-+ +-+           //  |\n-//  |  | | | | | |           //  |\n-//  v  v v v v v v           //  |\n-    let z = x + y;           //  |\n-    ...                      //  |\n-}                            // -+\n-\n-fn bar() { ... }\n-```\n-\n-In this example, there is a region for the fn body block as a whole,\n-and then a subregion for the declaration of the local variable.\n-Within that, there are sublifetimes for the assignment pattern and\n-also the expression `x + y`. The expression itself has sublifetimes\n-for evaluating `x` and `y`.\n-\n-#s## Function calls\n-\n-Function calls are a bit tricky. I will describe how we handle them\n-*now* and then a bit about how we can improve them (Issue #6268).\n-\n-Consider a function call like `func(expr1, expr2)`, where `func`,\n-`arg1`, and `arg2` are all arbitrary expressions. Currently,\n-we construct a region hierarchy like:\n-\n-    +----------------+\n-    |                |\n-    +--+ +---+  +---+|\n-    v  v v   v  v   vv\n-    func(expr1, expr2)\n-\n-Here you can see that the call as a whole has a region and the\n-function plus arguments are subregions of that. As a side-effect of\n-this, we get a lot of spurious errors around nested calls, in\n-particular when combined with `&mut` functions. For example, a call\n-like this one\n-\n-```rust\n-self.foo(self.bar())\n-```\n-\n-where both `foo` and `bar` are `&mut self` functions will always yield\n-an error.\n-\n-Here is a more involved example (which is safe) so we can see what's\n-going on:\n-\n-```rust\n-struct Foo { f: usize, g: usize }\n-// ...\n-fn add(p: &mut usize, v: usize) {\n-    *p += v;\n-}\n-// ...\n-fn inc(p: &mut usize) -> usize {\n-    *p += 1; *p\n-}\n-fn weird() {\n-    let mut x: Box<Foo> = box Foo { /* ... */ };\n-    'a: add(&mut (*x).f,\n-            'b: inc(&mut (*x).f)) // (..)\n-}\n-```\n-\n-The important part is the line marked `(..)` which contains a call to\n-`add()`. The first argument is a mutable borrow of the field `f`.  The\n-second argument also borrows the field `f`. Now, in the current borrow\n-checker, the first borrow is given the lifetime of the call to\n-`add()`, `'a`.  The second borrow is given the lifetime of `'b` of the\n-call to `inc()`. Because `'b` is considered to be a sublifetime of\n-`'a`, an error is reported since there are two co-existing mutable\n-borrows of the same data.\n-\n-However, if we were to examine the lifetimes a bit more carefully, we\n-can see that this error is unnecessary. Let's examine the lifetimes\n-involved with `'a` in detail. We'll break apart all the steps involved\n-in a call expression:\n-\n-```rust\n-'a: {\n-    'a_arg1: let a_temp1: ... = add;\n-    'a_arg2: let a_temp2: &'a mut usize = &'a mut (*x).f;\n-    'a_arg3: let a_temp3: usize = {\n-        let b_temp1: ... = inc;\n-        let b_temp2: &'b = &'b mut (*x).f;\n-        'b_call: b_temp1(b_temp2)\n-    };\n-    'a_call: a_temp1(a_temp2, a_temp3) // (**)\n-}\n-```\n-\n-Here we see that the lifetime `'a` includes a number of substatements.\n-In particular, there is this lifetime I've called `'a_call` that\n-corresponds to the *actual execution of the function `add()`*, after\n-all arguments have been evaluated. There is a corresponding lifetime\n-`'b_call` for the execution of `inc()`. If we wanted to be precise\n-about it, the lifetime of the two borrows should be `'a_call` and\n-`'b_call` respectively, since the references that were created\n-will not be dereferenced except during the execution itself.\n-\n-However, this model by itself is not sound. The reason is that\n-while the two references that are created will never be used\n-simultaneously, it is still true that the first reference is\n-*created* before the second argument is evaluated, and so even though\n-it will not be *dereferenced* during the evaluation of the second\n-argument, it can still be *invalidated* by that evaluation. Consider\n-this similar but unsound example:\n-\n-```rust\n-struct Foo { f: usize, g: usize }\n-// ...\n-fn add(p: &mut usize, v: usize) {\n-    *p += v;\n-}\n-// ...\n-fn consume(x: Box<Foo>) -> usize {\n-    x.f + x.g\n-}\n-fn weird() {\n-    let mut x: Box<Foo> = box Foo { ... };\n-    'a: add(&mut (*x).f, consume(x)) // (..)\n-}\n-```\n-\n-In this case, the second argument to `add` actually consumes `x`, thus\n-invalidating the first argument.\n-\n-So, for now, we exclude the `call` lifetimes from our model.\n-Eventually I would like to include them, but we will have to make the\n-borrow checker handle this situation correctly. In particular, if\n-there is a reference created whose lifetime does not enclose\n-the borrow expression, we must issue sufficient restrictions to ensure\n-that the pointee remains valid.\n-\n-### Modeling closures\n-\n-Integrating closures properly into the model is a bit of\n-work-in-progress. In an ideal world, we would model closures as\n-closely as possible after their desugared equivalents. That is, a\n-closure type would be modeled as a struct, and the region hierarchy of\n-different closure bodies would be completely distinct from all other\n-fns. We are generally moving in that direction but there are\n-complications in terms of the implementation.\n-\n-In practice what we currently do is somewhat different. The basis for\n-the current approach is the observation that the only time that\n-regions from distinct fn bodies interact with one another is through\n-an upvar or the type of a fn parameter (since closures live in the fn\n-body namespace, they can in fact have fn parameters whose types\n-include regions from the surrounding fn body). For these cases, there\n-are separate mechanisms which ensure that the regions that appear in\n-upvars/parameters outlive the dynamic extent of each call to the\n-closure:\n-\n-1. Types must outlive the region of any expression where they are used.\n-   For a closure type `C` to outlive a region `'r`, that implies that the\n-   types of all its upvars must outlive `'r`.\n-2. Parameters must outlive the region of any fn that they are passed to.\n-\n-Therefore, we can -- sort of -- assume that any region from an\n-enclosing fns is larger than any region from one of its enclosed\n-fn. And that is precisely what we do: when building the region\n-hierarchy, each region lives in its own distinct subtree, but if we\n-are asked to compute the `LUB(r1, r2)` of two regions, and those\n-regions are in disjoint subtrees, we compare the lexical nesting of\n-the two regions.\n-\n-*Ideas for improving the situation:* (FIXME #3696) The correctness\n-argument here is subtle and a bit hand-wavy. The ideal, as stated\n-earlier, would be to model things in such a way that it corresponds\n-more closely to the desugared code. The best approach for doing this\n-is a bit unclear: it may in fact be possible to *actually* desugar\n-before we start, but I don't think so. The main option that I've been\n-thinking through is imposing a \"view shift\" as we enter the fn body,\n-so that regions appearing in the types of fn parameters and upvars are\n-translated from being regions in the outer fn into free region\n-parameters, just as they would be if we applied the desugaring. The\n-challenge here is that type inference may not have fully run, so the\n-types may not be fully known: we could probably do this translation\n-lazilly, as type variables are instantiated. We would also have to\n-apply a kind of inverse translation to the return value. This would be\n-a good idea anyway, as right now it is possible for free regions\n-instantiated within the closure to leak into the parent: this\n-currently leads to type errors, since those regions cannot outlive any\n-expressions within the parent hierarchy. Much like the current\n-handling of closures, there are no known cases where this leads to a\n-type-checking accepting incorrect code (though it sometimes rejects\n-what might be considered correct code; see rust-lang/rust#22557), but\n-it still doesn't feel like the right approach.\n+[bc]: https://rust-lang.github.io/rustc-guide/borrow_check/region_inference.html"}, {"sha": "2a3a4fcc5fca4452c77504831765b11739591e33", "filename": "src/librustc_codegen_ssa/README.md", "status": "modified", "additions": 2, "deletions": 120, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a/src%2Flibrustc_codegen_ssa%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a/src%2Flibrustc_codegen_ssa%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FREADME.md?ref=78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a", "patch": "@@ -1,121 +1,3 @@\n-# Refactoring of `rustc_codegen_llvm`\n-by Denis Merigoux, October 23rd 2018\n+Please read the rustc-guide chapter on [Backend Agnostic Codegen][bac].\n \n-## State of the code before the refactoring\n-\n-All the code related to the compilation of MIR into LLVM IR was contained inside the `rustc_codegen_llvm` crate. Here is the breakdown of the most important elements:\n-* the `back` folder (7,800 LOC) implements the mechanisms for creating the different object files and archive through LLVM, but also the communication mechanisms for parallel code generation;\n-* the `debuginfo` (3,200 LOC) folder contains all code that passes debug information down to LLVM;\n-* the `llvm` (2,200 LOC) folder defines the FFI necessary to communicate with LLVM using the C++ API;\n-* the `mir` (4,300 LOC) folder implements the actual lowering from MIR to LLVM IR;\n-* the `base.rs` (1,300 LOC) file contains some helper functions but also the high-level code that launches the code generation and distributes the work.\n-* the `builder.rs` (1,200 LOC) file contains all the functions generating individual LLVM IR instructions inside a basic block;\n-* the `common.rs` (450 LOC) contains various helper functions and all the functions generating LLVM static values;\n-* the `type_.rs` (300 LOC) defines most of the type translations to LLVM IR.\n-\n-The goal of this refactoring is to separate inside this crate code that is specific to the LLVM from code that can be reused for other rustc backends. For instance, the `mir` folder is almost entirely backend-specific but it relies heavily on other parts of the crate. The separation of the code must not affect the logic of the code nor its performance.\n-\n-For these reasons, the separation process involves two transformations that have to be done at the same time for the resulting code to compile :\n-\n-1. replace all the LLVM-specific types by generics inside function signatures and structure definitions;\n-2. encapsulate all functions calling the LLVM FFI inside a set of traits that will define the interface between backend-agnostic code and the backend.\n-\n-While the LLVM-specific code will be left in `rustc_codegen_llvm`, all the new traits and backend-agnostic code will be moved in `rustc_codegen_ssa` (name suggestion by @eddyb).\n-\n-## Generic types and structures\n-\n-@irinagpopa started to parametrize the types of `rustc_codegen_llvm` by a generic `Value` type, implemented in LLVM by a reference `&'ll Value`. This work has been extended to all structures inside the `mir` folder and elsewhere, as well as for LLVM's `BasicBlock` and `Type` types.\n-\n-The two most important structures for the LLVM codegen are `CodegenCx` and `Builder`. They are parametrized by multiple lifetime parameters and the type for `Value`.\n-\n-```rust\n-struct CodegenCx<'ll, 'tcx> {\n-  /* ... */\n-}\n-\n-struct Builder<'a, 'll, 'tcx> {\n-  cx: &'a CodegenCx<'ll, 'tcx>,\n-  /* ... */\n-}\n-```\n-\n-`CodegenCx` is used to compile one codegen-unit that can contain multiple functions, whereas `Builder` is created to compile one basic block.\n-\n-The code in `rustc_codegen_llvm` has to deal with multiple explicit lifetime parameters, that correspond to the following:\n-* `'tcx` is the longest lifetime, that corresponds to the original `TyCtxt` containing the program's information;\n-* `'a` is a short-lived reference of a `CodegenCx` or another object inside a struct;\n-* `'ll` is the lifetime of references to LLVM objects such as `Value` or `Type`.\n-\n-Although there are already many lifetime parameters in the code, making it generic uncovered situations where the borrow-checker was passing only due to the special nature of the LLVM objects manipulated (they are extern pointers). For instance, a additional lifetime parameter had to be added to `LocalAnalyser` in `analyse.rs`, leading to the definition:\n-\n-```rust\n-struct LocalAnalyzer<'mir, 'a, 'tcx> {\n-  /* ... */\n-}\n-```\n-\n-However, the two most important structures `CodegenCx` and `Builder` are not defined in the backend-agnostic code. Indeed, their content is highly specific of the backend and it makes more sense to leave their definition to the backend implementor than to allow just a narrow spot via a generic field for the backend's context.\n-\n-## Traits and interface\n-\n-Because they have to be defined by the backend, `CodegenCx` and `Builder` will be the structures implementing all the traits defining the backend's interface. These traits are defined in the folder `rustc_codegen_ssa/traits` and all the backend-agnostic code is parametrized by them. For instance, let us explain how a function in `base.rs` is parametrized:\n-\n-```rust\n-pub fn codegen_instance<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    cx: &'a Bx::CodegenCx,\n-    instance: Instance<'tcx>\n-) {\n-    /* ... */\n-}\n-```\n-\n-In this signature, we have the two lifetime parameters explained earlier and the master type `Bx` which satisfies the trait `BuilderMethods` corresponding to the interface satisfied by the `Builder` struct. The `BuilderMethods` defines an associated type `Bx::CodegenCx` that itself satisfies the `CodegenMethods` traits implemented by the struct `CodegenCx`.\n-\n-On the trait side, here is an example with part of the definition of `BuilderMethods` in `traits/builder.rs`:\n-\n-```rust\n-pub trait BuilderMethods<'a, 'tcx>:\n-    HasCodegen<'tcx>\n-    + DebugInfoBuilderMethods<'tcx>\n-    + ArgTypeMethods<'tcx>\n-    + AbiBuilderMethods<'tcx>\n-    + IntrinsicCallMethods<'tcx>\n-    + AsmBuilderMethods<'tcx>\n-{\n-    fn new_block<'b>(\n-        cx: &'a Self::CodegenCx,\n-        llfn: Self::Function,\n-        name: &'b str\n-    ) -> Self;\n-    /* ... */\n-    fn cond_br(\n-        &mut self,\n-        cond: Self::Value,\n-        then_llbb: Self::BasicBlock,\n-        else_llbb: Self::BasicBlock,\n-    );\n-    /* ... */\n-}\n-```\n-\n-Finally, a master structure implementing the `ExtraBackendMethods` trait is used for high-level codegen-driving functions like `codegen_crate` in `base.rs`. For LLVM, it is the empty `LlvmCodegenBackend`. `ExtraBackendMethods` should be implemented by the same structure that implements the `CodegenBackend` defined in `rustc_codegen_utils/codegen_backend.rs`.\n-\n-During the traitification process, certain functions have been converted from methods of a local structure to methods of `CodegenCx` or `Builder` and a corresponding `self` parameter has been added. Indeed, LLVM stores information internally that it can access when called through its API. This information does not show up in a Rust data structure carried around when these methods are called. However, when implementing a Rust backend for `rustc`, these methods will need information from `CodegenCx`, hence the additional parameter (unused in the LLVM implementation of the trait).\n-\n-## State of the code after the refactoring\n-\n-The traits offer an API which is very similar to the API of LLVM. This is not the best solution since LLVM has a very special way of doing things: when addding another backend, the traits definition might be changed in order to offer more flexibility.\n-\n-However, the current separation between backend-agnostic and LLVM-specific code has allows the reuse of a significant part of the old `rustc_codegen_llvm`. Here is the new LOC breakdown between backend-agnostic (BA) and LLVM for the most important elements:\n-\n-* `back` folder: 3,800 (BA) vs 4,100 (LLVM);\n-* `mir` folder: 4,400 (BA) vs 0 (LLVM);\n-* `base.rs`: 1,100 (BA) vs 250 (LLVM);\n-* `builder.rs`: 1,400 (BA) vs 0 (LLVM);\n-* `common.rs`: 350 (BA) vs 350 (LLVM);\n-\n-The `debuginfo` folder has been left almost untouched by the splitting and is specific to LLVM. Only its high-level features have been traitified.\n-\n-The new `traits` folder has 1500 LOC only for trait definitions. Overall, the 27,000 LOC-sized old `rustc_codegen_llvm` code has been split into the new 18,500 LOC-sized new `rustc_codegen_llvm` and the 12,000 LOC-sized `rustc_codegen_ssa`. We can say that this refactoring allowed the reuse of approximately 10,000 LOC that would otherwise have had to be duplicated between the multiple backends of `rustc`.\n-\n-The refactored version of `rustc`'s backend introduced no regression over the test suite nor in performance benchmark, which is in coherence with the nature of the refactoring that used only compile-time parametricity (no trait objects).\n+[bac]: https://rust-lang.github.io/rustc-guide/codegen/backend-agnostic.html"}, {"sha": "8131d2840b49d3eed0afddc38966a83d2bd3038a", "filename": "src/librustc_incremental/persist/README.md", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a/src%2Flibrustc_incremental%2Fpersist%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a/src%2Flibrustc_incremental%2Fpersist%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2FREADME.md?ref=78a4f8c8ce66cda5f17a7cbf2bd7d772d2f8cf8a", "patch": "@@ -1,13 +1,3 @@\n-This is the code to load/save the dependency graph. Loading is assumed\n-to run early in compilation, and saving at the very end. When loading,\n-the basic idea is that we will load up the dependency graph from the\n-previous compilation and compare the hashes of our HIR nodes to the\n-hashes of the HIR nodes that existed at the time. For each node whose\n-hash has changed, or which no longer exists in the new HIR, we can\n-remove that node from the old graph along with any nodes that depend\n-on it. Then we add what's left to the new graph (if any such nodes or\n-edges already exist, then there would be no effect, but since we do\n-this first thing, they do not).\n-\n-\n+For info on how the incremental compilation works, see the [rustc guide].\n \n+[rustc guide]: https://rust-lang.github.io/rustc-guide/query.html"}]}