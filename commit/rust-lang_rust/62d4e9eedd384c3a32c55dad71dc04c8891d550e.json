{"sha": "62d4e9eedd384c3a32c55dad71dc04c8891d550e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZDRlOWVlZGQzODRjM2EzMmM1NWRhZDcxZGMwNGM4ODkxZDU1MGU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-22T09:32:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-22T09:32:23Z"}, "message": "Rollup merge of #72306 - Aaron1011:feature/turbo-spacing, r=petrochenkov\n\nBreak tokens before checking if they are 'probably equal'\n\nFixes #68489\nFixes #70987\n\nWhen checking two `TokenStreams` to see if they are 'probably equal',\nwe ignore the `IsJoint` information associated with each `TokenTree`.\nHowever, the `IsJoint` information determines whether adjacent tokens\nwill be 'glued' (if possible) when construction the `TokenStream` - e.g.\n`[Gt Gt]` can be 'glued' to `BinOp(Shr)`.\n\nSince we are ignoring the `IsJoint` information, 'glued' and 'unglued'\ntokens are equivalent for determining if two `TokenStreams` are\n'probably equal'. Therefore, we need to 'unglue' all tokens in the\nstream to avoid false negatives (which cause us to throw out the cached\ntokens, losing span information).", "tree": {"sha": "a35d2052a8b1ce1932c219aebf72fd40a6d786d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a35d2052a8b1ce1932c219aebf72fd40a6d786d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62d4e9eedd384c3a32c55dad71dc04c8891d550e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJex5wnCRBK7hj4Ov3rIwAAdHIIAFhEcWshHPjF1xy2AUGbO/in\nEZrwpnhic7keAG1rgNug4U6KkQtlDZHXcdmNxR2mY1nUJ7pMvNBpFRmaK8bIYvv/\nfQPn+6hAlIhlSC2tYUyo2x7pGyl7z7ZlnALSlTulg7iowCL0ex2nIEvPcd9YGZJb\ngWY3hSZ23/NwpCqc3Jli3MbERonBJqX6HhmjYYKrI0Y5C+0VSsQ20GVLh99JxeuY\ncvPepdVAwl5h8REcCilEjzj2gx6hhvm4lVvPDM4Ry3P2ioDK3rxHVEjCmH18xGnq\nJ56OImyE/oR+foZ84rnF7R1Cr7/Je5wH3vj7jGYtjhR3+WQ6H4JZbAUSdPieajE=\n=cB5g\n-----END PGP SIGNATURE-----\n", "payload": "tree a35d2052a8b1ce1932c219aebf72fd40a6d786d1\nparent a8018e224efa8aef9e6a8c9b8a74dc67c225d51d\nparent 633293fc3a54247f4308507632040424356a9e19\nauthor Ralf Jung <post@ralfj.de> 1590139943 +0200\ncommitter GitHub <noreply@github.com> 1590139943 +0200\n\nRollup merge of #72306 - Aaron1011:feature/turbo-spacing, r=petrochenkov\n\nBreak tokens before checking if they are 'probably equal'\n\nFixes #68489\nFixes #70987\n\nWhen checking two `TokenStreams` to see if they are 'probably equal',\nwe ignore the `IsJoint` information associated with each `TokenTree`.\nHowever, the `IsJoint` information determines whether adjacent tokens\nwill be 'glued' (if possible) when construction the `TokenStream` - e.g.\n`[Gt Gt]` can be 'glued' to `BinOp(Shr)`.\n\nSince we are ignoring the `IsJoint` information, 'glued' and 'unglued'\ntokens are equivalent for determining if two `TokenStreams` are\n'probably equal'. Therefore, we need to 'unglue' all tokens in the\nstream to avoid false negatives (which cause us to throw out the cached\ntokens, losing span information).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62d4e9eedd384c3a32c55dad71dc04c8891d550e", "html_url": "https://github.com/rust-lang/rust/commit/62d4e9eedd384c3a32c55dad71dc04c8891d550e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62d4e9eedd384c3a32c55dad71dc04c8891d550e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8018e224efa8aef9e6a8c9b8a74dc67c225d51d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8018e224efa8aef9e6a8c9b8a74dc67c225d51d", "html_url": "https://github.com/rust-lang/rust/commit/a8018e224efa8aef9e6a8c9b8a74dc67c225d51d"}, {"sha": "633293fc3a54247f4308507632040424356a9e19", "url": "https://api.github.com/repos/rust-lang/rust/commits/633293fc3a54247f4308507632040424356a9e19", "html_url": "https://github.com/rust-lang/rust/commit/633293fc3a54247f4308507632040424356a9e19"}], "stats": {"total": 117, "additions": 113, "deletions": 4}, "files": [{"sha": "075aaa7e5bc013dd5b0d9744d6ec73efda73de18", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/62d4e9eedd384c3a32c55dad71dc04c8891d550e/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d4e9eedd384c3a32c55dad71dc04c8891d550e/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=62d4e9eedd384c3a32c55dad71dc04c8891d550e", "patch": "@@ -21,6 +21,8 @@ use rustc_macros::HashStable_Generic;\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n+use log::debug;\n+\n use std::{iter, mem};\n \n /// When the main rust parser encounters a syntax-extension invocation, it\n@@ -338,8 +340,71 @@ impl TokenStream {\n             true\n         }\n \n-        let mut t1 = self.trees().filter(semantic_tree);\n-        let mut t2 = other.trees().filter(semantic_tree);\n+        // When comparing two `TokenStream`s, we ignore the `IsJoint` information.\n+        //\n+        // However, `rustc_parse::lexer::tokentrees::TokenStreamBuilder` will\n+        // use `Token.glue` on adjacent tokens with the proper `IsJoint`.\n+        // Since we are ignoreing `IsJoint`, a 'glued' token (e.g. `BinOp(Shr)`)\n+        // and its 'split'/'unglued' compoenents (e.g. `Gt, Gt`) are equivalent\n+        // when determining if two `TokenStream`s are 'probably equal'.\n+        //\n+        // Therefore, we use `break_two_token_op` to convert all tokens\n+        // to the 'unglued' form (if it exists). This ensures that two\n+        // `TokenStream`s which differ only in how their tokens are glued\n+        // will be considered 'probably equal', which allows us to keep spans.\n+        //\n+        // This is important when the original `TokenStream` contained\n+        // extra spaces (e.g. `f :: < Vec < _ > > ( ) ;'). These extra spaces\n+        // will be omitted when we pretty-print, which can cause the original\n+        // and reparsed `TokenStream`s to differ in the assignment of `IsJoint`,\n+        // leading to some tokens being 'glued' together in one stream but not\n+        // the other. See #68489 for more details.\n+        fn break_tokens(tree: TokenTree) -> impl Iterator<Item = TokenTree> {\n+            // In almost all cases, we should have either zero or one levels\n+            // of 'unglueing'. However, in some unusual cases, we may need\n+            // to iterate breaking tokens mutliple times. For example:\n+            // '[BinOpEq(Shr)] => [Gt, Ge] -> [Gt, Gt, Eq]'\n+            let mut token_trees: SmallVec<[_; 2]>;\n+            if let TokenTree::Token(token) = &tree {\n+                let mut out = SmallVec::<[_; 2]>::new();\n+                out.push(token.clone());\n+                // Iterate to fixpoint:\n+                // * We start off with 'out' containing our initial token, and `temp` empty\n+                // * If we are able to break any tokens in `out`, then `out` will have\n+                //   at least one more element than 'temp', so we will try to break tokens\n+                //   again.\n+                // * If we cannot break any tokens in 'out', we are done\n+                loop {\n+                    let mut temp = SmallVec::<[_; 2]>::new();\n+                    let mut changed = false;\n+\n+                    for token in out.into_iter() {\n+                        if let Some((first, second)) = token.kind.break_two_token_op() {\n+                            temp.push(Token::new(first, DUMMY_SP));\n+                            temp.push(Token::new(second, DUMMY_SP));\n+                            changed = true;\n+                        } else {\n+                            temp.push(token);\n+                        }\n+                    }\n+                    out = temp;\n+                    if !changed {\n+                        break;\n+                    }\n+                }\n+                token_trees = out.into_iter().map(|t| TokenTree::Token(t)).collect();\n+                if token_trees.len() != 1 {\n+                    debug!(\"break_tokens: broke {:?} to {:?}\", tree, token_trees);\n+                }\n+            } else {\n+                token_trees = SmallVec::new();\n+                token_trees.push(tree);\n+            }\n+            token_trees.into_iter()\n+        }\n+\n+        let mut t1 = self.trees().filter(semantic_tree).flat_map(break_tokens);\n+        let mut t2 = other.trees().filter(semantic_tree).flat_map(break_tokens);\n         for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n             if !t1.probably_equal_for_proc_macro(&t2) {\n                 return false;"}, {"sha": "59dc3b5043cd78bdb4ce6834daa8934c15b8dae4", "filename": "src/test/ui/proc-macro/break-token-spans.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/62d4e9eedd384c3a32c55dad71dc04c8891d550e/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d4e9eedd384c3a32c55dad71dc04c8891d550e/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.rs?ref=62d4e9eedd384c3a32c55dad71dc04c8891d550e", "patch": "@@ -0,0 +1,16 @@\n+// aux-build:test-macros.rs\n+// Regression test for issues #68489 and #70987\n+// Tests that we properly break tokens in `probably_equal_for_proc_macro`\n+// See #72306\n+//\n+// Note that the weird spacing in this example is critical\n+// for testing the issue.\n+\n+extern crate test_macros;\n+\n+#[test_macros::recollect_attr]\n+fn repro() {\n+    f :: < Vec < _ > > ( ) ; //~ ERROR cannot find\n+    let a: Option<Option<u8>>= true; //~ ERROR mismatched\n+}\n+fn main() {}"}, {"sha": "caca973f252f7fe442d8d904a4eb26cdbbf4c9d4", "filename": "src/test/ui/proc-macro/break-token-spans.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/62d4e9eedd384c3a32c55dad71dc04c8891d550e/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62d4e9eedd384c3a32c55dad71dc04c8891d550e/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.stderr?ref=62d4e9eedd384c3a32c55dad71dc04c8891d550e", "patch": "@@ -0,0 +1,21 @@\n+error[E0425]: cannot find function `f` in this scope\n+  --> $DIR/break-token-spans.rs:13:5\n+   |\n+LL |     f :: < Vec < _ > > ( ) ;\n+   |     ^ not found in this scope\n+\n+error[E0308]: mismatched types\n+  --> $DIR/break-token-spans.rs:14:32\n+   |\n+LL |     let a: Option<Option<u8>>= true;\n+   |            ------------------  ^^^^ expected enum `std::option::Option`, found `bool`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected enum `std::option::Option<std::option::Option<u8>>`\n+              found type `bool`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0308, E0425.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "666fc965f02f5caf2013effa1ca6b4a729b38fb9", "filename": "src/test/ui/suggestions/issue-61963.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62d4e9eedd384c3a32c55dad71dc04c8891d550e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d4e9eedd384c3a32c55dad71dc04c8891d550e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.rs?ref=62d4e9eedd384c3a32c55dad71dc04c8891d550e", "patch": "@@ -16,6 +16,7 @@ pub struct Qux<T>(T);\n \n #[dom_struct]\n pub struct Foo {\n+    //~^ ERROR trait objects without an explicit `dyn` are deprecated [bare_trait_objects]\n     qux: Qux<Qux<Baz>>,\n     bar: Box<Bar>,\n     //~^ ERROR trait objects without an explicit `dyn` are deprecated [bare_trait_objects]"}, {"sha": "62ae5fa3fe54fd09fc194f5ae5e5b4586564607e", "filename": "src/test/ui/suggestions/issue-61963.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62d4e9eedd384c3a32c55dad71dc04c8891d550e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62d4e9eedd384c3a32c55dad71dc04c8891d550e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.stderr?ref=62d4e9eedd384c3a32c55dad71dc04c8891d550e", "patch": "@@ -1,5 +1,5 @@\n error: trait objects without an explicit `dyn` are deprecated\n-  --> $DIR/issue-61963.rs:20:14\n+  --> $DIR/issue-61963.rs:21:14\n    |\n LL |     bar: Box<Bar>,\n    |              ^^^ help: use `dyn`: `dyn Bar`\n@@ -10,5 +10,11 @@ note: the lint level is defined here\n LL | #![deny(bare_trait_objects)]\n    |         ^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: trait objects without an explicit `dyn` are deprecated\n+  --> $DIR/issue-61963.rs:18:1\n+   |\n+LL | pub struct Foo {\n+   | ^^^ help: use `dyn`: `dyn pub`\n+\n+error: aborting due to 2 previous errors\n "}]}