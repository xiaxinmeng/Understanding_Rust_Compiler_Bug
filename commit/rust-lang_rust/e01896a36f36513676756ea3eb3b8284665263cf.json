{"sha": "e01896a36f36513676756ea3eb3b8284665263cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMTg5NmEzNmYzNjUxMzY3Njc1NmVhM2ViM2I4Mjg0NjY1MjYzY2Y=", "commit": {"author": {"name": "Ana-Maria Mihalache", "email": "mihalacheana.maria@yahoo.com", "date": "2020-05-11T15:25:33Z"}, "committer": {"name": "Ana-Maria Mihalache", "email": "mihalacheana.maria@yahoo.com", "date": "2020-06-05T13:20:09Z"}, "message": "Rename traits::Vtable to ImplSource.", "tree": {"sha": "e80f4650d676c941fa8ce4848ef3d50dfc239197", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e80f4650d676c941fa8ce4848ef3d50dfc239197"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e01896a36f36513676756ea3eb3b8284665263cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e01896a36f36513676756ea3eb3b8284665263cf", "html_url": "https://github.com/rust-lang/rust/commit/e01896a36f36513676756ea3eb3b8284665263cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e01896a36f36513676756ea3eb3b8284665263cf/comments", "author": {"login": "anyska", "id": 13694484, "node_id": "MDQ6VXNlcjEzNjk0NDg0", "avatar_url": "https://avatars.githubusercontent.com/u/13694484?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anyska", "html_url": "https://github.com/anyska", "followers_url": "https://api.github.com/users/anyska/followers", "following_url": "https://api.github.com/users/anyska/following{/other_user}", "gists_url": "https://api.github.com/users/anyska/gists{/gist_id}", "starred_url": "https://api.github.com/users/anyska/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anyska/subscriptions", "organizations_url": "https://api.github.com/users/anyska/orgs", "repos_url": "https://api.github.com/users/anyska/repos", "events_url": "https://api.github.com/users/anyska/events{/privacy}", "received_events_url": "https://api.github.com/users/anyska/received_events", "type": "User", "site_admin": false}, "committer": {"login": "anyska", "id": 13694484, "node_id": "MDQ6VXNlcjEzNjk0NDg0", "avatar_url": "https://avatars.githubusercontent.com/u/13694484?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anyska", "html_url": "https://github.com/anyska", "followers_url": "https://api.github.com/users/anyska/followers", "following_url": "https://api.github.com/users/anyska/following{/other_user}", "gists_url": "https://api.github.com/users/anyska/gists{/gist_id}", "starred_url": "https://api.github.com/users/anyska/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anyska/subscriptions", "organizations_url": "https://api.github.com/users/anyska/orgs", "repos_url": "https://api.github.com/users/anyska/repos", "events_url": "https://api.github.com/users/anyska/events{/privacy}", "received_events_url": "https://api.github.com/users/anyska/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "219380d840877de97b0e17674be7212ebc929d51", "url": "https://api.github.com/repos/rust-lang/rust/commits/219380d840877de97b0e17674be7212ebc929d51", "html_url": "https://github.com/rust-lang/rust/commit/219380d840877de97b0e17674be7212ebc929d51"}], "stats": {"total": 534, "additions": 270, "deletions": 264}, "files": [{"sha": "c4f1fa2cb26b359ac27f3d0a1461bd2621c14409", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -14,9 +14,9 @@ use rustc_middle::ty::{self, Const, Ty};\n use rustc_span::Span;\n \n pub use self::FulfillmentErrorCode::*;\n+pub use self::ImplSource::*;\n pub use self::ObligationCauseCode::*;\n pub use self::SelectionError::*;\n-pub use self::Vtable::*;\n \n pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::project::MismatchedProjectionTypes;\n@@ -30,10 +30,10 @@ crate use self::util::elaborate_predicates;\n pub use rustc_middle::traits::*;\n \n /// An `Obligation` represents some trait reference (e.g., `int: Eq`) for\n-/// which the vtable must be found. The process of finding a vtable is\n+/// which the \"impl_source\" must be found. The process of finding a \"impl_source\" is\n /// called \"resolving\" the `Obligation`. This process consists of\n /// either identifying an `impl` (e.g., `impl Eq for int`) that\n-/// provides the required vtable, or else finding a bound that is in\n+/// satisfies the obligation, or else finding a bound that is in\n /// scope. The eventual result is usually a `Selection` (defined below).\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Obligation<'tcx, T> {\n@@ -65,7 +65,7 @@ pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n-pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n+pub type Selection<'tcx> = ImplSource<'tcx, PredicateObligation<'tcx>>;\n \n pub struct FulfillmentError<'tcx> {\n     pub obligation: PredicateObligation<'tcx>,"}, {"sha": "59840118fd15d4abc9d70511e61abfc8b2266624", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -735,7 +735,7 @@ rustc_queries! {\n     Codegen {\n         query codegen_fulfill_obligation(\n             key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n-        ) -> Result<Vtable<'tcx, ()>, ErrorReported> {\n+        ) -> Result<ImplSource<'tcx, ()>, ErrorReported> {\n             cache_on_disk_if { true }\n             desc { |tcx|\n                 \"checking if `{}` fulfills its obligations\","}, {"sha": "16545a19732a6cbcd38a8d62fb626be783f4c04b", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 73, "deletions": 80, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -27,9 +27,9 @@ pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, Selecti\n \n pub type ChalkCanonicalGoal<'tcx> = Canonical<'tcx, ChalkEnvironmentAndGoal<'tcx>>;\n \n+pub use self::ImplSource::*;\n pub use self::ObligationCauseCode::*;\n pub use self::SelectionError::*;\n-pub use self::Vtable::*;\n \n pub use self::chalk::{\n     ChalkEnvironmentAndGoal, ChalkEnvironmentClause, RustDefId as ChalkRustDefId,\n@@ -343,15 +343,10 @@ pub enum SelectionError<'tcx> {\n /// - `Err(e)`: error `e` occurred\n pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n \n-/// Given the successful resolution of an obligation, the `Vtable`\n-/// indicates where the vtable comes from. Note that while we call this\n-/// a \"vtable\", it does not necessarily indicate dynamic dispatch at\n-/// runtime. `Vtable` instances just tell the compiler where to find\n-/// methods, but in generic code those methods are typically statically\n-/// dispatched -- only when an object is constructed is a `Vtable`\n-/// instance reified into an actual vtable.\n+/// Given the successful resolution of an obligation, the `ImplSource`\n+/// indicates where the impl comes from.\n ///\n-/// For example, the vtable may be tied to a specific impl (case A),\n+/// For example, the obligation may be satisfied by a specific impl (case A),\n /// or it may be relative to some bound that is in scope (case B).\n ///\n /// ```\n@@ -363,136 +358,136 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n ///                 param: T,\n ///                 mixed: Option<T>) {\n ///\n-///    // Case A: Vtable points at a specific impl. Only possible when\n+///    // Case A: ImplSource points at a specific impl. Only possible when\n ///    // type is concretely known. If the impl itself has bounded\n-///    // type parameters, Vtable will carry resolutions for those as well:\n-///    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n+///    // type parameters, ImplSource will carry resolutions for those as well:\n+///    concrete.clone(); // ImplSource(Impl_1, [ImplSource(Impl_2, [ImplSource(Impl_3)])])\n ///\n-///    // Case B: Vtable must be provided by caller. This applies when\n+///    // Case B: ImplSource must be provided by caller. This applies when\n ///    // type is a type parameter.\n-///    param.clone();    // VtableParam\n+///    param.clone();    // ImplSourceParam\n ///\n ///    // Case C: A mix of cases A and B.\n-///    mixed.clone();    // Vtable(Impl_1, [VtableParam])\n+///    mixed.clone();    // ImplSource(Impl_1, [ImplSourceParam])\n /// }\n /// ```\n ///\n /// ### The type parameter `N`\n ///\n-/// See explanation on `VtableImplData`.\n+/// See explanation on `ImplSourceImplData`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub enum Vtable<'tcx, N> {\n-    /// Vtable identifying a particular impl.\n-    VtableImpl(VtableImplData<'tcx, N>),\n+pub enum ImplSource<'tcx, N> {\n+    /// ImplSource identifying a particular impl.\n+    ImplSourceImpl(ImplSourceImplData<'tcx, N>),\n \n-    /// Vtable for auto trait implementations.\n+    /// ImplSource for auto trait implementations.\n     /// This carries the information and nested obligations with regards\n     /// to an auto implementation for a trait `Trait`. The nested obligations\n     /// ensure the trait implementation holds for all the constituent types.\n-    VtableAutoImpl(VtableAutoImplData<N>),\n+    ImplSourceAutoImpl(ImplSourceAutoImplData<N>),\n \n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter. The `Vec<N>` represents the\n     /// obligations incurred from normalizing the where-clause (if\n     /// any).\n-    VtableParam(Vec<N>),\n+    ImplSourceParam(Vec<N>),\n \n     /// Virtual calls through an object.\n-    VtableObject(VtableObjectData<'tcx, N>),\n+    ImplSourceObject(ImplSourceObjectData<'tcx, N>),\n \n     /// Successful resolution for a builtin trait.\n-    VtableBuiltin(VtableBuiltinData<N>),\n+    ImplSourceBuiltin(ImplSourceBuiltinData<N>),\n \n-    /// Vtable automatically generated for a closure. The `DefId` is the ID\n-    /// of the closure expression. This is a `VtableImpl` in spirit, but the\n+    /// ImplSource automatically generated for a closure. The `DefId` is the ID\n+    /// of the closure expression. This is a `ImplSourceImpl` in spirit, but the\n     /// impl is generated by the compiler and does not appear in the source.\n-    VtableClosure(VtableClosureData<'tcx, N>),\n+    ImplSourceClosure(ImplSourceClosureData<'tcx, N>),\n \n     /// Same as above, but for a function pointer type with the given signature.\n-    VtableFnPointer(VtableFnPointerData<'tcx, N>),\n+    ImplSourceFnPointer(ImplSourceFnPointerData<'tcx, N>),\n \n-    /// Vtable for a builtin `DeterminantKind` trait implementation.\n-    VtableDiscriminantKind(VtableDiscriminantKindData),\n+    /// ImplSource for a builtin `DeterminantKind` trait implementation.\n+    ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData),\n \n-    /// Vtable automatically generated for a generator.\n-    VtableGenerator(VtableGeneratorData<'tcx, N>),\n+    /// ImplSource automatically generated for a generator.\n+    ImplSourceGenerator(ImplSourceGeneratorData<'tcx, N>),\n \n-    /// Vtable for a trait alias.\n-    VtableTraitAlias(VtableTraitAliasData<'tcx, N>),\n+    /// ImplSource for a trait alias.\n+    ImplSourceTraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n }\n \n-impl<'tcx, N> Vtable<'tcx, N> {\n+impl<'tcx, N> ImplSource<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {\n-            VtableImpl(i) => i.nested,\n-            VtableParam(n) => n,\n-            VtableBuiltin(i) => i.nested,\n-            VtableAutoImpl(d) => d.nested,\n-            VtableClosure(c) => c.nested,\n-            VtableGenerator(c) => c.nested,\n-            VtableObject(d) => d.nested,\n-            VtableFnPointer(d) => d.nested,\n-            VtableDiscriminantKind(VtableDiscriminantKindData) => Vec::new(),\n-            VtableTraitAlias(d) => d.nested,\n+            ImplSourceImpl(i) => i.nested,\n+            ImplSourceParam(n) => n,\n+            ImplSourceBuiltin(i) => i.nested,\n+            ImplSourceAutoImpl(d) => d.nested,\n+            ImplSourceClosure(c) => c.nested,\n+            ImplSourceGenerator(c) => c.nested,\n+            ImplSourceObject(d) => d.nested,\n+            ImplSourceFnPointer(d) => d.nested,\n+            ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData) => Vec::new(),\n+            ImplSourceTraitAlias(d) => d.nested,\n         }\n     }\n \n     pub fn borrow_nested_obligations(&self) -> &[N] {\n         match &self {\n-            VtableImpl(i) => &i.nested[..],\n-            VtableParam(n) => &n[..],\n-            VtableBuiltin(i) => &i.nested[..],\n-            VtableAutoImpl(d) => &d.nested[..],\n-            VtableClosure(c) => &c.nested[..],\n-            VtableGenerator(c) => &c.nested[..],\n-            VtableObject(d) => &d.nested[..],\n-            VtableFnPointer(d) => &d.nested[..],\n-            VtableDiscriminantKind(VtableDiscriminantKindData) => &[],\n-            VtableTraitAlias(d) => &d.nested[..],\n+            ImplSourceImpl(i) => &i.nested[..],\n+            ImplSourceParam(n) => &n[..],\n+            ImplSourceBuiltin(i) => &i.nested[..],\n+            ImplSourceAutoImpl(d) => &d.nested[..],\n+            ImplSourceClosure(c) => &c.nested[..],\n+            ImplSourceGenerator(c) => &c.nested[..],\n+            ImplSourceObject(d) => &d.nested[..],\n+            ImplSourceFnPointer(d) => &d.nested[..],\n+            ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData) => &[],\n+            ImplSourceTraitAlias(d) => &d.nested[..],\n         }\n     }\n \n-    pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M>\n+    pub fn map<M, F>(self, f: F) -> ImplSource<'tcx, M>\n     where\n         F: FnMut(N) -> M,\n     {\n         match self {\n-            VtableImpl(i) => VtableImpl(VtableImplData {\n+            ImplSourceImpl(i) => ImplSourceImpl(ImplSourceImplData {\n                 impl_def_id: i.impl_def_id,\n                 substs: i.substs,\n                 nested: i.nested.into_iter().map(f).collect(),\n             }),\n-            VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n-            VtableBuiltin(i) => {\n-                VtableBuiltin(VtableBuiltinData { nested: i.nested.into_iter().map(f).collect() })\n-            }\n-            VtableObject(o) => VtableObject(VtableObjectData {\n+            ImplSourceParam(n) => ImplSourceParam(n.into_iter().map(f).collect()),\n+            ImplSourceBuiltin(i) => ImplSourceBuiltin(ImplSourceBuiltinData {\n+                nested: i.nested.into_iter().map(f).collect(),\n+            }),\n+            ImplSourceObject(o) => ImplSourceObject(ImplSourceObjectData {\n                 upcast_trait_ref: o.upcast_trait_ref,\n                 vtable_base: o.vtable_base,\n                 nested: o.nested.into_iter().map(f).collect(),\n             }),\n-            VtableAutoImpl(d) => VtableAutoImpl(VtableAutoImplData {\n+            ImplSourceAutoImpl(d) => ImplSourceAutoImpl(ImplSourceAutoImplData {\n                 trait_def_id: d.trait_def_id,\n                 nested: d.nested.into_iter().map(f).collect(),\n             }),\n-            VtableClosure(c) => VtableClosure(VtableClosureData {\n+            ImplSourceClosure(c) => ImplSourceClosure(ImplSourceClosureData {\n                 closure_def_id: c.closure_def_id,\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n             }),\n-            VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n+            ImplSourceGenerator(c) => ImplSourceGenerator(ImplSourceGeneratorData {\n                 generator_def_id: c.generator_def_id,\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n             }),\n-            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n+            ImplSourceFnPointer(p) => ImplSourceFnPointer(ImplSourceFnPointerData {\n                 fn_ty: p.fn_ty,\n                 nested: p.nested.into_iter().map(f).collect(),\n             }),\n-            VtableDiscriminantKind(VtableDiscriminantKindData) => {\n-                VtableDiscriminantKind(VtableDiscriminantKindData)\n+            ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData) => {\n+                ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData)\n             }\n-            VtableTraitAlias(d) => VtableTraitAlias(VtableTraitAliasData {\n+            ImplSourceTraitAlias(d) => ImplSourceTraitAlias(ImplSourceTraitAliasData {\n                 alias_def_id: d.alias_def_id,\n                 substs: d.substs,\n                 nested: d.nested.into_iter().map(f).collect(),\n@@ -512,14 +507,14 @@ impl<'tcx, N> Vtable<'tcx, N> {\n /// is `()`, because codegen only requires a shallow resolution of an\n /// impl, and nested obligations are satisfied later.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableImplData<'tcx, N> {\n+pub struct ImplSourceImplData<'tcx, N> {\n     pub impl_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub nested: Vec<N>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableGeneratorData<'tcx, N> {\n+pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub generator_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     /// Nested obligations. This can be non-empty if the generator\n@@ -528,7 +523,7 @@ pub struct VtableGeneratorData<'tcx, N> {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableClosureData<'tcx, N> {\n+pub struct ImplSourceClosureData<'tcx, N> {\n     pub closure_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     /// Nested obligations. This can be non-empty if the closure\n@@ -537,20 +532,18 @@ pub struct VtableClosureData<'tcx, N> {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableAutoImplData<N> {\n+pub struct ImplSourceAutoImplData<N> {\n     pub trait_def_id: DefId,\n     pub nested: Vec<N>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableBuiltinData<N> {\n+pub struct ImplSourceBuiltinData<N> {\n     pub nested: Vec<N>,\n }\n \n-/// A vtable for some object-safe trait `Foo` automatically derived\n-/// for the object type `Foo`.\n #[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableObjectData<'tcx, N> {\n+pub struct ImplSourceObjectData<'tcx, N> {\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n \n@@ -563,17 +556,17 @@ pub struct VtableObjectData<'tcx, N> {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableFnPointerData<'tcx, N> {\n+pub struct ImplSourceFnPointerData<'tcx, N> {\n     pub fn_ty: Ty<'tcx>,\n     pub nested: Vec<N>,\n }\n \n // FIXME(@lcnr): This should be  refactored and merged with other builtin vtables.\n #[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableDiscriminantKindData;\n+pub struct ImplSourceDiscriminantKindData;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableTraitAliasData<'tcx, N> {\n+pub struct ImplSourceTraitAliasData<'tcx, N> {\n     pub alias_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub nested: Vec<N>,"}, {"sha": "50ecf677deaa401780d5a276425935a9e9f290e6", "filename": "src/librustc_middle/traits/structural_impls.rs", "status": "modified", "additions": 58, "deletions": 52, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -6,99 +6,99 @@ use std::rc::Rc;\n \n // Structural impls for the structs in `traits`.\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSource<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            super::VtableImpl(ref v) => write!(f, \"{:?}\", v),\n+            super::ImplSourceImpl(ref v) => write!(f, \"{:?}\", v),\n \n-            super::VtableAutoImpl(ref t) => write!(f, \"{:?}\", t),\n+            super::ImplSourceAutoImpl(ref t) => write!(f, \"{:?}\", t),\n \n-            super::VtableClosure(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSourceClosure(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableGenerator(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSourceGenerator(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableFnPointer(ref d) => write!(f, \"VtableFnPointer({:?})\", d),\n+            super::ImplSourceFnPointer(ref d) => write!(f, \"ImplSourceFnPointer({:?})\", d),\n \n-            super::VtableDiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSourceDiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableObject(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSourceObject(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableParam(ref n) => write!(f, \"VtableParam({:?})\", n),\n+            super::ImplSourceParam(ref n) => write!(f, \"ImplSourceParam({:?})\", n),\n \n-            super::VtableBuiltin(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSourceBuiltin(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableTraitAlias(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSourceTraitAlias(ref d) => write!(f, \"{:?}\", d),\n         }\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableImplData(impl_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"ImplSourceImplData(impl_def_id={:?}, substs={:?}, nested={:?})\",\n             self.impl_def_id, self.substs, self.nested\n         )\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceGeneratorData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"ImplSourceGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n             self.generator_def_id, self.substs, self.nested\n         )\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceClosureData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"ImplSourceClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n             self.closure_def_id, self.substs, self.nested\n         )\n     }\n }\n \n-impl<N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n+impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceBuiltinData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"VtableBuiltinData(nested={:?})\", self.nested)\n+        write!(f, \"ImplSourceBuiltinData(nested={:?})\", self.nested)\n     }\n }\n \n-impl<N: fmt::Debug> fmt::Debug for traits::VtableAutoImplData<N> {\n+impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceAutoImplData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableAutoImplData(trait_def_id={:?}, nested={:?})\",\n+            \"ImplSourceAutoImplData(trait_def_id={:?}, nested={:?})\",\n             self.trait_def_id, self.nested\n         )\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceObjectData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableObjectData(upcast={:?}, vtable_base={}, nested={:?})\",\n+            \"ImplSourceObjectData(upcast={:?}, vtable_base={}, nested={:?})\",\n             self.upcast_trait_ref, self.vtable_base, self.nested\n         )\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceFnPointerData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"VtableFnPointerData(fn_ty={:?}, nested={:?})\", self.fn_ty, self.nested)\n+        write!(f, \"ImplSourceFnPointerData(fn_ty={:?}, nested={:?})\", self.fn_ty, self.nested)\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableTraitAliasData<'tcx, N> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"ImplSourceTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n             self.alias_def_id, self.substs, self.nested\n         )\n     }\n@@ -241,63 +241,69 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n }\n \n // For codegen only.\n-impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n-    type Lifted = traits::Vtable<'tcx, ()>;\n+impl<'a, 'tcx> Lift<'tcx> for traits::ImplSource<'a, ()> {\n+    type Lifted = traits::ImplSource<'tcx, ()>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self.clone() {\n-            traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested }) => {\n+            traits::ImplSourceImpl(traits::ImplSourceImplData { impl_def_id, substs, nested }) => {\n                 tcx.lift(&substs).map(|substs| {\n-                    traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested })\n+                    traits::ImplSourceImpl(traits::ImplSourceImplData {\n+                        impl_def_id,\n+                        substs,\n+                        nested,\n+                    })\n                 })\n             }\n-            traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n-            traits::VtableGenerator(traits::VtableGeneratorData {\n+            traits::ImplSourceAutoImpl(t) => Some(traits::ImplSourceAutoImpl(t)),\n+            traits::ImplSourceGenerator(traits::ImplSourceGeneratorData {\n                 generator_def_id,\n                 substs,\n                 nested,\n             }) => tcx.lift(&substs).map(|substs| {\n-                traits::VtableGenerator(traits::VtableGeneratorData {\n+                traits::ImplSourceGenerator(traits::ImplSourceGeneratorData {\n                     generator_def_id,\n                     substs,\n                     nested,\n                 })\n             }),\n-            traits::VtableClosure(traits::VtableClosureData { closure_def_id, substs, nested }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableClosure(traits::VtableClosureData {\n-                        closure_def_id,\n-                        substs,\n-                        nested,\n-                    })\n+            traits::ImplSourceClosure(traits::ImplSourceClosureData {\n+                closure_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::ImplSourceClosure(traits::ImplSourceClosureData {\n+                    closure_def_id,\n+                    substs,\n+                    nested,\n                 })\n-            }\n-            traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n+            }),\n+            traits::ImplSourceFnPointer(traits::ImplSourceFnPointerData { fn_ty, nested }) => {\n                 tcx.lift(&fn_ty).map(|fn_ty| {\n-                    traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n+                    traits::ImplSourceFnPointer(traits::ImplSourceFnPointerData { fn_ty, nested })\n                 })\n             }\n-            traits::VtableDiscriminantKind(traits::VtableDiscriminantKindData) => {\n-                Some(traits::VtableDiscriminantKind(traits::VtableDiscriminantKindData))\n+            traits::ImplSourceDiscriminantKind(traits::ImplSourceDiscriminantKindData) => {\n+                Some(traits::ImplSourceDiscriminantKind(traits::ImplSourceDiscriminantKindData))\n             }\n-            traits::VtableParam(n) => Some(traits::VtableParam(n)),\n-            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n-            traits::VtableObject(traits::VtableObjectData {\n+            traits::ImplSourceParam(n) => Some(traits::ImplSourceParam(n)),\n+            traits::ImplSourceBuiltin(n) => Some(traits::ImplSourceBuiltin(n)),\n+            traits::ImplSourceObject(traits::ImplSourceObjectData {\n                 upcast_trait_ref,\n                 vtable_base,\n                 nested,\n             }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n-                traits::VtableObject(traits::VtableObjectData {\n+                traits::ImplSourceObject(traits::ImplSourceObjectData {\n                     upcast_trait_ref: trait_ref,\n                     vtable_base,\n                     nested,\n                 })\n             }),\n-            traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+            traits::ImplSourceTraitAlias(traits::ImplSourceTraitAliasData {\n                 alias_def_id,\n                 substs,\n                 nested,\n             }) => tcx.lift(&substs).map(|substs| {\n-                traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+                traits::ImplSourceTraitAlias(traits::ImplSourceTraitAliasData {\n                     alias_def_id,\n                     substs,\n                     nested,"}, {"sha": "35d19b7603fafa8483ab743fb26778e3eda24df0", "filename": "src/librustc_middle/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -27,7 +27,7 @@ use crate::traits::query::{\n     OutlivesBound,\n };\n use crate::traits::specialization_graph;\n-use crate::traits::{self, Vtable};\n+use crate::traits::{self, ImplSource};\n use crate::ty::steal::Steal;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;"}, {"sha": "0b2ee3280df6ab06ae44606576783d32d100d82f", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -20,11 +20,11 @@ pub fn custom_coerce_unsize_info<'tcx>(\n     });\n \n     match tcx.codegen_fulfill_obligation((ty::ParamEnv::reveal_all(), trait_ref)) {\n-        Ok(traits::VtableImpl(traits::VtableImplData { impl_def_id, .. })) => {\n+        Ok(traits::ImplSourceImpl(traits::ImplSourceImplData { impl_def_id, .. })) => {\n             tcx.coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }\n-        vtable => {\n-            bug!(\"invalid `CoerceUnsized` vtable: {:?}\", vtable);\n+        impl_source => {\n+            bug!(\"invalid `CoerceUnsized` impl_source: {:?}\", impl_source);\n         }\n     }\n }"}, {"sha": "f773fa2ac6e6c7e5930fb31d1c008c05a3101d94", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             ));\n \n             match result {\n-                Ok(Some(Vtable::VtableImpl(_))) => {\n+                Ok(Some(ImplSource::ImplSourceImpl(_))) => {\n                     debug!(\n                         \"find_auto_trait_generics({:?}): \\\n                          manual impl found, bailing out\",\n@@ -304,11 +304,13 @@ impl AutoTraitFinder<'tcx> {\n             let result = select.select(&obligation);\n \n             match &result {\n-                &Ok(Some(ref vtable)) => {\n+                &Ok(Some(ref impl_source)) => {\n                     // If we see an explicit negative impl (e.g., `impl !Send for MyStruct`),\n                     // we immediately bail out, since it's impossible for us to continue.\n \n-                    if let Vtable::VtableImpl(VtableImplData { impl_def_id, .. }) = vtable {\n+                    if let ImplSource::ImplSourceImpl(ImplSourceImplData { impl_def_id, .. }) =\n+                        impl_source\n+                    {\n                         // Blame 'tidy' for the weird bracket placement.\n                         if infcx.tcx.impl_polarity(*impl_def_id) == ty::ImplPolarity::Negative {\n                             debug!(\n@@ -320,7 +322,7 @@ impl AutoTraitFinder<'tcx> {\n                         }\n                     }\n \n-                    let obligations = vtable.clone().nested_obligations().into_iter();\n+                    let obligations = impl_source.clone().nested_obligations().into_iter();\n \n                     if !self.evaluate_nested_obligations(\n                         ty,"}, {"sha": "cf575d3eca9c226853e7481af7b0b728f180a0ae", "filename": "src/librustc_trait_selection/traits/codegen/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -5,22 +5,22 @@\n \n use crate::infer::{InferCtxt, TyCtxtInferExt};\n use crate::traits::{\n-    FulfillmentContext, Obligation, ObligationCause, SelectionContext, TraitEngine, Vtable,\n+    FulfillmentContext, ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngine,\n };\n use rustc_errors::ErrorReported;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, TyCtxt};\n \n-/// Attempts to resolve an obligation to a vtable. The result is\n-/// a shallow vtable resolution, meaning that we do not\n+/// Attempts to resolve an obligation to a `ImplSource`. The result is\n+/// a shallow `ImplSource` resolution, meaning that we do not\n /// (necessarily) resolve all nested obligations on the impl. Note\n /// that type check should guarantee to us that all nested\n /// obligations *could be* resolved if we wanted to.\n /// Assumes that this is run after the entire crate has been successfully type-checked.\n pub fn codegen_fulfill_obligation<'tcx>(\n     ty: TyCtxt<'tcx>,\n     (param_env, trait_ref): (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>),\n-) -> Result<Vtable<'tcx, ()>, ErrorReported> {\n+) -> Result<ImplSource<'tcx, ()>, ErrorReported> {\n     // Remove any references to regions; this helps improve caching.\n     let trait_ref = ty.erase_regions(&trait_ref);\n \n@@ -69,14 +69,14 @@ pub fn codegen_fulfill_obligation<'tcx>(\n         // all nested obligations. This is because they can inform the\n         // inference of the impl's type parameters.\n         let mut fulfill_cx = FulfillmentContext::new();\n-        let vtable = selection.map(|predicate| {\n+        let impl_source = selection.map(|predicate| {\n             debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n             fulfill_cx.register_predicate_obligation(&infcx, predicate);\n         });\n-        let vtable = drain_fulfillment_cx_or_panic(&infcx, &mut fulfill_cx, &vtable);\n+        let impl_source = drain_fulfillment_cx_or_panic(&infcx, &mut fulfill_cx, &impl_source);\n \n-        info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n-        Ok(vtable)\n+        info!(\"Cache miss: {:?} => {:?}\", trait_ref, impl_source);\n+        Ok(impl_source)\n     })\n }\n "}, {"sha": "4a08a3426c1367941447e65d1afc074304dee99f", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -334,12 +334,12 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n \n                 match self.selcx.select(&trait_obligation) {\n-                    Ok(Some(vtable)) => {\n+                    Ok(Some(impl_source)) => {\n                         debug!(\n                             \"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n                             data, obligation.recursion_depth\n                         );\n-                        ProcessResult::Changed(mk_pending(vtable.nested_obligations()))\n+                        ProcessResult::Changed(mk_pending(impl_source.nested_obligations()))\n                     }\n                     Ok(None) => {\n                         debug!("}, {"sha": "6abea18ee296c90001caaaf286f417ac17549ff6", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -38,9 +38,9 @@ use rustc_span::Span;\n use std::fmt::Debug;\n \n pub use self::FulfillmentErrorCode::*;\n+pub use self::ImplSource::*;\n pub use self::ObligationCauseCode::*;\n pub use self::SelectionError::*;\n-pub use self::Vtable::*;\n \n pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n pub use self::coherence::{OrphanCheckErr, OverlapResult};"}, {"sha": "8266f350e5655d98953bb184191a1322d6107ec6", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 49, "deletions": 46, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -11,11 +11,11 @@ use super::PredicateObligation;\n use super::Selection;\n use super::SelectionContext;\n use super::SelectionError;\n-use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n use super::{\n-    VtableClosureData, VtableDiscriminantKindData, VtableFnPointerData, VtableGeneratorData,\n-    VtableImplData,\n+    ImplSourceClosureData, ImplSourceDiscriminantKindData, ImplSourceFnPointerData,\n+    ImplSourceGeneratorData, ImplSourceImplData,\n };\n+use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n \n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n@@ -974,8 +974,8 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n     let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n     let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n     let _ = selcx.infcx().commit_if_ok(|_| {\n-        let vtable = match selcx.select(&trait_obligation) {\n-            Ok(Some(vtable)) => vtable,\n+        let impl_source = match selcx.select(&trait_obligation) {\n+            Ok(Some(impl_source)) => impl_source,\n             Ok(None) => {\n                 candidate_set.mark_ambiguous();\n                 return Err(());\n@@ -987,16 +987,16 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n             }\n         };\n \n-        let eligible = match &vtable {\n-            super::VtableClosure(_)\n-            | super::VtableGenerator(_)\n-            | super::VtableFnPointer(_)\n-            | super::VtableObject(_)\n-            | super::VtableTraitAlias(_) => {\n-                debug!(\"assemble_candidates_from_impls: vtable={:?}\", vtable);\n+        let eligible = match &impl_source {\n+            super::ImplSourceClosure(_)\n+            | super::ImplSourceGenerator(_)\n+            | super::ImplSourceFnPointer(_)\n+            | super::ImplSourceObject(_)\n+            | super::ImplSourceTraitAlias(_) => {\n+                debug!(\"assemble_candidates_from_impls: impl_source={:?}\", impl_source);\n                 true\n             }\n-            super::VtableImpl(impl_data) => {\n+            super::ImplSourceImpl(impl_data) => {\n                 // We have to be careful when projecting out of an\n                 // impl because of specialization. If we are not in\n                 // codegen (i.e., projection mode is not \"any\"), and the\n@@ -1048,7 +1048,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     }\n                 }\n             }\n-            super::VtableDiscriminantKind(..) => {\n+            super::ImplSourceDiscriminantKind(..) => {\n                 // While `DiscriminantKind` is automatically implemented for every type,\n                 // the concrete discriminant may not be known yet.\n                 //\n@@ -1088,7 +1088,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     | ty::Error => false,\n                 }\n             }\n-            super::VtableParam(..) => {\n+            super::ImplSourceParam(..) => {\n                 // This case tell us nothing about the value of an\n                 // associated type. Consider:\n                 //\n@@ -1116,18 +1116,18 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // in `assemble_candidates_from_param_env`.\n                 false\n             }\n-            super::VtableAutoImpl(..) | super::VtableBuiltin(..) => {\n+            super::ImplSourceAutoImpl(..) | super::ImplSourceBuiltin(..) => {\n                 // These traits have no associated types.\n                 span_bug!(\n                     obligation.cause.span,\n                     \"Cannot project an associated type from `{:?}`\",\n-                    vtable\n+                    impl_source\n                 );\n             }\n         };\n \n         if eligible {\n-            if candidate_set.push_candidate(ProjectionTyCandidate::Select(vtable)) {\n+            if candidate_set.push_candidate(ProjectionTyCandidate::Select(impl_source)) {\n                 Ok(())\n             } else {\n                 Err(())\n@@ -1152,8 +1152,8 @@ fn confirm_candidate<'cx, 'tcx>(\n             confirm_param_env_candidate(selcx, obligation, poly_projection)\n         }\n \n-        ProjectionTyCandidate::Select(vtable) => {\n-            confirm_select_candidate(selcx, obligation, obligation_trait_ref, vtable)\n+        ProjectionTyCandidate::Select(impl_source) => {\n+            confirm_select_candidate(selcx, obligation, obligation_trait_ref, impl_source)\n         }\n     }\n }\n@@ -1162,26 +1162,29 @@ fn confirm_select_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    vtable: Selection<'tcx>,\n+    impl_source: Selection<'tcx>,\n ) -> Progress<'tcx> {\n-    match vtable {\n-        super::VtableImpl(data) => confirm_impl_candidate(selcx, obligation, data),\n-        super::VtableGenerator(data) => confirm_generator_candidate(selcx, obligation, data),\n-        super::VtableClosure(data) => confirm_closure_candidate(selcx, obligation, data),\n-        super::VtableFnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n-        super::VtableDiscriminantKind(data) => {\n+    match impl_source {\n+        super::ImplSourceImpl(data) => confirm_impl_candidate(selcx, obligation, data),\n+        super::ImplSourceGenerator(data) => confirm_generator_candidate(selcx, obligation, data),\n+        super::ImplSourceClosure(data) => confirm_closure_candidate(selcx, obligation, data),\n+        super::ImplSourceFnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n+        super::ImplSourceDiscriminantKind(data) => {\n             confirm_discriminant_kind_candidate(selcx, obligation, data)\n         }\n-        super::VtableObject(_) => confirm_object_candidate(selcx, obligation, obligation_trait_ref),\n-        super::VtableAutoImpl(..)\n-        | super::VtableParam(..)\n-        | super::VtableBuiltin(..)\n-        | super::VtableTraitAlias(..) => {\n-            // we don't create Select candidates with this kind of resolution\n+        super::ImplSourceObject(_) => {\n+            confirm_object_candidate(selcx, obligation, obligation_trait_ref)\n+        }\n+        super::ImplSourceAutoImpl(..)\n+        | super::ImplSourceParam(..)\n+        | super::ImplSourceBuiltin(..)\n+        | super::ImplSourceTraitAlias(..) =>\n+        // we don't create Select candidates with this kind of resolution\n+        {\n             span_bug!(\n                 obligation.cause.span,\n                 \"Cannot project an associated type from `{:?}`\",\n-                vtable\n+                impl_source\n             )\n         }\n     }\n@@ -1255,9 +1258,9 @@ fn confirm_object_candidate<'cx, 'tcx>(\n fn confirm_generator_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n+    impl_source: ImplSourceGeneratorData<'tcx, PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let gen_sig = vtable.substs.as_generator().poly_sig();\n+    let gen_sig = impl_source.substs.as_generator().poly_sig();\n     let Normalized { value: gen_sig, obligations } = normalize_with_depth(\n         selcx,\n         obligation.param_env,\n@@ -1301,14 +1304,14 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n     });\n \n     confirm_param_env_candidate(selcx, obligation, predicate)\n-        .with_addl_obligations(vtable.nested)\n+        .with_addl_obligations(impl_source.nested)\n         .with_addl_obligations(obligations)\n }\n \n fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    _: VtableDiscriminantKindData,\n+    _: ImplSourceDiscriminantKindData,\n ) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n \n@@ -1339,9 +1342,9 @@ fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>,\n+    fn_pointer_impl_source: ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n+    let fn_type = selcx.infcx().shallow_resolve(fn_pointer_impl_source.fn_ty);\n     let sig = fn_type.fn_sig(selcx.tcx());\n     let Normalized { value: sig, obligations } = normalize_with_depth(\n         selcx,\n@@ -1352,16 +1355,16 @@ fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     );\n \n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n-        .with_addl_obligations(fn_pointer_vtable.nested)\n+        .with_addl_obligations(fn_pointer_impl_source.nested)\n         .with_addl_obligations(obligations)\n }\n \n fn confirm_closure_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n+    impl_source: ImplSourceClosureData<'tcx, PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let closure_sig = vtable.substs.as_closure().sig();\n+    let closure_sig = impl_source.substs.as_closure().sig();\n     let Normalized { value: closure_sig, obligations } = normalize_with_depth(\n         selcx,\n         obligation.param_env,\n@@ -1376,7 +1379,7 @@ fn confirm_closure_candidate<'cx, 'tcx>(\n     );\n \n     confirm_callable_candidate(selcx, obligation, closure_sig, util::TupleArgumentsFlag::No)\n-        .with_addl_obligations(vtable.nested)\n+        .with_addl_obligations(impl_source.nested)\n         .with_addl_obligations(obligations)\n }\n \n@@ -1446,11 +1449,11 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n fn confirm_impl_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>,\n+    impl_impl_source: ImplSourceImplData<'tcx, PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n \n-    let VtableImplData { impl_def_id, substs, nested } = impl_vtable;\n+    let ImplSourceImplData { impl_def_id, substs, nested } = impl_impl_source;\n     let assoc_item_id = obligation.predicate.item_def_id;\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n "}, {"sha": "4de4c2ec3daac32f90903e5422d85b6d65b49d28", "filename": "src/librustc_trait_selection/traits/select/confirmation.rs", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -24,18 +24,19 @@ use crate::traits::OutputTypeParameterMismatch;\n use crate::traits::Selection;\n use crate::traits::TraitNotObjectSafe;\n use crate::traits::{BuiltinDerivedObligation, ImplDerivedObligation};\n-use crate::traits::{ObjectCastObligation, PredicateObligation, TraitObligation};\n-use crate::traits::{Obligation, ObligationCause};\n-use crate::traits::{SelectionError, Unimplemented};\n use crate::traits::{\n-    VtableAutoImpl, VtableBuiltin, VtableClosure, VtableDiscriminantKind, VtableFnPointer,\n-    VtableGenerator, VtableImpl, VtableObject, VtableParam, VtableTraitAlias,\n+    ImplSourceAutoImpl, ImplSourceBuiltin, ImplSourceClosure, ImplSourceDiscriminantKind,\n+    ImplSourceFnPointer, ImplSourceGenerator, ImplSourceImpl, ImplSourceObject, ImplSourceParam,\n+    ImplSourceTraitAlias,\n };\n use crate::traits::{\n-    VtableAutoImplData, VtableBuiltinData, VtableClosureData, VtableDiscriminantKindData,\n-    VtableFnPointerData, VtableGeneratorData, VtableImplData, VtableObjectData,\n-    VtableTraitAliasData,\n+    ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n+    ImplSourceDiscriminantKindData, ImplSourceFnPointerData, ImplSourceGeneratorData,\n+    ImplSourceImplData, ImplSourceObjectData, ImplSourceTraitAliasData,\n };\n+use crate::traits::{ObjectCastObligation, PredicateObligation, TraitObligation};\n+use crate::traits::{Obligation, ObligationCause};\n+use crate::traits::{SelectionError, Unimplemented};\n \n use super::BuiltinImplConditions;\n use super::SelectionCandidate::{self, *};\n@@ -54,65 +55,67 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match candidate {\n             BuiltinCandidate { has_nested } => {\n                 let data = self.confirm_builtin_candidate(obligation, has_nested);\n-                Ok(VtableBuiltin(data))\n+                Ok(ImplSourceBuiltin(data))\n             }\n \n             ParamCandidate(param) => {\n                 let obligations = self.confirm_param_candidate(obligation, param);\n-                Ok(VtableParam(obligations))\n+                Ok(ImplSourceParam(obligations))\n             }\n \n             ImplCandidate(impl_def_id) => {\n-                Ok(VtableImpl(self.confirm_impl_candidate(obligation, impl_def_id)))\n+                Ok(ImplSourceImpl(self.confirm_impl_candidate(obligation, impl_def_id)))\n             }\n \n             AutoImplCandidate(trait_def_id) => {\n                 let data = self.confirm_auto_impl_candidate(obligation, trait_def_id);\n-                Ok(VtableAutoImpl(data))\n+                Ok(ImplSourceAutoImpl(data))\n             }\n \n             ProjectionCandidate => {\n                 self.confirm_projection_candidate(obligation);\n-                Ok(VtableParam(Vec::new()))\n+                Ok(ImplSourceParam(Vec::new()))\n             }\n \n             ClosureCandidate => {\n                 let vtable_closure = self.confirm_closure_candidate(obligation)?;\n-                Ok(VtableClosure(vtable_closure))\n+                Ok(ImplSourceClosure(vtable_closure))\n             }\n \n             GeneratorCandidate => {\n                 let vtable_generator = self.confirm_generator_candidate(obligation)?;\n-                Ok(VtableGenerator(vtable_generator))\n+                Ok(ImplSourceGenerator(vtable_generator))\n             }\n \n             FnPointerCandidate => {\n                 let data = self.confirm_fn_pointer_candidate(obligation)?;\n-                Ok(VtableFnPointer(data))\n+                Ok(ImplSourceFnPointer(data))\n             }\n \n-            DiscriminantKindCandidate => Ok(VtableDiscriminantKind(VtableDiscriminantKindData)),\n+            DiscriminantKindCandidate => {\n+                Ok(ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData))\n+            }\n \n             TraitAliasCandidate(alias_def_id) => {\n                 let data = self.confirm_trait_alias_candidate(obligation, alias_def_id);\n-                Ok(VtableTraitAlias(data))\n+                Ok(ImplSourceTraitAlias(data))\n             }\n \n             ObjectCandidate => {\n                 let data = self.confirm_object_candidate(obligation);\n-                Ok(VtableObject(data))\n+                Ok(ImplSourceObject(data))\n             }\n \n             BuiltinObjectCandidate => {\n                 // This indicates something like `Trait + Send: Send`. In this case, we know that\n                 // this holds because that's what the object type is telling us, and there's really\n                 // no additional obligations to prove and no types in particular to unify, etc.\n-                Ok(VtableParam(Vec::new()))\n+                Ok(ImplSourceParam(Vec::new()))\n             }\n \n             BuiltinUnsizeCandidate => {\n                 let data = self.confirm_builtin_unsize_candidate(obligation)?;\n-                Ok(VtableBuiltin(data))\n+                Ok(ImplSourceBuiltin(data))\n             }\n         }\n     }\n@@ -152,7 +155,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         has_nested: bool,\n-    ) -> VtableBuiltinData<PredicateObligation<'tcx>> {\n+    ) -> ImplSourceBuiltinData<PredicateObligation<'tcx>> {\n         debug!(\"confirm_builtin_candidate({:?}, {:?})\", obligation, has_nested);\n \n         let lang_items = self.tcx().lang_items();\n@@ -188,7 +191,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"confirm_builtin_candidate: obligations={:?}\", obligations);\n \n-        VtableBuiltinData { nested: obligations }\n+        ImplSourceBuiltinData { nested: obligations }\n     }\n \n     /// This handles the case where a `auto trait Foo` impl is being used.\n@@ -200,7 +203,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         trait_def_id: DefId,\n-    ) -> VtableAutoImplData<PredicateObligation<'tcx>> {\n+    ) -> ImplSourceAutoImplData<PredicateObligation<'tcx>> {\n         debug!(\"confirm_auto_impl_candidate({:?}, {:?})\", obligation, trait_def_id);\n \n         let types = obligation.predicate.map_bound(|inner| {\n@@ -216,7 +219,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         trait_def_id: DefId,\n         nested: ty::Binder<Vec<Ty<'tcx>>>,\n-    ) -> VtableAutoImplData<PredicateObligation<'tcx>> {\n+    ) -> ImplSourceAutoImplData<PredicateObligation<'tcx>> {\n         debug!(\"vtable_auto_impl: nested={:?}\", nested);\n         ensure_sufficient_stack(|| {\n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n@@ -249,15 +252,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             debug!(\"vtable_auto_impl: obligations={:?}\", obligations);\n \n-            VtableAutoImplData { trait_def_id, nested: obligations }\n+            ImplSourceAutoImplData { trait_def_id, nested: obligations }\n         })\n     }\n \n     fn confirm_impl_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         impl_def_id: DefId,\n-    ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n+    ) -> ImplSourceImplData<'tcx, PredicateObligation<'tcx>> {\n         debug!(\"confirm_impl_candidate({:?},{:?})\", obligation, impl_def_id);\n \n         // First, create the substitutions by matching the impl again,\n@@ -285,7 +288,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         cause: ObligationCause<'tcx>,\n         recursion_depth: usize,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n+    ) -> ImplSourceImplData<'tcx, PredicateObligation<'tcx>> {\n         debug!(\n             \"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={})\",\n             impl_def_id, substs, recursion_depth,\n@@ -311,13 +314,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // e.g., `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n         impl_obligations.append(&mut substs.obligations);\n \n-        VtableImplData { impl_def_id, substs: substs.value, nested: impl_obligations }\n+        ImplSourceImplData { impl_def_id, substs: substs.value, nested: impl_obligations }\n     }\n \n     fn confirm_object_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> VtableObjectData<'tcx, PredicateObligation<'tcx>> {\n+    ) -> ImplSourceObjectData<'tcx, PredicateObligation<'tcx>> {\n         debug!(\"confirm_object_candidate({:?})\", obligation);\n \n         // FIXME(nmatsakis) skipping binder here seems wrong -- we should\n@@ -366,13 +369,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n         }\n \n-        VtableObjectData { upcast_trait_ref: upcast_trait_ref.unwrap(), vtable_base, nested }\n+        ImplSourceObjectData { upcast_trait_ref: upcast_trait_ref.unwrap(), vtable_base, nested }\n     }\n \n     fn confirm_fn_pointer_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<VtableFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+    ) -> Result<ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>>\n+    {\n         debug!(\"confirm_fn_pointer_candidate({:?})\", obligation);\n \n         // Okay to skip binder; it is reintroduced below.\n@@ -403,14 +407,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligation.predicate.to_poly_trait_ref(),\n             trait_ref,\n         )?;\n-        Ok(VtableFnPointerData { fn_ty: self_ty, nested: obligations })\n+        Ok(ImplSourceFnPointerData { fn_ty: self_ty, nested: obligations })\n     }\n \n     fn confirm_trait_alias_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         alias_def_id: DefId,\n-    ) -> VtableTraitAliasData<'tcx, PredicateObligation<'tcx>> {\n+    ) -> ImplSourceTraitAliasData<'tcx, PredicateObligation<'tcx>> {\n         debug!(\"confirm_trait_alias_candidate({:?}, {:?})\", obligation, alias_def_id);\n \n         self.infcx.commit_unconditionally(|_| {\n@@ -433,14 +437,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 trait_def_id, trait_obligations\n             );\n \n-            VtableTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n+            ImplSourceTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n         })\n     }\n \n     fn confirm_generator_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+    ) -> Result<ImplSourceGeneratorData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>>\n+    {\n         // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n@@ -476,13 +481,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             trait_ref,\n         )?);\n \n-        Ok(VtableGeneratorData { generator_def_id, substs, nested: obligations })\n+        Ok(ImplSourceGeneratorData { generator_def_id, substs, nested: obligations })\n     }\n \n     fn confirm_closure_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+    ) -> Result<ImplSourceClosureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         debug!(\"confirm_closure_candidate({:?})\", obligation);\n \n         let kind = self\n@@ -533,7 +538,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ));\n         }\n \n-        Ok(VtableClosureData { closure_def_id, substs, nested: obligations })\n+        Ok(ImplSourceClosureData { closure_def_id, substs, nested: obligations })\n     }\n \n     /// In the case of closure types and fn pointers,\n@@ -578,7 +583,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_builtin_unsize_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<VtableBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+    ) -> Result<ImplSourceBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let tcx = self.tcx();\n \n         // `assemble_candidates_for_unsizing` should ensure there are no late-bound\n@@ -815,6 +820,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => bug!(),\n         };\n \n-        Ok(VtableBuiltinData { nested })\n+        Ok(ImplSourceBuiltinData { nested })\n     }\n }"}, {"sha": "8b5b4128e6672e726248d98c7581b64daa23a82e", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -297,7 +297,7 @@ pub fn count_own_vtable_entries(tcx: TyCtxt<'tcx>, trait_ref: ty::PolyTraitRef<'\n /// `object.upcast_trait_ref`) within the vtable for `object`.\n pub fn get_vtable_index_of_object_method<N>(\n     tcx: TyCtxt<'tcx>,\n-    object: &super::VtableObjectData<'tcx, N>,\n+    object: &super::ImplSourceObjectData<'tcx, N>,\n     method_def_id: DefId,\n ) -> usize {\n     // Count number of methods preceding the one we are selecting and"}, {"sha": "2b4daad66101465c7a228130508cd2fd93c2384f", "filename": "src/librustc_ty/instance.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -84,9 +84,9 @@ fn resolve_associated_item<'tcx>(\n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n     Ok(match vtbl {\n-        traits::VtableImpl(impl_data) => {\n+        traits::ImplSourceImpl(impl_data) => {\n             debug!(\n-                \"resolving VtableImpl: {:?}, {:?}, {:?}, {:?}\",\n+                \"resolving ImplSourceImpl: {:?}, {:?}, {:?}, {:?}\",\n                 param_env, trait_item, rcvr_substs, impl_data\n             );\n             assert!(!rcvr_substs.needs_infer());\n@@ -181,11 +181,11 @@ fn resolve_associated_item<'tcx>(\n \n             Some(ty::Instance::new(leaf_def.item.def_id, substs))\n         }\n-        traits::VtableGenerator(generator_data) => Some(Instance {\n+        traits::ImplSourceGenerator(generator_data) => Some(Instance {\n             def: ty::InstanceDef::Item(generator_data.generator_def_id),\n             substs: generator_data.substs,\n         }),\n-        traits::VtableClosure(closure_data) => {\n+        traits::ImplSourceClosure(closure_data) => {\n             let trait_closure_kind = tcx.fn_trait_kind_from_lang_item(trait_id).unwrap();\n             Some(Instance::resolve_closure(\n                 tcx,\n@@ -194,7 +194,7 @@ fn resolve_associated_item<'tcx>(\n                 trait_closure_kind,\n             ))\n         }\n-        traits::VtableFnPointer(ref data) => {\n+        traits::ImplSourceFnPointer(ref data) => {\n             // `FnPtrShim` requires a monomorphic aka concrete type.\n             if data.fn_ty.needs_subst() {\n                 return Ok(None);\n@@ -205,11 +205,11 @@ fn resolve_associated_item<'tcx>(\n                 substs: rcvr_substs,\n             })\n         }\n-        traits::VtableObject(ref data) => {\n+        traits::ImplSourceObject(ref data) => {\n             let index = traits::get_vtable_index_of_object_method(tcx, data, def_id);\n             Some(Instance { def: ty::InstanceDef::Virtual(def_id, index), substs: rcvr_substs })\n         }\n-        traits::VtableBuiltin(..) => {\n+        traits::ImplSourceBuiltin(..) => {\n             if Some(trait_ref.def_id) == tcx.lang_items().clone_trait() {\n                 // FIXME(eddyb) use lang items for methods instead of names.\n                 let name = tcx.item_name(def_id);\n@@ -236,10 +236,10 @@ fn resolve_associated_item<'tcx>(\n                 None\n             }\n         }\n-        traits::VtableAutoImpl(..)\n-        | traits::VtableParam(..)\n-        | traits::VtableTraitAlias(..)\n-        | traits::VtableDiscriminantKind(..) => None,\n+        traits::ImplSourceAutoImpl(..)\n+        | traits::ImplSourceParam(..)\n+        | traits::ImplSourceTraitAlias(..)\n+        | traits::ImplSourceDiscriminantKind(..) => None,\n     })\n }\n "}, {"sha": "efafb05c0409138ec4162480ac50c27253ce26fb", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -657,7 +657,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     // be silent, as it causes a type mismatch later.\n                 }\n \n-                Ok(Some(vtable)) => queue.extend(vtable.nested_obligations()),\n+                Ok(Some(impl_source)) => queue.extend(impl_source.nested_obligations()),\n             }\n         }\n "}, {"sha": "f533e1097c210825b866a5f9d49d8ae7a084d955", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -1303,7 +1303,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     .at(&ObligationCause::dummy(), self.param_env)\n                     .sup(candidate.xform_self_ty, self_ty);\n                 match self.select_trait_candidate(trait_ref) {\n-                    Ok(Some(traits::Vtable::VtableImpl(ref impl_data))) => {\n+                    Ok(Some(traits::ImplSource::ImplSourceImpl(ref impl_data))) => {\n                         // If only a single impl matches, make the error message point\n                         // to that impl.\n                         ImplSource(impl_data.impl_def_id)\n@@ -1384,10 +1384,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         if self.probe(|_| {\n                             match self.select_trait_candidate(trait_ref) {\n                                 Err(_) => return true,\n-                                Ok(Some(vtable))\n-                                    if !vtable.borrow_nested_obligations().is_empty() =>\n+                                Ok(Some(impl_source))\n+                                    if !impl_source.borrow_nested_obligations().is_empty() =>\n                                 {\n-                                    for obligation in vtable.borrow_nested_obligations() {\n+                                    for obligation in impl_source.borrow_nested_obligations() {\n                                         // Determine exactly which obligation wasn't met, so\n                                         // that we can give more context in the error.\n                                         if !self.predicate_may_hold(&obligation) {"}, {"sha": "c3774f1d7965355dcc1f4dca09407db435f7e512", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01896a36f36513676756ea3eb3b8284665263cf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e01896a36f36513676756ea3eb3b8284665263cf", "patch": "@@ -31,9 +31,6 @@ can be broken down into several distinct phases:\n   final assignments of the various region variables if there is some\n   flexibility.\n \n-- vtable: find and records the impls to use for each trait bound that\n-  appears on a type parameter.\n-\n - writeback: writes the final types within a function body, replacing\n   type variables with their final inferred types.  These final types\n   are written into the `tcx.node_types` table, which should *never* contain\n@@ -4050,7 +4047,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             debug!(\"check_closures={}\", check_closures);\n \n             // More awful hacks: before we check argument types, try to do\n-            // an \"opportunistic\" vtable resolution of any trait bounds on\n+            // an \"opportunistic\" trait resolution of any trait bounds on\n             // the call. This helps coercions.\n             if check_closures {\n                 self.select_obligations_where_possible(false, |errors| {"}]}