{"sha": "5ce5e0860634258205c313879cb81a125aef4fcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZTVlMDg2MDYzNDI1ODIwNWMzMTM4NzljYjgxYTEyNWFlZjRmY2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-23T20:34:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-23T20:34:12Z"}, "message": "Auto merge of #53588 - tristanburgess:52985_diagnostics_no_concrete_type_behind_existential_type, r=oli-obk\n\n52985 diagnostics no concrete type behind existential type\n\n@oli-obk FYI. See below for new cycle error generated.\n\n```rust\nerror[E0391]: cycle detected when processing `Foo`\n --> /dev/staging/existential_type_no_concrete_type_nouse_potential.rs:3:1\n  |\n3 | existential type Foo: Copy;\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nnote: ...which requires processing `bar`...\n --> /dev/staging/existential_type_no_concrete_type_nouse_potential.rs:6:23\n  |\n6 |   fn bar(x: Foo) -> Foo {\n  |  _______________________^\n7 | |     x\n8 | | }\n  | |_^\n  = note: ...which again requires processing `Foo`, completing the cycle\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0391`.\n```", "tree": {"sha": "9af7f5ece63bb1a41e361adf3072b89c34590637", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9af7f5ece63bb1a41e361adf3072b89c34590637"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ce5e0860634258205c313879cb81a125aef4fcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ce5e0860634258205c313879cb81a125aef4fcb", "html_url": "https://github.com/rust-lang/rust/commit/5ce5e0860634258205c313879cb81a125aef4fcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ce5e0860634258205c313879cb81a125aef4fcb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54d82d0880f93e293bc8fd6439ccfa7970d41f02", "url": "https://api.github.com/repos/rust-lang/rust/commits/54d82d0880f93e293bc8fd6439ccfa7970d41f02", "html_url": "https://github.com/rust-lang/rust/commit/54d82d0880f93e293bc8fd6439ccfa7970d41f02"}, {"sha": "7440125d622356291909efd1027162b4983c6f9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7440125d622356291909efd1027162b4983c6f9f", "html_url": "https://github.com/rust-lang/rust/commit/7440125d622356291909efd1027162b4983c6f9f"}], "stats": {"total": 161, "additions": 95, "deletions": 66}, "files": [{"sha": "8b4954cc501dd3aeac50a0cd7e22ca4f7eba32ac", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5ce5e0860634258205c313879cb81a125aef4fcb/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ce5e0860634258205c313879cb81a125aef4fcb/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=5ce5e0860634258205c313879cb81a125aef4fcb", "patch": "@@ -121,36 +121,14 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                         let concrete_ty = generic_ty.subst(self.tcx(), substs);\n                         self.anon_depth += 1;\n                         if concrete_ty == ty {\n-                            // The type in question can only be inferred in terms of itself. This\n-                            // is likely a user code issue, not a compiler issue. Thus, we will\n-                            // induce a cycle error by calling the parent query again on the type.\n-                            //\n-                            // FIXME: Perhaps a better solution would be to have fold_ty()\n-                            // itself be a query. Then, a type fold cycle would be detected\n-                            // and reported more naturally as part of the query system, rather\n-                            // than forcing it here.\n-                            //\n-                            // FIXME: Need a better span than just one pointing to the type def.\n-                            // Should point to a defining use of the type that results in this\n-                            // un-normalizable state.\n-                            if let Some(param_env_lifted) =\n-                                self.tcx().lift_to_global(&self.param_env)\n-                            {\n-                                if let Some(ty_lifted) = self.tcx().lift_to_global(&concrete_ty) {\n-                                    let span = self.tcx().def_span(def_id);\n-                                    self.tcx()\n-                                        .global_tcx()\n-                                        .at(span)\n-                                        .normalize_ty_after_erasing_regions(\n-                                            param_env_lifted.and(ty_lifted),\n-                                        );\n-                                    self.tcx().sess.abort_if_errors();\n-                                }\n-                            }\n-                            // If a cycle error can't be emitted, indicate a NoSolution error\n-                            // and let the caller handle it.\n-                            self.error = true;\n-                            return concrete_ty;\n+                            bug!(\n+                                \"infinite recursion generic_ty: {:#?}, substs: {:#?}, \\\n+                                 concrete_ty: {:#?}, ty: {:#?}\",\n+                                generic_ty,\n+                                substs,\n+                                concrete_ty,\n+                                ty\n+                            );\n                         }\n                         let folded_ty = self.fold_ty(concrete_ty);\n                         self.anon_depth -= 1;"}, {"sha": "319de51713b93abcb8bec52bbbbcc9059aecd185", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 49, "deletions": 34, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5ce5e0860634258205c313879cb81a125aef4fcb/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ce5e0860634258205c313879cb81a125aef4fcb/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=5ce5e0860634258205c313879cb81a125aef4fcb", "patch": "@@ -17,15 +17,15 @@ use rustc::hir;\n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::infer::InferCtxt;\n+use rustc::ty::adjustment::{Adjust, Adjustment};\n+use rustc::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::adjustment::{Adjust, Adjustment};\n-use rustc::ty::fold::{TypeFoldable, TypeFolder, BottomUpFolder};\n use rustc::util::nodemap::DefIdSet;\n+use rustc_data_structures::sync::Lrc;\n+use std::mem;\n use syntax::ast;\n use syntax_pos::Span;\n-use std::mem;\n-use rustc_data_structures::sync::Lrc;\n \n ///////////////////////////////////////////////////////////////////////////\n // Entry point\n@@ -55,17 +55,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n         debug!(\n             \"used_trait_imports({:?}) = {:?}\",\n-            item_def_id,\n-            used_trait_imports\n+            item_def_id, used_trait_imports\n         );\n         wbcx.tables.used_trait_imports = used_trait_imports;\n \n         wbcx.tables.tainted_by_errors = self.is_tainted_by_errors();\n \n         debug!(\n             \"writeback: tables for {:?} are {:#?}\",\n-            item_def_id,\n-            wbcx.tables\n+            item_def_id, wbcx.tables\n         );\n \n         self.tcx.alloc_tables(wbcx.tables)\n@@ -118,8 +116,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     // operating on scalars, we clear the overload.\n     fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n-            hir::ExprKind::Unary(hir::UnNeg, ref inner) |\n-            hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n+            hir::ExprKind::Unary(hir::UnNeg, ref inner)\n+            | hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n                 let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n \n@@ -178,8 +176,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     let index_ty = tables.expr_ty_adjusted(&index);\n                     let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n \n-                    if base_ty.builtin_index().is_some()\n-                        && index_ty == self.fcx.tcx.types.usize {\n+                    if base_ty.builtin_index().is_some() && index_ty == self.fcx.tcx.types.usize {\n                         // Remove the method call record\n                         tables.type_dependent_defs_mut().remove(e.hir_id);\n                         tables.node_substs_mut().remove(e.hir_id);\n@@ -191,24 +188,26 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                 // of size information - we need to get rid of it\n                                 // Since this is \"after\" the other adjustment to be\n                                 // discarded, we do an extra `pop()`\n-                                Some(Adjustment { kind: Adjust::Unsize, .. }) => {\n+                                Some(Adjustment {\n+                                    kind: Adjust::Unsize,\n+                                    ..\n+                                }) => {\n                                     // So the borrow discard actually happens here\n                                     a.pop();\n-                                },\n+                                }\n                                 _ => {}\n                             }\n                         });\n                     }\n-                },\n+                }\n                 // Might encounter non-valid indexes at this point, so there\n                 // has to be a fall-through\n-                _ => {},\n+                _ => {}\n             }\n         }\n     }\n }\n \n-\n ///////////////////////////////////////////////////////////////////////////\n // Impl of Visitor for Resolver\n //\n@@ -262,7 +261,9 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n                 if let Some(&bm) = self.fcx.tables.borrow().pat_binding_modes().get(p.hir_id) {\n                     self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n                 } else {\n-                    self.tcx().sess.delay_span_bug(p.span, \"missing binding mode\");\n+                    self.tcx()\n+                        .sess\n+                        .delay_span_bug(p.span, \"missing binding mode\");\n                 }\n             }\n             hir::PatKind::Struct(_, ref fields, _) => {\n@@ -310,8 +311,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             };\n             debug!(\n                 \"Upvar capture for {:?} resolved to {:?}\",\n-                upvar_id,\n-                new_upvar_capture\n+                upvar_id, new_upvar_capture\n             );\n             self.tables\n                 .upvar_capture_map\n@@ -425,8 +425,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                     if subst == ty {\n                                         // found it in the substitution list, replace with the\n                                         // parameter from the existential type\n-                                        return self\n-                                            .tcx()\n+                                        return self.tcx()\n                                             .global_tcx()\n                                             .mk_ty_param(param.index, param.name);\n                                     }\n@@ -464,14 +463,16 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                                 name: p.name,\n                                             };\n                                             trace!(\"replace {:?} with {:?}\", region, reg);\n-                                            return self.tcx().global_tcx()\n+                                            return self.tcx()\n+                                                .global_tcx()\n                                                 .mk_region(ty::ReEarlyBound(reg));\n                                         }\n                                     }\n                                 }\n                                 trace!(\"anon_defn: {:#?}\", anon_defn);\n                                 trace!(\"generics: {:#?}\", generics);\n-                                self.tcx().sess\n+                                self.tcx()\n+                                    .sess\n                                     .struct_span_err(\n                                         span,\n                                         \"non-defining existential type use in defining scope\",\n@@ -480,25 +481,35 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                         span,\n                                         format!(\n                                             \"lifetime `{}` is part of concrete type but not used \\\n-                                            in parameter list of existential type\",\n+                                             in parameter list of existential type\",\n                                             region,\n                                         ),\n                                     )\n                                     .emit();\n                                 self.tcx().global_tcx().mk_region(ty::ReStatic)\n                             }\n                         }\n-                    }\n+                    },\n                 })\n             };\n \n-            let old = self.tables.concrete_existential_types.insert(def_id, definition_ty);\n+            if let ty::Anon(defin_ty_def_id, _substs) = definition_ty.sty {\n+                if def_id == defin_ty_def_id {\n+                    // Concrete type resolved to the existential type itself\n+                    // Force a cycle error\n+                    self.tcx().at(span).type_of(defin_ty_def_id);\n+                }\n+            }\n+\n+            let old = self.tables\n+                .concrete_existential_types\n+                .insert(def_id, definition_ty);\n             if let Some(old) = old {\n                 if old != definition_ty {\n                     span_bug!(\n                         span,\n                         \"visit_anon_types tried to write \\\n-                        different types for the same existential type: {:?}, {:?}, {:?}\",\n+                         different types for the same existential type: {:?}, {:?}, {:?}\",\n                         def_id,\n                         definition_ty,\n                         old,\n@@ -510,7 +521,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_field_id(&mut self, node_id: ast::NodeId) {\n         let hir_id = self.tcx().hir.node_to_hir_id(node_id);\n-        if let Some(index) = self.fcx.tables.borrow_mut().field_indices_mut().remove(hir_id) {\n+        if let Some(index) = self.fcx\n+            .tables\n+            .borrow_mut()\n+            .field_indices_mut()\n+            .remove(hir_id)\n+        {\n             self.tables.field_indices_mut().insert(hir_id, index);\n         }\n     }\n@@ -559,8 +575,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n                 debug!(\n                     \"Adjustments for node {:?}: {:?}\",\n-                    hir_id,\n-                    resolved_adjustment\n+                    hir_id, resolved_adjustment\n                 );\n                 self.tables\n                     .adjustments_mut()\n@@ -584,8 +599,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n                 debug!(\n                     \"pat_adjustments for node {:?}: {:?}\",\n-                    hir_id,\n-                    resolved_adjustment\n+                    hir_id, resolved_adjustment\n                 );\n                 self.tables\n                     .pat_adjustments_mut()\n@@ -701,7 +715,8 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n     fn report_error(&self, t: Ty<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n             self.infcx\n-                .need_type_info_err(Some(self.body.id()), self.span.to_span(&self.tcx), t).emit();\n+                .need_type_info_err(Some(self.body.id()), self.span.to_span(&self.tcx), t)\n+                .emit();\n         }\n     }\n }"}, {"sha": "aac72c71d030850b26b7fd8963fce28331047eb4", "filename": "src/test/ui/existential_types/nested_existential_types.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5ce5e0860634258205c313879cb81a125aef4fcb/src%2Ftest%2Fui%2Fexistential_types%2Fnested_existential_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ce5e0860634258205c313879cb81a125aef4fcb/src%2Ftest%2Fui%2Fexistential_types%2Fnested_existential_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fnested_existential_types.rs?ref=5ce5e0860634258205c313879cb81a125aef4fcb", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(existential_type)]\n+// compile-pass\n+mod my_mod {\n+  use std::fmt::Debug;\n+\n+  pub existential type Foo: Debug;\n+  pub existential type Foot: Debug;\n+\n+  pub fn get_foo() -> Foo {\n+      5i32\n+  }\n+\n+  pub fn get_foot() -> Foot {\n+      get_foo()\n+  }\n+}\n+\n+fn main() {\n+    let _: my_mod::Foot = my_mod::get_foot();\n+}\n+"}, {"sha": "06e40fd6ab554ff8aec2d8a5aa52e4138514fe2b", "filename": "src/test/ui/existential_types/no_inferrable_concrete_type.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5ce5e0860634258205c313879cb81a125aef4fcb/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ce5e0860634258205c313879cb81a125aef4fcb/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.stderr?ref=5ce5e0860634258205c313879cb81a125aef4fcb", "patch": "@@ -1,10 +1,15 @@\n-error[E0391]: cycle detected when normalizing `ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: All }, value: Foo }`\n+error[E0391]: cycle detected when processing `Foo`\n   --> $DIR/no_inferrable_concrete_type.rs:16:1\n    |\n LL | existential type Foo: Copy; //~ cycle detected\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires normalizing `ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: All }, value: Foo }`, completing the cycle\n+note: ...which requires processing `bar`...\n+  --> $DIR/no_inferrable_concrete_type.rs:19:23\n+   |\n+LL | fn bar(x: Foo) -> Foo { x }\n+   |                       ^^^^^\n+   = note: ...which again requires processing `Foo`, completing the cycle\n \n error: aborting due to previous error\n "}]}