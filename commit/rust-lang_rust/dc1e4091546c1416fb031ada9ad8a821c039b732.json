{"sha": "dc1e4091546c1416fb031ada9ad8a821c039b732", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMWU0MDkxNTQ2YzE0MTZmYjAzMWFkYTlhZDhhODIxYzAzOWI3MzI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-02T15:08:38Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-02T15:08:38Z"}, "message": "Merge #3344\n\n3344: Added lints `into_iter_on_ref` and `into_iter_on_array`. r=phansch a=kennytm\n\nFixes #1565.\r\n\r\n`into_iter_on_array` is a correctness lint against `into_iter()` on `[T; n]` and `PathBuf` (please provide a concise noun that covers both types \ud83d\ude43).\r\n\r\n`into_iter_on_ref` is a style lint against `into_iter()` on `&C` where `C` is `[T]`, `Vec<T>`, `BTreeSet<T>` etc.\r\n\r\nBoth suggests replacing the `into_iter()` with `iter()` or `iter_mut()`.\r\n\r\n`into_iter_on_array` is a correctness lint since it is very likely the standard library would provide an `into_iter()` method for `[T; n]` (rust-lang/rust#25725) and existing type inference of `[a, b, c].into_iter()` will be broken. `PathBuf` is also placed under this lint since `PathBuf::into_iter` currently doesn't exist and it makes some sense to implement `IntoIterator` on it yielding `OsString`s.\n\nCo-authored-by: kennytm <kennytm@gmail.com>", "tree": {"sha": "aa3cd792971f445f8b10faa495cf2af1958de1ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa3cd792971f445f8b10faa495cf2af1958de1ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc1e4091546c1416fb031ada9ad8a821c039b732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc1e4091546c1416fb031ada9ad8a821c039b732", "html_url": "https://github.com/rust-lang/rust/commit/dc1e4091546c1416fb031ada9ad8a821c039b732", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc1e4091546c1416fb031ada9ad8a821c039b732/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "a8d258454f4aba9e3e4375ff47e2fdc4d48450a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d258454f4aba9e3e4375ff47e2fdc4d48450a6", "html_url": "https://github.com/rust-lang/rust/commit/a8d258454f4aba9e3e4375ff47e2fdc4d48450a6"}, {"sha": "5563bd6cc366c1e1596bd65c86f04fa66649e993", "url": "https://api.github.com/repos/rust-lang/rust/commits/5563bd6cc366c1e1596bd65c86f04fa66649e993", "html_url": "https://github.com/rust-lang/rust/commit/5563bd6cc366c1e1596bd65c86f04fa66649e993"}], "stats": {"total": 357, "additions": 350, "deletions": 7}, "files": [{"sha": "72183f68ee0b23082b8700d1c1d2a5e065084c6a", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc1e4091546c1416fb031ada9ad8a821c039b732/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/dc1e4091546c1416fb031ada9ad8a821c039b732/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=dc1e4091546c1416fb031ada9ad8a821c039b732", "patch": "@@ -713,6 +713,8 @@ All notable changes to this project will be documented in this file.\n [`inline_fn_without_body`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#inline_fn_without_body\n [`int_plus_one`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#int_plus_one\n [`integer_arithmetic`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#integer_arithmetic\n+[`into_iter_on_array`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#into_iter_on_array\n+[`into_iter_on_ref`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#into_iter_on_ref\n [`invalid_ref`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#invalid_ref\n [`invalid_regex`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#invalid_regex\n [`invalid_upcast_comparisons`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#invalid_upcast_comparisons"}, {"sha": "8af7a20f66dc8a147846757eb6d7d3feced8b439", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc1e4091546c1416fb031ada9ad8a821c039b732/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/dc1e4091546c1416fb031ada9ad8a821c039b732/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=dc1e4091546c1416fb031ada9ad8a821c039b732", "patch": "@@ -9,7 +9,7 @@ We are currently in the process of discussing Clippy 1.0 via the RFC process in\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 284 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n+[There are 286 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "863c06234871e22d47948b01a8a3081c9e854024", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc1e4091546c1416fb031ada9ad8a821c039b732/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1e4091546c1416fb031ada9ad8a821c039b732/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=dc1e4091546c1416fb031ada9ad8a821c039b732", "patch": "@@ -628,6 +628,8 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         methods::EXPECT_FUN_CALL,\n         methods::FILTER_NEXT,\n         methods::GET_UNWRAP,\n+        methods::INTO_ITER_ON_ARRAY,\n+        methods::INTO_ITER_ON_REF,\n         methods::ITER_CLONED_COLLECT,\n         methods::ITER_NTH,\n         methods::ITER_SKIP_NEXT,\n@@ -784,6 +786,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         mem_replace::MEM_REPLACE_OPTION_WITH_NONE,\n         methods::CHARS_LAST_CMP,\n         methods::GET_UNWRAP,\n+        methods::INTO_ITER_ON_REF,\n         methods::ITER_CLONED_COLLECT,\n         methods::ITER_SKIP_NEXT,\n         methods::NEW_RET_NO_SELF,\n@@ -935,6 +938,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         loops::WHILE_IMMUTABLE_CONDITION,\n         mem_discriminant::MEM_DISCRIMINANT_NON_ENUM,\n         methods::CLONE_DOUBLE_REF,\n+        methods::INTO_ITER_ON_ARRAY,\n         methods::TEMPORARY_CSTRING_AS_PTR,\n         minmax::MIN_MAX,\n         misc::CMP_NAN,"}, {"sha": "f029dd65b395d1cde784d45e5b4043c11742456c", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc1e4091546c1416fb031ada9ad8a821c039b732/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1e4091546c1416fb031ada9ad8a821c039b732/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=dc1e4091546c1416fb031ada9ad8a821c039b732", "patch": "@@ -210,7 +210,7 @@ impl<'a> DigitInfo<'a> {\n                 .filter(|&c| c != '_')\n                 .collect::<Vec<_>>()\n                 .chunks(group_size)\n-                .map(|chunk| chunk.into_iter().rev().collect())\n+                .map(|chunk| chunk.iter().rev().collect())\n                 .rev()\n                 .collect::<Vec<String>>()\n                 .join(\"_\");\n@@ -221,7 +221,7 @@ impl<'a> DigitInfo<'a> {\n                 .filter(|&c| c != '_')\n                 .collect::<Vec<_>>()\n                 .chunks(group_size)\n-                .map(|chunk| chunk.into_iter().collect())\n+                .map(|chunk| chunk.iter().collect())\n                 .collect::<Vec<String>>()\n                 .join(\"_\");\n             format!(\n@@ -238,7 +238,7 @@ impl<'a> DigitInfo<'a> {\n                 .collect::<Vec<_>>();\n             let mut hint = filtered_digits_vec\n                 .chunks(group_size)\n-                .map(|chunk| chunk.into_iter().rev().collect())\n+                .map(|chunk| chunk.iter().rev().collect())\n                 .rev()\n                 .collect::<Vec<String>>()\n                 .join(\"_\");"}, {"sha": "e3c704b77adcab84cada77625e0cd6372469ff7e", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 117, "deletions": 2, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/dc1e4091546c1416fb031ada9ad8a821c039b732/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1e4091546c1416fb031ada9ad8a821c039b732/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=dc1e4091546c1416fb031ada9ad8a821c039b732", "patch": "@@ -575,7 +575,7 @@ declare_clippy_lint! {\n /// temporary placeholder for dealing with the `Option` type, then this does\n /// not mitigate the need for error handling. If there is a chance that `.get()`\n /// will be `None` in your program, then it is advisable that the `None` case\n-/// is handled in a future refactor instead of using `.unwrap()` or the Index \n+/// is handled in a future refactor instead of using `.unwrap()` or the Index\n /// trait.\n ///\n /// **Example:**\n@@ -745,6 +745,51 @@ declare_clippy_lint! {\n     \"using `filter_map` when a more succinct alternative exists\"\n }\n \n+/// **What it does:** Checks for `into_iter` calls on types which should be replaced by `iter` or\n+/// `iter_mut`.\n+///\n+/// **Why is this bad?** Arrays and `PathBuf` do not yet have an `into_iter` method which move out\n+/// their content into an iterator. Auto-referencing resolves the `into_iter` call to its reference\n+/// instead, like `<&[T; N] as IntoIterator>::into_iter`, which just iterates over item references\n+/// like calling `iter` would. Furthermore, when the standard library actually\n+/// [implements the `into_iter` method][25725] which moves the content out of the array, the\n+/// original use of `into_iter` got inferred with the wrong type and the code will be broken.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// let _ = [1, 2, 3].into_iter().map(|x| *x).collect::<Vec<u32>>();\n+/// ```\n+///\n+/// [25725]: https://github.com/rust-lang/rust/issues/25725\n+declare_clippy_lint! {\n+    pub INTO_ITER_ON_ARRAY,\n+    correctness,\n+    \"using `.into_iter()` on an array\"\n+}\n+\n+/// **What it does:** Checks for `into_iter` calls on references which should be replaced by `iter`\n+/// or `iter_mut`.\n+///\n+/// **Why is this bad?** Readability. Calling `into_iter` on a reference will not move out its\n+/// content into the resulting iterator, which is confusing. It is better just call `iter` or\n+/// `iter_mut` directly.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// let _ = (&vec![3, 4, 5]).into_iter();\n+/// ```\n+declare_clippy_lint! {\n+    pub INTO_ITER_ON_REF,\n+    style,\n+    \"using `.into_iter()` on a reference\"\n+}\n+\n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n@@ -779,7 +824,9 @@ impl LintPass for Pass {\n             ITER_CLONED_COLLECT,\n             USELESS_ASREF,\n             UNNECESSARY_FOLD,\n-            UNNECESSARY_FILTER_MAP\n+            UNNECESSARY_FILTER_MAP,\n+            INTO_ITER_ON_ARRAY,\n+            INTO_ITER_ON_REF,\n         )\n     }\n }\n@@ -843,6 +890,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             lint_single_char_pattern(cx, expr, &args[pos]);\n                         }\n                     },\n+                    ty::Ref(..) if method_call.ident.name == \"into_iter\" => {\n+                        lint_into_iter(cx, expr, self_ty, *method_span);\n+                    },\n                     _ => (),\n                 }\n             },\n@@ -2084,6 +2134,71 @@ fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_re\n     }\n }\n \n+fn ty_has_iter_method(cx: &LateContext<'_, '_>, self_ref_ty: ty::Ty<'_>) -> Option<(&'static Lint, &'static str, &'static str)> {\n+    // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n+    // exists and has the desired signature. Unfortunately FnCtxt is not exported\n+    // so we can't use its `lookup_method` method.\n+    static INTO_ITER_COLLECTIONS: [(&Lint, &[&str]); 13] = [\n+        (INTO_ITER_ON_REF, &paths::VEC),\n+        (INTO_ITER_ON_REF, &paths::OPTION),\n+        (INTO_ITER_ON_REF, &paths::RESULT),\n+        (INTO_ITER_ON_REF, &paths::BTREESET),\n+        (INTO_ITER_ON_REF, &paths::BTREEMAP),\n+        (INTO_ITER_ON_REF, &paths::VEC_DEQUE),\n+        (INTO_ITER_ON_REF, &paths::LINKED_LIST),\n+        (INTO_ITER_ON_REF, &paths::BINARY_HEAP),\n+        (INTO_ITER_ON_REF, &paths::HASHSET),\n+        (INTO_ITER_ON_REF, &paths::HASHMAP),\n+        (INTO_ITER_ON_ARRAY, &[\"std\", \"path\", \"PathBuf\"]),\n+        (INTO_ITER_ON_REF, &[\"std\", \"path\", \"Path\"]),\n+        (INTO_ITER_ON_REF, &[\"std\", \"sync\", \"mpsc\", \"Receiver\"]),\n+    ];\n+\n+    let (self_ty, mutbl) = match self_ref_ty.sty {\n+        ty::TyKind::Ref(_, self_ty, mutbl) => (self_ty, mutbl),\n+        _ => unreachable!(),\n+    };\n+    let method_name = match mutbl {\n+        hir::MutImmutable => \"iter\",\n+        hir::MutMutable => \"iter_mut\",\n+    };\n+\n+    let def_id = match self_ty.sty {\n+        ty::TyKind::Array(..) => return Some((INTO_ITER_ON_ARRAY, \"array\", method_name)),\n+        ty::TyKind::Slice(..) => return Some((INTO_ITER_ON_REF, \"slice\", method_name)),\n+        ty::Adt(adt, _) => adt.did,\n+        _ => return None,\n+    };\n+\n+    for (lint, path) in &INTO_ITER_COLLECTIONS {\n+        if match_def_path(cx.tcx, def_id, path) {\n+            return Some((lint, path.last().unwrap(), method_name))\n+        }\n+    }\n+    None\n+}\n+\n+fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: ty::Ty<'_>, method_span: Span) {\n+    if !match_trait_method(cx, expr, &paths::INTO_ITERATOR) {\n+        return;\n+    }\n+    if let Some((lint, kind, method_name)) = ty_has_iter_method(cx, self_ref_ty) {\n+        span_lint_and_sugg(\n+            cx,\n+            lint,\n+            method_span,\n+            &format!(\n+                \"this .into_iter() call is equivalent to .{}() and will not move the {}\",\n+                method_name,\n+                kind,\n+            ),\n+            \"call directly\",\n+            method_name.to_owned(),\n+        );\n+    }\n+}\n+\n+\n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext<'_, '_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n     if let ty::Adt(_, substs) = ty.sty {"}, {"sha": "513a3c0ee421a1898366b5230a0fd466b8d412e8", "filename": "tests/ui/for_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc1e4091546c1416fb031ada9ad8a821c039b732/tests%2Fui%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1e4091546c1416fb031ada9ad8a821c039b732/tests%2Fui%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.rs?ref=dc1e4091546c1416fb031ada9ad8a821c039b732", "patch": "@@ -29,7 +29,7 @@ impl Unrelated {\n        clippy::for_kv_map)]\n #[warn(clippy::unused_collect)]\n #[allow(clippy::linkedlist, clippy::shadow_unrelated, clippy::unnecessary_mut_passed, clippy::cyclomatic_complexity, clippy::similar_names)]\n-#[allow(clippy::many_single_char_names, unused_variables)]\n+#[allow(clippy::many_single_char_names, unused_variables, clippy::into_iter_on_array)]\n fn main() {\n     const MAX_LEN: usize = 42;\n "}, {"sha": "72aa6341a50b947df789dbd7fd3041786f600141", "filename": "tests/ui/into_iter_on_ref.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dc1e4091546c1416fb031ada9ad8a821c039b732/tests%2Fui%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1e4091546c1416fb031ada9ad8a821c039b732/tests%2Fui%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finto_iter_on_ref.rs?ref=dc1e4091546c1416fb031ada9ad8a821c039b732", "patch": "@@ -0,0 +1,44 @@\n+#![warn(clippy::into_iter_on_ref)]\n+#![deny(clippy::into_iter_on_array)]\n+\n+struct X;\n+use std::collections::*;\n+\n+fn main() {\n+    for _ in &[1,2,3] {}\n+    for _ in vec![X, X] {}\n+    for _ in &vec![X, X] {}\n+    for _ in [1,2,3].into_iter() {} //~ ERROR equivalent to .iter()\n+\n+    let _ = [1,2,3].into_iter(); //~ ERROR equivalent to .iter()\n+    let _ = vec![1,2,3].into_iter();\n+    let _ = (&vec![1,2,3]).into_iter(); //~ WARN equivalent to .iter()\n+    let _ = vec![1,2,3].into_boxed_slice().into_iter(); //~ WARN equivalent to .iter()\n+    let _ = std::rc::Rc::from(&[X][..]).into_iter(); //~ WARN equivalent to .iter()\n+    let _ = std::sync::Arc::from(&[X][..]).into_iter(); //~ WARN equivalent to .iter()\n+\n+    let _ = (&&&&&&&[1,2,3]).into_iter(); //~ ERROR equivalent to .iter()\n+    let _ = (&&&&mut &&&[1,2,3]).into_iter(); //~ ERROR equivalent to .iter()\n+    let _ = (&mut &mut &mut [1,2,3]).into_iter(); //~ ERROR equivalent to .iter_mut()\n+\n+    let _ = (&Some(4)).into_iter(); //~ WARN equivalent to .iter()\n+    let _ = (&mut Some(5)).into_iter(); //~ WARN equivalent to .iter_mut()\n+    let _ = (&Ok::<_, i32>(6)).into_iter(); //~ WARN equivalent to .iter()\n+    let _ = (&mut Err::<i32, _>(7)).into_iter(); //~ WARN equivalent to .iter_mut()\n+    let _ = (&Vec::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n+    let _ = (&mut Vec::<i32>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n+    let _ = (&BTreeMap::<i32, u64>::new()).into_iter(); //~ WARN equivalent to .iter()\n+    let _ = (&mut BTreeMap::<i32, u64>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n+    let _ = (&VecDeque::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n+    let _ = (&mut VecDeque::<i32>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n+    let _ = (&LinkedList::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n+    let _ = (&mut LinkedList::<i32>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n+    let _ = (&HashMap::<i32, u64>::new()).into_iter(); //~ WARN equivalent to .iter()\n+    let _ = (&mut HashMap::<i32, u64>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n+\n+    let _ = (&BTreeSet::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n+    let _ = (&BinaryHeap::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n+    let _ = (&HashSet::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n+    let _ = std::path::Path::new(\"12/34\").into_iter(); //~ WARN equivalent to .iter()\n+    let _ = std::path::PathBuf::from(\"12/34\").into_iter(); //~ ERROR equivalent to .iter()\n+}"}, {"sha": "390554230488ac7da03d0acfe23eb2873fb538b2", "filename": "tests/ui/into_iter_on_ref.stderr", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/dc1e4091546c1416fb031ada9ad8a821c039b732/tests%2Fui%2Finto_iter_on_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc1e4091546c1416fb031ada9ad8a821c039b732/tests%2Fui%2Finto_iter_on_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finto_iter_on_ref.stderr?ref=dc1e4091546c1416fb031ada9ad8a821c039b732", "patch": "@@ -0,0 +1,178 @@\n+error: this .into_iter() call is equivalent to .iter() and will not move the array\n+  --> $DIR/into_iter_on_ref.rs:11:22\n+   |\n+11 |     for _ in [1,2,3].into_iter() {} //~ ERROR equivalent to .iter()\n+   |                      ^^^^^^^^^ help: call directly: `iter`\n+   |\n+note: lint level defined here\n+  --> $DIR/into_iter_on_ref.rs:2:9\n+   |\n+2  | #![deny(clippy::into_iter_on_array)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the array\n+  --> $DIR/into_iter_on_ref.rs:13:21\n+   |\n+13 |     let _ = [1,2,3].into_iter(); //~ ERROR equivalent to .iter()\n+   |                     ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the Vec\n+  --> $DIR/into_iter_on_ref.rs:15:28\n+   |\n+15 |     let _ = (&vec![1,2,3]).into_iter(); //~ WARN equivalent to .iter()\n+   |                            ^^^^^^^^^ help: call directly: `iter`\n+   |\n+   = note: `-D clippy::into-iter-on-ref` implied by `-D warnings`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the slice\n+  --> $DIR/into_iter_on_ref.rs:16:44\n+   |\n+16 |     let _ = vec![1,2,3].into_boxed_slice().into_iter(); //~ WARN equivalent to .iter()\n+   |                                            ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the slice\n+  --> $DIR/into_iter_on_ref.rs:17:41\n+   |\n+17 |     let _ = std::rc::Rc::from(&[X][..]).into_iter(); //~ WARN equivalent to .iter()\n+   |                                         ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the slice\n+  --> $DIR/into_iter_on_ref.rs:18:44\n+   |\n+18 |     let _ = std::sync::Arc::from(&[X][..]).into_iter(); //~ WARN equivalent to .iter()\n+   |                                            ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the array\n+  --> $DIR/into_iter_on_ref.rs:20:30\n+   |\n+20 |     let _ = (&&&&&&&[1,2,3]).into_iter(); //~ ERROR equivalent to .iter()\n+   |                              ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the array\n+  --> $DIR/into_iter_on_ref.rs:21:34\n+   |\n+21 |     let _ = (&&&&mut &&&[1,2,3]).into_iter(); //~ ERROR equivalent to .iter()\n+   |                                  ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter_mut() and will not move the array\n+  --> $DIR/into_iter_on_ref.rs:22:38\n+   |\n+22 |     let _ = (&mut &mut &mut [1,2,3]).into_iter(); //~ ERROR equivalent to .iter_mut()\n+   |                                      ^^^^^^^^^ help: call directly: `iter_mut`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the Option\n+  --> $DIR/into_iter_on_ref.rs:24:24\n+   |\n+24 |     let _ = (&Some(4)).into_iter(); //~ WARN equivalent to .iter()\n+   |                        ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter_mut() and will not move the Option\n+  --> $DIR/into_iter_on_ref.rs:25:28\n+   |\n+25 |     let _ = (&mut Some(5)).into_iter(); //~ WARN equivalent to .iter_mut()\n+   |                            ^^^^^^^^^ help: call directly: `iter_mut`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the Result\n+  --> $DIR/into_iter_on_ref.rs:26:32\n+   |\n+26 |     let _ = (&Ok::<_, i32>(6)).into_iter(); //~ WARN equivalent to .iter()\n+   |                                ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter_mut() and will not move the Result\n+  --> $DIR/into_iter_on_ref.rs:27:37\n+   |\n+27 |     let _ = (&mut Err::<i32, _>(7)).into_iter(); //~ WARN equivalent to .iter_mut()\n+   |                                     ^^^^^^^^^ help: call directly: `iter_mut`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the Vec\n+  --> $DIR/into_iter_on_ref.rs:28:34\n+   |\n+28 |     let _ = (&Vec::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n+   |                                  ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter_mut() and will not move the Vec\n+  --> $DIR/into_iter_on_ref.rs:29:38\n+   |\n+29 |     let _ = (&mut Vec::<i32>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n+   |                                      ^^^^^^^^^ help: call directly: `iter_mut`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the BTreeMap\n+  --> $DIR/into_iter_on_ref.rs:30:44\n+   |\n+30 |     let _ = (&BTreeMap::<i32, u64>::new()).into_iter(); //~ WARN equivalent to .iter()\n+   |                                            ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter_mut() and will not move the BTreeMap\n+  --> $DIR/into_iter_on_ref.rs:31:48\n+   |\n+31 |     let _ = (&mut BTreeMap::<i32, u64>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n+   |                                                ^^^^^^^^^ help: call directly: `iter_mut`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the VecDeque\n+  --> $DIR/into_iter_on_ref.rs:32:39\n+   |\n+32 |     let _ = (&VecDeque::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n+   |                                       ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter_mut() and will not move the VecDeque\n+  --> $DIR/into_iter_on_ref.rs:33:43\n+   |\n+33 |     let _ = (&mut VecDeque::<i32>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n+   |                                           ^^^^^^^^^ help: call directly: `iter_mut`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the LinkedList\n+  --> $DIR/into_iter_on_ref.rs:34:41\n+   |\n+34 |     let _ = (&LinkedList::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n+   |                                         ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter_mut() and will not move the LinkedList\n+  --> $DIR/into_iter_on_ref.rs:35:45\n+   |\n+35 |     let _ = (&mut LinkedList::<i32>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n+   |                                             ^^^^^^^^^ help: call directly: `iter_mut`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the HashMap\n+  --> $DIR/into_iter_on_ref.rs:36:43\n+   |\n+36 |     let _ = (&HashMap::<i32, u64>::new()).into_iter(); //~ WARN equivalent to .iter()\n+   |                                           ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter_mut() and will not move the HashMap\n+  --> $DIR/into_iter_on_ref.rs:37:47\n+   |\n+37 |     let _ = (&mut HashMap::<i32, u64>::new()).into_iter(); //~ WARN equivalent to .iter_mut()\n+   |                                               ^^^^^^^^^ help: call directly: `iter_mut`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the BTreeSet\n+  --> $DIR/into_iter_on_ref.rs:39:39\n+   |\n+39 |     let _ = (&BTreeSet::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n+   |                                       ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the BinaryHeap\n+  --> $DIR/into_iter_on_ref.rs:40:41\n+   |\n+40 |     let _ = (&BinaryHeap::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n+   |                                         ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the HashSet\n+  --> $DIR/into_iter_on_ref.rs:41:38\n+   |\n+41 |     let _ = (&HashSet::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n+   |                                      ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the Path\n+  --> $DIR/into_iter_on_ref.rs:42:43\n+   |\n+42 |     let _ = std::path::Path::new(\"12/34\").into_iter(); //~ WARN equivalent to .iter()\n+   |                                           ^^^^^^^^^ help: call directly: `iter`\n+\n+error: this .into_iter() call is equivalent to .iter() and will not move the PathBuf\n+  --> $DIR/into_iter_on_ref.rs:43:47\n+   |\n+43 |     let _ = std::path::PathBuf::from(\"12/34\").into_iter(); //~ ERROR equivalent to .iter()\n+   |                                               ^^^^^^^^^ help: call directly: `iter`\n+\n+error: aborting due to 28 previous errors\n+"}]}