{"sha": "c2ae062e90105b4230981211f2979d3b093c3bcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYWUwNjJlOTAxMDViNDIzMDk4MTIxMWYyOTc5ZDNiMDkzYzNiY2I=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-21T14:52:44Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T05:29:17Z"}, "message": "std: adding tcp::write_future for non-block tcp writes, docs cleanup", "tree": {"sha": "c862d1c304e67535e54e29b102b8107461842da3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c862d1c304e67535e54e29b102b8107461842da3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2ae062e90105b4230981211f2979d3b093c3bcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ae062e90105b4230981211f2979d3b093c3bcb", "html_url": "https://github.com/rust-lang/rust/commit/c2ae062e90105b4230981211f2979d3b093c3bcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2ae062e90105b4230981211f2979d3b093c3bcb/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b1035904152ab5e12f08f5e5353c4af33368dcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b1035904152ab5e12f08f5e5353c4af33368dcd", "html_url": "https://github.com/rust-lang/rust/commit/9b1035904152ab5e12f08f5e5353c4af33368dcd"}], "stats": {"total": 96, "additions": 52, "deletions": 44}, "files": [{"sha": "f19919ceebf8bb4e3488cd56cf827d2691b6a16b", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 52, "deletions": 44, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c2ae062e90105b4230981211f2979d3b093c3bcb/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ae062e90105b4230981211f2979d3b093c3bcb/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=c2ae062e90105b4230981211f2979d3b093c3bcb", "patch": "@@ -6,11 +6,12 @@ import ip = net_ip;\n import comm::*;\n import result::*;\n import str::*;\n+import future::*;\n \n // data\n export tcp_socket, tcp_conn_port, tcp_err_data;\n // operations on a tcp_socket\n-export write, read_start, read_stop;\n+export write, write_future, read_start, read_stop;\n // tcp server stuff\n export listen_for_conn, accept;\n export new_listener, conn_recv, conn_recv_spawn, conn_peek;\n@@ -189,7 +190,7 @@ fn connect(input_ip: ip::ip_addr, port: uint)\n }\n \n #[doc=\"\n-Write binary data to a tcp stream\n+Write binary data to a tcp stream; Blocks until operatoin completes\n \n # Arguments\n \n@@ -199,55 +200,56 @@ This value must remain valid for the duration of the `write` call\n \n # Returns\n \n-A `result` object with a `()` value, in the event of success, or a\n-`tcp_err_data` value in the event of failure\n+A `result` object with a `nil` value as the `ok` variant, or a `tcp_err_data`\n+value as the `err` variant\n \"]\n-fn write(sock: tcp_socket, raw_write_data: [[u8]])\n+fn write(sock: tcp_socket, raw_write_data: [u8])\n     -> result::result<(), tcp_err_data> unsafe {\n     let socket_data_ptr = ptr::addr_of(**sock);\n-    let write_req_ptr = ptr::addr_of((*socket_data_ptr).write_req);\n-    let stream_handle_ptr =\n-        (*socket_data_ptr).stream_handle_ptr;\n-    let write_buf_vec = iter::map_to_vec(raw_write_data) {|raw_bytes|\n-        uv::ll::buf_init(vec::unsafe::to_ptr(raw_bytes),\n-                         vec::len(raw_bytes))\n-    };\n-    let write_buf_vec_ptr = ptr::addr_of(write_buf_vec);\n-    let result_po = comm::port::<tcp_write_result>();\n-    let write_data = {\n-        result_ch: comm::chan(result_po)\n-    };\n-    let write_data_ptr = ptr::addr_of(write_data);\n-    uv::hl::interact((*socket_data_ptr).hl_loop) {|loop_ptr|\n-        log(debug, #fmt(\"in interact cb for tcp::write %?\", loop_ptr));\n-        alt uv::ll::write(write_req_ptr,\n-                          stream_handle_ptr,\n-                          write_buf_vec_ptr,\n-                          tcp_write_complete_cb) {\n-          0i32 {\n-            log(debug, \"uv_write() invoked successfully\");\n-            uv::ll::set_data_for_req(write_req_ptr, write_data_ptr);\n-          }\n-          _ {\n-            log(debug, \"error invoking uv_write()\");\n-            let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            comm::send((*write_data_ptr).result_ch,\n-                       tcp_write_error(err_data.to_tcp_err()));\n-          }\n-        }\n-    };\n-    alt comm::recv(result_po) {\n-      tcp_write_success { result::ok(()) }\n-      tcp_write_error(err_data) { result::err(err_data.to_tcp_err()) }\n+    write_common_impl(socket_data_ptr, raw_write_data)\n+}\n+\n+#[doc=\"\n+Write binary data to tcp stream; Returns a `future::future` value immediately\n+\n+# Safety\n+\n+This function can produce unsafe results if the call to `write_future` is\n+made, the `future::future` value returned is never resolved via\n+`future::get`, and then the `tcp_socket` passed in to `write_future` leaves\n+scope and is destructured before the task that runs the libuv write\n+operation completes.\n+\n+As such: If using `write_future`, always be sure to resolve the returned\n+`future` so as to ensure libuv doesn't try to access a released write handle.\n+Otherwise, use the blocking `tcp::write` function instead.\n+\n+# Arguments\n+\n+* sock - a `tcp_socket` to write to\n+* raw_write_data - a vector of `[u8]` that will be written to the stream.\n+This value must remain valid for the duration of the `write` call\n+\n+# Returns\n+\n+A `future` value that, once the `write` operation completes, resolves to a\n+`result` object with a `nil` value as the `ok` variant, or a `tcp_err_data`\n+value as the `err` variant\n+\"]\n+fn write_future(sock: tcp_socket, raw_write_data: [u8])\n+    -> future::future<result::result<(), tcp_err_data>> unsafe {\n+    let socket_data_ptr = ptr::addr_of(**sock);\n+    future::spawn {||\n+        write_common_impl(socket_data_ptr, raw_write_data)\n     }\n }\n \n #[doc=\"\n-Begin reading binary data from an open TCP connection.\n+Begin reading binary data from an open TCP connection; used with `read_stop`\n \n # Arguments\n \n-* sock -- a `tcp_socket` for the connection to read from\n+* sock -- a `net::tcp::tcp_socket` for the connection to read from\n \n # Returns\n \n@@ -290,7 +292,11 @@ fn read_start(sock: tcp_socket)\n }\n \n #[doc=\"\n-Stop reading from an open TCP connection.\n+Stop reading from an open TCP connection; used with `read_start`\n+\n+# Arguments\n+\n+* `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n \"]\n fn read_stop(sock: tcp_socket) ->\n     result::result<(), tcp_err_data> unsafe {\n@@ -482,11 +488,13 @@ This function behaves similarly to `comm::peek()`\n \n # Arguments\n \n-* `server_port` -- a `net::tcp::tcp_conn_port` representing a server connection\n+* `server_port` -- a `net::tcp::tcp_conn_port` representing a server\n+connection\n \n # Returns\n \n-`true` if there are one-or-more pending connections, `false` if there are none.\n+`true` if there are one-or-more pending connections, `false` if there are\n+none.\n \"]\n fn conn_peek(server_port: tcp_conn_port) -> bool {\n     let new_conn_po = (**server_port).new_conn_po;"}]}