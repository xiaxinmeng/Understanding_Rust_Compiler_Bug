{"sha": "268e739c94d2e9edbb45374dfcc252b1648d3181", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2OGU3MzljOTRkMmU5ZWRiYjQ1Mzc0ZGZjYzI1MmIxNjQ4ZDMxODE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-22T10:01:33Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-22T10:01:33Z"}, "message": "move add_missing_members to structured editing API\n\nCurrently, this is more code, and we also loose auto-indenting of\nbodies, but, long-term, this is the right approach", "tree": {"sha": "25820553d53e8a638003e315076c6c074464fd9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25820553d53e8a638003e315076c6c074464fd9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/268e739c94d2e9edbb45374dfcc252b1648d3181", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/268e739c94d2e9edbb45374dfcc252b1648d3181", "html_url": "https://github.com/rust-lang/rust/commit/268e739c94d2e9edbb45374dfcc252b1648d3181", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/268e739c94d2e9edbb45374dfcc252b1648d3181/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b811922a530b7b22469b386a521946f1003911c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b811922a530b7b22469b386a521946f1003911c7", "html_url": "https://github.com/rust-lang/rust/commit/b811922a530b7b22469b386a521946f1003911c7"}], "stats": {"total": 377, "additions": 231, "deletions": 146}, "files": [{"sha": "17c2af89987d55aa5cb11f06ce76d52f34183554", "filename": "crates/ra_assists/src/add_missing_impl_members.rs", "status": "modified", "additions": 38, "deletions": 111, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/268e739c94d2e9edbb45374dfcc252b1648d3181/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268e739c94d2e9edbb45374dfcc252b1648d3181/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs?ref=268e739c94d2e9edbb45374dfcc252b1648d3181", "patch": "@@ -1,14 +1,9 @@\n-use std::fmt::Write;\n-\n-use crate::{Assist, AssistId, AssistCtx};\n+use crate::{Assist, AssistId, AssistCtx, ast_editor::{AstEditor, AstBuilder}};\n \n use hir::db::HirDatabase;\n-use ra_syntax::{SmolStr, SyntaxKind, TextRange, TextUnit, TreeArc};\n-use ra_syntax::ast::{self, AstNode, AstToken, FnDef, ImplItem, ImplItemKind, NameOwner};\n+use ra_syntax::{SmolStr, TreeArc};\n+use ra_syntax::ast::{self, AstNode, FnDef, ImplItem, ImplItemKind, NameOwner};\n use ra_db::FilePosition;\n-use ra_fmt::{leading_indent, reindent};\n-\n-use itertools::Itertools;\n \n enum AddMissingImplMembersMode {\n     DefaultMethodsOnly,\n@@ -76,48 +71,35 @@ fn add_missing_impl_members_inner(\n     }\n \n     ctx.add_action(AssistId(assist_id), label, |edit| {\n-        let (parent_indent, indent) = {\n-            // FIXME: Find a way to get the indent already used in the file.\n-            // Now, we copy the indent of first item or indent with 4 spaces relative to impl block\n-            const DEFAULT_INDENT: &str = \"    \";\n-            let first_item = impl_item_list.impl_items().next();\n-            let first_item_indent =\n-                first_item.and_then(|i| leading_indent(i.syntax())).map(ToOwned::to_owned);\n-            let impl_block_indent = leading_indent(impl_node.syntax()).unwrap_or_default();\n-\n-            (\n-                impl_block_indent.to_owned(),\n-                first_item_indent.unwrap_or_else(|| impl_block_indent.to_owned() + DEFAULT_INDENT),\n-            )\n-        };\n-\n-        let changed_range = {\n-            let children = impl_item_list.syntax().children_with_tokens();\n-            let last_whitespace =\n-                children.filter_map(|it| ast::Whitespace::cast(it.as_token()?)).last();\n-\n-            last_whitespace.map(|w| w.syntax().range()).unwrap_or_else(|| {\n-                let in_brackets = impl_item_list.syntax().range().end() - TextUnit::of_str(\"}\");\n-                TextRange::from_to(in_brackets, in_brackets)\n-            })\n-        };\n-\n-        let func_bodies = format!(\"\\n{}\", missing_fns.into_iter().map(build_func_body).join(\"\\n\"));\n-        let trailing_whitespace = format!(\"\\n{}\", parent_indent);\n-        let func_bodies = reindent(&func_bodies, &indent) + &trailing_whitespace;\n-\n-        let replaced_text_range = TextUnit::of_str(&func_bodies);\n-\n-        edit.replace(changed_range, func_bodies);\n-        // FIXME: place the cursor on the first unimplemented?\n-        edit.set_cursor(\n-            changed_range.start() + replaced_text_range - TextUnit::of_str(&trailing_whitespace),\n-        );\n+        let n_existing_items = impl_item_list.impl_items().count();\n+        let fns = missing_fns.into_iter().map(add_body_and_strip_docstring).collect::<Vec<_>>();\n+\n+        let mut ast_editor = AstEditor::new(impl_item_list);\n+        if n_existing_items == 0 {\n+            ast_editor.make_multiline();\n+        }\n+        ast_editor.append_functions(fns.iter().map(|it| &**it));\n+        let first_new_item = ast_editor.ast().impl_items().nth(n_existing_items).unwrap();\n+        let cursor_poisition = first_new_item.syntax().range().start();\n+        ast_editor.into_text_edit(edit.text_edit_builder());\n+\n+        edit.set_cursor(cursor_poisition);\n     });\n \n     ctx.build()\n }\n \n+fn add_body_and_strip_docstring(fn_def: &ast::FnDef) -> TreeArc<ast::FnDef> {\n+    let mut ast_editor = AstEditor::new(fn_def);\n+    if fn_def.body().is_none() {\n+        ast_editor.set_body(&AstBuilder::<ast::Block>::single_expr(\n+            &AstBuilder::<ast::Expr>::unimplemented(),\n+        ));\n+    }\n+    ast_editor.strip_attrs_and_docs();\n+    ast_editor.ast().to_owned()\n+}\n+\n /// Given an `ast::ImplBlock`, resolves the target trait (the one being\n /// implemented) to a `ast::TraitDef`.\n fn resolve_target_trait_def(\n@@ -134,22 +116,6 @@ fn resolve_target_trait_def(\n     }\n }\n \n-fn build_func_body(def: &ast::FnDef) -> String {\n-    let mut buf = String::new();\n-\n-    for child in def.syntax().children_with_tokens() {\n-        match (child.prev_sibling_or_token().map(|c| c.kind()), child.kind()) {\n-            (_, SyntaxKind::SEMI) => buf.push_str(\" {\\n    unimplemented!()\\n}\"),\n-            (_, SyntaxKind::ATTR) | (_, SyntaxKind::COMMENT) => {}\n-            (Some(SyntaxKind::ATTR), SyntaxKind::WHITESPACE)\n-            | (Some(SyntaxKind::COMMENT), SyntaxKind::WHITESPACE) => {}\n-            _ => write!(buf, \"{}\", child).unwrap(),\n-        };\n-    }\n-\n-    buf.trim_end().to_string()\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -170,7 +136,7 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n-    <|>\n+<|>\n }\",\n             \"\n trait Foo {\n@@ -183,12 +149,9 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n-    fn foo(&self) {\n-        unimplemented!()\n-    }\n-    fn baz(&self) {\n-        unimplemented!()\n-    }<|>\n+    <|>fn foo(&self) { unimplemented!() }\n+    fn baz(&self) { unimplemented!() }\n+\n }\",\n         );\n     }\n@@ -208,7 +171,7 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n-    <|>\n+<|>\n }\",\n             \"\n trait Foo {\n@@ -221,9 +184,8 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n-    fn foo(&self) {\n-        unimplemented!()\n-    }<|>\n+    <|>fn foo(&self) { unimplemented!() }\n+\n }\",\n         );\n     }\n@@ -240,9 +202,7 @@ impl Foo for S { <|> }\",\n trait Foo { fn foo(&self); }\n struct S;\n impl Foo for S {\n-    fn foo(&self) {\n-        unimplemented!()\n-    }<|>\n+    <|>fn foo(&self) { unimplemented!() }\n }\",\n         );\n     }\n@@ -259,9 +219,7 @@ impl Foo for S {}<|>\",\n trait Foo { fn foo(&self); }\n struct S;\n impl Foo for S {\n-    fn foo(&self) {\n-        unimplemented!()\n-    }<|>\n+    <|>fn foo(&self) { unimplemented!() }\n }\",\n         )\n     }\n@@ -291,35 +249,6 @@ impl Foo for S { <|> }\",\n         )\n     }\n \n-    #[test]\n-    fn test_indented_impl_block() {\n-        check_assist(\n-            add_missing_impl_members,\n-            \"\n-trait Foo {\n-    fn valid(some: u32) -> bool;\n-}\n-struct S;\n-\n-mod my_mod {\n-    impl crate::Foo for S { <|> }\n-}\",\n-            \"\n-trait Foo {\n-    fn valid(some: u32) -> bool;\n-}\n-struct S;\n-\n-mod my_mod {\n-    impl crate::Foo for S {\n-        fn valid(some: u32) -> bool {\n-            unimplemented!()\n-        }<|>\n-    }\n-}\",\n-        )\n-    }\n-\n     #[test]\n     fn test_with_docstring_and_attrs() {\n         check_assist(\n@@ -342,9 +271,7 @@ trait Foo {\n }\n struct S;\n impl Foo for S {\n-    fn foo(&self) {\n-        unimplemented!()\n-    }<|>\n+    <|>fn foo(&self) { unimplemented!() }\n }\"#,\n         )\n     }\n@@ -367,7 +294,7 @@ trait Foo {\n }\n struct S;\n impl Foo for S {\n-    fn valid(some: u32) -> bool { false }<|>\n+    <|>fn valid(some: u32) -> bool { false }\n }\",\n         )\n     }"}, {"sha": "283b280b6ab9c62b773d0313579d365aa87f2b6f", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "modified", "additions": 140, "deletions": 18, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/268e739c94d2e9edbb45374dfcc252b1648d3181/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268e739c94d2e9edbb45374dfcc252b1648d3181/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=268e739c94d2e9edbb45374dfcc252b1648d3181", "patch": "@@ -1,4 +1,4 @@\n-use std::iter;\n+use std::{iter, ops::RangeInclusive};\n \n use arrayvec::ArrayVec;\n use ra_text_edit::TextEditBuilder;\n@@ -26,6 +26,7 @@ impl<N: AstNode> AstEditor<N> {\n         &*self.ast\n     }\n \n+    #[must_use]\n     fn insert_children<'a>(\n         &self,\n         position: InsertPosition<SyntaxElement<'_>>,\n@@ -34,31 +35,55 @@ impl<N: AstNode> AstEditor<N> {\n         let new_syntax = self.ast().syntax().insert_children(position, to_insert);\n         N::cast(&new_syntax).unwrap().to_owned()\n     }\n-}\n \n-impl AstEditor<ast::NamedFieldList> {\n-    pub fn append_field(&mut self, field: &ast::NamedField) {\n-        self.insert_field(InsertPosition::Last, field)\n+    #[must_use]\n+    fn replace_children<'a>(\n+        &self,\n+        to_delete: RangeInclusive<SyntaxElement<'_>>,\n+        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n+    ) -> TreeArc<N> {\n+        let new_syntax = self.ast().syntax().replace_children(to_delete, to_insert);\n+        N::cast(&new_syntax).unwrap().to_owned()\n     }\n \n-    pub fn make_multiline(&mut self) {\n-        let l_curly = match self.l_curly() {\n-            Some(it) => it,\n-            None => return,\n-        };\n+    fn do_make_multiline(&mut self) {\n+        let l_curly =\n+            match self.ast().syntax().children_with_tokens().find(|it| it.kind() == L_CURLY) {\n+                Some(it) => it,\n+                None => return,\n+            };\n         let sibling = match l_curly.next_sibling_or_token() {\n             Some(it) => it,\n             None => return,\n         };\n-        if sibling.as_token().map(|it| it.text().contains('\\n')) == Some(true) {\n-            return;\n-        }\n+        let existing_ws = match sibling.as_token() {\n+            None => None,\n+            Some(tok) if tok.kind() != WHITESPACE => None,\n+            Some(ws) => {\n+                if ws.text().contains('\\n') {\n+                    return;\n+                }\n+                Some(ws)\n+            }\n+        };\n+\n+        let indent = leading_indent(self.ast().syntax()).unwrap_or(\"\");\n+        let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n+        let to_insert = iter::once(ws.ws().into());\n+        self.ast = match existing_ws {\n+            None => self.insert_children(InsertPosition::After(l_curly), to_insert),\n+            Some(ws) => self.replace_children(RangeInclusive::new(ws.into(), ws.into()), to_insert),\n+        };\n+    }\n+}\n+\n+impl AstEditor<ast::NamedFieldList> {\n+    pub fn append_field(&mut self, field: &ast::NamedField) {\n+        self.insert_field(InsertPosition::Last, field)\n+    }\n \n-        let ws = tokens::WsBuilder::new(&format!(\n-            \"\\n{}\",\n-            leading_indent(self.ast().syntax()).unwrap_or(\"\")\n-        ));\n-        self.ast = self.insert_children(InsertPosition::After(l_curly), iter::once(ws.ws().into()));\n+    pub fn make_multiline(&mut self) {\n+        self.do_make_multiline()\n     }\n \n     pub fn insert_field(\n@@ -132,6 +157,79 @@ impl AstEditor<ast::NamedFieldList> {\n     }\n }\n \n+impl AstEditor<ast::ItemList> {\n+    pub fn make_multiline(&mut self) {\n+        self.do_make_multiline()\n+    }\n+\n+    pub fn append_functions<'a>(&mut self, fns: impl Iterator<Item = &'a ast::FnDef>) {\n+        fns.for_each(|it| self.append_function(it))\n+    }\n+\n+    pub fn append_function(&mut self, fn_def: &ast::FnDef) {\n+        let (indent, position) = match self.ast().impl_items().last() {\n+            Some(it) => (\n+                leading_indent(it.syntax()).unwrap_or(\"\").to_string(),\n+                InsertPosition::After(it.syntax().into()),\n+            ),\n+            None => match self.l_curly() {\n+                Some(it) => (\n+                    \"    \".to_string() + leading_indent(self.ast().syntax()).unwrap_or(\"\"),\n+                    InsertPosition::After(it),\n+                ),\n+                None => return,\n+            },\n+        };\n+        let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n+        let to_insert: ArrayVec<[SyntaxElement; 2]> =\n+            [ws.ws().into(), fn_def.syntax().into()].into();\n+        self.ast = self.insert_children(position, to_insert.into_iter());\n+    }\n+\n+    fn l_curly(&self) -> Option<SyntaxElement> {\n+        self.ast().syntax().children_with_tokens().find(|it| it.kind() == L_CURLY)\n+    }\n+}\n+\n+impl AstEditor<ast::FnDef> {\n+    pub fn set_body(&mut self, body: &ast::Block) {\n+        let mut to_insert: ArrayVec<[SyntaxElement; 2]> = ArrayVec::new();\n+        let old_body_or_semi: SyntaxElement = if let Some(old_body) = self.ast().body() {\n+            old_body.syntax().into()\n+        } else if let Some(semi) = self.ast().semicolon_token() {\n+            to_insert.push(tokens::single_space().into());\n+            semi.into()\n+        } else {\n+            to_insert.push(tokens::single_space().into());\n+            to_insert.push(body.syntax().into());\n+            self.ast = self.insert_children(InsertPosition::Last, to_insert.into_iter());\n+            return;\n+        };\n+        to_insert.push(body.syntax().into());\n+        let replace_range = RangeInclusive::new(old_body_or_semi, old_body_or_semi);\n+        self.ast = self.replace_children(replace_range, to_insert.into_iter())\n+    }\n+\n+    pub fn strip_attrs_and_docs(&mut self) {\n+        loop {\n+            if let Some(start) = self\n+                .ast()\n+                .syntax()\n+                .children_with_tokens()\n+                .find(|it| it.kind() == ATTR || it.kind() == COMMENT)\n+            {\n+                let end = match start.next_sibling_or_token() {\n+                    Some(el) if el.kind() == WHITESPACE => el,\n+                    Some(_) | None => start,\n+                };\n+                self.ast = self.replace_children(RangeInclusive::new(start, end), iter::empty());\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n pub struct AstBuilder<N: AstNode> {\n     _phantom: std::marker::PhantomData<N>,\n }\n@@ -149,6 +247,16 @@ impl AstBuilder<ast::NamedField> {\n     }\n }\n \n+impl AstBuilder<ast::Block> {\n+    fn from_text(text: &str) -> TreeArc<ast::Block> {\n+        ast_node_from_file_text(&format!(\"fn f() {}\", text))\n+    }\n+\n+    pub fn single_expr(e: &ast::Expr) -> TreeArc<ast::Block> {\n+        Self::from_text(&format!(\"{{ {} }}\", e.syntax()))\n+    }\n+}\n+\n impl AstBuilder<ast::Expr> {\n     fn from_text(text: &str) -> TreeArc<ast::Expr> {\n         ast_node_from_file_text(&format!(\"fn f() {{ {}; }}\", text))\n@@ -157,6 +265,10 @@ impl AstBuilder<ast::Expr> {\n     pub fn unit() -> TreeArc<ast::Expr> {\n         Self::from_text(\"()\")\n     }\n+\n+    pub fn unimplemented() -> TreeArc<ast::Expr> {\n+        Self::from_text(\"unimplemented!()\")\n+    }\n }\n \n impl AstBuilder<ast::NameRef> {\n@@ -197,6 +309,16 @@ mod tokens {\n             .unwrap()\n     }\n \n+    #[allow(unused)]\n+    pub(crate) fn single_newline() -> SyntaxToken<'static> {\n+        SOURCE_FILE\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.as_token())\n+            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \"\\n\")\n+            .unwrap()\n+    }\n+\n     pub(crate) struct WsBuilder(TreeArc<SourceFile>);\n \n     impl WsBuilder {"}, {"sha": "9cbd2c6b8132e60977195d9e4023aaeb4a81d8b7", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/268e739c94d2e9edbb45374dfcc252b1648d3181/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268e739c94d2e9edbb45374dfcc252b1648d3181/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=268e739c94d2e9edbb45374dfcc252b1648d3181", "patch": "@@ -210,6 +210,15 @@ impl ast::EnumVariant {\n     }\n }\n \n+impl ast::FnDef {\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken<'_>> {\n+        self.syntax()\n+            .last_child_or_token()\n+            .and_then(|it| it.as_token())\n+            .filter(|it| it.kind() == SEMI)\n+    }\n+}\n+\n impl ast::LetStmt {\n     pub fn has_semi(&self) -> bool {\n         match self.syntax().last_child_or_token() {"}, {"sha": "92c15234e650a81b6b4c579508a6e469299e3655", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/268e739c94d2e9edbb45374dfcc252b1648d3181/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268e739c94d2e9edbb45374dfcc252b1648d3181/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=268e739c94d2e9edbb45374dfcc252b1648d3181", "patch": "@@ -7,6 +7,7 @@\n //! modules just wraps its API.\n \n use std::{\n+    ops::RangeInclusive,\n     fmt::{self, Write},\n     any::Any,\n     borrow::Borrow,\n@@ -323,8 +324,6 @@ impl SyntaxNode {\n     ///\n     /// This is a type-unsafe low-level editing API, if you need to use it,\n     /// prefer to create a type-safe abstraction on top of it instead.\n-    ///\n-    ///\n     pub fn insert_children<'a>(\n         &self,\n         position: InsertPosition<SyntaxElement<'_>>,\n@@ -338,12 +337,6 @@ impl SyntaxNode {\n \n         let old_children = self.0.green().children();\n \n-        let get_anchor_pos = |anchor: SyntaxElement| -> usize {\n-            self.children_with_tokens()\n-                .position(|it| it == anchor)\n-                .expect(\"anchor is not a child of current element\")\n-        };\n-\n         let new_children = match position {\n             InsertPosition::First => {\n                 to_insert.chain(old_children.iter().cloned()).collect::<Box<[_]>>()\n@@ -353,7 +346,8 @@ impl SyntaxNode {\n             }\n             InsertPosition::Before(anchor) | InsertPosition::After(anchor) => {\n                 let take_anchor = if let InsertPosition::After(_) = position { 1 } else { 0 };\n-                let (before, after) = old_children.split_at(get_anchor_pos(anchor) + take_anchor);\n+                let split_at = self.position_of_child(anchor) + take_anchor;\n+                let (before, after) = old_children.split_at(split_at);\n                 before\n                     .iter()\n                     .cloned()\n@@ -363,23 +357,56 @@ impl SyntaxNode {\n             }\n         };\n \n+        self.with_children(new_children)\n+    }\n+\n+    /// Replaces all nodes in `to_delete` with nodes from `to_insert`\n+    ///\n+    /// This is a type-unsafe low-level editing API, if you need to use it,\n+    /// prefer to create a type-safe abstraction on top of it instead.\n+    pub fn replace_children<'a>(\n+        &self,\n+        to_delete: RangeInclusive<SyntaxElement<'_>>,\n+        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n+    ) -> TreeArc<SyntaxNode> {\n+        let start = self.position_of_child(*to_delete.start());\n+        let end = self.position_of_child(*to_delete.end());\n+        let old_children = self.0.green().children();\n+\n+        let new_children = old_children[..start]\n+            .iter()\n+            .cloned()\n+            .chain(to_insert.map(to_green_element))\n+            .chain(old_children[end + 1..].iter().cloned())\n+            .collect::<Box<[_]>>();\n+        self.with_children(new_children)\n+    }\n+\n+    fn with_children(&self, new_children: Box<[rowan::GreenElement]>) -> TreeArc<SyntaxNode> {\n+        let len = new_children.iter().map(|it| it.text_len()).sum::<TextUnit>();\n         let new_node = GreenNode::new(rowan::SyntaxKind(self.kind() as u16), new_children);\n         let new_file_node = self.replace_with(new_node);\n         let file = SourceFile::new(new_file_node, Vec::new());\n \n         // FIXME: use a more elegant way to re-fetch the node (#1185), make\n         // `range` private afterwards\n         let mut ptr = SyntaxNodePtr::new(self);\n-        ptr.range = TextRange::from_to(ptr.range().start(), ptr.range().end() + delta);\n+        ptr.range = TextRange::offset_len(ptr.range().start(), len);\n         return ptr.to_node(&file).to_owned();\n+    }\n \n-        fn to_green_element(element: SyntaxElement) -> rowan::GreenElement {\n-            match element {\n-                SyntaxElement::Node(node) => node.0.green().clone().into(),\n-                SyntaxElement::Token(tok) => {\n-                    GreenToken::new(rowan::SyntaxKind(tok.kind() as u16), tok.text().clone()).into()\n-                }\n-            }\n+    fn position_of_child(&self, child: SyntaxElement) -> usize {\n+        self.children_with_tokens()\n+            .position(|it| it == child)\n+            .expect(\"elemetn is not a child of current element\")\n+    }\n+}\n+\n+fn to_green_element(element: SyntaxElement) -> rowan::GreenElement {\n+    match element {\n+        SyntaxElement::Node(node) => node.0.green().clone().into(),\n+        SyntaxElement::Token(tok) => {\n+            GreenToken::new(rowan::SyntaxKind(tok.kind() as u16), tok.text().clone()).into()\n         }\n     }\n }"}]}