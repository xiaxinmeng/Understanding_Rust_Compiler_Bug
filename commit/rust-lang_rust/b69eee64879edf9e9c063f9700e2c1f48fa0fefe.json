{"sha": "b69eee64879edf9e9c063f9700e2c1f48fa0fefe", "node_id": "C_kwDOAAsO6NoAKGI2OWVlZTY0ODc5ZWRmOWU5YzA2M2Y5NzAwZTJjMWY0OGZhMGZlZmU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-22T14:29:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-22T14:29:24Z"}, "message": "Merge #10809\n\n10809: fix: don't discard formatting of `use` lines r=Veykril a=iDawer\n\nUse mutable syntax trees in `merge_imports`, `split_imports`. This tries to resolve #9013. But I haven't much managed to simplify code of merging.\r\n\r\nAlso resolve #9361. It reuses a use tree under the cursor so that comments+indentation are preserved. Merged trees are just appended to the end.\r\n\r\nThis touches bunch of tests. I removed the sorting of use trees as it needs a proper implementation that takes into account comments and line wrapping. I think it is rustfmt's job or at least until we get a close implementation.\n\nCo-authored-by: iDawer <ilnur.iskhakov.oss@outlook.com>", "tree": {"sha": "873dc05be06b1cf08e10f4138a07c8ff9ef1e609", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/873dc05be06b1cf08e10f4138a07c8ff9ef1e609"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b69eee64879edf9e9c063f9700e2c1f48fa0fefe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhm6lECRBK7hj4Ov3rIwAAQFsIAGiherl6g+LeIqdqBmVsgrlt\nQJpMeYMJRjRVxZIcy1TrC5iboRV0bfeOQqJe9cByogUOnBDxMN/+EUj6EJGvVhhN\n6dpJzk4oqhtYITvG/eWrhQpYrKKd1tkzE2RDUXO/s3xN6uYhQCfyE2a8OSET5kJz\niJGvH/dahcUwEZdWakw7OrsH8iugFBX9DSrPY76ngRb+v2I6lYzMkh1bpvfzSPkD\nELpK98bXtCFJJ3SlUFcmWFX4LO6TdKFAMqhAAaBXW8XVIYLGbzohgTj+X20OYyr1\nQKG2fq5a+3ORJpznt4FOTet3DOaPE9peaglp8aFOf2xEeaQh1By3nqrPsgXgCNU=\n=9ZYV\n-----END PGP SIGNATURE-----\n", "payload": "tree 873dc05be06b1cf08e10f4138a07c8ff9ef1e609\nparent e8f15bd794de29056028ee40c0b8a23873535f8b\nparent 601413df8f938d70d24e28f33bbb6ff439230f79\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1637591364 +0000\ncommitter GitHub <noreply@github.com> 1637591364 +0000\n\nMerge #10809\n\n10809: fix: don't discard formatting of `use` lines r=Veykril a=iDawer\n\nUse mutable syntax trees in `merge_imports`, `split_imports`. This tries to resolve #9013. But I haven't much managed to simplify code of merging.\r\n\r\nAlso resolve #9361. It reuses a use tree under the cursor so that comments+indentation are preserved. Merged trees are just appended to the end.\r\n\r\nThis touches bunch of tests. I removed the sorting of use trees as it needs a proper implementation that takes into account comments and line wrapping. I think it is rustfmt's job or at least until we get a close implementation.\n\nCo-authored-by: iDawer <ilnur.iskhakov.oss@outlook.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b69eee64879edf9e9c063f9700e2c1f48fa0fefe", "html_url": "https://github.com/rust-lang/rust/commit/b69eee64879edf9e9c063f9700e2c1f48fa0fefe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8f15bd794de29056028ee40c0b8a23873535f8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f15bd794de29056028ee40c0b8a23873535f8b", "html_url": "https://github.com/rust-lang/rust/commit/e8f15bd794de29056028ee40c0b8a23873535f8b"}, {"sha": "601413df8f938d70d24e28f33bbb6ff439230f79", "url": "https://api.github.com/repos/rust-lang/rust/commits/601413df8f938d70d24e28f33bbb6ff439230f79", "html_url": "https://github.com/rust-lang/rust/commit/601413df8f938d70d24e28f33bbb6ff439230f79"}], "stats": {"total": 257, "additions": 144, "deletions": 113}, "files": [{"sha": "94400be7a5bddfc521c3e11a1a46e4846f3c236a", "filename": "crates/ide_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=b69eee64879edf9e9c063f9700e2c1f48fa0fefe", "patch": "@@ -80,7 +80,7 @@ use std::fmt$0::{Display, Debug};\n use std::fmt::{Display, Debug};\n \",\n             r\"\n-use std::fmt::{Debug, Display};\n+use std::fmt::{Display, Debug};\n \",\n         )\n     }\n@@ -108,7 +108,7 @@ use std::fmt::Debug;\n use std::fmt$0::Display;\n \",\n             r\"\n-use std::fmt::{Debug, Display};\n+use std::fmt::{Display, Debug};\n \",\n         );\n     }\n@@ -135,7 +135,7 @@ use std::fmt::{self, Display};\n use std::{fmt, $0fmt::Display};\n \",\n             r\"\n-use std::{fmt::{self, Display}};\n+use std::{fmt::{Display, self}};\n \",\n         );\n     }\n@@ -247,7 +247,7 @@ use std::{fmt::{Debug, Display}};\n use std::{fmt::Debug, fmt$0::Display};\n \",\n             r\"\n-use std::{fmt::{Debug, Display}};\n+use std::{fmt::{Display, Debug}};\n \",\n         );\n     }\n@@ -341,7 +341,9 @@ use foo::$0{\n };\n \",\n             r\"\n-use foo::{FooBar, bar::baz};\n+use foo::{\n+    FooBar, bar::baz,\n+};\n \",\n         )\n     }"}, {"sha": "6b196681cab0936d2e0491803fa111ad75e30df8", "filename": "crates/ide_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=b69eee64879edf9e9c063f9700e2c1f48fa0fefe", "patch": "@@ -299,7 +299,7 @@ fn main() {\n     \",\n             r\"\n mod std { pub mod fmt { pub trait Display {} } }\n-use std::fmt::{self, Display};\n+use std::fmt::{Display, self};\n \n fn main() {\n     fmt;"}, {"sha": "ac67874b31bdaf752caf01549d25a53b3c487cc5", "filename": "crates/ide_assists/src/handlers/split_import.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=b69eee64879edf9e9c063f9700e2c1f48fa0fefe", "patch": "@@ -19,14 +19,20 @@ pub(crate) fn split_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n     let use_tree = path.top_path().syntax().ancestors().find_map(ast::UseTree::cast)?;\n \n-    let new_tree = use_tree.split_prefix(&path);\n-    if new_tree == use_tree {\n+    let has_errors = use_tree\n+        .syntax()\n+        .descendants_with_tokens()\n+        .any(|it| it.kind() == syntax::SyntaxKind::ERROR);\n+    let last_segment = use_tree.path().and_then(|it| it.segment());\n+    if has_errors || last_segment.is_none() {\n         return None;\n     }\n \n     let target = colon_colon.text_range();\n     acc.add(AssistId(\"split_import\", AssistKind::RefactorRewrite), \"Split import\", target, |edit| {\n-        edit.replace_ast(use_tree, new_tree);\n+        let use_tree = edit.make_mut(use_tree.clone());\n+        let path = edit.make_mut(path);\n+        use_tree.split_prefix(&path);\n     })\n }\n "}, {"sha": "a5763eb41ccbb69e135a5235d2965fd16e922a19", "filename": "crates/ide_db/src/helpers/insert_use/tests.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs?ref=b69eee64879edf9e9c063f9700e2c1f48fa0fefe", "patch": "@@ -463,15 +463,15 @@ fn merge_groups_full() {\n \n #[test]\n fn merge_groups_long_full() {\n-    check_crate(\"std::foo::bar::Baz\", r\"use std::foo::bar::Qux;\", r\"use std::foo::bar::{Baz, Qux};\")\n+    check_crate(\"std::foo::bar::Baz\", r\"use std::foo::bar::Qux;\", r\"use std::foo::bar::{Qux, Baz};\")\n }\n \n #[test]\n fn merge_groups_long_last() {\n     check_module(\n         \"std::foo::bar::Baz\",\n         r\"use std::foo::bar::Qux;\",\n-        r\"use std::foo::bar::{Baz, Qux};\",\n+        r\"use std::foo::bar::{Qux, Baz};\",\n     )\n }\n \n@@ -480,7 +480,7 @@ fn merge_groups_long_full_list() {\n     check_crate(\n         \"std::foo::bar::Baz\",\n         r\"use std::foo::bar::{Qux, Quux};\",\n-        r\"use std::foo::bar::{Baz, Quux, Qux};\",\n+        r\"use std::foo::bar::{Qux, Quux, Baz};\",\n     )\n }\n \n@@ -489,7 +489,7 @@ fn merge_groups_long_last_list() {\n     check_module(\n         \"std::foo::bar::Baz\",\n         r\"use std::foo::bar::{Qux, Quux};\",\n-        r\"use std::foo::bar::{Baz, Quux, Qux};\",\n+        r\"use std::foo::bar::{Qux, Quux, Baz};\",\n     )\n }\n \n@@ -498,7 +498,7 @@ fn merge_groups_long_full_nested() {\n     check_crate(\n         \"std::foo::bar::Baz\",\n         r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n-        r\"use std::foo::bar::{Baz, Qux, quux::{Fez, Fizz}};\",\n+        r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}, Baz};\",\n     )\n }\n \n@@ -517,7 +517,7 @@ fn merge_groups_full_nested_deep() {\n     check_crate(\n         \"std::foo::bar::quux::Baz\",\n         r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n-        r\"use std::foo::bar::{Qux, quux::{Baz, Fez, Fizz}};\",\n+        r\"use std::foo::bar::{Qux, quux::{Fez, Fizz, Baz}};\",\n     )\n }\n \n@@ -526,7 +526,7 @@ fn merge_groups_full_nested_long() {\n     check_crate(\n         \"std::foo::bar::Baz\",\n         r\"use std::{foo::bar::Qux};\",\n-        r\"use std::{foo::bar::{Baz, Qux}};\",\n+        r\"use std::{foo::bar::{Qux, Baz}};\",\n     );\n }\n \n@@ -535,7 +535,7 @@ fn merge_groups_last_nested_long() {\n     check_crate(\n         \"std::foo::bar::Baz\",\n         r\"use std::{foo::bar::Qux};\",\n-        r\"use std::{foo::bar::{Baz, Qux}};\",\n+        r\"use std::{foo::bar::{Qux, Baz}};\",\n     );\n }\n \n@@ -600,7 +600,7 @@ fn merge_mod_into_glob() {\n     check_with_config(\n         \"token::TokenKind\",\n         r\"use token::TokenKind::*;\",\n-        r\"use token::TokenKind::{*, self};\",\n+        r\"use token::TokenKind::{self, *};\",\n         &InsertUseConfig {\n             granularity: ImportGranularity::Crate,\n             enforce_granularity: true,\n@@ -618,7 +618,7 @@ fn merge_self_glob() {\n     check_with_config(\n         \"self\",\n         r\"use self::*;\",\n-        r\"use self::{*, self};\",\n+        r\"use self::{self, *};\",\n         &InsertUseConfig {\n             granularity: ImportGranularity::Crate,\n             enforce_granularity: true,\n@@ -637,7 +637,7 @@ fn merge_glob() {\n         r\"\n use syntax::{SyntaxKind::*};\",\n         r\"\n-use syntax::{SyntaxKind::{*, self}};\",\n+use syntax::{SyntaxKind::{self, *}};\",\n     )\n }\n "}, {"sha": "8581a83436135703198801ec26f8749869264b4a", "filename": "crates/ide_db/src/helpers/merge_imports.rs", "status": "modified", "additions": 42, "deletions": 53, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs?ref=b69eee64879edf9e9c063f9700e2c1f48fa0fefe", "patch": "@@ -44,10 +44,10 @@ pub fn try_merge_imports(\n     }\n \n     let lhs = lhs.clone_subtree().clone_for_update();\n+    let rhs = rhs.clone_subtree().clone_for_update();\n     let lhs_tree = lhs.use_tree()?;\n     let rhs_tree = rhs.use_tree()?;\n-    let merged = try_merge_trees(&lhs_tree, &rhs_tree, merge_behavior)?;\n-    ted::replace(lhs_tree.syntax(), merged.syntax());\n+    try_merge_trees_mut(&lhs_tree, &rhs_tree, merge_behavior)?;\n     Some(lhs)\n }\n \n@@ -56,57 +56,49 @@ pub fn try_merge_trees(\n     rhs: &ast::UseTree,\n     merge: MergeBehavior,\n ) -> Option<ast::UseTree> {\n+    let lhs = lhs.clone_subtree().clone_for_update();\n+    let rhs = rhs.clone_subtree().clone_for_update();\n+    try_merge_trees_mut(&lhs, &rhs, merge)?;\n+    Some(lhs)\n+}\n+\n+fn try_merge_trees_mut(lhs: &ast::UseTree, rhs: &ast::UseTree, merge: MergeBehavior) -> Option<()> {\n     let lhs_path = lhs.path()?;\n     let rhs_path = rhs.path()?;\n \n     let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n-    let (lhs, rhs) = if lhs.is_simple_path()\n+    if !(lhs.is_simple_path()\n         && rhs.is_simple_path()\n         && lhs_path == lhs_prefix\n-        && rhs_path == rhs_prefix\n+        && rhs_path == rhs_prefix)\n     {\n-        (lhs.clone(), rhs.clone())\n-    } else {\n-        (lhs.split_prefix(&lhs_prefix), rhs.split_prefix(&rhs_prefix))\n-    };\n-    recursive_merge(&lhs, &rhs, merge).map(|it| it.clone_for_update())\n+        lhs.split_prefix(&lhs_prefix);\n+        rhs.split_prefix(&rhs_prefix);\n+    }\n+    recursive_merge(&lhs, &rhs, merge)\n }\n \n-/// Recursively \"zips\" together lhs and rhs.\n-fn recursive_merge(\n-    lhs: &ast::UseTree,\n-    rhs: &ast::UseTree,\n-    merge: MergeBehavior,\n-) -> Option<ast::UseTree> {\n-    let mut use_trees = lhs\n+/// Recursively merges rhs to lhs\n+#[must_use]\n+fn recursive_merge(lhs: &ast::UseTree, rhs: &ast::UseTree, merge: MergeBehavior) -> Option<()> {\n+    let mut use_trees: Vec<ast::UseTree> = lhs\n         .use_tree_list()\n         .into_iter()\n         .flat_map(|list| list.use_trees())\n         // We use Option here to early return from this function(this is not the\n         // same as a `filter` op).\n-        .map(|tree| match merge.is_tree_allowed(&tree) {\n-            true => Some(tree),\n-            false => None,\n-        })\n-        .collect::<Option<Vec<_>>>()?;\n+        .map(|tree| merge.is_tree_allowed(&tree).then(|| tree))\n+        .collect::<Option<_>>()?;\n     use_trees.sort_unstable_by(|a, b| path_cmp_for_sort(a.path(), b.path()));\n     for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {\n         if !merge.is_tree_allowed(&rhs_t) {\n             return None;\n         }\n         let rhs_path = rhs_t.path();\n-        match use_trees.binary_search_by(|lhs_t| {\n-            let (lhs_t, rhs_t) = match lhs_t\n-                .path()\n-                .zip(rhs_path.clone())\n-                .and_then(|(lhs, rhs)| common_prefix(&lhs, &rhs))\n-            {\n-                Some((lhs_p, rhs_p)) => (lhs_t.split_prefix(&lhs_p), rhs_t.split_prefix(&rhs_p)),\n-                None => (lhs_t.clone(), rhs_t.clone()),\n-            };\n \n-            path_cmp_bin_search(lhs_t.path(), rhs_t.path())\n-        }) {\n+        match use_trees\n+            .binary_search_by(|lhs_t| path_cmp_bin_search(lhs_t.path(), rhs_path.as_ref()))\n+        {\n             Ok(idx) => {\n                 let lhs_t = &mut use_trees[idx];\n                 let lhs_path = lhs_t.path()?;\n@@ -128,6 +120,7 @@ fn recursive_merge(\n                     match (tree_contains_self(lhs_t), tree_contains_self(&rhs_t)) {\n                         (true, false) => continue,\n                         (false, true) => {\n+                            ted::replace(lhs_t.syntax(), rhs_t.syntax());\n                             *lhs_t = rhs_t;\n                             continue;\n                         }\n@@ -142,25 +135,27 @@ fn recursive_merge(\n                     if lhs_t.star_token().is_some() || rhs_t.star_token().is_some() {\n                         if tree_is_self(lhs_t) || tree_is_self(&rhs_t) {\n                             cov_mark::hit!(merge_self_glob);\n-                            *lhs_t = make::use_tree(\n+                            let self_tree = make::use_tree(\n                                 make::path_unqualified(make::path_segment_self()),\n                                 None,\n                                 None,\n                                 false,\n-                            );\n-                            use_trees.insert(idx, make::use_tree_glob());\n+                            )\n+                            .clone_for_update();\n+                            ted::replace(lhs_t.syntax(), self_tree.syntax());\n+                            *lhs_t = self_tree;\n+                            let glob = make::use_tree_glob().clone_for_update();\n+                            use_trees.insert(idx, glob.clone());\n+                            lhs.get_or_create_use_tree_list().add_use_tree(glob);\n                             continue;\n                         }\n                     } else if lhs_t.use_tree_list().is_none() && rhs_t.use_tree_list().is_none() {\n                         continue;\n                     }\n                 }\n-                let lhs = lhs_t.split_prefix(&lhs_prefix);\n-                let rhs = rhs_t.split_prefix(&rhs_prefix);\n-                match recursive_merge(&lhs, &rhs, merge) {\n-                    Some(use_tree) => use_trees[idx] = use_tree,\n-                    None => return None,\n-                }\n+                lhs_t.split_prefix(&lhs_prefix);\n+                rhs_t.split_prefix(&rhs_prefix);\n+                recursive_merge(&lhs_t, &rhs_t, merge)?;\n             }\n             Err(_)\n                 if merge == MergeBehavior::Module\n@@ -170,16 +165,12 @@ fn recursive_merge(\n                 return None\n             }\n             Err(idx) => {\n-                use_trees.insert(idx, rhs_t);\n+                use_trees.insert(idx, rhs_t.clone());\n+                lhs.get_or_create_use_tree_list().add_use_tree(rhs_t);\n             }\n         }\n     }\n-\n-    let lhs = lhs.clone_subtree().clone_for_update();\n-    if let Some(old) = lhs.use_tree_list() {\n-        ted::replace(old.syntax(), make::use_tree_list(use_trees).syntax().clone_for_update());\n-    }\n-    ast::UseTree::cast(lhs.syntax().clone_subtree())\n+    Some(())\n }\n \n /// Traverses both paths until they differ, returning the common prefix of both.\n@@ -224,11 +215,9 @@ fn path_cmp_for_sort(a: Option<ast::Path>, b: Option<ast::Path>) -> Ordering {\n }\n \n /// Path comparison func for binary searching for merging.\n-fn path_cmp_bin_search(lhs: Option<ast::Path>, rhs: Option<ast::Path>) -> Ordering {\n-    match (\n-        lhs.as_ref().and_then(ast::Path::first_segment),\n-        rhs.as_ref().and_then(ast::Path::first_segment),\n-    ) {\n+fn path_cmp_bin_search(lhs: Option<ast::Path>, rhs: Option<&ast::Path>) -> Ordering {\n+    match (lhs.as_ref().and_then(ast::Path::first_segment), rhs.and_then(ast::Path::first_segment))\n+    {\n         (None, None) => Ordering::Equal,\n         (None, Some(_)) => Ordering::Less,\n         (Some(_), None) => Ordering::Greater,"}, {"sha": "15805dfc8608feba4429576eee1bb3e3db28fc2c", "filename": "crates/syntax/src/ast/edit.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs?ref=b69eee64879edf9e9c063f9700e2c1f48fa0fefe", "patch": "@@ -4,48 +4,10 @@\n use std::{fmt, iter, ops};\n \n use crate::{\n-    algo,\n     ast::{self, make, AstNode},\n     ted, AstToken, NodeOrToken, SyntaxElement, SyntaxNode, SyntaxToken,\n };\n \n-impl ast::UseTree {\n-    /// Splits off the given prefix, making it the path component of the use tree, appending the rest of the path to all UseTreeList items.\n-    #[must_use]\n-    pub fn split_prefix(&self, prefix: &ast::Path) -> ast::UseTree {\n-        let suffix = if self.path().as_ref() == Some(prefix) && self.use_tree_list().is_none() {\n-            make::path_unqualified(make::path_segment_self())\n-        } else {\n-            match split_path_prefix(prefix) {\n-                Some(it) => it,\n-                None => return self.clone(),\n-            }\n-        };\n-\n-        let use_tree = make::use_tree(\n-            suffix,\n-            self.use_tree_list(),\n-            self.rename(),\n-            self.star_token().is_some(),\n-        );\n-        let nested = make::use_tree_list(iter::once(use_tree));\n-        return make::use_tree(prefix.clone(), Some(nested), None, false);\n-\n-        fn split_path_prefix(prefix: &ast::Path) -> Option<ast::Path> {\n-            let parent = prefix.parent_path()?;\n-            let segment = parent.segment()?;\n-            if algo::has_errors(segment.syntax()) {\n-                return None;\n-            }\n-            let mut res = make::path_unqualified(segment);\n-            for p in iter::successors(parent.parent_path(), |it| it.parent_path()) {\n-                res = make::path_qualified(res, p.segment()?);\n-            }\n-            Some(res)\n-        }\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy)]\n pub struct IndentLevel(pub u8);\n "}, {"sha": "bf4f9d6d18b71aa01f7c9e5a2ff5e0e0f0c3c0c5", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 74, "deletions": 2, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b69eee64879edf9e9c063f9700e2c1f48fa0fefe/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=b69eee64879edf9e9c063f9700e2c1f48fa0fefe", "patch": "@@ -1,12 +1,12 @@\n //! Structural editing for ast.\n \n-use std::iter::empty;\n+use std::iter::{empty, successors};\n \n use parser::{SyntaxKind, T};\n use rowan::SyntaxElement;\n \n use crate::{\n-    algo::neighbor,\n+    algo::{self, neighbor},\n     ast::{self, edit::IndentLevel, make, HasGenericParams},\n     ted::{self, Position},\n     AstNode, AstToken, Direction,\n@@ -282,6 +282,78 @@ impl ast::UseTree {\n         }\n         ted::remove(self.syntax());\n     }\n+\n+    pub fn get_or_create_use_tree_list(&self) -> ast::UseTreeList {\n+        match self.use_tree_list() {\n+            Some(it) => it,\n+            None => {\n+                let position = Position::last_child_of(self.syntax());\n+                let use_tree_list = make::use_tree_list(empty()).clone_for_update();\n+                let mut elements = Vec::with_capacity(2);\n+                if self.coloncolon_token().is_none() {\n+                    elements.push(make::token(T![::]).into());\n+                }\n+                elements.push(use_tree_list.syntax().clone().into());\n+                ted::insert_all_raw(position, elements);\n+                use_tree_list\n+            }\n+        }\n+    }\n+\n+    /// Splits off the given prefix, making it the path component of the use tree,\n+    /// appending the rest of the path to all UseTreeList items.\n+    pub fn split_prefix(&self, prefix: &ast::Path) {\n+        debug_assert_eq!(self.path(), Some(prefix.top_path()));\n+        let path = self.path().unwrap();\n+        if &path == prefix && self.use_tree_list().is_none() {\n+            let self_suffix = make::path_unqualified(make::path_segment_self()).clone_for_update();\n+            ted::replace(path.syntax(), self_suffix.syntax());\n+        } else if split_path_prefix(prefix).is_none() {\n+            return;\n+        }\n+\n+        let subtree = self.clone_subtree().clone_for_update();\n+        ted::remove_all_iter(self.syntax().children_with_tokens());\n+        ted::insert(Position::first_child_of(self.syntax()), prefix.syntax());\n+        self.get_or_create_use_tree_list().add_use_tree(subtree);\n+\n+        fn split_path_prefix(prefix: &ast::Path) -> Option<()> {\n+            let parent = prefix.parent_path()?;\n+            let segment = parent.segment()?;\n+            if algo::has_errors(segment.syntax()) {\n+                return None;\n+            }\n+            for p in successors(parent.parent_path(), |it| it.parent_path()) {\n+                p.segment()?;\n+            }\n+            prefix.parent_path().and_then(|p| p.coloncolon_token()).map(ted::remove);\n+            ted::remove(prefix.syntax());\n+            Some(())\n+        }\n+    }\n+}\n+\n+impl ast::UseTreeList {\n+    pub fn add_use_tree(&self, use_tree: ast::UseTree) {\n+        let (position, elements) = match self.use_trees().last() {\n+            Some(last_tree) => (\n+                Position::after(last_tree.syntax()),\n+                vec![\n+                    make::token(T![,]).into(),\n+                    make::tokens::single_space().into(),\n+                    use_tree.syntax.into(),\n+                ],\n+            ),\n+            None => {\n+                let position = match self.l_curly_token() {\n+                    Some(l_curly) => Position::after(l_curly),\n+                    None => Position::last_child_of(self.syntax()),\n+                };\n+                (position, vec![use_tree.syntax.into()])\n+            }\n+        };\n+        ted::insert_all_raw(position, elements);\n+    }\n }\n \n impl ast::Use {"}]}