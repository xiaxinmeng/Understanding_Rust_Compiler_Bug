{"sha": "f10f5a81b326d161d9ed1fba263de972b89de2bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMGY1YTgxYjMyNmQxNjFkOWVkMWZiYTI2M2RlOTcyYjg5ZGUyYmY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-03-21T21:20:03Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-03-21T21:20:03Z"}, "message": "TypeName => TypeCtor", "tree": {"sha": "f54d83e74161c51cf8525213bf221b83d276de85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f54d83e74161c51cf8525213bf221b83d276de85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f10f5a81b326d161d9ed1fba263de972b89de2bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f10f5a81b326d161d9ed1fba263de972b89de2bf", "html_url": "https://github.com/rust-lang/rust/commit/f10f5a81b326d161d9ed1fba263de972b89de2bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f10f5a81b326d161d9ed1fba263de972b89de2bf/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a5fbf471305894094726834f7701747fce9c961", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a5fbf471305894094726834f7701747fce9c961", "html_url": "https://github.com/rust-lang/rust/commit/8a5fbf471305894094726834f7701747fce9c961"}], "stats": {"total": 196, "additions": 98, "deletions": 98}, "files": [{"sha": "5926b5758bbc9d10709b895d83ac6a83b081cf36", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=f10f5a81b326d161d9ed1fba263de972b89de2bf", "patch": "@@ -53,7 +53,7 @@ pub use self::{\n     name::Name,\n     ids::{HirFileId, MacroCallId, MacroCallLoc, HirInterner},\n     nameres::{PerNs, Namespace},\n-    ty::{Ty, ApplicationTy, TypeName, Substs, display::HirDisplay},\n+    ty::{Ty, ApplicationTy, TypeCtor, Substs, display::HirDisplay},\n     impl_block::{ImplBlock, ImplItem},\n     docs::{Docs, Documentation},\n     adt::AdtDef,"}, {"sha": "1d9e7b76cf223155c7ca6432a21f10669c7599be", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=f10f5a81b326d161d9ed1fba263de972b89de2bf", "patch": "@@ -21,7 +21,7 @@ pub(crate) use infer::{infer, InferenceResult, InferTy};\n use display::{HirDisplay, HirFormatter};\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum TypeName {\n+pub enum TypeCtor {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n \n@@ -87,7 +87,7 @@ pub enum TypeName {\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct ApplicationTy {\n-    pub name: TypeName,\n+    pub name: TypeCtor,\n     pub parameters: Substs,\n }\n \n@@ -191,17 +191,17 @@ impl FnSig {\n }\n \n impl Ty {\n-    pub fn simple(name: TypeName) -> Ty {\n+    pub fn simple(name: TypeCtor) -> Ty {\n         Ty::Apply(ApplicationTy { name, parameters: Substs::empty() })\n     }\n-    pub fn apply_one(name: TypeName, param: Ty) -> Ty {\n+    pub fn apply_one(name: TypeCtor, param: Ty) -> Ty {\n         Ty::Apply(ApplicationTy { name, parameters: Substs::single(param) })\n     }\n-    pub fn apply(name: TypeName, parameters: Substs) -> Ty {\n+    pub fn apply(name: TypeCtor, parameters: Substs) -> Ty {\n         Ty::Apply(ApplicationTy { name, parameters })\n     }\n     pub fn unit() -> Self {\n-        Ty::apply(TypeName::Tuple, Substs::empty())\n+        Ty::apply(TypeCtor::Tuple, Substs::empty())\n     }\n \n     pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n@@ -236,7 +236,7 @@ impl Ty {\n \n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n         match self {\n-            Ty::Apply(ApplicationTy { name: TypeName::Ref(mutability), parameters }) => {\n+            Ty::Apply(ApplicationTy { name: TypeCtor::Ref(mutability), parameters }) => {\n                 Some((parameters.as_single(), *mutability))\n             }\n             _ => None,\n@@ -245,7 +245,7 @@ impl Ty {\n \n     pub fn as_adt(&self) -> Option<(AdtDef, &Substs)> {\n         match self {\n-            Ty::Apply(ApplicationTy { name: TypeName::Adt(adt_def), parameters }) => {\n+            Ty::Apply(ApplicationTy { name: TypeCtor::Adt(adt_def), parameters }) => {\n                 Some((*adt_def, parameters))\n             }\n             _ => None,\n@@ -254,16 +254,16 @@ impl Ty {\n \n     pub fn as_tuple(&self) -> Option<&Substs> {\n         match self {\n-            Ty::Apply(ApplicationTy { name: TypeName::Tuple, parameters }) => Some(parameters),\n+            Ty::Apply(ApplicationTy { name: TypeCtor::Tuple, parameters }) => Some(parameters),\n             _ => None,\n         }\n     }\n \n     fn builtin_deref(&self) -> Option<Ty> {\n         match self {\n             Ty::Apply(a_ty) => match a_ty.name {\n-                TypeName::Ref(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n-                TypeName::RawPtr(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n+                TypeCtor::Ref(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n+                TypeCtor::RawPtr(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n                 _ => None,\n             },\n             _ => None,\n@@ -318,25 +318,25 @@ impl HirDisplay for &Ty {\n impl HirDisplay for ApplicationTy {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n         match self.name {\n-            TypeName::Bool => write!(f, \"bool\")?,\n-            TypeName::Char => write!(f, \"char\")?,\n-            TypeName::Int(t) => write!(f, \"{}\", t)?,\n-            TypeName::Float(t) => write!(f, \"{}\", t)?,\n-            TypeName::Str => write!(f, \"str\")?,\n-            TypeName::Slice | TypeName::Array => {\n+            TypeCtor::Bool => write!(f, \"bool\")?,\n+            TypeCtor::Char => write!(f, \"char\")?,\n+            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Str => write!(f, \"str\")?,\n+            TypeCtor::Slice | TypeCtor::Array => {\n                 let t = self.parameters.as_single();\n                 write!(f, \"[{}]\", t.display(f.db))?;\n             }\n-            TypeName::RawPtr(m) => {\n+            TypeCtor::RawPtr(m) => {\n                 let t = self.parameters.as_single();\n                 write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;\n             }\n-            TypeName::Ref(m) => {\n+            TypeCtor::Ref(m) => {\n                 let t = self.parameters.as_single();\n                 write!(f, \"&{}{}\", m.as_keyword_for_ref(), t.display(f.db))?;\n             }\n-            TypeName::Never => write!(f, \"!\")?,\n-            TypeName::Tuple => {\n+            TypeCtor::Never => write!(f, \"!\")?,\n+            TypeCtor::Tuple => {\n                 let ts = &self.parameters;\n                 if ts.0.len() == 1 {\n                     write!(f, \"({},)\", ts.0[0].display(f.db))?;\n@@ -346,13 +346,13 @@ impl HirDisplay for ApplicationTy {\n                     write!(f, \")\")?;\n                 }\n             }\n-            TypeName::FnPtr => {\n+            TypeCtor::FnPtr => {\n                 let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n                 write!(f, \"fn(\")?;\n                 f.write_joined(sig.params(), \", \")?;\n                 write!(f, \") -> {}\", sig.ret().display(f.db))?;\n             }\n-            TypeName::FnDef(def) => {\n+            TypeCtor::FnDef(def) => {\n                 let sig = f.db.callable_item_signature(def);\n                 let name = match def {\n                     CallableDef::Function(ff) => ff.name(f.db),\n@@ -372,7 +372,7 @@ impl HirDisplay for ApplicationTy {\n                 f.write_joined(sig.params(), \", \")?;\n                 write!(f, \") -> {}\", sig.ret().display(f.db))?;\n             }\n-            TypeName::Adt(def_id) => {\n+            TypeCtor::Adt(def_id) => {\n                 let name = match def_id {\n                     AdtDef::Struct(s) => s.name(f.db),\n                     AdtDef::Enum(e) => e.name(f.db),"}, {"sha": "e975f921790e01d575cfe54ffc988e98b466db08", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=f10f5a81b326d161d9ed1fba263de972b89de2bf", "patch": "@@ -38,7 +38,7 @@ use crate::{\n     resolve::{Resolver, Resolution},\n     nameres::Namespace\n };\n-use super::{Ty, TypableDef, Substs, primitive, op, FnSig, ApplicationTy, TypeName};\n+use super::{Ty, TypableDef, Substs, primitive, op, FnSig, ApplicationTy, TypeCtor};\n \n /// The entry point of type inference.\n pub fn infer(db: &impl HirDatabase, func: Function) -> Arc<InferenceResult> {\n@@ -278,11 +278,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         match ty {\n             Ty::Unknown => self.new_type_var(),\n             Ty::Apply(ApplicationTy {\n-                name: TypeName::Int(primitive::UncertainIntTy::Unknown),\n+                name: TypeCtor::Int(primitive::UncertainIntTy::Unknown),\n                 ..\n             }) => self.new_integer_var(),\n             Ty::Apply(ApplicationTy {\n-                name: TypeName::Float(primitive::UncertainFloatTy::Unknown),\n+                name: TypeCtor::Float(primitive::UncertainFloatTy::Unknown),\n                 ..\n             }) => self.new_float_var(),\n             _ => ty,\n@@ -629,7 +629,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     .collect::<Vec<_>>()\n                     .into();\n \n-                Ty::apply(TypeName::Tuple, Substs(inner_tys))\n+                Ty::apply(TypeCtor::Tuple, Substs(inner_tys))\n             }\n             Pat::Ref { pat, mutability } => {\n                 let expectation = match expected.as_reference() {\n@@ -642,7 +642,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     _ => &Ty::Unknown,\n                 };\n                 let subty = self.infer_pat(*pat, expectation, default_bm);\n-                Ty::apply_one(TypeName::Ref(*mutability), subty.into())\n+                Ty::apply_one(TypeCtor::Ref(*mutability), subty.into())\n             }\n             Pat::TupleStruct { path: ref p, args: ref subpats } => {\n                 self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm)\n@@ -670,7 +670,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 let bound_ty = match mode {\n                     BindingMode::Ref(mutability) => {\n-                        Ty::apply_one(TypeName::Ref(mutability), inner_ty.clone().into())\n+                        Ty::apply_one(TypeCtor::Ref(mutability), inner_ty.clone().into())\n                     }\n                     BindingMode::Move => inner_ty.clone(),\n                 };\n@@ -725,7 +725,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Missing => Ty::Unknown,\n             Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeName::Bool)));\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 let then_ty = self.infer_expr(*then_branch, expected);\n                 match else_branch {\n                     Some(else_branch) => {\n@@ -742,11 +742,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Loop { body } => {\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 // TODO handle break with value\n-                Ty::simple(TypeName::Never)\n+                Ty::simple(TypeCtor::Never)\n             }\n             Expr::While { condition, body } => {\n                 // while let is desugared to a match loop, so this is always simple while\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeName::Bool)));\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n@@ -777,11 +777,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 let (param_tys, ret_ty) = match &callee_ty {\n                     Ty::Apply(a_ty) => match a_ty.name {\n-                        TypeName::FnPtr => {\n+                        TypeCtor::FnPtr => {\n                             let sig = FnSig::from_fn_ptr_substs(&a_ty.parameters);\n                             (sig.params().to_vec(), sig.ret().clone())\n                         }\n-                        TypeName::FnDef(def) => {\n+                        TypeCtor::FnDef(def) => {\n                             let sig = self.db.callable_item_signature(def);\n                             let ret_ty = sig.ret().clone().subst(&a_ty.parameters);\n                             let param_tys = sig\n@@ -824,7 +824,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let method_ty = self.insert_type_vars(method_ty);\n                 let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n                     Ty::Apply(a_ty) => match a_ty.name {\n-                        TypeName::FnPtr => {\n+                        TypeCtor::FnPtr => {\n                             let sig = FnSig::from_fn_ptr_substs(&a_ty.parameters);\n                             if !sig.params().is_empty() {\n                                 (\n@@ -836,7 +836,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                                 (Ty::Unknown, Vec::new(), sig.ret().clone())\n                             }\n                         }\n-                        TypeName::FnDef(def) => {\n+                        TypeCtor::FnDef(def) => {\n                             let sig = self.db.callable_item_signature(def);\n                             let ret_ty = sig.ret().clone().subst(&a_ty.parameters);\n \n@@ -858,7 +858,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // Apply autoref so the below unification works correctly\n                 let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n                     Some((_, mutability)) => {\n-                        Ty::apply_one(TypeName::Ref(mutability), derefed_receiver_ty)\n+                        Ty::apply_one(TypeCtor::Ref(mutability), derefed_receiver_ty)\n                     }\n                     _ => derefed_receiver_ty,\n                 };\n@@ -885,7 +885,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n                             guard_expr,\n-                            &Expectation::has_type(Ty::simple(TypeName::Bool)),\n+                            &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n                         );\n                     }\n                     self.infer_expr(arm.expr, &expected);\n@@ -898,19 +898,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n                 self.infer_path_expr(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n-            Expr::Continue => Ty::simple(TypeName::Never),\n+            Expr::Continue => Ty::simple(TypeCtor::Never),\n             Expr::Break { expr } => {\n                 if let Some(expr) = expr {\n                     // TODO handle break with value\n                     self.infer_expr(*expr, &Expectation::none());\n                 }\n-                Ty::simple(TypeName::Never)\n+                Ty::simple(TypeCtor::Never)\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n                     self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()));\n                 }\n-                Ty::simple(TypeName::Never)\n+                Ty::simple(TypeCtor::Never)\n             }\n             Expr::StructLit { path, fields, spread } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_ref());\n@@ -933,11 +933,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     .autoderef(self.db)\n                     .find_map(|derefed_ty| match derefed_ty {\n                         Ty::Apply(a_ty) => match a_ty.name {\n-                            TypeName::Tuple => {\n+                            TypeCtor::Tuple => {\n                                 let i = name.to_string().parse::<usize>().ok();\n                                 i.and_then(|i| a_ty.parameters.0.get(i).cloned())\n                             }\n-                            TypeName::Adt(AdtDef::Struct(s)) => {\n+                            TypeCtor::Adt(AdtDef::Struct(s)) => {\n                                 s.field(self.db, name).map(|field| {\n                                     self.write_field_resolution(tgt_expr, field);\n                                     field.ty(self.db).subst(&a_ty.parameters)\n@@ -973,7 +973,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     };\n                 // TODO reference coercions etc.\n                 let inner_ty = self.infer_expr(*expr, &expectation);\n-                Ty::apply_one(TypeName::Ref(*mutability), inner_ty)\n+                Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n             }\n             Expr::UnaryOp { expr, op } => {\n                 let inner_ty = self.infer_expr(*expr, &Expectation::none());\n@@ -989,9 +989,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     UnaryOp::Neg => {\n                         match &inner_ty {\n                             Ty::Apply(a_ty) => match a_ty.name {\n-                                TypeName::Int(primitive::UncertainIntTy::Unknown)\n-                                | TypeName::Int(primitive::UncertainIntTy::Signed(..))\n-                                | TypeName::Float(..) => inner_ty,\n+                                TypeCtor::Int(primitive::UncertainIntTy::Unknown)\n+                                | TypeCtor::Int(primitive::UncertainIntTy::Signed(..))\n+                                | TypeCtor::Float(..) => inner_ty,\n                                 _ => Ty::Unknown,\n                             },\n                             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => {\n@@ -1004,7 +1004,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     UnaryOp::Not => {\n                         match &inner_ty {\n                             Ty::Apply(a_ty) => match a_ty.name {\n-                                TypeName::Bool | TypeName::Int(_) => inner_ty,\n+                                TypeCtor::Bool | TypeCtor::Int(_) => inner_ty,\n                                 _ => Ty::Unknown,\n                             },\n                             Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n@@ -1018,7 +1018,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Some(op) => {\n                     let lhs_expectation = match op {\n                         BinaryOp::BooleanAnd | BinaryOp::BooleanOr => {\n-                            Expectation::has_type(Ty::simple(TypeName::Bool))\n+                            Expectation::has_type(Ty::simple(TypeCtor::Bool))\n                         }\n                         _ => Expectation::none(),\n                     };\n@@ -1039,12 +1039,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     ty_vec.push(self.infer_expr(*arg, &Expectation::none()));\n                 }\n \n-                Ty::apply(TypeName::Tuple, Substs(ty_vec.into()))\n+                Ty::apply(TypeCtor::Tuple, Substs(ty_vec.into()))\n             }\n             Expr::Array { exprs } => {\n                 let elem_ty = match &expected.ty {\n                     Ty::Apply(a_ty) => match a_ty.name {\n-                        TypeName::Slice | TypeName::Array => {\n+                        TypeCtor::Slice | TypeCtor::Array => {\n                             Ty::clone(&a_ty.parameters.as_single())\n                         }\n                         _ => self.new_type_var(),\n@@ -1056,23 +1056,23 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     self.infer_expr(*expr, &Expectation::has_type(elem_ty.clone()));\n                 }\n \n-                Ty::apply_one(TypeName::Array, elem_ty)\n+                Ty::apply_one(TypeCtor::Array, elem_ty)\n             }\n             Expr::Literal(lit) => match lit {\n-                Literal::Bool(..) => Ty::simple(TypeName::Bool),\n+                Literal::Bool(..) => Ty::simple(TypeCtor::Bool),\n                 Literal::String(..) => {\n-                    Ty::apply_one(TypeName::Ref(Mutability::Shared), Ty::simple(TypeName::Str))\n+                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), Ty::simple(TypeCtor::Str))\n                 }\n                 Literal::ByteString(..) => {\n-                    let byte_type = Ty::simple(TypeName::Int(primitive::UncertainIntTy::Unsigned(\n+                    let byte_type = Ty::simple(TypeCtor::Int(primitive::UncertainIntTy::Unsigned(\n                         primitive::UintTy::U8,\n                     )));\n-                    let slice_type = Ty::apply_one(TypeName::Slice, byte_type);\n-                    Ty::apply_one(TypeName::Ref(Mutability::Shared), slice_type)\n+                    let slice_type = Ty::apply_one(TypeCtor::Slice, byte_type);\n+                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), slice_type)\n                 }\n-                Literal::Char(..) => Ty::simple(TypeName::Char),\n-                Literal::Int(_v, ty) => Ty::simple(TypeName::Int(*ty)),\n-                Literal::Float(_v, ty) => Ty::simple(TypeName::Float(*ty)),\n+                Literal::Char(..) => Ty::simple(TypeCtor::Char),\n+                Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int(*ty)),\n+                Literal::Float(_v, ty) => Ty::simple(TypeCtor::Float(*ty)),\n             },\n         };\n         // use a new type variable if we got Ty::Unknown here\n@@ -1208,9 +1208,9 @@ impl InferTy {\n         match self {\n             InferTy::TypeVar(..) => Ty::Unknown,\n             InferTy::IntVar(..) => {\n-                Ty::simple(TypeName::Int(primitive::UncertainIntTy::Signed(primitive::IntTy::I32)))\n+                Ty::simple(TypeCtor::Int(primitive::UncertainIntTy::Signed(primitive::IntTy::I32)))\n             }\n-            InferTy::FloatVar(..) => Ty::simple(TypeName::Float(\n+            InferTy::FloatVar(..) => Ty::simple(TypeCtor::Float(\n                 primitive::UncertainFloatTy::Known(primitive::FloatTy::F64),\n             )),\n         }"}, {"sha": "72b1234bf97c50b97b0f83213e23f705a01aafe9", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=f10f5a81b326d161d9ed1fba263de972b89de2bf", "patch": "@@ -19,40 +19,40 @@ use crate::{\n     generics::GenericParams,\n     adt::VariantDef,\n };\n-use super::{Ty, primitive, FnSig, Substs, TypeName};\n+use super::{Ty, primitive, FnSig, Substs, TypeCtor};\n \n impl Ty {\n     pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n         match type_ref {\n-            TypeRef::Never => Ty::simple(TypeName::Never),\n+            TypeRef::Never => Ty::simple(TypeCtor::Never),\n             TypeRef::Tuple(inner) => {\n                 let inner_tys =\n                     inner.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n-                Ty::apply(TypeName::Tuple, Substs(inner_tys.into()))\n+                Ty::apply(TypeCtor::Tuple, Substs(inner_tys.into()))\n             }\n             TypeRef::Path(path) => Ty::from_hir_path(db, resolver, path),\n             TypeRef::RawPtr(inner, mutability) => {\n                 let inner_ty = Ty::from_hir(db, resolver, inner);\n-                Ty::apply_one(TypeName::RawPtr(*mutability), inner_ty)\n+                Ty::apply_one(TypeCtor::RawPtr(*mutability), inner_ty)\n             }\n             TypeRef::Array(inner) => {\n                 let inner_ty = Ty::from_hir(db, resolver, inner);\n-                Ty::apply_one(TypeName::Array, inner_ty)\n+                Ty::apply_one(TypeCtor::Array, inner_ty)\n             }\n             TypeRef::Slice(inner) => {\n                 let inner_ty = Ty::from_hir(db, resolver, inner);\n-                Ty::apply_one(TypeName::Slice, inner_ty)\n+                Ty::apply_one(TypeCtor::Slice, inner_ty)\n             }\n             TypeRef::Reference(inner, mutability) => {\n                 let inner_ty = Ty::from_hir(db, resolver, inner);\n-                Ty::apply_one(TypeName::Ref(*mutability), inner_ty)\n+                Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n                 let inner_tys =\n                     params.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n                 let sig = Substs(inner_tys.into());\n-                Ty::apply(TypeName::FnPtr, sig)\n+                Ty::apply(TypeCtor::FnPtr, sig)\n             }\n             TypeRef::Error => Ty::Unknown,\n         }\n@@ -62,14 +62,14 @@ impl Ty {\n         if let Some(name) = path.as_ident() {\n             // TODO handle primitive type names in resolver as well?\n             if let Some(int_ty) = primitive::UncertainIntTy::from_type_name(name) {\n-                return Ty::simple(TypeName::Int(int_ty));\n+                return Ty::simple(TypeCtor::Int(int_ty));\n             } else if let Some(float_ty) = primitive::UncertainFloatTy::from_type_name(name) {\n-                return Ty::simple(TypeName::Float(float_ty));\n+                return Ty::simple(TypeCtor::Float(float_ty));\n             } else if let Some(known) = name.as_known_name() {\n                 match known {\n-                    KnownName::Bool => return Ty::simple(TypeName::Bool),\n-                    KnownName::Char => return Ty::simple(TypeName::Char),\n-                    KnownName::Str => return Ty::simple(TypeName::Str),\n+                    KnownName::Bool => return Ty::simple(TypeCtor::Bool),\n+                    KnownName::Char => return Ty::simple(TypeCtor::Char),\n+                    KnownName::Str => return Ty::simple(TypeCtor::Str),\n                     _ => {}\n                 }\n             }\n@@ -245,7 +245,7 @@ fn fn_sig_for_fn(db: &impl HirDatabase, def: Function) -> FnSig {\n fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n     let generics = def.generic_params(db);\n     let substs = make_substs(&generics);\n-    Ty::apply(TypeName::FnDef(def.into()), substs)\n+    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n /// Build the declared type of a const.\n@@ -287,7 +287,7 @@ fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n     }\n     let generics = def.generic_params(db);\n     let substs = make_substs(&generics);\n-    Ty::apply(TypeName::FnDef(def.into()), substs)\n+    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) -> FnSig {\n@@ -315,7 +315,7 @@ fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) ->\n     }\n     let generics = def.parent_enum(db).generic_params(db);\n     let substs = make_substs(&generics);\n-    Ty::apply(TypeName::FnDef(def.into()), substs)\n+    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n fn make_substs(generics: &GenericParams) -> Substs {\n@@ -331,12 +331,12 @@ fn make_substs(generics: &GenericParams) -> Substs {\n \n fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n     let generics = s.generic_params(db);\n-    Ty::apply(TypeName::Adt(s.into()), make_substs(&generics))\n+    Ty::apply(TypeCtor::Adt(s.into()), make_substs(&generics))\n }\n \n fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n     let generics = s.generic_params(db);\n-    Ty::apply(TypeName::Adt(s.into()), make_substs(&generics))\n+    Ty::apply(TypeCtor::Adt(s.into()), make_substs(&generics))\n }\n \n fn type_for_type_alias(db: &impl HirDatabase, t: TypeAlias) -> Ty {"}, {"sha": "9422bad84387ba4f084471fe7e0b83e7103d9220", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=f10f5a81b326d161d9ed1fba263de972b89de2bf", "patch": "@@ -10,15 +10,15 @@ use crate::{\n     HirDatabase, Module, Crate, Name, Function, Trait,\n     ids::TraitId,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n-    ty::{Ty, TypeName},\n+    ty::{Ty, TypeCtor},\n     nameres::CrateModuleId,\n \n };\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum TyFingerprint {\n-    Apply(TypeName),\n+    Apply(TypeCtor),\n }\n \n impl TyFingerprint {\n@@ -112,7 +112,7 @@ impl CrateImplBlocks {\n fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n     match ty {\n         Ty::Apply(a_ty) => match a_ty.name {\n-            TypeName::Adt(def_id) => def_id.krate(db),\n+            TypeCtor::Adt(def_id) => def_id.krate(db),\n             _ => None,\n         },\n         _ => None,"}, {"sha": "1d230140b13eb6ae85c03e2deea6d62bfffc6f01", "filename": "crates/ra_hir/src/ty/op.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs?ref=f10f5a81b326d161d9ed1fba263de972b89de2bf", "patch": "@@ -1,5 +1,5 @@\n use crate::{ ty::ApplicationTy, expr::BinaryOp};\n-use super::{Ty, TypeName, InferTy};\n+use super::{Ty, TypeCtor, InferTy};\n \n pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n     match op {\n@@ -10,7 +10,7 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n         | BinaryOp::LesserEqualTest\n         | BinaryOp::GreaterEqualTest\n         | BinaryOp::LesserTest\n-        | BinaryOp::GreaterTest => Ty::simple(TypeName::Bool),\n+        | BinaryOp::GreaterTest => Ty::simple(TypeCtor::Bool),\n         BinaryOp::Assignment\n         | BinaryOp::AddAssign\n         | BinaryOp::SubAssign\n@@ -33,7 +33,7 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n         | BinaryOp::BitwiseOr\n         | BinaryOp::BitwiseXor => match rhs_ty {\n             Ty::Apply(ApplicationTy { name, .. }) => match name {\n-                TypeName::Int(..) | TypeName::Float(..) => rhs_ty,\n+                TypeCtor::Int(..) | TypeCtor::Float(..) => rhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => rhs_ty,\n@@ -45,14 +45,14 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n \n pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n     match op {\n-        BinaryOp::BooleanAnd | BinaryOp::BooleanOr => Ty::simple(TypeName::Bool),\n+        BinaryOp::BooleanAnd | BinaryOp::BooleanOr => Ty::simple(TypeCtor::Bool),\n         BinaryOp::Assignment | BinaryOp::EqualityTest => match lhs_ty {\n             Ty::Apply(ApplicationTy { name, .. }) => match name {\n-                TypeName::Int(..)\n-                | TypeName::Float(..)\n-                | TypeName::Str\n-                | TypeName::Char\n-                | TypeName::Bool => lhs_ty,\n+                TypeCtor::Int(..)\n+                | TypeCtor::Float(..)\n+                | TypeCtor::Str\n+                | TypeCtor::Char\n+                | TypeCtor::Bool => lhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n@@ -83,7 +83,7 @@ pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n         | BinaryOp::BitwiseOr\n         | BinaryOp::BitwiseXor => match lhs_ty {\n             Ty::Apply(ApplicationTy { name, .. }) => match name {\n-                TypeName::Int(..) | TypeName::Float(..) => lhs_ty,\n+                TypeCtor::Int(..) | TypeCtor::Float(..) => lhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,"}, {"sha": "f975214e92a4cd241c29eaf841fe96fab5e18cee", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f5a81b326d161d9ed1fba263de972b89de2bf/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=f10f5a81b326d161d9ed1fba263de972b89de2bf", "patch": "@@ -1,4 +1,4 @@\n-use hir::{Ty, AdtDef, TypeName};\n+use hir::{Ty, AdtDef, TypeCtor};\n \n use crate::completion::{CompletionContext, Completions};\n \n@@ -25,13 +25,13 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n     for receiver in receiver.autoderef(ctx.db) {\n         match receiver {\n             Ty::Apply(a_ty) => match a_ty.name {\n-                TypeName::Adt(AdtDef::Struct(s)) => {\n+                TypeCtor::Adt(AdtDef::Struct(s)) => {\n                     for field in s.fields(ctx.db) {\n                         acc.add_field(ctx, field, &a_ty.parameters);\n                     }\n                 }\n                 // TODO unions\n-                TypeName::Tuple => {\n+                TypeCtor::Tuple => {\n                     for (i, ty) in a_ty.parameters.iter().enumerate() {\n                         acc.add_pos_field(ctx, i, ty);\n                     }"}]}