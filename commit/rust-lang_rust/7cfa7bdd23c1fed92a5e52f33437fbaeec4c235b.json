{"sha": "7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZmE3YmRkMjNjMWZlZDkyYTVlNTJmMzM0MzdmYmFlZWM0YzIzNWI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-26T23:26:51Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-26T23:27:47Z"}, "message": "Make vreg constrs per-quad, regfence on nontrivial constrs, back out workaround to _uint, add regression test. Closes #152.", "tree": {"sha": "347a467a95c132dbe86eb0b23ce27559884ebc50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/347a467a95c132dbe86eb0b23ce27559884ebc50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b", "html_url": "https://github.com/rust-lang/rust/commit/7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7eeeb596a9aa0660e6e3f8cff92876ac1686007", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7eeeb596a9aa0660e6e3f8cff92876ac1686007", "html_url": "https://github.com/rust-lang/rust/commit/a7eeeb596a9aa0660e6e3f8cff92876ac1686007"}], "stats": {"total": 122, "additions": 73, "deletions": 49}, "files": [{"sha": "77045777b9cb309d4a056575387f068358ebd6e9", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b", "patch": "@@ -510,6 +510,7 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       obj-with-vec.rs \\\n                       operator-associativity.rs \\\n                       output-slot-variants.rs \\\n+                      over-constrained-vregs.rs \\\n                       pred.rs \\\n                       preempt.rs \\\n                       readalias.rs \\"}, {"sha": "ddcc32fab75a124d462382d8dcbf0482056eacdf", "filename": "src/boot/be/ra.ml", "status": "modified", "additions": 61, "deletions": 46, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b/src%2Fboot%2Fbe%2Fra.ml", "raw_url": "https://github.com/rust-lang/rust/raw/7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b/src%2Fboot%2Fbe%2Fra.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fra.ml?ref=7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b", "patch": "@@ -322,38 +322,34 @@ let dump_quads cx =\n   done\n ;;\n \n-let calculate_vreg_constraints (cx:ctxt) : Bits.t array =\n+let calculate_vreg_constraints\n+    (cx:ctxt)\n+    (constraints:Bits.t array)\n+    (q:quad)\n+    : unit =\n   let abi = cx.ctxt_abi in\n-  let n_vregs = cx.ctxt_n_vregs in\n-  let n_hregs = abi.Abi.abi_n_hardregs in\n-  let constraints = Array.init n_vregs (fun _ -> Bits.create n_hregs true) in\n-    Array.iteri\n+    Array.iter (fun c -> Bits.clear c; Bits.invert c) constraints;\n+    abi.Abi.abi_constrain_vregs q constraints;\n+    iflog cx\n       begin\n-        fun i q ->\n-          abi.Abi.abi_constrain_vregs q constraints;\n-          iflog cx\n-            begin\n-              fun _ ->\n-                let hr_str = cx.ctxt_abi.Abi.abi_str_of_hardreg in\n-                  log cx \"constraints for quad %d = %s\"\n-                    i (string_of_quad hr_str q);\n-                  let qp_reg _ r =\n-                    begin\n-                      match r with\n-                          Il.Hreg _ -> ()\n-                        | Il.Vreg v ->\n-                            let hregs = Bits.to_list constraints.(v) in\n-                              log cx \"<v%d> constrained to hregs: [%s]\"\n-                                v (list_to_str hregs hr_str)\n-                    end;\n-                    r\n-                  in\n-                    ignore (Il.process_quad { Il.identity_processor with\n-                                                Il.qp_reg = qp_reg } q)\n-            end;\n+        fun _ ->\n+          let hr_str = cx.ctxt_abi.Abi.abi_str_of_hardreg in\n+            log cx \"constraints for quad %s\"\n+              (string_of_quad hr_str q);\n+            let qp_reg _ r =\n+              begin\n+                match r with\n+                    Il.Hreg _ -> ()\n+                  | Il.Vreg v ->\n+                      let hregs = Bits.to_list constraints.(v) in\n+                        log cx \"<v%d> constrained to hregs: [%s]\"\n+                          v (list_to_str hregs hr_str)\n+              end;\n+              r\n+            in\n+              ignore (Il.process_quad { Il.identity_processor with\n+                                          Il.qp_reg = qp_reg } q)\n       end\n-      cx.ctxt_quads;\n-    constraints\n ;;\n \n (* Simple local register allocator. Nothing fancy. *)\n@@ -380,8 +376,10 @@ let reg_alloc\n     let (live_in_vregs, live_out_vregs) =\n       calculate_live_bitvectors cx\n     in\n+    let n_vregs = cx.ctxt_n_vregs in\n+    let n_hregs = abi.Abi.abi_n_hardregs in\n     let (vreg_constraints:Bits.t array) = (* vreg idx -> hreg bits.t *)\n-      calculate_vreg_constraints cx\n+      Array.init n_vregs (fun _ -> Bits.create n_hregs true)\n     in\n     let inactive_hregs = ref [] in (* [hreg] *)\n     let active_hregs = ref [] in (* [hreg] *)\n@@ -560,23 +558,40 @@ let reg_alloc\n       for i = 0 to (Array.length cx.ctxt_quads) - 1\n       do\n         let quad = cx.ctxt_quads.(i) in\n+        let _ = calculate_vreg_constraints cx vreg_constraints quad in\n         let clobbers = cx.ctxt_abi.Abi.abi_clobbers quad in\n         let used = quad_used_vregs quad in\n         let defined = quad_defined_vregs quad in\n \n-        let vreg_constrs v = (v, Bits.to_list (vreg_constraints.(v))) in\n-        let used_constrs = List.map vreg_constrs used in\n-        let constrs_collide (v1,c1) =\n-          if List.length c1 <> 1\n-          then false\n-          else\n-            List.exists\n-              (fun (v2,c2) -> if v1 = v2 then false else c1 = c2)\n-              used_constrs\n-        in\n           begin\n-            if List.exists constrs_collide used_constrs\n-            then raise (Ra_error (\"over-constrained vregs\"));\n+\n+            (* If the quad has any nontrivial vreg constraints, regfence.\n+             * This is awful but it saves us from cached/constrained\n+             * interference as was found in issue #152. *)\n+            if List.exists\n+              (fun v -> not (Bits.equal vreg_constraints.(v) all_hregs))\n+              used\n+            then\n+              begin\n+                (* Regfence. *)\n+                spill_all_regs i;\n+                (* Check for over-constrained-ness after any such regfence. *)\n+                let vreg_constrs v =\n+                  (v, Bits.to_list (vreg_constraints.(v)))\n+                in\n+                let constrs = List.map vreg_constrs (used @ defined) in\n+                let constrs_collide (v1,c1) =\n+                  if List.length c1 <> 1\n+                  then false\n+                  else\n+                    List.exists\n+                      (fun (v2,c2) -> if v1 = v2 then false else c1 = c2)\n+                      constrs\n+                in\n+                  if List.exists constrs_collide constrs\n+                  then raise (Ra_error (\"over-constrained vregs\"));\n+              end;\n+\n             if List.exists (fun def -> List.mem def clobbers) defined\n             then raise (Ra_error (\"clobber and defined sets overlap\"));\n             iflog cx\n@@ -640,10 +655,10 @@ let reg_alloc\n         end;\n       (cx.ctxt_quads, cx.ctxt_next_spill)\n \n-  with\n-      Ra_error s ->\n-        Session.fail sess \"RA error: %s\\n\" s;\n-        (quads, 0)\n+ with\n+     Ra_error s ->\n+       Session.fail sess \"RA error: %s\\n\" s;\n+       (quads, 0)\n \n ;;\n "}, {"sha": "f3a6f93570686359bfd6db9d270aea468447f968", "filename": "src/lib/_uint.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b/src%2Flib%2F_uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b/src%2Flib%2F_uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_uint.rs?ref=7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b", "patch": "@@ -28,9 +28,7 @@ fn next_power_of_two(uint n) -> uint {\n   let uint shift = 1u;\n   while (shift <= halfbits) {\n     tmp |= tmp >> shift;\n-    // FIXME (issue #152):  This would be just a tad cuter if it were\n-    //   shift <<= 1u\n-    shift = shift << 1u;\n+    shift <<= 1u;\n   }\n   ret tmp + 1u;\n }"}, {"sha": "914373f03dc974c0dd15a6c93c4b40d115cfa84e", "filename": "src/test/run-pass/over-constrained-vregs.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b/src%2Ftest%2Frun-pass%2Fover-constrained-vregs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b/src%2Ftest%2Frun-pass%2Fover-constrained-vregs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fover-constrained-vregs.rs?ref=7cfa7bdd23c1fed92a5e52f33437fbaeec4c235b", "patch": "@@ -0,0 +1,10 @@\n+// Regression test for issue #152.\n+\n+fn main() {\n+  let uint b = 1u;\n+  while (b <= 32u) {\n+    0u << b;\n+    b <<= 1u;\n+    log b;\n+  }\n+}"}]}