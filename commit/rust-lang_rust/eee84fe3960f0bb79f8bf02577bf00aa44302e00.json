{"sha": "eee84fe3960f0bb79f8bf02577bf00aa44302e00", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZTg0ZmUzOTYwZjBiYjc5ZjhiZjAyNTc3YmYwMGFhNDQzMDJlMDA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-09T04:57:07Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-11T06:42:26Z"}, "message": "move struct_lint_level to levels.rs", "tree": {"sha": "8526d9f87fb2fe8207a9253c4724c0c9dd0a2726", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8526d9f87fb2fe8207a9253c4724c0c9dd0a2726"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eee84fe3960f0bb79f8bf02577bf00aa44302e00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eee84fe3960f0bb79f8bf02577bf00aa44302e00", "html_url": "https://github.com/rust-lang/rust/commit/eee84fe3960f0bb79f8bf02577bf00aa44302e00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eee84fe3960f0bb79f8bf02577bf00aa44302e00/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f577b44712f0cba0404482b3e44d24ceb5b54a9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f577b44712f0cba0404482b3e44d24ceb5b54a9e", "html_url": "https://github.com/rust-lang/rust/commit/f577b44712f0cba0404482b3e44d24ceb5b54a9e"}], "stats": {"total": 326, "additions": 161, "deletions": 165}, "files": [{"sha": "7e966a7491050ee3be0107ef92f33144593f6a37", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 160, "deletions": 8, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/eee84fe3960f0bb79f8bf02577bf00aa44302e00/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee84fe3960f0bb79f8bf02577bf00aa44302e00/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=eee84fe3960f0bb79f8bf02577bf00aa44302e00", "patch": "@@ -1,15 +1,15 @@\n use std::cmp;\n \n use crate::ich::StableHashingContext;\n-use crate::lint;\n use crate::lint::context::{CheckLintNameResult, LintStore};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc_hir::HirId;\n use rustc_session::lint::{builtin, Level, Lint, LintId};\n-use rustc_session::Session;\n-use rustc_span::source_map::MultiSpan;\n+use rustc_session::{DiagnosticMessageId, Session};\n+use rustc_span::hygiene::MacroKind;\n+use rustc_span::source_map::{DesugaringKind, ExpnKind, MultiSpan};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use syntax::ast;\n@@ -326,7 +326,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                                      Also `cfg_attr(cargo-clippy)` won't be necessary anymore\",\n                                     name\n                                 );\n-                                lint::struct_lint_level(\n+                                struct_lint_level(\n                                     self.sess,\n                                     lint,\n                                     lvl,\n@@ -366,7 +366,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n                         let (level, src) =\n                             self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n-                        let mut err = lint::struct_lint_level(\n+                        let mut err = struct_lint_level(\n                             self.sess,\n                             lint,\n                             level,\n@@ -389,7 +389,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         let (level, src) =\n                             self.sets.get_lint_level(lint, self.cur, Some(&specs), self.sess);\n                         let msg = format!(\"unknown lint: `{}`\", name);\n-                        let mut db = lint::struct_lint_level(\n+                        let mut db = struct_lint_level(\n                             self.sess,\n                             lint,\n                             level,\n@@ -480,7 +480,7 @@ impl<'a> LintLevelsBuilder<'a> {\n         msg: &str,\n     ) -> DiagnosticBuilder<'a> {\n         let (level, src) = self.sets.get_lint_level(lint, self.cur, None, self.sess);\n-        lint::struct_lint_level(self.sess, lint, level, src, span, msg)\n+        struct_lint_level(self.sess, lint, level, src, span, msg)\n     }\n \n     /// Registers the ID provided with the current set of lints stored in\n@@ -553,3 +553,155 @@ impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n         })\n     }\n }\n+\n+pub fn struct_lint_level<'a>(\n+    sess: &'a Session,\n+    lint: &'static Lint,\n+    level: Level,\n+    src: LintSource,\n+    span: Option<MultiSpan>,\n+    msg: &str,\n+) -> DiagnosticBuilder<'a> {\n+    let mut err = match (level, span) {\n+        (Level::Allow, _) => return sess.diagnostic().struct_dummy(),\n+        (Level::Warn, Some(span)) => sess.struct_span_warn(span, msg),\n+        (Level::Warn, None) => sess.struct_warn(msg),\n+        (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => sess.struct_span_err(span, msg),\n+        (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(msg),\n+    };\n+\n+    // Check for future incompatibility lints and issue a stronger warning.\n+    let lint_id = LintId::of(lint);\n+    let future_incompatible = lint.future_incompatible;\n+\n+    // If this code originates in a foreign macro, aka something that this crate\n+    // did not itself author, then it's likely that there's nothing this crate\n+    // can do about it. We probably want to skip the lint entirely.\n+    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n+        // Any suggestions made here are likely to be incorrect, so anything we\n+        // emit shouldn't be automatically fixed by rustfix.\n+        err.allow_suggestions(false);\n+\n+        // If this is a future incompatible lint it'll become a hard error, so\n+        // we have to emit *something*. Also allow lints to whitelist themselves\n+        // on a case-by-case basis for emission in a foreign macro.\n+        if future_incompatible.is_none() && !lint.report_in_external_macro {\n+            err.cancel();\n+            // Don't continue further, since we don't want to have\n+            // `diag_span_note_once` called for a diagnostic that isn't emitted.\n+            return err;\n+        }\n+    }\n+\n+    let name = lint.name_lower();\n+    match src {\n+        LintSource::Default => {\n+            sess.diag_note_once(\n+                &mut err,\n+                DiagnosticMessageId::from(lint),\n+                &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n+            );\n+        }\n+        LintSource::CommandLine(lint_flag_val) => {\n+            let flag = match level {\n+                Level::Warn => \"-W\",\n+                Level::Deny => \"-D\",\n+                Level::Forbid => \"-F\",\n+                Level::Allow => panic!(),\n+            };\n+            let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n+            if lint_flag_val.as_str() == name {\n+                sess.diag_note_once(\n+                    &mut err,\n+                    DiagnosticMessageId::from(lint),\n+                    &format!(\n+                        \"requested on the command line with `{} {}`\",\n+                        flag, hyphen_case_lint_name\n+                    ),\n+                );\n+            } else {\n+                let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n+                sess.diag_note_once(\n+                    &mut err,\n+                    DiagnosticMessageId::from(lint),\n+                    &format!(\n+                        \"`{} {}` implied by `{} {}`\",\n+                        flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n+                    ),\n+                );\n+            }\n+        }\n+        LintSource::Node(lint_attr_name, src, reason) => {\n+            if let Some(rationale) = reason {\n+                err.note(&rationale.as_str());\n+            }\n+            sess.diag_span_note_once(\n+                &mut err,\n+                DiagnosticMessageId::from(lint),\n+                src,\n+                \"lint level defined here\",\n+            );\n+            if lint_attr_name.as_str() != name {\n+                let level_str = level.as_str();\n+                sess.diag_note_once(\n+                    &mut err,\n+                    DiagnosticMessageId::from(lint),\n+                    &format!(\n+                        \"`#[{}({})]` implied by `#[{}({})]`\",\n+                        level_str, name, level_str, lint_attr_name\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+\n+    err.code(DiagnosticId::Lint(name));\n+\n+    if let Some(future_incompatible) = future_incompatible {\n+        const STANDARD_MESSAGE: &str = \"this was previously accepted by the compiler but is being phased out; \\\n+             it will become a hard error\";\n+\n+        let explanation = if lint_id == LintId::of(builtin::UNSTABLE_NAME_COLLISIONS) {\n+            \"once this method is added to the standard library, \\\n+             the ambiguity may cause an error or change in behavior!\"\n+                .to_owned()\n+        } else if lint_id == LintId::of(builtin::MUTABLE_BORROW_RESERVATION_CONFLICT) {\n+            \"this borrowing pattern was not meant to be accepted, \\\n+             and may become a hard error in the future\"\n+                .to_owned()\n+        } else if let Some(edition) = future_incompatible.edition {\n+            format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)\n+        } else {\n+            format!(\"{} in a future release!\", STANDARD_MESSAGE)\n+        };\n+        let citation = format!(\"for more information, see {}\", future_incompatible.reference);\n+        err.warn(&explanation);\n+        err.note(&citation);\n+    }\n+\n+    return err;\n+}\n+\n+/// Returns whether `span` originates in a foreign crate's external macro.\n+///\n+/// This is used to test whether a lint should not even begin to figure out whether it should\n+/// be reported on the current node.\n+pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n+    let expn_data = span.ctxt().outer_expn_data();\n+    match expn_data.kind {\n+        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n+        ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n+        ExpnKind::Macro(MacroKind::Bang, _) => {\n+            if expn_data.def_site.is_dummy() {\n+                // Dummy span for the `def_site` means it's an external macro.\n+                return true;\n+            }\n+            match sess.source_map().span_to_snippet(expn_data.def_site) {\n+                Ok(code) => !code.starts_with(\"macro_rules\"),\n+                // No snippet means external macro or compiler-builtin expansion.\n+                Err(_) => true,\n+            }\n+        }\n+        ExpnKind::Macro(..) => true, // definitely a plugin\n+    }\n+}"}, {"sha": "371fa27cb2418002a46bac53cd5bbe449eca694d", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 157, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/eee84fe3960f0bb79f8bf02577bf00aa44302e00/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee84fe3960f0bb79f8bf02577bf00aa44302e00/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=eee84fe3960f0bb79f8bf02577bf00aa44302e00", "patch": "@@ -23,12 +23,8 @@ pub use self::Level::*;\n \n use crate::ty::TyCtxt;\n use rustc_data_structures::sync;\n-use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n use rustc_hir as hir;\n use rustc_session::lint::builtin::HardwiredLints;\n-use rustc_session::{DiagnosticMessageId, Session};\n-use rustc_span::hygiene::MacroKind;\n-use rustc_span::source_map::{DesugaringKind, ExpnKind, MultiSpan};\n use rustc_span::Span;\n use syntax::ast;\n \n@@ -318,161 +314,9 @@ mod context;\n pub mod internal;\n mod levels;\n \n-pub use self::levels::{LintLevelMap, LintLevelSets, LintLevelsBuilder};\n-\n-pub fn struct_lint_level<'a>(\n-    sess: &'a Session,\n-    lint: &'static Lint,\n-    level: Level,\n-    src: LintSource,\n-    span: Option<MultiSpan>,\n-    msg: &str,\n-) -> DiagnosticBuilder<'a> {\n-    let mut err = match (level, span) {\n-        (Level::Allow, _) => return sess.diagnostic().struct_dummy(),\n-        (Level::Warn, Some(span)) => sess.struct_span_warn(span, msg),\n-        (Level::Warn, None) => sess.struct_warn(msg),\n-        (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => sess.struct_span_err(span, msg),\n-        (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(msg),\n-    };\n-\n-    // Check for future incompatibility lints and issue a stronger warning.\n-    let lint_id = LintId::of(lint);\n-    let future_incompatible = lint.future_incompatible;\n-\n-    // If this code originates in a foreign macro, aka something that this crate\n-    // did not itself author, then it's likely that there's nothing this crate\n-    // can do about it. We probably want to skip the lint entirely.\n-    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n-        // Any suggestions made here are likely to be incorrect, so anything we\n-        // emit shouldn't be automatically fixed by rustfix.\n-        err.allow_suggestions(false);\n-\n-        // If this is a future incompatible lint it'll become a hard error, so\n-        // we have to emit *something*. Also allow lints to whitelist themselves\n-        // on a case-by-case basis for emission in a foreign macro.\n-        if future_incompatible.is_none() && !lint.report_in_external_macro {\n-            err.cancel();\n-            // Don't continue further, since we don't want to have\n-            // `diag_span_note_once` called for a diagnostic that isn't emitted.\n-            return err;\n-        }\n-    }\n-\n-    let name = lint.name_lower();\n-    match src {\n-        LintSource::Default => {\n-            sess.diag_note_once(\n-                &mut err,\n-                DiagnosticMessageId::from(lint),\n-                &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n-            );\n-        }\n-        LintSource::CommandLine(lint_flag_val) => {\n-            let flag = match level {\n-                Level::Warn => \"-W\",\n-                Level::Deny => \"-D\",\n-                Level::Forbid => \"-F\",\n-                Level::Allow => panic!(),\n-            };\n-            let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n-            if lint_flag_val.as_str() == name {\n-                sess.diag_note_once(\n-                    &mut err,\n-                    DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"requested on the command line with `{} {}`\",\n-                        flag, hyphen_case_lint_name\n-                    ),\n-                );\n-            } else {\n-                let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n-                sess.diag_note_once(\n-                    &mut err,\n-                    DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"`{} {}` implied by `{} {}`\",\n-                        flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n-                    ),\n-                );\n-            }\n-        }\n-        LintSource::Node(lint_attr_name, src, reason) => {\n-            if let Some(rationale) = reason {\n-                err.note(&rationale.as_str());\n-            }\n-            sess.diag_span_note_once(\n-                &mut err,\n-                DiagnosticMessageId::from(lint),\n-                src,\n-                \"lint level defined here\",\n-            );\n-            if lint_attr_name.as_str() != name {\n-                let level_str = level.as_str();\n-                sess.diag_note_once(\n-                    &mut err,\n-                    DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"`#[{}({})]` implied by `#[{}({})]`\",\n-                        level_str, name, level_str, lint_attr_name\n-                    ),\n-                );\n-            }\n-        }\n-    }\n-\n-    err.code(DiagnosticId::Lint(name));\n-\n-    if let Some(future_incompatible) = future_incompatible {\n-        const STANDARD_MESSAGE: &str = \"this was previously accepted by the compiler but is being phased out; \\\n-             it will become a hard error\";\n-\n-        let explanation = if lint_id == LintId::of(builtin::UNSTABLE_NAME_COLLISIONS) {\n-            \"once this method is added to the standard library, \\\n-             the ambiguity may cause an error or change in behavior!\"\n-                .to_owned()\n-        } else if lint_id == LintId::of(builtin::MUTABLE_BORROW_RESERVATION_CONFLICT) {\n-            \"this borrowing pattern was not meant to be accepted, \\\n-             and may become a hard error in the future\"\n-                .to_owned()\n-        } else if let Some(edition) = future_incompatible.edition {\n-            format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)\n-        } else {\n-            format!(\"{} in a future release!\", STANDARD_MESSAGE)\n-        };\n-        let citation = format!(\"for more information, see {}\", future_incompatible.reference);\n-        err.warn(&explanation);\n-        err.note(&citation);\n-    }\n-\n-    return err;\n-}\n+pub use self::levels::{struct_lint_level, LintLevelMap, LintLevelSets, LintLevelsBuilder};\n \n pub fn maybe_lint_level_root(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n     let attrs = tcx.hir().attrs(id);\n     attrs.iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some())\n }\n-\n-/// Returns whether `span` originates in a foreign crate's external macro.\n-///\n-/// This is used to test whether a lint should not even begin to figure out whether it should\n-/// be reported on the current node.\n-pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n-    let expn_data = span.ctxt().outer_expn_data();\n-    match expn_data.kind {\n-        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n-        ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n-        ExpnKind::Macro(MacroKind::Bang, _) => {\n-            if expn_data.def_site.is_dummy() {\n-                // Dummy span for the `def_site` means it's an external macro.\n-                return true;\n-            }\n-            match sess.source_map().span_to_snippet(expn_data.def_site) {\n-                Ok(code) => !code.starts_with(\"macro_rules\"),\n-                // No snippet means external macro or compiler-builtin expansion.\n-                Err(_) => true,\n-            }\n-        }\n-        ExpnKind::Macro(..) => true, // definitely a plugin\n-    }\n-}"}]}