{"sha": "9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc", "node_id": "C_kwDOAAsO6NoAKDlmNjljNDFjNWZjMGU4NzZjNzU5MjdjYmMzZWY3YTVlZmY0ODFlY2M", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-07-16T07:36:11Z"}, "committer": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-08-18T02:53:22Z"}, "message": "rewrite handle impl again", "tree": {"sha": "305777a9ad331f93fdeeef9ed9c8369d406c3e34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/305777a9ad331f93fdeeef9ed9c8369d406c3e34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc", "html_url": "https://github.com/rust-lang/rust/commit/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08ffbb8d8ad5a65825a458982981222bccf951b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/08ffbb8d8ad5a65825a458982981222bccf951b7", "html_url": "https://github.com/rust-lang/rust/commit/08ffbb8d8ad5a65825a458982981222bccf951b7"}], "stats": {"total": 178, "additions": 90, "deletions": 88}, "files": [{"sha": "fc36913638e0cc5172ba9f0f66ea8f26ba77380a", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc", "patch": "@@ -5,7 +5,7 @@ use rustc_target::spec::abi::Abi;\n use log::trace;\n \n use crate::helpers::check_arg_count;\n-use crate::shims::windows::handle::{EvalContextExt as _, Handle};\n+use crate::shims::windows::handle::{EvalContextExt as _, Handle, PseudoHandle};\n use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n@@ -112,14 +112,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Dlsym::SetThreadDescription => {\n                 let [handle, name] = check_arg_count(args)?;\n \n+                let handle = this.read_scalar(handle)?.check_init()?;\n+\n                 let name = this.read_wide_str(this.read_pointer(name)?)?;\n \n-                let thread =\n-                    match Handle::from_scalar(this.read_scalar(handle)?.check_init()?, this)? {\n-                        Some(Handle::Thread(thread)) => thread,\n-                        Some(Handle::CurrentThread) => this.get_active_thread(),\n-                        _ => this.invalid_handle(\"SetThreadDescription\")?,\n-                    };\n+                let thread = match Handle::from_scalar(handle, this)? {\n+                    Some(Handle::Thread(thread)) => thread,\n+                    Some(Handle::Pseudo(PseudoHandle::CurrentThread)) => this.get_active_thread(),\n+                    _ => this.invalid_handle(\"SetThreadDescription\")?,\n+                };\n \n                 this.set_thread_name_wide(thread, name);\n "}, {"sha": "cc030ec3d0cf11f8aa426ba970b19aefb76b4397", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc", "patch": "@@ -1,14 +1,12 @@\n use std::iter;\n-use std::time::{Duration, Instant};\n \n use rustc_span::Symbol;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n-use crate::thread::Time;\n use crate::*;\n use shims::foreign_items::EmulateByNameResult;\n-use shims::windows::handle::{EvalContextExt as _, Handle};\n+use shims::windows::handle::{EvalContextExt as _, Handle, PseudoHandle};\n use shims::windows::sync::EvalContextExt as _;\n use shims::windows::thread::EvalContextExt as _;\n \n@@ -373,7 +371,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"GetCurrentThread\" => {\n                 let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n \n-                this.write_scalar(Handle::CurrentThread.to_scalar(this), dest)?;\n+                this.write_scalar(\n+                    Handle::Pseudo(PseudoHandle::CurrentThread).to_scalar(this),\n+                    dest,\n+                )?;\n             }\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work."}, {"sha": "041033717e44cfe473ef3325399f8368769c74c1", "filename": "src/shims/windows/handle.rs", "status": "modified", "additions": 69, "deletions": 70, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/src%2Fshims%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/src%2Fshims%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fhandle.rs?ref=9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc", "patch": "@@ -3,44 +3,79 @@ use std::mem::variant_count;\n \n use crate::*;\n \n-/// A Windows `HANDLE` that represents a resource instead of being null or a pseudohandle.\n-///\n-/// This is a seperate type from [`Handle`] to simplify the packing and unpacking code.\n-#[derive(Clone, Copy)]\n-enum RealHandle {\n-    Thread(ThreadId),\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum PseudoHandle {\n+    CurrentThread,\n }\n \n-impl RealHandle {\n-    const USABLE_BITS: u32 = 31;\n+impl PseudoHandle {\n+    const CURRENT_THREAD_VALUE: u32 = 0;\n \n-    const THREAD_DISCRIMINANT: u32 = 1;\n+    fn value(self) -> u32 {\n+        match self {\n+            Self::CurrentThread => Self::CURRENT_THREAD_VALUE,\n+        }\n+    }\n+\n+    fn from_value(value: u32) -> Option<Self> {\n+        match value {\n+            Self::CURRENT_THREAD_VALUE => Some(Self::CurrentThread),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// Miri representation of a Windows `HANDLE`\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum Handle {\n+    Null,\n+    Pseudo(PseudoHandle),\n+    Thread(ThreadId),\n+}\n+\n+impl Handle {\n+    const NULL_DISCRIMINANT: u32 = 0;\n+    const PSEUDO_DISCRIMINANT: u32 = 1;\n+    const THREAD_DISCRIMINANT: u32 = 2;\n \n     fn discriminant(self) -> u32 {\n         match self {\n-            // can't use zero here because all zero handle is invalid\n+            Self::Null => Self::NULL_DISCRIMINANT,\n+            Self::Pseudo(_) => Self::PSEUDO_DISCRIMINANT,\n             Self::Thread(_) => Self::THREAD_DISCRIMINANT,\n         }\n     }\n \n     fn data(self) -> u32 {\n         match self {\n+            Self::Null => 0,\n+            Self::Pseudo(pseudo_handle) => pseudo_handle.value(),\n             Self::Thread(thread) => thread.to_u32(),\n         }\n     }\n \n     fn packed_disc_size() -> u32 {\n-        // log2(x) + 1 is how many bits it takes to store x\n-        // because the discriminants start at 1, the variant count is equal to the highest discriminant\n-        variant_count::<Self>().ilog2() + 1\n+        // ceil(log2(x)) is how many bits it takes to store x numbers\n+        let variant_count = variant_count::<Self>();\n+\n+        // however, std's ilog2 is floor(log2(x))\n+        let floor_log2 = variant_count.ilog2();\n+\n+        // we need to add one for non powers of two to compensate for the difference\n+        let ceil_log2 = if variant_count.is_power_of_two() { floor_log2 } else { floor_log2 + 1 };\n+\n+        ceil_log2\n     }\n \n-    /// This function packs the discriminant and data values into a 31-bit space.\n+    /// Converts a handle into its machine representation.\n+    ///\n+    /// The upper [`Self::packed_disc_size()`] bits are used to store a discriminant corresponding to the handle variant.\n+    /// The remaining bits are used for the variant's field.\n+    ///\n     /// None of this layout is guaranteed to applications by Windows or Miri.\n-    /// The sign bit is not used to avoid overlapping any pseudo-handles.\n-    fn to_packed(self) -> i32 {\n+    fn to_packed(self) -> u32 {\n         let disc_size = Self::packed_disc_size();\n-        let data_size = Self::USABLE_BITS - disc_size;\n+        let data_size = u32::BITS - disc_size;\n \n         let discriminant = self.discriminant();\n         let data = self.data();\n@@ -53,90 +88,54 @@ impl RealHandle {\n \n         // packs the data into the lower `data_size` bits\n         // and packs the discriminant right above the data\n-        (discriminant << data_size | data) as i32\n+        discriminant << data_size | data\n     }\n \n     fn new(discriminant: u32, data: u32) -> Option<Self> {\n         match discriminant {\n+            Self::NULL_DISCRIMINANT if data == 0 => Some(Self::Null),\n+            Self::PSEUDO_DISCRIMINANT => Some(Self::Pseudo(PseudoHandle::from_value(data)?)),\n             Self::THREAD_DISCRIMINANT => Some(Self::Thread(data.into())),\n             _ => None,\n         }\n     }\n \n     /// see docs for `to_packed`\n-    fn from_packed(handle: i32) -> Option<Self> {\n-        let handle_bits = handle as u32;\n-\n+    fn from_packed(handle: u32) -> Option<Self> {\n         let disc_size = Self::packed_disc_size();\n-        let data_size = Self::USABLE_BITS - disc_size;\n+        let data_size = u32::BITS - disc_size;\n \n         // the lower `data_size` bits of this mask are 1\n         let data_mask = 2u32.pow(data_size) - 1;\n \n         // the discriminant is stored right above the lower `data_size` bits\n-        let discriminant = handle_bits >> data_size;\n+        let discriminant = handle >> data_size;\n \n         // the data is stored in the lower `data_size` bits\n-        let data = handle_bits & data_mask;\n+        let data = handle & data_mask;\n \n         Self::new(discriminant, data)\n     }\n-}\n-\n-/// Miri representation of a Windows `HANDLE`\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum Handle {\n-    Null, // = 0\n-\n-    // pseudo-handles\n-    // The lowest real windows pseudo-handle is -6, so miri pseduo-handles start at -7 to break code hardcoding these values\n-    CurrentThread, // = -7\n-\n-    // real handles\n-    Thread(ThreadId),\n-}\n-\n-impl Handle {\n-    const CURRENT_THREAD_VALUE: i32 = -7;\n-\n-    fn to_packed(self) -> i32 {\n-        match self {\n-            Self::Null => 0,\n-            Self::CurrentThread => Self::CURRENT_THREAD_VALUE,\n-            Self::Thread(thread) => RealHandle::Thread(thread).to_packed(),\n-        }\n-    }\n \n     pub fn to_scalar(self, cx: &impl HasDataLayout) -> Scalar<Provenance> {\n         // 64-bit handles are sign extended 32-bit handles\n         // see https://docs.microsoft.com/en-us/windows/win32/winprog64/interprocess-communication\n-        let handle = self.to_packed().into();\n-\n-        Scalar::from_machine_isize(handle, cx)\n-    }\n-\n-    fn from_packed(handle: i64) -> Option<Self> {\n-        let current_thread_val = Self::CURRENT_THREAD_VALUE as i64;\n-\n-        if handle == 0 {\n-            Some(Self::Null)\n-        } else if handle == current_thread_val {\n-            Some(Self::CurrentThread)\n-        } else if let Ok(handle) = handle.try_into() {\n-            match RealHandle::from_packed(handle)? {\n-                RealHandle::Thread(id) => Some(Self::Thread(id)),\n-            }\n-        } else {\n-            // if a handle doesn't fit in an i32, it isn't valid.\n-            None\n-        }\n+        let signed_handle = self.to_packed() as i32;\n+        Scalar::from_machine_isize(signed_handle.into(), cx)\n     }\n \n     pub fn from_scalar<'tcx>(\n         handle: Scalar<Provenance>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Option<Self>> {\n-        let handle = handle.to_machine_isize(cx)?;\n+        let sign_extended_handle = handle.to_machine_isize(cx)?;\n+\n+        let handle = if let Ok(signed_handle) = i32::try_from(sign_extended_handle) {\n+            signed_handle as u32\n+        } else {\n+            // if a handle doesn't fit in an i32, it isn't valid.\n+            return Ok(None);\n+        };\n \n         Ok(Self::from_packed(handle))\n     }"}, {"sha": "08eb4ddba10ceb2d6e5279dcb03dcf9bd6fd2e6a", "filename": "src/shims/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/src%2Fshims%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/src%2Fshims%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fthread.rs?ref=9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc", "patch": "@@ -2,7 +2,7 @@ use rustc_middle::ty::layout::LayoutOf;\n use rustc_target::spec::abi::Abi;\n \n use crate::*;\n-use shims::windows::handle::{EvalContextExt as _, Handle};\n+use shims::windows::handle::{EvalContextExt as _, Handle, PseudoHandle};\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n \n@@ -58,7 +58,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Some(Handle::Thread(thread)) => thread,\n             // Unlike on posix, joining the current thread is not UB on windows.\n             // It will just deadlock.\n-            Some(Handle::CurrentThread) => this.get_active_thread(),\n+            Some(Handle::Pseudo(PseudoHandle::CurrentThread)) => this.get_active_thread(),\n             _ => this.invalid_handle(\"WaitForSingleObject\")?,\n         };\n "}, {"sha": "d3b54cdf156fd738c0112784dd2050743c18449c", "filename": "tests/fail/concurrency/windows_join_main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs?ref=9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc", "patch": "@@ -7,15 +7,15 @@\n use std::thread;\n \n extern \"system\" {\n-    fn WaitForSingleObject(handle: usize, timeout: u32) -> u32;\n+    fn WaitForSingleObject(handle: isize, timeout: u32) -> u32;\n }\n \n const INFINITE: u32 = u32::MAX;\n \n // This is how miri represents the handle for thread 0.\n // This value can be \"legitimately\" obtained by using `GetCurrentThread` with `DuplicateHandle`\n // but miri does not implement `DuplicateHandle` yet.\n-const MAIN_THREAD: usize = 1 << 30;\n+const MAIN_THREAD: isize = (2i32 << 30) as isize;\n \n fn main() {\n     thread::spawn(|| {"}, {"sha": "ff0d074fa7d2604874b30c77f3fdbb365476ac4f", "filename": "tests/fail/concurrency/windows_join_main.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.stderr?ref=9f69c41c5fc0e876c75927cbc3ef7a5eff481ecc", "patch": "@@ -1,10 +1,11 @@\n error: deadlock: the evaluated program deadlocked\n   --> $DIR/windows_join_main.rs:LL:CC\n    |\n-LL |         WaitForSingleObject(MAIN_THREAD, INFINITE);\n-   |                                                   ^ the evaluated program deadlocked\n+LL |             assert_eq!(WaitForSingleObject(MAIN_THREAD, INFINITE), 0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program deadlocked\n    |\n-   = note: inside closure at $DIR/windows_join_main.rs:LL:CC\n+   = note: inside closure at RUSTLIB/core/src/macros/mod.rs:LL:CC\n+   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}]}