{"sha": "8b911587dfed1cc1973b361865c3632a2e2cffde", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiOTExNTg3ZGZlZDFjYzE5NzNiMzYxODY1YzM2MzJhMmUyY2ZmZGU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-10T14:49:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-10T21:31:06Z"}, "message": "rename sendfn to fn~, lambda to fn@", "tree": {"sha": "7a0be45d1690d5ccc80a23e80243f20076bf93eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a0be45d1690d5ccc80a23e80243f20076bf93eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b911587dfed1cc1973b361865c3632a2e2cffde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b911587dfed1cc1973b361865c3632a2e2cffde", "html_url": "https://github.com/rust-lang/rust/commit/8b911587dfed1cc1973b361865c3632a2e2cffde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b911587dfed1cc1973b361865c3632a2e2cffde/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af086aa8ef0628cc21d4dc5831258bf45c9bb872", "url": "https://api.github.com/repos/rust-lang/rust/commits/af086aa8ef0628cc21d4dc5831258bf45c9bb872", "html_url": "https://github.com/rust-lang/rust/commit/af086aa8ef0628cc21d4dc5831258bf45c9bb872"}], "stats": {"total": 209, "additions": 113, "deletions": 96}, "files": [{"sha": "caddce43f72a50be7f35551b37c5b795e3e6645b", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -231,10 +231,10 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         ret ty::mk_tup(st.tcx, params);\n       }\n       's' {\n-        ret parse_ty_rust_fn(st, conv, ast::proto_send);\n+        ret parse_ty_rust_fn(st, conv, ast::proto_uniq);\n       }\n       'F' {\n-        ret parse_ty_rust_fn(st, conv, ast::proto_shared);\n+        ret parse_ty_rust_fn(st, conv, ast::proto_box);\n       }\n       'f' {\n         ret parse_ty_rust_fn(st, conv, ast::proto_bare);\n@@ -279,9 +279,9 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       'y' { ret ty::mk_send_type(st.tcx); }\n       'C' {\n         let ck = alt next(st) as char {\n-          '&' { ty::closure_block }\n-          '@' { ty::closure_shared }\n-          '~' { ty::closure_send }\n+          '&' { ty::ck_block }\n+          '@' { ty::ck_box }\n+          '~' { ty::ck_uniq }\n         };\n         ret ty::mk_opaque_closure_ptr(st.tcx, ck);\n       }"}, {"sha": "ef5085f37e9d12924f56448023a69f6ac5ad5667", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -189,9 +189,9 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       }\n       ty::ty_type. { w.write_char('Y'); }\n       ty::ty_send_type. { w.write_char('y'); }\n-      ty::ty_opaque_closure_ptr(ty::closure_block.) { w.write_str(\"C&\"); }\n-      ty::ty_opaque_closure_ptr(ty::closure_shared.) { w.write_str(\"C@\"); }\n-      ty::ty_opaque_closure_ptr(ty::closure_send.) { w.write_str(\"C~\"); }\n+      ty::ty_opaque_closure_ptr(ty::ck_block.) { w.write_str(\"C&\"); }\n+      ty::ty_opaque_closure_ptr(ty::ck_box.) { w.write_str(\"C@\"); }\n+      ty::ty_opaque_closure_ptr(ty::ck_uniq.) { w.write_str(\"C~\"); }\n       ty::ty_constr(ty, cs) {\n         w.write_str(\"A[\");\n         enc_ty(w, cx, ty);\n@@ -202,8 +202,8 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n }\n fn enc_proto(w: io::writer, proto: proto) {\n     alt proto {\n-      proto_send. { w.write_char('s'); }\n-      proto_shared. { w.write_char('F'); }\n+      proto_uniq. { w.write_char('s'); }\n+      proto_box. { w.write_char('F'); }\n       proto_block. { w.write_char('B'); }\n       proto_bare. { w.write_char('f'); }\n     }"}, {"sha": "e1c1c63d02fb52ae2c9fe3d5fc812baaefd1ad08", "filename": "src/comp/middle/capture.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcapture.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -78,7 +78,7 @@ fn check_capture_clause(tcx: ty::ctxt,\n         check_block_captures(cap_clause.copies);\n         check_block_captures(cap_clause.moves);\n       }\n-      ast::proto_bare. | ast::proto_shared. | ast::proto_send. {\n+      ast::proto_bare. | ast::proto_box. | ast::proto_uniq. {\n         vec::iter(cap_clause.copies, check_capture_item);\n         vec::iter(cap_clause.moves, check_capture_item);\n         vec::iter(cap_clause.moves, check_not_upvar);\n@@ -113,7 +113,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n \n     let implicit_mode = alt fn_proto {\n       ast::proto_block. { cap_ref }\n-      ast::proto_bare. | ast::proto_shared. | ast::proto_send. { cap_copy }\n+      ast::proto_bare. | ast::proto_box. | ast::proto_uniq. { cap_copy }\n     };\n \n     vec::iter(*freevars) { |fvar|"}, {"sha": "5b1cc73ede0f285496316462f2ef2cb55857aea3", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -60,8 +60,8 @@ fn with_appropriate_checker(cx: ctx, id: node_id,\n                             b: block(fn(ctx, ty::t, sp: span))) {\n     let fty = ty::node_id_to_monotype(cx.tcx, id);\n     alt ty::ty_fn_proto(cx.tcx, fty) {\n-      proto_send. { b(check_send); }\n-      proto_shared. { b(check_copy); }\n+      proto_uniq. { b(check_send); }\n+      proto_box. { b(check_copy); }\n       proto_block. { /* no check needed */ }\n       proto_bare. { b(check_none); }\n     }"}, {"sha": "92ceed4879dc8049afd86aaf3e2217c619b5fc73", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -136,8 +136,8 @@ fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> str {\n \n fn mk_tydesc_ty(tcx: ty::ctxt, ck: ty::closure_kind) -> ty::t {\n     ret alt ck {\n-      ty::closure_block. | ty::closure_shared. { ty::mk_type(tcx) }\n-      ty::closure_send. { ty::mk_send_type(tcx) }\n+      ty::ck_block. | ty::ck_box. { ty::mk_type(tcx) }\n+      ty::ck_uniq. { ty::mk_send_type(tcx) }\n     };\n }\n \n@@ -236,15 +236,15 @@ fn allocate_cbox(bcx: @block_ctxt,\n     // Allocate the box:\n     let temp_cleanups = [];\n     let (bcx, box, rc) = alt ck {\n-      ty::closure_shared. {\n+      ty::ck_box. {\n         let (bcx, box) = alloc_in_heap(bcx, false, temp_cleanups);\n         (bcx, box, 1)\n       }\n-      ty::closure_send. {\n+      ty::ck_uniq. {\n         let (bcx, box) = alloc_in_heap(bcx, true, temp_cleanups);\n         (bcx, box, 0x12345678) // use arbitrary value for debugging\n       }\n-      ty::closure_block. {\n+      ty::ck_block. {\n         let {bcx, val: box} = trans::alloc_ty(bcx, cbox_ty);\n         (bcx, box, 0x12345678) // use arbitrary value for debugging\n       }\n@@ -288,10 +288,10 @@ fn store_environment(\n                           ck: ty::closure_kind,\n                           td: ValueRef) -> ValueRef {\n         ret alt ck {\n-          ty::closure_block. | ty::closure_shared. {\n+          ty::ck_block. | ty::ck_box. {\n             td\n           }\n-          ty::closure_send. {\n+          ty::ck_uniq. {\n             Call(bcx, bcx_ccx(bcx).upcalls.create_shared_type_desc, [td])\n           }\n         };\n@@ -310,7 +310,7 @@ fn store_environment(\n \n     // store data tydesc.\n     alt ck {\n-      ty::closure_shared. | ty::closure_send. {\n+      ty::ck_box. | ty::ck_uniq. {\n         let bound_tydesc = GEPi(bcx, llbox, [0, abi::cbox_elt_tydesc]);\n         let ti = none;\n \n@@ -331,7 +331,7 @@ fn store_environment(\n         let td = maybe_clone_tydesc(bcx, ck, closure_td.val);\n         Store(bcx, td, bound_tydesc);\n       }\n-      ty::closure_block. { /* skip this for blocks, not really relevant */ }\n+      ty::ck_block. { /* skip this for blocks, not really relevant */ }\n     }\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n@@ -425,7 +425,7 @@ fn build_closure(bcx0: @block_ctxt,\n         let ty = ty::node_id_to_monotype(tcx, nid);\n         alt cap_var.mode {\n           capture::cap_ref. {\n-            assert ck == ty::closure_block;\n+            assert ck == ty::ck_block;\n             ty = ty::mk_mut_ptr(tcx, ty);\n             env_vals += [env_ref(lv.val, ty, lv.kind)];\n           }\n@@ -492,8 +492,8 @@ fn load_environment(enclosing_cx: @block_ctxt,\n             bcx = upvarptr.bcx;\n             let llupvarptr = upvarptr.val;\n             alt ck {\n-              ty::closure_block. { llupvarptr = Load(bcx, llupvarptr); }\n-              ty::closure_send. | ty::closure_shared. { }\n+              ty::ck_block. { llupvarptr = Load(bcx, llupvarptr); }\n+              ty::ck_uniq. | ty::ck_box. { }\n             }\n             let def_id = ast_util::def_id_of_def(cap_var.def);\n             fcx.llupvars.insert(def_id.node, llupvarptr);\n@@ -531,9 +531,9 @@ fn trans_expr_fn(bcx: @block_ctxt,\n     };\n \n     let closure = alt proto {\n-      ast::proto_block. { trans_closure_env(ty::closure_block) }\n-      ast::proto_shared. { trans_closure_env(ty::closure_shared) }\n-      ast::proto_send. { trans_closure_env(ty::closure_send) }\n+      ast::proto_block. { trans_closure_env(ty::ck_block) }\n+      ast::proto_box. { trans_closure_env(ty::ck_box) }\n+      ast::proto_uniq. { trans_closure_env(ty::ck_uniq) }\n       ast::proto_bare. {\n         let closure = C_null(T_opaque_cbox_ptr(ccx));\n         trans_closure(sub_cx, sp, decl, body, llfn, no_self, [],\n@@ -625,7 +625,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     let {llbox, cboxptr_ty, bcx} = store_environment(\n         bcx, vec::map(lltydescs, {|d| {desc: d, dicts: none}}),\n         env_vals + vec::map(bound, {|x| env_expr(x)}),\n-        ty::closure_shared);\n+        ty::ck_box);\n \n     // Make thunk\n     let llthunk =\n@@ -672,12 +672,8 @@ fn make_fn_glue(\n     ret alt ty::struct(tcx, t) {\n       ty::ty_native_fn(_, _) | ty::ty_fn({proto: ast::proto_bare., _}) { bcx }\n       ty::ty_fn({proto: ast::proto_block., _}) { bcx }\n-      ty::ty_fn({proto: ast::proto_send., _}) {\n-        fn_env(ty::closure_send)\n-      }\n-      ty::ty_fn({proto: ast::proto_shared., _}) {\n-        fn_env(ty::closure_shared)\n-      }\n+      ty::ty_fn({proto: ast::proto_uniq., _}) { fn_env(ty::ck_uniq) }\n+      ty::ty_fn({proto: ast::proto_box., _}) { fn_env(ty::ck_box) }\n       _ { fail \"make_fn_glue invoked on non-function type\" }\n     };\n }\n@@ -689,13 +685,9 @@ fn make_opaque_cbox_take_glue(\n     -> @block_ctxt {\n     // Easy cases:\n     alt ck {\n-      ty::closure_block. {\n-        ret bcx;\n-      }\n-      ty::closure_shared. {\n-        ret incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr));\n-      }\n-      ty::closure_send. { /* hard case: */ }\n+      ty::ck_block. { ret bcx; }\n+      ty::ck_box. { ret incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr)); }\n+      ty::ck_uniq. { /* hard case: */ }\n     }\n \n     // Hard case, a deep copy:\n@@ -731,12 +723,12 @@ fn make_opaque_cbox_drop_glue(\n     cboxptr: ValueRef)     // ptr to the opaque closure\n     -> @block_ctxt {\n     alt ck {\n-      ty::closure_block. { bcx }\n-      ty::closure_shared. {\n+      ty::ck_block. { bcx }\n+      ty::ck_box. {\n         decr_refcnt_maybe_free(bcx, Load(bcx, cboxptr),\n                                ty::mk_opaque_closure_ptr(bcx_tcx(bcx), ck))\n       }\n-      ty::closure_send. {\n+      ty::ck_uniq. {\n         free_ty(bcx, Load(bcx, cboxptr),\n                 ty::mk_opaque_closure_ptr(bcx_tcx(bcx), ck))\n       }\n@@ -749,8 +741,8 @@ fn make_opaque_cbox_free_glue(\n     cbox: ValueRef)     // ptr to the opaque closure\n     -> @block_ctxt {\n     alt ck {\n-      ty::closure_block. { ret bcx; }\n-      ty::closure_shared. | ty::closure_send. { /* hard cases: */ }\n+      ty::ck_block. { ret bcx; }\n+      ty::ck_box. | ty::ck_uniq. { /* hard cases: */ }\n     }\n \n     let ccx = bcx_ccx(bcx);\n@@ -777,11 +769,11 @@ fn make_opaque_cbox_free_glue(\n \n         // Free the ty descr (if necc) and the box itself\n         alt ck {\n-          ty::closure_block. { fail \"Impossible.\"; }\n-          ty::closure_shared. {\n+          ty::ck_block. { fail \"Impossible.\"; }\n+          ty::ck_box. {\n             trans_free_if_not_gc(bcx, cbox)\n           }\n-          ty::closure_send. {\n+          ty::ck_uniq. {\n             let bcx = free_ty(bcx, tydesc, mk_tydesc_ty(tcx, ck));\n             trans_shared_free(bcx, cbox)\n           }"}, {"sha": "76a9b4c69c74cabd2924c190ec5f544ec9e5a342", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -181,9 +181,9 @@ export variant_info;\n export walk_ty;\n export occurs_check_fails;\n export closure_kind;\n-export closure_block;\n-export closure_shared;\n-export closure_send;\n+export ck_block;\n+export ck_box;\n+export ck_uniq;\n export param_bound, param_bounds, bound_copy, bound_send, bound_iface;\n export param_bounds_to_kind;\n \n@@ -234,9 +234,9 @@ type raw_t = {struct: sty,\n type t = uint;\n \n tag closure_kind {\n-    closure_block;\n-    closure_shared;\n-    closure_send;\n+    ck_block;\n+    ck_box;\n+    ck_uniq;\n }\n \n type fn_ty = {proto: ast::proto,\n@@ -1020,8 +1020,8 @@ pure fn kind_can_be_sent(k: kind) -> bool {\n fn proto_kind(p: proto) -> kind {\n     alt p {\n       ast::proto_block. { kind_noncopyable }\n-      ast::proto_shared. { kind_copyable }\n-      ast::proto_send. { kind_sendable }\n+      ast::proto_box. { kind_copyable }\n+      ast::proto_uniq. { kind_sendable }\n       ast::proto_bare. { kind_sendable }\n     }\n }\n@@ -1057,9 +1057,9 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       // anything about its fields.\n       ty_obj(_) { kind_copyable }\n       ty_fn(f) { proto_kind(f.proto) }\n-      ty_opaque_closure_ptr(closure_block.) { kind_noncopyable }\n-      ty_opaque_closure_ptr(closure_shared.) { kind_copyable }\n-      ty_opaque_closure_ptr(closure_send.) { kind_sendable }\n+      ty_opaque_closure_ptr(ck_block.) { kind_noncopyable }\n+      ty_opaque_closure_ptr(ck_box.) { kind_copyable }\n+      ty_opaque_closure_ptr(ck_uniq.) { kind_sendable }\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n       ty_box(_) | ty_iface(_, _) { kind_copyable }\n@@ -1422,9 +1422,9 @@ fn hash_type_structure(st: sty) -> uint {\n         for typ: t in tys { h = hash_subty(h, typ); }\n         ret h;\n       }\n-      ty_opaque_closure_ptr(closure_block.) { ret 41u; }\n-      ty_opaque_closure_ptr(closure_shared.) { ret 42u; }\n-      ty_opaque_closure_ptr(closure_send.) { ret 43u; }\n+      ty_opaque_closure_ptr(ck_block.) { ret 41u; }\n+      ty_opaque_closure_ptr(ck_box.) { ret 42u; }\n+      ty_opaque_closure_ptr(ck_uniq.) { ret 43u; }\n     }\n }\n \n@@ -1563,7 +1563,7 @@ fn ty_fn_proto(cx: ctxt, fty: t) -> ast::proto {\n       ty::ty_fn(f) { ret f.proto; }\n       ty::ty_native_fn(_, _) {\n         // FIXME: This should probably be proto_bare\n-        ret ast::proto_shared;\n+        ret ast::proto_box;\n       }\n       _ { cx.sess.bug(\"ty_fn_proto() called on non-fn type\"); }\n     }"}, {"sha": "bfa3463935a635ce08507a720ed715ad14f8c0ee", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -553,7 +553,7 @@ fn ty_of_obj_ctor(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n         let t_field = ast_ty_to_ty(tcx, mode, f.ty);\n         t_inputs += [{mode: ast::by_copy, ty: t_field}];\n     }\n-    let t_fn = ty::mk_fn(tcx, {proto: ast::proto_shared,\n+    let t_fn = ty::mk_fn(tcx, {proto: ast::proto_box,\n                                inputs: t_inputs, output: t_obj.ty,\n                                ret_style: ast::return_val, constraints: []});\n     let tpt = {bounds: ty_param_bounds(tcx, mode, ty_params), ty: t_fn};\n@@ -697,7 +697,7 @@ mod collect {\n                 }\n                 // FIXME: this will be different for constrained types\n                 ty::mk_fn(cx.tcx,\n-                          {proto: ast::proto_shared,\n+                          {proto: ast::proto_box,\n                            inputs: args, output: tag_ty,\n                            ret_style: ast::return_val, constraints: []})\n             };\n@@ -799,13 +799,13 @@ mod collect {\n             let t_res = ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n                                    params);\n             let t_ctor = ty::mk_fn(cx.tcx, {\n-                proto: ast::proto_shared,\n+                proto: ast::proto_box,\n                 inputs: [{mode: ast::by_copy with t_arg}],\n                 output: t_res,\n                 ret_style: ast::return_val, constraints: []\n             });\n             let t_dtor = ty::mk_fn(cx.tcx, {\n-                proto: ast::proto_shared,\n+                proto: ast::proto_box,\n                 inputs: [t_arg], output: ty::mk_nil(cx.tcx),\n                 ret_style: ast::return_val, constraints: []\n             });\n@@ -2179,7 +2179,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         fn lower_bound_proto(proto: ast::proto) -> ast::proto {\n             // FIXME: This is right for bare fns, possibly not others\n             alt proto {\n-              ast::proto_bare. { ast::proto_shared }\n+              ast::proto_bare. { ast::proto_box }\n               _ { proto }\n             }\n         }\n@@ -2632,7 +2632,7 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     let fcx: @fn_ctxt =\n         @{ret_ty: rty,\n           purity: ast::pure_fn,\n-          proto: ast::proto_shared,\n+          proto: ast::proto_box,\n           var_bindings: ty::unify::mk_var_bindings(),\n           locals: new_int_hash::<int>(),\n           next_var_id: @mutable 0,"}, {"sha": "1c053b4ed1aede37fdacbca9f23f8e8e29dc70d8", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -111,10 +111,10 @@ tag pat_ {\n tag mutability { mut; imm; maybe_mut; }\n \n tag proto {\n-    proto_bare;\n-    proto_send;\n-    proto_shared;\n-    proto_block;\n+    proto_bare;    // fn\n+    proto_uniq;    // fn~\n+    proto_box;     // fn@\n+    proto_block;   // block\n }\n \n tag binop {"}, {"sha": "92efa7bbd82421303c252bcc9d13c30f08a3b1f4", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -514,10 +514,10 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n         t = parse_ty_fn(proto, p);\n     } else if eat_word(p, \"block\") {\n         t = parse_ty_fn(ast::proto_block, p);\n-    } else if eat_word(p, \"fn@\") {\n-        t = parse_ty_fn(ast::proto_shared, p);\n+    } else if eat_word(p, \"lambda\") {\n+        t = parse_ty_fn(ast::proto_box, p);\n     } else if eat_word(p, \"sendfn\") {\n-        t = parse_ty_fn(ast::proto_send, p);\n+        t = parse_ty_fn(ast::proto_uniq, p);\n     } else if eat_word(p, \"obj\") {\n         t = ast::ty_obj(parse_ty_methods(p, false));\n     } else if p.peek() == token::MOD_SEP || is_ident(p.peek()) {\n@@ -821,10 +821,10 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         ret pexpr(parse_fn_expr(p, proto));\n     } else if eat_word(p, \"block\") {\n         ret pexpr(parse_fn_expr(p, ast::proto_block));\n-    } else if eat_word(p, \"fn@\") {\n-        ret pexpr(parse_fn_expr(p, ast::proto_shared));\n+    } else if eat_word(p, \"lambda\") {\n+        ret pexpr(parse_fn_expr(p, ast::proto_box));\n     } else if eat_word(p, \"sendfn\") {\n-        ret pexpr(parse_fn_expr(p, ast::proto_send));\n+        ret pexpr(parse_fn_expr(p, ast::proto_uniq));\n     } else if eat_word(p, \"unchecked\") {\n         ret pexpr(parse_block_expr(p, lo, ast::unchecked_blk));\n     } else if eat_word(p, \"unsafe\") {\n@@ -2113,7 +2113,10 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n fn parse_fn_ty_proto(p: parser) -> ast::proto {\n     if p.peek() == token::AT {\n         p.bump();\n-        ast::proto_shared\n+        ast::proto_box\n+    } else if p.peek() == token::TILDE {\n+        p.bump();\n+        ast::proto_uniq\n     } else {\n         ast::proto_bare\n     }"}, {"sha": "b35ccc456d52944d46df7e2de7d65b98677ff9fd", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -1684,8 +1684,8 @@ fn proto_to_str(p: ast::proto) -> str {\n     ret alt p {\n           ast::proto_bare. { \"fn\" }\n           ast::proto_block. { \"block\" }\n-          ast::proto_send. { \"sendfn\" }\n-          ast::proto_shared. { \"fn@\" }\n+          ast::proto_uniq. { \"fn~\" }\n+          ast::proto_box. { \"fn@\" }\n         };\n }\n "}, {"sha": "ca8701c692e8f794f6db817ce6cf7bf46a1c8c17", "filename": "src/test/compile-fail/sendfn-is-not-a-lambda.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Ftest%2Fcompile-fail%2Fsendfn-is-not-a-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Ftest%2Fcompile-fail%2Fsendfn-is-not-a-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsendfn-is-not-a-lambda.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -1,10 +1,8 @@\n-// error-pattern: mismatched types: expected `fn@(++uint) -> uint`\n-\n fn test(f: fn@(uint) -> uint) -> uint {\n     ret f(22u);\n }\n \n fn main() {\n-    let f = sendfn(x: uint) -> uint { ret 4u; };\n-    log(debug, test(f));\n+    let f = fn~(x: uint) -> uint { ret 4u; };\n+    log(debug, test(f)); //! ERROR expected `fn@(++uint) -> uint`\n }"}, {"sha": "e6a78c3d7625aa429c5a384c2759694c71e999cb", "filename": "src/test/pretty/cap-clause.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Ftest%2Fpretty%2Fcap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Ftest%2Fpretty%2Fcap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fcap-clause.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     let x = 1;\n     let y = 2;\n     let z = 3;\n-    let s1 = sendfn[copy x]() -> int { x + y };\n-    let s2 = sendfn[copy x; move y]() -> int { x + y };\n-    let s3 = sendfn[move z]() -> int { z };\n+    let s1 = fn~[copy x]() -> int { x + y };\n+    let s2 = fn~[copy x; move y]() -> int { x + y };\n+    let s3 = fn~[move z]() -> int { z };\n }"}, {"sha": "f70e6bf727c55152fab9c54923ba2854e4bd6abb", "filename": "src/test/run-fail/unwind-lambda.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-lambda.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -8,9 +8,10 @@ fn main() {\n         macerate(*tasties);\n     } (carrots, { |food|\n         let mush = food + cheese;\n-        let _ = fn@() {\n+        let f = fn@() {\n             let chew = mush + cheese;\n             fail \"so yummy\"\n-        } ();\n+        };\n+        f();\n     });\n }\n\\ No newline at end of file"}, {"sha": "9ef41f5bc6077fdee53e440c29d60d750413f423", "filename": "src/test/run-pass/lambda-no-leak.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Ftest%2Frun-pass%2Flambda-no-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Ftest%2Frun-pass%2Flambda-no-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-no-leak.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -2,6 +2,6 @@\n fn force(f: fn@()) { f() }\n fn main() {\n     let x = 7;\n-    let _ = fn@ () { log(error, x); };\n-    force(fn@ () { log(error, x); });\n+    let _f = fn@() { log(error, x); };\n+    force(fn@() { log(error, x); });\n }"}, {"sha": "7c9a6e7aca5f326143df8e8609085fa1993353ab", "filename": "src/test/run-pass/uniq-fn-leak.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Ftest%2Frun-pass%2Funiq-fn-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b911587dfed1cc1973b361865c3632a2e2cffde/src%2Ftest%2Frun-pass%2Funiq-fn-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-fn-leak.rs?ref=8b911587dfed1cc1973b361865c3632a2e2cffde", "patch": "@@ -0,0 +1,23 @@\n+// xfail-test\n+    tag maybe_pointy {\n+        none;\n+        p(@pointy);\n+    }\n+\n+    type pointy = {\n+        mutable a : maybe_pointy,\n+        d : sendfn()->(),\n+    };\n+\n+    fn empty_pointy() -> @pointy {\n+        ret @{\n+            mutable a : none,\n+            d : sendfn()->(){},\n+        }\n+    }\n+\n+    fn main()\n+    {\n+        let v = empty_pointy();\n+        v.a = p(v);\n+    }"}]}