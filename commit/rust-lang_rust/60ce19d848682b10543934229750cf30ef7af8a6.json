{"sha": "60ce19d848682b10543934229750cf30ef7af8a6", "node_id": "C_kwDOAAsO6NoAKDYwY2UxOWQ4NDg2ODJiMTA1NDM5MzQyMjk3NTBjZjMwZWY3YWY4YTY", "commit": {"author": {"name": "nils", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-03-28T10:51:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-28T10:51:14Z"}, "message": "Rollup merge of #109629 - aliemjay:remove-givens, r=lcnr\n\nremove obsolete `givens` from regionck\n\nRevives #107376. The only change is the last commit (https://github.com/rust-lang/rust/pull/109629/commits/2a3177a8bcc4c5a5285dc2908a0f1ce98e9a6377) which should fix the regression.\n\nFixes https://github.com/rust-lang/rust/issues/106567\n\nr? `@lcnr`", "tree": {"sha": "3673b02246250062d04b27623f645df4869dab92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3673b02246250062d04b27623f645df4869dab92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60ce19d848682b10543934229750cf30ef7af8a6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkIsaiCRBK7hj4Ov3rIwAA88kIABn3xfqPR5MtS3gDXfHeY7Hi\nEtX33CYa+aRK2OAWh14V7MJ15NP0W59sJkwiwbK3HVVZpYot6NAmjcVE412CvfuO\ntALQqs0Rlse+4zSIau5rWNlolBI711xCHROKUWFL47J9Ulnt45zZTTX62ibnMy1h\nBWXFNF9oXVLaHqv5rus+/1XH12R3vpU+3q5SBYmdrxCmSAsvF9ckQWNCK1yeZgs0\n0bBTMqoU0I/fR2n08Kh/o8RyrWLyCGQg5/POts2ABOjRMWL1lFGYKeuPWln6/2pN\nPVS75hcpkzFf9Y+dK5bOfZiHYyLpohj/4kNPW93AFfYZxPKRM0q8afKq4hzZvTE=\n=zfJ6\n-----END PGP SIGNATURE-----\n", "payload": "tree 3673b02246250062d04b27623f645df4869dab92\nparent ef5ef53a6f5cc6d40a45e8041ea9e720b948108b\nparent 2a3177a8bcc4c5a5285dc2908a0f1ce98e9a6377\nauthor nils <48135649+Nilstrieb@users.noreply.github.com> 1680000674 +0200\ncommitter GitHub <noreply@github.com> 1680000674 +0200\n\nRollup merge of #109629 - aliemjay:remove-givens, r=lcnr\n\nremove obsolete `givens` from regionck\n\nRevives #107376. The only change is the last commit (https://github.com/rust-lang/rust/pull/109629/commits/2a3177a8bcc4c5a5285dc2908a0f1ce98e9a6377) which should fix the regression.\n\nFixes https://github.com/rust-lang/rust/issues/106567\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60ce19d848682b10543934229750cf30ef7af8a6", "html_url": "https://github.com/rust-lang/rust/commit/60ce19d848682b10543934229750cf30ef7af8a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60ce19d848682b10543934229750cf30ef7af8a6/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef5ef53a6f5cc6d40a45e8041ea9e720b948108b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5ef53a6f5cc6d40a45e8041ea9e720b948108b", "html_url": "https://github.com/rust-lang/rust/commit/ef5ef53a6f5cc6d40a45e8041ea9e720b948108b"}, {"sha": "2a3177a8bcc4c5a5285dc2908a0f1ce98e9a6377", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a3177a8bcc4c5a5285dc2908a0f1ce98e9a6377", "html_url": "https://github.com/rust-lang/rust/commit/2a3177a8bcc4c5a5285dc2908a0f1ce98e9a6377"}], "stats": {"total": 266, "additions": 114, "deletions": 152}, "files": [{"sha": "2d509a114ad2e2272108700e5d8bf4aa81d2a0a5", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -330,7 +330,6 @@ fn compare_method_predicate_entailment<'tcx>(\n     // lifetime parameters.\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys.clone()),\n     );\n     infcx.process_registered_region_obligations(\n@@ -727,7 +726,6 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     // lifetime parameters.\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys),\n     );\n     infcx\n@@ -2065,8 +2063,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_def_id, assumed_wf_types);\n-    let outlives_environment =\n-        OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n+    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n     infcx.err_ctxt().check_region_obligations_and_report_errors(\n         impl_ty.def_id.expect_local(),"}, {"sha": "d126f7beb10f733b0fd562c36d552b6d617a2ff8", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -114,8 +114,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n         return;\n     }\n \n-    let outlives_environment =\n-        OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n     let _ = infcx\n         .err_ctxt()\n@@ -675,7 +674,6 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     let infcx = tcx.infer_ctxt().build();\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(&infcx),\n         infcx.implied_bounds_tys(param_env, id, wf_tys.clone()),\n     );\n     let region_bound_pairs = outlives_environment.region_bound_pairs();"}, {"sha": "b5bae5788f6b2d825b5b00cb4b746a1e09654924", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -179,7 +179,7 @@ fn get_impl_substs(\n     }\n \n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_def_id, assumed_wf_types);\n-    let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n     let _ =\n         infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {"}, {"sha": "11ff65d0c373a2a82700a5435482b2ecbe57b872", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -238,15 +238,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Note that there are two tests to check that this remains true\n         // (`regions-reassign-{match,let}-bound-pointer.rs`).\n         //\n-        // 2. Things go horribly wrong if we use subtype. The reason for\n-        // THIS is a fairly subtle case involving bound regions. See the\n-        // `givens` field in `region_constraints`, as well as the test\n+        // 2. An outdated issue related to the old HIR borrowck. See the test\n         // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n-        // for details. Short version is that we must sometimes detect\n-        // relationships between specific region variables and regions\n-        // bound in a closure signature, and that detection gets thrown\n-        // off when we substitute fresh region variables here to enable\n-        // subtyping.\n     }\n \n     /// Compute the new expected type and default binding mode from the old ones"}, {"sha": "e98f68ae5a851b05ace2f947404f37e35dc6b97f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -640,11 +640,9 @@ pub fn make_query_region_constraints<'tcx>(\n     outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> QueryRegionConstraints<'tcx> {\n-    let RegionConstraintData { constraints, verifys, givens, member_constraints } =\n-        region_constraints;\n+    let RegionConstraintData { constraints, verifys, member_constraints } = region_constraints;\n \n     assert!(verifys.is_empty());\n-    assert!(givens.is_empty());\n \n     debug!(?constraints);\n "}, {"sha": "cf657756ff534477c967f6b8ceefcf36536c42ad", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_data_structures::intern::Interned;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::PlaceholderRegion;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -132,7 +132,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n \n         let graph = self.construct_graph();\n-        self.expand_givens(&graph);\n         self.expansion(&mut var_data);\n         self.collect_errors(&mut var_data, errors);\n         self.collect_var_errors(&var_data, &graph, errors);\n@@ -164,38 +163,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n-    fn expand_givens(&mut self, graph: &RegionGraph<'_>) {\n-        // Givens are a kind of horrible hack to account for\n-        // constraints like 'c <= '0 that are known to hold due to\n-        // closure signatures (see the comment above on the `givens`\n-        // field). They should go away. But until they do, the role\n-        // of this fn is to account for the transitive nature:\n-        //\n-        //     Given 'c <= '0\n-        //     and   '0 <= '1\n-        //     then  'c <= '1\n-\n-        let seeds: Vec<_> = self.data.givens.iter().cloned().collect();\n-        for (r, vid) in seeds {\n-            // While all things transitively reachable in the graph\n-            // from the variable (`'0` in the example above).\n-            let seed_index = NodeIndex(vid.index() as usize);\n-            for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n-                let succ_index = succ_index.0;\n-\n-                // The first N nodes correspond to the region\n-                // variables. Other nodes correspond to constant\n-                // regions.\n-                if succ_index < self.num_vars() {\n-                    let succ_vid = RegionVid::new(succ_index);\n-\n-                    // Add `'c <= '1`.\n-                    self.data.givens.insert((r, succ_vid));\n-                }\n-            }\n-        }\n-    }\n-\n     /// Gets the LUb of a given region and the empty region\n     fn lub_empty(&self, a_region: Region<'tcx>) -> Result<Region<'tcx>, PlaceholderRegion> {\n         match *a_region {\n@@ -362,18 +329,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ) -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\", a_region, b_vid, b_data);\n \n-        match *a_region {\n-            // Check if this relationship is implied by a given.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                if self.data.givens.contains(&(a_region, b_vid)) {\n-                    debug!(\"given\");\n-                    return false;\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n         match *b_data {\n             VarValue::Empty(empty_ui) => {\n                 let lub = match self.lub_empty(a_region) {"}, {"sha": "9903ffa90bae1588bc724071c04c03791c3791d3", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -869,10 +869,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow().undo_log.opaque_types_in_snapshot(&snapshot.undo_snapshot)\n     }\n \n-    pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n-        self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n-    }\n-\n     pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,"}, {"sha": "47e3dd762b08b2d6f07ce8dd0aa457bfc228ac52", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -1,9 +1,9 @@\n use crate::infer::free_regions::FreeRegionMap;\n-use crate::infer::{GenericKind, InferCtxt};\n+use crate::infer::GenericKind;\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_data_structures::transitive_relation::TransitiveRelationBuilder;\n-use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n+use rustc_middle::ty::{self, Region};\n \n use super::explicit_outlives_bounds;\n \n@@ -75,7 +75,7 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n             region_bound_pairs: Default::default(),\n         };\n \n-        builder.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n+        builder.add_outlives_bounds(explicit_outlives_bounds(param_env));\n \n         builder\n     }\n@@ -89,11 +89,10 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n     /// Create a new `OutlivesEnvironment` with extra outlives bounds.\n     pub fn with_bounds(\n         param_env: ty::ParamEnv<'tcx>,\n-        infcx: Option<&InferCtxt<'tcx>>,\n         extra_bounds: impl IntoIterator<Item = OutlivesBound<'tcx>>,\n     ) -> Self {\n         let mut builder = Self::builder(param_env);\n-        builder.add_outlives_bounds(infcx, extra_bounds);\n+        builder.add_outlives_bounds(extra_bounds);\n         builder.build()\n     }\n \n@@ -120,12 +119,7 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n     }\n \n     /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n-    ///\n-    /// The `infcx` parameter is optional; if the implied bounds may\n-    /// contain inference variables, it must be supplied, in which\n-    /// case we will register \"givens\" on the inference context. (See\n-    /// `RegionConstraintData`.)\n-    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'tcx>>, outlives_bounds: I)\n+    fn add_outlives_bounds<I>(&mut self, outlives_bounds: I)\n     where\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {\n@@ -142,27 +136,17 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n                     self.region_bound_pairs\n                         .insert(ty::OutlivesPredicate(GenericKind::Alias(alias_b), r_a));\n                 }\n-                OutlivesBound::RegionSubRegion(r_a, r_b) => {\n-                    if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {\n-                        infcx\n-                            .expect(\"no infcx provided but region vars found\")\n-                            .add_given(r_a, vid_b);\n-                    } else {\n-                        // In principle, we could record (and take\n-                        // advantage of) every relationship here, but\n-                        // we are also free not to -- it simply means\n-                        // strictly less that we can successfully type\n-                        // check. Right now we only look for things\n-                        // relationships between free regions. (It may\n-                        // also be that we should revise our inference\n-                        // system to be more general and to make use\n-                        // of *every* relationship that arises here,\n-                        // but presently we do not.)\n-                        if r_a.is_free_or_static() && r_b.is_free() {\n-                            self.region_relation.add(r_a, r_b)\n-                        }\n-                    }\n-                }\n+                OutlivesBound::RegionSubRegion(r_a, r_b) => match (*r_a, *r_b) {\n+                    (\n+                        ty::ReStatic | ty::ReEarlyBound(_) | ty::ReFree(_),\n+                        ty::ReStatic | ty::ReEarlyBound(_) | ty::ReFree(_),\n+                    ) => self.region_relation.add(r_a, r_b),\n+                    (ty::ReError(_), _) | (_, ty::ReError(_)) => {}\n+                    // FIXME(#109628): We shouldn't have existential variables in implied bounds.\n+                    // Panic here once the linked issue is resolved!\n+                    (ty::ReVar(_), _) | (_, ty::ReVar(_)) => {}\n+                    _ => bug!(\"add_outlives_bounds: unexpected regions: ({r_a:?}, {r_b:?})\"),\n+                },\n             }\n         }\n     }"}, {"sha": "89ada23c6673aefeaa4ccac65e25ff748ee14a13", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -424,9 +424,6 @@ impl<'tcx> MiniGraph<'tcx> {\n                 &AddConstraint(Constraint::RegSubReg(a, b)) => {\n                     each_edge(a, b);\n                 }\n-                &AddGiven(a, b) => {\n-                    each_edge(a, tcx.mk_re_var(b));\n-                }\n                 &AddVerify(i) => span_bug!(\n                     verifys[i].origin.span(),\n                     \"we never add verifications while doing higher-ranked things\","}, {"sha": "7b272dfd2a4547f3dcba6ab063b12ca39eb816af", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 41, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -7,7 +7,7 @@ use super::{\n     InferCtxtUndoLogs, MiscVariable, RegionVariableOrigin, Rollback, Snapshot, SubregionOrigin,\n };\n \n-use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::UndoLogs;\n@@ -104,26 +104,6 @@ pub struct RegionConstraintData<'tcx> {\n     /// An example is a `A <= B` where neither `A` nor `B` are\n     /// inference variables.\n     pub verifys: Vec<Verify<'tcx>>,\n-\n-    /// A \"given\" is a relationship that is known to hold. In\n-    /// particular, we often know from closure fn signatures that a\n-    /// particular free region must be a subregion of a region\n-    /// variable:\n-    ///\n-    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n-    ///\n-    /// In situations like this, `'b` is in fact a region variable\n-    /// introduced by the call to `iter()`, and `'a` is a bound region\n-    /// on the closure (as indicated by the `<'a>` prefix). If we are\n-    /// naive, we wind up inferring that `'b` must be `'static`,\n-    /// because we require that it be greater than `'a` and we do not\n-    /// know what `'a` is precisely.\n-    ///\n-    /// This hashmap is used to avoid that naive scenario. Basically\n-    /// we record the fact that `'a <= 'b` is implied by the fn\n-    /// signature, and then ignore the constraint when solving\n-    /// equations. This is a bit of a hack but seems to work.\n-    pub givens: FxIndexSet<(Region<'tcx>, ty::RegionVid)>,\n }\n \n /// Represents a constraint that influences the inference process.\n@@ -297,9 +277,6 @@ pub(crate) enum UndoLog<'tcx> {\n     /// We added the given `verify`.\n     AddVerify(usize),\n \n-    /// We added the given `given`.\n-    AddGiven(Region<'tcx>, ty::RegionVid),\n-\n     /// We added a GLB/LUB \"combination variable\".\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n }\n@@ -348,9 +325,6 @@ impl<'tcx> RegionConstraintStorage<'tcx> {\n                 self.data.verifys.pop();\n                 assert_eq!(self.data.verifys.len(), index);\n             }\n-            AddGiven(sub, sup) => {\n-                self.data.givens.remove(&(sub, sup));\n-            }\n             AddCombination(Glb, ref regions) => {\n                 self.glbs.remove(regions);\n             }\n@@ -492,15 +466,6 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         self.undo_log.push(AddVerify(index));\n     }\n \n-    pub(super) fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n-        // cannot add givens once regions are resolved\n-        if self.data.givens.insert((sub, sup)) {\n-            debug!(\"add_given({:?} <= {:?})\", sub, sup);\n-\n-            self.undo_log.push(AddGiven(sub, sup));\n-        }\n-    }\n-\n     pub(super) fn make_eqregion(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n@@ -804,11 +769,8 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     /// Returns `true` if this region constraint data contains no constraints, and `false`\n     /// otherwise.\n     pub fn is_empty(&self) -> bool {\n-        let RegionConstraintData { constraints, member_constraints, verifys, givens } = self;\n-        constraints.is_empty()\n-            && member_constraints.is_empty()\n-            && verifys.is_empty()\n-            && givens.is_empty()\n+        let RegionConstraintData { constraints, member_constraints, verifys } = self;\n+        constraints.is_empty() && member_constraints.is_empty() && verifys.is_empty()\n     }\n }\n "}, {"sha": "d21cb63b06c5693cfd744965608cce32a7406ffe", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -402,7 +402,6 @@ fn resolve_negative_obligation<'tcx>(\n     let wf_tys = ocx.assumed_wf_types(param_env, DUMMY_SP, body_def_id);\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(&infcx),\n         infcx.implied_bounds_tys(param_env, body_def_id, wf_tys),\n     );\n "}, {"sha": "0bde43c54df99892fba558fa3bef7ac282986fb5", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -111,7 +111,6 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n             // Check regions assuming the self type of the impl is WF\n             let outlives_env = OutlivesEnvironment::with_bounds(\n                 param_env,\n-                Some(&infcx),\n                 infcx.implied_bounds_tys(\n                     param_env,\n                     parent_cause.body_id,"}, {"sha": "6d2dc94845d0d6dfb0121c6dfa55c1bdb8373988", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -3,7 +3,8 @@ use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use crate::traits::query::NoSolution;\n use crate::traits::{ObligationCause, ObligationCtxt};\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_middle::ty::{self, ParamEnv, Ty};\n+use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n+use rustc_middle::ty::{self, ParamEnv, Ty, TypeFolder, TypeVisitableExt};\n use rustc_span::def_id::LocalDefId;\n \n pub use rustc_middle::traits::query::OutlivesBound;\n@@ -52,6 +53,10 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n         body_id: LocalDefId,\n         ty: Ty<'tcx>,\n     ) -> Vec<OutlivesBound<'tcx>> {\n+        let ty = self.resolve_vars_if_possible(ty);\n+        let ty = OpportunisticRegionResolver::new(self).fold_ty(ty);\n+        assert!(!ty.needs_infer());\n+\n         let span = self.tcx.def_span(body_id);\n         let result = param_env\n             .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n@@ -106,10 +111,7 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n         tys: FxIndexSet<Ty<'tcx>>,\n     ) -> Bounds<'a, 'tcx> {\n         tys.into_iter()\n-            .map(move |ty| {\n-                let ty = self.resolve_vars_if_possible(ty);\n-                self.implied_outlives_bounds(param_env, body_id, ty)\n-            })\n+            .map(move |ty| self.implied_outlives_bounds(param_env, body_id, ty))\n             .flatten()\n     }\n }"}, {"sha": "9e1e3feaeec9fafb022b3a1d7e4660d8e682e27f", "filename": "tests/ui/implied-bounds/ice-unbound-region-vars.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/tests%2Fui%2Fimplied-bounds%2Fice-unbound-region-vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/tests%2Fui%2Fimplied-bounds%2Fice-unbound-region-vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fice-unbound-region-vars.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -0,0 +1,24 @@\n+// Because of #109628, we can have unbounded region vars in implied bounds.\n+// Make sure we don't ICE in this case!\n+//\n+// check-pass\n+\n+pub trait MapAccess {\n+    type Error;\n+    fn next_key_seed(&mut self) -> Option<Self::Error>;\n+}\n+\n+struct Access<'a> {\n+    _marker: std::marker::PhantomData<&'a ()>,\n+}\n+\n+// implied_bounds(Option<Self::Error>) = ['?1: 'a, ]\n+// where '?1 is a fresh region var.\n+impl<'a, 'b: 'a> MapAccess for Access<'a> {\n+    type Error = ();\n+    fn next_key_seed(&mut self) -> Option<Self::Error> {\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f776fc98a9edeb24b3ba13298659d652e38884c2", "filename": "tests/ui/implied-bounds/normalization.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/60ce19d848682b10543934229750cf30ef7af8a6/tests%2Fui%2Fimplied-bounds%2Fnormalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ce19d848682b10543934229750cf30ef7af8a6/tests%2Fui%2Fimplied-bounds%2Fnormalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fnormalization.rs?ref=60ce19d848682b10543934229750cf30ef7af8a6", "patch": "@@ -0,0 +1,58 @@\n+// Test that we get implied bounds from complex projections after normalization.\n+\n+// check-pass\n+\n+// implementations wil ensure that\n+// WF(<T as Combine<'a>>::Ty) implies T: 'a\n+trait Combine<'a> {\n+    type Ty;\n+}\n+\n+impl<'a, T: 'a> Combine<'a> for Box<T> {\n+    type Ty = &'a T;\n+}\n+\n+// ======= Wrappers ======\n+\n+// normalizes to a projection\n+struct WrapA<T>(T);\n+impl<'a, T> Combine<'a> for WrapA<T>\n+where\n+    T: Combine<'a>,\n+{\n+    type Ty = T::Ty;\n+}\n+\n+// <WrapB<T> as Combine<'a>>::Ty normalizes to a type variable ?X\n+// with constraint `<T as Combine<'a>>::Ty == ?X`\n+struct WrapB<T>(T);\n+impl<'a, X, T> Combine<'a> for WrapB<T>\n+where\n+    T: Combine<'a, Ty = X>,\n+{\n+    type Ty = X;\n+}\n+\n+// <WrapC<T> as Combine<'a>>::Ty normalizes to `&'a &'?x ()`\n+// with constraint `<T as Combine<'a>>::Ty == &'a &'?x ()`\n+struct WrapC<T>(T);\n+impl<'a, 'x: 'a, T> Combine<'a> for WrapC<T>\n+where\n+    T: Combine<'a, Ty = &'a &'x ()>,\n+{\n+    type Ty = &'a &'x ();\n+}\n+\n+//==== Test implied bounds ======\n+\n+fn test_wrap<'a, 'b, 'c1, 'c2, A, B>(\n+    _: <WrapA<Box<A>> as Combine<'a>>::Ty,        // normalized: &'a A\n+    _: <WrapB<Box<B>> as Combine<'b>>::Ty,        // normalized: &'b B\n+    _: <WrapC<Box<&'c1 ()>> as Combine<'c2>>::Ty, // normalized: &'c2 &'c1 ()\n+) {\n+    None::<&'a A>;\n+    None::<&'b B>;\n+    None::<&'c2 &'c1 ()>;\n+}\n+\n+fn main() {}"}]}