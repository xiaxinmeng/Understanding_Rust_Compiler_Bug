{"sha": "c70bbea257d43242fa9f700d099c4a8a8eae2971", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MGJiZWEyNTdkNDMyNDJmYTlmNzAwZDA5OWM0YThhOGVhZTI5NzE=", "commit": {"author": {"name": "JCTyBlaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-11-05T14:18:28Z"}, "committer": {"name": "JCTyBlaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-11-05T14:18:28Z"}, "message": "Move to use of thread termination hook for vector re-use,\n convert validate atomic op to use shared reference and get_raw\n instead of get_raw_mut so it can be used for validate_atomic_load as well", "tree": {"sha": "56d89338102727aa36d8d6d4f5deaec240b66e98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56d89338102727aa36d8d6d4f5deaec240b66e98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c70bbea257d43242fa9f700d099c4a8a8eae2971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c70bbea257d43242fa9f700d099c4a8a8eae2971", "html_url": "https://github.com/rust-lang/rust/commit/c70bbea257d43242fa9f700d099c4a8a8eae2971", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c70bbea257d43242fa9f700d099c4a8a8eae2971/comments", "author": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cb6b8da3f6ca2da1139c91754d520bf2d354f31", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cb6b8da3f6ca2da1139c91754d520bf2d354f31", "html_url": "https://github.com/rust-lang/rust/commit/9cb6b8da3f6ca2da1139c91754d520bf2d354f31"}], "stats": {"total": 176, "additions": 91, "deletions": 85}, "files": [{"sha": "153e63b77dfd8da88d042d23c7d377df3efbf521", "filename": "src/data_race.rs", "status": "modified", "additions": 90, "deletions": 85, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/c70bbea257d43242fa9f700d099c4a8a8eae2971/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70bbea257d43242fa9f700d099c4a8a8eae2971/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=c70bbea257d43242fa9f700d099c4a8a8eae2971", "patch": "@@ -159,61 +159,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         &self, place: MPlaceTy<'tcx, Tag>, atomic: AtomicReadOp\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n-        let data_race = &*this.memory.extra.data_race;\n-        if data_race.multi_threaded.get() {\n-\n-            // Load an log the atomic operation\n-            //  the memory access has to be `get_raw` since otherwise this despite only \n-            //  mutating MemoryExtra will still trigger errors on read-only memory\n-            let place_ptr = place.ptr.assert_ptr();\n-            let size = place.layout.size;\n-            let alloc_meta =  &this.memory.get_raw(place_ptr.alloc_id)?.extra.data_race;\n-            log::trace!(\n-                \"Atomic op({}) with ordering {:?} on memory({:?}, offset={}, size={})\",\n-                \"Atomic load\", &atomic, place_ptr.alloc_id, place_ptr.offset.bytes(), size.bytes()\n-            );\n-\n-            // Perform the atomic operation\n-            let data_race = &alloc_meta.global;\n-            data_race.maybe_perform_sync_operation(move |index, mut clocks| {\n-                for (_,range) in alloc_meta.alloc_ranges.borrow_mut().iter_mut(place_ptr.offset, size) {\n-                    let res = if atomic == AtomicReadOp::Relaxed {\n-                        range.load_relaxed(&mut *clocks, index)\n-                    }else{\n-                        range.acquire(&mut *clocks, index)\n-                    };\n-                    if let Err(DataRace) = res {\n-                        mem::drop(clocks);\n-                        return VClockAlloc::report_data_race(\n-                            &alloc_meta.global, range, \"Atomic load\", true,\n-                            place_ptr, size\n-                        );\n-                    }\n-                }\n-                Ok(())\n-            })?;\n-\n-            // Log changes to atomic memory\n-            if log::log_enabled!(log::Level::Trace) {\n-                for (_,range) in alloc_meta.alloc_ranges.borrow().iter(place_ptr.offset, size) {\n-                    log::trace!(\n-                        \"Updated atomic memory({:?}, offset={}, size={}) to {:#?}\",\n-                        place.ptr.assert_ptr().alloc_id, place_ptr.offset.bytes(), size.bytes(),\n-                        range.atomic_ops\n-                    );\n+        this.validate_atomic_op(\n+            place, atomic, \"Atomic Load\",\n+            move |memory, clocks, index, atomic| {\n+                if atomic == AtomicReadOp::Relaxed {\n+                    memory.load_relaxed(&mut *clocks, index)\n+                }else{\n+                    memory.acquire(&mut *clocks, index)\n                 }\n             }\n-        }\n-        Ok(())\n+        )\n     }\n \n     /// Update the data-race detector for an atomic write occuring at the\n     ///  associated memory-place and on the current thread\n     fn validate_atomic_store(\n         &mut self, place: MPlaceTy<'tcx, Tag>, atomic: AtomicWriteOp\n     ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        this.validate_atomic_op_mut(\n+        let this = self.eval_context_ref();\n+        this.validate_atomic_op(\n             place, atomic, \"Atomic Store\",\n             move |memory, clocks, index, atomic| {\n                 if atomic == AtomicWriteOp::Relaxed {\n@@ -233,8 +197,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         use AtomicRWOp::*;\n         let acquire = matches!(atomic, Acquire | AcqRel | SeqCst);\n         let release = matches!(atomic, Release | AcqRel | SeqCst);\n-        let this = self.eval_context_mut();\n-        this.validate_atomic_op_mut(\n+        let this = self.eval_context_ref();\n+        this.validate_atomic_op(\n             place, atomic, \"Atomic RMW\",\n             move |memory, clocks, index, _| {\n                 if acquire {\n@@ -276,25 +240,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n \n-    /// Generic atomic operation implementation, this however\n-    ///  cannot be used for the atomic read operation since\n-    ///  that requires non mutable memory access to not trigger\n-    ///  the writing to read-only memory errors during `get_raw_mut`\n-    fn validate_atomic_op_mut<A: Debug + Copy>(\n-        &mut self, place: MPlaceTy<'tcx, Tag>,\n+    /// Generic atomic operation implementation,\n+    ///  this accesses memory via get_raw instead of\n+    ///  get_raw_mut, due to issues calling get_raw_mut\n+    ///  for atomic loads from read-only memory\n+    /// FIXME: is this valid, or should get_raw_mut be used for\n+    ///  atomic-stores/atomic-rmw?\n+    fn validate_atomic_op<A: Debug + Copy>(\n+        &self, place: MPlaceTy<'tcx, Tag>,\n         atomic: A, description: &str,\n         mut op: impl FnMut(\n             &mut MemoryCellClocks, &mut ThreadClockSet, VectorIdx, A\n         ) -> Result<(), DataRace>\n     ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n+        let this = self.eval_context_ref();\n         let data_race = &*this.memory.extra.data_race;\n         if data_race.multi_threaded.get() {\n \n             // Load an log the atomic operation\n             let place_ptr = place.ptr.assert_ptr();\n             let size = place.layout.size;\n-            let alloc_meta =  &mut this.memory.get_raw_mut(place_ptr.alloc_id)?.extra.data_race;\n+            let alloc_meta =  &this.memory.get_raw(place_ptr.alloc_id)?.extra.data_race;\n             log::trace!(\n                 \"Atomic op({}) with ordering {:?} on memory({:?}, offset={}, size={})\",\n                 description, &atomic, place_ptr.alloc_id, place_ptr.offset.bytes(), size.bytes()\n@@ -800,6 +766,29 @@ impl ThreadClockSet {\n     }\n }\n \n+/// Extra metadata associated with a thread\n+#[derive(Debug, Clone, Default)]\n+struct ThreadExtraState {\n+\n+    /// The current vector index in use by the\n+    ///  thread currently, this is set to None\n+    ///  after the vector index has been re-used\n+    vector_index: Option<VectorIdx>,\n+\n+    /// The name of the thread, updated for better\n+    ///  diagnostics when reporting detected data\n+    ///  races\n+    thread_name: Option<Box<str>>,\n+    \n+    /// Thread termination vector clock, this\n+    ///  is set on thread termination and is used\n+    ///  for joining on threads that have already\n+    ///  terminated. This should be used first\n+    ///  on joining as there is the possibility\n+    ///  that `vector_index` is None in some cases\n+    termination_vector_clock: Option<VClock>,\n+}\n+\n /// Global data-race detection state, contains the currently\n ///  executing thread as well as the vector-clocks associated\n ///  with each of the threads.\n@@ -822,18 +811,18 @@ pub struct GlobalState {\n     /// Mapping of a given vector index to the current thread\n     ///  that the execution is representing, this may change\n     ///  if a vector index is re-assigned to a new thread\n-    vector_info: RefCell<IndexVec<VectorIdx, ThreadId>>, //FIXME: make option\n+    vector_info: RefCell<IndexVec<VectorIdx, ThreadId>>,\n \n-    /// The mapping of a given thread to a known vector clock\n-    thread_info: RefCell<IndexVec<ThreadId, (Option<VectorIdx>, Option<Box<str>>)>>,\n+    /// The mapping of a given thread to assocaited thread metadata\n+    thread_info: RefCell<IndexVec<ThreadId, ThreadExtraState>>,\n \n     /// The current vector index being executed\n     current_index: Cell<VectorIdx>,\n \n     /// Potential vector indices that could be re-used on thread creation\n-    ///  values are inserted here on thread join events, and can be\n-    ///  re-used once the vector clocks of all current threads\n-    ///  are equal to the vector clock of the joined thread\n+    ///  values are inserted here on thread termination, vector index values\n+    ///  are then re-used once all the termination event happens-before all\n+    ///  existing thread-clocks\n     reuse_candidates: RefCell<FxHashSet<VectorIdx>>,\n }\n impl GlobalState {\n@@ -856,8 +845,12 @@ impl GlobalState {\n         let index = global_state.vector_clocks.borrow_mut().push(ThreadClockSet::default());\n         global_state.vector_info.borrow_mut().push(ThreadId::new(0));\n         global_state.thread_info.borrow_mut().push(\n-            (Some(index), Some(\"main\".to_string().into_boxed_str())\n-        ));\n+            ThreadExtraState {\n+                vector_index: Some(index),\n+                thread_name: Some(\"main\".to_string().into_boxed_str()),\n+                termination_vector_clock: None\n+            }\n+        );\n \n         global_state\n     }\n@@ -873,10 +866,9 @@ impl GlobalState {\n                 clock.clock[candidate] == target_timestamp\n             }) {\n                 // All vector clocks for each vector index are equal to\n-                //  the target timestamp, therefore since the thread has\n-                //  terminated and cannot update the vector clock.\n-                // No more data-races involving this vector index are possible\n-                //  so it can be re-used\n+                //  the target timestamp, and the thread is known to have\n+                //  terminated, therefore this vector clock index cannot\n+                //  report any more data-races\n                 assert!(reuse.remove(&candidate));\n                 return Some(candidate)\n             }\n@@ -916,7 +908,7 @@ impl GlobalState {\n \n             // Mark the thread the vector index was associated with as no longer\n             //  representing a thread index\n-            thread_info[old_thread].0 = None;\n+            thread_info[old_thread].vector_index = None;\n \n             reuse_index\n         }else{\n@@ -927,7 +919,7 @@ impl GlobalState {\n         };\n \n         // Mark the chosen vector index as in use by the thread\n-        thread_info[thread].0 = Some(created_index);\n+        thread_info[thread].vector_index = Some(created_index);\n \n         // Create a thread clock set if applicable\n         let mut vector_clocks = self.vector_clocks.borrow_mut();\n@@ -952,15 +944,13 @@ impl GlobalState {\n \n     /// Hook on a thread join to update the implicit happens-before relation\n     ///  between the joined thead and the current thread.\n-    /// Called after the join has occured, and hence implicitly also states\n-    ///  that the thread must have terminated as well\n     #[inline]\n     pub fn thread_joined(&self, current_thread: ThreadId, join_thread: ThreadId) {\n         let (current_index, join_index) = {\n             let thread_info = self.thread_info.borrow();\n-            let current_index = thread_info[current_thread].0\n+            let current_index = thread_info[current_thread].vector_index\n                 .expect(\"Joining into thread with no assigned vector\");\n-            let join_index = thread_info[join_thread].0\n+            let join_index = thread_info[join_thread].vector_index\n                 .expect(\"Joining thread with no assigned vector\");\n             (current_index, join_index)\n         };\n@@ -976,16 +966,31 @@ impl GlobalState {\n         current.join_with(join);\n \n         // Post increment clocks after atomic operation\n+        //  the join clock is not incremented, since there will\n+        //  be no future events, also if it was incremented\n+        //  the thread re-use condition would never pass\n         current.increment_clock(current_index);\n-        join.increment_clock(join_index);\n+    }\n+\n+    /// On thread termination, the vector-clock may re-used\n+    ///  in the future once all remaining thread-clocks catch\n+    ///  up with the time index of the terminated thread\n+    #[inline]\n+    pub fn thread_terminated(&self, terminated_thread: ThreadId) {\n+        let mut thread_info = self.thread_info.borrow_mut();\n+        let termination_meta = &mut thread_info[terminated_thread];\n+\n+        // Find the terminated index & setup the termination vector-clock\n+        //  in case thread join is called in the future after the thread\n+        //  has been re-used\n+        let terminated_index = termination_meta.vector_index\n+            .expect(\"Joining into thread with no assigned vector\");\n+        let vector_clocks = self.vector_clocks.borrow();\n+        termination_meta.termination_vector_clock = Some(vector_clocks[terminated_index].clock.clone());\n \n-        // The joined thread vector clock is a potential candidate\n-        //  for re-use given sufficient time, mark as available once\n-        //  threads have been created. This is because this function\n-        //  is called once join_thread has terminated and such cannot\n-        //  update any-more\n+        // Add this thread as a candidate for re-use\n         let mut reuse = self.reuse_candidates.borrow_mut();\n-        reuse.insert(join_index);\n+        reuse.insert(terminated_index);\n     }\n \n     /// Hook for updating the local tracker of the currently\n@@ -994,7 +999,7 @@ impl GlobalState {\n     #[inline]\n     pub fn thread_set_active(&self, thread: ThreadId) {\n         let thread_info = self.thread_info.borrow();\n-        let vector_idx = thread_info[thread].0\n+        let vector_idx = thread_info[thread].vector_index\n             .expect(\"Setting thread active with no assigned vector\");\n         self.current_index.set(vector_idx);\n     }\n@@ -1007,7 +1012,7 @@ impl GlobalState {\n     pub fn thread_set_name(&self, thread: ThreadId, name: String) {\n         let name = name.into_boxed_str();\n         let mut thread_info = self.thread_info.borrow_mut();\n-        thread_info[thread].1 = Some(name);\n+        thread_info[thread].thread_name = Some(name);\n     }\n \n \n@@ -1036,7 +1041,7 @@ impl GlobalState {\n     ///  returns the id and the name for better diagnostics\n     fn print_thread_metadata(&self, vector: VectorIdx) -> String {\n         let thread = self.vector_info.borrow()[vector];\n-        let thread_name = &self.thread_info.borrow()[thread].1;\n+        let thread_name = &self.thread_info.borrow()[thread].thread_name;\n         if let Some(name) = thread_name {\n             let name: &str = name;\n             format!(\"Thread(id = {:?}, name = {:?})\", thread.to_u32(), &*name)\n@@ -1079,7 +1084,7 @@ impl GlobalState {\n     ///  used by the thread\n     #[inline]\n     fn load_thread_state_mut(&self, thread: ThreadId) -> (VectorIdx, RefMut<'_, ThreadClockSet>) {\n-        let index = self.thread_info.borrow()[thread].0\n+        let index = self.thread_info.borrow()[thread].vector_index\n             .expect(\"Loading thread state for thread with no assigned vector\");\n         let ref_vector = self.vector_clocks.borrow_mut();\n         let clocks = RefMut::map(ref_vector, |vec| &mut vec[index]);"}, {"sha": "976ac816a04852b3aa50d406a71b2eafd17f1114", "filename": "src/thread.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c70bbea257d43242fa9f700d099c4a8a8eae2971/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70bbea257d43242fa9f700d099c4a8a8eae2971/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=c70bbea257d43242fa9f700d099c4a8a8eae2971", "patch": "@@ -452,6 +452,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n                 thread.state = ThreadState::Enabled;\n             }\n         }\n+        data_race.thread_terminated(self.active_thread);\n         return free_tls_statics;\n     }\n "}]}