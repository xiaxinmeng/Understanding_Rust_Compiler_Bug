{"sha": "d9bd4b289f07956819c59704d88d9eed61af3a6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5YmQ0YjI4OWYwNzk1NjgxOWM1OTcwNGQ4OGQ5ZWVkNjFhZjNhNmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-02T22:44:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-02T22:44:53Z"}, "message": "Auto merge of #63228 - Centril:rollup-x39p5ga, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #63107 (Added support for armv7-unknown-linux-gnueabi/musleabi)\n - #63121 (On `format!()` arg count mismatch provide extra info)\n - #63196 (build_helper: try less confusing method names)\n - #63206 (remove unsupported test case)\n - #63208 (Round generator sizes to a multiple of their alignment)\n - #63212 (Pretty print attributes in `print_arg`)\n - #63215 (Clarify semantics of mem::zeroed)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "4186e474003e5f9e5dc416553a89e2088a05b636", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4186e474003e5f9e5dc416553a89e2088a05b636"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9bd4b289f07956819c59704d88d9eed61af3a6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9bd4b289f07956819c59704d88d9eed61af3a6d", "html_url": "https://github.com/rust-lang/rust/commit/d9bd4b289f07956819c59704d88d9eed61af3a6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9bd4b289f07956819c59704d88d9eed61af3a6d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0e40bfba44836ad30051ffb077c1cfc5bf4a59f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0e40bfba44836ad30051ffb077c1cfc5bf4a59f", "html_url": "https://github.com/rust-lang/rust/commit/b0e40bfba44836ad30051ffb077c1cfc5bf4a59f"}, {"sha": "4520a39b94a691f58c4a266e2c9d52406dfac414", "url": "https://api.github.com/repos/rust-lang/rust/commits/4520a39b94a691f58c4a266e2c9d52406dfac414", "html_url": "https://github.com/rust-lang/rust/commit/4520a39b94a691f58c4a266e2c9d52406dfac414"}], "stats": {"total": 997, "additions": 709, "deletions": 288}, "files": [{"sha": "298330869b6847ad21181b2978afdb3db7a5fbb6", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -125,7 +125,9 @@ def v(*args):\n   \"arm-unknown-linux-musleabihf install directory\")\n v(\"musl-root-armv5te\", \"target.armv5te-unknown-linux-musleabi.musl-root\",\n   \"armv5te-unknown-linux-musleabi install directory\")\n-v(\"musl-root-armv7\", \"target.armv7-unknown-linux-musleabihf.musl-root\",\n+v(\"musl-root-armv7\", \"target.armv7-unknown-linux-musleabi.musl-root\",\n+  \"armv7-unknown-linux-musleabi install directory\")\n+v(\"musl-root-armv7hf\", \"target.armv7-unknown-linux-musleabihf.musl-root\",\n   \"armv7-unknown-linux-musleabihf install directory\")\n v(\"musl-root-aarch64\", \"target.aarch64-unknown-linux-musl.musl-root\",\n   \"aarch64-unknown-linux-musl install directory\")"}, {"sha": "c8ea3157dc92b5b9dbb0f5fda43f8455ea3b97c1", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -125,7 +125,7 @@ use std::os::unix::fs::symlink as symlink_file;\n use std::os::windows::fs::symlink_file;\n \n use build_helper::{\n-    mtime, output, run_silent, run_suppressed, t, try_run_silent, try_run_suppressed,\n+    mtime, output, run, run_suppressed, t, try_run, try_run_suppressed,\n };\n use filetime::FileTime;\n \n@@ -682,7 +682,7 @@ impl Build {\n     fn run(&self, cmd: &mut Command) {\n         if self.config.dry_run { return; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n-        run_silent(cmd)\n+        run(cmd)\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails.\n@@ -698,7 +698,7 @@ impl Build {\n     fn try_run(&self, cmd: &mut Command) -> bool {\n         if self.config.dry_run { return true; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n-        try_run_silent(cmd)\n+        try_run(cmd)\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails."}, {"sha": "1f81efd16a7e4ee35e809553d60cbf741f51650f", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1527,7 +1527,7 @@ impl Step for RustcGuide {\n     fn run(self, builder: &Builder<'_>) {\n         let src = builder.src.join(\"src/doc/rustc-guide\");\n         let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n-        try_run_quiet(builder, rustbook_cmd.arg(\"linkcheck\").arg(&src));\n+        try_run(builder, rustbook_cmd.arg(\"linkcheck\").arg(&src));\n     }\n }\n "}, {"sha": "a1aa18922b5c5b9ccac1712c0033ce7e13e959d6", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -45,18 +45,19 @@ pub fn restore_library_path() {\n     }\n }\n \n-pub fn run(cmd: &mut Command) {\n+/// Run the command, printing what we are running.\n+pub fn run_verbose(cmd: &mut Command) {\n     println!(\"running: {:?}\", cmd);\n-    run_silent(cmd);\n+    run(cmd);\n }\n \n-pub fn run_silent(cmd: &mut Command) {\n-    if !try_run_silent(cmd) {\n+pub fn run(cmd: &mut Command) {\n+    if !try_run(cmd) {\n         std::process::exit(1);\n     }\n }\n \n-pub fn try_run_silent(cmd: &mut Command) -> bool {\n+pub fn try_run(cmd: &mut Command) -> bool {\n     let status = match cmd.status() {\n         Ok(status) => status,\n         Err(e) => fail(&format!("}, {"sha": "ae2ea8ef95a6a18fe0661595f8e3f8cd893fffd0", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -64,7 +64,7 @@ RUN env \\\n     env \\\n     CC=arm-linux-gnueabihf-gcc CFLAGS=\"-march=armv7-a\" \\\n     CXX=arm-linux-gnueabihf-g++ CXXFLAGS=\"-march=armv7-a\" \\\n-    bash musl.sh armv7 && \\\n+    bash musl.sh armv7hf && \\\n     env \\\n     CC=aarch64-linux-gnu-gcc \\\n     CXX=aarch64-linux-gnu-g++ \\\n@@ -137,7 +137,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-armv5te=/musl-armv5te \\\n       --musl-root-arm=/musl-arm \\\n       --musl-root-armhf=/musl-armhf \\\n-      --musl-root-armv7=/musl-armv7 \\\n+      --musl-root-armv7hf=/musl-armv7hf \\\n       --musl-root-aarch64=/musl-aarch64 \\\n       --musl-root-mips=/musl-mips \\\n       --musl-root-mipsel=/musl-mipsel \\"}, {"sha": "2ae6c58941e4c62e781600772640c701582f7e3d", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -8,7 +8,8 @@ RUN sed -i 's/^# deb-src/deb-src/' /etc/apt/sources.list\n \n RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y --no-install-recommends \\\n   build-essential \\\n-  gcc-multilib \\\n+# gcc-multilib can not be installed together with gcc-arm-linux-gnueabi\n+  gcc-7-multilib \\\n   libedit-dev \\\n   libgmp-dev \\\n   libisl-dev \\\n@@ -21,11 +22,20 @@ RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y --no\n   unzip \\\n   # Needed for apt-key to work:\n   dirmngr \\\n-  gpg-agent\n+  gpg-agent \\\n+  g++-7-arm-linux-gnueabi\n \n RUN apt-key adv --batch --yes --keyserver keyserver.ubuntu.com --recv-keys 74DA7924C5513486\n RUN add-apt-repository -y 'deb http://apt.dilos.org/dilos dilos2 main'\n \n+WORKDIR /build\n+COPY scripts/musl.sh /build\n+RUN env \\\n+    CC=arm-linux-gnueabi-gcc-7 CFLAGS=\"-march=armv7-a\" \\\n+    CXX=arm-linux-gnueabi-g++-7 CXXFLAGS=\"-march=armv7-a\" \\\n+    bash musl.sh armv7 && \\\n+    rm -rf /build/*\n+\n WORKDIR /tmp\n COPY dist-various-2/shared.sh /tmp/\n COPY dist-various-2/build-cloudabi-toolchain.sh /tmp/\n@@ -58,7 +68,11 @@ ENV \\\n     CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n     AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n     CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n-    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++\n+    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++ \\\n+    CC_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-gcc-7 \\\n+    CXX_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-g++-7 \\\n+    CC=gcc-7 \\\n+    CXX=g++-7\n \n ENV CARGO_TARGET_X86_64_FUCHSIA_AR /usr/local/bin/llvm-ar\n ENV CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS \\\n@@ -81,9 +95,19 @@ ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n ENV TARGETS=$TARGETS,x86_64-unknown-cloudabi\n ENV TARGETS=$TARGETS,x86_64-fortanix-unknown-sgx\n ENV TARGETS=$TARGETS,nvptx64-nvidia-cuda\n+ENV TARGETS=$TARGETS,armv7-unknown-linux-gnueabi\n+ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabi\n \n ENV X86_FORTANIX_SGX_LIBS=\"/x86_64-fortanix-unknown-sgx/lib/\"\n \n+# As per https://bugs.launchpad.net/ubuntu/+source/gcc-defaults/+bug/1300211\n+# we need asm in the search path for gcc-7 (for gnux32) but not in the search path of the\n+# cross compilers.\n+# Luckily one of the folders is /usr/local/include so symlink /usr/include/asm-generic there\n+RUN ln -s /usr/include/asm-generic /usr/local/include/asm\n+\n ENV RUST_CONFIGURE_ARGS --enable-extended --enable-lld --disable-docs \\\n-  --set target.wasm32-wasi.wasi-root=/wasm32-wasi\n+  --set target.wasm32-wasi.wasi-root=/wasm32-wasi \\\n+  --musl-root-armv7=/musl-armv7\n+\n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS"}, {"sha": "86dae985fdb00cc3d6ab67609dd6663de19200b1", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -414,17 +414,20 @@ pub const fn needs_drop<T>() -> bool {\n     intrinsics::needs_drop::<T>()\n }\n \n-/// Creates a value whose bytes are all zero.\n+/// Returns the value of type `T` represented by the all-zero byte-pattern.\n ///\n-/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n-/// It is useful for FFI sometimes, but should generally be avoided.\n+/// This means that, for example, the padding byte in `(u8, u16)` is not\n+/// necessarily zeroed.\n ///\n /// There is no guarantee that an all-zero byte-pattern represents a valid value of\n /// some type `T`. For example, the all-zero byte-pattern is not a valid value\n /// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n /// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n /// that there always is a valid value in a variable it considers initialized.\n ///\n+/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n+/// It is useful for FFI sometimes, but should generally be avoided.\n+///\n /// [zeroed]: union.MaybeUninit.html#method.zeroed\n /// [ub]: ../../reference/behavior-considered-undefined.html\n /// [inv]: union.MaybeUninit.html#initialization-invariant"}, {"sha": "985abaf2c1bd568bd74b8b661c1b1ead6e06cfe4", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -56,16 +56,20 @@ pub struct Argument<'a> {\n /// Specification for the formatting of an argument in the format string.\n #[derive(Copy, Clone, PartialEq)]\n pub struct FormatSpec<'a> {\n-    /// Optionally specified character to fill alignment with\n+    /// Optionally specified character to fill alignment with.\n     pub fill: Option<char>,\n-    /// Optionally specified alignment\n+    /// Optionally specified alignment.\n     pub align: Alignment,\n-    /// Packed version of various flags provided\n+    /// Packed version of various flags provided.\n     pub flags: u32,\n-    /// The integer precision to use\n+    /// The integer precision to use.\n     pub precision: Count,\n-    /// The string width requested for the resulting format\n+    /// The span of the precision formatting flag (for diagnostics).\n+    pub precision_span: Option<InnerSpan>,\n+    /// The string width requested for the resulting format.\n     pub width: Count,\n+    /// The span of the width formatting flag (for diagnostics).\n+    pub width_span: Option<InnerSpan>,\n     /// The descriptor string representing the name of the format desired for\n     /// this argument, this can be empty or any number of characters, although\n     /// it is required to be one word.\n@@ -282,19 +286,24 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Optionally consumes the specified character. If the character is not at\n-    /// the current position, then the current iterator isn't moved and false is\n-    /// returned, otherwise the character is consumed and true is returned.\n+    /// the current position, then the current iterator isn't moved and `false` is\n+    /// returned, otherwise the character is consumed and `true` is returned.\n     fn consume(&mut self, c: char) -> bool {\n-        if let Some(&(_, maybe)) = self.cur.peek() {\n+        self.consume_pos(c).is_some()\n+    }\n+\n+    /// Optionally consumes the specified character. If the character is not at\n+    /// the current position, then the current iterator isn't moved and `None` is\n+    /// returned, otherwise the character is consumed and the current position is\n+    /// returned.\n+    fn consume_pos(&mut self, c: char) -> Option<usize> {\n+        if let Some(&(pos, maybe)) = self.cur.peek() {\n             if c == maybe {\n                 self.cur.next();\n-                true\n-            } else {\n-                false\n+                return Some(pos);\n             }\n-        } else {\n-            false\n         }\n+        None\n     }\n \n     fn to_span_index(&self, pos: usize) -> InnerOffset {\n@@ -462,7 +471,9 @@ impl<'a> Parser<'a> {\n             align: AlignUnknown,\n             flags: 0,\n             precision: CountImplied,\n+            precision_span: None,\n             width: CountImplied,\n+            width_span: None,\n             ty: &self.input[..0],\n         };\n         if !self.consume(':') {\n@@ -499,6 +510,7 @@ impl<'a> Parser<'a> {\n         }\n         // Width and precision\n         let mut havewidth = false;\n+\n         if self.consume('0') {\n             // small ambiguity with '0$' as a format string. In theory this is a\n             // '0' flag and then an ill-formatted format string with just a '$'\n@@ -512,17 +524,28 @@ impl<'a> Parser<'a> {\n             }\n         }\n         if !havewidth {\n-            spec.width = self.count();\n+            let width_span_start = if let Some((pos, _)) = self.cur.peek() {\n+                *pos\n+            } else {\n+                0\n+            };\n+            let (w, sp) = self.count(width_span_start);\n+            spec.width = w;\n+            spec.width_span = sp;\n         }\n-        if self.consume('.') {\n-            if self.consume('*') {\n+        if let Some(start) = self.consume_pos('.') {\n+            if let Some(end) = self.consume_pos('*') {\n                 // Resolve `CountIsNextParam`.\n                 // We can do this immediately as `position` is resolved later.\n                 let i = self.curarg;\n                 self.curarg += 1;\n                 spec.precision = CountIsParam(i);\n+                spec.precision_span =\n+                    Some(self.to_span_index(start).to(self.to_span_index(end + 1)));\n             } else {\n-                spec.precision = self.count();\n+                let (p, sp) = self.count(start);\n+                spec.precision = p;\n+                spec.precision_span = sp;\n             }\n         }\n         // Optional radix followed by the actual format specifier\n@@ -551,24 +574,25 @@ impl<'a> Parser<'a> {\n     /// Parses a Count parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n-    fn count(&mut self) -> Count {\n+    fn count(&mut self, start: usize) -> (Count, Option<InnerSpan>) {\n         if let Some(i) = self.integer() {\n-            if self.consume('$') {\n-                CountIsParam(i)\n+            if let Some(end) = self.consume_pos('$') {\n+                let span = self.to_span_index(start).to(self.to_span_index(end + 1));\n+                (CountIsParam(i), Some(span))\n             } else {\n-                CountIs(i)\n+                (CountIs(i), None)\n             }\n         } else {\n             let tmp = self.cur.clone();\n             let word = self.word();\n             if word.is_empty() {\n                 self.cur = tmp;\n-                CountImplied\n+                (CountImplied, None)\n             } else if self.consume('$') {\n-                CountIsName(Symbol::intern(word))\n+                (CountIsName(Symbol::intern(word)), None)\n             } else {\n                 self.cur = tmp;\n-                CountImplied\n+                (CountImplied, None)\n             }\n         }\n     }"}, {"sha": "e2ddb8810e90a64cd58ed4076b5613ec745152fb", "filename": "src/libfmt_macros/tests.rs", "status": "modified", "additions": 187, "deletions": 146, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibfmt_macros%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibfmt_macros%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Ftests.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -12,6 +12,8 @@ fn fmtdflt() -> FormatSpec<'static> {\n         flags: 0,\n         precision: CountImplied,\n         width: CountImplied,\n+        precision_span: None,\n+        width_span: None,\n         ty: \"\",\n     };\n }\n@@ -79,165 +81,204 @@ fn format_position_nothing_else() {\n }\n #[test]\n fn format_type() {\n-    same(\"{3:a}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentIs(3),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"a\",\n-               },\n-           })]);\n+    same(\n+        \"{3:a}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"a\",\n+            },\n+        })]);\n }\n #[test]\n fn format_align_fill() {\n-    same(\"{3:>}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentIs(3),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignRight,\n-                   flags: 0,\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"\",\n-               },\n-           })]);\n-    same(\"{3:0<}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentIs(3),\n-               format: FormatSpec {\n-                   fill: Some('0'),\n-                   align: AlignLeft,\n-                   flags: 0,\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"\",\n-               },\n-           })]);\n-    same(\"{3:*<abcd}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentIs(3),\n-               format: FormatSpec {\n-                   fill: Some('*'),\n-                   align: AlignLeft,\n-                   flags: 0,\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"abcd\",\n-               },\n-           })]);\n+    same(\n+        \"{3:>}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignRight,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"\",\n+            },\n+        })]);\n+    same(\n+        \"{3:0<}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: Some('0'),\n+                align: AlignLeft,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"\",\n+            },\n+        })]);\n+    same(\n+        \"{3:*<abcd}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: Some('*'),\n+                align: AlignLeft,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"abcd\",\n+            },\n+        })]);\n }\n #[test]\n fn format_counts() {\n     use syntax_pos::{GLOBALS, Globals, edition};\n     GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n-    same(\"{:10s}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(0),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountImplied,\n-                   width: CountIs(10),\n-                   ty: \"s\",\n-               },\n-           })]);\n-    same(\"{:10$.10s}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(0),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountIs(10),\n-                   width: CountIsParam(10),\n-                   ty: \"s\",\n-               },\n-           })]);\n-    same(\"{:.*s}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(1),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountIsParam(0),\n-                   width: CountImplied,\n-                   ty: \"s\",\n-               },\n-           })]);\n-    same(\"{:.10$s}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(0),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountIsParam(10),\n-                   width: CountImplied,\n-                   ty: \"s\",\n-               },\n-           })]);\n-    same(\"{:a$.b$s}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(0),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountIsName(Symbol::intern(\"b\")),\n-                   width: CountIsName(Symbol::intern(\"a\")),\n-                   ty: \"s\",\n-               },\n-           })]);\n+    same(\n+        \"{:10s}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountIs(10),\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"s\",\n+            },\n+        })]);\n+    same(\n+        \"{:10$.10s}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIs(10),\n+                width: CountIsParam(10),\n+                precision_span: None,\n+                width_span: Some(InnerSpan::new(3, 6)),\n+                ty: \"s\",\n+            },\n+        })]);\n+    same(\n+        \"{:.*s}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(1),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIsParam(0),\n+                width: CountImplied,\n+                precision_span: Some(InnerSpan::new(3, 5)),\n+                width_span: None,\n+                ty: \"s\",\n+            },\n+        })]);\n+    same(\n+        \"{:.10$s}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIsParam(10),\n+                width: CountImplied,\n+                precision_span: Some(InnerSpan::new(3, 7)),\n+                width_span: None,\n+                ty: \"s\",\n+            },\n+        })]);\n+    same(\n+        \"{:a$.b$s}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIsName(Symbol::intern(\"b\")),\n+                width: CountIsName(Symbol::intern(\"a\")),\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"s\",\n+            },\n+        })]);\n     });\n }\n #[test]\n fn format_flags() {\n-    same(\"{:-}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(0),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: (1 << FlagSignMinus as u32),\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"\",\n-               },\n-           })]);\n-    same(\"{:+#}\",\n-         &[NextArgument(Argument {\n-               position: ArgumentImplicitlyIs(0),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"\",\n-               },\n-           })]);\n+    same(\n+        \"{:-}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: (1 << FlagSignMinus as u32),\n+                precision: CountImplied,\n+                width: CountImplied,\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"\",\n+            },\n+        })]);\n+    same(\n+        \"{:+#}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n+                precision: CountImplied,\n+                width: CountImplied,\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"\",\n+            },\n+        })]);\n }\n #[test]\n fn format_mixture() {\n-    same(\"abcd {3:a} efg\",\n-         &[String(\"abcd \"),\n-           NextArgument(Argument {\n-               position: ArgumentIs(3),\n-               format: FormatSpec {\n-                   fill: None,\n-                   align: AlignUnknown,\n-                   flags: 0,\n-                   precision: CountImplied,\n-                   width: CountImplied,\n-                   ty: \"a\",\n-               },\n-           }),\n-           String(\" efg\")]);\n+    same(\n+        \"abcd {3:a} efg\",\n+        &[\n+            String(\"abcd \"),\n+            NextArgument(Argument {\n+                position: ArgumentIs(3),\n+                format: FormatSpec {\n+                    fill: None,\n+                    align: AlignUnknown,\n+                    flags: 0,\n+                    precision: CountImplied,\n+                    width: CountImplied,\n+                    precision_span: None,\n+                    width_span: None,\n+                    ty: \"a\",\n+                },\n+            }),\n+            String(\" efg\"),\n+        ],\n+    );\n }"}, {"sha": "e0e70f41abe6a1385e072913912115f4f0251202", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1540,6 +1540,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             Ok(variant)\n         }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n+        size = size.align_to(align.abi);\n+\n         let abi = if prefix.abi.is_uninhabited() ||\n                      variants.iter().all(|v| v.abi.is_uninhabited()) {\n             Abi::Uninhabited"}, {"sha": "441cb9bfff3eb85372c68afbc910837c6a24ff61", "filename": "src/librustc_target/spec/armv7_unknown_linux_gnueabi.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibrustc_target%2Fspec%2Farmv7_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibrustc_target%2Fspec%2Farmv7_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farmv7_unknown_linux_gnueabi.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -0,0 +1,29 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+// This target is for glibc Linux on ARMv7 without thumb-mode, NEON or\n+// hardfloat.\n+\n+pub fn target() -> TargetResult {\n+    let base = super::linux_base::opts();\n+    Ok(Target {\n+        llvm_target: \"armv7-unknown-linux-gnueabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+\n+        options: TargetOptions {\n+            features: \"+v7,+thumb2,+soft-float,-neon\".to_string(),\n+            cpu: \"generic\".to_string(),\n+            max_atomic_width: Some(64),\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n+            .. base\n+        }\n+    })\n+}"}, {"sha": "c0368e5f0768a6a1cbe93a8cf279a47eaabda0f2", "filename": "src/librustc_target/spec/armv7_unknown_linux_musleabi.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibrustc_target%2Fspec%2Farmv7_unknown_linux_musleabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibrustc_target%2Fspec%2Farmv7_unknown_linux_musleabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farmv7_unknown_linux_musleabi.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -0,0 +1,34 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+// This target is for musl Linux on ARMv7 without thumb-mode, NEON or\n+// hardfloat.\n+\n+pub fn target() -> TargetResult {\n+    let base = super::linux_musl_base::opts();\n+    // Most of these settings are copied from the armv7_unknown_linux_gnueabi\n+    // target.\n+    Ok(Target {\n+        // It's important we use \"gnueabi\" and not \"musleabi\" here. LLVM uses it\n+        // to determine the calling convention and float ABI, and it doesn't\n+        // support the \"musleabi\" value.\n+        llvm_target: \"armv7-unknown-linux-gnueabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+\n+        options: TargetOptions {\n+            features: \"+v7,+thumb2,+soft-float,-neon\".to_string(),\n+            cpu: \"generic\".to_string(),\n+            max_atomic_width: Some(64),\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            target_mcount: \"\\u{1}mcount\".to_string(),\n+            .. base\n+        }\n+    })\n+}"}, {"sha": "b7b6627bbd8ab19224c988888e54403f5015a499", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -359,8 +359,10 @@ supported_targets! {\n     (\"armv4t-unknown-linux-gnueabi\", armv4t_unknown_linux_gnueabi),\n     (\"armv5te-unknown-linux-gnueabi\", armv5te_unknown_linux_gnueabi),\n     (\"armv5te-unknown-linux-musleabi\", armv5te_unknown_linux_musleabi),\n+    (\"armv7-unknown-linux-gnueabi\", armv7_unknown_linux_gnueabi),\n     (\"armv7-unknown-linux-gnueabihf\", armv7_unknown_linux_gnueabihf),\n     (\"thumbv7neon-unknown-linux-gnueabihf\", thumbv7neon_unknown_linux_gnueabihf),\n+    (\"armv7-unknown-linux-musleabi\", armv7_unknown_linux_musleabi),\n     (\"armv7-unknown-linux-musleabihf\", armv7_unknown_linux_musleabihf),\n     (\"aarch64-unknown-linux-gnu\", aarch64_unknown_linux_gnu),\n     (\"aarch64-unknown-linux-musl\", aarch64_unknown_linux_musl),"}, {"sha": "397200c39c2d743737de758b363f05b91db5afac", "filename": "src/libstd/sys/vxworks/process/process_common.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -403,67 +403,3 @@ impl ExitCode {\n         self.0 as i32\n     }\n }\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests {\n-    use super::*;\n-\n-    use crate::ffi::OsStr;\n-    use crate::mem;\n-    use crate::ptr;\n-    use crate::sys::cvt;\n-\n-    macro_rules! t {\n-        ($e:expr) => {\n-            match $e {\n-                Ok(t) => t,\n-                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n-            }\n-        }\n-    }\n-\n-    extern {\n-        fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int;\n-        fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n-    }\n-\n-    #[test]\n-    fn test_process_mask() {\n-        unsafe {\n-            // Test to make sure that a signal mask does not get inherited.\n-            let mut cmd = Command::new(OsStr::new(\"cat\"));\n-\n-            let mut set: libc::sigset_t = mem::uninitialized();\n-            let mut old_set: libc::sigset_t = mem::uninitialized();\n-            t!(cvt(sigemptyset(&mut set)));\n-            t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n-\n-            cmd.stdin(Stdio::MakePipe);\n-            cmd.stdout(Stdio::MakePipe);\n-\n-            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n-            let stdin_write = pipes.stdin.take().unwrap();\n-            let stdout_read = pipes.stdout.take().unwrap();\n-\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &old_set,\n-                                         ptr::null_mut())));\n-\n-            t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n-            // We need to wait until SIGINT is definitely delivered. The\n-            // easiest way is to write something to cat, and try to read it\n-            // back: if SIGINT is unmasked, it'll get delivered when cat is\n-            // next scheduled.\n-            let _ = stdin_write.write(b\"Hello\");\n-            drop(stdin_write);\n-\n-            // Either EOF or failure (EPIPE) is okay.\n-            let mut buf = [0; 5];\n-            if let Ok(ret) = stdout_read.read(&mut buf) {\n-                assert_eq!(ret, 0);\n-            }\n-\n-            t!(cat.wait());\n-        }\n-    }\n-}"}, {"sha": "07b1aef337fdccff8d8b887cfdab9526f6b24d1b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -2622,27 +2622,23 @@ impl<'a> State<'a> {\n         self.s.word(\"<\");\n \n         self.commasep(Inconsistent, &generic_params, |s, param| {\n+            s.print_outer_attributes_inline(&param.attrs);\n+\n             match param.kind {\n                 ast::GenericParamKind::Lifetime => {\n-                    s.print_outer_attributes_inline(&param.attrs);\n                     let lt = ast::Lifetime { id: param.id, ident: param.ident };\n                     s.print_lifetime_bounds(lt, &param.bounds)\n                 }\n                 ast::GenericParamKind::Type { ref default } => {\n-                    s.print_outer_attributes_inline(&param.attrs);\n                     s.print_ident(param.ident);\n                     s.print_type_bounds(\":\", &param.bounds);\n-                    match default {\n-                        Some(ref default) => {\n-                            s.s.space();\n-                            s.word_space(\"=\");\n-                            s.print_type(default)\n-                        }\n-                        _ => {}\n+                    if let Some(ref default) = default {\n+                        s.s.space();\n+                        s.word_space(\"=\");\n+                        s.print_type(default)\n                     }\n                 }\n                 ast::GenericParamKind::Const { ref ty } => {\n-                    s.print_outer_attributes_inline(&param.attrs);\n                     s.word_space(\"const\");\n                     s.print_ident(param.ident);\n                     s.s.space();\n@@ -2743,6 +2739,9 @@ impl<'a> State<'a> {\n \n     crate fn print_arg(&mut self, input: &ast::Arg, is_closure: bool) {\n         self.ibox(INDENT_UNIT);\n+\n+        self.print_outer_attributes_inline(&input.attrs);\n+\n         match input.ty.node {\n             ast::TyKind::Infer if is_closure => self.print_pat(&input.pat),\n             _ => {"}, {"sha": "fe9cad1e32fcad09ceb83268bd6062675a4e9c51", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 122, "deletions": 24, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -109,6 +109,8 @@ struct Context<'a, 'b> {\n     invalid_refs: Vec<(usize, usize)>,\n     /// Spans of all the formatting arguments, in order.\n     arg_spans: Vec<Span>,\n+    /// All the formatting arguments that have formatting flags set, in order for diagnostics.\n+    arg_with_formatting: Vec<parse::FormatSpec<'a>>,\n     /// Whether this formatting string is a literal or it comes from a macro.\n     is_literal: bool,\n }\n@@ -273,31 +275,44 @@ impl<'a, 'b> Context<'a, 'b> {\n         } else {\n             MultiSpan::from_span(self.fmtsp)\n         };\n-        let refs_len = self.invalid_refs.len();\n-        let mut refs = self\n+        let refs = self\n             .invalid_refs\n             .iter()\n             .map(|(r, pos)| (r.to_string(), self.arg_spans.get(*pos)));\n \n-        if self.names.is_empty() && !numbered_position_args {\n+        let mut zero_based_note = false;\n+\n+        let count = self.pieces.len() + self.arg_with_formatting\n+            .iter()\n+            .filter(|fmt| fmt.precision_span.is_some())\n+            .count();\n+        if self.names.is_empty() && !numbered_position_args && count != self.args.len() {\n             e = self.ecx.mut_span_err(\n                 sp,\n                 &format!(\n                     \"{} positional argument{} in format string, but {}\",\n-                         self.pieces.len(),\n-                         if self.pieces.len() > 1 { \"s\" } else { \"\" },\n-                    self.describe_num_args()\n+                    count,\n+                    if count > 1 { \"s\" } else { \"\" },\n+                    self.describe_num_args(),\n                 ),\n             );\n         } else {\n-            let (arg_list, mut sp) = if refs_len == 1 {\n-                let (reg, pos) = refs.next().unwrap();\n+            let (mut refs, spans): (Vec<_>, Vec<_>) = refs.unzip();\n+            // Avoid `invalid reference to positional arguments 7 and 7 (there is 1 argument)`\n+            // for `println!(\"{7:7$}\", 1);`\n+            refs.sort();\n+            refs.dedup();\n+            let (arg_list, mut sp) = if refs.len() == 1 {\n+                let spans: Vec<_> = spans.into_iter().filter_map(|sp| sp.map(|sp| *sp)).collect();\n                 (\n-                    format!(\"argument {}\", reg),\n-                    MultiSpan::from_span(*pos.unwrap_or(&self.fmtsp)),\n+                    format!(\"argument {}\", refs[0]),\n+                    if spans.is_empty() {\n+                        MultiSpan::from_span(self.fmtsp)\n+                    } else {\n+                        MultiSpan::from_spans(spans)\n+                    },\n                 )\n             } else {\n-                let (mut refs, spans): (Vec<_>, Vec<_>) = refs.unzip();\n                 let pos = MultiSpan::from_spans(spans.into_iter().map(|s| *s.unwrap()).collect());\n                 let reg = refs.pop().unwrap();\n                 (\n@@ -317,9 +332,70 @@ impl<'a, 'b> Context<'a, 'b> {\n                 &format!(\"invalid reference to positional {} ({})\",\n                          arg_list,\n                          self.describe_num_args()));\n-            e.note(\"positional arguments are zero-based\");\n+            zero_based_note = true;\n         };\n \n+        for fmt in &self.arg_with_formatting {\n+            if let Some(span) = fmt.precision_span {\n+                let span = self.fmtsp.from_inner(span);\n+                match fmt.precision {\n+                    parse::CountIsParam(pos) if pos > self.args.len() => {\n+                        e.span_label(span, &format!(\n+                            \"this precision flag expects an `usize` argument at position {}, \\\n+                             but {}\",\n+                            pos,\n+                            self.describe_num_args(),\n+                        ));\n+                        zero_based_note = true;\n+                    }\n+                    parse::CountIsParam(pos) => {\n+                        let count = self.pieces.len() + self.arg_with_formatting\n+                            .iter()\n+                            .filter(|fmt| fmt.precision_span.is_some())\n+                            .count();\n+                        e.span_label(span, &format!(\n+                            \"this precision flag adds an extra required argument at position {}, \\\n+                             which is why there {} expected\",\n+                            pos,\n+                            if count == 1 {\n+                                \"is 1 argument\".to_string()\n+                            } else {\n+                                format!(\"are {} arguments\", count)\n+                            },\n+                        ));\n+                        e.span_label(\n+                            self.args[pos].span,\n+                            \"this parameter corresponds to the precision flag\",\n+                        );\n+                        zero_based_note = true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            if let Some(span) = fmt.width_span {\n+                let span = self.fmtsp.from_inner(span);\n+                match fmt.width {\n+                    parse::CountIsParam(pos) if pos > self.args.len() => {\n+                        e.span_label(span, &format!(\n+                            \"this width flag expects an `usize` argument at position {}, \\\n+                             but {}\",\n+                            pos,\n+                            self.describe_num_args(),\n+                        ));\n+                        zero_based_note = true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        if zero_based_note {\n+            e.note(\"positional arguments are zero-based\");\n+        }\n+        if !self.arg_with_formatting.is_empty() {\n+            e.note(\"for information about formatting flags, visit \\\n+                    https://doc.rust-lang.org/std/fmt/index.html\");\n+        }\n+\n         e.emit();\n     }\n \n@@ -435,10 +511,11 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Builds a static `rt::Argument` from a `parse::Piece` or append\n     /// to the `literal` string.\n-    fn build_piece(&mut self,\n-                   piece: &parse::Piece<'_>,\n-                   arg_index_consumed: &mut Vec<usize>)\n-                   -> Option<P<ast::Expr>> {\n+    fn build_piece(\n+        &mut self,\n+        piece: &parse::Piece<'a>,\n+        arg_index_consumed: &mut Vec<usize>,\n+    ) -> Option<P<ast::Expr>> {\n         let sp = self.macsp;\n         match *piece {\n             parse::String(s) => {\n@@ -496,7 +573,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                         align: parse::AlignUnknown,\n                         flags: 0,\n                         precision: parse::CountImplied,\n+                        precision_span: None,\n                         width: parse::CountImplied,\n+                        width_span: None,\n                         ty: arg.format.ty,\n                     },\n                 };\n@@ -506,6 +585,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let pos_simple =\n                     arg.position.index() == simple_arg.position.index();\n \n+                if arg.format.precision_span.is_some() || arg.format.width_span.is_some() {\n+                    self.arg_with_formatting.push(arg.format);\n+                }\n                 if !pos_simple || arg.format != simple_arg.format || fill != ' ' {\n                     self.all_pieces_simple = false;\n                 }\n@@ -530,7 +612,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n                 let fmt = self.ecx.expr_struct(\n                     sp,\n-                                         path,\n+                    path,\n                     vec![\n                         self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n                         self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n@@ -657,12 +739,13 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.ecx.expr_call_global(self.macsp, path, fn_args)\n     }\n \n-    fn format_arg(ecx: &ExtCtxt<'_>,\n-                  macsp: Span,\n-                  mut sp: Span,\n-                  ty: &ArgumentType,\n-                  arg: ast::Ident)\n-                  -> P<ast::Expr> {\n+    fn format_arg(\n+        ecx: &ExtCtxt<'_>,\n+        macsp: Span,\n+        mut sp: Span,\n+        ty: &ArgumentType,\n+        arg: ast::Ident,\n+    ) -> P<ast::Expr> {\n         sp = sp.apply_mark(ecx.current_expansion.id);\n         let arg = ecx.expr_ident(sp, arg);\n         let trait_ = match *ty {\n@@ -678,7 +761,21 @@ impl<'a, 'b> Context<'a, 'b> {\n                     \"x\" => \"LowerHex\",\n                     \"X\" => \"UpperHex\",\n                     _ => {\n-                        ecx.span_err(sp, &format!(\"unknown format trait `{}`\", *tyname));\n+                        let mut err = ecx.struct_span_err(\n+                            sp,\n+                            &format!(\"unknown format trait `{}`\", *tyname),\n+                        );\n+                        err.note(\"the only appropriate formatting traits are:\\n\\\n+                                  - ``, which uses the `Display` trait\\n\\\n+                                  - `?`, which uses the `Debug` trait\\n\\\n+                                  - `e`, which uses the `LowerExp` trait\\n\\\n+                                  - `E`, which uses the `UpperExp` trait\\n\\\n+                                  - `o`, which uses the `Octal` trait\\n\\\n+                                  - `p`, which uses the `Pointer` trait\\n\\\n+                                  - `b`, which uses the `Binary` trait\\n\\\n+                                  - `x`, which uses the `LowerHex` trait\\n\\\n+                                  - `X`, which uses the `UpperHex` trait\");\n+                        err.emit();\n                         return DummyResult::raw_expr(sp, true);\n                     }\n                 }\n@@ -941,6 +1038,7 @@ pub fn expand_preparsed_format_args(\n         fmtsp: fmt.span,\n         invalid_refs: Vec::new(),\n         arg_spans,\n+        arg_with_formatting: Vec::new(),\n         is_literal,\n     };\n "}, {"sha": "02a7433d9469daa2e218cf79d68b6c7a90c4e405", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -1402,6 +1402,7 @@ pub struct MalformedSourceMapPositions {\n     pub end_pos: BytePos\n }\n \n+/// Range inside of a `Span` used for diagnostics when we only have access to relative positions.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct InnerSpan {\n     pub start: usize,"}, {"sha": "90fbb47bffda8b1fb966da7d1684fd6282f66172", "filename": "src/test/ui/async-await/issue-62658.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fasync-await%2Fissue-62658.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fasync-await%2Fissue-62658.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-62658.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -0,0 +1,29 @@\n+// This test created a generator whose size was not rounded to a multiple of its\n+// alignment. This caused an assertion error in codegen.\n+\n+// build-pass\n+// edition:2018\n+\n+#![feature(async_await)]\n+\n+async fn noop() {}\n+\n+async fn foo() {\n+    // This suspend should be the largest variant.\n+    {\n+        let x = [0u8; 17];\n+        noop().await;\n+        println!(\"{:?}\", x);\n+    }\n+\n+    // Add one variant that's aligned to 8 bytes.\n+    {\n+        let x = 0u64;\n+        noop().await;\n+        println!(\"{:?}\", x);\n+    }\n+}\n+\n+fn main() {\n+    let _ = foo();\n+}"}, {"sha": "ba897f171af25aa3c0ba5a28e820b0bcb66d0d10", "filename": "src/test/ui/if/ifmt-bad-arg.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -75,4 +75,15 @@ ninth number: {\n tenth number: {}\",\n         1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     //~^^ ERROR: invalid format string\n+    println!(\"{} {:.*} {}\", 1, 3.2, 4);\n+    //~^ ERROR 4 positional arguments in format string, but there are 3 arguments\n+    //~| ERROR mismatched types\n+    println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n+    //~^ ERROR 4 positional arguments in format string, but there are 3 arguments\n+    //~| ERROR mismatched types\n+    println!(\"{} {:07$} {}\", 1, 3.2, 4);\n+    //~^ ERROR invalid reference to positional argument 7 (there are 3 arguments)\n+    println!(\"{:foo}\", 1); //~ ERROR unknown format trait `foo`\n+    println!(\"{5} {:4$} {6:7$}\", 1);\n+    //~^ ERROR invalid reference to positional arguments 4, 5, 6 and 7 (there is 1 argument)\n }"}, {"sha": "336ea2254bf5a698e90b843c3e0c8a0a97d829d0", "filename": "src/test/ui/if/ifmt-bad-arg.stderr", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -220,5 +220,87 @@ LL | tenth number: {}\",\n    |\n    = note: if you intended to print `{`, you can escape it using `{{`\n \n-error: aborting due to 28 previous errors\n+error: 4 positional arguments in format string, but there are 3 arguments\n+  --> $DIR/ifmt-bad-arg.rs:78:15\n+   |\n+LL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n+   |               ^^ ^^--^ ^^      --- this parameter corresponds to the precision flag\n+   |                    |\n+   |                    this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n+   |\n+   = note: positional arguments are zero-based\n+   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n+\n+error: 4 positional arguments in format string, but there are 3 arguments\n+  --> $DIR/ifmt-bad-arg.rs:81:15\n+   |\n+LL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n+   |               ^^ ^^^----^ ^^      --- this parameter corresponds to the precision flag\n+   |                     | |\n+   |                     | this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n+   |                     this width flag expects an `usize` argument at position 7, but there are 3 arguments\n+   |\n+   = note: positional arguments are zero-based\n+   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n+\n+error: invalid reference to positional argument 7 (there are 3 arguments)\n+  --> $DIR/ifmt-bad-arg.rs:84:18\n+   |\n+LL |     println!(\"{} {:07$} {}\", 1, 3.2, 4);\n+   |                  ^^^--^\n+   |                     |\n+   |                     this width flag expects an `usize` argument at position 7, but there are 3 arguments\n+   |\n+   = note: positional arguments are zero-based\n+   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n+\n+error: unknown format trait `foo`\n+  --> $DIR/ifmt-bad-arg.rs:86:24\n+   |\n+LL |     println!(\"{:foo}\", 1);\n+   |                        ^\n+   |\n+   = note: the only appropriate formatting traits are:\n+           - ``, which uses the `Display` trait\n+           - `?`, which uses the `Debug` trait\n+           - `e`, which uses the `LowerExp` trait\n+           - `E`, which uses the `UpperExp` trait\n+           - `o`, which uses the `Octal` trait\n+           - `p`, which uses the `Pointer` trait\n+           - `b`, which uses the `Binary` trait\n+           - `x`, which uses the `LowerHex` trait\n+           - `X`, which uses the `UpperHex` trait\n+\n+error: invalid reference to positional arguments 4, 5, 6 and 7 (there is 1 argument)\n+  --> $DIR/ifmt-bad-arg.rs:87:15\n+   |\n+LL |     println!(\"{5} {:4$} {6:7$}\", 1);\n+   |               ^^^ ^^--^ ^^^--^\n+   |                     |      |\n+   |                     |      this width flag expects an `usize` argument at position 7, but there is 1 argument\n+   |                     this width flag expects an `usize` argument at position 4, but there is 1 argument\n+   |\n+   = note: positional arguments are zero-based\n+   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n+\n+error[E0308]: mismatched types\n+  --> $DIR/ifmt-bad-arg.rs:78:32\n+   |\n+LL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n+   |                                ^^^ expected usize, found floating-point number\n+   |\n+   = note: expected type `&usize`\n+              found type `&{float}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/ifmt-bad-arg.rs:81:35\n+   |\n+LL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n+   |                                   ^^^ expected usize, found floating-point number\n+   |\n+   = note: expected type `&usize`\n+              found type `&{float}`\n+\n+error: aborting due to 35 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "7853b5ca0c9a6c642bf27d11bdad689e07399c5a", "filename": "src/test/ui/if/ifmt-unknown-trait.stderr", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fif%2Fifmt-unknown-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Fif%2Fifmt-unknown-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fifmt-unknown-trait.stderr?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -3,6 +3,17 @@ error: unknown format trait `notimplemented`\n    |\n LL |     format!(\"{:notimplemented}\", \"3\");\n    |                                  ^^^\n+   |\n+   = note: the only appropriate formatting traits are:\n+           - ``, which uses the `Display` trait\n+           - `?`, which uses the `Debug` trait\n+           - `e`, which uses the `LowerExp` trait\n+           - `E`, which uses the `UpperExp` trait\n+           - `o`, which uses the `Octal` trait\n+           - `p`, which uses the `Pointer` trait\n+           - `b`, which uses the `Binary` trait\n+           - `x`, which uses the `LowerHex` trait\n+           - `X`, which uses the `UpperHex` trait\n \n error: aborting due to previous error\n "}, {"sha": "71815e3c08974f3c9b5d2f1205443aa4af91458c", "filename": "src/test/ui/rfc-2565-param-attrs/auxiliary/param-attrs.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fauxiliary%2Fparam-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fauxiliary%2Fparam-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fauxiliary%2Fparam-attrs.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -0,0 +1,34 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+macro_rules! checker {\n+    ($attr_name:ident, $expected:literal) => {\n+        #[proc_macro_attribute]\n+        pub fn $attr_name(attr: TokenStream, input: TokenStream) -> TokenStream {\n+            assert!(attr.to_string().is_empty());\n+            assert_eq!(input.to_string(), $expected);\n+            TokenStream::new()\n+        }\n+    }\n+}\n+\n+checker!(attr_extern, r#\"extern \"C\" {\n+    fn ffi(#[a1] arg1: i32, #[a2] ...);\n+}\"#);\n+checker!(attr_extern_cvar, r#\"unsafe extern \"C\" fn cvar(arg1: i32, #[a1] mut args: ...) { }\"#);\n+checker!(attr_alias, \"type Alias = fn(#[a1] u8, #[a2] ...);\");\n+checker!(attr_free, \"fn free(#[a1] arg1: u8) { let lam = |#[a2] W(x), #[a3] y| (); }\");\n+checker!(attr_inherent_1, \"fn inherent1(#[a1] self, #[a2] arg1: u8) { }\");\n+checker!(attr_inherent_2, \"fn inherent2(#[a1] &self, #[a2] arg1: u8) { }\");\n+checker!(attr_inherent_3, \"fn inherent3<'a>(#[a1] &'a mut self, #[a2] arg1: u8) { }\");\n+checker!(attr_inherent_4, \"fn inherent4<'a>(#[a1] self: Box<Self>, #[a2] arg1: u8) { }\");\n+checker!(attr_trait_1, \"fn trait1(#[a1] self, #[a2] arg1: u8);\");\n+checker!(attr_trait_2, \"fn trait2(#[a1] &self, #[a2] arg1: u8);\");\n+checker!(attr_trait_3, \"fn trait3<'a>(#[a1] &'a mut self, #[a2] arg1: u8);\");\n+checker!(attr_trait_4, \"fn trait4<'a>(#[a1] self: Box<Self>, #[a2] arg1: u8, #[a3] Vec<u8>);\");"}, {"sha": "1a7e9481745066659b8e233fe7b612c586ba709e", "filename": "src/test/ui/rfc-2565-param-attrs/param-attrs-pretty.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-pretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-pretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-pretty.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -0,0 +1,56 @@\n+// aux-build:param-attrs.rs\n+\n+// check-pass\n+\n+#![feature(param_attrs)]\n+#![feature(c_variadic)]\n+\n+extern crate param_attrs;\n+\n+use param_attrs::*;\n+\n+struct W(u8);\n+\n+#[attr_extern]\n+extern \"C\" { fn ffi(#[a1] arg1: i32, #[a2] ...); }\n+\n+#[attr_extern_cvar]\n+unsafe extern \"C\" fn cvar(arg1: i32, #[a1] mut args: ...) {}\n+\n+#[attr_alias]\n+type Alias = fn(#[a1] u8, #[a2] ...);\n+\n+#[attr_free]\n+fn free(#[a1] arg1: u8) {\n+    let lam = |#[a2] W(x), #[a3] y| ();\n+}\n+\n+impl W {\n+    #[attr_inherent_1]\n+    fn inherent1(#[a1] self, #[a2] arg1: u8) {}\n+\n+    #[attr_inherent_2]\n+    fn inherent2(#[a1] &self, #[a2] arg1: u8) {}\n+\n+    #[attr_inherent_3]\n+    fn inherent3<'a>(#[a1] &'a mut self, #[a2] arg1: u8) {}\n+\n+    #[attr_inherent_4]\n+    fn inherent4<'a>(#[a1] self: Box<Self>, #[a2] arg1: u8) {}\n+}\n+\n+trait A {\n+    #[attr_trait_1]\n+    fn trait1(#[a1] self, #[a2] arg1: u8);\n+\n+    #[attr_trait_2]\n+    fn trait2(#[a1] &self, #[a2] arg1: u8);\n+\n+    #[attr_trait_3]\n+    fn trait3<'a>(#[a1] &'a mut self, #[a2] arg1: u8);\n+\n+    #[attr_trait_4]\n+    fn trait4<'a>(#[a1] self: Box<Self>, #[a2] arg1: u8, #[a3] Vec<u8>);\n+}\n+\n+fn main() {}"}, {"sha": "2d1a52c920baec262a5ca7510f3cb39357512c78", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9bd4b289f07956819c59704d88d9eed61af3a6d/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=d9bd4b289f07956819c59704d88d9eed61af3a6d", "patch": "@@ -56,8 +56,10 @@ static TARGETS: &[&str] = &[\n     \"armv7-apple-ios\",\n     \"armv7-linux-androideabi\",\n     \"thumbv7neon-linux-androideabi\",\n+    \"armv7-unknown-linux-gnueabi\",\n     \"armv7-unknown-linux-gnueabihf\",\n     \"thumbv7neon-unknown-linux-gnueabihf\",\n+    \"armv7-unknown-linux-musleabi\",\n     \"armv7-unknown-linux-musleabihf\",\n     \"armebv7r-none-eabi\",\n     \"armebv7r-none-eabihf\","}]}