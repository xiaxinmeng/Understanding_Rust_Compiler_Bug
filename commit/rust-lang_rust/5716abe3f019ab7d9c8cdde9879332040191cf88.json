{"sha": "5716abe3f019ab7d9c8cdde9879332040191cf88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MTZhYmUzZjAxOWFiN2Q5YzhjZGRlOTg3OTMzMjA0MDE5MWNmODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-09T05:11:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-09T05:11:38Z"}, "message": "auto merge of #15537 : jbclements/rust/hygiene-for-methods, r=pcwalton\n\nThis patch adds hygiene for methods. This one was more difficult than the others, due principally to issues surrounding `self`. Specifically, there were a whole bunch of places in the code that assumed that a `self` identifier could be discarded and then made up again later, causing the discard of contexts and hygiene breakage.", "tree": {"sha": "b493f77b0890971676a0eecb880a79ee2f20714a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b493f77b0890971676a0eecb880a79ee2f20714a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5716abe3f019ab7d9c8cdde9879332040191cf88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5716abe3f019ab7d9c8cdde9879332040191cf88", "html_url": "https://github.com/rust-lang/rust/commit/5716abe3f019ab7d9c8cdde9879332040191cf88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5716abe3f019ab7d9c8cdde9879332040191cf88/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec3efa8055069e285a4bfcba892f8463ce925d68", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec3efa8055069e285a4bfcba892f8463ce925d68", "html_url": "https://github.com/rust-lang/rust/commit/ec3efa8055069e285a4bfcba892f8463ce925d68"}, {"sha": "4c312b6d0ddc4de7e00176d5099dad299473aabd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c312b6d0ddc4de7e00176d5099dad299473aabd", "html_url": "https://github.com/rust-lang/rust/commit/4c312b6d0ddc4de7e00176d5099dad299473aabd"}], "stats": {"total": 945, "additions": 540, "deletions": 405}, "files": [{"sha": "c1d782991b43d08888aa5b829f410fea866e9c65", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -185,15 +185,15 @@ impl<K: Ord, V> TreeMap<K, V> {\n \n macro_rules! bound_setup {\n     // initialiser of the iterator to manipulate\n-    ($iter:expr,\n+    ($iter:expr, $k:expr,\n      // whether we are looking for the lower or upper bound.\n      $is_lower_bound:expr) => {\n         {\n             let mut iter = $iter;\n             loop {\n                 if !iter.node.is_null() {\n                     let node_k = unsafe {&(*iter.node).key};\n-                    match k.cmp(node_k) {\n+                    match $k.cmp(node_k) {\n                         Less => iter.traverse_left(),\n                         Greater => iter.traverse_right(),\n                         Equal => {\n@@ -230,13 +230,13 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// Return a lazy iterator to the first key-value pair whose key is not less than `k`\n     /// If all keys in map are less than `k` an empty iterator is returned.\n     pub fn lower_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> {\n-        bound_setup!(self.iter_for_traversal(), true)\n+        bound_setup!(self.iter_for_traversal(), k, true)\n     }\n \n     /// Return a lazy iterator to the first key-value pair whose key is greater than `k`\n     /// If all keys in map are not greater than `k` an empty iterator is returned.\n     pub fn upper_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> {\n-        bound_setup!(self.iter_for_traversal(), false)\n+        bound_setup!(self.iter_for_traversal(), k, false)\n     }\n \n     /// Get a lazy iterator that should be initialized using\n@@ -256,7 +256,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// If all keys in map are less than `k` an empty iterator is\n     /// returned.\n     pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n-        bound_setup!(self.mut_iter_for_traversal(), true)\n+        bound_setup!(self.mut_iter_for_traversal(), k, true)\n     }\n \n     /// Return a lazy iterator to the first key-value pair (with the\n@@ -265,7 +265,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// If all keys in map are not greater than `k` an empty iterator\n     /// is returned.\n     pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n-        bound_setup!(self.mut_iter_for_traversal(), false)\n+        bound_setup!(self.mut_iter_for_traversal(), k, false)\n     }\n }\n "}, {"sha": "3230873883e19113bcf78fc8e4b9a785080fa7c7", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -769,16 +769,16 @@ pub trait ToPrimitive {\n }\n \n macro_rules! impl_to_primitive_int_to_int(\n-    ($SrcT:ty, $DstT:ty) => (\n+    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         {\n             if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some(*self as $DstT)\n+                Some($slf as $DstT)\n             } else {\n-                let n = *self as i64;\n+                let n = $slf as i64;\n                 let min_value: $DstT = Bounded::min_value();\n                 let max_value: $DstT = Bounded::max_value();\n                 if min_value as i64 <= n && n <= max_value as i64 {\n-                    Some(*self as $DstT)\n+                    Some($slf as $DstT)\n                 } else {\n                     None\n                 }\n@@ -788,12 +788,12 @@ macro_rules! impl_to_primitive_int_to_int(\n )\n \n macro_rules! impl_to_primitive_int_to_uint(\n-    ($SrcT:ty, $DstT:ty) => (\n+    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         {\n             let zero: $SrcT = Zero::zero();\n             let max_value: $DstT = Bounded::max_value();\n-            if zero <= *self && *self as u64 <= max_value as u64 {\n-                Some(*self as $DstT)\n+            if zero <= $slf && $slf as u64 <= max_value as u64 {\n+                Some($slf as $DstT)\n             } else {\n                 None\n             }\n@@ -805,26 +805,26 @@ macro_rules! impl_to_primitive_int(\n     ($T:ty) => (\n         impl ToPrimitive for $T {\n             #[inline]\n-            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int) }\n+            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int, *self) }\n             #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8) }\n+            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8, *self) }\n             #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16) }\n+            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16, *self) }\n             #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32) }\n+            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32, *self) }\n             #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64) }\n+            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64, *self) }\n \n             #[inline]\n-            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint) }\n+            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint, *self) }\n             #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8) }\n+            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8, *self) }\n             #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16) }\n+            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16, *self) }\n             #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32) }\n+            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32, *self) }\n             #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64) }\n+            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64, *self) }\n \n             #[inline]\n             fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n@@ -841,11 +841,11 @@ impl_to_primitive_int!(i32)\n impl_to_primitive_int!(i64)\n \n macro_rules! impl_to_primitive_uint_to_int(\n-    ($DstT:ty) => (\n+    ($DstT:ty, $slf:expr) => (\n         {\n             let max_value: $DstT = Bounded::max_value();\n-            if *self as u64 <= max_value as u64 {\n-                Some(*self as $DstT)\n+            if $slf as u64 <= max_value as u64 {\n+                Some($slf as $DstT)\n             } else {\n                 None\n             }\n@@ -854,15 +854,15 @@ macro_rules! impl_to_primitive_uint_to_int(\n )\n \n macro_rules! impl_to_primitive_uint_to_uint(\n-    ($SrcT:ty, $DstT:ty) => (\n+    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         {\n             if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some(*self as $DstT)\n+                Some($slf as $DstT)\n             } else {\n                 let zero: $SrcT = Zero::zero();\n                 let max_value: $DstT = Bounded::max_value();\n-                if zero <= *self && *self as u64 <= max_value as u64 {\n-                    Some(*self as $DstT)\n+                if zero <= $slf && $slf as u64 <= max_value as u64 {\n+                    Some($slf as $DstT)\n                 } else {\n                     None\n                 }\n@@ -875,26 +875,26 @@ macro_rules! impl_to_primitive_uint(\n     ($T:ty) => (\n         impl ToPrimitive for $T {\n             #[inline]\n-            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int) }\n+            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int, *self) }\n             #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8) }\n+            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8, *self) }\n             #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16) }\n+            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16, *self) }\n             #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32) }\n+            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32, *self) }\n             #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64) }\n+            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64, *self) }\n \n             #[inline]\n-            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint) }\n+            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint, *self) }\n             #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8) }\n+            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8, *self) }\n             #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16) }\n+            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16, *self) }\n             #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32) }\n+            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32, *self) }\n             #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64) }\n+            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64, *self) }\n \n             #[inline]\n             fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n@@ -911,14 +911,14 @@ impl_to_primitive_uint!(u32)\n impl_to_primitive_uint!(u64)\n \n macro_rules! impl_to_primitive_float_to_float(\n-    ($SrcT:ty, $DstT:ty) => (\n+    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-            Some(*self as $DstT)\n+            Some($slf as $DstT)\n         } else {\n-            let n = *self as f64;\n+            let n = $slf as f64;\n             let max_value: $SrcT = Bounded::max_value();\n             if -max_value as f64 <= n && n <= max_value as f64 {\n-                Some(*self as $DstT)\n+                Some($slf as $DstT)\n             } else {\n                 None\n             }\n@@ -952,9 +952,9 @@ macro_rules! impl_to_primitive_float(\n             fn to_u64(&self) -> Option<u64> { Some(*self as u64) }\n \n             #[inline]\n-            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32) }\n+            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32, *self) }\n             #[inline]\n-            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64) }\n+            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64, *self) }\n         }\n     )\n )\n@@ -1104,38 +1104,38 @@ pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n }\n \n macro_rules! impl_from_primitive(\n-    ($T:ty, $to_ty:expr) => (\n+    ($T:ty, $to_ty:ident) => (\n         impl FromPrimitive for $T {\n-            #[inline] fn from_int(n: int) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i8(n: i8) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i16(n: i16) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i32(n: i32) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i64(n: i64) -> Option<$T> { $to_ty }\n-\n-            #[inline] fn from_uint(n: uint) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u8(n: u8) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u16(n: u16) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u32(n: u32) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u64(n: u64) -> Option<$T> { $to_ty }\n-\n-            #[inline] fn from_f32(n: f32) -> Option<$T> { $to_ty }\n-            #[inline] fn from_f64(n: f64) -> Option<$T> { $to_ty }\n+            #[inline] fn from_int(n: int) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_i8(n: i8) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_i16(n: i16) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_i32(n: i32) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_i64(n: i64) -> Option<$T> { n.$to_ty() }\n+\n+            #[inline] fn from_uint(n: uint) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_u8(n: u8) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_u16(n: u16) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_u32(n: u32) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_u64(n: u64) -> Option<$T> { n.$to_ty() }\n+\n+            #[inline] fn from_f32(n: f32) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_f64(n: f64) -> Option<$T> { n.$to_ty() }\n         }\n     )\n )\n \n-impl_from_primitive!(int, n.to_int())\n-impl_from_primitive!(i8, n.to_i8())\n-impl_from_primitive!(i16, n.to_i16())\n-impl_from_primitive!(i32, n.to_i32())\n-impl_from_primitive!(i64, n.to_i64())\n-impl_from_primitive!(uint, n.to_uint())\n-impl_from_primitive!(u8, n.to_u8())\n-impl_from_primitive!(u16, n.to_u16())\n-impl_from_primitive!(u32, n.to_u32())\n-impl_from_primitive!(u64, n.to_u64())\n-impl_from_primitive!(f32, n.to_f32())\n-impl_from_primitive!(f64, n.to_f64())\n+impl_from_primitive!(int, to_int)\n+impl_from_primitive!(i8, to_i8)\n+impl_from_primitive!(i16, to_i16)\n+impl_from_primitive!(i32, to_i32)\n+impl_from_primitive!(i64, to_i64)\n+impl_from_primitive!(uint, to_uint)\n+impl_from_primitive!(u8, to_u8)\n+impl_from_primitive!(u16, to_u16)\n+impl_from_primitive!(u32, to_u32)\n+impl_from_primitive!(u64, to_u64)\n+impl_from_primitive!(f32, to_f32)\n+impl_from_primitive!(f64, to_f64)\n \n /// Cast from one machine scalar to another.\n ///"}, {"sha": "8a2b95ae463b414f34c8e75774e00ac09562b2bc", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -739,10 +739,11 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n     let explicit_self_kind = string.as_bytes()[0];\n     match explicit_self_kind as char {\n         's' => ast::SelfStatic,\n-        'v' => ast::SelfValue,\n-        '~' => ast::SelfUniq,\n+        'v' => ast::SelfValue(special_idents::self_),\n+        '~' => ast::SelfUniq(special_idents::self_),\n         // FIXME(#4846) expl. region\n-        '&' => ast::SelfRegion(None, get_mutability(string.as_bytes()[1])),\n+        '&' => ast::SelfRegion(None, get_mutability(string.as_bytes()[1]),\n+                               special_idents::self_),\n         _ => fail!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n     }\n }"}, {"sha": "fbf0288418ab8f8e83865255fd3959fe88097f3f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -628,10 +628,10 @@ fn encode_explicit_self(ebml_w: &mut Encoder, explicit_self: ast::ExplicitSelf_)\n \n     // Encode the base self type.\n     match explicit_self {\n-        SelfStatic => { ebml_w.writer.write(&[ 's' as u8 ]); }\n-        SelfValue  => { ebml_w.writer.write(&[ 'v' as u8 ]); }\n-        SelfUniq   => { ebml_w.writer.write(&[ '~' as u8 ]); }\n-        SelfRegion(_, m) => {\n+        SelfStatic   => { ebml_w.writer.write(&[ 's' as u8 ]); }\n+        SelfValue(_) => { ebml_w.writer.write(&[ 'v' as u8 ]); }\n+        SelfUniq(_)  => { ebml_w.writer.write(&[ '~' as u8 ]); }\n+        SelfRegion(_, m, _) => {\n             // FIXME(#4846) encode custom lifetime\n             ebml_w.writer.write(&['&' as u8]);\n             encode_mutability(ebml_w, m);"}, {"sha": "129a5b7c6bed394c8b0f25cfdfd8467af5291ec3", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -25,6 +25,7 @@ use syntax::ast;\n use syntax::ast_util::{local_def};\n use syntax::ast_util::{walk_pat, trait_method_to_ty_method};\n use syntax::ext::mtwt;\n+use syntax::parse::token::special_names;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::codemap::{Span, DUMMY_SP, Pos};\n@@ -830,9 +831,9 @@ struct Resolver<'a> {\n     current_self_type: Option<Ty>,\n \n     // The ident for the keyword \"self\".\n-    self_ident: Ident,\n+    self_name: Name,\n     // The ident for the non-keyword \"Self\".\n-    type_self_ident: Ident,\n+    type_self_name: Name,\n \n     // The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n@@ -926,8 +927,8 @@ impl<'a> Resolver<'a> {\n             current_trait_ref: None,\n             current_self_type: None,\n \n-            self_ident: special_idents::self_,\n-            type_self_ident: special_idents::type_self,\n+            self_name: special_names::self_,\n+            type_self_name: special_names::type_self,\n \n             primitive_type_table: PrimitiveTypeTable::new(),\n \n@@ -3628,8 +3629,8 @@ impl<'a> Resolver<'a> {\n                 // Create a new rib for the self type.\n                 let self_type_rib = Rib::new(ItemRibKind);\n \n-                // plain insert (no renaming)\n-                let name = self.type_self_ident.name;\n+                // plain insert (no renaming, types are not currently hygienic....)\n+                let name = self.type_self_name;\n                 self_type_rib.bindings.borrow_mut()\n                              .insert(name, DlDef(DefSelfTy(item.id)));\n                 self.type_ribs.borrow_mut().push(self_type_rib);\n@@ -5159,8 +5160,8 @@ impl<'a> Resolver<'a> {\n                                     false // Stop advancing\n                                 });\n \n-                                if method_scope && token::get_name(self.self_ident.name).get()\n-                                                                        == wrong_name.as_slice() {\n+                                if method_scope && token::get_name(self.self_name).get()\n+                                                                   == wrong_name.as_slice() {\n                                         self.resolve_error(\n                                             expr.span,\n                                             \"`self` is not available \\\n@@ -5532,6 +5533,7 @@ impl<'a> Resolver<'a> {\n                     collect_mod(idents, &*module.upgrade().unwrap());\n                 }\n                 BlockParentLink(ref module, _) => {\n+                    // danger, shouldn't be ident?\n                     idents.push(special_idents::opaque);\n                     collect_mod(idents, &*module.upgrade().unwrap());\n                 }"}, {"sha": "c79e435707aee724f203f140db71e1d7eac1c3d2", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -502,12 +502,15 @@ fn emit_vtable_methods(bcx: &Block,\n                                                        ExprId(0),\n                                                        substs.clone(),\n                                                        vtables.clone());\n-            if m.explicit_self == ast::SelfValue {\n-                fn_ref = trans_unboxing_shim(bcx,\n-                                             fn_ref,\n-                                             &*m,\n-                                             m_id,\n-                                             substs.clone());\n+            match m.explicit_self {\n+                ast::SelfValue(_) => {\n+                    fn_ref = trans_unboxing_shim(bcx,\n+                                                 fn_ref,\n+                                                 &*m,\n+                                                 m_id,\n+                                                 substs.clone());\n+                },\n+                _ => {}\n             }\n             fn_ref\n         }"}, {"sha": "90331d8f43430c2e3531b870e4724508c6df06d7", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -938,10 +938,10 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n     let self_ty = opt_self_info.and_then(|self_info| {\n         match self_info.explicit_self.node {\n             ast::SelfStatic => None,\n-            ast::SelfValue => {\n+            ast::SelfValue(_) => {\n                 Some(self_info.untransformed_self_ty)\n             }\n-            ast::SelfRegion(ref lifetime, mutability) => {\n+            ast::SelfRegion(ref lifetime, mutability, _) => {\n                 let region =\n                     opt_ast_region_to_region(this, &rb,\n                                              self_info.explicit_self.span,\n@@ -950,7 +950,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: mutability}))\n             }\n-            ast::SelfUniq => {\n+            ast::SelfUniq(_) => {\n                 Some(ty::mk_uniq(this.tcx(), self_info.untransformed_self_ty))\n             }\n         }"}, {"sha": "a184ecac9dea669196a66ce619dc40341f6a9586", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -270,12 +270,12 @@ fn construct_transformed_self_ty_for_object(\n         ast::SelfStatic => {\n             tcx.sess.span_bug(span, \"static method for object type receiver\");\n         }\n-        ast::SelfValue => {\n+        ast::SelfValue(_) => {\n             let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n                                   ty::empty_builtin_bounds());\n             ty::mk_uniq(tcx, tr)\n         }\n-        ast::SelfRegion(..) | ast::SelfUniq => {\n+        ast::SelfRegion(..) | ast::SelfUniq(..) => {\n             let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n             match ty::get(transformed_self_ty).sty {\n                 ty::ty_rptr(r, mt) => { // must be SelfRegion\n@@ -1227,7 +1227,7 @@ impl<'a> LookupContext<'a> {\n                      through an object\");\n             }\n \n-            ast::SelfValue | ast::SelfRegion(..) | ast::SelfUniq => {}\n+            ast::SelfValue(_) | ast::SelfRegion(..) | ast::SelfUniq(_) => {}\n         }\n \n         // reason (a) above\n@@ -1296,7 +1296,7 @@ impl<'a> LookupContext<'a> {\n                 self.report_statics == ReportStaticMethods\n             }\n \n-            SelfValue => {\n+            SelfValue(_) => {\n                 debug!(\"(is relevant?) explicit self is by-value\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(typ) => {\n@@ -1319,7 +1319,7 @@ impl<'a> LookupContext<'a> {\n                 }\n             }\n \n-            SelfRegion(_, m) => {\n+            SelfRegion(_, m, _) => {\n                 debug!(\"(is relevant?) explicit self is a region\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n@@ -1339,7 +1339,7 @@ impl<'a> LookupContext<'a> {\n                 }\n             }\n \n-            SelfUniq => {\n+            SelfUniq(_) => {\n                 debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(typ) => {"}, {"sha": "b0c9900be909cc2bb8ee0d3b2d38e6737a5826f1", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -947,16 +947,16 @@ impl<'a> Rebuilder<'a> {\n                          -> Option<ast::ExplicitSelf_> {\n         match expl_self_opt {\n             Some(expl_self) => match expl_self {\n-                ast::SelfRegion(lt_opt, muta) => match lt_opt {\n+                ast::SelfRegion(lt_opt, muta, id) => match lt_opt {\n                     Some(lt) => if region_names.contains(&lt.name) {\n-                        return Some(ast::SelfRegion(Some(lifetime), muta));\n+                        return Some(ast::SelfRegion(Some(lifetime), muta, id));\n                     },\n                     None => {\n                         let anon = self.cur_anon.get();\n                         self.inc_and_offset_cur_anon(1);\n                         if anon_nums.contains(&anon) {\n                             self.track_anon(anon);\n-                            return Some(ast::SelfRegion(Some(lifetime), muta));\n+                            return Some(ast::SelfRegion(Some(lifetime), muta, id));\n                         }\n                     }\n                 },"}, {"sha": "2581ba51c2e107b1830a6a5fda3b82b971eda11c", "filename": "src/librustc/plugin/registry.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -13,7 +13,7 @@\n use lint::LintPassObject;\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n-use syntax::ext::base::{IdentTT, ItemDecorator, ItemModifier, BasicMacroExpander};\n+use syntax::ext::base::{IdentTT, LetSyntaxTT, ItemDecorator, ItemModifier, BasicMacroExpander};\n use syntax::ext::base::{MacroExpanderFn};\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -57,6 +57,8 @@ impl Registry {\n             IdentTT(ext, _) => IdentTT(ext, Some(self.krate_span)),\n             ItemDecorator(ext) => ItemDecorator(ext),\n             ItemModifier(ext) => ItemModifier(ext),\n+            // there's probably a nicer way to signal this:\n+            LetSyntaxTT(_, _) => fail!(\"can't register a new LetSyntax!\"),\n         }));\n     }\n "}, {"sha": "af0b6a1cb21d104d496de178bd696f1db0c8920d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -775,9 +775,9 @@ impl Clean<SelfTy> for ast::ExplicitSelf_ {\n     fn clean(&self) -> SelfTy {\n         match *self {\n             ast::SelfStatic => SelfStatic,\n-            ast::SelfValue => SelfValue,\n-            ast::SelfUniq => SelfOwned,\n-            ast::SelfRegion(lt, mt) => SelfBorrowed(lt.clean(), mt.clean()),\n+            ast::SelfValue(_) => SelfValue,\n+            ast::SelfUniq(_) => SelfOwned,\n+            ast::SelfRegion(lt, mt, _) => SelfBorrowed(lt.clean(), mt.clean()),\n         }\n     }\n }"}, {"sha": "5f3adbdb54df498f054fffc5e34b0c1f0fe328ee", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -14,7 +14,7 @@ use codemap::{Span, Spanned, DUMMY_SP};\n use abi::Abi;\n use ast_util;\n use owned_slice::OwnedSlice;\n-use parse::token::{InternedString, special_idents, str_to_ident};\n+use parse::token::{InternedString, str_to_ident};\n use parse::token;\n \n use std::fmt;\n@@ -824,8 +824,8 @@ pub struct Arg {\n }\n \n impl Arg {\n-    pub fn new_self(span: Span, mutability: Mutability) -> Arg {\n-        let path = Spanned{span:span,node:special_idents::self_};\n+    pub fn new_self(span: Span, mutability: Mutability, self_ident: Ident) -> Arg {\n+        let path = Spanned{span:span,node:self_ident};\n         Arg {\n             // HACK(eddyb) fake type for the self argument.\n             ty: P(Ty {\n@@ -874,16 +874,18 @@ pub enum RetStyle {\n     Return, // everything else\n }\n \n+/// Represents the kind of 'self' associated with a method\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum ExplicitSelf_ {\n-    SelfStatic,                                // no self\n-    SelfValue,                                 // `self`\n-    SelfRegion(Option<Lifetime>, Mutability),  // `&'lt self`, `&'lt mut self`\n-    SelfUniq                                   // `~self`\n+    SelfStatic,                                       // no self\n+    SelfValue(Ident),                                 // `self`\n+    SelfRegion(Option<Lifetime>, Mutability, Ident),  // `&'lt self`, `&'lt mut self`\n+    SelfUniq(Ident),                                  // `~self`\n }\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n+// Represents a method declaration\n #[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Method {\n     pub ident: Ident,"}, {"sha": "a2a442f8b6aa756fa8ba51abd4d365808a6c41f3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -264,8 +264,15 @@ pub enum SyntaxExtension {\n     /// A function-like syntax extension that has an extra ident before\n     /// the block.\n     ///\n-    /// `macro_rules!` is an `IdentTT`.\n     IdentTT(Box<IdentMacroExpander + 'static>, Option<Span>),\n+\n+    /// An ident macro that has two properties:\n+    /// - it adds a macro definition to the environment, and\n+    /// - the definition it adds doesn't introduce any new\n+    ///   identifiers.\n+    ///\n+    /// `macro_rules!` is a LetSyntaxTT\n+    LetSyntaxTT(Box<IdentMacroExpander + 'static>, Option<Span>),\n }\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n@@ -300,7 +307,7 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n \n     let mut syntax_expanders = SyntaxEnv::new();\n     syntax_expanders.insert(intern(\"macro_rules\"),\n-                            IdentTT(box BasicIdentMacroExpander {\n+                            LetSyntaxTT(box BasicIdentMacroExpander {\n                                 expander: ext::tt::macro_rules::add_new_extension,\n                                 span: None,\n                             },"}, {"sha": "764c88cc954ede2a1e6849706de44b306db9cb65", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -191,6 +191,7 @@ use codemap;\n use codemap::Span;\n use owned_slice::OwnedSlice;\n use parse::token::InternedString;\n+use parse::token::special_idents;\n \n use self::ty::*;\n \n@@ -617,7 +618,8 @@ impl<'a> MethodDef<'a> {\n \n         let self_arg = match explicit_self.node {\n             ast::SelfStatic => None,\n-            _ => Some(ast::Arg::new_self(trait_.span, ast::MutImmutable))\n+            // creating fresh self id\n+            _ => Some(ast::Arg::new_self(trait_.span, ast::MutImmutable, special_idents::self_))\n         };\n         let args = {\n             let args = arg_types.move_iter().map(|(name, ty)| {"}, {"sha": "b53281f99633f8837dbcf04222bf3b79ab44c111", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -19,6 +19,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::{Span,respan};\n use owned_slice::OwnedSlice;\n+use parse::token::special_idents;\n \n use std::gc::Gc;\n \n@@ -244,22 +245,23 @@ impl<'a> LifetimeBounds<'a> {\n     }\n }\n \n-\n pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n     -> (Gc<Expr>, ast::ExplicitSelf) {\n+    // this constructs a fresh `self` path, which will match the fresh `self` binding\n+    // created below.\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n-            (self_path, respan(span, ast::SelfValue))\n+            (self_path, respan(span, ast::SelfValue(special_idents::self_)))\n         }\n         Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n-                    Send => ast::SelfUniq,\n+                    Send => ast::SelfUniq(special_idents::self_),\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n-                        ast::SelfRegion(lt, mutbl)\n+                        ast::SelfRegion(lt, mutbl, special_idents::self_)\n                     }\n                 });\n             let self_expr = cx.expr_deref(span, self_path);"}, {"sha": "9fe431cfb6c757992e53aec94a50cc610b658f70", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 123, "deletions": 29, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -484,6 +484,24 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n             let marked_tts = mark_tts(tts.as_slice(), fm);\n             expander.expand(fld.cx, it.span, it.ident, marked_tts)\n         }\n+        Some(&LetSyntaxTT(ref expander, span)) => {\n+            if it.ident.name == parse::token::special_idents::invalid.name {\n+                fld.cx.span_err(pth.span,\n+                                format!(\"macro {}! expects an ident argument\",\n+                                        extnamestr.get()).as_slice());\n+                return SmallVector::zero();\n+            }\n+            fld.cx.bt_push(ExpnInfo {\n+                call_site: it.span,\n+                callee: NameAndSpan {\n+                    name: extnamestr.get().to_string(),\n+                    format: MacroBang,\n+                    span: span\n+                }\n+            });\n+            // DON'T mark before expansion:\n+            expander.expand(fld.cx, it.span, it.ident, tts)\n+        }\n         _ => {\n             fld.cx.span_err(it.span,\n                             format!(\"{}! is not legal in item position\",\n@@ -494,8 +512,10 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n \n     let items = match expanded.make_def() {\n         Some(MacroDef { name, ext }) => {\n-            // yikes... no idea how to apply the mark to this. I'm afraid\n-            // we're going to have to wait-and-see on this one.\n+            // hidden invariant: this should only be possible as the\n+            // result of expanding a LetSyntaxTT, and thus doesn't\n+            // need to be marked. Not that it could be marked anyway.\n+            // create issue to recommend refactoring here?\n             fld.extsbox.insert(intern(name.as_slice()), ext);\n             if attr::contains_name(it.attrs.as_slice(), \"macro_export\") {\n                 SmallVector::one(it)\n@@ -914,6 +934,27 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n     }\n }\n \n+// expand a method\n+fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> Gc<ast::Method> {\n+    let id = fld.new_id(m.id);\n+    let (rewritten_fn_decl, rewritten_body)\n+        = expand_and_rename_fn_decl_and_block(m.decl,m.body,fld);\n+\n+    // all of the other standard stuff:\n+    box(GC) ast::Method {\n+        id: id,\n+        ident: fld.fold_ident(m.ident),\n+        attrs: m.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n+        generics: fold_generics(&m.generics, fld),\n+        explicit_self: fld.fold_explicit_self(&m.explicit_self),\n+        fn_style: m.fn_style,\n+        decl: rewritten_fn_decl,\n+        body: rewritten_body,\n+        span: fld.new_span(m.span),\n+        vis: m.vis\n+    }\n+}\n+\n /// Given a fn_decl and a block and a MacroExpander, expand the fn_decl, then use the\n /// PatIdents in its arguments to perform renaming in the FnDecl and\n /// the block, returning both the new FnDecl and the new Block.\n@@ -968,6 +1009,10 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_arm(arm, self)\n     }\n \n+    fn fold_method(&mut self, method: Gc<ast::Method>) -> Gc<ast::Method> {\n+        expand_method(method, self)\n+    }\n+\n     fn new_span(&mut self, span: Span) -> Span {\n         new_span(self.cx, span)\n     }\n@@ -1280,6 +1325,14 @@ mod test {\n             \"macro_rules! m((a)=>(13)) fn main(){m!(a);}\".to_string());\n     }\n \n+    // should be able to use a bound identifier as a literal in a macro definition:\n+    #[test] fn self_macro_parsing(){\n+        expand_crate_str(\n+            \"macro_rules! foo ((zz) => (287u;))\n+            fn f(zz : int) {foo!(zz);}\".to_string()\n+            );\n+    }\n+\n     // renaming tests expand a crate and then check that the bindings match\n     // the right varrefs. The specification of the test case includes the\n     // text of the crate, and also an array of arrays.  Each element in the\n@@ -1390,6 +1443,32 @@ mod test {\n     // but *shouldn't* bind because it was inserted by a different macro....\n     // can't write this test case until we have macro-generating macros.\n \n+    // method arg hygiene\n+    // method expands to fn get_x(&self_0, x_1:int) {self_0 + self_2 + x_3 + x_1}\n+    #[test] fn method_arg_hygiene(){\n+        run_renaming_test(\n+            &(\"macro_rules! inject_x (()=>(x))\n+              macro_rules! inject_self (()=>(self))\n+              struct A;\n+              impl A{fn get_x(&self, x: int) {self + inject_self!() + inject_x!() + x;} }\",\n+              vec!(vec!(0),vec!(3)),\n+              true),\n+            0)\n+    }\n+\n+    // ooh, got another bite?\n+    // expands to struct A; impl A {fn thingy(&self_1) {self_1;}}\n+    #[test] fn method_arg_hygiene_2(){\n+        run_renaming_test(\n+            &(\"struct A;\n+              macro_rules! add_method (($T:ty) =>\n+              (impl $T {  fn thingy(&self) {self;} }))\n+              add_method!(A)\",\n+              vec!(vec!(0)),\n+              true),\n+            0)\n+    }\n+\n     // item fn hygiene\n     // expands to fn q(x_1:int){fn g(x_2:int){x_2 + x_1};}\n     #[test] fn issue_9383(){\n@@ -1422,6 +1501,28 @@ mod test {\n             0)\n     }\n \n+    // macro_rules in method position. Sadly, unimplemented.\n+    #[ignore] #[test] fn macro_in_method_posn(){\n+        expand_crate_str(\n+            \"macro_rules! my_method (() => fn thirteen(&self) -> int {13})\n+            struct A;\n+            impl A{ my_method!()}\n+            fn f(){A.thirteen;}\".to_string());\n+    }\n+\n+    // another nested macro\n+    // expands to impl Entries {fn size_hint(&self_1) {self_1;}\n+    #[test] fn item_macro_workaround(){\n+        run_renaming_test(\n+            &(\"macro_rules! item { ($i:item) => {$i}}\n+              struct Entries;\n+              macro_rules! iterator_impl {\n+              () => { item!( impl Entries { fn size_hint(&self) { self;}})}}\n+              iterator_impl! { }\",\n+              vec!(vec!(0)), true),\n+            0)\n+    }\n+\n     // run one of the renaming tests\n     fn run_renaming_test(t: &RenamingTest, test_idx: uint) {\n         let invalid_name = token::special_idents::invalid.name;\n@@ -1441,27 +1542,36 @@ mod test {\n             assert!((shouldmatch.len() == 0) ||\n                     (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n             for (idx,varref) in varrefs.iter().enumerate() {\n+                let print_hygiene_debug_info = || {\n+                    // good lord, you can't make a path with 0 segments, can you?\n+                    let final_varref_ident = match varref.segments.last() {\n+                        Some(pathsegment) => pathsegment.identifier,\n+                        None => fail!(\"varref with 0 path segments?\")\n+                    };\n+                    let varref_name = mtwt::resolve(final_varref_ident);\n+                    let varref_idents : Vec<ast::Ident>\n+                        = varref.segments.iter().map(|s| s.identifier)\n+                        .collect();\n+                    println!(\"varref #{}: {}, resolves to {}\",idx, varref_idents, varref_name);\n+                    let string = token::get_ident(final_varref_ident);\n+                    println!(\"varref's first segment's string: \\\"{}\\\"\", string.get());\n+                    println!(\"binding #{}: {}, resolves to {}\",\n+                             binding_idx, *bindings.get(binding_idx), binding_name);\n+                    mtwt::with_sctable(|x| mtwt::display_sctable(x));\n+                };\n                 if shouldmatch.contains(&idx) {\n                     // it should be a path of length 1, and it should\n                     // be free-identifier=? or bound-identifier=? to the given binding\n                     assert_eq!(varref.segments.len(),1);\n-                    let varref_name = mtwt::resolve(varref.segments\n-                                                          .get(0)\n-                                                          .identifier);\n+                    let varref_name = mtwt::resolve(varref.segments.get(0).identifier);\n                     let varref_marks = mtwt::marksof(varref.segments\n                                                            .get(0)\n                                                            .identifier\n                                                            .ctxt,\n                                                      invalid_name);\n                     if !(varref_name==binding_name) {\n-                        let varref_idents : Vec<ast::Ident>\n-                            = varref.segments.iter().map(|s|\n-                                                         s.identifier)\n-                            .collect();\n                         println!(\"uh oh, should match but doesn't:\");\n-                        println!(\"varref #{}: {}\",idx, varref_idents);\n-                        println!(\"binding #{}: {}\", binding_idx, *bindings.get(binding_idx));\n-                        mtwt::with_sctable(|x| mtwt::display_sctable(x));\n+                        print_hygiene_debug_info();\n                     }\n                     assert_eq!(varref_name,binding_name);\n                     if bound_ident_check {\n@@ -1475,27 +1585,11 @@ mod test {\n                         && (varref_name == binding_name);\n                     // temp debugging:\n                     if fail {\n-                        let varref_idents : Vec<ast::Ident>\n-                            = varref.segments.iter().map(|s|\n-                                                         s.identifier)\n-                            .collect();\n                         println!(\"failure on test {}\",test_idx);\n                         println!(\"text of test case: \\\"{}\\\"\", teststr);\n                         println!(\"\");\n                         println!(\"uh oh, matches but shouldn't:\");\n-                        println!(\"varref #{}: {}, resolves to {}\",idx, varref_idents,\n-                                 varref_name);\n-                        // good lord, you can't make a path with 0 segments, can you?\n-                        let string = token::get_ident(varref.segments\n-                                                            .get(0)\n-                                                            .identifier);\n-                        println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n-                                 varref.segments.get(0).identifier.name,\n-                                 string.get());\n-                        println!(\"binding #{}: {}, resolves to {}\",\n-                                 binding_idx, *bindings.get(binding_idx),\n-                                 binding_name);\n-                        mtwt::with_sctable(|x| mtwt::display_sctable(x));\n+                        print_hygiene_debug_info();\n                     }\n                     assert!(!fail);\n                 }"}, {"sha": "b30ede70f0e4bd36a2d7917b1df98911d5ae82c8", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -354,8 +354,7 @@ pub fn parse(sess: &ParseSess,\n                   MatchNonterminal(_,_,_) => { bb_eis.push(ei) }\n                   MatchTok(ref t) => {\n                     let mut ei_t = ei.clone();\n-                    //if (token_name_eq(t,&tok)) {\n-                    if token::mtwt_token_eq(t,&tok) {\n+                    if token_name_eq(t,&tok) {\n                         ei_t.idx += 1;\n                         next_eis.push(ei_t);\n                     }"}, {"sha": "bcdf920e5dd41779d76bfe020ee324c04a0841b0", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -334,9 +334,9 @@ pub trait Folder {\n \n     fn fold_explicit_self_(&mut self, es: &ExplicitSelf_) -> ExplicitSelf_ {\n         match *es {\n-            SelfStatic | SelfValue | SelfUniq => *es,\n-            SelfRegion(ref lifetime, m) => {\n-                SelfRegion(fold_opt_lifetime(lifetime, self), m)\n+            SelfStatic | SelfValue(_) | SelfUniq(_) => *es,\n+            SelfRegion(ref lifetime, m, id) => {\n+                SelfRegion(fold_opt_lifetime(lifetime, self), m, id)\n             }\n         }\n     }"}, {"sha": "ac4cbf3aa8e55f4dbacdb2fc3d2a0dd38b447b10", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 247, "deletions": 227, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -541,20 +541,21 @@ impl<'a> Parser<'a> {\n     // if the next token is the given keyword, eat it and return\n     // true. Otherwise, return false.\n     pub fn eat_keyword(&mut self, kw: keywords::Keyword) -> bool {\n-        let is_kw = match self.token {\n-            token::IDENT(sid, false) => kw.to_ident().name == sid.name,\n+        match self.token {\n+            token::IDENT(sid, false) if kw.to_name() == sid.name => {\n+                self.bump();\n+                true\n+            }\n             _ => false\n-        };\n-        if is_kw { self.bump() }\n-        is_kw\n+        }\n     }\n \n     // if the given word is not a keyword, signal an error.\n     // if the next token is not the given word, signal an error.\n     // otherwise, eat it.\n     pub fn expect_keyword(&mut self, kw: keywords::Keyword) {\n         if !self.eat_keyword(kw) {\n-            let id_interned_str = token::get_ident(kw.to_ident());\n+            let id_interned_str = token::get_name(kw.to_name());\n             let token_str = self.this_token_to_string();\n             self.fatal(format!(\"expected `{}`, found `{}`\",\n                                id_interned_str, token_str).as_slice())\n@@ -1877,211 +1878,230 @@ impl<'a> Parser<'a> {\n \n         let ex: Expr_;\n \n-        if self.token == token::LPAREN {\n-            self.bump();\n-            // (e) is parenthesized e\n-            // (e,) is a tuple with only one field, e\n-            let mut trailing_comma = false;\n-            if self.token == token::RPAREN {\n-                hi = self.span.hi;\n-                self.bump();\n-                let lit = box(GC) spanned(lo, hi, LitNil);\n-                return self.mk_expr(lo, hi, ExprLit(lit));\n-            }\n-            let mut es = vec!(self.parse_expr());\n-            self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n-            while self.token == token::COMMA {\n+        match self.token {\n+            token::LPAREN => {\n                 self.bump();\n-                if self.token != token::RPAREN {\n-                    es.push(self.parse_expr());\n-                    self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n+                // (e) is parenthesized e\n+                // (e,) is a tuple with only one field, e\n+                let mut trailing_comma = false;\n+                if self.token == token::RPAREN {\n+                    hi = self.span.hi;\n+                    self.bump();\n+                    let lit = box(GC) spanned(lo, hi, LitNil);\n+                    return self.mk_expr(lo, hi, ExprLit(lit));\n                 }\n-                else {\n-                    trailing_comma = true;\n+                let mut es = vec!(self.parse_expr());\n+                self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n+                while self.token == token::COMMA {\n+                    self.bump();\n+                    if self.token != token::RPAREN {\n+                        es.push(self.parse_expr());\n+                        self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n+                    }\n+                        else {\n+                        trailing_comma = true;\n+                    }\n                 }\n-            }\n-            hi = self.span.hi;\n-            self.commit_expr_expecting(*es.last().unwrap(), token::RPAREN);\n-\n-            return if es.len() == 1 && !trailing_comma {\n-                self.mk_expr(lo, hi, ExprParen(*es.get(0)))\n-            }\n-            else {\n-                self.mk_expr(lo, hi, ExprTup(es))\n-            }\n-        } else if self.token == token::LBRACE {\n-            self.bump();\n-            let blk = self.parse_block_tail(lo, DefaultBlock);\n-            return self.mk_expr(blk.span.lo, blk.span.hi,\n-                                 ExprBlock(blk));\n-        } else if token::is_bar(&self.token) {\n-            return self.parse_lambda_expr();\n-        } else if self.eat_keyword(keywords::Proc) {\n-            let decl = self.parse_proc_decl();\n-            let body = self.parse_expr();\n-            let fakeblock = P(ast::Block {\n-                view_items: Vec::new(),\n-                stmts: Vec::new(),\n-                expr: Some(body),\n-                id: ast::DUMMY_NODE_ID,\n-                rules: DefaultBlock,\n-                span: body.span,\n-            });\n+                hi = self.span.hi;\n+                self.commit_expr_expecting(*es.last().unwrap(), token::RPAREN);\n \n-            return self.mk_expr(lo, body.span.hi, ExprProc(decl, fakeblock));\n-        } else if self.eat_keyword(keywords::Self) {\n-            let path = ast_util::ident_to_path(mk_sp(lo, hi), special_idents::self_);\n-            ex = ExprPath(path);\n-            hi = self.last_span.hi;\n-        } else if self.eat_keyword(keywords::If) {\n-            return self.parse_if_expr();\n-        } else if self.eat_keyword(keywords::For) {\n-            return self.parse_for_expr(None);\n-        } else if self.eat_keyword(keywords::While) {\n-            return self.parse_while_expr();\n-        } else if Parser::token_is_lifetime(&self.token) {\n-            let lifetime = self.get_lifetime();\n-            self.bump();\n-            self.expect(&token::COLON);\n-            if self.eat_keyword(keywords::For) {\n-                return self.parse_for_expr(Some(lifetime))\n-            } else if self.eat_keyword(keywords::Loop) {\n-                return self.parse_loop_expr(Some(lifetime))\n-            } else {\n-                self.fatal(\"expected `for` or `loop` after a label\")\n+                return if es.len() == 1 && !trailing_comma {\n+                    self.mk_expr(lo, hi, ExprParen(*es.get(0)))\n+                }\n+                    else {\n+                    self.mk_expr(lo, hi, ExprTup(es))\n+                }\n+            },\n+            token::LBRACE => {\n+                self.bump();\n+                let blk = self.parse_block_tail(lo, DefaultBlock);\n+                return self.mk_expr(blk.span.lo, blk.span.hi,\n+                                    ExprBlock(blk));\n+            },\n+            token::BINOP(token::OR) |  token::OROR => {\n+                return self.parse_lambda_expr();\n+            },\n+            _ if self.eat_keyword(keywords::Proc) => {\n+                let decl = self.parse_proc_decl();\n+                let body = self.parse_expr();\n+                let fakeblock = P(ast::Block {\n+                        view_items: Vec::new(),\n+                        stmts: Vec::new(),\n+                        expr: Some(body),\n+                        id: ast::DUMMY_NODE_ID,\n+                        rules: DefaultBlock,\n+                        span: body.span,\n+                    });\n+                return self.mk_expr(lo, body.span.hi, ExprProc(decl, fakeblock));\n+            },\n+            token::IDENT(id @ ast::Ident{name:token::SELF_KEYWORD_NAME,ctxt:_},false) => {\n+                self.bump();\n+                let path = ast_util::ident_to_path(mk_sp(lo, hi), id);\n+                ex = ExprPath(path);\n+                hi = self.last_span.hi;\n             }\n-        } else if self.eat_keyword(keywords::Loop) {\n-            return self.parse_loop_expr(None);\n-        } else if self.eat_keyword(keywords::Continue) {\n-            let lo = self.span.lo;\n-            let ex = if Parser::token_is_lifetime(&self.token) {\n+            _ if self.eat_keyword(keywords::If) => {\n+                return self.parse_if_expr();\n+            },\n+            _ if self.eat_keyword(keywords::For) => {\n+                return self.parse_for_expr(None);\n+            },\n+            _ if self.eat_keyword(keywords::While) => {\n+                return self.parse_while_expr();\n+            },\n+            _ if Parser::token_is_lifetime(&self.token) => {\n                 let lifetime = self.get_lifetime();\n                 self.bump();\n-                ExprAgain(Some(lifetime))\n-            } else {\n-                ExprAgain(None)\n-            };\n-            let hi = self.span.hi;\n-            return self.mk_expr(lo, hi, ex);\n-        } else if self.eat_keyword(keywords::Match) {\n-            return self.parse_match_expr();\n-        } else if self.eat_keyword(keywords::Unsafe) {\n-            return self.parse_block_expr(lo, UnsafeBlock(ast::UserProvided));\n-        } else if self.token == token::LBRACKET {\n-            self.bump();\n-\n-            if self.token == token::RBRACKET {\n-                // Empty vector.\n-                self.bump();\n-                ex = ExprVec(Vec::new());\n-            } else {\n-                // Nonempty vector.\n-                let first_expr = self.parse_expr();\n-                if self.token == token::COMMA &&\n-                        self.look_ahead(1, |t| *t == token::DOTDOT) {\n-                    // Repeating vector syntax: [ 0, ..512 ]\n+                self.expect(&token::COLON);\n+                if self.eat_keyword(keywords::For) {\n+                    return self.parse_for_expr(Some(lifetime))\n+                } else if self.eat_keyword(keywords::Loop) {\n+                    return self.parse_loop_expr(Some(lifetime))\n+                } else {\n+                    self.fatal(\"expected `for` or `loop` after a label\")\n+                }\n+            },\n+            _ if self.eat_keyword(keywords::Loop) => {\n+                return self.parse_loop_expr(None);\n+            },\n+            _ if self.eat_keyword(keywords::Continue) => {\n+                let lo = self.span.lo;\n+                let ex = if Parser::token_is_lifetime(&self.token) {\n+                    let lifetime = self.get_lifetime();\n                     self.bump();\n+                    ExprAgain(Some(lifetime))\n+                } else {\n+                    ExprAgain(None)\n+                };\n+                let hi = self.span.hi;\n+                return self.mk_expr(lo, hi, ex);\n+            },\n+            _ if self.eat_keyword(keywords::Match) => {\n+                return self.parse_match_expr();\n+            },\n+            _ if self.eat_keyword(keywords::Unsafe) => {\n+                return self.parse_block_expr(lo, UnsafeBlock(ast::UserProvided));\n+            },\n+            token::LBRACKET => {\n+                self.bump();\n+\n+                if self.token == token::RBRACKET {\n+                    // Empty vector.\n                     self.bump();\n-                    let count = self.parse_expr();\n-                    self.expect(&token::RBRACKET);\n-                    ex = ExprRepeat(first_expr, count);\n-                } else if self.token == token::COMMA {\n-                    // Vector with two or more elements.\n+                    ex = ExprVec(Vec::new());\n+                } else {\n+                    // Nonempty vector.\n+                    let first_expr = self.parse_expr();\n+                    if self.token == token::COMMA &&\n+                        self.look_ahead(1, |t| *t == token::DOTDOT) {\n+                        // Repeating vector syntax: [ 0, ..512 ]\n+                        self.bump();\n+                        self.bump();\n+                        let count = self.parse_expr();\n+                        self.expect(&token::RBRACKET);\n+                        ex = ExprRepeat(first_expr, count);\n+                    } else if self.token == token::COMMA {\n+                        // Vector with two or more elements.\n+                        self.bump();\n+                        let remaining_exprs = self.parse_seq_to_end(\n+                            &token::RBRACKET,\n+                            seq_sep_trailing_allowed(token::COMMA),\n+                            |p| p.parse_expr()\n+                                );\n+                        let mut exprs = vec!(first_expr);\n+                        exprs.push_all_move(remaining_exprs);\n+                        ex = ExprVec(exprs);\n+                    } else {\n+                        // Vector with one element.\n+                        self.expect(&token::RBRACKET);\n+                        ex = ExprVec(vec!(first_expr));\n+                    }\n+                }\n+                hi = self.last_span.hi;\n+            },\n+            _ if self.eat_keyword(keywords::Return) => {\n+                // RETURN expression\n+                if can_begin_expr(&self.token) {\n+                    let e = self.parse_expr();\n+                    hi = e.span.hi;\n+                    ex = ExprRet(Some(e));\n+                } else { ex = ExprRet(None); }\n+            },\n+            _ if self.eat_keyword(keywords::Break) => {\n+                // BREAK expression\n+                if Parser::token_is_lifetime(&self.token) {\n+                    let lifetime = self.get_lifetime();\n                     self.bump();\n-                    let remaining_exprs = self.parse_seq_to_end(\n-                        &token::RBRACKET,\n-                        seq_sep_trailing_allowed(token::COMMA),\n-                        |p| p.parse_expr()\n-                    );\n-                    let mut exprs = vec!(first_expr);\n-                    exprs.push_all_move(remaining_exprs);\n-                    ex = ExprVec(exprs);\n+                    ex = ExprBreak(Some(lifetime));\n                 } else {\n-                    // Vector with one element.\n-                    self.expect(&token::RBRACKET);\n-                    ex = ExprVec(vec!(first_expr));\n+                    ex = ExprBreak(None);\n                 }\n-            }\n-            hi = self.last_span.hi;\n-        } else if self.eat_keyword(keywords::Return) {\n-            // RETURN expression\n-            if can_begin_expr(&self.token) {\n-                let e = self.parse_expr();\n-                hi = e.span.hi;\n-                ex = ExprRet(Some(e));\n-            } else { ex = ExprRet(None); }\n-        } else if self.eat_keyword(keywords::Break) {\n-            // BREAK expression\n-            if Parser::token_is_lifetime(&self.token) {\n-                let lifetime = self.get_lifetime();\n-                self.bump();\n-                ex = ExprBreak(Some(lifetime));\n-            } else {\n-                ex = ExprBreak(None);\n-            }\n-            hi = self.span.hi;\n-        } else if self.token == token::MOD_SEP ||\n+                hi = self.span.hi;\n+            },\n+            _ if self.token == token::MOD_SEP ||\n                 is_ident(&self.token) && !self.is_keyword(keywords::True) &&\n-                !self.is_keyword(keywords::False) {\n-            let pth = self.parse_path(LifetimeAndTypesWithColons).path;\n+                !self.is_keyword(keywords::False) => {\n+                let pth = self.parse_path(LifetimeAndTypesWithColons).path;\n \n-            // `!`, as an operator, is prefix, so we know this isn't that\n-            if self.token == token::NOT {\n-                // MACRO INVOCATION expression\n-                self.bump();\n+                // `!`, as an operator, is prefix, so we know this isn't that\n+                if self.token == token::NOT {\n+                    // MACRO INVOCATION expression\n+                    self.bump();\n \n-                let ket = token::close_delimiter_for(&self.token)\n-                                .unwrap_or_else(|| self.fatal(\"expected open delimiter\"));\n-                self.bump();\n+                    let ket = token::close_delimiter_for(&self.token)\n+                        .unwrap_or_else(|| self.fatal(\"expected open delimiter\"));\n+                    self.bump();\n \n-                let tts = self.parse_seq_to_end(&ket,\n-                                                seq_sep_none(),\n-                                                |p| p.parse_token_tree());\n-                let hi = self.span.hi;\n+                    let tts = self.parse_seq_to_end(&ket,\n+                                                    seq_sep_none(),\n+                                                    |p| p.parse_token_tree());\n+                    let hi = self.span.hi;\n \n-                return self.mk_mac_expr(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT));\n-            } else if self.token == token::LBRACE {\n-                // This is a struct literal, unless we're prohibited from\n-                // parsing struct literals here.\n-                if self.restriction != RESTRICT_NO_STRUCT_LITERAL {\n-                    // It's a struct literal.\n-                    self.bump();\n-                    let mut fields = Vec::new();\n-                    let mut base = None;\n+                    return self.mk_mac_expr(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT));\n+                } else if self.token == token::LBRACE {\n+                    // This is a struct literal, unless we're prohibited from\n+                    // parsing struct literals here.\n+                    if self.restriction != RESTRICT_NO_STRUCT_LITERAL {\n+                        // It's a struct literal.\n+                        self.bump();\n+                        let mut fields = Vec::new();\n+                        let mut base = None;\n \n-                    while self.token != token::RBRACE {\n-                        if self.eat(&token::DOTDOT) {\n-                            base = Some(self.parse_expr());\n-                            break;\n+                        while self.token != token::RBRACE {\n+                            if self.eat(&token::DOTDOT) {\n+                                base = Some(self.parse_expr());\n+                                break;\n+                            }\n+\n+                            fields.push(self.parse_field());\n+                            self.commit_expr(fields.last().unwrap().expr,\n+                                             &[token::COMMA], &[token::RBRACE]);\n                         }\n \n-                        fields.push(self.parse_field());\n-                        self.commit_expr(fields.last().unwrap().expr,\n-                                         &[token::COMMA], &[token::RBRACE]);\n-                    }\n+                        if fields.len() == 0 && base.is_none() {\n+                            let last_span = self.last_span;\n+                            self.span_err(last_span,\n+                                          \"structure literal must either have at \\\n+                                          least one field or use functional \\\n+                                          structure update syntax\");\n+                        }\n \n-                    if fields.len() == 0 && base.is_none() {\n-                        let last_span = self.last_span;\n-                        self.span_err(last_span,\n-                                      \"structure literal must either have at \\\n-                                       least one field or use functional \\\n-                                       structure update syntax\");\n+                        hi = self.span.hi;\n+                        self.expect(&token::RBRACE);\n+                        ex = ExprStruct(pth, fields, base);\n+                        return self.mk_expr(lo, hi, ex);\n                     }\n-\n-                    hi = self.span.hi;\n-                    self.expect(&token::RBRACE);\n-                    ex = ExprStruct(pth, fields, base);\n-                    return self.mk_expr(lo, hi, ex);\n                 }\n-            }\n \n             hi = pth.span.hi;\n             ex = ExprPath(pth);\n-        } else {\n-            // other literal expression\n-            let lit = self.parse_lit();\n-            hi = lit.span.hi;\n-            ex = ExprLit(box(GC) lit);\n+            },\n+            _ => {\n+                // other literal expression\n+                let lit = self.parse_lit();\n+                hi = lit.span.hi;\n+                ex = ExprLit(box(GC) lit);\n+            }\n         }\n \n         return self.mk_expr(lo, hi, ex);\n@@ -3213,18 +3233,6 @@ impl<'a> Parser<'a> {\n         } else if is_ident(&self.token)\n             && !token::is_any_keyword(&self.token)\n             && self.look_ahead(1, |t| *t == token::NOT) {\n-            // parse a macro invocation. Looks like there's serious\n-            // overlap here; if this clause doesn't catch it (and it\n-            // won't, for brace-delimited macros) it will fall through\n-            // to the macro clause of parse_item_or_view_item. This\n-            // could use some cleanup, it appears to me.\n-\n-            // whoops! I now have a guess: I'm guessing the \"parens-only\"\n-            // rule here is deliberate, to allow macro users to use parens\n-            // for things that should be parsed as stmt_mac, and braces\n-            // for things that should expand into items. Tricky, and\n-            // somewhat awkward... and probably undocumented. Of course,\n-            // I could just be wrong.\n \n             check_expected_item(self, !item_attrs.is_empty());\n \n@@ -3740,13 +3748,18 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn expect_self_ident(&mut self) {\n-        if !self.is_self_ident() {\n-            let token_str = self.this_token_to_string();\n-            self.fatal(format!(\"expected `self` but found `{}`\",\n-                               token_str).as_slice())\n+    fn expect_self_ident(&mut self) -> ast::Ident {\n+        match self.token {\n+            token::IDENT(id, false) if id.name == special_idents::self_.name => {\n+                self.bump();\n+                id\n+            },\n+            _ => {\n+                let token_str = self.this_token_to_string();\n+                self.fatal(format!(\"expected `self` but found `{}`\",\n+                                   token_str).as_slice())\n+            }\n         }\n-        self.bump();\n     }\n \n     // parse the argument list and result type of a function\n@@ -3766,24 +3779,21 @@ impl<'a> Parser<'a> {\n \n             if this.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) {\n                 this.bump();\n-                this.expect_self_ident();\n-                SelfRegion(None, MutImmutable)\n+                SelfRegion(None, MutImmutable, this.expect_self_ident())\n             } else if this.look_ahead(1, |t| Parser::token_is_mutability(t)) &&\n                     this.look_ahead(2,\n                                     |t| token::is_keyword(keywords::Self,\n                                                           t)) {\n                 this.bump();\n                 let mutability = this.parse_mutability();\n-                this.expect_self_ident();\n-                SelfRegion(None, mutability)\n+                SelfRegion(None, mutability, this.expect_self_ident())\n             } else if this.look_ahead(1, |t| Parser::token_is_lifetime(t)) &&\n                        this.look_ahead(2,\n                                        |t| token::is_keyword(keywords::Self,\n                                                              t)) {\n                 this.bump();\n                 let lifetime = this.parse_lifetime();\n-                this.expect_self_ident();\n-                SelfRegion(Some(lifetime), MutImmutable)\n+                SelfRegion(Some(lifetime), MutImmutable, this.expect_self_ident())\n             } else if this.look_ahead(1, |t| Parser::token_is_lifetime(t)) &&\n                       this.look_ahead(2, |t| {\n                           Parser::token_is_mutability(t)\n@@ -3793,8 +3803,7 @@ impl<'a> Parser<'a> {\n                 this.bump();\n                 let lifetime = this.parse_lifetime();\n                 let mutability = this.parse_mutability();\n-                this.expect_self_ident();\n-                SelfRegion(Some(lifetime), mutability)\n+                SelfRegion(Some(lifetime), mutability, this.expect_self_ident())\n             } else {\n                 SelfStatic\n             }\n@@ -3814,15 +3823,13 @@ impl<'a> Parser<'a> {\n                 // We need to make sure it isn't a type\n                 if self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) {\n                     self.bump();\n-                    self.expect_self_ident();\n-                    SelfUniq\n+                    SelfUniq(self.expect_self_ident())\n                 } else {\n                     SelfStatic\n                 }\n             }\n             token::IDENT(..) if self.is_self_ident() => {\n-                self.bump();\n-                SelfValue\n+                SelfValue(self.expect_self_ident())\n             }\n             token::BINOP(token::STAR) => {\n                 // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n@@ -3836,29 +3843,32 @@ impl<'a> Parser<'a> {\n                     self.span_err(span, \"cannot pass self by unsafe pointer\");\n                     self.bump();\n                 }\n-                SelfValue\n+                // error case, making bogus self ident:\n+                SelfValue(special_idents::self_)\n             }\n             _ if Parser::token_is_mutability(&self.token) &&\n                     self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) => {\n                 mutbl_self = self.parse_mutability();\n-                self.expect_self_ident();\n-                SelfValue\n+                SelfValue(self.expect_self_ident())\n             }\n             _ if Parser::token_is_mutability(&self.token) &&\n                     self.look_ahead(1, |t| *t == token::TILDE) &&\n                     self.look_ahead(2, |t| token::is_keyword(keywords::Self, t)) => {\n                 mutbl_self = self.parse_mutability();\n                 self.bump();\n-                self.expect_self_ident();\n-                SelfUniq\n+                SelfUniq(self.expect_self_ident())\n             }\n             _ => SelfStatic\n         };\n \n         let explicit_self_sp = mk_sp(lo, self.span.hi);\n \n-        // If we parsed a self type, expect a comma before the argument list.\n-        let fn_inputs = if explicit_self != SelfStatic {\n+        // shared fall-through for the three cases below. borrowing prevents simply\n+        // writing this as a closure\n+        macro_rules! parse_remaining_arguments {\n+            ($self_id:ident) =>\n+            {\n+            // If we parsed a self type, expect a comma before the argument list.\n             match self.token {\n                 token::COMMA => {\n                     self.bump();\n@@ -3868,23 +3878,33 @@ impl<'a> Parser<'a> {\n                         sep,\n                         parse_arg_fn\n                     );\n-                    fn_inputs.unshift(Arg::new_self(explicit_self_sp, mutbl_self));\n+                    fn_inputs.unshift(Arg::new_self(explicit_self_sp, mutbl_self, $self_id));\n                     fn_inputs\n                 }\n                 token::RPAREN => {\n-                    vec!(Arg::new_self(explicit_self_sp, mutbl_self))\n+                    vec!(Arg::new_self(explicit_self_sp, mutbl_self, $self_id))\n                 }\n                 _ => {\n                     let token_str = self.this_token_to_string();\n                     self.fatal(format!(\"expected `,` or `)`, found `{}`\",\n                                        token_str).as_slice())\n                 }\n             }\n-        } else {\n-            let sep = seq_sep_trailing_disallowed(token::COMMA);\n-            self.parse_seq_to_before_end(&token::RPAREN, sep, parse_arg_fn)\n+            }\n+        }\n+\n+        let fn_inputs = match explicit_self {\n+            SelfStatic =>  {\n+                let sep = seq_sep_trailing_disallowed(token::COMMA);\n+                self.parse_seq_to_before_end(&token::RPAREN, sep, parse_arg_fn)\n+            }\n+            SelfValue(id) => parse_remaining_arguments!(id),\n+            SelfRegion(_,_,id) => parse_remaining_arguments!(id),\n+            SelfUniq(id) => parse_remaining_arguments!(id)\n+\n         };\n \n+\n         self.expect(&token::RPAREN);\n \n         let hi = self.span.hi;"}, {"sha": "55db3482a61a731a1d2eb91066d0f70ea9d9f088", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -365,10 +365,6 @@ pub fn is_plain_ident(t: &Token) -> bool {\n     match *t { IDENT(_, false) => true, _ => false }\n }\n \n-pub fn is_bar(t: &Token) -> bool {\n-    match *t { BINOP(OR) | OROR => true, _ => false }\n-}\n-\n // Get the first \"argument\"\n macro_rules! first {\n     ( $first:expr, $( $remainder:expr, )* ) => ( $first )\n@@ -409,6 +405,11 @@ macro_rules! declare_special_idents_and_keywords {(\n         $( pub static $si_static: Ident = Ident { name: $si_name, ctxt: 0 }; )*\n     }\n \n+    pub mod special_names {\n+        use ast::Name;\n+        $( pub static $si_static: Name =  $si_name; )*\n+    }\n+\n     /**\n      * All the valid words that have meaning in the Rust language.\n      *\n@@ -417,26 +418,26 @@ macro_rules! declare_special_idents_and_keywords {(\n      * the language and may not appear as identifiers.\n      */\n     pub mod keywords {\n-        use ast::Ident;\n+        use ast::Name;\n \n         pub enum Keyword {\n             $( $sk_variant, )*\n             $( $rk_variant, )*\n         }\n \n         impl Keyword {\n-            pub fn to_ident(&self) -> Ident {\n+            pub fn to_name(&self) -> Name {\n                 match *self {\n-                    $( $sk_variant => Ident { name: $sk_name, ctxt: 0 }, )*\n-                    $( $rk_variant => Ident { name: $rk_name, ctxt: 0 }, )*\n+                    $( $sk_variant => $sk_name, )*\n+                    $( $rk_variant => $rk_name, )*\n                 }\n             }\n         }\n     }\n \n     fn mk_fresh_ident_interner() -> IdentInterner {\n         // The indices here must correspond to the numbers in\n-        // special_idents, in Keyword to_ident(), and in static\n+        // special_idents, in Keyword to_name(), and in static\n         // constants below.\n         let mut init_vec = Vec::new();\n         $(init_vec.push($si_str);)*\n@@ -447,7 +448,7 @@ macro_rules! declare_special_idents_and_keywords {(\n }}\n \n // If the special idents get renumbered, remember to modify these two as appropriate\n-static SELF_KEYWORD_NAME: Name = 1;\n+pub static SELF_KEYWORD_NAME: Name = 1;\n static STATIC_KEYWORD_NAME: Name = 2;\n \n // NB: leaving holes in the ident table is bad! a different ident will get\n@@ -714,7 +715,7 @@ pub fn fresh_mark() -> Mrk {\n \n pub fn is_keyword(kw: keywords::Keyword, tok: &Token) -> bool {\n     match *tok {\n-        token::IDENT(sid, false) => { kw.to_ident().name == sid.name }\n+        token::IDENT(sid, false) => { kw.to_name() == sid.name }\n         _ => { false }\n     }\n }"}, {"sha": "a5d70a9333ddea942e242e07c8e9e77cf1c51cf8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -1967,13 +1967,13 @@ impl<'a> State<'a> {\n         try!(self.print_mutability(mutbl));\n         match explicit_self {\n             ast::SelfStatic => { return Ok(false); }\n-            ast::SelfValue => {\n+            ast::SelfValue(_) => {\n                 try!(word(&mut self.s, \"self\"));\n             }\n-            ast::SelfUniq => {\n+            ast::SelfUniq(_) => {\n                 try!(word(&mut self.s, \"~self\"));\n             }\n-            ast::SelfRegion(ref lt, m) => {\n+            ast::SelfRegion(ref lt, m, _) => {\n                 try!(word(&mut self.s, \"&\"));\n                 try!(self.print_opt_lifetime(lt));\n                 try!(self.print_mutability(m));"}, {"sha": "df34ff30db67f1dfd455e0bc943b28a381a280cc", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -202,8 +202,8 @@ pub fn walk_explicit_self<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                    explicit_self: &ExplicitSelf,\n                                                    env: E) {\n     match explicit_self.node {\n-        SelfStatic | SelfValue | SelfUniq => {}\n-        SelfRegion(ref lifetime, _) => {\n+        SelfStatic | SelfValue(_) | SelfUniq(_) => {},\n+        SelfRegion(ref lifetime, _, _) => {\n             visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime, env)\n         }\n     }"}, {"sha": "75494c47dcef10746663b0ab18f249578f0b2ed0", "filename": "src/test/run-pass/issue-7911.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Ftest%2Frun-pass%2Fissue-7911.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5716abe3f019ab7d9c8cdde9879332040191cf88/src%2Ftest%2Frun-pass%2Fissue-7911.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7911.rs?ref=5716abe3f019ab7d9c8cdde9879332040191cf88", "patch": "@@ -27,19 +27,19 @@ trait Test {\n     fn get_mut<'r>(&'r mut self) -> &'r mut FooBar;\n }\n \n-macro_rules! generate_test(($type_:path, $field:expr) => (\n+macro_rules! generate_test(($type_:path, $slf:ident, $field:expr) => (\n     impl Test for $type_ {\n-        fn get_immut<'r>(&'r self) -> &'r FooBar {\n+        fn get_immut<'r>(&'r $slf) -> &'r FooBar {\n             &$field as &FooBar\n         }\n \n-        fn get_mut<'r>(&'r mut self) -> &'r mut FooBar {\n+        fn get_mut<'r>(&'r mut $slf) -> &'r mut FooBar {\n             &mut $field as &mut FooBar\n         }\n     }\n ))\n \n-generate_test!(Foo, self.bar)\n+generate_test!(Foo, self, self.bar)\n \n pub fn main() {\n     let mut foo: Foo = Foo { bar: Bar(42) };"}]}