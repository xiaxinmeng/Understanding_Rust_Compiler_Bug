{"sha": "498216e9db724cb26f269b0419d4e9e2897cee79", "node_id": "C_kwDOAAsO6NoAKDQ5ODIxNmU5ZGI3MjRjYjI2ZjI2OWIwNDE5ZDRlOWUyODk3Y2VlNzk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-06T20:26:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-06T20:26:10Z"}, "message": "Rollup merge of #106341 - Ezrashaw:refactor-error-code-tidy-check, r=mejrs,klensy,GuillaumeGomez\n\nrefactor: clean up `errors.rs` and `error_codes_check.rs`\n\n`errors.rs` is basically unused now, `error_codes_check.rs` is useful but not well commented, etc. It also doesn't check certain things which are certainly not correct. For example, `E0505` has a UI test in `src/test/ui/error-codes/` but that test actually outputs `E0504`?! Other issues like these exist. I've implemented these with \"warnings\" which are a bit rough around the edges but should be removed eventually.\n\nr? `@GuillaumeGomez` (again not sure if you want to review but its relevant to you)", "tree": {"sha": "cbda599052c365aaa20441a53038a98cc32d7099", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbda599052c365aaa20441a53038a98cc32d7099"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/498216e9db724cb26f269b0419d4e9e2897cee79", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjuIPiCRBK7hj4Ov3rIwAAq7AIADVW4iZROyaP5XcdIqVTSbp7\nDpjuGorgSsx7wGFSAfsivWjh0N0PI717fscLdrNwwYmy73tgNx6YKtiAgtRoG7tq\nowtlfZkh+scK5n2P0x8VJtM5lxqfSjxsXjWpBYwfISNaqc3Rq3fsHhQFI6WTmvaP\n3dw1PlVZiH/vly99pAeWm1e3PXibKumY8dLj5WjneFAa+Y+OegyPlNO+0FSXLjXH\nIJWTDc0PMKemgdKFuE/oaYZqGOfFiilVHHPonZY4tAu8aZpeV8SlubdUAxeX/VW/\nLbJ4SVwoSTxuYWg+QrkW5l1I+u3TkLJAD+Bn/CsgkBVRTHF5NgKNgvxH4WEfkp4=\n=KMd2\n-----END PGP SIGNATURE-----\n", "payload": "tree cbda599052c365aaa20441a53038a98cc32d7099\nparent 7568c49bf0c11038635458cabb9661b6b4297d74\nparent c00ab4b2de2b5a321476244a9316d4dd3d8f8242\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1673036770 +0100\ncommitter GitHub <noreply@github.com> 1673036770 +0100\n\nRollup merge of #106341 - Ezrashaw:refactor-error-code-tidy-check, r=mejrs,klensy,GuillaumeGomez\n\nrefactor: clean up `errors.rs` and `error_codes_check.rs`\n\n`errors.rs` is basically unused now, `error_codes_check.rs` is useful but not well commented, etc. It also doesn't check certain things which are certainly not correct. For example, `E0505` has a UI test in `src/test/ui/error-codes/` but that test actually outputs `E0504`?! Other issues like these exist. I've implemented these with \"warnings\" which are a bit rough around the edges but should be removed eventually.\n\nr? `@GuillaumeGomez` (again not sure if you want to review but its relevant to you)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/498216e9db724cb26f269b0419d4e9e2897cee79", "html_url": "https://github.com/rust-lang/rust/commit/498216e9db724cb26f269b0419d4e9e2897cee79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/498216e9db724cb26f269b0419d4e9e2897cee79/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7568c49bf0c11038635458cabb9661b6b4297d74", "url": "https://api.github.com/repos/rust-lang/rust/commits/7568c49bf0c11038635458cabb9661b6b4297d74", "html_url": "https://github.com/rust-lang/rust/commit/7568c49bf0c11038635458cabb9661b6b4297d74"}, {"sha": "c00ab4b2de2b5a321476244a9316d4dd3d8f8242", "url": "https://api.github.com/repos/rust-lang/rust/commits/c00ab4b2de2b5a321476244a9316d4dd3d8f8242", "html_url": "https://github.com/rust-lang/rust/commit/c00ab4b2de2b5a321476244a9316d4dd3d8f8242"}], "stats": {"total": 772, "additions": 386, "deletions": 386}, "files": [{"sha": "3891745b5008efaa8475462cdb2d21e050e29e84", "filename": "compiler/rustc_error_codes/src/error_codes/E0729.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498216e9db724cb26f269b0419d4e9e2897cee79/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0729.md", "raw_url": "https://github.com/rust-lang/rust/raw/498216e9db724cb26f269b0419d4e9e2897cee79/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0729.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0729.md?ref=498216e9db724cb26f269b0419d4e9e2897cee79", "patch": "@@ -1,3 +1,5 @@\n+#### Note: this error code is no longer emitted by the compiler\n+\n Support for Non-Lexical Lifetimes (NLL) has been included in the Rust compiler\n since 1.31, and has been enabled on the 2015 edition since 1.36. The new borrow\n checker for NLL uncovered some bugs in the old borrow checker, which in some"}, {"sha": "fdc9d789905905004581216b1dd5dc08b9fdfdc2", "filename": "src/tools/tidy/src/error_codes.rs", "status": "added", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/498216e9db724cb26f269b0419d4e9e2897cee79/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498216e9db724cb26f269b0419d4e9e2897cee79/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs?ref=498216e9db724cb26f269b0419d4e9e2897cee79", "patch": "@@ -0,0 +1,381 @@\n+//! Tidy check to ensure error codes are properly documented and tested.\n+//!\n+//! Overview of check:\n+//!\n+//! 1. We create a list of error codes used by the compiler. Error codes are extracted from `compiler/rustc_error_codes/src/error_codes.rs`.\n+//!\n+//! 2. We check that the error code has a long-form explanation in `compiler/rustc_error_codes/src/error_codes/`.\n+//!   - The explanation is expected to contain a `doctest` that fails with the correct error code. (`EXEMPT_FROM_DOCTEST` *currently* bypasses this check)\n+//!   - Note that other stylistic conventions for markdown files are checked in the `style.rs` tidy check.\n+//!\n+//! 3. We check that the error code has a UI test in `src/test/ui/error-codes/`.\n+//!   - We ensure that there is both a `Exxxx.rs` file and a corresponding `Exxxx.stderr` file.\n+//!   - We also ensure that the error code is used in the tests.\n+//!   - *Currently*, it is possible to opt-out of this check with the `EXEMPTED_FROM_TEST` constant.\n+//!\n+//! 4. We check that the error code is actually emitted by the compiler.\n+//!   - This is done by searching `compiler/` with a regex.\n+//!\n+//! This tidy check was merged and refactored from two others. See #PR_NUM for information about linting changes that occurred during this refactor.\n+\n+use std::{ffi::OsStr, fs, path::Path};\n+\n+use regex::Regex;\n+\n+use crate::walk::{filter_dirs, walk, walk_many};\n+\n+const ERROR_CODES_PATH: &str = \"compiler/rustc_error_codes/src/error_codes.rs\";\n+const ERROR_DOCS_PATH: &str = \"compiler/rustc_error_codes/src/error_codes/\";\n+const ERROR_TESTS_PATH: &str = \"src/test/ui/error-codes/\";\n+\n+// Error codes that (for some reason) can't have a doctest in their explanation. Error codes are still expected to provide a code example, even if untested.\n+const IGNORE_DOCTEST_CHECK: &[&str] = &[\"E0464\", \"E0570\", \"E0601\", \"E0602\"];\n+\n+// Error codes that don't yet have a UI test. This list will eventually be removed.\n+const IGNORE_UI_TEST_CHECK: &[&str] = &[\n+    \"E0313\", \"E0461\", \"E0465\", \"E0476\", \"E0490\", \"E0514\", \"E0523\", \"E0554\", \"E0640\", \"E0717\",\n+    \"E0729\", \"E0789\",\n+];\n+\n+macro_rules! verbose_print {\n+    ($verbose:expr, $($fmt:tt)*) => {\n+        if $verbose {\n+            println!(\"{}\", format_args!($($fmt)*));\n+        }\n+    };\n+}\n+\n+pub fn check(root_path: &Path, search_paths: &[&Path], verbose: bool, bad: &mut bool) {\n+    let mut errors = Vec::new();\n+\n+    // Stage 1: create list\n+    let error_codes = extract_error_codes(root_path, &mut errors, verbose);\n+    println!(\"Found {} error codes\", error_codes.len());\n+    println!(\"Highest error code: `{}`\", error_codes.iter().max().unwrap());\n+\n+    // Stage 2: check list has docs\n+    let no_longer_emitted = check_error_codes_docs(root_path, &error_codes, &mut errors, verbose);\n+\n+    // Stage 3: check list has UI tests\n+    check_error_codes_tests(root_path, &error_codes, &mut errors, verbose);\n+\n+    // Stage 4: check list is emitted by compiler\n+    check_error_codes_used(search_paths, &error_codes, &mut errors, &no_longer_emitted, verbose);\n+\n+    // Print any errors.\n+    for error in errors {\n+        tidy_error!(bad, \"{}\", error);\n+    }\n+}\n+\n+/// Stage 1: Parses a list of error codes from `error_codes.rs`.\n+fn extract_error_codes(root_path: &Path, errors: &mut Vec<String>, verbose: bool) -> Vec<String> {\n+    let path = root_path.join(Path::new(ERROR_CODES_PATH));\n+    let file =\n+        fs::read_to_string(&path).unwrap_or_else(|e| panic!(\"failed to read `{path:?}`: {e}\"));\n+\n+    let mut error_codes = Vec::new();\n+    let mut reached_undocumented_codes = false;\n+\n+    for line in file.lines() {\n+        let line = line.trim();\n+\n+        if !reached_undocumented_codes && line.starts_with('E') {\n+            let split_line = line.split_once(':');\n+\n+            // Extract the error code from the line, emitting a fatal error if it is not in a correct format.\n+            let err_code = if let Some(err_code) = split_line {\n+                err_code.0.to_owned()\n+            } else {\n+                errors.push(format!(\n+                    \"Expected a line with the format `Exxxx: include_str!(\\\"..\\\")`, but got \\\"{}\\\" \\\n+                    without a `:` delimiter\",\n+                    line,\n+                ));\n+                continue;\n+            };\n+\n+            // If this is a duplicate of another error code, emit a fatal error.\n+            if error_codes.contains(&err_code) {\n+                errors.push(format!(\"Found duplicate error code: `{}`\", err_code));\n+                continue;\n+            }\n+\n+            // Ensure that the line references the correct markdown file.\n+            let expected_filename = format!(\" include_str!(\\\"./error_codes/{}.md\\\"),\", err_code);\n+            if expected_filename != split_line.unwrap().1 {\n+                errors.push(format!(\n+                    \"Error code `{}` expected to reference docs with `{}` but instead found `{}` in \\\n+                    `compiler/rustc_error_codes/src/error_codes.rs`\",\n+                    err_code,\n+                    expected_filename,\n+                    split_line.unwrap().1,\n+                ));\n+                continue;\n+            }\n+\n+            error_codes.push(err_code);\n+        } else if reached_undocumented_codes && line.starts_with('E') {\n+            let err_code = match line.split_once(',') {\n+                None => line,\n+                Some((err_code, _)) => err_code,\n+            }\n+            .to_string();\n+\n+            verbose_print!(verbose, \"warning: Error code `{}` is undocumented.\", err_code);\n+\n+            if error_codes.contains(&err_code) {\n+                errors.push(format!(\"Found duplicate error code: `{}`\", err_code));\n+            }\n+\n+            error_codes.push(err_code);\n+        } else if line == \";\" {\n+            // Once we reach the undocumented error codes, adapt to different syntax.\n+            reached_undocumented_codes = true;\n+        }\n+    }\n+\n+    error_codes\n+}\n+\n+/// Stage 2: Checks that long-form error code explanations exist and have doctests.\n+fn check_error_codes_docs(\n+    root_path: &Path,\n+    error_codes: &[String],\n+    errors: &mut Vec<String>,\n+    verbose: bool,\n+) -> Vec<String> {\n+    let docs_path = root_path.join(Path::new(ERROR_DOCS_PATH));\n+\n+    let mut no_longer_emitted_codes = Vec::new();\n+\n+    walk(&docs_path, &mut |_| false, &mut |entry, contents| {\n+        let path = entry.path();\n+\n+        // Error if the file isn't markdown.\n+        if path.extension() != Some(OsStr::new(\"md\")) {\n+            errors.push(format!(\n+                \"Found unexpected non-markdown file in error code docs directory: {}\",\n+                path.display()\n+            ));\n+            return;\n+        }\n+\n+        // Make sure that the file is referenced in `error_codes.rs`\n+        let filename = path.file_name().unwrap().to_str().unwrap().split_once('.');\n+        let err_code = filename.unwrap().0; // `unwrap` is ok because we know the filename is in the correct format.\n+\n+        if error_codes.iter().all(|e| e != err_code) {\n+            errors.push(format!(\n+                \"Found valid file `{}` in error code docs directory without corresponding \\\n+                entry in `error_code.rs`\",\n+                path.display()\n+            ));\n+            return;\n+        }\n+\n+        let (found_code_example, found_proper_doctest, emit_ignore_warning, emit_no_longer_warning) =\n+            check_explanation_has_doctest(&contents, &err_code);\n+        if emit_ignore_warning {\n+            verbose_print!(\n+                verbose,\n+                \"warning: Error code `{err_code}` uses the ignore header. This should not be used, add the error code to the \\\n+                `IGNORE_DOCTEST_CHECK` constant instead.\"\n+            );\n+        }\n+        if emit_no_longer_warning {\n+            no_longer_emitted_codes.push(err_code.to_owned());\n+            verbose_print!(\n+                verbose,\n+                \"warning: Error code `{err_code}` is no longer emitted and should be removed entirely.\"\n+            );\n+        }\n+        if !found_code_example {\n+            verbose_print!(\n+                verbose,\n+                \"warning: Error code `{err_code}` doesn't have a code example, all error codes are expected to have one \\\n+                (even if untested).\"\n+            );\n+        }\n+\n+        let test_ignored = IGNORE_DOCTEST_CHECK.contains(&&err_code);\n+\n+        // Check that the explanation has a doctest, and if it shouldn't, that it doesn't\n+        if !found_proper_doctest && !test_ignored {\n+            errors.push(format!(\n+                \"`{}` doesn't use its own error code in compile_fail example\",\n+                path.display(),\n+            ));\n+        } else if found_proper_doctest && test_ignored {\n+            errors.push(format!(\n+                \"`{}` has a compile_fail doctest with its own error code, it shouldn't \\\n+                be listed in `IGNORE_DOCTEST_CHECK`\",\n+                path.display(),\n+            ));\n+        }\n+    });\n+\n+    no_longer_emitted_codes\n+}\n+\n+/// This function returns a tuple indicating whether the provided explanation:\n+/// a) has a code example, tested or not.\n+/// b) has a valid doctest\n+fn check_explanation_has_doctest(explanation: &str, err_code: &str) -> (bool, bool, bool, bool) {\n+    let mut found_code_example = false;\n+    let mut found_proper_doctest = false;\n+\n+    let mut emit_ignore_warning = false;\n+    let mut emit_no_longer_warning = false;\n+\n+    for line in explanation.lines() {\n+        let line = line.trim();\n+\n+        if line.starts_with(\"```\") {\n+            found_code_example = true;\n+\n+            // Check for the `rustdoc` doctest headers.\n+            if line.contains(\"compile_fail\") && line.contains(err_code) {\n+                found_proper_doctest = true;\n+            }\n+\n+            if line.contains(\"ignore\") {\n+                emit_ignore_warning = true;\n+                found_proper_doctest = true;\n+            }\n+        } else if line\n+            .starts_with(\"#### Note: this error code is no longer emitted by the compiler\")\n+        {\n+            emit_no_longer_warning = true;\n+            found_code_example = true;\n+            found_proper_doctest = true;\n+        }\n+    }\n+\n+    (found_code_example, found_proper_doctest, emit_ignore_warning, emit_no_longer_warning)\n+}\n+\n+// Stage 3: Checks that each error code has a UI test in the correct directory\n+fn check_error_codes_tests(\n+    root_path: &Path,\n+    error_codes: &[String],\n+    errors: &mut Vec<String>,\n+    verbose: bool,\n+) {\n+    let tests_path = root_path.join(Path::new(ERROR_TESTS_PATH));\n+\n+    for code in error_codes {\n+        let test_path = tests_path.join(format!(\"{}.stderr\", code));\n+\n+        if !test_path.exists() && !IGNORE_UI_TEST_CHECK.contains(&code.as_str()) {\n+            verbose_print!(\n+                verbose,\n+                \"warning: Error code `{code}` needs to have at least one UI test in the `src/test/ui/error-codes/` directory`!\"\n+            );\n+            continue;\n+        }\n+        if IGNORE_UI_TEST_CHECK.contains(&code.as_str()) {\n+            if test_path.exists() {\n+                errors.push(format!(\n+                    \"Error code `{code}` has a UI test in `src/test/ui/error-codes/{code}.rs`, it shouldn't be listed in `EXEMPTED_FROM_TEST`!\"\n+                ));\n+            }\n+            continue;\n+        }\n+\n+        let file = match fs::read_to_string(&test_path) {\n+            Ok(file) => file,\n+            Err(err) => {\n+                verbose_print!(\n+                    verbose,\n+                    \"warning: Failed to read UI test file (`{}`) for `{code}` but the file exists. The test is assumed to work:\\n{err}\",\n+                    test_path.display()\n+                );\n+                continue;\n+            }\n+        };\n+\n+        let mut found_code = false;\n+\n+        for line in file.lines() {\n+            let s = line.trim();\n+            // Assuming the line starts with `error[E`, we can substring the error code out.\n+            if s.starts_with(\"error[E\") {\n+                if &s[6..11] == code {\n+                    found_code = true;\n+                    break;\n+                }\n+            };\n+        }\n+\n+        if !found_code {\n+            verbose_print!(\n+                verbose,\n+                \"warning: Error code {code}`` has a UI test file, but doesn't contain its own error code!\"\n+            );\n+        }\n+    }\n+}\n+\n+/// Stage 4: Search `compiler/` and ensure that every error code is actually used by the compiler and that no undocumented error codes exist.\n+fn check_error_codes_used(\n+    search_paths: &[&Path],\n+    error_codes: &[String],\n+    errors: &mut Vec<String>,\n+    no_longer_emitted: &[String],\n+    verbose: bool,\n+) {\n+    // We want error codes which match the following cases:\n+    //\n+    // * foo(a, E0111, a)\n+    // * foo(a, E0111)\n+    // * foo(E0111, a)\n+    // * #[error = \"E0111\"]\n+    let regex = Regex::new(r#\"[(,\"\\s](E\\d{4})[,)\"]\"#).unwrap();\n+\n+    let mut found_codes = Vec::new();\n+\n+    walk_many(search_paths, &mut filter_dirs, &mut |entry, contents| {\n+        let path = entry.path();\n+\n+        // Return early if we aren't looking at a source file.\n+        if path.extension() != Some(OsStr::new(\"rs\")) {\n+            return;\n+        }\n+\n+        for line in contents.lines() {\n+            // We want to avoid parsing error codes in comments.\n+            if line.trim_start().starts_with(\"//\") {\n+                continue;\n+            }\n+\n+            for cap in regex.captures_iter(line) {\n+                if let Some(error_code) = cap.get(1) {\n+                    let error_code = error_code.as_str().to_owned();\n+\n+                    if !error_codes.contains(&error_code) {\n+                        // This error code isn't properly defined, we must error.\n+                        errors.push(format!(\"Error code `{}` is used in the compiler but not defined and documented in `compiler/rustc_error_codes/src/error_codes.rs`.\", error_code));\n+                        continue;\n+                    }\n+\n+                    // This error code can now be marked as used.\n+                    found_codes.push(error_code);\n+                }\n+            }\n+        }\n+    });\n+\n+    for code in error_codes {\n+        if !found_codes.contains(code) && !no_longer_emitted.contains(code) {\n+            errors.push(format!(\"Error code `{code}` exists, but is not emitted by the compiler!\"))\n+        }\n+\n+        if found_codes.contains(code) && no_longer_emitted.contains(code) {\n+            verbose_print!(\n+                verbose,\n+                \"warning: Error code `{code}` is used when it's marked as \\\"no longer emitted\\\"\"\n+            );\n+        }\n+    }\n+}"}, {"sha": "3f060e437aca7ac72a0c3404da445637c81afad6", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/7568c49bf0c11038635458cabb9661b6b4297d74/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7568c49bf0c11038635458cabb9661b6b4297d74/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=7568c49bf0c11038635458cabb9661b6b4297d74", "patch": "@@ -1,305 +0,0 @@\n-//! Checks that all error codes have at least one test to prevent having error\n-//! codes that are silently not thrown by the compiler anymore.\n-\n-use crate::walk::{filter_dirs, walk};\n-use std::collections::{HashMap, HashSet};\n-use std::ffi::OsStr;\n-use std::fs::read_to_string;\n-use std::path::Path;\n-\n-use regex::Regex;\n-\n-// A few of those error codes can't be tested but all the others can and *should* be tested!\n-const EXEMPTED_FROM_TEST: &[&str] = &[\n-    \"E0313\", \"E0461\", \"E0476\", \"E0490\", \"E0514\", \"E0523\", \"E0554\", \"E0640\", \"E0717\", \"E0729\",\n-    \"E0789\",\n-];\n-\n-// Some error codes don't have any tests apparently...\n-const IGNORE_EXPLANATION_CHECK: &[&str] = &[\"E0464\", \"E0570\", \"E0601\", \"E0602\", \"E0729\"];\n-\n-// If the file path contains any of these, we don't want to try to extract error codes from it.\n-//\n-// We need to declare each path in the windows version (with backslash).\n-const PATHS_TO_IGNORE_FOR_EXTRACTION: &[&str] =\n-    &[\"src/test/\", \"src\\\\test\\\\\", \"src/doc/\", \"src\\\\doc\\\\\", \"src/tools/\", \"src\\\\tools\\\\\"];\n-\n-#[derive(Default, Debug)]\n-struct ErrorCodeStatus {\n-    has_test: bool,\n-    has_explanation: bool,\n-    is_used: bool,\n-}\n-\n-fn check_error_code_explanation(\n-    f: &str,\n-    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n-    err_code: String,\n-) -> bool {\n-    let mut invalid_compile_fail_format = false;\n-    let mut found_error_code = false;\n-\n-    for line in f.lines() {\n-        let s = line.trim();\n-        if s.starts_with(\"```\") {\n-            if s.contains(\"compile_fail\") && s.contains('E') {\n-                if !found_error_code {\n-                    error_codes.get_mut(&err_code).map(|x| x.has_test = true);\n-                    found_error_code = true;\n-                }\n-            } else if s.contains(\"compile-fail\") {\n-                invalid_compile_fail_format = true;\n-            }\n-        } else if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n-            if !found_error_code {\n-                error_codes.get_mut(&err_code).map(|x| x.has_test = true);\n-                found_error_code = true;\n-            }\n-        }\n-    }\n-    invalid_compile_fail_format\n-}\n-\n-fn check_if_error_code_is_test_in_explanation(f: &str, err_code: &str) -> bool {\n-    let mut ignore_found = false;\n-\n-    for line in f.lines() {\n-        let s = line.trim();\n-        if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n-            return true;\n-        }\n-        if s.starts_with(\"```\") {\n-            if s.contains(\"compile_fail\") && s.contains(err_code) {\n-                return true;\n-            } else if s.contains(\"ignore\") {\n-                // It's very likely that we can't actually make it fail compilation...\n-                ignore_found = true;\n-            }\n-        }\n-    }\n-    ignore_found\n-}\n-\n-fn extract_error_codes(\n-    f: &str,\n-    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n-    path: &Path,\n-    errors: &mut Vec<String>,\n-) {\n-    let mut reached_no_explanation = false;\n-\n-    for line in f.lines() {\n-        let s = line.trim();\n-        if !reached_no_explanation && s.starts_with('E') && s.contains(\"include_str!(\\\"\") {\n-            let err_code = s\n-                .split_once(':')\n-                .expect(\n-                    format!(\n-                        \"Expected a line with the format `E0xxx: include_str!(\\\"..\\\")`, but got {} \\\n-                         without a `:` delimiter\",\n-                        s,\n-                    )\n-                    .as_str(),\n-                )\n-                .0\n-                .to_owned();\n-            error_codes.entry(err_code.clone()).or_default().has_explanation = true;\n-\n-            // Now we extract the tests from the markdown file!\n-            let md_file_name = match s.split_once(\"include_str!(\\\"\") {\n-                None => continue,\n-                Some((_, md)) => match md.split_once(\"\\\")\") {\n-                    None => continue,\n-                    Some((file_name, _)) => file_name,\n-                },\n-            };\n-\n-            let Some(parent) = path.parent() else {\n-                continue;\n-            };\n-\n-            let path = parent\n-                .join(md_file_name)\n-                .canonicalize()\n-                .expect(\"failed to canonicalize error explanation file path\");\n-\n-            match read_to_string(&path) {\n-                Ok(content) => {\n-                    let has_test = check_if_error_code_is_test_in_explanation(&content, &err_code);\n-                    if !has_test && !IGNORE_EXPLANATION_CHECK.contains(&err_code.as_str()) {\n-                        errors.push(format!(\n-                            \"`{}` doesn't use its own error code in compile_fail example\",\n-                            path.display(),\n-                        ));\n-                    } else if has_test && IGNORE_EXPLANATION_CHECK.contains(&err_code.as_str()) {\n-                        errors.push(format!(\n-                            \"`{}` has a compile_fail example with its own error code, it shouldn't \\\n-                             be listed in IGNORE_EXPLANATION_CHECK!\",\n-                            path.display(),\n-                        ));\n-                    }\n-                    if check_error_code_explanation(&content, error_codes, err_code) {\n-                        errors.push(format!(\n-                            \"`{}` uses invalid tag `compile-fail` instead of `compile_fail`\",\n-                            path.display(),\n-                        ));\n-                    }\n-                }\n-                Err(e) => {\n-                    eprintln!(\"Couldn't read `{}`: {}\", path.display(), e);\n-                }\n-            }\n-        } else if reached_no_explanation && s.starts_with('E') {\n-            let err_code = match s.split_once(',') {\n-                None => s,\n-                Some((err_code, _)) => err_code,\n-            }\n-            .to_string();\n-            if !error_codes.contains_key(&err_code) {\n-                // this check should *never* fail!\n-                error_codes.insert(err_code, ErrorCodeStatus::default());\n-            }\n-        } else if s == \";\" {\n-            reached_no_explanation = true;\n-        }\n-    }\n-}\n-\n-fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, ErrorCodeStatus>) {\n-    for line in f.lines() {\n-        let s = line.trim();\n-        if s.starts_with(\"error[E\") || s.starts_with(\"warning[E\") {\n-            let err_code = match s.split_once(']') {\n-                None => continue,\n-                Some((err_code, _)) => match err_code.split_once('[') {\n-                    None => continue,\n-                    Some((_, err_code)) => err_code,\n-                },\n-            };\n-            error_codes.entry(err_code.to_owned()).or_default().has_test = true;\n-        }\n-    }\n-}\n-\n-fn extract_error_codes_from_source(\n-    f: &str,\n-    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n-    regex: &Regex,\n-) {\n-    for line in f.lines() {\n-        if line.trim_start().starts_with(\"//\") {\n-            continue;\n-        }\n-        for cap in regex.captures_iter(line) {\n-            if let Some(error_code) = cap.get(1) {\n-                error_codes.entry(error_code.as_str().to_owned()).or_default().is_used = true;\n-            }\n-        }\n-    }\n-}\n-\n-pub fn check(paths: &[&Path], bad: &mut bool) {\n-    let mut errors = Vec::new();\n-    let mut found_explanations = 0;\n-    let mut found_tests = 0;\n-    let mut error_codes: HashMap<String, ErrorCodeStatus> = HashMap::new();\n-    let mut explanations: HashSet<String> = HashSet::new();\n-    // We want error codes which match the following cases:\n-    //\n-    // * foo(a, E0111, a)\n-    // * foo(a, E0111)\n-    // * foo(E0111, a)\n-    // * #[error = \"E0111\"]\n-    let regex = Regex::new(r#\"[(,\"\\s](E\\d{4})[,)\"]\"#).unwrap();\n-\n-    for path in paths {\n-        walk(path, &mut filter_dirs, &mut |entry, contents| {\n-            let file_name = entry.file_name();\n-            let entry_path = entry.path();\n-\n-            if file_name == \"error_codes.rs\" {\n-                extract_error_codes(contents, &mut error_codes, entry.path(), &mut errors);\n-                found_explanations += 1;\n-            } else if entry_path.extension() == Some(OsStr::new(\"stderr\")) {\n-                extract_error_codes_from_tests(contents, &mut error_codes);\n-                found_tests += 1;\n-            } else if entry_path.extension() == Some(OsStr::new(\"rs\")) {\n-                let path = entry.path().to_string_lossy();\n-                if PATHS_TO_IGNORE_FOR_EXTRACTION.iter().all(|c| !path.contains(c)) {\n-                    extract_error_codes_from_source(contents, &mut error_codes, &regex);\n-                }\n-            } else if entry_path\n-                .parent()\n-                .and_then(|p| p.file_name())\n-                .map(|p| p == \"error_codes\")\n-                .unwrap_or(false)\n-                && entry_path.extension() == Some(OsStr::new(\"md\"))\n-            {\n-                explanations.insert(file_name.to_str().unwrap().replace(\".md\", \"\"));\n-            }\n-        });\n-    }\n-    if found_explanations == 0 {\n-        tidy_error!(bad, \"No error code explanation was tested!\");\n-    }\n-    if found_tests == 0 {\n-        tidy_error!(bad, \"No error code was found in compilation errors!\");\n-    }\n-    if explanations.is_empty() {\n-        tidy_error!(bad, \"No error code explanation was found!\");\n-    }\n-    if errors.is_empty() {\n-        for (err_code, error_status) in &error_codes {\n-            if !error_status.has_test && !EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n-                errors.push(format!(\"Error code {err_code} needs to have at least one UI test!\"));\n-            } else if error_status.has_test && EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n-                errors.push(format!(\n-                    \"Error code {} has a UI test, it shouldn't be listed into EXEMPTED_FROM_TEST!\",\n-                    err_code\n-                ));\n-            }\n-            if !error_status.is_used && !error_status.has_explanation {\n-                errors.push(format!(\n-                    \"Error code {} isn't used and doesn't have an error explanation, it should be \\\n-                     commented in error_codes.rs file\",\n-                    err_code\n-                ));\n-            }\n-        }\n-    }\n-    if errors.is_empty() {\n-        // Checking if local constants need to be cleaned.\n-        for err_code in EXEMPTED_FROM_TEST {\n-            match error_codes.get(err_code.to_owned()) {\n-                Some(status) => {\n-                    if status.has_test {\n-                        errors.push(format!(\n-                            \"{} error code has a test and therefore should be \\\n-                            removed from the `EXEMPTED_FROM_TEST` constant\",\n-                            err_code\n-                        ));\n-                    }\n-                }\n-                None => errors.push(format!(\n-                    \"{} error code isn't used anymore and therefore should be removed \\\n-                        from `EXEMPTED_FROM_TEST` constant\",\n-                    err_code\n-                )),\n-            }\n-        }\n-    }\n-    if errors.is_empty() {\n-        for explanation in explanations {\n-            if !error_codes.contains_key(&explanation) {\n-                errors.push(format!(\n-                    \"{} error code explanation should be listed in `error_codes.rs`\",\n-                    explanation\n-                ));\n-            }\n-        }\n-    }\n-    errors.sort();\n-    for err in &errors {\n-        tidy_error!(bad, \"{err}\");\n-    }\n-}"}, {"sha": "fe5fd72b91a49946337ed8bdda075d9b41733dae", "filename": "src/tools/tidy/src/errors.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7568c49bf0c11038635458cabb9661b6b4297d74/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7568c49bf0c11038635458cabb9661b6b4297d74/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs?ref=7568c49bf0c11038635458cabb9661b6b4297d74", "patch": "@@ -1,77 +0,0 @@\n-//! Tidy check to verify the validity of long error diagnostic codes.\n-//!\n-//! This ensures that error codes are used at most once and also prints out some\n-//! statistics about the error codes.\n-\n-use crate::walk::{filter_dirs, walk};\n-use std::collections::HashMap;\n-use std::path::Path;\n-\n-pub fn check(path: &Path, bad: &mut bool) {\n-    let mut map: HashMap<_, Vec<_>> = HashMap::new();\n-    walk(\n-        path,\n-        &mut |path| filter_dirs(path) || path.ends_with(\"src/test\"),\n-        &mut |entry, contents| {\n-            let file = entry.path();\n-            let filename = file.file_name().unwrap().to_string_lossy();\n-            if filename != \"error_codes.rs\" {\n-                return;\n-            }\n-\n-            // In the `register_long_diagnostics!` macro, entries look like this:\n-            //\n-            // ```\n-            // EXXXX: r##\"\n-            // <Long diagnostic message>\n-            // \"##,\n-            // ```\n-            //\n-            // and these long messages often have error codes themselves inside\n-            // them, but we don't want to report duplicates in these cases. This\n-            // variable keeps track of whether we're currently inside one of these\n-            // long diagnostic messages.\n-            let mut inside_long_diag = false;\n-            for (num, line) in contents.lines().enumerate() {\n-                if inside_long_diag {\n-                    inside_long_diag = !line.contains(\"\\\"##\");\n-                    continue;\n-                }\n-\n-                let mut search = line;\n-                while let Some(i) = search.find('E') {\n-                    search = &search[i + 1..];\n-                    let code = if search.len() > 4 { search[..4].parse::<u32>() } else { continue };\n-                    let code = match code {\n-                        Ok(n) => n,\n-                        Err(..) => continue,\n-                    };\n-                    map.entry(code).or_default().push((file.to_owned(), num + 1, line.to_owned()));\n-                    break;\n-                }\n-\n-                inside_long_diag = line.contains(\"r##\\\"\");\n-            }\n-        },\n-    );\n-\n-    let mut max = 0;\n-    for (&code, entries) in map.iter() {\n-        if code > max {\n-            max = code;\n-        }\n-        if entries.len() == 1 {\n-            continue;\n-        }\n-\n-        tidy_error!(bad, \"duplicate error code: {}\", code);\n-        for &(ref file, line_num, ref line) in entries.iter() {\n-            tidy_error!(bad, \"{}:{}: {}\", file.display(), line_num, line);\n-        }\n-    }\n-\n-    if !*bad {\n-        println!(\"* {} error codes\", map.len());\n-        println!(\"* highest error code: E{:04}\", max);\n-    }\n-}"}, {"sha": "15c641d748c8e414ba62e728eaa2b7a7106ea163", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/498216e9db724cb26f269b0419d4e9e2897cee79/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498216e9db724cb26f269b0419d4e9e2897cee79/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=498216e9db724cb26f269b0419d4e9e2897cee79", "patch": "@@ -56,8 +56,7 @@ pub mod bins;\n pub mod debug_artifacts;\n pub mod deps;\n pub mod edition;\n-pub mod error_codes_check;\n-pub mod errors;\n+pub mod error_codes;\n pub mod extdeps;\n pub mod features;\n pub mod mir_opt_tests;"}, {"sha": "a5685ba7c942c31980d59c4d0348f32f88e966ec", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/498216e9db724cb26f269b0419d4e9e2897cee79/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498216e9db724cb26f269b0419d4e9e2897cee79/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=498216e9db724cb26f269b0419d4e9e2897cee79", "patch": "@@ -27,6 +27,7 @@ fn main() {\n     let src_path = root_path.join(\"src\");\n     let library_path = root_path.join(\"library\");\n     let compiler_path = root_path.join(\"compiler\");\n+    let librustdoc_path = src_path.join(\"librustdoc\");\n \n     let args: Vec<String> = env::args().skip(1).collect();\n \n@@ -79,8 +80,7 @@ fn main() {\n         check!(mir_opt_tests, &src_path, bless);\n \n         // Checks that only make sense for the compiler.\n-        check!(errors, &compiler_path);\n-        check!(error_codes_check, &[&src_path, &compiler_path]);\n+        check!(error_codes, &root_path, &[&compiler_path, &librustdoc_path], verbose);\n \n         // Checks that only make sense for the std libs.\n         check!(pal, &library_path);"}]}