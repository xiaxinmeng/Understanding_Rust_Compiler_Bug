{"sha": "94ac0ac59fc4203b4d57a56e2b4eb46004b2a603", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YWMwYWM1OWZjNDIwM2I0ZDU3YTU2ZTJiNGViNDYwMDRiMmE2MDM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-27T01:26:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-27T01:26:15Z"}, "message": "Rollup merge of #71419 - contrun:wrong-namespace-rustc-resolve, r=petrochenkov\n\nadd message for resolution failure because wrong namespace\n\ncloses https://github.com/rust-lang/rust/issues/71406", "tree": {"sha": "1d9cacb46dad0e2ecac324c0d0d3715e73ca1c08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d9cacb46dad0e2ecac324c0d0d3715e73ca1c08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94ac0ac59fc4203b4d57a56e2b4eb46004b2a603", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJepjS3CRBK7hj4Ov3rIwAAdHIIAHbk9HxAWmL4J1ZBGzWcThws\nzDyPjOampPwXIrb9RA7nKGxCU9L0X6A5r+Zi7nWNdypl2jglLb6YgmOam3jTmwhR\npmW31NeI8saLdYTJCPMzG+b8D99G+YKkJzI9vOGqhZT5WTsiiAqlPbOfnNbaloQF\nVlZSm38FAAV7LNry5fQyu8VCmeo9wd/YtvIgtr2eyRVzscJOSYQMM8wdkFBp6shE\nwDH0lKq4mh/GL8aKQES9jOOF/daC/5ygGXm4GjxbNUPshfB9yi+oxljxWHsU7V2B\nGnbK5sqTHn79nSSm0AuwkibPY42KXia/vExMJjZNzxmr/tF4fBBtDsFYq1I0tV4=\n=G/UE\n-----END PGP SIGNATURE-----\n", "payload": "tree 1d9cacb46dad0e2ecac324c0d0d3715e73ca1c08\nparent c95bcbc9d5db498b572909bdcc56e684ceece68a\nparent eb8a7031ef1ecd9b44a929f0b93f0e41c78fda25\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587950775 +0200\ncommitter GitHub <noreply@github.com> 1587950775 +0200\n\nRollup merge of #71419 - contrun:wrong-namespace-rustc-resolve, r=petrochenkov\n\nadd message for resolution failure because wrong namespace\n\ncloses https://github.com/rust-lang/rust/issues/71406\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94ac0ac59fc4203b4d57a56e2b4eb46004b2a603", "html_url": "https://github.com/rust-lang/rust/commit/94ac0ac59fc4203b4d57a56e2b4eb46004b2a603", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94ac0ac59fc4203b4d57a56e2b4eb46004b2a603/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c95bcbc9d5db498b572909bdcc56e684ceece68a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c95bcbc9d5db498b572909bdcc56e684ceece68a", "html_url": "https://github.com/rust-lang/rust/commit/c95bcbc9d5db498b572909bdcc56e684ceece68a"}, {"sha": "eb8a7031ef1ecd9b44a929f0b93f0e41c78fda25", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb8a7031ef1ecd9b44a929f0b93f0e41c78fda25", "html_url": "https://github.com/rust-lang/rust/commit/eb8a7031ef1ecd9b44a929f0b93f0e41c78fda25"}], "stats": {"total": 143, "additions": 98, "deletions": 45}, "files": [{"sha": "d84edbe3ad77b0378b70c07c737e5322be8805fc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 83, "deletions": 45, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/94ac0ac59fc4203b4d57a56e2b4eb46004b2a603/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ac0ac59fc4203b4d57a56e2b4eb46004b2a603/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=94ac0ac59fc4203b4d57a56e2b4eb46004b2a603", "patch": "@@ -2066,52 +2066,64 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n \n-            let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(\n-                    module,\n-                    ident,\n-                    ns,\n-                    parent_scope,\n-                    record_used,\n-                    path_span,\n-                )\n-            } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n-                let scopes = ScopeSet::All(ns, opt_ns.is_none());\n-                self.early_resolve_ident_in_lexical_scope(\n-                    ident,\n-                    scopes,\n-                    parent_scope,\n-                    record_used,\n-                    record_used,\n-                    path_span,\n-                )\n-            } else {\n-                let record_used_id =\n-                    if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n-                match self.resolve_ident_in_lexical_scope(\n-                    ident,\n-                    ns,\n-                    parent_scope,\n-                    record_used_id,\n-                    path_span,\n-                    &ribs.unwrap()[ns],\n-                ) {\n-                    // we found a locally-imported or available item/module\n-                    Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n-                    // we found a local variable or type param\n-                    Some(LexicalScopeBinding::Res(res))\n-                        if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) =>\n-                    {\n-                        record_segment_res(self, res);\n-                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n-                            res,\n-                            path.len() - 1,\n-                        ));\n+            enum FindBindingResult<'a> {\n+                Binding(Result<&'a NameBinding<'a>, Determinacy>),\n+                PathResult(PathResult<'a>),\n+            }\n+            let find_binding_in_ns = |this: &mut Self, ns| {\n+                let binding = if let Some(module) = module {\n+                    this.resolve_ident_in_module(\n+                        module,\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        record_used,\n+                        path_span,\n+                    )\n+                } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n+                    let scopes = ScopeSet::All(ns, opt_ns.is_none());\n+                    this.early_resolve_ident_in_lexical_scope(\n+                        ident,\n+                        scopes,\n+                        parent_scope,\n+                        record_used,\n+                        record_used,\n+                        path_span,\n+                    )\n+                } else {\n+                    let record_used_id = if record_used {\n+                        crate_lint.node_id().or(Some(CRATE_NODE_ID))\n+                    } else {\n+                        None\n+                    };\n+                    match this.resolve_ident_in_lexical_scope(\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        record_used_id,\n+                        path_span,\n+                        &ribs.unwrap()[ns],\n+                    ) {\n+                        // we found a locally-imported or available item/module\n+                        Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n+                        // we found a local variable or type param\n+                        Some(LexicalScopeBinding::Res(res))\n+                            if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) =>\n+                        {\n+                            record_segment_res(this, res);\n+                            return FindBindingResult::PathResult(PathResult::NonModule(\n+                                PartialRes::with_unresolved_segments(res, path.len() - 1),\n+                            ));\n+                        }\n+                        _ => Err(Determinacy::determined(record_used)),\n                     }\n-                    _ => Err(Determinacy::determined(record_used)),\n-                }\n+                };\n+                FindBindingResult::Binding(binding)\n+            };\n+            let binding = match find_binding_in_ns(self, ns) {\n+                FindBindingResult::PathResult(x) => return x,\n+                FindBindingResult::Binding(binding) => binding,\n             };\n-\n             match binding {\n                 Ok(binding) => {\n                     if i == 1 {\n@@ -2201,7 +2213,33 @@ impl<'a> Resolver<'a> {\n                     } else if i == 0 {\n                         (format!(\"use of undeclared type or module `{}`\", ident), None)\n                     } else {\n-                        (format!(\"could not find `{}` in `{}`\", ident, path[i - 1].ident), None)\n+                        let mut msg =\n+                            format!(\"could not find `{}` in `{}`\", ident, path[i - 1].ident);\n+                        if ns == TypeNS || ns == ValueNS {\n+                            let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n+                            if let FindBindingResult::Binding(Ok(binding)) =\n+                                find_binding_in_ns(self, ns_to_try)\n+                            {\n+                                let mut found = |what| {\n+                                    msg = format!(\n+                                        \"expected {}, found {} `{}` in `{}`\",\n+                                        ns.descr(),\n+                                        what,\n+                                        ident,\n+                                        path[i - 1].ident\n+                                    )\n+                                };\n+                                if binding.module().is_some() {\n+                                    found(\"module\")\n+                                } else {\n+                                    match binding.res() {\n+                                        def::Res::<NodeId>::Def(kind, id) => found(kind.descr(id)),\n+                                        _ => found(ns_to_try.descr()),\n+                                    }\n+                                }\n+                            };\n+                        }\n+                        (msg, None)\n                     };\n                     return PathResult::Failed {\n                         span: ident.span,"}, {"sha": "6266112c3a86c0526309d415d2c7a7de3388ae48", "filename": "src/test/ui/issues/issue-71406.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94ac0ac59fc4203b4d57a56e2b4eb46004b2a603/src%2Ftest%2Fui%2Fissues%2Fissue-71406.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ac0ac59fc4203b4d57a56e2b4eb46004b2a603/src%2Ftest%2Fui%2Fissues%2Fissue-71406.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-71406.rs?ref=94ac0ac59fc4203b4d57a56e2b4eb46004b2a603", "patch": "@@ -0,0 +1,6 @@\n+use std::sync::mpsc;\n+\n+fn main() {\n+    let (tx, rx) = mpsc::channel::new(1);\n+    //~^ ERROR expected type, found function `channel` in `mpsc`\n+}"}, {"sha": "918163b60947309b5a55fb0ecd87c2c695d86f9c", "filename": "src/test/ui/issues/issue-71406.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94ac0ac59fc4203b4d57a56e2b4eb46004b2a603/src%2Ftest%2Fui%2Fissues%2Fissue-71406.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94ac0ac59fc4203b4d57a56e2b4eb46004b2a603/src%2Ftest%2Fui%2Fissues%2Fissue-71406.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-71406.stderr?ref=94ac0ac59fc4203b4d57a56e2b4eb46004b2a603", "patch": "@@ -0,0 +1,9 @@\n+error[E0433]: failed to resolve: expected type, found function `channel` in `mpsc`\n+  --> $DIR/issue-71406.rs:4:26\n+   |\n+LL |     let (tx, rx) = mpsc::channel::new(1);\n+   |                          ^^^^^^^ expected type, found function `channel` in `mpsc`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}]}