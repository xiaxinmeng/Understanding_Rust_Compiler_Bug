{"sha": "55c938b2c233cc7661c0557c7d485b9df581f7ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1YzkzOGIyYzIzM2NjNzY2MWMwNTU3YzdkNDg1YjlkZjU4MWY3ZWY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-28T19:49:21Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-30T09:06:06Z"}, "message": "Only build debuginfo blocks for blocks that appear in the program text\n\nI.e. a set of curly braces, not everything that creates a block\ncontext in the trans pass.\n\nIssue #1694", "tree": {"sha": "deea8f52edfb4dc33e54f0028742ed9a15f48c86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deea8f52edfb4dc33e54f0028742ed9a15f48c86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55c938b2c233cc7661c0557c7d485b9df581f7ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55c938b2c233cc7661c0557c7d485b9df581f7ef", "html_url": "https://github.com/rust-lang/rust/commit/55c938b2c233cc7661c0557c7d485b9df581f7ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55c938b2c233cc7661c0557c7d485b9df581f7ef/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ec92a4ca716b4e051300a420bdfb8c4af32c06b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec92a4ca716b4e051300a420bdfb8c4af32c06b", "html_url": "https://github.com/rust-lang/rust/commit/0ec92a4ca716b4e051300a420bdfb8c4af32c06b"}], "stats": {"total": 185, "additions": 104, "deletions": 81}, "files": [{"sha": "0ab1a8e001adb2788e389252ea4c811bb3479e7c", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/55c938b2c233cc7661c0557c7d485b9df581f7ef/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55c938b2c233cc7661c0557c7d485b9df581f7ef/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=55c938b2c233cc7661c0557c7d485b9df581f7ef", "patch": "@@ -7,7 +7,7 @@ import trans::common::*;\n import trans::base;\n import trans::build::B;\n import middle::ty;\n-import syntax::{ast, codemap};\n+import syntax::{ast, codemap, ast_util};\n import codemap::span;\n import ast::ty;\n import pat_util::*;\n@@ -224,8 +224,17 @@ fn line_from_span(cm: codemap::codemap, sp: span) -> uint {\n     codemap::lookup_char_pos(cm, sp.lo).line\n }\n \n-fn create_block(cx: @block_ctxt, sp: span) -> @metadata<block_md> {\n-    //let cache = get_cache(bcx_ccx(cx));\n+fn create_block(cx: @block_ctxt) -> @metadata<block_md> {\n+    let cache = get_cache(bcx_ccx(cx));\n+    let cx = cx;\n+    while option::is_none(cx.block_span) {\n+        alt cx.parent {\n+          parent_none { fail \"BAD\"; /*break;*/ }\n+          parent_some(b) { cx = b; }\n+        }\n+    }\n+    let sp = option::get(cx.block_span);\n+        \n     let start = codemap::lookup_char_pos(bcx_ccx(cx).sess.codemap,\n                                          sp.lo);\n     let fname = start.filename;\n@@ -240,25 +249,25 @@ fn create_block(cx: @block_ctxt, sp: span) -> @metadata<block_md> {\n     }*/\n \n     let parent = alt cx.parent {\n-      parent_none { create_function(cx.fcx, sp).node }\n-      parent_some(bcx) { create_block(bcx, sp).node }\n+      parent_none { create_function(cx.fcx).node }\n+      parent_some(bcx) { create_block(bcx).node }\n     };\n     let file_node = create_file(bcx_ccx(cx), fname);\n-    /*let unique_id = alt cache.find(LexicalBlockTag) {\n+    let unique_id = alt cache.find(LexicalBlockTag) {\n       option::some(v) { vec::len(v) as int }\n       option::none { 0 }\n-    };*/\n+    };\n     let lldata = [lltag(tg),\n                   parent,\n                   lli32(start.line as int),\n                   lli32(start.col as int),\n-                  file_node.node/*,\n-                  lli32(unique_id)*/\n+                  file_node.node,\n+                  lli32(unique_id)\n                  ];\n-      let val = llmdnode(lldata);\n-      let mdval = @{node: val, data: {start: start, end: end}};\n-      //update_cache(cache, tg, block_metadata(mdval));\n-      ret mdval;\n+    let val = llmdnode(lldata);\n+    let mdval = @{node: val, data: {start: start, end: end}};\n+    //update_cache(cache, tg, block_metadata(mdval));\n+    ret mdval;\n }\n \n fn size_and_align_of<T>() -> (int, int) {\n@@ -642,8 +651,8 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n     let tymd = create_ty(cx, ty, local.node.ty);\n     let filemd = create_file(cx, loc.filename);\n     let context = alt bcx.parent {\n-      parent_none { create_function(bcx.fcx, local.span).node }\n-      parent_some(_) { create_block(bcx, local.span).node }\n+      parent_none { create_function(bcx.fcx).node }\n+      parent_some(_) { create_block(bcx).node }\n     };\n     let mdnode = create_var(tg, context, name, filemd.node,\n                             loc.line as int, tymd.node);\n@@ -684,7 +693,7 @@ fn create_arg(bcx: @block_ctxt, arg: ast::arg, sp: span)\n     let ty = base::node_id_type(cx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty);\n     let filemd = create_file(cx, loc.filename);\n-    let context = create_function(bcx.fcx, sp);\n+    let context = create_function(bcx.fcx);\n     let mdnode = create_var(tg, context.node, arg.ident, filemd.node,\n                             loc.line as int, tymd.node);\n     let mdval = @{node: mdnode, data: {id: arg.id}};\n@@ -704,7 +713,7 @@ fn update_source_pos(cx: @block_ctxt, s: span) {\n         ret;\n     }\n     let cm = bcx_ccx(cx).sess.codemap;\n-    let blockmd = create_block(cx, s);\n+    let blockmd = create_block(cx);\n     let loc = codemap::lookup_char_pos(cm, s.lo);\n     let scopedata = [lli32(loc.line as int),\n                      lli32(loc.col as int),\n@@ -714,14 +723,15 @@ fn update_source_pos(cx: @block_ctxt, s: span) {\n     llvm::LLVMSetCurrentDebugLocation(trans::build::B(cx), dbgscope);\n }\n \n-fn create_function(fcx: @fn_ctxt, sp: span) -> @metadata<subprogram_md> {\n+fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n     let cx = fcx_ccx(fcx);\n     let dbg_cx = option::get(cx.dbg_cx);\n \n     #debug(\"~~\");\n     log(debug, fcx.id);\n \n-    //log(debug, codemap::span_to_str(sp, cx.sess.codemap));\n+    let sp = option::get(fcx.span);\n+    log(debug, codemap::span_to_str(sp, cx.sess.codemap));\n \n     let (ident, ret_ty, id) = alt cx.ast_map.get(fcx.id) {\n       ast_map::node_item(item) {\n@@ -754,12 +764,12 @@ fn create_function(fcx: @fn_ctxt, sp: span) -> @metadata<subprogram_md> {\n     log(debug, ident);\n     log(debug, id);\n \n-    /*let cache = get_cache(cx);\n+    let cache = get_cache(cx);\n     alt cached_metadata::<@metadata<subprogram_md>>(\n         cache, SubprogramTag, {|md| md.data.id == id}) {\n       option::some(md) { ret md; }\n       option::none {}\n-    }*/\n+    }\n \n     let path = str::connect(fcx.lcx.path + [ident], \"::\");\n \n@@ -805,6 +815,6 @@ fn create_function(fcx: @fn_ctxt, sp: span) -> @metadata<subprogram_md> {\n     let val = llmdnode(fn_metadata);\n     add_named_metadata(cx, \"llvm.dbg.sp\", val);\n     let mdval = @{node: val, data: {id: id}};\n-    //update_cache(cache, SubprogramTag, subprogram_metadata(mdval));\n+    update_cache(cache, SubprogramTag, subprogram_metadata(mdval));\n     ret mdval;\n }"}, {"sha": "1eb67b4ed8440d0af0d7f184ab0ef11f51537d91", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55c938b2c233cc7661c0557c7d485b9df581f7ef/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55c938b2c233cc7661c0557c7d485b9df581f7ef/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=55c938b2c233cc7661c0557c7d485b9df581f7ef", "patch": "@@ -6,7 +6,8 @@ import lib::llvm::llvm;\n import lib::llvm::llvm::{ValueRef, BasicBlockRef};\n import pat_util::*;\n import build::*;\n-import base::{new_sub_block_ctxt, new_scope_block_ctxt, load_if_immediate};\n+import base::{new_sub_block_ctxt, new_scope_block_ctxt,\n+              new_real_block_ctxt, load_if_immediate};\n import syntax::ast;\n import syntax::ast_util;\n import syntax::ast_util::{dummy_sp};\n@@ -651,7 +652,8 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms_: [ast::arm],\n     let arms = normalize_arms(bcx_tcx(cx), arms_);\n \n     for a: ast::arm in arms {\n-        let body = new_scope_block_ctxt(er.bcx, \"case_body\");\n+        let body = new_real_block_ctxt(er.bcx, \"case_body\",\n+                                       a.body.span);\n         let id_map = pat_util::pat_id_map(bcx_tcx(cx), a.pats[0]);\n         bodies += [body];\n         for p: @ast::pat in a.pats {"}, {"sha": "9ea07604c2c1c3778e805b11833892484cf69890", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 55, "deletions": 38, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/55c938b2c233cc7661c0557c7d485b9df581f7ef/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55c938b2c233cc7661c0557c7d485b9df581f7ef/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=55c938b2c233cc7661c0557c7d485b9df581f7ef", "patch": "@@ -1122,7 +1122,7 @@ fn declare_generic_glue(cx: @local_ctxt, t: ty::t, llfnty: TypeRef, name: str)\n fn make_generic_glue_inner(cx: @local_ctxt, t: ty::t,\n                            llfn: ValueRef, helper: glue_helper,\n                            ty_params: [uint]) -> ValueRef {\n-    let fcx = new_fn_ctxt(cx, llfn);\n+    let fcx = new_fn_ctxt(cx, llfn, none);\n     llvm::LLVMSetLinkage(llfn,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n     cx.ccx.stats.n_glues_created += 1u;\n@@ -1151,7 +1151,7 @@ fn make_generic_glue_inner(cx: @local_ctxt, t: ty::t,\n \n     fcx.lltyparams = vec::map_mut(lltydescs, {|d| {desc: d, dicts: none}});\n \n-    let bcx = new_top_block_ctxt(fcx);\n+    let bcx = new_top_block_ctxt(fcx, none);\n     let lltop = bcx.llbb;\n     let llrawptr0 = llvm::LLVMGetParam(llfn, 3u as c_uint);\n     let llval0 = BitCast(bcx, llrawptr0, llty);\n@@ -2410,8 +2410,11 @@ fn trans_if(cx: @block_ctxt, cond: @ast::expr, thn: ast::blk,\n \n     let then_dest = dup_for_join(dest);\n     let else_dest = dup_for_join(dest);\n-    let then_cx = new_scope_block_ctxt(bcx, \"then\");\n-    let else_cx = new_scope_block_ctxt(bcx, \"else\");\n+    let then_cx = new_real_block_ctxt(bcx, \"then\", thn.span);\n+    let else_cx = new_real_block_ctxt(bcx, \"else\", alt els {\n+        some(e) { e.span }\n+        _ { ast_util::dummy_sp() }\n+    });\n     CondBr(bcx, cond_val, then_cx.llbb, else_cx.llbb);\n     then_cx = trans_block_dps(then_cx, thn, then_dest);\n     // Calling trans_block directly instead of trans_expr\n@@ -2442,7 +2445,8 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n         let next_cx = new_sub_block_ctxt(bcx, \"next\");\n         let scope_cx =\n             new_loop_scope_block_ctxt(bcx, option::some(next_cx),\n-                                      outer_next_cx, \"for loop scope\");\n+                                      outer_next_cx, \"for loop scope\",\n+                                      body.span);\n         Br(bcx, scope_cx.llbb);\n         let curr = PointerCast(bcx, curr, T_ptr(type_of_or_i8(bcx, t)));\n         let bcx = alt::bind_irrefutable_pat(scope_cx, local.node.pat,\n@@ -2471,7 +2475,7 @@ fn trans_while(cx: @block_ctxt, cond: @ast::expr, body: ast::blk)\n     let next_cx = new_sub_block_ctxt(cx, \"while next\");\n     let cond_cx =\n         new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n-                                  \"while cond\");\n+                                  \"while cond\", body.span);\n     let body_cx = new_scope_block_ctxt(cond_cx, \"while loop body\");\n     let body_end = trans_block(body_cx, body);\n     let cond_res = trans_temp_expr(cond_cx, cond);\n@@ -2487,7 +2491,7 @@ fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let body_cx =\n         new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n-                                  \"do-while loop body\");\n+                                  \"do-while loop body\", body.span);\n     let body_end = trans_block(body_cx, body);\n     let cond_cx = new_scope_block_ctxt(body_cx, \"do-while cond\");\n     Br(body_end, cond_cx.llbb);\n@@ -3479,7 +3483,8 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret alt::trans_alt(bcx, expr, arms, dest);\n       }\n       ast::expr_block(blk) {\n-        let sub_cx = new_scope_block_ctxt(bcx, \"block-expr body\");\n+        let sub_cx = new_real_block_ctxt(bcx, \"block-expr body\",\n+                                          blk.span);\n         Br(bcx, sub_cx.llbb);\n         sub_cx = trans_block_dps(sub_cx, blk, dest);\n         let next_cx = new_sub_block_ctxt(bcx, \"next\");\n@@ -4022,7 +4027,7 @@ fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n // You probably don't want to use this one. See the\n // next three functions instead.\n fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n-                  name: str) -> @block_ctxt {\n+                  name: str, block_span: option::t<span>) -> @block_ctxt {\n     let s = \"\";\n     if cx.lcx.ccx.sess.opts.save_temps ||\n            cx.lcx.ccx.sess.opts.debuginfo {\n@@ -4037,7 +4042,8 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n                 kind: kind,\n                 mutable cleanups: [],\n                 mutable lpad_dirty: true,\n-                mutable lpad: option::none,\n+                mutable lpad: none,\n+                block_span: block_span,\n                 fcx: cx};\n     alt parent {\n       parent_some(cx) {\n@@ -4050,26 +4056,32 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n \n \n // Use this when you're at the top block of a function or the like.\n-fn new_top_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n-    ret new_block_ctxt(fcx, parent_none, SCOPE_BLOCK, \"function top level\");\n+fn new_top_block_ctxt(fcx: @fn_ctxt, sp: option::t<span>) -> @block_ctxt {\n+    ret new_block_ctxt(fcx, parent_none, SCOPE_BLOCK, \"function top level\",\n+                       sp);\n }\n \n \n // Use this when you're at a curly-brace or similar lexical scope.\n fn new_scope_block_ctxt(bcx: @block_ctxt, n: str) -> @block_ctxt {\n-    ret new_block_ctxt(bcx.fcx, parent_some(bcx), SCOPE_BLOCK, n);\n+    ret new_block_ctxt(bcx.fcx, parent_some(bcx), SCOPE_BLOCK, n, none);\n+}\n+\n+fn new_real_block_ctxt(bcx: @block_ctxt, n: str, sp: span) -> @block_ctxt {\n+    ret new_block_ctxt(bcx.fcx, parent_some(bcx), SCOPE_BLOCK, n, some(sp));\n }\n \n fn new_loop_scope_block_ctxt(bcx: @block_ctxt, _cont: option::t<@block_ctxt>,\n-                             _break: @block_ctxt, n: str) -> @block_ctxt {\n+                             _break: @block_ctxt, n: str, sp: span)\n+    -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx),\n-                       LOOP_SCOPE_BLOCK(_cont, _break), n);\n+                       LOOP_SCOPE_BLOCK(_cont, _break), n, some(sp));\n }\n \n \n // Use this when you're making a general CFG BB within a scope.\n fn new_sub_block_ctxt(bcx: @block_ctxt, n: str) -> @block_ctxt {\n-    ret new_block_ctxt(bcx.fcx, parent_some(bcx), NON_SCOPE_BLOCK, n);\n+    ret new_block_ctxt(bcx.fcx, parent_some(bcx), NON_SCOPE_BLOCK, n, none);\n }\n \n fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n@@ -4080,7 +4092,8 @@ fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n           kind: NON_SCOPE_BLOCK,\n           mutable cleanups: [],\n           mutable lpad_dirty: true,\n-          mutable lpad: option::none,\n+          mutable lpad: none,\n+          block_span: none,\n           fcx: fcx};\n }\n \n@@ -4146,7 +4159,8 @@ fn llstaticallocas_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n           kind: SCOPE_BLOCK,\n           mutable cleanups: [],\n           mutable lpad_dirty: true,\n-          mutable lpad: option::none,\n+          mutable lpad: none,\n+          block_span: none,\n           fcx: fcx};\n }\n \n@@ -4158,7 +4172,8 @@ fn llderivedtydescs_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n           kind: SCOPE_BLOCK,\n           mutable cleanups: [],\n           mutable lpad_dirty: true,\n-          mutable lpad: option::none,\n+          mutable lpad: none,\n+          block_span: none,\n           fcx: fcx};\n }\n \n@@ -4290,8 +4305,8 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - new_fn_ctxt\n //  - trans_args\n fn new_fn_ctxt_w_id(cx: @local_ctxt, llfndecl: ValueRef,\n-                    id: ast::node_id, rstyle: ast::ret_style)\n-    -> @fn_ctxt {\n+                    id: ast::node_id, rstyle: ast::ret_style,\n+                    sp: option::t<span>) -> @fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     ret @{llfn: llfndecl,\n           llenv: llvm::LLVMGetParam(llfndecl, 1u as c_uint),\n@@ -4311,11 +4326,13 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, llfndecl: ValueRef,\n           derived_tydescs: ty::new_ty_hash(),\n           id: id,\n           ret_style: rstyle,\n+          span: sp,\n           lcx: cx};\n }\n \n-fn new_fn_ctxt(cx: @local_ctxt, llfndecl: ValueRef) -> @fn_ctxt {\n-    ret new_fn_ctxt_w_id(cx, llfndecl, -1, ast::return_val);\n+fn new_fn_ctxt(cx: @local_ctxt, llfndecl: ValueRef, sp: option::t<span>)\n+    -> @fn_ctxt {\n+    ret new_fn_ctxt_w_id(cx, llfndecl, -1, ast::return_val, sp);\n }\n \n // NB: must keep 4 fns in sync:\n@@ -4430,19 +4447,19 @@ enum self_arg { impl_self(ty::t), no_self, }\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-fn trans_closure(cx: @local_ctxt, decl: ast::fn_decl,\n+fn trans_closure(cx: @local_ctxt, sp: span, decl: ast::fn_decl,\n                  body: ast::blk, llfndecl: ValueRef,\n                  ty_self: self_arg, ty_params: [ast::ty_param],\n                  id: ast::node_id, maybe_load_env: fn(@fn_ctxt)) {\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n-    let fcx = new_fn_ctxt_w_id(cx, llfndecl, id, decl.cf);\n+    let fcx = new_fn_ctxt_w_id(cx, llfndecl, id, decl.cf, some(sp));\n     create_llargs_for_fn_args(fcx, ty_self, decl.inputs, ty_params);\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-    let bcx = new_top_block_ctxt(fcx);\n+    let bcx = new_top_block_ctxt(fcx, some(body.span));\n     let lltop = bcx.llbb;\n     let block_ty = node_id_type(cx.ccx, body.node.id);\n \n@@ -4478,10 +4495,10 @@ fn trans_fn(cx: @local_ctxt, sp: span, decl: ast::fn_decl, body: ast::blk,\n     let do_time = cx.ccx.sess.opts.stats;\n     let start = do_time ? time::get_time() : {sec: 0u32, usec: 0u32};\n     let fcx = option::none;\n-    trans_closure(cx, decl, body, llfndecl, ty_self, ty_params, id,\n+    trans_closure(cx, sp, decl, body, llfndecl, ty_self, ty_params, id,\n                   {|new_fcx| fcx = option::some(new_fcx);});\n     if cx.ccx.sess.opts.extra_debuginfo {\n-        debuginfo::create_function(option::get(fcx), sp);\n+        debuginfo::create_function(option::get(fcx));\n     }\n     if do_time {\n         let end = time::get_time();\n@@ -4495,10 +4512,10 @@ fn trans_res_ctor(cx: @local_ctxt, dtor: ast::fn_decl,\n \n     // Create a function for the constructor\n     let llctor_decl = ccx.item_ids.get(ctor_id);\n-    let fcx = new_fn_ctxt(cx, llctor_decl);\n+    let fcx = new_fn_ctxt(cx, llctor_decl, none);\n     let ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n     create_llargs_for_fn_args(fcx, no_self, dtor.inputs, ty_params);\n-    let bcx = new_top_block_ctxt(fcx);\n+    let bcx = new_top_block_ctxt(fcx, none);\n     let lltop = bcx.llbb;\n     let arg_t = arg_tys_of_fn(ccx, ctor_id)[0].ty;\n     let tup_t = ty::mk_tup(ccx.tcx, [ty::mk_int(ccx.tcx), arg_t]);\n@@ -4555,7 +4572,7 @@ fn trans_enum_variant(cx: @local_ctxt, enum_id: ast::node_id,\n                                \"unbound variant id in trans_enum_variant\");\n       }\n     }\n-    let fcx = new_fn_ctxt(cx, llfndecl);\n+    let fcx = new_fn_ctxt(cx, llfndecl, none);\n     create_llargs_for_fn_args(fcx, no_self, fn_args, ty_params);\n     let ty_param_substs: [ty::t] = [];\n     i = 0u;\n@@ -4565,7 +4582,7 @@ fn trans_enum_variant(cx: @local_ctxt, enum_id: ast::node_id,\n         i += 1u;\n     }\n     let arg_tys = arg_tys_of_fn(ccx, variant.node.id);\n-    let bcx = new_top_block_ctxt(fcx);\n+    let bcx = new_top_block_ctxt(fcx, none);\n     let lltop = bcx.llbb;\n     bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n \n@@ -4777,8 +4794,8 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n             ccx.llmod, shim_name, tys.shim_fn_ty);\n \n         // Declare the body of the shim function:\n-        let fcx = new_fn_ctxt(lcx, llshimfn);\n-        let bcx = new_top_block_ctxt(fcx);\n+        let fcx = new_fn_ctxt(lcx, llshimfn, none);\n+        let bcx = new_top_block_ctxt(fcx, none);\n         let lltop = bcx.llbb;\n         let llargbundle = llvm::LLVMGetParam(llshimfn, 0 as c_uint);\n         let i = 0u, n = vec::len(tys.arg_tys);\n@@ -4814,8 +4831,8 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n         let ccx = lcx_ccx(lcx);\n-        let fcx = new_fn_ctxt(lcx, llwrapfn);\n-        let bcx = new_top_block_ctxt(fcx);\n+        let fcx = new_fn_ctxt(lcx, llwrapfn, none);\n+        let bcx = new_top_block_ctxt(fcx, none);\n         let lltop = bcx.llbb;\n \n         // Allocate the struct and write the arguments into it.\n@@ -5006,9 +5023,9 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::LLVMCCallConv, llfty);\n \n-        let fcx = new_fn_ctxt(new_local_ctxt(ccx), llfdecl);\n+        let fcx = new_fn_ctxt(new_local_ctxt(ccx), llfdecl, none);\n \n-        let bcx = new_top_block_ctxt(fcx);\n+        let bcx = new_top_block_ctxt(fcx, none);\n         let lltop = bcx.llbb;\n \n         let lloutputarg = llvm::LLVMGetParam(llfdecl, 0 as c_uint);"}, {"sha": "a9cf5e7cffa035bed5aaefaa09eaa63e6329d5f3", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55c938b2c233cc7661c0557c7d485b9df581f7ef/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55c938b2c233cc7661c0557c7d485b9df581f7ef/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=55c938b2c233cc7661c0557c7d485b9df581f7ef", "patch": "@@ -520,7 +520,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n         let cap_vars = capture::compute_capture_vars(\n             ccx.tcx, id, proto, cap_clause);\n         let {llbox, cbox_ty, bcx} = build_closure(bcx, cap_vars, ck);\n-        trans_closure(sub_cx, decl, body, llfn, no_self, [], id, {|fcx|\n+        trans_closure(sub_cx, sp, decl, body, llfn, no_self, [], id, {|fcx|\n             load_environment(bcx, fcx, cbox_ty, cap_vars, ck);\n         });\n         llbox\n@@ -532,7 +532,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n       ast::proto_uniq { trans_closure_env(ty::ck_uniq) }\n       ast::proto_bare {\n         let closure = C_null(T_opaque_cbox_ptr(ccx));\n-        trans_closure(sub_cx, decl, body, llfn, no_self, [],\n+        trans_closure(sub_cx, sp, decl, body, llfn, no_self, [],\n                       id, {|_fcx|});\n         closure\n       }\n@@ -825,8 +825,8 @@ fn trans_bind_thunk(cx: @local_ctxt,\n \n     // Create a new function context and block context for the thunk, and hold\n     // onto a pointer to the first block in the function for later use.\n-    let fcx = new_fn_ctxt(cx, llthunk);\n-    let bcx = new_top_block_ctxt(fcx);\n+    let fcx = new_fn_ctxt(cx, llthunk, none);\n+    let bcx = new_top_block_ctxt(fcx, none);\n     let lltop = bcx.llbb;\n     // Since we might need to construct derived tydescs that depend on\n     // our bound tydescs, we need to load tydescs out of the environment"}, {"sha": "57c74d1bad398b51f267f164fd2877fd27360136", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/55c938b2c233cc7661c0557c7d485b9df581f7ef/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55c938b2c233cc7661c0557c7d485b9df581f7ef/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=55c938b2c233cc7661c0557c7d485b9df581f7ef", "patch": "@@ -240,6 +240,7 @@ type fn_ctxt =\n      derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n      id: ast::node_id,\n      ret_style: ast::ret_style,\n+     span: option::t<span>,\n      lcx: @local_ctxt};\n \n enum cleanup {\n@@ -331,22 +332,14 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, inner_t: ty::t)\n }\n \n enum block_kind {\n-\n-\n-    // A scope block is a basic block created by translating a block { ... }\n-    // in the source language.  Since these blocks create variable scope, any\n-    // variables created in them that are still live at the end of the block\n-    // must be dropped and cleaned up when the block ends.\n+    // A scope at the end of which temporary values created inside of it are\n+    // cleaned up. May correspond to an actual block in the language, but also\n+    // to an implicit scope, for example, calls introduce an implicit scope in\n+    // which the arguments are evaluated and cleaned up.\n     SCOPE_BLOCK,\n-\n-\n     // A basic block created from the body of a loop.  Contains pointers to\n-    // which block to jump to in the case of \"continue\" or \"break\", with the\n-    // \"continue\" block optional, because \"while\" and \"do while\" don't support\n-    // \"continue\" (TODO: is this intentional?)\n+    // which block to jump to in the case of \"continue\" or \"break\".\n     LOOP_SCOPE_BLOCK(option::t<@block_ctxt>, @block_ctxt),\n-\n-\n     // A non-scope block is a basic block created as a translation artifact\n     // from translating code that expresses conditional logic rather than by\n     // explicit { ... } block structure in the source language.  It's called a\n@@ -382,6 +375,7 @@ type block_ctxt =\n      mutable cleanups: [cleanup],\n      mutable lpad_dirty: bool,\n      mutable lpad: option::t<BasicBlockRef>,\n+     block_span: option::t<span>,\n      fcx: @fn_ctxt};\n \n // FIXME: we should be able to use option::t<@block_parent> here but"}, {"sha": "94f874bc28b985d20ea2670cbda9356ae72b197a", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55c938b2c233cc7661c0557c7d485b9df581f7ef/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55c938b2c233cc7661c0557c7d485b9df581f7ef/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=55c938b2c233cc7661c0557c7d485b9df581f7ef", "patch": "@@ -178,8 +178,8 @@ fn trans_wrapper(ccx: @crate_ctxt, pt: [ast::ident], llfty: TypeRef,\n     let lcx = @{path: pt, module_path: [], ccx: ccx};\n     let name = link::mangle_internal_name_by_path(ccx, pt);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, name, llfty);\n-    let fcx = new_fn_ctxt(lcx, llfn);\n-    let bcx = new_top_block_ctxt(fcx), lltop = bcx.llbb;\n+    let fcx = new_fn_ctxt(lcx, llfn, none);\n+    let bcx = new_top_block_ctxt(fcx, none), lltop = bcx.llbb;\n     let bcx = fill(llfn, bcx);\n     build_return(bcx);\n     finish_fn(fcx, lltop);"}]}