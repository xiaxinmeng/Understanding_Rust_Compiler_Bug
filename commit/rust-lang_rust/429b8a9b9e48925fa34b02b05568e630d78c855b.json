{"sha": "429b8a9b9e48925fa34b02b05568e630d78c855b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyOWI4YTliOWU0ODkyNWZhMzRiMDJiMDU1NjhlNjMwZDc4Yzg1NWI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-03-14T06:41:28Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-03-22T13:15:05Z"}, "message": "libcore: handle trailing newlines more like other languages.\n\nSpecifically, `lines` and `each_line` will not emit a trailing empty string\nwhen given \"...\\n\". Also, add `read_lines`, which just collects all of\n`each_line` into a vector, and `split_*_no_trailing` which will is the\ngeneralised version of `lines`.", "tree": {"sha": "72d2bca230ea931ab5fe0907cb84017b0ef5546d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72d2bca230ea931ab5fe0907cb84017b0ef5546d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/429b8a9b9e48925fa34b02b05568e630d78c855b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/429b8a9b9e48925fa34b02b05568e630d78c855b", "html_url": "https://github.com/rust-lang/rust/commit/429b8a9b9e48925fa34b02b05568e630d78c855b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/429b8a9b9e48925fa34b02b05568e630d78c855b/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9584c60871dc712f95a2f37f24853cf3faf6191e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9584c60871dc712f95a2f37f24853cf3faf6191e", "html_url": "https://github.com/rust-lang/rust/commit/9584c60871dc712f95a2f37f24853cf3faf6191e"}], "stats": {"total": 173, "additions": 141, "deletions": 32}, "files": [{"sha": "c5bfa9424584cc974aa3e70c311a796834835aa4", "filename": "src/libcore/io.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/429b8a9b9e48925fa34b02b05568e630d78c855b/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429b8a9b9e48925fa34b02b05568e630d78c855b/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=429b8a9b9e48925fa34b02b05568e630d78c855b", "patch": "@@ -99,8 +99,8 @@ pub trait ReaderUtil {\n     /// Read len bytes into a new vec.\n     fn read_bytes(&self, len: uint) -> ~[u8];\n \n-    /// Read up until a specified character (which is not returned) or EOF.\n-    fn read_until(&self, c: char) -> ~str;\n+    /// Read up until a specified character (which is optionally included) or EOF.\n+    fn read_until(&self, c: char, include: bool) -> ~str;\n \n     /// Read up until the first '\\n' char (which is not returned), or EOF.\n     fn read_line(&self) -> ~str;\n@@ -126,6 +126,9 @@ pub trait ReaderUtil {\n     /// Iterate over every line until the iterator breaks or EOF.\n     fn each_line(&self, it: &fn(&str) -> bool);\n \n+    /// Read all the lines of the file into a vector.\n+    fn read_lines(&self) -> ~[~str];\n+\n     /// Read n (between 1 and 8) little-endian unsigned integer bytes.\n     fn read_le_uint_n(&self, nbytes: uint) -> u64;\n \n@@ -219,11 +222,14 @@ impl<T:Reader> ReaderUtil for T {\n         bytes\n     }\n \n-    fn read_until(&self, c: char) -> ~str {\n+    fn read_until(&self, c: char, include: bool) -> ~str {\n         let mut bytes = ~[];\n         loop {\n             let ch = self.read_byte();\n             if ch == -1 || ch == c as int {\n+                if include && ch == c as int {\n+                    bytes.push(ch as u8);\n+                }\n                 break;\n             }\n             bytes.push(ch as u8);\n@@ -232,7 +238,7 @@ impl<T:Reader> ReaderUtil for T {\n     }\n \n     fn read_line(&self) -> ~str {\n-        self.read_until('\\n')\n+        self.read_until('\\n', false)\n     }\n \n     fn read_chars(&self, n: uint) -> ~[char] {\n@@ -306,7 +312,7 @@ impl<T:Reader> ReaderUtil for T {\n     }\n \n     fn read_c_str(&self) -> ~str {\n-        self.read_until(0 as char)\n+        self.read_until(0 as char, false)\n     }\n \n     fn read_whole_stream(&self) -> ~[u8] {\n@@ -329,7 +335,29 @@ impl<T:Reader> ReaderUtil for T {\n \n     fn each_line(&self, it: &fn(s: &str) -> bool) {\n         while !self.eof() {\n-            if !it(self.read_line()) { break; }\n+            // include the \\n, so that we can distinguish an entirely empty\n+            // line read after \"...\\n\", and the trailing empty line in\n+            // \"...\\n\\n\".\n+            let mut line = self.read_until('\\n', true);\n+\n+            // blank line at the end of the reader is ignored\n+            if self.eof() && line.is_empty() { break; }\n+\n+            // trim the \\n, so that each_line is consistent with read_line\n+            let n = str::len(line);\n+            if line[n-1] == '\\n' as u8 {\n+                unsafe { str::raw::set_len(&mut line, n-1); }\n+            }\n+\n+            if !it(line) { break; }\n+        }\n+    }\n+\n+    fn read_lines(&self) -> ~[~str] {\n+        do vec::build |push| {\n+            for self.each_line |line| {\n+                push(str::from_slice(line));\n+            }\n         }\n     }\n \n@@ -1335,6 +1363,21 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_read_lines() {\n+        do io::with_str_reader(~\"a\\nb\\nc\\n\") |inp| {\n+            fail_unless!(inp.read_lines() == ~[~\"a\", ~\"b\", ~\"c\"]);\n+        }\n+\n+        do io::with_str_reader(~\"a\\nb\\nc\") |inp| {\n+            fail_unless!(inp.read_lines() == ~[~\"a\", ~\"b\", ~\"c\"]);\n+        }\n+\n+        do io::with_str_reader(~\"\") |inp| {\n+            fail_unless!(inp.read_lines().is_empty());\n+        }\n+    }\n+\n     #[test]\n     fn test_readchars_wide() {\n         let wide_test = ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\";"}, {"sha": "bbb5ce3d8a190934243fdc89b0b7d777de17f3f7", "filename": "src/libcore/str.rs", "status": "modified", "additions": 92, "deletions": 26, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/429b8a9b9e48925fa34b02b05568e630d78c855b/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429b8a9b9e48925fa34b02b05568e630d78c855b/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=429b8a9b9e48925fa34b02b05568e630d78c855b", "patch": "@@ -437,28 +437,37 @@ pub pure fn slice(s: &'a str, begin: uint, end: uint) -> &'a str {\n     unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n-/// Splits a string into substrings at each occurrence of a given character\n+/// Splits a string into substrings at each occurrence of a given\n+/// character.\n pub pure fn split_char(s: &str, sep: char) -> ~[~str] {\n-    split_char_inner(s, sep, len(s), true)\n+    split_char_inner(s, sep, len(s), true, true)\n }\n \n /**\n  * Splits a string into substrings at each occurrence of a given\n- * character up to 'count' times\n+ * character up to 'count' times.\n  *\n  * The byte must be a valid UTF-8/ASCII byte\n  */\n pub pure fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n-    split_char_inner(s, sep, count, true)\n+    split_char_inner(s, sep, count, true, true)\n }\n \n /// Like `split_char`, but omits empty strings from the returned vector\n pub pure fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n-    split_char_inner(s, sep, len(s), false)\n+    split_char_inner(s, sep, len(s), false, false)\n }\n \n-pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n-    -> ~[~str] {\n+/**\n+ * Like `split_char`, but a trailing empty string is omitted\n+ * (e.g. `split_char_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n+ */\n+pub pure fn split_char_no_trailing(s: &str, sep: char) -> ~[~str] {\n+    split_char_inner(s, sep, len(s), true, false)\n+}\n+\n+pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n+                         allow_trailing_empty: bool) -> ~[~str] {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n         let mut result = ~[], done = 0u;\n@@ -475,19 +484,20 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n             }\n             i += 1u;\n         }\n-        if allow_empty || start < l {\n+        // only push a non-empty trailing substring\n+        if allow_trailing_empty || start < l {\n             unsafe { result.push(raw::slice_bytes_unique(s, start, l) ) };\n         }\n         result\n     } else {\n-        splitn(s, |cur| cur == sep, count)\n+        split_inner(s, |cur| cur == sep, count, allow_empty, allow_trailing_empty)\n     }\n }\n \n \n /// Splits a string into substrings using a character function\n pub pure fn split(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n-    split_inner(s, sepfn, len(s), true)\n+    split_inner(s, sepfn, len(s), true, true)\n }\n \n /**\n@@ -498,16 +508,25 @@ pub pure fn splitn(s: &str,\n                    sepfn: &fn(char) -> bool,\n                    count: uint)\n                 -> ~[~str] {\n-    split_inner(s, sepfn, count, true)\n+    split_inner(s, sepfn, count, true, true)\n }\n \n /// Like `split`, but omits empty strings from the returned vector\n pub pure fn split_nonempty(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n-    split_inner(s, sepfn, len(s), false)\n+    split_inner(s, sepfn, len(s), false, false)\n+}\n+\n+\n+/**\n+ * Like `split`, but a trailing empty string is omitted\n+ * (e.g. `split_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n+ */\n+pub pure fn split_no_trailing(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n+    split_inner(s, sepfn, len(s), true, false)\n }\n \n pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n-               allow_empty: bool) -> ~[~str] {\n+               allow_empty: bool, allow_trailing_empty: bool) -> ~[~str] {\n     let l = len(s);\n     let mut result = ~[], i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n@@ -523,7 +542,7 @@ pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n         }\n         i = next;\n     }\n-    if allow_empty || start < l {\n+    if allow_trailing_empty || start < l {\n         unsafe {\n             result.push(raw::slice_bytes_unique(s, start, l));\n         }\n@@ -630,9 +649,11 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n }\n \n /**\n- * Splits a string into a vector of the substrings separated by LF ('\\n')\n+ * Splits a string into a vector of the substrings separated by LF ('\\n').\n  */\n-pub pure fn lines(s: &str) -> ~[~str] { split_char(s, '\\n') }\n+pub pure fn lines(s: &str) -> ~[~str] {\n+    split_char_no_trailing(s, '\\n')\n+}\n \n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n@@ -651,7 +672,7 @@ pub pure fn lines_any(s: &str) -> ~[~str] {\n \n /// Splits a string into a vector of the substrings separated by whitespace\n pub pure fn words(s: &str) -> ~[~str] {\n-    split_nonempty(s, |c| char::is_whitespace(c))\n+    split_nonempty(s, char::is_whitespace)\n }\n \n /** Split a string into a vector of substrings,\n@@ -2669,6 +2690,35 @@ mod tests {\n \n     }\n \n+    #[test]\n+    fn test_split_char_no_trailing() {\n+     fn t(s: &str, c: char, u: &[~str]) {\n+            debug!(~\"split_byte: \" + s);\n+            let v = split_char_no_trailing(s, c);\n+            debug!(\"split_byte to: %?\", v);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n+        t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n+        t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n+        t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]);\n+\n+        fail_unless!(~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]\n+                     == split_char_no_trailing(~\"...hello.there.\", '.'));\n+\n+        fail_unless!(~[] == split_char_no_trailing(~\"\", 'z'));\n+        fail_unless!(~[~\"\"] == split_char_no_trailing(~\"z\", 'z'));\n+        fail_unless!(~[~\"ok\"] == split_char_no_trailing(~\"ok\", 'z'));\n+    }\n+\n+    #[test]\n+    fn test_split_char_no_trailing_2() {\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n+                     == split_char_no_trailing(data, 'V'));\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n+                     == split_char_no_trailing(data, '\u0e17'));\n+    }\n+\n     #[test]\n     fn test_split_str() {\n         fn t(s: &str, sep: &'a str, i: int, k: &str) {\n@@ -2722,28 +2772,45 @@ mod tests {\n         fail_unless!(~[~\"ok\"] == split(~\"ok\", |cc| cc == 'z'));\n     }\n \n+    #[test]\n+    fn test_split_no_trailing() {\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n+                     == split_no_trailing (data, |cc| cc == '\u534e'));\n+\n+        fail_unless!(~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\"]\n+                     == split_no_trailing(~\"zzXXXzYYYz\", char::is_lowercase));\n+\n+        fail_unless!(~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]\n+                     == split_no_trailing(~\"zzXXXzYYYz\", char::is_uppercase));\n+\n+        fail_unless!(~[~\"\"] == split_no_trailing(~\"z\", |cc| cc == 'z'));\n+        fail_unless!(~[] == split_no_trailing(~\"\", |cc| cc == 'z'));\n+        fail_unless!(~[~\"ok\"] == split_no_trailing(~\"ok\", |cc| cc == 'z'));\n+    }\n+\n     #[test]\n     fn test_lines() {\n         let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n         let crlf = ~\"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n \n-        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n+        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]\n                      == lines(lf));\n \n-        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n+        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]\n                      == lines_any(lf));\n \n         fail_unless!(~[~\"\\r\", ~\"Mary had a little lamb\\r\",\n-                       ~\"Little lamb\\r\", ~\"\"]\n+                       ~\"Little lamb\\r\"]\n             == lines(crlf));\n \n-        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n+        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]\n             == lines_any(crlf));\n \n-        fail_unless!(~[~\"\"] == lines    (~\"\"));\n-        fail_unless!(~[~\"\"] == lines_any(~\"\"));\n-        fail_unless!(~[~\"\",~\"\"] == lines    (~\"\\n\"));\n-        fail_unless!(~[~\"\",~\"\"] == lines_any(~\"\\n\"));\n+        fail_unless!(~[] == lines    (~\"\"));\n+        fail_unless!(~[] == lines_any(~\"\"));\n+        fail_unless!(~[~\"\"] == lines    (~\"\\n\"));\n+        fail_unless!(~[~\"\"] == lines_any(~\"\\n\"));\n         fail_unless!(~[~\"banana\"] == lines    (~\"banana\"));\n         fail_unless!(~[~\"banana\"] == lines_any(~\"banana\"));\n     }\n@@ -3359,7 +3426,6 @@ mod tests {\n                 0 => fail_unless!(\"\" == x),\n                 1 => fail_unless!(\"Mary had a little lamb\" == x),\n                 2 => fail_unless!(\"Little lamb\" == x),\n-                3 => fail_unless!(\"\" == x),\n                 _ => ()\n             }\n             ii += 1;"}]}