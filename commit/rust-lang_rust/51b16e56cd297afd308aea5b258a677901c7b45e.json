{"sha": "51b16e56cd297afd308aea5b258a677901c7b45e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxYjE2ZTU2Y2QyOTdhZmQzMDhhZWE1YjI1OGE2Nzc5MDFjN2I0NWU=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-15T21:34:34Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:26:36Z"}, "message": "Generate thread local allocations in eval_maybe_thread_local_static_const.", "tree": {"sha": "e88ccdec5b6829441739700e10e16518fcb91154", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e88ccdec5b6829441739700e10e16518fcb91154"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51b16e56cd297afd308aea5b258a677901c7b45e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51b16e56cd297afd308aea5b258a677901c7b45e", "html_url": "https://github.com/rust-lang/rust/commit/51b16e56cd297afd308aea5b258a677901c7b45e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51b16e56cd297afd308aea5b258a677901c7b45e/comments", "author": null, "committer": null, "parents": [{"sha": "963e9698f9ab959de06f42047ef1979bde0aac84", "url": "https://api.github.com/repos/rust-lang/rust/commits/963e9698f9ab959de06f42047ef1979bde0aac84", "html_url": "https://github.com/rust-lang/rust/commit/963e9698f9ab959de06f42047ef1979bde0aac84"}], "stats": {"total": 172, "additions": 78, "deletions": 94}, "files": [{"sha": "a5183d3e8166a7755e0a4f32d0e067ba990df14d", "filename": "src/machine.rs", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/51b16e56cd297afd308aea5b258a677901c7b45e/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b16e56cd297afd308aea5b258a677901c7b45e/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=51b16e56cd297afd308aea5b258a677901c7b45e", "patch": "@@ -18,6 +18,7 @@ use rustc_middle::{\n     mir,\n     ty::{\n         self,\n+        Instance,\n         layout::{LayoutCx, LayoutError, TyAndLayout},\n         TyCtxt,\n     },\n@@ -27,7 +28,7 @@ use rustc_target::abi::{LayoutOf, Size};\n \n use crate::*;\n \n-pub use crate::threads::{ThreadId, ThreadManager, ThreadState, ThreadLocalStorage};\n+pub use crate::threads::{ThreadId, ThreadManager, ThreadState};\n \n // Some global facts about the emulated machine.\n pub const PAGE_SIZE: u64 = 4 * 1024; // FIXME: adjust to target architecture\n@@ -110,7 +111,6 @@ pub struct AllocExtra {\n pub struct MemoryExtra {\n     pub stacked_borrows: Option<stacked_borrows::MemoryExtra>,\n     pub intptrcast: intptrcast::MemoryExtra,\n-    pub tls: ThreadLocalStorage,\n \n     /// Mapping extern static names to their canonical allocation.\n     extern_statics: FxHashMap<Symbol, AllocId>,\n@@ -147,7 +147,6 @@ impl MemoryExtra {\n             rng: RefCell::new(rng),\n             tracked_alloc_id,\n             check_alignment,\n-            tls: Default::default(),\n         }\n     }\n \n@@ -423,24 +422,58 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     fn eval_maybe_thread_local_static_const(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n-        mut val: mir::interpret::ConstValue<'tcx>\n-    )-> InterpResult<'tcx, mir::interpret::ConstValue<'tcx>> {\n+        mut val: mir::interpret::ConstValue<'tcx>,\n+    ) -> InterpResult<'tcx, mir::interpret::ConstValue<'tcx>> {\n         match &mut val {\n             mir::interpret::ConstValue::Scalar(Scalar::Ptr(ptr)) => {\n                 let alloc_id = ptr.alloc_id;\n                 let alloc = ecx.tcx.alloc_map.lock().get(alloc_id);\n                 match alloc {\n                     Some(GlobalAlloc::Static(def_id))\n-                        if ecx.tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) => {\n+                        if ecx\n+                            .tcx\n+                            .codegen_fn_attrs(def_id)\n+                            .flags\n+                            .contains(CodegenFnAttrFlags::THREAD_LOCAL) =>\n+                    {\n                         // We have a thread-local static.\n-                        let new_alloc_id = ecx.memory.extra.tls.get_or_register_allocation(\n-                            *ecx.memory.tcx, alloc_id);\n+                        let new_alloc_id = if let Some(new_alloc_id) =\n+                            ecx.get_thread_local_alloc_id(alloc_id)\n+                        {\n+                            new_alloc_id\n+                        } else {\n+                            if ecx.tcx.is_foreign_item(def_id) {\n+                                throw_unsup_format!(\n+                                    \"Foreign thread-local statics are not supported.\"\n+                                )\n+                            }\n+                            let instance = Instance::mono(ecx.tcx.tcx, def_id);\n+                            let gid = GlobalId { instance, promoted: None };\n+                            let raw_const = ecx\n+                                .tcx\n+                                .const_eval_raw(ty::ParamEnv::reveal_all().and(gid))\n+                                .map_err(|err| {\n+                                    // no need to report anything, the const_eval call takes care of that\n+                                    // for statics\n+                                    assert!(ecx.tcx.is_static(def_id));\n+                                    match err {\n+                                        ErrorHandled::Reported => err_inval!(ReferencedConstant),\n+                                        ErrorHandled::TooGeneric => err_inval!(TooGeneric),\n+                                    }\n+                                })?;\n+                            let id = raw_const.alloc_id;\n+                            let mut alloc_map = ecx.tcx.alloc_map.lock();\n+                            let allocation = alloc_map.unwrap_memory(id);\n+                            let new_alloc_id = alloc_map.create_memory_alloc(allocation);\n+                            ecx.set_thread_local_alloc_id(alloc_id, new_alloc_id);\n+                            new_alloc_id\n+                        };\n                         ptr.alloc_id = new_alloc_id;\n-                    },\n-                    _ => {},\n+                    }\n+                    _ => {}\n                 }\n             }\n-            _ => {},\n+            _ => {}\n         }\n         Ok(val)\n     }\n@@ -470,15 +503,6 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline(always)]\n-    fn resolve_maybe_global_alloc(\n-        tcx: ty::query::TyCtxtAt<'tcx>,\n-        extra: &Self::MemoryExtra,\n-        id: AllocId,\n-    ) -> Option<mir::interpret::GlobalAlloc<'tcx>> {\n-        extra.tls.resolve_allocation(*tcx, id)\n-    }\n-\n     fn init_allocation_extra<'b>(\n         memory_extra: &MemoryExtra,\n         id: AllocId,"}, {"sha": "170fb0c4767eff0f3e645febdc7ab5628a84c4ff", "filename": "src/threads.rs", "status": "modified", "additions": 34, "deletions": 74, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/51b16e56cd297afd308aea5b258a677901c7b45e/src%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b16e56cd297afd308aea5b258a677901c7b45e/src%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthreads.rs?ref=51b16e56cd297afd308aea5b258a677901c7b45e", "patch": "@@ -1,15 +1,12 @@\n //! Implements threads.\n \n use std::cell::RefCell;\n-use std::collections::hash_map::Entry;\n use std::convert::TryFrom;\n \n use log::trace;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::mir;\n-use rustc_middle::ty;\n \n use crate::*;\n \n@@ -129,17 +126,41 @@ pub struct ThreadManager<'mir, 'tcx> {\n     threads: IndexVec<ThreadId, Thread<'mir, 'tcx>>,\n     /// A counter used to generate unique identifiers for blocksets.\n     blockset_counter: u32,\n+    /// A mapping from an allocation id of a thread-local static to an\n+    /// allocation id of a thread specific allocation.\n+    thread_local_alloc_ids: RefCell<FxHashMap<(AllocId, ThreadId), AllocId>>,\n }\n \n impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n     fn default() -> Self {\n         let mut threads = IndexVec::new();\n         threads.push(Default::default());\n-        Self { active_thread: ThreadId::new(0), threads: threads, blockset_counter: 0 }\n+        Self {\n+            active_thread: ThreadId::new(0),\n+            threads: threads,\n+            blockset_counter: 0,\n+            thread_local_alloc_ids: Default::default(),\n+        }\n     }\n }\n \n impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n+    /// Check if we have an allocation for the given thread local static for the\n+    /// active thread.\n+    pub fn get_thread_local_alloc_id(&self, static_alloc_id: AllocId) -> Option<AllocId> {\n+        self.thread_local_alloc_ids.borrow().get(&(static_alloc_id, self.active_thread)).cloned()\n+    }\n+    /// Set the allocation id as the allocation id of the given thread local\n+    /// static for the active thread.\n+    pub fn set_thread_local_alloc_id(&self, static_alloc_id: AllocId, new_alloc_id: AllocId) {\n+        assert!(\n+            self.thread_local_alloc_ids\n+                .borrow_mut()\n+                .insert((static_alloc_id, self.active_thread), new_alloc_id)\n+                .is_none(),\n+            \"Bug: a thread local initialized twice for the same thread.\"\n+        );\n+    }\n     /// Borrow the stack of the active thread.\n     fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n         &self.threads[self.active_thread].stack\n@@ -251,69 +272,16 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n }\n \n-/// In Rust, a thread local variable is just a specially marked static. To\n-/// ensure a property that each memory allocation has a globally unique\n-/// allocation identifier, we create a fresh allocation id for each thread. This\n-/// data structure keeps the track of the created allocation identifiers and\n-/// their relation to the original static allocations.\n-#[derive(Clone, Debug, Default)]\n-pub struct ThreadLocalStorage {\n-    /// A map from a thread local allocation identifier to the static from which\n-    /// it was created.\n-    thread_local_origin: RefCell<FxHashMap<AllocId, AllocId>>,\n-    /// A map from a thread local static and thread id to the unique thread\n-    /// local allocation.\n-    thread_local_allocations: RefCell<FxHashMap<(AllocId, ThreadId), AllocId>>,\n-    /// The currently active thread.\n-    active_thread: Option<ThreadId>,\n-}\n-\n-impl ThreadLocalStorage {\n-    /// For static allocation identifier `original_id` get a thread local\n-    /// allocation identifier. If it is not allocated yet, allocate.\n-    pub fn get_or_register_allocation(&self, tcx: ty::TyCtxt<'_>, original_id: AllocId) -> AllocId {\n-        match self\n-            .thread_local_allocations\n-            .borrow_mut()\n-            .entry((original_id, self.active_thread.unwrap()))\n-        {\n-            Entry::Occupied(entry) => *entry.get(),\n-            Entry::Vacant(entry) => {\n-                let fresh_id = tcx.alloc_map.lock().reserve();\n-                entry.insert(fresh_id);\n-                self.thread_local_origin.borrow_mut().insert(fresh_id, original_id);\n-                trace!(\n-                    \"get_or_register_allocation(original_id={:?}) -> {:?}\",\n-                    original_id,\n-                    fresh_id\n-                );\n-                fresh_id\n-            }\n-        }\n-    }\n-    /// For thread local allocation identifier `alloc_id`, retrieve the original\n-    /// static allocation identifier from which it was created.\n-    pub fn resolve_allocation<'tcx>(\n-        &self,\n-        tcx: ty::TyCtxt<'tcx>,\n-        alloc_id: AllocId,\n-    ) -> Option<mir::interpret::GlobalAlloc<'tcx>> {\n-        trace!(\"resolve_allocation(alloc_id: {:?})\", alloc_id);\n-        if let Some(original_id) = self.thread_local_origin.borrow().get(&alloc_id) {\n-            trace!(\"resolve_allocation(alloc_id: {:?}) -> {:?}\", alloc_id, original_id);\n-            tcx.alloc_map.lock().get(*original_id)\n-        } else {\n-            tcx.alloc_map.lock().get(alloc_id)\n-        }\n-    }\n-    /// Set which thread is currently active.\n-    fn set_active_thread(&mut self, active_thread: ThreadId) {\n-        self.active_thread = Some(active_thread);\n-    }\n-}\n-\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn get_thread_local_alloc_id(&self, static_alloc_id: AllocId) -> Option<AllocId> {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.get_thread_local_alloc_id(static_alloc_id)\n+    }\n+    fn set_thread_local_alloc_id(&self, static_alloc_id: AllocId, thread_local_alloc_id: AllocId) {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.set_thread_local_alloc_id(static_alloc_id, thread_local_alloc_id)\n+    }\n     fn create_thread(&mut self) -> InterpResult<'tcx, ThreadId> {\n         let this = self.eval_context_mut();\n         Ok(this.machine.threads.create_thread())\n@@ -330,7 +298,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n     fn set_active_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx, ThreadId> {\n         let this = self.eval_context_mut();\n-        this.memory.extra.tls.set_active_thread(thread_id);\n         Ok(this.machine.threads.set_active_thread_id(thread_id))\n     }\n     fn get_active_thread(&self) -> InterpResult<'tcx, ThreadId> {\n@@ -370,13 +337,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Returns `false` if all threads terminated.\n     fn schedule(&mut self) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n-        // Find the next thread to run.\n-        if this.machine.threads.schedule()? {\n-            let active_thread = this.machine.threads.get_active_thread_id();\n-            this.memory.extra.tls.set_active_thread(active_thread);\n-            Ok(true)\n-        } else {\n-            Ok(false)\n-        }\n+        this.machine.threads.schedule()\n     }\n }"}]}