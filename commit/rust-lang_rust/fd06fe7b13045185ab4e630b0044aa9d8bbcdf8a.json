{"sha": "fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMDZmZTdiMTMwNDUxODVhYjRlNjMwYjAwNDRhYTlkOGJiY2RmOGE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-11T18:40:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-11T18:40:46Z"}, "message": "Merge #3925\n\n3925: Implement assist \"Reorder field names\" r=matklad a=geoffreycopin\n\nThis PR implements the \"Reorder record fields\" assist as discussed in issue #3821 .\r\n\r\nAdding a `RecordFieldPat` variant to the `Pat` enum seemed like the easiest way to handle the `RecordPat` children as a single sequence of elements, maybe there is a better way ?\n\nCo-authored-by: Geoffrey Copin <copin.geoffrey@gmail.com>", "tree": {"sha": "1481f3fb3e65902b36571ad403fabf5e5940aa56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1481f3fb3e65902b36571ad403fabf5e5940aa56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJekg8uCRBK7hj4Ov3rIwAAdHIIACMbgyjIeMSNcgDE91/1JWBJ\n5CcYAHagVdOWjA+d3y2FfpTdX15bEPYb+JHRCWQIBERuIchSzbssvmyUqJqdOpe7\nvPXHV6YQimSlndxzQRDu5C7Dljz9eCGlL6gmjpgyAy793aZZbnqVkr4/zJu47b1Z\nb2loAbg3erC03WPQ8sR/+TUe9og0vMnBWrDifPX54sQaBy7kUgtmHCV8Fq4CMHmW\nbLFD/PMJSITyotLUZxVTGzYiaCLunhqjuKBI19T4m5MD2ymZOKywtcbDAjoGmIZU\nt/oQCydg8WOnjjr8zIMtK6IBFpyGiLncEY7nCiBYIetxu4cKaJ7E/olicCTZVoA=\n=2TAR\n-----END PGP SIGNATURE-----\n", "payload": "tree 1481f3fb3e65902b36571ad403fabf5e5940aa56\nparent 1a1c09ed3e3a34c0a8750f98ece9ad85595395d2\nparent d9089245fefdc4179c1d61839e78131c5e5a5a45\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586630446 +0000\ncommitter GitHub <noreply@github.com> 1586630446 +0000\n\nMerge #3925\n\n3925: Implement assist \"Reorder field names\" r=matklad a=geoffreycopin\n\nThis PR implements the \"Reorder record fields\" assist as discussed in issue #3821 .\r\n\r\nAdding a `RecordFieldPat` variant to the `Pat` enum seemed like the easiest way to handle the `RecordPat` children as a single sequence of elements, maybe there is a better way ?\n\nCo-authored-by: Geoffrey Copin <copin.geoffrey@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a", "html_url": "https://github.com/rust-lang/rust/commit/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "html_url": "https://github.com/rust-lang/rust/commit/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2"}, {"sha": "d9089245fefdc4179c1d61839e78131c5e5a5a45", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9089245fefdc4179c1d61839e78131c5e5a5a45", "html_url": "https://github.com/rust-lang/rust/commit/d9089245fefdc4179c1d61839e78131c5e5a5a45"}], "stats": {"total": 263, "additions": 262, "deletions": 1}, "files": [{"sha": "b63b4d81a2a47f835579287d1639d2bd2266ef5a", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a", "patch": "@@ -606,6 +606,21 @@ impl Walrus {\n     )\n }\n \n+#[test]\n+fn doctest_reorder_fields() {\n+    check(\n+        \"reorder_fields\",\n+        r#####\"\n+struct Foo {foo: i32, bar: i32};\n+const test: Foo = <|>Foo {bar: 0, foo: 1}\n+\"#####,\n+        r#####\"\n+struct Foo {foo: i32, bar: i32};\n+const test: Foo = Foo {foo: 1, bar: 0}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_replace_if_let_with_match() {\n     check("}, {"sha": "692dd1315e2806f2129ffcacd552e774611fa099", "filename": "crates/ra_assists/src/handlers/reorder_fields.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a", "patch": "@@ -0,0 +1,230 @@\n+use std::collections::HashMap;\n+\n+use itertools::Itertools;\n+\n+use hir::{Adt, ModuleDef, PathResolution, Semantics, Struct};\n+use ra_ide_db::RootDatabase;\n+use ra_syntax::{\n+    algo, ast,\n+    ast::{Name, Path, RecordLit, RecordPat},\n+    AstNode, SyntaxKind, SyntaxNode,\n+};\n+\n+use crate::{\n+    assist_ctx::{Assist, AssistCtx},\n+    AssistId,\n+};\n+use ra_syntax::ast::{Expr, NameRef};\n+\n+// Assist: reorder_fields\n+//\n+// Reorder the fields of record literals and record patterns in the same order as in\n+// the definition.\n+//\n+// ```\n+// struct Foo {foo: i32, bar: i32};\n+// const test: Foo = <|>Foo {bar: 0, foo: 1}\n+// ```\n+// ->\n+// ```\n+// struct Foo {foo: i32, bar: i32};\n+// const test: Foo = Foo {foo: 1, bar: 0}\n+// ```\n+//\n+pub(crate) fn reorder_fields(ctx: AssistCtx) -> Option<Assist> {\n+    reorder::<RecordLit>(ctx.clone()).or_else(|| reorder::<RecordPat>(ctx))\n+}\n+\n+fn reorder<R: AstNode>(ctx: AssistCtx) -> Option<Assist> {\n+    let record = ctx.find_node_at_offset::<R>()?;\n+    let path = record.syntax().children().find_map(Path::cast)?;\n+\n+    let ranks = compute_fields_ranks(&path, &ctx)?;\n+\n+    let fields = get_fields(&record.syntax());\n+    let sorted_fields = sorted_by_rank(&fields, |node| {\n+        *ranks.get(&get_field_name(node)).unwrap_or(&usize::max_value())\n+    });\n+\n+    if sorted_fields == fields {\n+        return None;\n+    }\n+\n+    ctx.add_assist(AssistId(\"reorder_fields\"), \"Reorder record fields\", |edit| {\n+        for (old, new) in fields.iter().zip(&sorted_fields) {\n+            algo::diff(old, new).into_text_edit(edit.text_edit_builder());\n+        }\n+        edit.target(record.syntax().text_range())\n+    })\n+}\n+\n+fn get_fields_kind(node: &SyntaxNode) -> Vec<SyntaxKind> {\n+    use SyntaxKind::*;\n+    match node.kind() {\n+        RECORD_LIT => vec![RECORD_FIELD],\n+        RECORD_PAT => vec![RECORD_FIELD_PAT, BIND_PAT],\n+        _ => vec![],\n+    }\n+}\n+\n+fn get_field_name(node: &SyntaxNode) -> String {\n+    use SyntaxKind::*;\n+    match node.kind() {\n+        RECORD_FIELD => {\n+            if let Some(name) = node.children().find_map(NameRef::cast) {\n+                return name.to_string();\n+            }\n+            node.children().find_map(Expr::cast).map(|expr| expr.to_string()).unwrap_or_default()\n+        }\n+        BIND_PAT | RECORD_FIELD_PAT => {\n+            node.children().find_map(Name::cast).map(|n| n.to_string()).unwrap_or_default()\n+        }\n+        _ => String::new(),\n+    }\n+}\n+\n+fn get_fields(record: &SyntaxNode) -> Vec<SyntaxNode> {\n+    let kinds = get_fields_kind(record);\n+    record.children().flat_map(|n| n.children()).filter(|n| kinds.contains(&n.kind())).collect()\n+}\n+\n+fn sorted_by_rank(\n+    fields: &[SyntaxNode],\n+    get_rank: impl Fn(&SyntaxNode) -> usize,\n+) -> Vec<SyntaxNode> {\n+    fields.iter().cloned().sorted_by_key(get_rank).collect()\n+}\n+\n+fn struct_definition(path: &ast::Path, sema: &Semantics<RootDatabase>) -> Option<Struct> {\n+    match sema.resolve_path(path) {\n+        Some(PathResolution::Def(ModuleDef::Adt(Adt::Struct(s)))) => Some(s),\n+        _ => None,\n+    }\n+}\n+\n+fn compute_fields_ranks(path: &Path, ctx: &AssistCtx) -> Option<HashMap<String, usize>> {\n+    Some(\n+        struct_definition(path, ctx.sema)?\n+            .fields(ctx.db)\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, field)| (field.name(ctx.db).to_string(), idx))\n+            .collect(),\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::helpers::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn not_applicable_if_sorted() {\n+        check_assist_not_applicable(\n+            reorder_fields,\n+            r#\"\n+        struct Foo {\n+            foo: i32,\n+            bar: i32,\n+        }\n+\n+        const test: Foo = <|>Foo { foo: 0, bar: 0 };\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn trivial_empty_fields() {\n+        check_assist_not_applicable(\n+            reorder_fields,\n+            r#\"\n+        struct Foo {};\n+        const test: Foo = <|>Foo {}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn reorder_struct_fields() {\n+        check_assist(\n+            reorder_fields,\n+            r#\"\n+        struct Foo {foo: i32, bar: i32};\n+        const test: Foo = <|>Foo {bar: 0, foo: 1}\n+        \"#,\n+            r#\"\n+        struct Foo {foo: i32, bar: i32};\n+        const test: Foo = <|>Foo {foo: 1, bar: 0}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn reorder_struct_pattern() {\n+        check_assist(\n+            reorder_fields,\n+            r#\"\n+        struct Foo { foo: i64, bar: i64, baz: i64 }\n+\n+        fn f(f: Foo) -> {\n+            match f {\n+                <|>Foo { baz: 0, ref mut bar, .. } => (),\n+                _ => ()\n+            }\n+        }\n+        \"#,\n+            r#\"\n+        struct Foo { foo: i64, bar: i64, baz: i64 }\n+\n+        fn f(f: Foo) -> {\n+            match f {\n+                <|>Foo { ref mut bar, baz: 0, .. } => (),\n+                _ => ()\n+            }\n+        }\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn reorder_with_extra_field() {\n+        check_assist(\n+            reorder_fields,\n+            r#\"\n+            struct Foo {\n+                foo: String,\n+                bar: String,\n+            }\n+\n+            impl Foo {\n+                fn new() -> Foo {\n+                    let foo = String::new();\n+                    <|>Foo {\n+                        bar: foo.clone(),\n+                        extra: \"Extra field\",\n+                        foo,\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            struct Foo {\n+                foo: String,\n+                bar: String,\n+            }\n+\n+            impl Foo {\n+                fn new() -> Foo {\n+                    let foo = String::new();\n+                    <|>Foo {\n+                        foo,\n+                        bar: foo.clone(),\n+                        extra: \"Extra field\",\n+                    }\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+}"}, {"sha": "a00136da1c14baa05ea9afd4a48460fffadb0c36", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a", "patch": "@@ -129,6 +129,7 @@ mod handlers {\n     mod replace_unwrap_with_match;\n     mod split_import;\n     mod add_from_impl_for_enum;\n+    mod reorder_fields;\n \n     pub(crate) fn all() -> &'static [AssistHandler] {\n         &[\n@@ -170,6 +171,7 @@ mod handlers {\n             // These are manually sorted for better priorities\n             add_missing_impl_members::add_missing_impl_members,\n             add_missing_impl_members::add_missing_default_members,\n+            reorder_fields::reorder_fields,\n         ]\n     }\n }"}, {"sha": "c057dc8f259a851f2c3c8b8a2f1714d95004eed2", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a", "patch": "@@ -665,7 +665,6 @@ impl ExprCollector<'_> {\n                     Pat::Missing\n                 }\n             }\n-\n             // FIXME: implement\n             ast::Pat::BoxPat(_) | ast::Pat::RangePat(_) | ast::Pat::MacroPat(_) => Pat::Missing,\n         };"}, {"sha": "1d95104237244d2dbfcc763605a241e95ef1fe2f", "filename": "docs/user/assists.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=fd06fe7b13045185ab4e630b0044aa9d8bbcdf8a", "patch": "@@ -582,6 +582,21 @@ impl Walrus {\n }\n ```\n \n+## `reorder_fields`\n+\n+Reorder the fields of record literals and record patterns in the same order as in\n+the definition.\n+\n+```rust\n+// BEFORE\n+struct Foo {foo: i32, bar: i32};\n+const test: Foo = \u2503Foo {bar: 0, foo: 1}\n+\n+// AFTER\n+struct Foo {foo: i32, bar: i32};\n+const test: Foo = Foo {foo: 1, bar: 0}\n+```\n+\n ## `replace_if_let_with_match`\n \n Replaces `if let` with an else branch with a `match` expression."}]}