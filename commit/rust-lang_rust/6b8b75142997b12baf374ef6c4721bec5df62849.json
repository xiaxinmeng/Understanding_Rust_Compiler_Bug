{"sha": "6b8b75142997b12baf374ef6c4721bec5df62849", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiOGI3NTE0Mjk5N2IxMmJhZjM3NGVmNmM0NzIxYmVjNWRmNjI4NDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-09T19:08:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-11T21:55:25Z"}, "message": "borrowck -- treak borrows from closures like other borrows", "tree": {"sha": "ecf01d191c8d104074c149506580b19db26cbfc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecf01d191c8d104074c149506580b19db26cbfc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b8b75142997b12baf374ef6c4721bec5df62849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b8b75142997b12baf374ef6c4721bec5df62849", "html_url": "https://github.com/rust-lang/rust/commit/6b8b75142997b12baf374ef6c4721bec5df62849", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b8b75142997b12baf374ef6c4721bec5df62849/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db38192daf8eb20b17ddad22d2029dec0df2b203", "url": "https://api.github.com/repos/rust-lang/rust/commits/db38192daf8eb20b17ddad22d2029dec0df2b203", "html_url": "https://github.com/rust-lang/rust/commit/db38192daf8eb20b17ddad22d2029dec0df2b203"}], "stats": {"total": 1113, "additions": 634, "deletions": 479}, "files": [{"sha": "cb1a803c35a0f4475420ebf1d2411532943a9020", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 183, "deletions": 120, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=6b8b75142997b12baf374ef6c4721bec5df62849", "patch": "@@ -52,9 +52,11 @@ impl<'a> Visitor<()> for CheckLoanCtxt<'a> {\n     fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n         check_loans_in_pat(self, p);\n     }\n-    fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n-                b: &ast::Block, s: Span, n: ast::NodeId, _: ()) {\n-        check_loans_in_fn(self, fk, fd, b, s, n);\n+    fn visit_fn(&mut self, _fk: &visit::FnKind, _fd: &ast::FnDecl,\n+                _b: &ast::Block, _s: Span, _n: ast::NodeId, _: ()) {\n+        // Don't process nested items or closures here,\n+        // the outer loop will take care of it.\n+        return;\n     }\n \n     // FIXME(#10894) should continue recursing\n@@ -218,57 +220,127 @@ impl<'a> CheckLoanCtxt<'a> {\n                loan2.repr(self.tcx()));\n \n         // Restrictions that would cause the new loan to be illegal:\n-        let illegal_if = match loan2.mutbl {\n-            MutableMutability   => RESTR_FREEZE | RESTR_CLAIM,\n-            ImmutableMutability => RESTR_FREEZE,\n+        let illegal_if = match loan2.kind {\n+            // Look for restrictions against mutation. These are\n+            // generated by all other borrows.\n+            ty::MutBorrow => RESTR_MUTATE,\n+\n+            // Look for restrictions against freezing (immutable borrows).\n+            // These are generated by `&mut` borrows.\n+            ty::ImmBorrow => RESTR_FREEZE,\n+\n+            // No matter how the data is borrowed (as `&`, as `&mut`,\n+            // or as `&unique imm`) it will always generate a\n+            // restriction against mutating the data. So look for those.\n+            ty::UniqueImmBorrow => RESTR_MUTATE,\n         };\n         debug!(\"illegal_if={:?}\", illegal_if);\n \n         for restr in loan1.restrictions.iter() {\n             if !restr.set.intersects(illegal_if) { continue; }\n             if restr.loan_path != loan2.loan_path { continue; }\n \n-            match (new_loan.mutbl, old_loan.mutbl) {\n-                (_, MutableMutability) => {\n-                    let var = self.bccx.loan_path_to_str(new_loan.loan_path);\n+            let old_pronoun = if new_loan.loan_path == old_loan.loan_path {\n+                ~\"it\"\n+            } else {\n+                format!(\"`{}`\",\n+                        self.bccx.loan_path_to_str(old_loan.loan_path))\n+            };\n+\n+            match (new_loan.kind, old_loan.kind) {\n+                (ty::MutBorrow, ty::MutBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}` because it is already \\\n-                                 borrowed as mutable\", var));\n-                    self.bccx.span_note(\n-                        old_loan.span,\n-                        format!(\"previous borrow of `{0}` as mutable occurs \\\n-                                 here; the mutable borrow prevents subsequent \\\n-                                 moves, borrows, or modification of `{0}` \\\n-                                 until the borrow ends\", var));\n+                        format!(\"cannot borrow `{}` as mutable \\\n+                                more than once at a time\",\n+                                self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                }\n+\n+                (ty::UniqueImmBorrow, _) => {\n+                    self.bccx.span_err(\n+                        new_loan.span,\n+                        format!(\"closure requires unique access to `{}` \\\n+                                but {} is already borrowed\",\n+                                self.bccx.loan_path_to_str(new_loan.loan_path),\n+                                old_pronoun));\n                 }\n \n-                (_, mutability) => {\n+                (_, ty::UniqueImmBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as {} because \\\n-                              it is already borrowed as {}\",\n-                             self.bccx.loan_path_to_str(new_loan.loan_path),\n-                             self.bccx.mut_to_str(new_loan.mutbl),\n-                             self.bccx.mut_to_str(old_loan.mutbl)));\n-\n-                    let var = self.bccx.loan_path_to_str(new_loan.loan_path);\n-                    let mut note = format!(\"previous borrow of `{}` occurs \\\n-                                            here\", var);\n-                    if mutability == ImmutableMutability {\n-                        note.push_str(format!(\"; the immutable borrow prevents \\\n-                                               subsequent moves or mutable\n-                                               borrows of `{}` until the\n-                                               borrow ends\", var));\n-                    }\n-                    self.bccx.span_note(old_loan.span, note);\n+                                previous closure requires unique access\",\n+                                self.bccx.loan_path_to_str(new_loan.loan_path),\n+                                new_loan.kind.to_user_str()));\n+                }\n+\n+                (_, _) => {\n+                    self.bccx.span_err(\n+                        new_loan.span,\n+                        format!(\"cannot borrow `{}` as {} because \\\n+                                {} is also borrowed as {}\",\n+                                self.bccx.loan_path_to_str(new_loan.loan_path),\n+                                new_loan.kind.to_user_str(),\n+                                old_pronoun,\n+                                old_loan.kind.to_user_str()));\n                 }\n             }\n \n+            match new_loan.cause {\n+                ClosureCapture(span) => {\n+                    self.bccx.span_note(\n+                        span,\n+                        format!(\"borrow occurs due to use of `{}` in closure\",\n+                                self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                }\n+                _ => { }\n+            }\n+\n+            let rule_summary = match old_loan.kind {\n+                ty::MutBorrow => {\n+                    format!(\"the mutable borrow prevents subsequent \\\n+                            moves, borrows, or modification of `{0}` \\\n+                            until the borrow ends\",\n+                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                }\n+\n+                ty::ImmBorrow => {\n+                    format!(\"the immutable borrow prevents subsequent \\\n+                            moves or mutable borrows of `{0}` \\\n+                            until the borrow ends\",\n+                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                }\n+\n+                ty::UniqueImmBorrow => {\n+                    format!(\"the unique capture prevents subsequent \\\n+                            moves or borrows of `{0}` \\\n+                            until the borrow ends\",\n+                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                }\n+            };\n+\n+            let borrow_summary = match old_loan.cause {\n+                ClosureCapture(_) => {\n+                    format!(\"previous borrow of `{}` occurs here due to \\\n+                            use in closure\",\n+                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                }\n+\n+                AddrOf | AutoRef | RefBinding => {\n+                    format!(\"previous borrow of `{}` occurs here\",\n+                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                }\n+            };\n+\n+            self.bccx.span_note(\n+                old_loan.span,\n+                format!(\"{}; {}\", borrow_summary, rule_summary));\n+\n             let old_loan_span = ast_map::node_span(self.tcx().items,\n                                                    old_loan.kill_scope);\n             self.bccx.span_end_note(old_loan_span,\n                                     \"previous borrow ends here\");\n+\n             return false;\n         }\n \n@@ -349,11 +421,23 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n \n         // Otherwise, just a plain error.\n-        self.bccx.span_err(\n-            expr.span,\n-            format!(\"cannot assign to {} {}\",\n-                 cmt.mutbl.to_user_str(),\n-                 self.bccx.cmt_to_str(cmt)));\n+        match opt_loan_path(cmt) {\n+            Some(lp) => {\n+                self.bccx.span_err(\n+                    expr.span,\n+                    format!(\"cannot assign to {} {} `{}`\",\n+                            cmt.mutbl.to_user_str(),\n+                            self.bccx.cmt_to_str(cmt),\n+                            self.bccx.loan_path_to_str(lp)));\n+            }\n+            None => {\n+                self.bccx.span_err(\n+                    expr.span,\n+                    format!(\"cannot assign to {} {}\",\n+                            cmt.mutbl.to_user_str(),\n+                            self.bccx.cmt_to_str(cmt)));\n+            }\n+        }\n         return;\n \n         fn mark_variable_as_used_mut(this: &CheckLoanCtxt,\n@@ -377,37 +461,34 @@ impl<'a> CheckLoanCtxt<'a> {\n                         return;\n                     }\n \n-                    mc::cat_stack_upvar(b) => {\n-                        cmt = b;\n+                    mc::cat_upvar(..) => {\n+                        return;\n                     }\n \n-                    mc::cat_deref(_, _, mc::gc_ptr) => {\n+                    mc::cat_deref(_, _, mc::GcPtr) => {\n                         assert_eq!(cmt.mutbl, mc::McImmutable);\n                         return;\n                     }\n \n                     mc::cat_rvalue(..) |\n                     mc::cat_static_item |\n                     mc::cat_copied_upvar(..) |\n-                    mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n-                    mc::cat_deref(_, _, mc::region_ptr(..)) => {\n+                    mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+                    mc::cat_deref(_, _, mc::BorrowedPtr(..)) => {\n                         assert_eq!(cmt.mutbl, mc::McDeclared);\n                         return;\n                     }\n \n                     mc::cat_discr(b, _) |\n-                    mc::cat_deref(b, _, mc::uniq_ptr) => {\n+                    mc::cat_deref(b, _, mc::OwnedPtr) => {\n                         assert_eq!(cmt.mutbl, mc::McInherited);\n                         cmt = b;\n                     }\n \n                     mc::cat_downcast(b) |\n                     mc::cat_interior(b, _) => {\n-                        if cmt.mutbl == mc::McInherited {\n-                            cmt = b;\n-                        } else {\n-                            return; // field declared as mutable or some such\n-                        }\n+                        assert_eq!(cmt.mutbl, mc::McInherited);\n+                        cmt = b;\n                     }\n                 }\n             }\n@@ -422,7 +503,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             debug!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n                    cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n             match guarantor.cat {\n-                mc::cat_deref(b, _, mc::region_ptr(ast::MutMutable, _)) => {\n+                mc::cat_deref(b, _, mc::BorrowedPtr(ty::MutBorrow, _)) => {\n                     // Statically prohibit writes to `&mut` when aliasable\n \n                     check_for_aliasability_violation(this, expr, b);\n@@ -557,7 +638,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                     // with inherited mutability and with `&mut`\n                     // pointers.\n                     LpExtend(lp_base, mc::McInherited, _) |\n-                    LpExtend(lp_base, _, LpDeref(mc::region_ptr(ast::MutMutable, _))) => {\n+                    LpExtend(lp_base, _, LpDeref(mc::BorrowedPtr(ty::MutBorrow, _))) => {\n                         loan_path = lp_base;\n                     }\n \n@@ -572,9 +653,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 // Check for a non-const loan of `loan_path`\n                 let cont = this.each_in_scope_loan(expr.id, |loan| {\n                     if loan.loan_path == loan_path {\n-                        this.report_illegal_mutation(expr,\n-                                                     full_loan_path,\n-                                                     loan);\n+                        this.report_illegal_mutation(expr, full_loan_path, loan);\n                         false\n                     } else {\n                         true\n@@ -603,9 +682,10 @@ impl<'a> CheckLoanCtxt<'a> {\n     fn check_move_out_from_expr(&self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n-                // moves due to capture clauses are checked\n-                // in `check_loans_in_fn`, so that we can\n-                // give a better error message\n+                // Moves due to captures are checked in\n+                // check_captured_variables() because it allows\n+                // us to give a more precise error message with\n+                // a more precise span.\n             }\n             _ => {\n                 self.check_move_out_from_id(expr.id, expr.span)\n@@ -621,18 +701,59 @@ impl<'a> CheckLoanCtxt<'a> {\n                     self.bccx.span_err(\n                         span,\n                         format!(\"cannot move out of `{}` \\\n-                              because it is borrowed\",\n+                                because it is borrowed\",\n                              self.bccx.loan_path_to_str(move_path)));\n                     self.bccx.span_note(\n                         loan_span,\n                         format!(\"borrow of `{}` occurs here\",\n-                             self.bccx.loan_path_to_str(loan_path)));\n+                                self.bccx.loan_path_to_str(loan_path)));\n                 }\n             }\n             true\n         });\n     }\n \n+    fn check_captured_variables(&self,\n+                                closure_id: ast::NodeId,\n+                                span: Span) {\n+        let capture_map = self.bccx.capture_map.borrow();\n+        let cap_vars = capture_map.get().get(&closure_id);\n+        for cap_var in cap_vars.borrow().iter() {\n+            let var_id = ast_util::def_id_of_def(cap_var.def).node;\n+            let var_path = @LpVar(var_id);\n+            self.check_if_path_is_moved(closure_id, span,\n+                                        MovedInCapture, var_path);\n+            match cap_var.mode {\n+                moves::CapRef | moves::CapCopy => {}\n+                moves::CapMove => {\n+                    check_by_move_capture(self, closure_id, cap_var, var_path);\n+                }\n+            }\n+        }\n+        return;\n+\n+        fn check_by_move_capture(this: &CheckLoanCtxt,\n+                                 closure_id: ast::NodeId,\n+                                 cap_var: &moves::CaptureVar,\n+                                 move_path: @LoanPath) {\n+            let move_err = this.analyze_move_out_from(closure_id, move_path);\n+            match move_err {\n+                MoveOk => {}\n+                MoveWhileBorrowed(loan_path, loan_span) => {\n+                    this.bccx.span_err(\n+                        cap_var.span,\n+                        format!(\"cannot move `{}` into closure \\\n+                                because it is borrowed\",\n+                                this.bccx.loan_path_to_str(move_path)));\n+                    this.bccx.span_note(\n+                        loan_span,\n+                        format!(\"borrow of `{}` occurs here\",\n+                                this.bccx.loan_path_to_str(loan_path)));\n+                }\n+            }\n+        }\n+    }\n+\n     pub fn analyze_move_out_from(&self,\n                                  expr_id: ast::NodeId,\n                                  mut move_path: @LoanPath)\n@@ -681,67 +802,6 @@ impl<'a> CheckLoanCtxt<'a> {\n     }\n }\n \n-fn check_loans_in_fn<'a>(this: &mut CheckLoanCtxt<'a>,\n-                         fk: &visit::FnKind,\n-                         decl: &ast::FnDecl,\n-                         body: &ast::Block,\n-                         sp: Span,\n-                         id: ast::NodeId) {\n-    match *fk {\n-        visit::FkItemFn(..) | visit::FkMethod(..) => {\n-            // Don't process nested items.\n-            return;\n-        }\n-\n-        visit::FkFnBlock(..) => {\n-            check_captured_variables(this, id, sp);\n-        }\n-    }\n-\n-    visit::walk_fn(this, fk, decl, body, sp, id, ());\n-\n-    fn check_captured_variables(this: &CheckLoanCtxt,\n-                                closure_id: ast::NodeId,\n-                                span: Span) {\n-        let capture_map = this.bccx.capture_map.borrow();\n-        let cap_vars = capture_map.get().get(&closure_id);\n-        for cap_var in cap_vars.borrow().iter() {\n-            let var_id = ast_util::def_id_of_def(cap_var.def).node;\n-            let var_path = @LpVar(var_id);\n-            this.check_if_path_is_moved(closure_id, span,\n-                                        MovedInCapture, var_path);\n-            match cap_var.mode {\n-                moves::CapRef | moves::CapCopy => {}\n-                moves::CapMove => {\n-                    check_by_move_capture(this, closure_id, cap_var, var_path);\n-                }\n-            }\n-        }\n-        return;\n-\n-        fn check_by_move_capture(this: &CheckLoanCtxt,\n-                                 closure_id: ast::NodeId,\n-                                 cap_var: &moves::CaptureVar,\n-                                 move_path: @LoanPath) {\n-            let move_err = this.analyze_move_out_from(closure_id, move_path);\n-            match move_err {\n-                MoveOk => {}\n-                MoveWhileBorrowed(loan_path, loan_span) => {\n-                    this.bccx.span_err(\n-                        cap_var.span,\n-                        format!(\"cannot move `{}` into closure \\\n-                              because it is borrowed\",\n-                             this.bccx.loan_path_to_str(move_path)));\n-                    this.bccx.span_note(\n-                        loan_span,\n-                        format!(\"borrow of `{}` occurs here\",\n-                             this.bccx.loan_path_to_str(loan_path)));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n fn check_loans_in_local<'a>(this: &mut CheckLoanCtxt<'a>,\n                             local: &ast::Local) {\n     visit::walk_local(this, local, ());\n@@ -769,6 +829,9 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n               }\n           }\n       }\n+      ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n+          this.check_captured_variables(expr.id, expr.span)\n+      }\n       ast::ExprAssign(dest, _) |\n       ast::ExprAssignOp(_, _, dest, _) => {\n         this.check_assignment(dest);"}, {"sha": "49b12a6db1fb5afe8d660f1e3451308094122bc1", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=6b8b75142997b12baf374ef6c4721bec5df62849", "patch": "@@ -18,9 +18,8 @@ use middle::borrowck::move_data::*;\n use middle::moves;\n use middle::ty;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::codemap::Span;\n-use util::ppaux::{UserString};\n+use util::ppaux::{Repr, UserString};\n \n pub fn gather_decl(bccx: &BorrowckCtxt,\n                    move_data: &MoveData,\n@@ -35,33 +34,14 @@ pub fn gather_move_from_expr(bccx: &BorrowckCtxt,\n                              move_data: &MoveData,\n                              move_expr: &ast::Expr,\n                              cmt: mc::cmt) {\n-    gather_move_from_expr_or_pat(bccx, move_data, move_expr.id, MoveExpr, cmt);\n+    gather_move(bccx, move_data, move_expr.id, MoveExpr, cmt);\n }\n \n pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n                             move_data: &MoveData,\n                             move_pat: &ast::Pat,\n                             cmt: mc::cmt) {\n-    gather_move_from_expr_or_pat(bccx, move_data, move_pat.id, MovePat, cmt);\n-}\n-\n-fn gather_move_from_expr_or_pat(bccx: &BorrowckCtxt,\n-                                move_data: &MoveData,\n-                                move_id: ast::NodeId,\n-                                move_kind: MoveKind,\n-                                cmt: mc::cmt) {\n-    if !check_is_legal_to_move_from(bccx, cmt, cmt) {\n-        return;\n-    }\n-\n-    match opt_loan_path(cmt) {\n-        Some(loan_path) => {\n-            move_data.add_move(bccx.tcx, loan_path, move_id, move_kind);\n-        }\n-        None => {\n-            // move from rvalue or unsafe pointer, hence ok\n-        }\n-    }\n+    gather_move(bccx, move_data, move_pat.id, MovePat, cmt);\n }\n \n pub fn gather_captures(bccx: &BorrowckCtxt,\n@@ -72,16 +52,38 @@ pub fn gather_captures(bccx: &BorrowckCtxt,\n     for captured_var in captured_vars.borrow().iter() {\n         match captured_var.mode {\n             moves::CapMove => {\n-                let fvar_id = ast_util::def_id_of_def(captured_var.def).node;\n-                let loan_path = @LpVar(fvar_id);\n-                move_data.add_move(bccx.tcx, loan_path, closure_expr.id,\n-                                   Captured);\n+                let cmt = bccx.cat_captured_var(closure_expr.id,\n+                                                closure_expr.span,\n+                                                captured_var);\n+                gather_move(bccx, move_data, closure_expr.id, Captured, cmt);\n             }\n             moves::CapCopy | moves::CapRef => {}\n         }\n     }\n }\n \n+fn gather_move(bccx: &BorrowckCtxt,\n+               move_data: &MoveData,\n+               move_id: ast::NodeId,\n+               move_kind: MoveKind,\n+               cmt: mc::cmt) {\n+    debug!(\"gather_move(move_id={}, cmt={})\",\n+           move_id, cmt.repr(bccx.tcx));\n+\n+    if !check_is_legal_to_move_from(bccx, cmt, cmt) {\n+        return;\n+    }\n+\n+    match opt_loan_path(cmt) {\n+        Some(loan_path) => {\n+            move_data.add_move(bccx.tcx, loan_path, move_id, move_kind);\n+        }\n+        None => {\n+            // move from rvalue or unsafe pointer, hence ok\n+        }\n+    }\n+}\n+\n pub fn gather_assignment(bccx: &BorrowckCtxt,\n                          move_data: &MoveData,\n                          assignment_id: ast::NodeId,\n@@ -99,15 +101,15 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n                                cmt0: mc::cmt,\n                                cmt: mc::cmt) -> bool {\n     match cmt.cat {\n-        mc::cat_deref(_, _, mc::region_ptr(..)) |\n-        mc::cat_deref(_, _, mc::gc_ptr) |\n-        mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n-        mc::cat_stack_upvar(..) |\n+        mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n+        mc::cat_deref(_, _, mc::GcPtr) |\n+        mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+        mc::cat_upvar(..) |\n         mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {\n             bccx.span_err(\n                 cmt0.span,\n                 format!(\"cannot move out of {}\",\n-                     bccx.cmt_to_str(cmt)));\n+                        bccx.cmt_to_str(cmt)));\n             false\n         }\n \n@@ -158,7 +160,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n             }\n         }\n \n-        mc::cat_deref(b, _, mc::uniq_ptr) |\n+        mc::cat_deref(b, _, mc::OwnedPtr) |\n         mc::cat_discr(b, _) => {\n             check_is_legal_to_move_from(bccx, cmt0, b)\n         }"}, {"sha": "c47affac683f4fcedddc9739bdde9e05cc4ec6d3", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=6b8b75142997b12baf374ef6c4721bec5df62849", "patch": "@@ -26,16 +26,19 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                           item_scope_id: ast::NodeId,\n                           root_scope_id: ast::NodeId,\n                           span: Span,\n+                          cause: LoanCause,\n                           cmt: mc::cmt,\n                           loan_region: ty::Region,\n-                          loan_mutbl: LoanMutability) -> R {\n+                          loan_kind: ty::BorrowKind)\n+                          -> Result<(),()> {\n     debug!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n            cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n                                          item_scope_id: item_scope_id,\n                                          span: span,\n+                                         cause: cause,\n                                          loan_region: loan_region,\n-                                         loan_mutbl: loan_mutbl,\n+                                         loan_kind: loan_kind,\n                                          cmt_original: cmt,\n                                          root_scope_id: root_scope_id};\n     ctxt.check(cmt, None)\n@@ -55,8 +58,9 @@ struct GuaranteeLifetimeContext<'a> {\n     root_scope_id: ast::NodeId,\n \n     span: Span,\n+    cause: LoanCause,\n     loan_region: ty::Region,\n-    loan_mutbl: LoanMutability,\n+    loan_kind: ty::BorrowKind,\n     cmt_original: mc::cmt\n }\n \n@@ -76,21 +80,18 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_copied_upvar(..) |                  // L-Local\n             mc::cat_local(..) |                         // L-Local\n             mc::cat_arg(..) |                           // L-Local\n-            mc::cat_deref(_, _, mc::region_ptr(..)) |   // L-Deref-Borrowed\n-            mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {\n+            mc::cat_upvar(..) |\n+            mc::cat_deref(_, _, mc::BorrowedPtr(..)) |  // L-Deref-Borrowed\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) => {\n                 let scope = self.scope(cmt);\n                 self.check_scope(scope)\n             }\n \n-            mc::cat_stack_upvar(cmt) => {\n-                self.check(cmt, discr_scope)\n-            }\n-\n             mc::cat_static_item => {\n                 Ok(())\n             }\n \n-            mc::cat_deref(base, derefs, mc::gc_ptr) => {\n+            mc::cat_deref(base, derefs, mc::GcPtr) => {\n                 let base_scope = self.scope(base);\n \n                 // L-Deref-Managed-Imm-User-Root\n@@ -112,7 +113,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             }\n \n             mc::cat_downcast(base) |\n-            mc::cat_deref(base, _, mc::uniq_ptr) |     // L-Deref-Send\n+            mc::cat_deref(base, _, mc::OwnedPtr) |     // L-Deref-Send\n             mc::cat_interior(base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n             }\n@@ -269,12 +270,12 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_rvalue(..) |\n             mc::cat_static_item |\n             mc::cat_copied_upvar(..) |\n-            mc::cat_deref(..) => {\n+            mc::cat_deref(..) |\n+            mc::cat_upvar(..) => {\n                 false\n             }\n             r @ mc::cat_downcast(..) |\n             r @ mc::cat_interior(..) |\n-            r @ mc::cat_stack_upvar(..) |\n             r @ mc::cat_discr(..) => {\n                 self.tcx().sess.span_bug(\n                     cmt.span,\n@@ -294,6 +295,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_rvalue(temp_scope) => {\n                 temp_scope\n             }\n+            mc::cat_upvar(..) |\n             mc::cat_copied_upvar(_) => {\n                 ty::ReScope(self.item_scope_id)\n             }\n@@ -304,28 +306,26 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_arg(local_id) => {\n                 ty::ReScope(self.bccx.tcx.region_maps.var_scope(local_id))\n             }\n-            mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) => {\n                 ty::ReStatic\n             }\n-            mc::cat_deref(_, _, mc::region_ptr(_, r)) => {\n+            mc::cat_deref(_, _, mc::BorrowedPtr(_, r)) => {\n                 r\n             }\n             mc::cat_downcast(cmt) |\n-            mc::cat_deref(cmt, _, mc::uniq_ptr) |\n-            mc::cat_deref(cmt, _, mc::gc_ptr) |\n+            mc::cat_deref(cmt, _, mc::OwnedPtr) |\n+            mc::cat_deref(cmt, _, mc::GcPtr) |\n             mc::cat_interior(cmt, _) |\n-            mc::cat_stack_upvar(cmt) |\n             mc::cat_discr(cmt, _) => {\n                 self.scope(cmt)\n             }\n         }\n     }\n \n     fn report_error(&self, code: bckerr_code) {\n-        self.bccx.report(BckError {\n-            cmt: self.cmt_original,\n-            span: self.span,\n-            code: code\n-        });\n+        self.bccx.report(BckError { cmt: self.cmt_original,\n+                                    span: self.span,\n+                                    cause: self.cause,\n+                                    code: code });\n     }\n }"}, {"sha": "c6a77988bced91dbee36b5a8ec24bf4827682cef", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 166, "deletions": 130, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=6b8b75142997b12baf374ef6c4721bec5df62849", "patch": "@@ -16,10 +16,10 @@\n // their associated scopes.  In phase two, checking loans, we will then make\n // sure that all of these loans are honored.\n \n-\n use middle::borrowck::*;\n use middle::borrowck::move_data::MoveData;\n use mc = middle::mem_categorization;\n+use middle::moves;\n use middle::pat_util;\n use middle::ty::{ty_region};\n use middle::ty;\n@@ -28,6 +28,7 @@ use util::ppaux::{Repr};\n \n use std::cell::RefCell;\n use syntax::ast;\n+use syntax::ast_util;\n use syntax::ast_util::IdRange;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n@@ -127,22 +128,15 @@ fn add_pat_to_id_range(this: &mut GatherLoanCtxt,\n     visit::walk_pat(this, p, ());\n }\n \n-fn gather_loans_in_fn(this: &mut GatherLoanCtxt, fk: &FnKind,\n-                      decl: &ast::FnDecl, body: &ast::Block,\n-                      sp: Span, id: ast::NodeId) {\n-    match fk {\n-        &visit::FkItemFn(..) | &visit::FkMethod(..) => {\n-            fail!(\"cannot occur, due to visit_item override\");\n-        }\n-\n-        // Visit closures as part of the containing item.\n-        &visit::FkFnBlock(..) => {\n-            this.push_repeating_id(body.id);\n-            visit::walk_fn(this, fk, decl, body, sp, id, ());\n-            this.pop_repeating_id(body.id);\n-            this.gather_fn_arg_patterns(decl, body);\n-        }\n-    }\n+fn gather_loans_in_fn(_v: &mut GatherLoanCtxt,\n+                      _fk: &FnKind,\n+                      _decl: &ast::FnDecl,\n+                      _body: &ast::Block,\n+                      _sp: Span,\n+                      _id: ast::NodeId) {\n+    // Do not visit closures or fn items here, the outer loop in\n+    // borrowck/mod will visit them for us in turn.\n+    return;\n }\n \n fn gather_loans_in_block(this: &mut GatherLoanCtxt,\n@@ -232,8 +226,9 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n             this.guarantee_valid(ex.id,\n                                  ex.span,\n                                  base_cmt,\n-                                 LoanMutability::from_ast_mutability(mutbl),\n-                                 scope_r);\n+                                 mutbl,\n+                                 scope_r,\n+                                 AddrOf);\n         }\n         visit::walk_expr(this, ex, ());\n       }\n@@ -278,8 +273,9 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n           this.guarantee_valid(arg.id,\n                                arg.span,\n                                arg_cmt,\n-                               ImmutableMutability,\n-                               scope_r);\n+                               ast::MutImmutable,\n+                               scope_r,\n+                               AutoRef);\n           visit::walk_expr(this, ex, ());\n       }\n \n@@ -305,6 +301,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n \n       ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n           gather_moves::gather_captures(this.bccx, &this.move_data, ex);\n+          this.guarantee_captures(ex);\n           visit::walk_expr(this, ex, ());\n       }\n \n@@ -367,49 +364,48 @@ impl<'a> GatherLoanCtxt<'a> {\n                 ty::AutoDerefRef {\n                     autoref: Some(ref autoref),\n                     autoderefs: autoderefs}) => {\n-                let mcx = &mc::mem_categorization_ctxt {\n-                    tcx: self.tcx(),\n-                    method_map: self.bccx.method_map};\n-                let cmt = mcx.cat_expr_autoderefd(expr, autoderefs);\n+                let mut mc = self.bccx.mc();\n+                let cmt = match mc.cat_expr_autoderefd(expr, autoderefs) {\n+                    Ok(v) => v,\n+                    Err(()) => self.tcx().sess.span_bug(expr.span, \"Err from mc\")\n+                };\n                 debug!(\"after autoderef, cmt={}\", cmt.repr(self.tcx()));\n \n                 match *autoref {\n                     ty::AutoPtr(r, m) => {\n-                        let loan_mutability =\n-                            LoanMutability::from_ast_mutability(m);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt,\n-                                             loan_mutability,\n-                                             r)\n+                                             m,\n+                                             r,\n+                                             AutoRef)\n                     }\n                     ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n-                        let cmt_index = mcx.cat_index(expr, cmt, autoderefs+1);\n-                        let loan_mutability =\n-                            LoanMutability::from_ast_mutability(m);\n+                        let cmt_index = mc.cat_index(expr, cmt, autoderefs+1);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_index,\n-                                             loan_mutability,\n-                                             r)\n+                                             m,\n+                                             r,\n+                                             AutoRef)\n                     }\n                     ty::AutoBorrowFn(r) => {\n-                        let cmt_deref = mcx.cat_deref_fn_or_obj(expr, cmt, 0);\n+                        let cmt_deref = mc.cat_deref_fn_or_obj(expr, cmt, 0);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_deref,\n-                                             ImmutableMutability,\n-                                             r)\n+                                             ast::MutImmutable,\n+                                             r,\n+                                             AutoRef)\n                     }\n                     ty::AutoBorrowObj(r, m) => {\n-                        let cmt_deref = mcx.cat_deref_fn_or_obj(expr, cmt, 0);\n-                        let loan_mutability =\n-                            LoanMutability::from_ast_mutability(m);\n+                        let cmt_deref = mc.cat_deref_fn_or_obj(expr, cmt, 0);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_deref,\n-                                             loan_mutability,\n-                                             r)\n+                                             m,\n+                                             r,\n+                                             AutoRef)\n                     }\n                     ty::AutoUnsafe(_) => {}\n                 }\n@@ -421,22 +417,71 @@ impl<'a> GatherLoanCtxt<'a> {\n         }\n     }\n \n-    // Guarantees that addr_of(cmt) will be valid for the duration of\n-    // `static_scope_r`, or reports an error.  This may entail taking\n-    // out loans, which will be added to the `req_loan_map`.  This can\n-    // also entail \"rooting\" GC'd pointers, which means ensuring\n-    // dynamically that they are not freed.\n+    fn guarantee_captures(&mut self,\n+                          closure_expr: &ast::Expr) {\n+        let capture_map = self.bccx.capture_map.borrow();\n+        let captured_vars = capture_map.get().get(&closure_expr.id);\n+        for captured_var in captured_vars.borrow().iter() {\n+            match captured_var.mode {\n+                moves::CapCopy | moves::CapMove => { continue; }\n+                moves::CapRef => { }\n+            }\n+\n+            let var_id = ast_util::def_id_of_def(captured_var.def).node;\n+            let var_cmt = self.bccx.cat_captured_var(closure_expr.id,\n+                                                     closure_expr.span,\n+                                                     captured_var);\n+\n+            // Lookup the kind of borrow the callee requires\n+            let upvar_id = ty::UpvarId { var_id: var_id,\n+                                         closure_expr_id: closure_expr.id };\n+            let upvar_borrow_map = self.tcx().upvar_borrow_map.borrow();\n+            let upvar_borrow = upvar_borrow_map.get().get_copy(&upvar_id);\n+\n+            self.guarantee_valid_kind(closure_expr.id,\n+                                      closure_expr.span,\n+                                      var_cmt,\n+                                      upvar_borrow.kind,\n+                                      upvar_borrow.region,\n+                                      ClosureCapture(captured_var.span));\n+        }\n+    }\n+\n     pub fn guarantee_valid(&mut self,\n                            borrow_id: ast::NodeId,\n                            borrow_span: Span,\n                            cmt: mc::cmt,\n-                           req_mutbl: LoanMutability,\n-                           loan_region: ty::Region) {\n+                           req_mutbl: ast::Mutability,\n+                           loan_region: ty::Region,\n+                           cause: LoanCause) {\n+        self.guarantee_valid_kind(borrow_id,\n+                                  borrow_span,\n+                                  cmt,\n+                                  ty::BorrowKind::from_mutbl(req_mutbl),\n+                                  loan_region,\n+                                  cause);\n+    }\n+\n+    fn guarantee_valid_kind(&mut self,\n+                            borrow_id: ast::NodeId,\n+                            borrow_span: Span,\n+                            cmt: mc::cmt,\n+                            req_kind: ty::BorrowKind,\n+                            loan_region: ty::Region,\n+                            cause: LoanCause) {\n+        /*!\n+         * Guarantees that `addr_of(cmt)` will be valid for the duration of\n+         * `static_scope_r`, or reports an error.  This may entail taking\n+         * out loans, which will be added to the `req_loan_map`.  This can\n+         * also entail \"rooting\" GC'd pointers, which means ensuring\n+         * dynamically that they are not freed.\n+         */\n+\n         debug!(\"guarantee_valid(borrow_id={:?}, cmt={}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n                cmt.repr(self.tcx()),\n-               req_mutbl,\n+               req_kind,\n                loan_region);\n \n         // a loan for the empty region can never be dereferenced, so\n@@ -450,26 +495,28 @@ impl<'a> GatherLoanCtxt<'a> {\n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed.\n         if lifetime::guarantee_lifetime(self.bccx, self.item_ub, root_ub,\n-                                        borrow_span, cmt, loan_region,\n-                                        req_mutbl).is_err() {\n+                                        borrow_span, cause, cmt, loan_region,\n+                                        req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of non-mutable data.\n-        if check_mutability(self.bccx, borrow_span, cmt, req_mutbl).is_err() {\n+        if check_mutability(self.bccx, borrow_span, cause,\n+                            cmt, req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of aliasable data.\n-        if check_aliasability(self.bccx, borrow_span, cmt, req_mutbl).is_err() {\n+        if check_aliasability(self.bccx, borrow_span, cause,\n+                              cmt, req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Compute the restrictions that are required to enforce the\n         // loan is safe.\n         let restr = restrictions::compute_restrictions(\n-            self.bccx, borrow_span,\n-            cmt, loan_region, self.restriction_set(req_mutbl));\n+            self.bccx, borrow_span, cause,\n+            cmt, loan_region, self.restriction_set(req_kind));\n \n         // Create the loan record (if needed).\n         let loan = match restr {\n@@ -512,7 +559,7 @@ impl<'a> GatherLoanCtxt<'a> {\n                 let kill_scope = self.compute_kill_scope(loan_scope, loan_path);\n                 debug!(\"kill_scope = {:?}\", kill_scope);\n \n-                if req_mutbl == MutableMutability {\n+                if req_kind == ty::MutBorrow {\n                     self.mark_loan_path_as_mutated(loan_path);\n                 }\n \n@@ -521,11 +568,12 @@ impl<'a> GatherLoanCtxt<'a> {\n                     index: all_loans.get().len(),\n                     loan_path: loan_path,\n                     cmt: cmt,\n-                    mutbl: req_mutbl,\n+                    kind: req_kind,\n                     gen_scope: gen_scope,\n                     kill_scope: kill_scope,\n                     span: borrow_span,\n-                    restrictions: restrictions\n+                    restrictions: restrictions,\n+                    cause: cause,\n                 }\n             }\n         };\n@@ -568,23 +616,33 @@ impl<'a> GatherLoanCtxt<'a> {\n \n         fn check_mutability(bccx: &BorrowckCtxt,\n                             borrow_span: Span,\n+                            cause: LoanCause,\n                             cmt: mc::cmt,\n-                            req_mutbl: LoanMutability) -> Result<(),()> {\n+                            req_kind: ty::BorrowKind)\n+                            -> Result<(),()> {\n             //! Implements the M-* rules in doc.rs.\n \n-            match req_mutbl {\n-                ImmutableMutability => {\n-                    // both imm and mut data can be lent as imm;\n-                    // for mutable data, this is a freeze\n-                    Ok(())\n+            match req_kind {\n+                ty::UniqueImmBorrow | ty::ImmBorrow => {\n+                    match cmt.mutbl {\n+                        // I am intentionally leaving this here to help\n+                        // refactoring if, in the future, we should add new\n+                        // kinds of mutability.\n+                        mc::McImmutable | mc::McDeclared | mc::McInherited => {\n+                            // both imm and mut data can be lent as imm;\n+                            // for mutable data, this is a freeze\n+                            Ok(())\n+                        }\n+                    }\n                 }\n \n-                MutableMutability => {\n+                ty::MutBorrow => {\n                     // Only mutable data can be lent as mutable.\n                     if !cmt.mutbl.is_mutable() {\n-                        Err(bccx.report(BckError {span: borrow_span,\n-                                                  cmt: cmt,\n-                                                  code: err_mutbl(req_mutbl)}))\n+                        Err(bccx.report(BckError { span: borrow_span,\n+                                                   cause: cause,\n+                                                   cmt: cmt,\n+                                                   code: err_mutbl }))\n                     } else {\n                         Ok(())\n                     }\n@@ -594,18 +652,18 @@ impl<'a> GatherLoanCtxt<'a> {\n \n         fn check_aliasability(bccx: &BorrowckCtxt,\n                               borrow_span: Span,\n+                              loan_cause: LoanCause,\n                               cmt: mc::cmt,\n-                              req_mutbl: LoanMutability) -> Result<(),()> {\n+                              req_kind: ty::BorrowKind)\n+                              -> Result<(),()> {\n             //! Implements the A-* rules in doc.rs.\n \n-            match req_mutbl {\n-                ImmutableMutability => {\n-                    // both imm and mut data can be lent as imm;\n-                    // for mutable data, this is a freeze\n+            match req_kind {\n+                ty::ImmBorrow => {\n                     Ok(())\n                 }\n \n-                MutableMutability => {\n+                ty::UniqueImmBorrow | ty::MutBorrow => {\n                     // Check for those cases where we cannot control\n                     // the aliasing and make sure that we are not\n                     // being asked to.\n@@ -620,11 +678,11 @@ impl<'a> GatherLoanCtxt<'a> {\n                             // unsafe. At your own peril and all that.\n                             Ok(())\n                         }\n-                        Some(cause) => {\n+                        Some(alias_cause) => {\n                             bccx.report_aliasability_violation(\n                                 borrow_span,\n-                                BorrowViolation,\n-                                cause);\n+                                BorrowViolation(loan_cause),\n+                                alias_cause);\n                             Err(())\n                         }\n                     }\n@@ -633,11 +691,18 @@ impl<'a> GatherLoanCtxt<'a> {\n         }\n     }\n \n-    pub fn restriction_set(&self, req_mutbl: LoanMutability)\n-                           -> RestrictionSet {\n-        match req_mutbl {\n-            ImmutableMutability => RESTR_MUTATE | RESTR_CLAIM,\n-            MutableMutability => RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE,\n+    fn restriction_set(&self, req_kind: ty::BorrowKind) -> RestrictionSet {\n+        match req_kind {\n+            // If borrowing data as immutable, no mutation allowed:\n+            ty::ImmBorrow => RESTR_MUTATE,\n+\n+            // If borrowing data as mutable, no mutation nor other\n+            // borrows allowed:\n+            ty::MutBorrow => RESTR_MUTATE | RESTR_FREEZE,\n+\n+            // If borrowing data as unique imm, no mutation nor other\n+            // borrows allowed:\n+            ty::UniqueImmBorrow => RESTR_MUTATE | RESTR_FREEZE,\n         }\n     }\n \n@@ -719,11 +784,11 @@ impl<'a> GatherLoanCtxt<'a> {\n          * `gather_pat()`.\n          */\n \n-        let mc_ctxt = self.bccx.mc_ctxt();\n+        let mut mc = self.bccx.mc();\n         for arg in decl.inputs.iter() {\n             let arg_ty = ty::node_id_to_type(self.tcx(), arg.pat.id);\n \n-            let arg_cmt = mc_ctxt.cat_rvalue(\n+            let arg_cmt = mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n                 ty::ReScope(body.id), // Args live only as long as the fn body.\n@@ -735,7 +800,7 @@ impl<'a> GatherLoanCtxt<'a> {\n \n     fn gather_pat(&mut self,\n                   discr_cmt: mc::cmt,\n-                  root_pat: &ast::Pat,\n+                  root_pat: @ast::Pat,\n                   arm_match_ids: Option<(ast::NodeId, ast::NodeId)>) {\n         /*!\n          * Walks patterns, examining the bindings to determine if they\n@@ -774,13 +839,12 @@ impl<'a> GatherLoanCtxt<'a> {\n                             }\n                         }\n                     };\n-                    let loan_mutability =\n-                        LoanMutability::from_ast_mutability(mutbl);\n                     self.guarantee_valid(pat.id,\n                                          pat.span,\n                                          cmt_discr,\n-                                         loan_mutability,\n-                                         scope_r);\n+                                         mutbl,\n+                                         scope_r,\n+                                         RefBinding);\n                   }\n                   ast::BindByValue(_) => {\n                       // No borrows here, but there may be moves\n@@ -797,14 +861,15 @@ impl<'a> GatherLoanCtxt<'a> {\n                   // original vector.  This is effectively a borrow of\n                   // the elements of the vector being matched.\n \n-                  let slice_ty = ty::node_id_to_type(self.tcx(),\n-                                                     slice_pat.id);\n-                  let (slice_mutbl, slice_r) =\n-                      self.vec_slice_info(slice_pat, slice_ty);\n-                  let mcx = self.bccx.mc_ctxt();\n-                  let cmt_index = mcx.cat_index(slice_pat, cmt, 0);\n-                  let slice_loan_mutability =\n-                    LoanMutability::from_ast_mutability(slice_mutbl);\n+                  let (slice_cmt, slice_borrow_kind, slice_r) = {\n+                      match self.bccx.mc().cat_slice_pattern(cmt, slice_pat) {\n+                          Ok(v) => v,\n+                          Err(()) => {\n+                              self.tcx().sess.span_bug(slice_pat.span,\n+                                                       \"Err from mc\")\n+                          }\n+                      }\n+                  };\n \n                   // Note: We declare here that the borrow occurs upon\n                   // entering the `[...]` pattern. This implies that\n@@ -823,45 +888,16 @@ impl<'a> GatherLoanCtxt<'a> {\n                   // trans do the right thing, and it would only work\n                   // for `~` vectors. It seems simpler to just require\n                   // that people call `vec.pop()` or `vec.unshift()`.\n-                  self.guarantee_valid(pat.id,\n-                                       pat.span,\n-                                       cmt_index,\n-                                       slice_loan_mutability,\n-                                       slice_r);\n+                  self.guarantee_valid(pat.id, pat.span,\n+                                       slice_cmt, slice_borrow_kind, slice_r,\n+                                       RefBinding);\n               }\n \n               _ => {}\n             }\n         })\n     }\n \n-    pub fn vec_slice_info(&self, pat: &ast::Pat, slice_ty: ty::t)\n-                          -> (ast::Mutability, ty::Region) {\n-        /*!\n-         *\n-         * In a pattern like [a, b, ..c], normally `c` has slice type,\n-         * but if you have [a, b, ..ref c], then the type of `ref c`\n-         * will be `&&[]`, so to extract the slice details we have\n-         * to recurse through rptrs.\n-         */\n-\n-        match ty::get(slice_ty).sty {\n-            ty::ty_vec(slice_mt, ty::vstore_slice(slice_r)) => {\n-                (slice_mt.mutbl, slice_r)\n-            }\n-\n-            ty::ty_rptr(_, ref mt) => {\n-                self.vec_slice_info(pat, mt.ty)\n-            }\n-\n-            _ => {\n-                self.tcx().sess.span_bug(\n-                    pat.span,\n-                    format!(\"type of slice pattern is not a slice\"));\n-            }\n-        }\n-    }\n-\n     pub fn pat_is_binding(&self, pat: &ast::Pat) -> bool {\n         pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n     }"}, {"sha": "575119ba6904b34933032277c803acfcbc564ada", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=6b8b75142997b12baf374ef6c4721bec5df62849", "patch": "@@ -16,8 +16,8 @@ use std::vec;\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n-use syntax::ast::{MutImmutable, MutMutable};\n use syntax::codemap::Span;\n+use util::ppaux::Repr;\n \n pub enum RestrictionResult {\n     Safe,\n@@ -26,12 +26,14 @@ pub enum RestrictionResult {\n \n pub fn compute_restrictions(bccx: &BorrowckCtxt,\n                             span: Span,\n+                            cause: LoanCause,\n                             cmt: mc::cmt,\n                             loan_region: ty::Region,\n                             restr: RestrictionSet) -> RestrictionResult {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n         span: span,\n+        cause: cause,\n         cmt_original: cmt,\n         loan_region: loan_region,\n     };\n@@ -47,12 +49,17 @@ struct RestrictionsContext<'a> {\n     span: Span,\n     cmt_original: mc::cmt,\n     loan_region: ty::Region,\n+    cause: LoanCause,\n }\n \n impl<'a> RestrictionsContext<'a> {\n     fn restrict(&self,\n                 cmt: mc::cmt,\n                 restrictions: RestrictionSet) -> RestrictionResult {\n+        debug!(\"restrict(cmt={}, restrictions={})\",\n+               cmt.repr(self.bccx.tcx),\n+               restrictions.repr(self.bccx.tcx));\n+\n         match cmt.cat {\n             mc::cat_rvalue(..) => {\n                 // Effectively, rvalues are stored into a\n@@ -64,7 +71,8 @@ impl<'a> RestrictionsContext<'a> {\n             }\n \n             mc::cat_local(local_id) |\n-            mc::cat_arg(local_id) => {\n+            mc::cat_arg(local_id) |\n+            mc::cat_upvar(ty::UpvarId {var_id: local_id, ..}, _) => {\n                 // R-Variable\n                 let lp = @LpVar(local_id);\n                 SafeIf(lp, ~[Restriction {loan_path: lp,\n@@ -77,7 +85,7 @@ impl<'a> RestrictionsContext<'a> {\n                 // could cause the type of the memory to change.\n                 self.restrict(\n                     cmt_base,\n-                    restrictions | RESTR_MUTATE | RESTR_CLAIM)\n+                    restrictions | RESTR_MUTATE)\n             }\n \n             mc::cat_interior(cmt_base, i) => {\n@@ -90,15 +98,15 @@ impl<'a> RestrictionsContext<'a> {\n                 self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::uniq_ptr) => {\n+            mc::cat_deref(cmt_base, _, pk @ mc::OwnedPtr) => {\n                 // R-Deref-Send-Pointer\n                 //\n                 // When we borrow the interior of an owned pointer, we\n                 // cannot permit the base to be mutated, because that\n                 // would cause the unique pointer to be freed.\n                 let result = self.restrict(\n                     cmt_base,\n-                    restrictions | RESTR_MUTATE | RESTR_CLAIM);\n+                    restrictions | RESTR_MUTATE);\n                 self.extend(result, cmt.mutbl, LpDeref(pk), restrictions)\n             }\n \n@@ -107,12 +115,14 @@ impl<'a> RestrictionsContext<'a> {\n                 Safe\n             }\n \n-            mc::cat_deref(cmt_base, _, mc::region_ptr(MutImmutable, lt)) => {\n+            mc::cat_deref(cmt_base, _, mc::BorrowedPtr(ty::ImmBorrow, lt)) |\n+            mc::cat_deref(cmt_base, _, mc::BorrowedPtr(ty::UniqueImmBorrow, lt)) => {\n                 // R-Deref-Imm-Borrowed\n                 if !self.bccx.is_subregion_of(self.loan_region, lt) {\n                     self.bccx.report(\n                         BckError {\n                             span: self.span,\n+                            cause: self.cause,\n                             cmt: cmt_base,\n                             code: err_borrowed_pointer_too_short(\n                                 self.loan_region, lt, restrictions)});\n@@ -121,17 +131,18 @@ impl<'a> RestrictionsContext<'a> {\n                 Safe\n             }\n \n-            mc::cat_deref(_, _, mc::gc_ptr) => {\n+            mc::cat_deref(_, _, mc::GcPtr) => {\n                 // R-Deref-Imm-Managed\n                 Safe\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::region_ptr(MutMutable, lt)) => {\n+            mc::cat_deref(cmt_base, _, pk @ mc::BorrowedPtr(ty::MutBorrow, lt)) => {\n                 // R-Deref-Mut-Borrowed\n                 if !self.bccx.is_subregion_of(self.loan_region, lt) {\n                     self.bccx.report(\n                         BckError {\n                             span: self.span,\n+                            cause: self.cause,\n                             cmt: cmt_base,\n                             code: err_borrowed_pointer_too_short(\n                                 self.loan_region, lt, restrictions)});\n@@ -142,12 +153,11 @@ impl<'a> RestrictionsContext<'a> {\n                 self.extend(result, cmt.mutbl, LpDeref(pk), restrictions)\n             }\n \n-            mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) => {\n                 // We are very trusting when working with unsafe pointers.\n                 Safe\n             }\n \n-            mc::cat_stack_upvar(cmt_base) |\n             mc::cat_discr(cmt_base, _) => {\n                 self.restrict(cmt_base, restrictions)\n             }"}, {"sha": "acc8ece85f8d8cce8051dc8c0f9edaaf308ce385", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 207, "deletions": 153, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=6b8b75142997b12baf374ef6c4721bec5df62849", "patch": "@@ -120,41 +120,32 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                body: &ast::Block,\n                sp: Span,\n                id: ast::NodeId) {\n-    match fk {\n-        &visit::FkFnBlock(..) => {\n-            // Closures are checked as part of their containing fn item.\n-        }\n-\n-        &visit::FkItemFn(..) | &visit::FkMethod(..) => {\n-            debug!(\"borrowck_fn(id={:?})\", id);\n-\n-            // Check the body of fn items.\n-            let (id_range, all_loans, move_data) =\n-                gather_loans::gather_loans(this, decl, body);\n-\n-            let all_loans = all_loans.borrow();\n-            let mut loan_dfcx = DataFlowContext::new(this.tcx,\n-                                                     this.method_map,\n-                                                     LoanDataFlowOperator,\n-                                                     id_range,\n-                                                     all_loans.get().len());\n-            for (loan_idx, loan) in all_loans.get().iter().enumerate() {\n-                loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n-                loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n-            }\n-\n-            loan_dfcx.propagate(body);\n-\n-            let flowed_moves = move_data::FlowedMoveData::new(move_data,\n-                                                              this.tcx,\n-                                                              this.method_map,\n-                                                              id_range,\n-                                                              body);\n-\n-            check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n-                                     *all_loans.get(), body);\n-        }\n-    }\n+    debug!(\"borrowck_fn(id={})\", id);\n+\n+    // Check the body of fn items.\n+    let (id_range, all_loans, move_data) =\n+        gather_loans::gather_loans(this, decl, body);\n+    let all_loans = all_loans.borrow();\n+    let mut loan_dfcx =\n+        DataFlowContext::new(this.tcx,\n+                             this.method_map,\n+                             LoanDataFlowOperator,\n+                             id_range,\n+                             all_loans.get().len());\n+    for (loan_idx, loan) in all_loans.get().iter().enumerate() {\n+        loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n+        loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n+    }\n+    loan_dfcx.propagate(body);\n+\n+    let flowed_moves = move_data::FlowedMoveData::new(move_data,\n+                                                      this.tcx,\n+                                                      this.method_map,\n+                                                      id_range,\n+                                                      body);\n+\n+    check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n+                             *all_loans.get(), body);\n \n     visit::walk_fn(this, fk, decl, body, sp, id, ());\n }\n@@ -211,41 +202,25 @@ pub enum PartialTotal {\n ///////////////////////////////////////////////////////////////////////////\n // Loans and loan paths\n \n-#[deriving(Clone, Eq)]\n-pub enum LoanMutability {\n-    ImmutableMutability,\n-    MutableMutability,\n-}\n-\n-impl LoanMutability {\n-    pub fn from_ast_mutability(ast_mutability: ast::Mutability)\n-                               -> LoanMutability {\n-        match ast_mutability {\n-            ast::MutImmutable => ImmutableMutability,\n-            ast::MutMutable => MutableMutability,\n-        }\n-    }\n-}\n-\n-impl ToStr for LoanMutability {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            ImmutableMutability => ~\"immutable\",\n-            MutableMutability => ~\"mutable\",\n-        }\n-    }\n-}\n-\n /// Record of a loan that was issued.\n pub struct Loan {\n     index: uint,\n     loan_path: @LoanPath,\n     cmt: mc::cmt,\n-    mutbl: LoanMutability,\n+    kind: ty::BorrowKind,\n     restrictions: ~[Restriction],\n     gen_scope: ast::NodeId,\n     kill_scope: ast::NodeId,\n     span: Span,\n+    cause: LoanCause,\n+}\n+\n+#[deriving(Eq)]\n+pub enum LoanCause {\n+    ClosureCapture(Span),\n+    AddrOf,\n+    AutoRef,\n+    RefBinding,\n }\n \n #[deriving(Eq, IterBytes)]\n@@ -283,7 +258,9 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n             None\n         }\n \n-        mc::cat_local(id) | mc::cat_arg(id) => {\n+        mc::cat_local(id) |\n+        mc::cat_arg(id) |\n+        mc::cat_upvar(ty::UpvarId {var_id: id, ..}, _) => {\n             Some(@LpVar(id))\n         }\n \n@@ -300,7 +277,6 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n         }\n \n         mc::cat_downcast(cmt_base) |\n-        mc::cat_stack_upvar(cmt_base) |\n         mc::cat_discr(cmt_base, _) => {\n             opt_loan_path(cmt_base)\n         }\n@@ -313,8 +289,7 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n // Borrowing an lvalue often results in *restrictions* that limit what\n // can be done with this lvalue during the scope of the loan:\n //\n-// - `RESTR_MUTATE`: The lvalue may not be modified.\n-// - `RESTR_CLAIM`: `&mut` borrows of the lvalue are forbidden.\n+// - `RESTR_MUTATE`: The lvalue may not be modified or `&mut` borrowed.\n // - `RESTR_FREEZE`: `&` borrows of the lvalue are forbidden.\n //\n // In addition, no value which is restricted may be moved. Therefore,\n@@ -333,8 +308,7 @@ pub struct RestrictionSet {\n \n pub static RESTR_EMPTY: RestrictionSet  = RestrictionSet {bits: 0b0000};\n pub static RESTR_MUTATE: RestrictionSet = RestrictionSet {bits: 0b0001};\n-pub static RESTR_CLAIM: RestrictionSet  = RestrictionSet {bits: 0b0010};\n-pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b0100};\n+pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b0010};\n \n impl RestrictionSet {\n     pub fn intersects(&self, restr: RestrictionSet) -> bool {\n@@ -358,6 +332,12 @@ impl BitAnd<RestrictionSet,RestrictionSet> for RestrictionSet {\n     }\n }\n \n+impl Repr for RestrictionSet {\n+    fn repr(&self, _tcx: ty::ctxt) -> ~str {\n+        format!(\"RestrictionSet(0x{:x})\", self.bits as uint)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Rooting of managed boxes\n //\n@@ -393,10 +373,9 @@ pub fn root_map() -> root_map {\n // Errors that can occur\n #[deriving(Eq)]\n pub enum bckerr_code {\n-    err_mutbl(LoanMutability),\n+    err_mutbl,\n     err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n     err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n-    err_freeze_aliasable_const,\n     err_borrowed_pointer_too_short(\n         ty::Region, ty::Region, RestrictionSet), // loan, ptr\n }\n@@ -406,13 +385,14 @@ pub enum bckerr_code {\n #[deriving(Eq)]\n pub struct BckError {\n     span: Span,\n+    cause: LoanCause,\n     cmt: mc::cmt,\n     code: bckerr_code\n }\n \n pub enum AliasableViolationKind {\n     MutabilityViolation,\n-    BorrowViolation\n+    BorrowViolation(LoanCause)\n }\n \n pub enum MovedValueUseKind {\n@@ -439,29 +419,55 @@ impl BorrowckCtxt {\n         moves_map.get().contains(&id)\n     }\n \n+    pub fn mc(&self) -> mc::MemCategorizationContext<TcxTyper> {\n+        mc::MemCategorizationContext {\n+            typer: TcxTyper {\n+                tcx: self.tcx,\n+                method_map: self.method_map\n+            }\n+        }\n+    }\n+\n     pub fn cat_expr(&self, expr: &ast::Expr) -> mc::cmt {\n-        mc::cat_expr(self.tcx, self.method_map, expr)\n+        match self.mc().cat_expr(expr) {\n+            Ok(c) => c,\n+            Err(()) => {\n+                self.tcx.sess.span_bug(expr.span, \"error in mem categorization\");\n+            }\n+        }\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> mc::cmt {\n-        mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n+        match self.mc().cat_expr_unadjusted(expr) {\n+            Ok(c) => c,\n+            Err(()) => {\n+                self.tcx.sess.span_bug(expr.span, \"error in mem categorization\");\n+            }\n+        }\n     }\n \n     pub fn cat_expr_autoderefd(&self,\n                                expr: &ast::Expr,\n                                adj: &ty::AutoAdjustment)\n                                -> mc::cmt {\n-        match *adj {\n+        let r = match *adj {\n             ty::AutoAddEnv(..) | ty::AutoObject(..) => {\n                 // no autoderefs\n-                mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n+                self.mc().cat_expr_unadjusted(expr)\n             }\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoderefs: autoderefs, ..}) => {\n-                mc::cat_expr_autoderefd(self.tcx, self.method_map, expr,\n-                                        autoderefs)\n+                self.mc().cat_expr_autoderefd(expr, autoderefs)\n+            }\n+        };\n+\n+        match r {\n+            Ok(c) => c,\n+            Err(()) => {\n+                self.tcx.sess.span_bug(expr.span,\n+                                       \"error in mem categorization\");\n             }\n         }\n     }\n@@ -472,7 +478,23 @@ impl BorrowckCtxt {\n                    ty: ty::t,\n                    def: ast::Def)\n                    -> mc::cmt {\n-        mc::cat_def(self.tcx, self.method_map, id, span, ty, def)\n+        match self.mc().cat_def(id, span, ty, def) {\n+            Ok(c) => c,\n+            Err(()) => {\n+                self.tcx.sess.span_bug(span, \"error in mem categorization\");\n+            }\n+        }\n+    }\n+\n+    pub fn cat_captured_var(&self,\n+                            id: ast::NodeId,\n+                            span: Span,\n+                            captured_var: &moves::CaptureVar) -> mc::cmt {\n+        // Create the cmt for the variable being borrowed, from the\n+        // caller's perspective\n+        let var_id = ast_util::def_id_of_def(captured_var.def).node;\n+        let var_ty = ty::node_id_to_type(self.tcx, var_id);\n+        self.cat_def(id, span, var_ty, captured_var.def)\n     }\n \n     pub fn cat_discr(&self, cmt: mc::cmt, match_id: ast::NodeId) -> mc::cmt {\n@@ -481,17 +503,12 @@ impl BorrowckCtxt {\n                    ..*cmt}\n     }\n \n-    pub fn mc_ctxt(&self) -> mc::mem_categorization_ctxt {\n-        mc::mem_categorization_ctxt {tcx: self.tcx,\n-                                     method_map: self.method_map}\n-    }\n-\n     pub fn cat_pattern(&self,\n                        cmt: mc::cmt,\n-                       pat: &ast::Pat,\n+                       pat: @ast::Pat,\n                        op: |mc::cmt, &ast::Pat|) {\n-        let mc = self.mc_ctxt();\n-        mc.cat_pattern(cmt, pat, op);\n+        let r = self.mc().cat_pattern(cmt, pat, |_,x,y| op(x,y));\n+        assert!(r.is_ok());\n     }\n \n     pub fn report(&self, err: BckError) {\n@@ -622,24 +639,35 @@ impl BorrowckCtxt {\n \n     pub fn bckerr_to_str(&self, err: BckError) -> ~str {\n         match err.code {\n-            err_mutbl(lk) => {\n-                format!(\"cannot borrow {} {} as {}\",\n-                     err.cmt.mutbl.to_user_str(),\n-                     self.cmt_to_str(err.cmt),\n-                     self.mut_to_str(lk))\n+            err_mutbl => {\n+                let descr = match opt_loan_path(err.cmt) {\n+                    None => format!(\"{} {}\",\n+                                    err.cmt.mutbl.to_user_str(),\n+                                    self.cmt_to_str(err.cmt)),\n+                    Some(lp) => format!(\"{} {} `{}`\",\n+                                        err.cmt.mutbl.to_user_str(),\n+                                        self.cmt_to_str(err.cmt),\n+                                        self.loan_path_to_str(lp)),\n+                };\n+\n+                match err.cause {\n+                    ClosureCapture(_) => {\n+                        format!(\"closure cannot assign to {}\", descr)\n+                    }\n+                    AddrOf | RefBinding | AutoRef => {\n+                        format!(\"cannot borrow {} as mutable\", descr)\n+                    }\n+                }\n             }\n             err_out_of_root_scope(..) => {\n                 format!(\"cannot root managed value long enough\")\n             }\n             err_out_of_scope(..) => {\n-                format!(\"borrowed value does not live long enough\")\n-            }\n-            err_freeze_aliasable_const => {\n-                // Means that the user borrowed a ~T or enum value\n-                // residing in &const or @const pointer.  Terrible\n-                // error message, but then &const and @const are\n-                // supposed to be going away.\n-                format!(\"unsafe borrow of aliasable, const value\")\n+                let msg = match opt_loan_path(err.cmt) {\n+                    None => format!(\"borrowed value\"),\n+                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n+                };\n+                format!(\"{} does not live long enough\", msg)\n             }\n             err_borrowed_pointer_too_short(..) => {\n                 let descr = match opt_loan_path(err.cmt) {\n@@ -659,8 +687,24 @@ impl BorrowckCtxt {\n                                          kind: AliasableViolationKind,\n                                          cause: mc::AliasableReason) {\n         let prefix = match kind {\n-            MutabilityViolation => \"cannot assign to data\",\n-            BorrowViolation => \"cannot borrow data mutably\"\n+            MutabilityViolation => {\n+                \"cannot assign to data\"\n+            }\n+            BorrowViolation(ClosureCapture(_)) => {\n+                // I don't think we can get aliasability violations\n+                // with closure captures, so no need to come up with a\n+                // good error message. The reason this cannot happen\n+                // is because we only capture local variables in\n+                // closures, and those are never aliasable.\n+                self.tcx.sess.span_bug(\n+                    span,\n+                    \"aliasability violation with closure\");\n+            }\n+            BorrowViolation(AddrOf) |\n+            BorrowViolation(AutoRef) |\n+            BorrowViolation(RefBinding) => {\n+                \"cannot borrow data mutably\"\n+            }\n         };\n \n         match cause {\n@@ -680,7 +724,7 @@ impl BorrowckCtxt {\n                     span,\n                     format!(\"{} in a `@` pointer\", prefix));\n             }\n-            mc::AliasableBorrowed(_) => {\n+            mc::AliasableBorrowed => {\n                 self.tcx.sess.span_err(\n                     span,\n                     format!(\"{} in a `&` reference\", prefix));\n@@ -691,7 +735,7 @@ impl BorrowckCtxt {\n     pub fn note_and_explain_bckerr(&self, err: BckError) {\n         let code = err.code;\n         match code {\n-            err_mutbl(..) | err_freeze_aliasable_const(..) => {}\n+            err_mutbl(..) => { }\n \n             err_out_of_root_scope(super_scope, sub_scope) => {\n                 note_and_explain_region(\n@@ -738,52 +782,16 @@ impl BorrowckCtxt {\n         }\n     }\n \n-    pub fn append_loan_path_to_str_from_interior(&self,\n-                                                 loan_path: &LoanPath,\n-                                                 out: &mut ~str) {\n-        match *loan_path {\n-            LpExtend(_, _, LpDeref(_)) => {\n-                out.push_char('(');\n-                self.append_loan_path_to_str(loan_path, out);\n-                out.push_char(')');\n-            }\n-            LpExtend(_, _, LpInterior(_)) |\n-            LpVar(_) => {\n-                self.append_loan_path_to_str(loan_path, out);\n-            }\n-        }\n-    }\n-\n     pub fn append_loan_path_to_str(&self,\n                                    loan_path: &LoanPath,\n                                    out: &mut ~str) {\n         match *loan_path {\n             LpVar(id) => {\n-                match self.tcx.items.find(id) {\n-                    Some(ast_map::NodeLocal(pat)) => {\n-                        match pat.node {\n-                            ast::PatIdent(_, ref path, _) => {\n-                                let ident = ast_util::path_to_ident(path);\n-                                let string = token::get_ident(ident.name);\n-                                out.push_str(string.get());\n-                            }\n-                            _ => {\n-                                self.tcx.sess.bug(\n-                                    format!(\"loan path LpVar({:?}) maps to {:?}, not local\",\n-                                        id, pat));\n-                            }\n-                        }\n-                    }\n-                    r => {\n-                        self.tcx.sess.bug(\n-                            format!(\"loan path LpVar({:?}) maps to {:?}, not local\",\n-                                 id, r));\n-                    }\n-                }\n+                out.push_str(ty::local_var_name_str(self.tcx, id).get());\n             }\n \n             LpExtend(lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n-                self.append_loan_path_to_str_from_interior(lp_base, out);\n+                self.append_autoderefd_loan_path_to_str(lp_base, out);\n                 match fname {\n                     mc::NamedField(ref fname) => {\n                         let string = token::get_ident(*fname);\n@@ -798,8 +806,8 @@ impl BorrowckCtxt {\n             }\n \n             LpExtend(lp_base, _, LpInterior(mc::InteriorElement(_))) => {\n-                self.append_loan_path_to_str_from_interior(lp_base, out);\n-                out.push_str(\"[]\");\n+                self.append_autoderefd_loan_path_to_str(lp_base, out);\n+                out.push_str(\"[..]\");\n             }\n \n             LpExtend(lp_base, _, LpDeref(_)) => {\n@@ -809,20 +817,35 @@ impl BorrowckCtxt {\n         }\n     }\n \n+    pub fn append_autoderefd_loan_path_to_str(&self,\n+                                              loan_path: &LoanPath,\n+                                              out: &mut ~str) {\n+        match *loan_path {\n+            LpExtend(lp_base, _, LpDeref(_)) => {\n+                // For a path like `(*x).f` or `(*x)[3]`, autoderef\n+                // rules would normally allow users to omit the `*x`.\n+                // So just serialize such paths to `x.f` or x[3]` respectively.\n+                self.append_autoderefd_loan_path_to_str(lp_base, out)\n+            }\n+\n+            LpVar(..) | LpExtend(_, _, LpInterior(..)) => {\n+                self.append_loan_path_to_str(loan_path, out)\n+            }\n+        }\n+    }\n+\n     pub fn loan_path_to_str(&self, loan_path: &LoanPath) -> ~str {\n         let mut result = ~\"\";\n         self.append_loan_path_to_str(loan_path, &mut result);\n         result\n     }\n \n     pub fn cmt_to_str(&self, cmt: mc::cmt) -> ~str {\n-        let mc = &mc::mem_categorization_ctxt {tcx: self.tcx,\n-                                               method_map: self.method_map};\n-        mc.cmt_to_str(cmt)\n+        self.mc().cmt_to_str(cmt)\n     }\n \n-    pub fn mut_to_str(&self, mutbl: LoanMutability) -> ~str {\n-        mutbl.to_str()\n+    pub fn mut_to_str(&self, mutbl: ast::Mutability) -> ~str {\n+        self.mc().mut_to_str(mutbl)\n     }\n \n     pub fn mut_to_keyword(&self, mutbl: ast::Mutability) -> &'static str {\n@@ -843,19 +866,14 @@ impl DataFlowOperator for LoanDataFlowOperator {\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // loans from both preds are in scope\n     }\n-\n-    #[inline]\n-    fn walk_closures(&self) -> bool {\n-        true\n-    }\n }\n \n impl Repr for Loan {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         format!(\"Loan_{:?}({}, {:?}, {:?}-{:?}, {})\",\n              self.index,\n              self.loan_path.repr(tcx),\n-             self.mutbl,\n+             self.kind,\n              self.gen_scope,\n              self.kill_scope,\n              self.restrictions.repr(tcx))\n@@ -890,3 +908,39 @@ impl Repr for LoanPath {\n         }\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+struct TcxTyper {\n+    tcx: ty::ctxt,\n+    method_map: typeck::method_map,\n+}\n+\n+impl mc::Typer for TcxTyper {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.tcx\n+    }\n+\n+    fn node_ty(&mut self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+        Ok(ty::node_id_to_type(self.tcx, id))\n+    }\n+\n+    fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n+        let adjustments = self.tcx.adjustments.borrow();\n+        adjustments.get().find_copy(&id)\n+    }\n+\n+    fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n+        let method_map = self.method_map.borrow();\n+        method_map.get().contains_key(&id)\n+    }\n+\n+    fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n+        self.tcx.region_maps.temporary_scope(id)\n+    }\n+\n+    fn upvar_borrow(&mut self, id: ty::UpvarId) -> ty::UpvarBorrow {\n+        let upvar_borrow_map = self.tcx.upvar_borrow_map.borrow();\n+        upvar_borrow_map.get().get_copy(&id)\n+    }\n+}"}, {"sha": "34efcacc44b0611fe3735283a05f66db2b142ae5", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8b75142997b12baf374ef6c4721bec5df62849/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=6b8b75142997b12baf374ef6c4721bec5df62849", "patch": "@@ -722,11 +722,6 @@ impl DataFlowOperator for MoveDataFlowOperator {\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // moves from both preds are in scope\n     }\n-\n-    #[inline]\n-    fn walk_closures(&self) -> bool {\n-        true\n-    }\n }\n \n impl DataFlowOperator for AssignDataFlowOperator {\n@@ -739,9 +734,4 @@ impl DataFlowOperator for AssignDataFlowOperator {\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // moves from both preds are in scope\n     }\n-\n-    #[inline]\n-    fn walk_closures(&self) -> bool {\n-        true\n-    }\n }"}]}