{"sha": "41db9b152f13f8559f4e77dfdc0ef866b4cc0e75", "node_id": "C_kwDOAAsO6NoAKDQxZGI5YjE1MmYxM2Y4NTU5ZjRlNzdkZmRjMGVmODY2YjRjYzBlNzU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-01T07:41:32Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-01T14:18:13Z"}, "message": "Move code to rustc_lint.", "tree": {"sha": "b35a0b3f49e8f1ae5d0f4fd05619714a11dc0417", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b35a0b3f49e8f1ae5d0f4fd05619714a11dc0417"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41db9b152f13f8559f4e77dfdc0ef866b4cc0e75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41db9b152f13f8559f4e77dfdc0ef866b4cc0e75", "html_url": "https://github.com/rust-lang/rust/commit/41db9b152f13f8559f4e77dfdc0ef866b4cc0e75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41db9b152f13f8559f4e77dfdc0ef866b4cc0e75/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "107170b9c3c32263f6d06c888a7feabbc6e095d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/107170b9c3c32263f6d06c888a7feabbc6e095d7", "html_url": "https://github.com/rust-lang/rust/commit/107170b9c3c32263f6d06c888a7feabbc6e095d7"}], "stats": {"total": 258, "additions": 107, "deletions": 151}, "files": [{"sha": "7d8210e03516af8ffb1e813cc761d1d402ec9cf9", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 69, "deletions": 2, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/41db9b152f13f8559f4e77dfdc0ef866b4cc0e75/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41db9b152f13f8559f4e77dfdc0ef866b4cc0e75/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=41db9b152f13f8559f4e77dfdc0ef866b4cc0e75", "patch": "@@ -6,10 +6,11 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::{intravisit, HirId};\n+use rustc_index::vec::IndexVec;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::lint::{\n-    struct_lint_level, LevelAndSource, LintExpectation, LintLevelQueryMap, LintLevelSets,\n-    LintLevelSource, LintSet, LintStackIndex, COMMAND_LINE,\n+    reveal_actual_level, struct_lint_level, LevelAndSource, LintExpectation, LintLevelQueryMap,\n+    LintLevelSource,\n };\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{RegisteredTools, TyCtxt};\n@@ -27,6 +28,72 @@ use crate::errors::{\n     UnknownToolInScopedLint,\n };\n \n+#[derive(Debug)]\n+pub struct LintLevelSets {\n+    pub list: IndexVec<LintStackIndex, LintSet>,\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct LintStackIndex {\n+        ENCODABLE = custom, // we don't need encoding\n+        const COMMAND_LINE = 0,\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct LintSet {\n+    // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n+    // flag.\n+    pub specs: FxHashMap<LintId, LevelAndSource>,\n+\n+    pub parent: LintStackIndex,\n+}\n+\n+impl LintLevelSets {\n+    pub fn new() -> Self {\n+        LintLevelSets { list: IndexVec::new() }\n+    }\n+\n+    fn get_lint_level(\n+        &self,\n+        lint: &'static Lint,\n+        idx: LintStackIndex,\n+        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n+        sess: &Session,\n+    ) -> LevelAndSource {\n+        let lint = LintId::of(lint);\n+        let (level, mut src) = self.get_lint_id_level(lint, idx, aux);\n+        let level = reveal_actual_level(level, &mut src, sess, lint, |id| {\n+            self.get_lint_id_level(id, idx, aux)\n+        });\n+\n+        (level, src)\n+    }\n+\n+    pub fn get_lint_id_level(\n+        &self,\n+        id: LintId,\n+        mut idx: LintStackIndex,\n+        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n+    ) -> (Option<Level>, LintLevelSource) {\n+        if let Some(specs) = aux {\n+            if let Some(&(level, src)) = specs.get(&id) {\n+                return (Some(level), src);\n+            }\n+        }\n+        loop {\n+            let LintSet { ref specs, parent } = self.list[idx];\n+            if let Some(&(level, src)) = specs.get(&id) {\n+                return (Some(level), src);\n+            }\n+            if idx == COMMAND_LINE {\n+                return (None, LintLevelSource::Default);\n+            }\n+            idx = parent;\n+        }\n+    }\n+}\n+\n fn lint_expectations(tcx: TyCtxt<'_>, (): ()) -> Vec<(LintExpectationId, LintExpectation)> {\n     let store = unerased_lint_store(tcx);\n "}, {"sha": "16cf9ea3278c01053e10f07fb2cee1ebead413f6", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 38, "deletions": 149, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/41db9b152f13f8559f4e77dfdc0ef866b4cc0e75/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41db9b152f13f8559f4e77dfdc0ef866b4cc0e75/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=41db9b152f13f8559f4e77dfdc0ef866b4cc0e75", "patch": "@@ -1,14 +1,11 @@\n use std::cmp;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticId, DiagnosticMessage, MultiSpan};\n use rustc_hir::HirId;\n-use rustc_index::vec::IndexVec;\n-use rustc_query_system::ich::StableHashingContext;\n use rustc_session::lint::{\n     builtin::{self, FORBIDDEN_LINT_GROUPS},\n-    FutureIncompatibilityReason, Level, Lint, LintExpectationId, LintId,\n+    FutureIncompatibilityReason, Level, Lint, LintId,\n };\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n@@ -59,159 +56,51 @@ impl LintLevelSource {\n /// A tuple of a lint level and its source.\n pub type LevelAndSource = (Level, LintLevelSource);\n \n-#[derive(Debug, HashStable)]\n-pub struct LintLevelSets {\n-    pub list: IndexVec<LintStackIndex, LintSet>,\n-}\n-\n-rustc_index::newtype_index! {\n-    #[derive(HashStable)]\n-    pub struct LintStackIndex {\n-        const COMMAND_LINE = 0,\n-    }\n-}\n-\n-#[derive(Debug, HashStable)]\n-pub struct LintSet {\n-    // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n-    // flag.\n-    pub specs: FxHashMap<LintId, LevelAndSource>,\n-\n-    pub parent: LintStackIndex,\n-}\n-\n-impl LintLevelSets {\n-    pub fn new() -> Self {\n-        LintLevelSets { list: IndexVec::new() }\n-    }\n-\n-    pub fn actual_level(\n-        level: Option<Level>,\n-        src: &mut LintLevelSource,\n-        sess: &Session,\n-        lint: &'static Lint,\n-        get_lint_id_level: impl FnOnce(LintId) -> (Option<Level>, LintLevelSource),\n-    ) -> Level {\n-        // If `level` is none then we actually assume the default level for this\n-        // lint.\n-        let mut level = level.unwrap_or_else(|| lint.default_level(sess.edition()));\n-\n-        // If we're about to issue a warning, check at the last minute for any\n-        // directives against the warnings \"lint\". If, for example, there's an\n-        // `allow(warnings)` in scope then we want to respect that instead.\n-        //\n-        // We exempt `FORBIDDEN_LINT_GROUPS` from this because it specifically\n-        // triggers in cases (like #80988) where you have `forbid(warnings)`,\n-        // and so if we turned that into an error, it'd defeat the purpose of the\n-        // future compatibility warning.\n-        if level == Level::Warn && LintId::of(lint) != LintId::of(FORBIDDEN_LINT_GROUPS) {\n-            let (warnings_level, warnings_src) = get_lint_id_level(LintId::of(builtin::WARNINGS));\n-            if let Some(configured_warning_level) = warnings_level {\n-                if configured_warning_level != Level::Warn {\n-                    level = configured_warning_level;\n-                    *src = warnings_src;\n-                }\n+pub fn reveal_actual_level(\n+    level: Option<Level>,\n+    src: &mut LintLevelSource,\n+    sess: &Session,\n+    lint: LintId,\n+    get_lint_id_level: impl FnOnce(LintId) -> (Option<Level>, LintLevelSource),\n+) -> Level {\n+    // If `level` is none then we actually assume the default level for this\n+    // lint.\n+    let mut level = level.unwrap_or_else(|| lint.lint.default_level(sess.edition()));\n+\n+    // If we're about to issue a warning, check at the last minute for any\n+    // directives against the warnings \"lint\". If, for example, there's an\n+    // `allow(warnings)` in scope then we want to respect that instead.\n+    //\n+    // We exempt `FORBIDDEN_LINT_GROUPS` from this because it specifically\n+    // triggers in cases (like #80988) where you have `forbid(warnings)`,\n+    // and so if we turned that into an error, it'd defeat the purpose of the\n+    // future compatibility warning.\n+    if level == Level::Warn && lint != LintId::of(FORBIDDEN_LINT_GROUPS) {\n+        let (warnings_level, warnings_src) = get_lint_id_level(LintId::of(builtin::WARNINGS));\n+        if let Some(configured_warning_level) = warnings_level {\n+            if configured_warning_level != Level::Warn {\n+                level = configured_warning_level;\n+                *src = warnings_src;\n             }\n         }\n-\n-        // Ensure that we never exceed the `--cap-lints` argument\n-        // unless the source is a --force-warn\n-        level = if let LintLevelSource::CommandLine(_, Level::ForceWarn(_)) = src {\n-            level\n-        } else {\n-            cmp::min(level, sess.opts.lint_cap.unwrap_or(Level::Forbid))\n-        };\n-\n-        if let Some(driver_level) = sess.driver_lint_caps.get(&LintId::of(lint)) {\n-            // Ensure that we never exceed driver level.\n-            level = cmp::min(*driver_level, level);\n-        }\n-\n-        level\n     }\n \n-    pub fn get_lint_level(\n-        &self,\n-        lint: &'static Lint,\n-        idx: LintStackIndex,\n-        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n-        sess: &Session,\n-    ) -> LevelAndSource {\n-        let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx, aux);\n-\n-        let level = Self::actual_level(level, &mut src, sess, lint, |id| {\n-            self.get_lint_id_level(id, idx, aux)\n-        });\n-\n-        (level, src)\n-    }\n+    // Ensure that we never exceed the `--cap-lints` argument\n+    // unless the source is a --force-warn\n+    level = if let LintLevelSource::CommandLine(_, Level::ForceWarn(_)) = src {\n+        level\n+    } else {\n+        cmp::min(level, sess.opts.lint_cap.unwrap_or(Level::Forbid))\n+    };\n \n-    pub fn get_lint_id_level(\n-        &self,\n-        id: LintId,\n-        mut idx: LintStackIndex,\n-        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n-    ) -> (Option<Level>, LintLevelSource) {\n-        if let Some(specs) = aux {\n-            if let Some(&(level, src)) = specs.get(&id) {\n-                return (Some(level), src);\n-            }\n-        }\n-        loop {\n-            let LintSet { ref specs, parent } = self.list[idx];\n-            if let Some(&(level, src)) = specs.get(&id) {\n-                return (Some(level), src);\n-            }\n-            if idx == COMMAND_LINE {\n-                return (None, LintLevelSource::Default);\n-            }\n-            idx = parent;\n-        }\n+    if let Some(driver_level) = sess.driver_lint_caps.get(&lint) {\n+        // Ensure that we never exceed driver level.\n+        level = cmp::min(*driver_level, level);\n     }\n-}\n-\n-#[derive(Debug)]\n-pub struct LintLevelMap {\n-    /// This is a collection of lint expectations as described in RFC 2383, that\n-    /// can be fulfilled during this compilation session. This means that at least\n-    /// one expected lint is currently registered in the lint store.\n-    ///\n-    /// The [`LintExpectationId`] is stored as a part of the [`Expect`](Level::Expect)\n-    /// lint level.\n-    pub lint_expectations: Vec<(LintExpectationId, LintExpectation)>,\n-    pub sets: LintLevelSets,\n-    pub id_to_set: FxHashMap<HirId, LintStackIndex>,\n-}\n \n-impl LintLevelMap {\n-    /// If the `id` was previously registered with `register_id` when building\n-    /// this `LintLevelMap` this returns the corresponding lint level and source\n-    /// of the lint level for the lint provided.\n-    ///\n-    /// If the `id` was not previously registered, returns `None`. If `None` is\n-    /// returned then the parent of `id` should be acquired and this function\n-    /// should be called again.\n-    pub fn level_and_source(\n-        &self,\n-        lint: &'static Lint,\n-        id: HirId,\n-        session: &Session,\n-    ) -> Option<LevelAndSource> {\n-        self.id_to_set.get(&id).map(|idx| self.sets.get_lint_level(lint, *idx, None, session))\n-    }\n+    level\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let LintLevelMap { ref sets, ref id_to_set, ref lint_expectations } = *self;\n-\n-        id_to_set.hash_stable(hcx, hasher);\n-        lint_expectations.hash_stable(hcx, hasher);\n-\n-        hcx.while_hashing_spans(true, |hcx| sets.hash_stable(hcx, hasher))\n-    }\n-}\n pub struct LintLevelQueryMap<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub cur: HirId,\n@@ -258,7 +147,7 @@ impl<'tcx> LintLevelQueryMap<'tcx> {\n         specs: &FxHashMap<LintId, LevelAndSource>,\n     ) -> (Level, LintLevelSource) {\n         let (level, mut src) = Self::get_lint_id_level(id, cur, tcx, specs);\n-        let level = LintLevelSets::actual_level(level, &mut src, tcx.sess, id.lint, |id| {\n+        let level = reveal_actual_level(level, &mut src, tcx.sess, id, |id| {\n             Self::get_lint_id_level(id, cur, tcx, specs)\n         });\n         (level, src)"}]}