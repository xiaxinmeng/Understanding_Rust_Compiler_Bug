{"sha": "99e2e7075c0e32644498dd0bb64aae9a76ecfbce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZTJlNzA3NWMwZTMyNjQ0NDk4ZGQwYmI2NGFhZTlhNzZlY2ZiY2U=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-09-19T20:51:59Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-09-21T02:00:31Z"}, "message": "Moved all functions prefixed with 'check' to a separate file", "tree": {"sha": "41ca6b7fec181316aa687935b1e981b55b9d01ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41ca6b7fec181316aa687935b1e981b55b9d01ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99e2e7075c0e32644498dd0bb64aae9a76ecfbce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99e2e7075c0e32644498dd0bb64aae9a76ecfbce", "html_url": "https://github.com/rust-lang/rust/commit/99e2e7075c0e32644498dd0bb64aae9a76ecfbce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99e2e7075c0e32644498dd0bb64aae9a76ecfbce/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f896ddfc737d9ba9be22f60e8194986a6dc589ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/f896ddfc737d9ba9be22f60e8194986a6dc589ad", "html_url": "https://github.com/rust-lang/rust/commit/f896ddfc737d9ba9be22f60e8194986a6dc589ad"}], "stats": {"total": 2683, "additions": 1356, "deletions": 1327}, "files": [{"sha": "2daa0354acb0b97465a8d29148ece6e22621037d", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "added", "additions": 1344, "deletions": 0, "changes": 1344, "blob_url": "https://github.com/rust-lang/rust/blob/99e2e7075c0e32644498dd0bb64aae9a76ecfbce/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e2e7075c0e32644498dd0bb64aae9a76ecfbce/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=99e2e7075c0e32644498dd0bb64aae9a76ecfbce", "patch": "@@ -0,0 +1,1344 @@\n+use super::coercion::CoerceMany;\n+use super::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n+use super::*;\n+\n+use rustc_attr as attr;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::lang_items::LangItem;\n+use rustc_hir::{ItemKind, Node};\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::RegionVariableOrigin;\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::util::{Discr, IntTypeExt, Representability};\n+use rustc_middle::ty::{self, RegionKind, ToPredicate, Ty, TyCtxt};\n+use rustc_session::config::EntryFnType;\n+use rustc_span::symbol::sym;\n+use rustc_span::{self, MultiSpan, Span};\n+use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits::{self, ObligationCauseCode};\n+\n+pub fn check_wf_new(tcx: TyCtxt<'_>) {\n+    let visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n+    tcx.hir().krate().par_visit_all_item_likes(&visit);\n+}\n+\n+pub(super) fn check_abi(tcx: TyCtxt<'_>, span: Span, abi: Abi) {\n+    if !tcx.sess.target.target.is_abi_supported(abi) {\n+        struct_span_err!(\n+            tcx.sess,\n+            span,\n+            E0570,\n+            \"The ABI `{}` is not supported for the current target\",\n+            abi\n+        )\n+        .emit()\n+    }\n+}\n+\n+/// Helper used for fns and closures. Does the grungy work of checking a function\n+/// body and returns the function context used for that purpose, since in the case of a fn item\n+/// there is still a bit more to do.\n+///\n+/// * ...\n+/// * inherited: other fields inherited from the enclosing fn (if any)\n+pub(super) fn check_fn<'a, 'tcx>(\n+    inherited: &'a Inherited<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    fn_sig: ty::FnSig<'tcx>,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n+    fn_id: hir::HirId,\n+    body: &'tcx hir::Body<'tcx>,\n+    can_be_generator: Option<hir::Movability>,\n+) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n+    let mut fn_sig = fn_sig;\n+\n+    debug!(\"check_fn(sig={:?}, fn_id={}, param_env={:?})\", fn_sig, fn_id, param_env);\n+\n+    // Create the function context. This is either derived from scratch or,\n+    // in the case of closures, based on the outer context.\n+    let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n+    *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n+\n+    let tcx = fcx.tcx;\n+    let sess = tcx.sess;\n+    let hir = tcx.hir();\n+\n+    let declared_ret_ty = fn_sig.output();\n+\n+    let revealed_ret_ty =\n+        fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty, decl.output.span());\n+    debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n+    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n+    fcx.ret_type_span = Some(decl.output.span());\n+    if let ty::Opaque(..) = declared_ret_ty.kind() {\n+        fcx.ret_coercion_impl_trait = Some(declared_ret_ty);\n+    }\n+    fn_sig = tcx.mk_fn_sig(\n+        fn_sig.inputs().iter().cloned(),\n+        revealed_ret_ty,\n+        fn_sig.c_variadic,\n+        fn_sig.unsafety,\n+        fn_sig.abi,\n+    );\n+\n+    let span = body.value.span;\n+\n+    fn_maybe_err(tcx, span, fn_sig.abi);\n+\n+    if body.generator_kind.is_some() && can_be_generator.is_some() {\n+        let yield_ty = fcx\n+            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n+        fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n+\n+        // Resume type defaults to `()` if the generator has no argument.\n+        let resume_ty = fn_sig.inputs().get(0).copied().unwrap_or_else(|| tcx.mk_unit());\n+\n+        fcx.resume_yield_tys = Some((resume_ty, yield_ty));\n+    }\n+\n+    let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id).to_def_id()).expect_local();\n+    let outer_hir_id = hir.local_def_id_to_hir_id(outer_def_id);\n+    GatherLocalsVisitor::new(&fcx, outer_hir_id).visit_body(body);\n+\n+    // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n+    // (as it's created inside the body itself, not passed in from outside).\n+    let maybe_va_list = if fn_sig.c_variadic {\n+        let span = body.params.last().unwrap().span;\n+        let va_list_did = tcx.require_lang_item(LangItem::VaList, Some(span));\n+        let region = fcx.next_region_var(RegionVariableOrigin::MiscVariable(span));\n+\n+        Some(tcx.type_of(va_list_did).subst(tcx, &[region.into()]))\n+    } else {\n+        None\n+    };\n+\n+    // Add formal parameters.\n+    let inputs_hir = hir.fn_decl_by_hir_id(fn_id).map(|decl| &decl.inputs);\n+    let inputs_fn = fn_sig.inputs().iter().copied();\n+    for (idx, (param_ty, param)) in inputs_fn.chain(maybe_va_list).zip(body.params).enumerate() {\n+        // Check the pattern.\n+        let ty_span = try { inputs_hir?.get(idx)?.span };\n+        fcx.check_pat_top(&param.pat, param_ty, ty_span, false);\n+\n+        // Check that argument is Sized.\n+        // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n+        // for simple cases like `fn foo(x: Trait)`,\n+        // where we would error once on the parameter as a whole, and once on the binding `x`.\n+        if param.pat.simple_ident().is_none() && !tcx.features().unsized_locals {\n+            fcx.require_type_is_sized(param_ty, param.pat.span, traits::SizedArgumentType(ty_span));\n+        }\n+\n+        fcx.write_ty(param.hir_id, param_ty);\n+    }\n+\n+    inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n+\n+    fcx.in_tail_expr = true;\n+    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n+        // FIXME: We need to verify that the return type is `Sized` after the return expression has\n+        // been evaluated so that we have types available for all the nodes being returned, but that\n+        // requires the coerced evaluated type to be stored. Moving `check_return_expr` before this\n+        // causes unsized errors caused by the `declared_ret_ty` to point at the return expression,\n+        // while keeping the current ordering we will ignore the tail expression's type because we\n+        // don't know it yet. We can't do `check_expr_kind` while keeping `check_return_expr`\n+        // because we will trigger \"unreachable expression\" lints unconditionally.\n+        // Because of all of this, we perform a crude check to know whether the simplest `!Sized`\n+        // case that a newcomer might make, returning a bare trait, and in that case we populate\n+        // the tail expression's type so that the suggestion will be correct, but ignore all other\n+        // possible cases.\n+        fcx.check_expr(&body.value);\n+        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+        tcx.sess.delay_span_bug(decl.output.span(), \"`!Sized` return type\");\n+    } else {\n+        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+        fcx.check_return_expr(&body.value);\n+    }\n+    fcx.in_tail_expr = false;\n+\n+    // We insert the deferred_generator_interiors entry after visiting the body.\n+    // This ensures that all nested generators appear before the entry of this generator.\n+    // resolve_generator_interiors relies on this property.\n+    let gen_ty = if let (Some(_), Some(gen_kind)) = (can_be_generator, body.generator_kind) {\n+        let interior = fcx\n+            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::MiscVariable, span });\n+        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior, gen_kind));\n+\n+        let (resume_ty, yield_ty) = fcx.resume_yield_tys.unwrap();\n+        Some(GeneratorTypes {\n+            resume_ty,\n+            yield_ty,\n+            interior,\n+            movability: can_be_generator.unwrap(),\n+        })\n+    } else {\n+        None\n+    };\n+\n+    // Finalize the return check by taking the LUB of the return types\n+    // we saw and assigning it to the expected return type. This isn't\n+    // really expected to fail, since the coercions would have failed\n+    // earlier when trying to find a LUB.\n+    //\n+    // However, the behavior around `!` is sort of complex. In the\n+    // event that the `actual_return_ty` comes back as `!`, that\n+    // indicates that the fn either does not return or \"returns\" only\n+    // values of type `!`. In this case, if there is an expected\n+    // return type that is *not* `!`, that should be ok. But if the\n+    // return type is being inferred, we want to \"fallback\" to `!`:\n+    //\n+    //     let x = move || panic!();\n+    //\n+    // To allow for that, I am creating a type variable with diverging\n+    // fallback. This was deemed ever so slightly better than unifying\n+    // the return value with `!` because it allows for the caller to\n+    // make more assumptions about the return type (e.g., they could do\n+    //\n+    //     let y: Option<u32> = Some(x());\n+    //\n+    // which would then cause this return type to become `u32`, not\n+    // `!`).\n+    let coercion = fcx.ret_coercion.take().unwrap().into_inner();\n+    let mut actual_return_ty = coercion.complete(&fcx);\n+    if actual_return_ty.is_never() {\n+        actual_return_ty = fcx.next_diverging_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::DivergingFn,\n+            span,\n+        });\n+    }\n+    fcx.demand_suptype(span, revealed_ret_ty, actual_return_ty);\n+\n+    // Check that the main return type implements the termination trait.\n+    if let Some(term_id) = tcx.lang_items().termination() {\n+        if let Some((def_id, EntryFnType::Main)) = tcx.entry_fn(LOCAL_CRATE) {\n+            let main_id = hir.local_def_id_to_hir_id(def_id);\n+            if main_id == fn_id {\n+                let substs = tcx.mk_substs_trait(declared_ret_ty, &[]);\n+                let trait_ref = ty::TraitRef::new(term_id, substs);\n+                let return_ty_span = decl.output.span();\n+                let cause = traits::ObligationCause::new(\n+                    return_ty_span,\n+                    fn_id,\n+                    ObligationCauseCode::MainFunctionType,\n+                );\n+\n+                inherited.register_predicate(traits::Obligation::new(\n+                    cause,\n+                    param_env,\n+                    trait_ref.without_const().to_predicate(tcx),\n+                ));\n+            }\n+        }\n+    }\n+\n+    // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n+    if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n+        if panic_impl_did == hir.local_def_id(fn_id).to_def_id() {\n+            if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n+                if *declared_ret_ty.kind() != ty::Never {\n+                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n+                }\n+\n+                let inputs = fn_sig.inputs();\n+                let span = hir.span(fn_id);\n+                if inputs.len() == 1 {\n+                    let arg_is_panic_info = match *inputs[0].kind() {\n+                        ty::Ref(region, ty, mutbl) => match *ty.kind() {\n+                            ty::Adt(ref adt, _) => {\n+                                adt.did == panic_info_did\n+                                    && mutbl == hir::Mutability::Not\n+                                    && *region != RegionKind::ReStatic\n+                            }\n+                            _ => false,\n+                        },\n+                        _ => false,\n+                    };\n+\n+                    if !arg_is_panic_info {\n+                        sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n+                    }\n+\n+                    if let Node::Item(item) = hir.get(fn_id) {\n+                        if let ItemKind::Fn(_, ref generics, _) = item.kind {\n+                            if !generics.params.is_empty() {\n+                                sess.span_err(span, \"should have no type parameters\");\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    let span = sess.source_map().guess_head_span(span);\n+                    sess.span_err(span, \"function should have one argument\");\n+                }\n+            } else {\n+                sess.err(\"language item required, but not found: `panic_info`\");\n+            }\n+        }\n+    }\n+\n+    // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n+    if let Some(alloc_error_handler_did) = tcx.lang_items().oom() {\n+        if alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id() {\n+            if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n+                if *declared_ret_ty.kind() != ty::Never {\n+                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n+                }\n+\n+                let inputs = fn_sig.inputs();\n+                let span = hir.span(fn_id);\n+                if inputs.len() == 1 {\n+                    let arg_is_alloc_layout = match inputs[0].kind() {\n+                        ty::Adt(ref adt, _) => adt.did == alloc_layout_did,\n+                        _ => false,\n+                    };\n+\n+                    if !arg_is_alloc_layout {\n+                        sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n+                    }\n+\n+                    if let Node::Item(item) = hir.get(fn_id) {\n+                        if let ItemKind::Fn(_, ref generics, _) = item.kind {\n+                            if !generics.params.is_empty() {\n+                                sess.span_err(\n+                                    span,\n+                                    \"`#[alloc_error_handler]` function should have no type \\\n+                                     parameters\",\n+                                );\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    let span = sess.source_map().guess_head_span(span);\n+                    sess.span_err(span, \"function should have one argument\");\n+                }\n+            } else {\n+                sess.err(\"language item required, but not found: `alloc_layout`\");\n+            }\n+        }\n+    }\n+\n+    (fcx, gen_ty)\n+}\n+\n+pub(super) fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n+    let def_id = tcx.hir().local_def_id(id);\n+    let def = tcx.adt_def(def_id);\n+    def.destructor(tcx); // force the destructor to be evaluated\n+    check_representable(tcx, span, def_id);\n+\n+    if def.repr.simd() {\n+        check_simd(tcx, span, def_id);\n+    }\n+\n+    check_transparent(tcx, span, def);\n+    check_packed(tcx, span, def);\n+}\n+\n+pub(super) fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n+    let def_id = tcx.hir().local_def_id(id);\n+    let def = tcx.adt_def(def_id);\n+    def.destructor(tcx); // force the destructor to be evaluated\n+    check_representable(tcx, span, def_id);\n+    check_transparent(tcx, span, def);\n+    check_union_fields(tcx, span, def_id);\n+    check_packed(tcx, span, def);\n+}\n+\n+/// When the `#![feature(untagged_unions)]` gate is active,\n+/// check that the fields of the `union` does not contain fields that need dropping.\n+pub(super) fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> bool {\n+    let item_type = tcx.type_of(item_def_id);\n+    if let ty::Adt(def, substs) = item_type.kind() {\n+        assert!(def.is_union());\n+        let fields = &def.non_enum_variant().fields;\n+        let param_env = tcx.param_env(item_def_id);\n+        for field in fields {\n+            let field_ty = field.ty(tcx, substs);\n+            // We are currently checking the type this field came from, so it must be local.\n+            let field_span = tcx.hir().span_if_local(field.did).unwrap();\n+            if field_ty.needs_drop(tcx, param_env) {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    field_span,\n+                    E0740,\n+                    \"unions may not contain fields that need dropping\"\n+                )\n+                .span_note(field_span, \"`std::mem::ManuallyDrop` can be used to wrap the type\")\n+                .emit();\n+                return false;\n+            }\n+        }\n+    } else {\n+        span_bug!(span, \"unions must be ty::Adt, but got {:?}\", item_type.kind());\n+    }\n+    true\n+}\n+\n+/// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n+/// projections that would result in \"inheriting lifetimes\".\n+pub(super) fn check_opaque<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+    substs: SubstsRef<'tcx>,\n+    span: Span,\n+    origin: &hir::OpaqueTyOrigin,\n+) {\n+    check_opaque_for_inheriting_lifetimes(tcx, def_id, span);\n+    check_opaque_for_cycles(tcx, def_id, substs, span, origin);\n+}\n+\n+/// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n+/// in \"inheriting lifetimes\".\n+pub(super) fn check_opaque_for_inheriting_lifetimes(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+    span: Span,\n+) {\n+    let item = tcx.hir().expect_item(tcx.hir().local_def_id_to_hir_id(def_id));\n+    debug!(\n+        \"check_opaque_for_inheriting_lifetimes: def_id={:?} span={:?} item={:?}\",\n+        def_id, span, item\n+    );\n+\n+    #[derive(Debug)]\n+    struct ProhibitOpaqueVisitor<'tcx> {\n+        opaque_identity_ty: Ty<'tcx>,\n+        generics: &'tcx ty::Generics,\n+        ty: Option<Ty<'tcx>>,\n+    };\n+\n+    impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n+            if t != self.opaque_identity_ty && t.super_visit_with(self) {\n+                self.ty = Some(t);\n+                return true;\n+            }\n+            false\n+        }\n+\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_region) r={:?}\", r);\n+            if let RegionKind::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = r {\n+                return *index < self.generics.parent_count as u32;\n+            }\n+\n+            r.super_visit_with(self)\n+        }\n+\n+        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+            if let ty::ConstKind::Unevaluated(..) = c.val {\n+                // FIXME(#72219) We currenctly don't detect lifetimes within substs\n+                // which would violate this check. Even though the particular substitution is not used\n+                // within the const, this should still be fixed.\n+                return false;\n+            }\n+            c.super_visit_with(self)\n+        }\n+    }\n+\n+    if let ItemKind::OpaqueTy(hir::OpaqueTy {\n+        origin: hir::OpaqueTyOrigin::AsyncFn | hir::OpaqueTyOrigin::FnReturn,\n+        ..\n+    }) = item.kind\n+    {\n+        let mut visitor = ProhibitOpaqueVisitor {\n+            opaque_identity_ty: tcx.mk_opaque(\n+                def_id.to_def_id(),\n+                InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n+            ),\n+            generics: tcx.generics_of(def_id),\n+            ty: None,\n+        };\n+        let prohibit_opaque = tcx\n+            .predicates_of(def_id)\n+            .predicates\n+            .iter()\n+            .any(|(predicate, _)| predicate.visit_with(&mut visitor));\n+        debug!(\n+            \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor={:?}\",\n+            prohibit_opaque, visitor\n+        );\n+\n+        if prohibit_opaque {\n+            let is_async = match item.kind {\n+                ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => match origin {\n+                    hir::OpaqueTyOrigin::AsyncFn => true,\n+                    _ => false,\n+                },\n+                _ => unreachable!(),\n+            };\n+\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0760,\n+                \"`{}` return type cannot contain a projection or `Self` that references lifetimes from \\\n+             a parent scope\",\n+                if is_async { \"async fn\" } else { \"impl Trait\" },\n+            );\n+\n+            if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(span) {\n+                if snippet == \"Self\" {\n+                    if let Some(ty) = visitor.ty {\n+                        err.span_suggestion(\n+                            span,\n+                            \"consider spelling out the type instead\",\n+                            format!(\"{:?}\", ty),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+            err.emit();\n+        }\n+    }\n+}\n+\n+/// Checks that an opaque type does not contain cycles.\n+pub(super) fn check_opaque_for_cycles<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+    substs: SubstsRef<'tcx>,\n+    span: Span,\n+    origin: &hir::OpaqueTyOrigin,\n+) {\n+    if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id.to_def_id(), substs)\n+    {\n+        match origin {\n+            hir::OpaqueTyOrigin::AsyncFn => async_opaque_type_cycle_error(tcx, span),\n+            hir::OpaqueTyOrigin::Binding => {\n+                binding_opaque_type_cycle_error(tcx, def_id, span, partially_expanded_type)\n+            }\n+            _ => opaque_type_cycle_error(tcx, def_id, span),\n+        }\n+    }\n+}\n+\n+pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n+    debug!(\n+        \"check_item_type(it.hir_id={}, it.name={})\",\n+        it.hir_id,\n+        tcx.def_path_str(tcx.hir().local_def_id(it.hir_id).to_def_id())\n+    );\n+    let _indenter = indenter();\n+    match it.kind {\n+        // Consts can play a role in type-checking, so they are included here.\n+        hir::ItemKind::Static(..) => {\n+            let def_id = tcx.hir().local_def_id(it.hir_id);\n+            tcx.ensure().typeck(def_id);\n+            maybe_check_static_with_link_section(tcx, def_id, it.span);\n+        }\n+        hir::ItemKind::Const(..) => {\n+            tcx.ensure().typeck(tcx.hir().local_def_id(it.hir_id));\n+        }\n+        hir::ItemKind::Enum(ref enum_definition, _) => {\n+            check_enum(tcx, it.span, &enum_definition.variants, it.hir_id);\n+        }\n+        hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n+        hir::ItemKind::Impl { ref items, .. } => {\n+            debug!(\"ItemKind::Impl {} with id {}\", it.ident, it.hir_id);\n+            let impl_def_id = tcx.hir().local_def_id(it.hir_id);\n+            if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n+                check_impl_items_against_trait(tcx, it.span, impl_def_id, impl_trait_ref, items);\n+                let trait_def_id = impl_trait_ref.def_id;\n+                check_on_unimplemented(tcx, trait_def_id, it);\n+            }\n+        }\n+        hir::ItemKind::Trait(_, _, _, _, ref items) => {\n+            let def_id = tcx.hir().local_def_id(it.hir_id);\n+            check_on_unimplemented(tcx, def_id.to_def_id(), it);\n+\n+            for item in items.iter() {\n+                let item = tcx.hir().trait_item(item.id);\n+                if let hir::TraitItemKind::Fn(sig, _) = &item.kind {\n+                    let abi = sig.header.abi;\n+                    fn_maybe_err(tcx, item.ident.span, abi);\n+                }\n+            }\n+        }\n+        hir::ItemKind::Struct(..) => {\n+            check_struct(tcx, it.hir_id, it.span);\n+        }\n+        hir::ItemKind::Union(..) => {\n+            check_union(tcx, it.hir_id, it.span);\n+        }\n+        hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n+            // HACK(jynelson): trying to infer the type of `impl trait` breaks documenting\n+            // `async-std` (and `pub async fn` in general).\n+            // Since rustdoc doesn't care about the concrete type behind `impl Trait`, just don't look at it!\n+            // See https://github.com/rust-lang/rust/issues/75100\n+            if !tcx.sess.opts.actually_rustdoc {\n+                let def_id = tcx.hir().local_def_id(it.hir_id);\n+\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                check_opaque(tcx, def_id, substs, it.span, &origin);\n+            }\n+        }\n+        hir::ItemKind::TyAlias(..) => {\n+            let def_id = tcx.hir().local_def_id(it.hir_id);\n+            let pty_ty = tcx.type_of(def_id);\n+            let generics = tcx.generics_of(def_id);\n+            check_type_params_are_used(tcx, &generics, pty_ty);\n+        }\n+        hir::ItemKind::ForeignMod(ref m) => {\n+            check_abi(tcx, it.span, m.abi);\n+\n+            if m.abi == Abi::RustIntrinsic {\n+                for item in m.items {\n+                    intrinsic::check_intrinsic_type(tcx, item);\n+                }\n+            } else if m.abi == Abi::PlatformIntrinsic {\n+                for item in m.items {\n+                    intrinsic::check_platform_intrinsic_type(tcx, item);\n+                }\n+            } else {\n+                for item in m.items {\n+                    let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n+                    let own_counts = generics.own_counts();\n+                    if generics.params.len() - own_counts.lifetimes != 0 {\n+                        let (kinds, kinds_pl, egs) = match (own_counts.types, own_counts.consts) {\n+                            (_, 0) => (\"type\", \"types\", Some(\"u32\")),\n+                            // We don't specify an example value, because we can't generate\n+                            // a valid value for any type.\n+                            (0, _) => (\"const\", \"consts\", None),\n+                            _ => (\"type or const\", \"types or consts\", None),\n+                        };\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            item.span,\n+                            E0044,\n+                            \"foreign items may not have {} parameters\",\n+                            kinds,\n+                        )\n+                        .span_label(item.span, &format!(\"can't have {} parameters\", kinds))\n+                        .help(\n+                            // FIXME: once we start storing spans for type arguments, turn this\n+                            // into a suggestion.\n+                            &format!(\n+                                \"replace the {} parameters with concrete {}{}\",\n+                                kinds,\n+                                kinds_pl,\n+                                egs.map(|egs| format!(\" like `{}`\", egs)).unwrap_or_default(),\n+                            ),\n+                        )\n+                        .emit();\n+                    }\n+\n+                    if let hir::ForeignItemKind::Fn(ref fn_decl, _, _) = item.kind {\n+                        require_c_abi_if_c_variadic(tcx, fn_decl, m.abi, item.span);\n+                    }\n+                }\n+            }\n+        }\n+        _ => { /* nothing to do */ }\n+    }\n+}\n+\n+pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, trait_def_id: DefId, item: &hir::Item<'_>) {\n+    let item_def_id = tcx.hir().local_def_id(item.hir_id);\n+    // an error would be reported if this fails.\n+    let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id.to_def_id());\n+}\n+\n+pub(super) fn check_specialization_validity<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_def: &ty::TraitDef,\n+    trait_item: &ty::AssocItem,\n+    impl_id: DefId,\n+    impl_item: &hir::ImplItem<'_>,\n+) {\n+    let kind = match impl_item.kind {\n+        hir::ImplItemKind::Const(..) => ty::AssocKind::Const,\n+        hir::ImplItemKind::Fn(..) => ty::AssocKind::Fn,\n+        hir::ImplItemKind::TyAlias(_) => ty::AssocKind::Type,\n+    };\n+\n+    let ancestors = match trait_def.ancestors(tcx, impl_id) {\n+        Ok(ancestors) => ancestors,\n+        Err(_) => return,\n+    };\n+    let mut ancestor_impls = ancestors\n+        .skip(1)\n+        .filter_map(|parent| {\n+            if parent.is_from_trait() {\n+                None\n+            } else {\n+                Some((parent, parent.item(tcx, trait_item.ident, kind, trait_def.def_id)))\n+            }\n+        })\n+        .peekable();\n+\n+    if ancestor_impls.peek().is_none() {\n+        // No parent, nothing to specialize.\n+        return;\n+    }\n+\n+    let opt_result = ancestor_impls.find_map(|(parent_impl, parent_item)| {\n+        match parent_item {\n+            // Parent impl exists, and contains the parent item we're trying to specialize, but\n+            // doesn't mark it `default`.\n+            Some(parent_item) if traits::impl_item_is_final(tcx, &parent_item) => {\n+                Some(Err(parent_impl.def_id()))\n+            }\n+\n+            // Parent impl contains item and makes it specializable.\n+            Some(_) => Some(Ok(())),\n+\n+            // Parent impl doesn't mention the item. This means it's inherited from the\n+            // grandparent. In that case, if parent is a `default impl`, inherited items use the\n+            // \"defaultness\" from the grandparent, else they are final.\n+            None => {\n+                if tcx.impl_defaultness(parent_impl.def_id()).is_default() {\n+                    None\n+                } else {\n+                    Some(Err(parent_impl.def_id()))\n+                }\n+            }\n+        }\n+    });\n+\n+    // If `opt_result` is `None`, we have only encountered `default impl`s that don't contain the\n+    // item. This is allowed, the item isn't actually getting specialized here.\n+    let result = opt_result.unwrap_or(Ok(()));\n+\n+    if let Err(parent_impl) = result {\n+        report_forbidden_specialization(tcx, impl_item, parent_impl);\n+    }\n+}\n+\n+pub(super) fn check_impl_items_against_trait<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    full_impl_span: Span,\n+    impl_id: LocalDefId,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    impl_item_refs: &[hir::ImplItemRef<'_>],\n+) {\n+    let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n+\n+    // If the trait reference itself is erroneous (so the compilation is going\n+    // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n+    // isn't populated for such impls.\n+    if impl_trait_ref.references_error() {\n+        return;\n+    }\n+\n+    // Negative impls are not expected to have any items\n+    match tcx.impl_polarity(impl_id) {\n+        ty::ImplPolarity::Reservation | ty::ImplPolarity::Positive => {}\n+        ty::ImplPolarity::Negative => {\n+            if let [first_item_ref, ..] = impl_item_refs {\n+                let first_item_span = tcx.hir().impl_item(first_item_ref.id).span;\n+                struct_span_err!(\n+                    tcx.sess,\n+                    first_item_span,\n+                    E0749,\n+                    \"negative impls cannot have any items\"\n+                )\n+                .emit();\n+            }\n+            return;\n+        }\n+    }\n+\n+    // Locate trait definition and items\n+    let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n+\n+    let impl_items = || impl_item_refs.iter().map(|iiref| tcx.hir().impl_item(iiref.id));\n+\n+    // Check existing impl methods to see if they are both present in trait\n+    // and compatible with trait signature\n+    for impl_item in impl_items() {\n+        let namespace = impl_item.kind.namespace();\n+        let ty_impl_item = tcx.associated_item(tcx.hir().local_def_id(impl_item.hir_id));\n+        let ty_trait_item = tcx\n+            .associated_items(impl_trait_ref.def_id)\n+            .find_by_name_and_namespace(tcx, ty_impl_item.ident, namespace, impl_trait_ref.def_id)\n+            .or_else(|| {\n+                // Not compatible, but needed for the error message\n+                tcx.associated_items(impl_trait_ref.def_id)\n+                    .filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id)\n+                    .next()\n+            });\n+\n+        // Check that impl definition matches trait definition\n+        if let Some(ty_trait_item) = ty_trait_item {\n+            match impl_item.kind {\n+                hir::ImplItemKind::Const(..) => {\n+                    // Find associated const definition.\n+                    if ty_trait_item.kind == ty::AssocKind::Const {\n+                        compare_const_impl(\n+                            tcx,\n+                            &ty_impl_item,\n+                            impl_item.span,\n+                            &ty_trait_item,\n+                            impl_trait_ref,\n+                        );\n+                    } else {\n+                        let mut err = struct_span_err!(\n+                            tcx.sess,\n+                            impl_item.span,\n+                            E0323,\n+                            \"item `{}` is an associated const, \\\n+                             which doesn't match its trait `{}`\",\n+                            ty_impl_item.ident,\n+                            impl_trait_ref.print_only_trait_path()\n+                        );\n+                        err.span_label(impl_item.span, \"does not match trait\");\n+                        // We can only get the spans from local trait definition\n+                        // Same for E0324 and E0325\n+                        if let Some(trait_span) = tcx.hir().span_if_local(ty_trait_item.def_id) {\n+                            err.span_label(trait_span, \"item in trait\");\n+                        }\n+                        err.emit()\n+                    }\n+                }\n+                hir::ImplItemKind::Fn(..) => {\n+                    let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n+                    if ty_trait_item.kind == ty::AssocKind::Fn {\n+                        compare_impl_method(\n+                            tcx,\n+                            &ty_impl_item,\n+                            impl_item.span,\n+                            &ty_trait_item,\n+                            impl_trait_ref,\n+                            opt_trait_span,\n+                        );\n+                    } else {\n+                        let mut err = struct_span_err!(\n+                            tcx.sess,\n+                            impl_item.span,\n+                            E0324,\n+                            \"item `{}` is an associated method, \\\n+                             which doesn't match its trait `{}`\",\n+                            ty_impl_item.ident,\n+                            impl_trait_ref.print_only_trait_path()\n+                        );\n+                        err.span_label(impl_item.span, \"does not match trait\");\n+                        if let Some(trait_span) = opt_trait_span {\n+                            err.span_label(trait_span, \"item in trait\");\n+                        }\n+                        err.emit()\n+                    }\n+                }\n+                hir::ImplItemKind::TyAlias(_) => {\n+                    let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n+                    if ty_trait_item.kind == ty::AssocKind::Type {\n+                        compare_ty_impl(\n+                            tcx,\n+                            &ty_impl_item,\n+                            impl_item.span,\n+                            &ty_trait_item,\n+                            impl_trait_ref,\n+                            opt_trait_span,\n+                        );\n+                    } else {\n+                        let mut err = struct_span_err!(\n+                            tcx.sess,\n+                            impl_item.span,\n+                            E0325,\n+                            \"item `{}` is an associated type, \\\n+                             which doesn't match its trait `{}`\",\n+                            ty_impl_item.ident,\n+                            impl_trait_ref.print_only_trait_path()\n+                        );\n+                        err.span_label(impl_item.span, \"does not match trait\");\n+                        if let Some(trait_span) = opt_trait_span {\n+                            err.span_label(trait_span, \"item in trait\");\n+                        }\n+                        err.emit()\n+                    }\n+                }\n+            }\n+\n+            check_specialization_validity(\n+                tcx,\n+                trait_def,\n+                &ty_trait_item,\n+                impl_id.to_def_id(),\n+                impl_item,\n+            );\n+        }\n+    }\n+\n+    // Check for missing items from trait\n+    let mut missing_items = Vec::new();\n+    if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id.to_def_id()) {\n+        for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n+            let is_implemented = ancestors\n+                .leaf_def(tcx, trait_item.ident, trait_item.kind)\n+                .map(|node_item| !node_item.defining_node.is_from_trait())\n+                .unwrap_or(false);\n+\n+            if !is_implemented && tcx.impl_defaultness(impl_id).is_final() {\n+                if !trait_item.defaultness.has_value() {\n+                    missing_items.push(*trait_item);\n+                }\n+            }\n+        }\n+    }\n+\n+    if !missing_items.is_empty() {\n+        missing_items_err(tcx, impl_span, &missing_items, full_impl_span);\n+    }\n+}\n+\n+/// Checks whether a type can be represented in memory. In particular, it\n+/// identifies types that contain themselves without indirection through a\n+/// pointer, which would mean their size is unbounded.\n+pub(super) fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalDefId) -> bool {\n+    let rty = tcx.type_of(item_def_id);\n+\n+    // Check that it is possible to represent this type. This call identifies\n+    // (1) types that contain themselves and (2) types that contain a different\n+    // recursive type. It is only necessary to throw an error on those that\n+    // contain themselves. For case 2, there must be an inner type that will be\n+    // caught by case 1.\n+    match rty.is_representable(tcx, sp) {\n+        Representability::SelfRecursive(spans) => {\n+            recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id(), spans);\n+            return false;\n+        }\n+        Representability::Representable | Representability::ContainsRecursive => (),\n+    }\n+    true\n+}\n+\n+pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n+    let t = tcx.type_of(def_id);\n+    if let ty::Adt(def, substs) = t.kind() {\n+        if def.is_struct() {\n+            let fields = &def.non_enum_variant().fields;\n+            if fields.is_empty() {\n+                struct_span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\").emit();\n+                return;\n+            }\n+            let e = fields[0].ty(tcx, substs);\n+            if !fields.iter().all(|f| f.ty(tcx, substs) == e) {\n+                struct_span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\")\n+                    .span_label(sp, \"SIMD elements must have the same type\")\n+                    .emit();\n+                return;\n+            }\n+            match e.kind() {\n+                ty::Param(_) => { /* struct<T>(T, T, T, T) is ok */ }\n+                _ if e.is_machine() => { /* struct(u8, u8, u8, u8) is ok */ }\n+                _ => {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        sp,\n+                        E0077,\n+                        \"SIMD vector element type should be machine type\"\n+                    )\n+                    .emit();\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n+    let repr = def.repr;\n+    if repr.packed() {\n+        for attr in tcx.get_attrs(def.did).iter() {\n+            for r in attr::find_repr_attrs(&tcx.sess, attr) {\n+                if let attr::ReprPacked(pack) = r {\n+                    if let Some(repr_pack) = repr.pack {\n+                        if pack as u64 != repr_pack.bytes() {\n+                            struct_span_err!(\n+                                tcx.sess,\n+                                sp,\n+                                E0634,\n+                                \"type has conflicting packed representation hints\"\n+                            )\n+                            .emit();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if repr.align.is_some() {\n+            struct_span_err!(\n+                tcx.sess,\n+                sp,\n+                E0587,\n+                \"type has conflicting packed and align representation hints\"\n+            )\n+            .emit();\n+        } else {\n+            if let Some(def_spans) = check_packed_inner(tcx, def.did, &mut vec![]) {\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    sp,\n+                    E0588,\n+                    \"packed type cannot transitively contain a `#[repr(align)]` type\"\n+                );\n+\n+                err.span_note(\n+                    tcx.def_span(def_spans[0].0),\n+                    &format!(\n+                        \"`{}` has a `#[repr(align)]` attribute\",\n+                        tcx.item_name(def_spans[0].0)\n+                    ),\n+                );\n+\n+                if def_spans.len() > 2 {\n+                    let mut first = true;\n+                    for (adt_def, span) in def_spans.iter().skip(1).rev() {\n+                        let ident = tcx.item_name(*adt_def);\n+                        err.span_note(\n+                            *span,\n+                            &if first {\n+                                format!(\n+                                    \"`{}` contains a field of type `{}`\",\n+                                    tcx.type_of(def.did),\n+                                    ident\n+                                )\n+                            } else {\n+                                format!(\"...which contains a field of type `{}`\", ident)\n+                            },\n+                        );\n+                        first = false;\n+                    }\n+                }\n+\n+                err.emit();\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn check_packed_inner(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+    stack: &mut Vec<DefId>,\n+) -> Option<Vec<(DefId, Span)>> {\n+    if let ty::Adt(def, substs) = tcx.type_of(def_id).kind() {\n+        if def.is_struct() || def.is_union() {\n+            if def.repr.align.is_some() {\n+                return Some(vec![(def.did, DUMMY_SP)]);\n+            }\n+\n+            stack.push(def_id);\n+            for field in &def.non_enum_variant().fields {\n+                if let ty::Adt(def, _) = field.ty(tcx, substs).kind() {\n+                    if !stack.contains(&def.did) {\n+                        if let Some(mut defs) = check_packed_inner(tcx, def.did, stack) {\n+                            defs.push((def.did, field.ident.span));\n+                            return Some(defs);\n+                        }\n+                    }\n+                }\n+            }\n+            stack.pop();\n+        }\n+    }\n+\n+    None\n+}\n+\n+pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: &'tcx ty::AdtDef) {\n+    if !adt.repr.transparent() {\n+        return;\n+    }\n+    let sp = tcx.sess.source_map().guess_head_span(sp);\n+\n+    if adt.is_union() && !tcx.features().transparent_unions {\n+        feature_err(\n+            &tcx.sess.parse_sess,\n+            sym::transparent_unions,\n+            sp,\n+            \"transparent unions are unstable\",\n+        )\n+        .emit();\n+    }\n+\n+    if adt.variants.len() != 1 {\n+        bad_variant_count(tcx, adt, sp, adt.did);\n+        if adt.variants.is_empty() {\n+            // Don't bother checking the fields. No variants (and thus no fields) exist.\n+            return;\n+        }\n+    }\n+\n+    // For each field, figure out if it's known to be a ZST and align(1)\n+    let field_infos = adt.all_fields().map(|field| {\n+        let ty = field.ty(tcx, InternalSubsts::identity_for_item(tcx, field.did));\n+        let param_env = tcx.param_env(field.did);\n+        let layout = tcx.layout_of(param_env.and(ty));\n+        // We are currently checking the type this field came from, so it must be local\n+        let span = tcx.hir().span_if_local(field.did).unwrap();\n+        let zst = layout.map(|layout| layout.is_zst()).unwrap_or(false);\n+        let align1 = layout.map(|layout| layout.align.abi.bytes() == 1).unwrap_or(false);\n+        (span, zst, align1)\n+    });\n+\n+    let non_zst_fields =\n+        field_infos.clone().filter_map(|(span, zst, _align1)| if !zst { Some(span) } else { None });\n+    let non_zst_count = non_zst_fields.clone().count();\n+    if non_zst_count != 1 {\n+        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, sp);\n+    }\n+    for (span, zst, align1) in field_infos {\n+        if zst && !align1 {\n+            struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0691,\n+                \"zero-sized field in transparent {} has alignment larger than 1\",\n+                adt.descr(),\n+            )\n+            .span_label(span, \"has alignment larger than 1\")\n+            .emit();\n+        }\n+    }\n+}\n+\n+#[allow(trivial_numeric_casts)]\n+pub fn check_enum<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sp: Span,\n+    vs: &'tcx [hir::Variant<'tcx>],\n+    id: hir::HirId,\n+) {\n+    let def_id = tcx.hir().local_def_id(id);\n+    let def = tcx.adt_def(def_id);\n+    def.destructor(tcx); // force the destructor to be evaluated\n+\n+    if vs.is_empty() {\n+        let attributes = tcx.get_attrs(def_id.to_def_id());\n+        if let Some(attr) = tcx.sess.find_by_name(&attributes, sym::repr) {\n+            struct_span_err!(\n+                tcx.sess,\n+                attr.span,\n+                E0084,\n+                \"unsupported representation for zero-variant enum\"\n+            )\n+            .span_label(sp, \"zero-variant enum\")\n+            .emit();\n+        }\n+    }\n+\n+    let repr_type_ty = def.repr.discr_type().to_ty(tcx);\n+    if repr_type_ty == tcx.types.i128 || repr_type_ty == tcx.types.u128 {\n+        if !tcx.features().repr128 {\n+            feature_err(\n+                &tcx.sess.parse_sess,\n+                sym::repr128,\n+                sp,\n+                \"repr with 128-bit type is unstable\",\n+            )\n+            .emit();\n+        }\n+    }\n+\n+    for v in vs {\n+        if let Some(ref e) = v.disr_expr {\n+            tcx.ensure().typeck(tcx.hir().local_def_id(e.hir_id));\n+        }\n+    }\n+\n+    if tcx.adt_def(def_id).repr.int.is_none() && tcx.features().arbitrary_enum_discriminant {\n+        let is_unit = |var: &hir::Variant<'_>| match var.data {\n+            hir::VariantData::Unit(..) => true,\n+            _ => false,\n+        };\n+\n+        let has_disr = |var: &hir::Variant<'_>| var.disr_expr.is_some();\n+        let has_non_units = vs.iter().any(|var| !is_unit(var));\n+        let disr_units = vs.iter().any(|var| is_unit(&var) && has_disr(&var));\n+        let disr_non_unit = vs.iter().any(|var| !is_unit(&var) && has_disr(&var));\n+\n+        if disr_non_unit || (disr_units && has_non_units) {\n+            let mut err =\n+                struct_span_err!(tcx.sess, sp, E0732, \"`#[repr(inttype)]` must be specified\");\n+            err.emit();\n+        }\n+    }\n+\n+    let mut disr_vals: Vec<Discr<'tcx>> = Vec::with_capacity(vs.len());\n+    for ((_, discr), v) in def.discriminants(tcx).zip(vs) {\n+        // Check for duplicate discriminant values\n+        if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n+            let variant_did = def.variants[VariantIdx::new(i)].def_id;\n+            let variant_i_hir_id = tcx.hir().local_def_id_to_hir_id(variant_did.expect_local());\n+            let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n+            let i_span = match variant_i.disr_expr {\n+                Some(ref expr) => tcx.hir().span(expr.hir_id),\n+                None => tcx.hir().span(variant_i_hir_id),\n+            };\n+            let span = match v.disr_expr {\n+                Some(ref expr) => tcx.hir().span(expr.hir_id),\n+                None => v.span,\n+            };\n+            struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0081,\n+                \"discriminant value `{}` already exists\",\n+                disr_vals[i]\n+            )\n+            .span_label(i_span, format!(\"first use of `{}`\", disr_vals[i]))\n+            .span_label(span, format!(\"enum already has `{}`\", disr_vals[i]))\n+            .emit();\n+        }\n+        disr_vals.push(discr);\n+    }\n+\n+    check_representable(tcx, sp, def_id);\n+    check_transparent(tcx, sp, def);\n+}\n+\n+pub(super) fn check_type_params_are_used<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    generics: &ty::Generics,\n+    ty: Ty<'tcx>,\n+) {\n+    debug!(\"check_type_params_are_used(generics={:?}, ty={:?})\", generics, ty);\n+\n+    assert_eq!(generics.parent, None);\n+\n+    if generics.own_counts().types == 0 {\n+        return;\n+    }\n+\n+    let mut params_used = BitSet::new_empty(generics.params.len());\n+\n+    if ty.references_error() {\n+        // If there is already another error, do not emit\n+        // an error for not using a type parameter.\n+        assert!(tcx.sess.has_errors());\n+        return;\n+    }\n+\n+    for leaf in ty.walk() {\n+        if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n+            if let ty::Param(param) = leaf_ty.kind() {\n+                debug!(\"found use of ty param {:?}\", param);\n+                params_used.insert(param.index);\n+            }\n+        }\n+    }\n+\n+    for param in &generics.params {\n+        if !params_used.contains(param.index) {\n+            if let ty::GenericParamDefKind::Type { .. } = param.kind {\n+                let span = tcx.def_span(param.def_id);\n+                struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0091,\n+                    \"type parameter `{}` is unused\",\n+                    param.name,\n+                )\n+                .span_label(span, \"unused type parameter\")\n+                .emit();\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n+    tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckItemTypesVisitor { tcx });\n+}\n+\n+pub(super) fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    wfcheck::check_item_well_formed(tcx, def_id);\n+}\n+\n+pub(super) fn check_trait_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    wfcheck::check_trait_item(tcx, def_id);\n+}\n+\n+pub(super) fn check_impl_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    wfcheck::check_impl_item(tcx, def_id);\n+}\n+\n+fn async_opaque_type_cycle_error(tcx: TyCtxt<'tcx>, span: Span) {\n+    struct_span_err!(tcx.sess, span, E0733, \"recursion in an `async fn` requires boxing\")\n+        .span_label(span, \"recursive `async fn`\")\n+        .note(\"a recursive `async fn` must be rewritten to return a boxed `dyn Future`\")\n+        .emit();\n+}\n+\n+/// Emit an error for recursive opaque types.\n+///\n+/// If this is a return `impl Trait`, find the item's return expressions and point at them. For\n+/// direct recursion this is enough, but for indirect recursion also point at the last intermediary\n+/// `impl Trait`.\n+///\n+/// If all the return expressions evaluate to `!`, then we explain that the error will go away\n+/// after changing it. This can happen when a user uses `panic!()` or similar as a placeholder.\n+fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n+    let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n+\n+    let mut label = false;\n+    if let Some((hir_id, visitor)) = get_owner_return_paths(tcx, def_id) {\n+        let typeck_results = tcx.typeck(tcx.hir().local_def_id(hir_id));\n+        if visitor\n+            .returns\n+            .iter()\n+            .filter_map(|expr| typeck_results.node_type_opt(expr.hir_id))\n+            .all(|ty| matches!(ty.kind(), ty::Never))\n+        {\n+            let spans = visitor\n+                .returns\n+                .iter()\n+                .filter(|expr| typeck_results.node_type_opt(expr.hir_id).is_some())\n+                .map(|expr| expr.span)\n+                .collect::<Vec<Span>>();\n+            let span_len = spans.len();\n+            if span_len == 1 {\n+                err.span_label(spans[0], \"this returned value is of `!` type\");\n+            } else {\n+                let mut multispan: MultiSpan = spans.clone().into();\n+                for span in spans {\n+                    multispan\n+                        .push_span_label(span, \"this returned value is of `!` type\".to_string());\n+                }\n+                err.span_note(multispan, \"these returned values have a concrete \\\"never\\\" type\");\n+            }\n+            err.help(\"this error will resolve once the item's body returns a concrete type\");\n+        } else {\n+            let mut seen = FxHashSet::default();\n+            seen.insert(span);\n+            err.span_label(span, \"recursive opaque type\");\n+            label = true;\n+            for (sp, ty) in visitor\n+                .returns\n+                .iter()\n+                .filter_map(|e| typeck_results.node_type_opt(e.hir_id).map(|t| (e.span, t)))\n+                .filter(|(_, ty)| !matches!(ty.kind(), ty::Never))\n+            {\n+                struct VisitTypes(Vec<DefId>);\n+                impl<'tcx> ty::fold::TypeVisitor<'tcx> for VisitTypes {\n+                    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                        match *t.kind() {\n+                            ty::Opaque(def, _) => {\n+                                self.0.push(def);\n+                                false\n+                            }\n+                            _ => t.super_visit_with(self),\n+                        }\n+                    }\n+                }\n+                let mut visitor = VisitTypes(vec![]);\n+                ty.visit_with(&mut visitor);\n+                for def_id in visitor.0 {\n+                    let ty_span = tcx.def_span(def_id);\n+                    if !seen.contains(&ty_span) {\n+                        err.span_label(ty_span, &format!(\"returning this opaque type `{}`\", ty));\n+                        seen.insert(ty_span);\n+                    }\n+                    err.span_label(sp, &format!(\"returning here with type `{}`\", ty));\n+                }\n+            }\n+        }\n+    }\n+    if !label {\n+        err.span_label(span, \"cannot resolve opaque type\");\n+    }\n+    err.emit();\n+}"}, {"sha": "04d4d8171d48aef857dec6f97e4732ca7260d462", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 12, "deletions": 1327, "changes": 1339, "blob_url": "https://github.com/rust-lang/rust/blob/99e2e7075c0e32644498dd0bb64aae9a76ecfbce/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e2e7075c0e32644498dd0bb64aae9a76ecfbce/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=99e2e7075c0e32644498dd0bb64aae9a76ecfbce", "patch": "@@ -66,6 +66,7 @@ pub mod _match;\n mod autoderef;\n mod callee;\n pub mod cast;\n+mod check;\n mod closure;\n pub mod coercion;\n mod compare_method;\n@@ -88,53 +89,52 @@ mod upvar;\n mod wfcheck;\n pub mod writeback;\n \n+use check::{\n+    check_abi, check_fn, check_impl_item_well_formed, check_item_well_formed, check_mod_item_types,\n+    check_trait_item_well_formed,\n+};\n+pub use check::{check_item_type, check_wf_new};\n pub use diverges::Diverges;\n pub use expectation::Expectation;\n pub use fn_ctxt::FnCtxt;\n pub use inherited::{Inherited, InheritedBuilder};\n \n use crate::astconv::AstConv;\n use crate::check::gather_locals::GatherLocalsVisitor;\n-use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{HirIdMap, ItemKind, Node};\n+use rustc_hir::{HirIdMap, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::RegionVariableOrigin;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::util::{Discr, IntTypeExt, Representability};\n use rustc_middle::ty::WithConstness;\n-use rustc_middle::ty::{self, RegionKind, ToPredicate, Ty, TyCtxt, UserType};\n-use rustc_session::config::{self, EntryFnType};\n+use rustc_middle::ty::{self, RegionKind, Ty, TyCtxt, UserType};\n+use rustc_session::config;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::source_map::DUMMY_SP;\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::{self, BytePos, MultiSpan, Span};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::recursive_type_with_infinite_size_error;\n use rustc_trait_selection::traits::error_reporting::suggestions::ReturnsVisitor;\n-use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n use std::cell::{Ref, RefCell, RefMut};\n \n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n \n-use self::coercion::{CoerceMany, DynamicCoerceMany};\n-use self::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n+use self::coercion::DynamicCoerceMany;\n pub use self::Expectation::*;\n \n #[macro_export]\n@@ -245,11 +245,6 @@ impl<'tcx> EnclosingBreakables<'tcx> {\n     }\n }\n \n-pub fn check_wf_new(tcx: TyCtxt<'_>) {\n-    let visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n-    tcx.hir().krate().par_visit_all_item_likes(&visit);\n-}\n-\n pub fn provide(providers: &mut Providers) {\n     method::provide(providers);\n     *providers = Providers {\n@@ -631,19 +626,6 @@ fn typeck_with_fallback<'tcx>(\n     typeck_results\n }\n \n-fn check_abi(tcx: TyCtxt<'_>, span: Span, abi: Abi) {\n-    if !tcx.sess.target.target.is_abi_supported(abi) {\n-        struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0570,\n-            \"The ABI `{}` is not supported for the current target\",\n-            abi\n-        )\n-        .emit()\n-    }\n-}\n-\n /// When `check_fn` is invoked on a generator (i.e., a body that\n /// includes yield), it returns back some information about the yield\n /// points.\n@@ -661,460 +643,6 @@ struct GeneratorTypes<'tcx> {\n     movability: hir::Movability,\n }\n \n-/// Helper used for fns and closures. Does the grungy work of checking a function\n-/// body and returns the function context used for that purpose, since in the case of a fn item\n-/// there is still a bit more to do.\n-///\n-/// * ...\n-/// * inherited: other fields inherited from the enclosing fn (if any)\n-fn check_fn<'a, 'tcx>(\n-    inherited: &'a Inherited<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    fn_sig: ty::FnSig<'tcx>,\n-    decl: &'tcx hir::FnDecl<'tcx>,\n-    fn_id: hir::HirId,\n-    body: &'tcx hir::Body<'tcx>,\n-    can_be_generator: Option<hir::Movability>,\n-) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n-    let mut fn_sig = fn_sig;\n-\n-    debug!(\"check_fn(sig={:?}, fn_id={}, param_env={:?})\", fn_sig, fn_id, param_env);\n-\n-    // Create the function context. This is either derived from scratch or,\n-    // in the case of closures, based on the outer context.\n-    let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n-    *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n-\n-    let tcx = fcx.tcx;\n-    let sess = tcx.sess;\n-    let hir = tcx.hir();\n-\n-    let declared_ret_ty = fn_sig.output();\n-\n-    let revealed_ret_ty =\n-        fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty, decl.output.span());\n-    debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n-    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n-    fcx.ret_type_span = Some(decl.output.span());\n-    if let ty::Opaque(..) = declared_ret_ty.kind() {\n-        fcx.ret_coercion_impl_trait = Some(declared_ret_ty);\n-    }\n-    fn_sig = tcx.mk_fn_sig(\n-        fn_sig.inputs().iter().cloned(),\n-        revealed_ret_ty,\n-        fn_sig.c_variadic,\n-        fn_sig.unsafety,\n-        fn_sig.abi,\n-    );\n-\n-    let span = body.value.span;\n-\n-    fn_maybe_err(tcx, span, fn_sig.abi);\n-\n-    if body.generator_kind.is_some() && can_be_generator.is_some() {\n-        let yield_ty = fcx\n-            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n-        fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n-\n-        // Resume type defaults to `()` if the generator has no argument.\n-        let resume_ty = fn_sig.inputs().get(0).copied().unwrap_or_else(|| tcx.mk_unit());\n-\n-        fcx.resume_yield_tys = Some((resume_ty, yield_ty));\n-    }\n-\n-    let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id).to_def_id()).expect_local();\n-    let outer_hir_id = hir.local_def_id_to_hir_id(outer_def_id);\n-    GatherLocalsVisitor::new(&fcx, outer_hir_id).visit_body(body);\n-\n-    // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n-    // (as it's created inside the body itself, not passed in from outside).\n-    let maybe_va_list = if fn_sig.c_variadic {\n-        let span = body.params.last().unwrap().span;\n-        let va_list_did = tcx.require_lang_item(LangItem::VaList, Some(span));\n-        let region = fcx.next_region_var(RegionVariableOrigin::MiscVariable(span));\n-\n-        Some(tcx.type_of(va_list_did).subst(tcx, &[region.into()]))\n-    } else {\n-        None\n-    };\n-\n-    // Add formal parameters.\n-    let inputs_hir = hir.fn_decl_by_hir_id(fn_id).map(|decl| &decl.inputs);\n-    let inputs_fn = fn_sig.inputs().iter().copied();\n-    for (idx, (param_ty, param)) in inputs_fn.chain(maybe_va_list).zip(body.params).enumerate() {\n-        // Check the pattern.\n-        let ty_span = try { inputs_hir?.get(idx)?.span };\n-        fcx.check_pat_top(&param.pat, param_ty, ty_span, false);\n-\n-        // Check that argument is Sized.\n-        // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n-        // for simple cases like `fn foo(x: Trait)`,\n-        // where we would error once on the parameter as a whole, and once on the binding `x`.\n-        if param.pat.simple_ident().is_none() && !tcx.features().unsized_locals {\n-            fcx.require_type_is_sized(param_ty, param.pat.span, traits::SizedArgumentType(ty_span));\n-        }\n-\n-        fcx.write_ty(param.hir_id, param_ty);\n-    }\n-\n-    inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n-\n-    fcx.in_tail_expr = true;\n-    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n-        // FIXME: We need to verify that the return type is `Sized` after the return expression has\n-        // been evaluated so that we have types available for all the nodes being returned, but that\n-        // requires the coerced evaluated type to be stored. Moving `check_return_expr` before this\n-        // causes unsized errors caused by the `declared_ret_ty` to point at the return expression,\n-        // while keeping the current ordering we will ignore the tail expression's type because we\n-        // don't know it yet. We can't do `check_expr_kind` while keeping `check_return_expr`\n-        // because we will trigger \"unreachable expression\" lints unconditionally.\n-        // Because of all of this, we perform a crude check to know whether the simplest `!Sized`\n-        // case that a newcomer might make, returning a bare trait, and in that case we populate\n-        // the tail expression's type so that the suggestion will be correct, but ignore all other\n-        // possible cases.\n-        fcx.check_expr(&body.value);\n-        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-        tcx.sess.delay_span_bug(decl.output.span(), \"`!Sized` return type\");\n-    } else {\n-        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-        fcx.check_return_expr(&body.value);\n-    }\n-    fcx.in_tail_expr = false;\n-\n-    // We insert the deferred_generator_interiors entry after visiting the body.\n-    // This ensures that all nested generators appear before the entry of this generator.\n-    // resolve_generator_interiors relies on this property.\n-    let gen_ty = if let (Some(_), Some(gen_kind)) = (can_be_generator, body.generator_kind) {\n-        let interior = fcx\n-            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::MiscVariable, span });\n-        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior, gen_kind));\n-\n-        let (resume_ty, yield_ty) = fcx.resume_yield_tys.unwrap();\n-        Some(GeneratorTypes {\n-            resume_ty,\n-            yield_ty,\n-            interior,\n-            movability: can_be_generator.unwrap(),\n-        })\n-    } else {\n-        None\n-    };\n-\n-    // Finalize the return check by taking the LUB of the return types\n-    // we saw and assigning it to the expected return type. This isn't\n-    // really expected to fail, since the coercions would have failed\n-    // earlier when trying to find a LUB.\n-    //\n-    // However, the behavior around `!` is sort of complex. In the\n-    // event that the `actual_return_ty` comes back as `!`, that\n-    // indicates that the fn either does not return or \"returns\" only\n-    // values of type `!`. In this case, if there is an expected\n-    // return type that is *not* `!`, that should be ok. But if the\n-    // return type is being inferred, we want to \"fallback\" to `!`:\n-    //\n-    //     let x = move || panic!();\n-    //\n-    // To allow for that, I am creating a type variable with diverging\n-    // fallback. This was deemed ever so slightly better than unifying\n-    // the return value with `!` because it allows for the caller to\n-    // make more assumptions about the return type (e.g., they could do\n-    //\n-    //     let y: Option<u32> = Some(x());\n-    //\n-    // which would then cause this return type to become `u32`, not\n-    // `!`).\n-    let coercion = fcx.ret_coercion.take().unwrap().into_inner();\n-    let mut actual_return_ty = coercion.complete(&fcx);\n-    if actual_return_ty.is_never() {\n-        actual_return_ty = fcx.next_diverging_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::DivergingFn,\n-            span,\n-        });\n-    }\n-    fcx.demand_suptype(span, revealed_ret_ty, actual_return_ty);\n-\n-    // Check that the main return type implements the termination trait.\n-    if let Some(term_id) = tcx.lang_items().termination() {\n-        if let Some((def_id, EntryFnType::Main)) = tcx.entry_fn(LOCAL_CRATE) {\n-            let main_id = hir.local_def_id_to_hir_id(def_id);\n-            if main_id == fn_id {\n-                let substs = tcx.mk_substs_trait(declared_ret_ty, &[]);\n-                let trait_ref = ty::TraitRef::new(term_id, substs);\n-                let return_ty_span = decl.output.span();\n-                let cause = traits::ObligationCause::new(\n-                    return_ty_span,\n-                    fn_id,\n-                    ObligationCauseCode::MainFunctionType,\n-                );\n-\n-                inherited.register_predicate(traits::Obligation::new(\n-                    cause,\n-                    param_env,\n-                    trait_ref.without_const().to_predicate(tcx),\n-                ));\n-            }\n-        }\n-    }\n-\n-    // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n-    if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n-        if panic_impl_did == hir.local_def_id(fn_id).to_def_id() {\n-            if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n-                if *declared_ret_ty.kind() != ty::Never {\n-                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n-                }\n-\n-                let inputs = fn_sig.inputs();\n-                let span = hir.span(fn_id);\n-                if inputs.len() == 1 {\n-                    let arg_is_panic_info = match *inputs[0].kind() {\n-                        ty::Ref(region, ty, mutbl) => match *ty.kind() {\n-                            ty::Adt(ref adt, _) => {\n-                                adt.did == panic_info_did\n-                                    && mutbl == hir::Mutability::Not\n-                                    && *region != RegionKind::ReStatic\n-                            }\n-                            _ => false,\n-                        },\n-                        _ => false,\n-                    };\n-\n-                    if !arg_is_panic_info {\n-                        sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n-                    }\n-\n-                    if let Node::Item(item) = hir.get(fn_id) {\n-                        if let ItemKind::Fn(_, ref generics, _) = item.kind {\n-                            if !generics.params.is_empty() {\n-                                sess.span_err(span, \"should have no type parameters\");\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    let span = sess.source_map().guess_head_span(span);\n-                    sess.span_err(span, \"function should have one argument\");\n-                }\n-            } else {\n-                sess.err(\"language item required, but not found: `panic_info`\");\n-            }\n-        }\n-    }\n-\n-    // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n-    if let Some(alloc_error_handler_did) = tcx.lang_items().oom() {\n-        if alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id() {\n-            if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n-                if *declared_ret_ty.kind() != ty::Never {\n-                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n-                }\n-\n-                let inputs = fn_sig.inputs();\n-                let span = hir.span(fn_id);\n-                if inputs.len() == 1 {\n-                    let arg_is_alloc_layout = match inputs[0].kind() {\n-                        ty::Adt(ref adt, _) => adt.did == alloc_layout_did,\n-                        _ => false,\n-                    };\n-\n-                    if !arg_is_alloc_layout {\n-                        sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n-                    }\n-\n-                    if let Node::Item(item) = hir.get(fn_id) {\n-                        if let ItemKind::Fn(_, ref generics, _) = item.kind {\n-                            if !generics.params.is_empty() {\n-                                sess.span_err(\n-                                    span,\n-                                    \"`#[alloc_error_handler]` function should have no type \\\n-                                     parameters\",\n-                                );\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    let span = sess.source_map().guess_head_span(span);\n-                    sess.span_err(span, \"function should have one argument\");\n-                }\n-            } else {\n-                sess.err(\"language item required, but not found: `alloc_layout`\");\n-            }\n-        }\n-    }\n-\n-    (fcx, gen_ty)\n-}\n-\n-fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n-    let def_id = tcx.hir().local_def_id(id);\n-    let def = tcx.adt_def(def_id);\n-    def.destructor(tcx); // force the destructor to be evaluated\n-    check_representable(tcx, span, def_id);\n-\n-    if def.repr.simd() {\n-        check_simd(tcx, span, def_id);\n-    }\n-\n-    check_transparent(tcx, span, def);\n-    check_packed(tcx, span, def);\n-}\n-\n-fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n-    let def_id = tcx.hir().local_def_id(id);\n-    let def = tcx.adt_def(def_id);\n-    def.destructor(tcx); // force the destructor to be evaluated\n-    check_representable(tcx, span, def_id);\n-    check_transparent(tcx, span, def);\n-    check_union_fields(tcx, span, def_id);\n-    check_packed(tcx, span, def);\n-}\n-\n-/// When the `#![feature(untagged_unions)]` gate is active,\n-/// check that the fields of the `union` does not contain fields that need dropping.\n-fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> bool {\n-    let item_type = tcx.type_of(item_def_id);\n-    if let ty::Adt(def, substs) = item_type.kind() {\n-        assert!(def.is_union());\n-        let fields = &def.non_enum_variant().fields;\n-        let param_env = tcx.param_env(item_def_id);\n-        for field in fields {\n-            let field_ty = field.ty(tcx, substs);\n-            // We are currently checking the type this field came from, so it must be local.\n-            let field_span = tcx.hir().span_if_local(field.did).unwrap();\n-            if field_ty.needs_drop(tcx, param_env) {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    field_span,\n-                    E0740,\n-                    \"unions may not contain fields that need dropping\"\n-                )\n-                .span_note(field_span, \"`std::mem::ManuallyDrop` can be used to wrap the type\")\n-                .emit();\n-                return false;\n-            }\n-        }\n-    } else {\n-        span_bug!(span, \"unions must be ty::Adt, but got {:?}\", item_type.kind());\n-    }\n-    true\n-}\n-\n-/// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n-/// projections that would result in \"inheriting lifetimes\".\n-fn check_opaque<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n-    substs: SubstsRef<'tcx>,\n-    span: Span,\n-    origin: &hir::OpaqueTyOrigin,\n-) {\n-    check_opaque_for_inheriting_lifetimes(tcx, def_id, span);\n-    check_opaque_for_cycles(tcx, def_id, substs, span, origin);\n-}\n-\n-/// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n-/// in \"inheriting lifetimes\".\n-fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n-    let item = tcx.hir().expect_item(tcx.hir().local_def_id_to_hir_id(def_id));\n-    debug!(\n-        \"check_opaque_for_inheriting_lifetimes: def_id={:?} span={:?} item={:?}\",\n-        def_id, span, item\n-    );\n-\n-    #[derive(Debug)]\n-    struct ProhibitOpaqueVisitor<'tcx> {\n-        opaque_identity_ty: Ty<'tcx>,\n-        generics: &'tcx ty::Generics,\n-        ty: Option<Ty<'tcx>>,\n-    };\n-\n-    impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n-        fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n-            if t != self.opaque_identity_ty && t.super_visit_with(self) {\n-                self.ty = Some(t);\n-                return true;\n-            }\n-            false\n-        }\n-\n-        fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_region) r={:?}\", r);\n-            if let RegionKind::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = r {\n-                return *index < self.generics.parent_count as u32;\n-            }\n-\n-            r.super_visit_with(self)\n-        }\n-\n-        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n-            if let ty::ConstKind::Unevaluated(..) = c.val {\n-                // FIXME(#72219) We currenctly don't detect lifetimes within substs\n-                // which would violate this check. Even though the particular substitution is not used\n-                // within the const, this should still be fixed.\n-                return false;\n-            }\n-            c.super_visit_with(self)\n-        }\n-    }\n-\n-    if let ItemKind::OpaqueTy(hir::OpaqueTy {\n-        origin: hir::OpaqueTyOrigin::AsyncFn | hir::OpaqueTyOrigin::FnReturn,\n-        ..\n-    }) = item.kind\n-    {\n-        let mut visitor = ProhibitOpaqueVisitor {\n-            opaque_identity_ty: tcx.mk_opaque(\n-                def_id.to_def_id(),\n-                InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n-            ),\n-            generics: tcx.generics_of(def_id),\n-            ty: None,\n-        };\n-        let prohibit_opaque = tcx\n-            .predicates_of(def_id)\n-            .predicates\n-            .iter()\n-            .any(|(predicate, _)| predicate.visit_with(&mut visitor));\n-        debug!(\n-            \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor={:?}\",\n-            prohibit_opaque, visitor\n-        );\n-\n-        if prohibit_opaque {\n-            let is_async = match item.kind {\n-                ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => match origin {\n-                    hir::OpaqueTyOrigin::AsyncFn => true,\n-                    _ => false,\n-                },\n-                _ => unreachable!(),\n-            };\n-\n-            let mut err = struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0760,\n-                \"`{}` return type cannot contain a projection or `Self` that references lifetimes from \\\n-             a parent scope\",\n-                if is_async { \"async fn\" } else { \"impl Trait\" },\n-            );\n-\n-            if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(span) {\n-                if snippet == \"Self\" {\n-                    if let Some(ty) = visitor.ty {\n-                        err.span_suggestion(\n-                            span,\n-                            \"consider spelling out the type instead\",\n-                            format!(\"{:?}\", ty),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n-            err.emit();\n-        }\n-    }\n-}\n-\n /// Given a `DefId` for an opaque type in return position, find its parent item's return\n /// expressions.\n fn get_owner_return_paths(\n@@ -1135,86 +663,6 @@ fn get_owner_return_paths(\n         })\n }\n \n-/// Emit an error for recursive opaque types.\n-///\n-/// If this is a return `impl Trait`, find the item's return expressions and point at them. For\n-/// direct recursion this is enough, but for indirect recursion also point at the last intermediary\n-/// `impl Trait`.\n-///\n-/// If all the return expressions evaluate to `!`, then we explain that the error will go away\n-/// after changing it. This can happen when a user uses `panic!()` or similar as a placeholder.\n-fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n-    let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n-\n-    let mut label = false;\n-    if let Some((hir_id, visitor)) = get_owner_return_paths(tcx, def_id) {\n-        let typeck_results = tcx.typeck(tcx.hir().local_def_id(hir_id));\n-        if visitor\n-            .returns\n-            .iter()\n-            .filter_map(|expr| typeck_results.node_type_opt(expr.hir_id))\n-            .all(|ty| matches!(ty.kind(), ty::Never))\n-        {\n-            let spans = visitor\n-                .returns\n-                .iter()\n-                .filter(|expr| typeck_results.node_type_opt(expr.hir_id).is_some())\n-                .map(|expr| expr.span)\n-                .collect::<Vec<Span>>();\n-            let span_len = spans.len();\n-            if span_len == 1 {\n-                err.span_label(spans[0], \"this returned value is of `!` type\");\n-            } else {\n-                let mut multispan: MultiSpan = spans.clone().into();\n-                for span in spans {\n-                    multispan\n-                        .push_span_label(span, \"this returned value is of `!` type\".to_string());\n-                }\n-                err.span_note(multispan, \"these returned values have a concrete \\\"never\\\" type\");\n-            }\n-            err.help(\"this error will resolve once the item's body returns a concrete type\");\n-        } else {\n-            let mut seen = FxHashSet::default();\n-            seen.insert(span);\n-            err.span_label(span, \"recursive opaque type\");\n-            label = true;\n-            for (sp, ty) in visitor\n-                .returns\n-                .iter()\n-                .filter_map(|e| typeck_results.node_type_opt(e.hir_id).map(|t| (e.span, t)))\n-                .filter(|(_, ty)| !matches!(ty.kind(), ty::Never))\n-            {\n-                struct VisitTypes(Vec<DefId>);\n-                impl<'tcx> ty::fold::TypeVisitor<'tcx> for VisitTypes {\n-                    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-                        match *t.kind() {\n-                            ty::Opaque(def, _) => {\n-                                self.0.push(def);\n-                                false\n-                            }\n-                            _ => t.super_visit_with(self),\n-                        }\n-                    }\n-                }\n-                let mut visitor = VisitTypes(vec![]);\n-                ty.visit_with(&mut visitor);\n-                for def_id in visitor.0 {\n-                    let ty_span = tcx.def_span(def_id);\n-                    if !seen.contains(&ty_span) {\n-                        err.span_label(ty_span, &format!(\"returning this opaque type `{}`\", ty));\n-                        seen.insert(ty_span);\n-                    }\n-                    err.span_label(sp, &format!(\"returning here with type `{}`\", ty));\n-                }\n-            }\n-        }\n-    }\n-    if !label {\n-        err.span_label(span, \"cannot resolve opaque type\");\n-    }\n-    err.emit();\n-}\n-\n /// Emit an error for recursive opaque types in a `let` binding.\n fn binding_opaque_type_cycle_error(\n     tcx: TyCtxt<'tcx>,\n@@ -1275,33 +723,6 @@ fn binding_opaque_type_cycle_error(\n     err.emit();\n }\n \n-fn async_opaque_type_cycle_error(tcx: TyCtxt<'tcx>, span: Span) {\n-    struct_span_err!(tcx.sess, span, E0733, \"recursion in an `async fn` requires boxing\")\n-        .span_label(span, \"recursive `async fn`\")\n-        .note(\"a recursive `async fn` must be rewritten to return a boxed `dyn Future`\")\n-        .emit();\n-}\n-\n-/// Checks that an opaque type does not contain cycles.\n-fn check_opaque_for_cycles<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n-    substs: SubstsRef<'tcx>,\n-    span: Span,\n-    origin: &hir::OpaqueTyOrigin,\n-) {\n-    if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id.to_def_id(), substs)\n-    {\n-        match origin {\n-            hir::OpaqueTyOrigin::AsyncFn => async_opaque_type_cycle_error(tcx, span),\n-            hir::OpaqueTyOrigin::Binding => {\n-                binding_opaque_type_cycle_error(tcx, def_id, span, partially_expanded_type)\n-            }\n-            _ => opaque_type_cycle_error(tcx, def_id, span),\n-        }\n-    }\n-}\n-\n // Forbid defining intrinsics in Rust code,\n // as they must always be defined by the compiler.\n fn fn_maybe_err(tcx: TyCtxt<'_>, sp: Span, abi: Abi) {\n@@ -1310,126 +731,6 @@ fn fn_maybe_err(tcx: TyCtxt<'_>, sp: Span, abi: Abi) {\n     }\n }\n \n-pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n-    debug!(\n-        \"check_item_type(it.hir_id={}, it.name={})\",\n-        it.hir_id,\n-        tcx.def_path_str(tcx.hir().local_def_id(it.hir_id).to_def_id())\n-    );\n-    let _indenter = indenter();\n-    match it.kind {\n-        // Consts can play a role in type-checking, so they are included here.\n-        hir::ItemKind::Static(..) => {\n-            let def_id = tcx.hir().local_def_id(it.hir_id);\n-            tcx.ensure().typeck(def_id);\n-            maybe_check_static_with_link_section(tcx, def_id, it.span);\n-        }\n-        hir::ItemKind::Const(..) => {\n-            tcx.ensure().typeck(tcx.hir().local_def_id(it.hir_id));\n-        }\n-        hir::ItemKind::Enum(ref enum_definition, _) => {\n-            check_enum(tcx, it.span, &enum_definition.variants, it.hir_id);\n-        }\n-        hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n-        hir::ItemKind::Impl { ref items, .. } => {\n-            debug!(\"ItemKind::Impl {} with id {}\", it.ident, it.hir_id);\n-            let impl_def_id = tcx.hir().local_def_id(it.hir_id);\n-            if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n-                check_impl_items_against_trait(tcx, it.span, impl_def_id, impl_trait_ref, items);\n-                let trait_def_id = impl_trait_ref.def_id;\n-                check_on_unimplemented(tcx, trait_def_id, it);\n-            }\n-        }\n-        hir::ItemKind::Trait(_, _, _, _, ref items) => {\n-            let def_id = tcx.hir().local_def_id(it.hir_id);\n-            check_on_unimplemented(tcx, def_id.to_def_id(), it);\n-\n-            for item in items.iter() {\n-                let item = tcx.hir().trait_item(item.id);\n-                if let hir::TraitItemKind::Fn(sig, _) = &item.kind {\n-                    let abi = sig.header.abi;\n-                    fn_maybe_err(tcx, item.ident.span, abi);\n-                }\n-            }\n-        }\n-        hir::ItemKind::Struct(..) => {\n-            check_struct(tcx, it.hir_id, it.span);\n-        }\n-        hir::ItemKind::Union(..) => {\n-            check_union(tcx, it.hir_id, it.span);\n-        }\n-        hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n-            // HACK(jynelson): trying to infer the type of `impl trait` breaks documenting\n-            // `async-std` (and `pub async fn` in general).\n-            // Since rustdoc doesn't care about the concrete type behind `impl Trait`, just don't look at it!\n-            // See https://github.com/rust-lang/rust/issues/75100\n-            if !tcx.sess.opts.actually_rustdoc {\n-                let def_id = tcx.hir().local_def_id(it.hir_id);\n-\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n-                check_opaque(tcx, def_id, substs, it.span, &origin);\n-            }\n-        }\n-        hir::ItemKind::TyAlias(..) => {\n-            let def_id = tcx.hir().local_def_id(it.hir_id);\n-            let pty_ty = tcx.type_of(def_id);\n-            let generics = tcx.generics_of(def_id);\n-            check_type_params_are_used(tcx, &generics, pty_ty);\n-        }\n-        hir::ItemKind::ForeignMod(ref m) => {\n-            check_abi(tcx, it.span, m.abi);\n-\n-            if m.abi == Abi::RustIntrinsic {\n-                for item in m.items {\n-                    intrinsic::check_intrinsic_type(tcx, item);\n-                }\n-            } else if m.abi == Abi::PlatformIntrinsic {\n-                for item in m.items {\n-                    intrinsic::check_platform_intrinsic_type(tcx, item);\n-                }\n-            } else {\n-                for item in m.items {\n-                    let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n-                    let own_counts = generics.own_counts();\n-                    if generics.params.len() - own_counts.lifetimes != 0 {\n-                        let (kinds, kinds_pl, egs) = match (own_counts.types, own_counts.consts) {\n-                            (_, 0) => (\"type\", \"types\", Some(\"u32\")),\n-                            // We don't specify an example value, because we can't generate\n-                            // a valid value for any type.\n-                            (0, _) => (\"const\", \"consts\", None),\n-                            _ => (\"type or const\", \"types or consts\", None),\n-                        };\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            item.span,\n-                            E0044,\n-                            \"foreign items may not have {} parameters\",\n-                            kinds,\n-                        )\n-                        .span_label(item.span, &format!(\"can't have {} parameters\", kinds))\n-                        .help(\n-                            // FIXME: once we start storing spans for type arguments, turn this\n-                            // into a suggestion.\n-                            &format!(\n-                                \"replace the {} parameters with concrete {}{}\",\n-                                kinds,\n-                                kinds_pl,\n-                                egs.map(|egs| format!(\" like `{}`\", egs)).unwrap_or_default(),\n-                            ),\n-                        )\n-                        .emit();\n-                    }\n-\n-                    if let hir::ForeignItemKind::Fn(ref fn_decl, _, _) = item.kind {\n-                        require_c_abi_if_c_variadic(tcx, fn_decl, m.abi, item.span);\n-                    }\n-                }\n-            }\n-        }\n-        _ => { /* nothing to do */ }\n-    }\n-}\n-\n fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId, span: Span) {\n     // Only restricted on wasm32 target for now\n     if !tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n@@ -1463,12 +764,6 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId, span: S\n     }\n }\n \n-fn check_on_unimplemented(tcx: TyCtxt<'_>, trait_def_id: DefId, item: &hir::Item<'_>) {\n-    let item_def_id = tcx.hir().local_def_id(item.hir_id);\n-    // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id.to_def_id());\n-}\n-\n fn report_forbidden_specialization(\n     tcx: TyCtxt<'_>,\n     impl_item: &hir::ImplItem<'_>,\n@@ -1500,248 +795,6 @@ fn report_forbidden_specialization(\n     err.emit();\n }\n \n-fn check_specialization_validity<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_def: &ty::TraitDef,\n-    trait_item: &ty::AssocItem,\n-    impl_id: DefId,\n-    impl_item: &hir::ImplItem<'_>,\n-) {\n-    let kind = match impl_item.kind {\n-        hir::ImplItemKind::Const(..) => ty::AssocKind::Const,\n-        hir::ImplItemKind::Fn(..) => ty::AssocKind::Fn,\n-        hir::ImplItemKind::TyAlias(_) => ty::AssocKind::Type,\n-    };\n-\n-    let ancestors = match trait_def.ancestors(tcx, impl_id) {\n-        Ok(ancestors) => ancestors,\n-        Err(_) => return,\n-    };\n-    let mut ancestor_impls = ancestors\n-        .skip(1)\n-        .filter_map(|parent| {\n-            if parent.is_from_trait() {\n-                None\n-            } else {\n-                Some((parent, parent.item(tcx, trait_item.ident, kind, trait_def.def_id)))\n-            }\n-        })\n-        .peekable();\n-\n-    if ancestor_impls.peek().is_none() {\n-        // No parent, nothing to specialize.\n-        return;\n-    }\n-\n-    let opt_result = ancestor_impls.find_map(|(parent_impl, parent_item)| {\n-        match parent_item {\n-            // Parent impl exists, and contains the parent item we're trying to specialize, but\n-            // doesn't mark it `default`.\n-            Some(parent_item) if traits::impl_item_is_final(tcx, &parent_item) => {\n-                Some(Err(parent_impl.def_id()))\n-            }\n-\n-            // Parent impl contains item and makes it specializable.\n-            Some(_) => Some(Ok(())),\n-\n-            // Parent impl doesn't mention the item. This means it's inherited from the\n-            // grandparent. In that case, if parent is a `default impl`, inherited items use the\n-            // \"defaultness\" from the grandparent, else they are final.\n-            None => {\n-                if tcx.impl_defaultness(parent_impl.def_id()).is_default() {\n-                    None\n-                } else {\n-                    Some(Err(parent_impl.def_id()))\n-                }\n-            }\n-        }\n-    });\n-\n-    // If `opt_result` is `None`, we have only encountered `default impl`s that don't contain the\n-    // item. This is allowed, the item isn't actually getting specialized here.\n-    let result = opt_result.unwrap_or(Ok(()));\n-\n-    if let Err(parent_impl) = result {\n-        report_forbidden_specialization(tcx, impl_item, parent_impl);\n-    }\n-}\n-\n-fn check_impl_items_against_trait<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    full_impl_span: Span,\n-    impl_id: LocalDefId,\n-    impl_trait_ref: ty::TraitRef<'tcx>,\n-    impl_item_refs: &[hir::ImplItemRef<'_>],\n-) {\n-    let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n-\n-    // If the trait reference itself is erroneous (so the compilation is going\n-    // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n-    // isn't populated for such impls.\n-    if impl_trait_ref.references_error() {\n-        return;\n-    }\n-\n-    // Negative impls are not expected to have any items\n-    match tcx.impl_polarity(impl_id) {\n-        ty::ImplPolarity::Reservation | ty::ImplPolarity::Positive => {}\n-        ty::ImplPolarity::Negative => {\n-            if let [first_item_ref, ..] = impl_item_refs {\n-                let first_item_span = tcx.hir().impl_item(first_item_ref.id).span;\n-                struct_span_err!(\n-                    tcx.sess,\n-                    first_item_span,\n-                    E0749,\n-                    \"negative impls cannot have any items\"\n-                )\n-                .emit();\n-            }\n-            return;\n-        }\n-    }\n-\n-    // Locate trait definition and items\n-    let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n-\n-    let impl_items = || impl_item_refs.iter().map(|iiref| tcx.hir().impl_item(iiref.id));\n-\n-    // Check existing impl methods to see if they are both present in trait\n-    // and compatible with trait signature\n-    for impl_item in impl_items() {\n-        let namespace = impl_item.kind.namespace();\n-        let ty_impl_item = tcx.associated_item(tcx.hir().local_def_id(impl_item.hir_id));\n-        let ty_trait_item = tcx\n-            .associated_items(impl_trait_ref.def_id)\n-            .find_by_name_and_namespace(tcx, ty_impl_item.ident, namespace, impl_trait_ref.def_id)\n-            .or_else(|| {\n-                // Not compatible, but needed for the error message\n-                tcx.associated_items(impl_trait_ref.def_id)\n-                    .filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id)\n-                    .next()\n-            });\n-\n-        // Check that impl definition matches trait definition\n-        if let Some(ty_trait_item) = ty_trait_item {\n-            match impl_item.kind {\n-                hir::ImplItemKind::Const(..) => {\n-                    // Find associated const definition.\n-                    if ty_trait_item.kind == ty::AssocKind::Const {\n-                        compare_const_impl(\n-                            tcx,\n-                            &ty_impl_item,\n-                            impl_item.span,\n-                            &ty_trait_item,\n-                            impl_trait_ref,\n-                        );\n-                    } else {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            impl_item.span,\n-                            E0323,\n-                            \"item `{}` is an associated const, \\\n-                             which doesn't match its trait `{}`\",\n-                            ty_impl_item.ident,\n-                            impl_trait_ref.print_only_trait_path()\n-                        );\n-                        err.span_label(impl_item.span, \"does not match trait\");\n-                        // We can only get the spans from local trait definition\n-                        // Same for E0324 and E0325\n-                        if let Some(trait_span) = tcx.hir().span_if_local(ty_trait_item.def_id) {\n-                            err.span_label(trait_span, \"item in trait\");\n-                        }\n-                        err.emit()\n-                    }\n-                }\n-                hir::ImplItemKind::Fn(..) => {\n-                    let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                    if ty_trait_item.kind == ty::AssocKind::Fn {\n-                        compare_impl_method(\n-                            tcx,\n-                            &ty_impl_item,\n-                            impl_item.span,\n-                            &ty_trait_item,\n-                            impl_trait_ref,\n-                            opt_trait_span,\n-                        );\n-                    } else {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            impl_item.span,\n-                            E0324,\n-                            \"item `{}` is an associated method, \\\n-                             which doesn't match its trait `{}`\",\n-                            ty_impl_item.ident,\n-                            impl_trait_ref.print_only_trait_path()\n-                        );\n-                        err.span_label(impl_item.span, \"does not match trait\");\n-                        if let Some(trait_span) = opt_trait_span {\n-                            err.span_label(trait_span, \"item in trait\");\n-                        }\n-                        err.emit()\n-                    }\n-                }\n-                hir::ImplItemKind::TyAlias(_) => {\n-                    let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                    if ty_trait_item.kind == ty::AssocKind::Type {\n-                        compare_ty_impl(\n-                            tcx,\n-                            &ty_impl_item,\n-                            impl_item.span,\n-                            &ty_trait_item,\n-                            impl_trait_ref,\n-                            opt_trait_span,\n-                        );\n-                    } else {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            impl_item.span,\n-                            E0325,\n-                            \"item `{}` is an associated type, \\\n-                             which doesn't match its trait `{}`\",\n-                            ty_impl_item.ident,\n-                            impl_trait_ref.print_only_trait_path()\n-                        );\n-                        err.span_label(impl_item.span, \"does not match trait\");\n-                        if let Some(trait_span) = opt_trait_span {\n-                            err.span_label(trait_span, \"item in trait\");\n-                        }\n-                        err.emit()\n-                    }\n-                }\n-            }\n-\n-            check_specialization_validity(\n-                tcx,\n-                trait_def,\n-                &ty_trait_item,\n-                impl_id.to_def_id(),\n-                impl_item,\n-            );\n-        }\n-    }\n-\n-    // Check for missing items from trait\n-    let mut missing_items = Vec::new();\n-    if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id.to_def_id()) {\n-        for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n-            let is_implemented = ancestors\n-                .leaf_def(tcx, trait_item.ident, trait_item.kind)\n-                .map(|node_item| !node_item.defining_node.is_from_trait())\n-                .unwrap_or(false);\n-\n-            if !is_implemented && tcx.impl_defaultness(impl_id).is_final() {\n-                if !trait_item.defaultness.has_value() {\n-                    missing_items.push(*trait_item);\n-                }\n-            }\n-        }\n-    }\n-\n-    if !missing_items.is_empty() {\n-        missing_items_err(tcx, impl_span, &missing_items, full_impl_span);\n-    }\n-}\n-\n fn missing_items_err(\n     tcx: TyCtxt<'_>,\n     impl_span: Span,\n@@ -1941,161 +994,6 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n     }\n }\n \n-/// Checks whether a type can be represented in memory. In particular, it\n-/// identifies types that contain themselves without indirection through a\n-/// pointer, which would mean their size is unbounded.\n-fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalDefId) -> bool {\n-    let rty = tcx.type_of(item_def_id);\n-\n-    // Check that it is possible to represent this type. This call identifies\n-    // (1) types that contain themselves and (2) types that contain a different\n-    // recursive type. It is only necessary to throw an error on those that\n-    // contain themselves. For case 2, there must be an inner type that will be\n-    // caught by case 1.\n-    match rty.is_representable(tcx, sp) {\n-        Representability::SelfRecursive(spans) => {\n-            recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id(), spans);\n-            return false;\n-        }\n-        Representability::Representable | Representability::ContainsRecursive => (),\n-    }\n-    true\n-}\n-\n-pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n-    let t = tcx.type_of(def_id);\n-    if let ty::Adt(def, substs) = t.kind() {\n-        if def.is_struct() {\n-            let fields = &def.non_enum_variant().fields;\n-            if fields.is_empty() {\n-                struct_span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\").emit();\n-                return;\n-            }\n-            let e = fields[0].ty(tcx, substs);\n-            if !fields.iter().all(|f| f.ty(tcx, substs) == e) {\n-                struct_span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\")\n-                    .span_label(sp, \"SIMD elements must have the same type\")\n-                    .emit();\n-                return;\n-            }\n-            match e.kind() {\n-                ty::Param(_) => { /* struct<T>(T, T, T, T) is ok */ }\n-                _ if e.is_machine() => { /* struct(u8, u8, u8, u8) is ok */ }\n-                _ => {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        sp,\n-                        E0077,\n-                        \"SIMD vector element type should be machine type\"\n-                    )\n-                    .emit();\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n-    let repr = def.repr;\n-    if repr.packed() {\n-        for attr in tcx.get_attrs(def.did).iter() {\n-            for r in attr::find_repr_attrs(&tcx.sess, attr) {\n-                if let attr::ReprPacked(pack) = r {\n-                    if let Some(repr_pack) = repr.pack {\n-                        if pack as u64 != repr_pack.bytes() {\n-                            struct_span_err!(\n-                                tcx.sess,\n-                                sp,\n-                                E0634,\n-                                \"type has conflicting packed representation hints\"\n-                            )\n-                            .emit();\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        if repr.align.is_some() {\n-            struct_span_err!(\n-                tcx.sess,\n-                sp,\n-                E0587,\n-                \"type has conflicting packed and align representation hints\"\n-            )\n-            .emit();\n-        } else {\n-            if let Some(def_spans) = check_packed_inner(tcx, def.did, &mut vec![]) {\n-                let mut err = struct_span_err!(\n-                    tcx.sess,\n-                    sp,\n-                    E0588,\n-                    \"packed type cannot transitively contain a `#[repr(align)]` type\"\n-                );\n-\n-                err.span_note(\n-                    tcx.def_span(def_spans[0].0),\n-                    &format!(\n-                        \"`{}` has a `#[repr(align)]` attribute\",\n-                        tcx.item_name(def_spans[0].0)\n-                    ),\n-                );\n-\n-                if def_spans.len() > 2 {\n-                    let mut first = true;\n-                    for (adt_def, span) in def_spans.iter().skip(1).rev() {\n-                        let ident = tcx.item_name(*adt_def);\n-                        err.span_note(\n-                            *span,\n-                            &if first {\n-                                format!(\n-                                    \"`{}` contains a field of type `{}`\",\n-                                    tcx.type_of(def.did),\n-                                    ident\n-                                )\n-                            } else {\n-                                format!(\"...which contains a field of type `{}`\", ident)\n-                            },\n-                        );\n-                        first = false;\n-                    }\n-                }\n-\n-                err.emit();\n-            }\n-        }\n-    }\n-}\n-\n-fn check_packed_inner(\n-    tcx: TyCtxt<'_>,\n-    def_id: DefId,\n-    stack: &mut Vec<DefId>,\n-) -> Option<Vec<(DefId, Span)>> {\n-    if let ty::Adt(def, substs) = tcx.type_of(def_id).kind() {\n-        if def.is_struct() || def.is_union() {\n-            if def.repr.align.is_some() {\n-                return Some(vec![(def.did, DUMMY_SP)]);\n-            }\n-\n-            stack.push(def_id);\n-            for field in &def.non_enum_variant().fields {\n-                if let ty::Adt(def, _) = field.ty(tcx, substs).kind() {\n-                    if !stack.contains(&def.did) {\n-                        if let Some(mut defs) = check_packed_inner(tcx, def.did, stack) {\n-                            defs.push((def.did, field.ident.span));\n-                            return Some(defs);\n-                        }\n-                    }\n-                }\n-            }\n-            stack.pop();\n-        }\n-    }\n-\n-    None\n-}\n-\n /// Emit an error when encountering more or less than one variant in a transparent enum.\n fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: &'tcx ty::AdtDef, sp: Span, did: DefId) {\n     let variant_spans: Vec<_> = adt\n@@ -2141,158 +1039,6 @@ fn bad_non_zero_sized_fields<'tcx>(\n     err.emit();\n }\n \n-fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: &'tcx ty::AdtDef) {\n-    if !adt.repr.transparent() {\n-        return;\n-    }\n-    let sp = tcx.sess.source_map().guess_head_span(sp);\n-\n-    if adt.is_union() && !tcx.features().transparent_unions {\n-        feature_err(\n-            &tcx.sess.parse_sess,\n-            sym::transparent_unions,\n-            sp,\n-            \"transparent unions are unstable\",\n-        )\n-        .emit();\n-    }\n-\n-    if adt.variants.len() != 1 {\n-        bad_variant_count(tcx, adt, sp, adt.did);\n-        if adt.variants.is_empty() {\n-            // Don't bother checking the fields. No variants (and thus no fields) exist.\n-            return;\n-        }\n-    }\n-\n-    // For each field, figure out if it's known to be a ZST and align(1)\n-    let field_infos = adt.all_fields().map(|field| {\n-        let ty = field.ty(tcx, InternalSubsts::identity_for_item(tcx, field.did));\n-        let param_env = tcx.param_env(field.did);\n-        let layout = tcx.layout_of(param_env.and(ty));\n-        // We are currently checking the type this field came from, so it must be local\n-        let span = tcx.hir().span_if_local(field.did).unwrap();\n-        let zst = layout.map(|layout| layout.is_zst()).unwrap_or(false);\n-        let align1 = layout.map(|layout| layout.align.abi.bytes() == 1).unwrap_or(false);\n-        (span, zst, align1)\n-    });\n-\n-    let non_zst_fields =\n-        field_infos.clone().filter_map(|(span, zst, _align1)| if !zst { Some(span) } else { None });\n-    let non_zst_count = non_zst_fields.clone().count();\n-    if non_zst_count != 1 {\n-        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, sp);\n-    }\n-    for (span, zst, align1) in field_infos {\n-        if zst && !align1 {\n-            struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0691,\n-                \"zero-sized field in transparent {} has alignment larger than 1\",\n-                adt.descr(),\n-            )\n-            .span_label(span, \"has alignment larger than 1\")\n-            .emit();\n-        }\n-    }\n-}\n-\n-#[allow(trivial_numeric_casts)]\n-pub fn check_enum<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    sp: Span,\n-    vs: &'tcx [hir::Variant<'tcx>],\n-    id: hir::HirId,\n-) {\n-    let def_id = tcx.hir().local_def_id(id);\n-    let def = tcx.adt_def(def_id);\n-    def.destructor(tcx); // force the destructor to be evaluated\n-\n-    if vs.is_empty() {\n-        let attributes = tcx.get_attrs(def_id.to_def_id());\n-        if let Some(attr) = tcx.sess.find_by_name(&attributes, sym::repr) {\n-            struct_span_err!(\n-                tcx.sess,\n-                attr.span,\n-                E0084,\n-                \"unsupported representation for zero-variant enum\"\n-            )\n-            .span_label(sp, \"zero-variant enum\")\n-            .emit();\n-        }\n-    }\n-\n-    let repr_type_ty = def.repr.discr_type().to_ty(tcx);\n-    if repr_type_ty == tcx.types.i128 || repr_type_ty == tcx.types.u128 {\n-        if !tcx.features().repr128 {\n-            feature_err(\n-                &tcx.sess.parse_sess,\n-                sym::repr128,\n-                sp,\n-                \"repr with 128-bit type is unstable\",\n-            )\n-            .emit();\n-        }\n-    }\n-\n-    for v in vs {\n-        if let Some(ref e) = v.disr_expr {\n-            tcx.ensure().typeck(tcx.hir().local_def_id(e.hir_id));\n-        }\n-    }\n-\n-    if tcx.adt_def(def_id).repr.int.is_none() && tcx.features().arbitrary_enum_discriminant {\n-        let is_unit = |var: &hir::Variant<'_>| match var.data {\n-            hir::VariantData::Unit(..) => true,\n-            _ => false,\n-        };\n-\n-        let has_disr = |var: &hir::Variant<'_>| var.disr_expr.is_some();\n-        let has_non_units = vs.iter().any(|var| !is_unit(var));\n-        let disr_units = vs.iter().any(|var| is_unit(&var) && has_disr(&var));\n-        let disr_non_unit = vs.iter().any(|var| !is_unit(&var) && has_disr(&var));\n-\n-        if disr_non_unit || (disr_units && has_non_units) {\n-            let mut err =\n-                struct_span_err!(tcx.sess, sp, E0732, \"`#[repr(inttype)]` must be specified\");\n-            err.emit();\n-        }\n-    }\n-\n-    let mut disr_vals: Vec<Discr<'tcx>> = Vec::with_capacity(vs.len());\n-    for ((_, discr), v) in def.discriminants(tcx).zip(vs) {\n-        // Check for duplicate discriminant values\n-        if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n-            let variant_did = def.variants[VariantIdx::new(i)].def_id;\n-            let variant_i_hir_id = tcx.hir().local_def_id_to_hir_id(variant_did.expect_local());\n-            let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n-            let i_span = match variant_i.disr_expr {\n-                Some(ref expr) => tcx.hir().span(expr.hir_id),\n-                None => tcx.hir().span(variant_i_hir_id),\n-            };\n-            let span = match v.disr_expr {\n-                Some(ref expr) => tcx.hir().span(expr.hir_id),\n-                None => v.span,\n-            };\n-            struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0081,\n-                \"discriminant value `{}` already exists\",\n-                disr_vals[i]\n-            )\n-            .span_label(i_span, format!(\"first use of `{}`\", disr_vals[i]))\n-            .span_label(span, format!(\"enum already has `{}`\", disr_vals[i]))\n-            .emit();\n-        }\n-        disr_vals.push(discr);\n-    }\n-\n-    check_representable(tcx, sp, def_id);\n-    check_transparent(tcx, sp, def);\n-}\n-\n fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span) {\n     struct_span_err!(\n         tcx.sess,\n@@ -2337,51 +1083,6 @@ enum FallbackMode {\n     All,\n }\n \n-fn check_type_params_are_used<'tcx>(tcx: TyCtxt<'tcx>, generics: &ty::Generics, ty: Ty<'tcx>) {\n-    debug!(\"check_type_params_are_used(generics={:?}, ty={:?})\", generics, ty);\n-\n-    assert_eq!(generics.parent, None);\n-\n-    if generics.own_counts().types == 0 {\n-        return;\n-    }\n-\n-    let mut params_used = BitSet::new_empty(generics.params.len());\n-\n-    if ty.references_error() {\n-        // If there is already another error, do not emit\n-        // an error for not using a type parameter.\n-        assert!(tcx.sess.has_errors());\n-        return;\n-    }\n-\n-    for leaf in ty.walk() {\n-        if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n-            if let ty::Param(param) = leaf_ty.kind() {\n-                debug!(\"found use of ty param {:?}\", param);\n-                params_used.insert(param.index);\n-            }\n-        }\n-    }\n-\n-    for param in &generics.params {\n-        if !params_used.contains(param.index) {\n-            if let ty::GenericParamDefKind::Type { .. } = param.kind {\n-                let span = tcx.def_span(param.def_id);\n-                struct_span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0091,\n-                    \"type parameter `{}` is unused\",\n-                    param.name,\n-                )\n-                .span_label(span, \"unused type parameter\")\n-                .emit();\n-            }\n-        }\n-    }\n-}\n-\n /// A wrapper for `InferCtxt`'s `in_progress_typeck_results` field.\n #[derive(Copy, Clone)]\n struct MaybeInProgressTables<'a, 'tcx> {\n@@ -2420,22 +1121,6 @@ impl ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'tcx> {\n     fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem<'tcx>) {}\n }\n \n-fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckItemTypesVisitor { tcx });\n-}\n-\n-fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    wfcheck::check_item_well_formed(tcx, def_id);\n-}\n-\n-fn check_trait_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    wfcheck::check_trait_item(tcx, def_id);\n-}\n-\n-fn check_impl_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    wfcheck::check_impl_item(tcx, def_id);\n-}\n-\n fn typeck_item_bodies(tcx: TyCtxt<'_>, crate_num: CrateNum) {\n     debug_assert!(crate_num == LOCAL_CRATE);\n     tcx.par_body_owners(|body_owner_def_id| {"}]}