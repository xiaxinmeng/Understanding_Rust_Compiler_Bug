{"sha": "46e7fbe60b53e486ff39d29c571428c8a345e925", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZTdmYmU2MGI1M2U0ODZmZjM5ZDI5YzU3MTQyOGM4YTM0NWU5MjU=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-09-10T20:12:42Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-11-13T18:46:35Z"}, "message": "reduce syscalls by inferring FD types based on source struct instead of calling stat()\n\nalso adds handling for edge-cases involving large sparse files where sendfile could fail with EOVERFLOW", "tree": {"sha": "2d9b663b4581d9875074eec29eb6ab08823e859d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d9b663b4581d9875074eec29eb6ab08823e859d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46e7fbe60b53e486ff39d29c571428c8a345e925", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46e7fbe60b53e486ff39d29c571428c8a345e925", "html_url": "https://github.com/rust-lang/rust/commit/46e7fbe60b53e486ff39d29c571428c8a345e925", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46e7fbe60b53e486ff39d29c571428c8a345e925/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0624730d9e9e2b6de974b6f4edd1ea48ab5f240c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0624730d9e9e2b6de974b6f4edd1ea48ab5f240c", "html_url": "https://github.com/rust-lang/rust/commit/0624730d9e9e2b6de974b6f4edd1ea48ab5f240c"}], "stats": {"total": 251, "additions": 158, "deletions": 93}, "files": [{"sha": "31bfdb63386b56ae016a9107ff6c7b49c126de16", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 102, "deletions": 66, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/46e7fbe60b53e486ff39d29c571428c8a345e925/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46e7fbe60b53e486ff39d29c571428c8a345e925/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=46e7fbe60b53e486ff39d29c571428c8a345e925", "patch": "@@ -99,6 +99,7 @@ mod kernel_copy {\n     use crate::os::unix::fs::FileTypeExt;\n     use crate::os::unix::io::{AsRawFd, FromRawFd, RawFd};\n     use crate::process::{ChildStderr, ChildStdin, ChildStdout};\n+    use crate::sys::fs::{copy_regular_files, sendfile_splice, CopyResult, SpliceMode};\n \n     pub(super) fn copy_spec<R: Read + ?Sized, W: Write + ?Sized>(\n         read: &mut R,\n@@ -108,20 +109,55 @@ mod kernel_copy {\n         SpecCopy::copy(copier)\n     }\n \n+    /// This type represents either the inferred `FileType` of a `RawFd` based on the source\n+    /// type from which it was extracted or the actual metadata\n+    ///\n+    /// The methods on this type only provide hints, due to `AsRawFd` and `FromRawFd` the inferred\n+    /// type may be wrong.\n     enum FdMeta {\n+        /// We obtained the FD from a type that can contain any type of `FileType` and queried the metadata\n+        /// because it is cheaper than probing all possible syscalls (reader side)\n         Metadata(Metadata),\n         Socket,\n         Pipe,\n-        None,\n+        /// We don't have any metadata, e.g. because the original type was `File` which can represent\n+        /// any `FileType` and we did not query the metadata either since it did not seem beneficial\n+        /// (writer side)\n+        NoneObtained,\n     }\n \n     impl FdMeta {\n-        fn is_fifo(&self) -> bool {\n+        fn maybe_fifo(&self) -> bool {\n             match self {\n                 FdMeta::Metadata(meta) => meta.file_type().is_fifo(),\n                 FdMeta::Socket => false,\n                 FdMeta::Pipe => true,\n-                FdMeta::None => false,\n+                FdMeta::NoneObtained => true,\n+            }\n+        }\n+\n+        fn potential_sendfile_source(&self) -> bool {\n+            match self {\n+                // procfs erronously shows 0 length on non-empty readable files.\n+                // and if a file is truly empty then a `read` syscall will determine that and skip the write syscall\n+                // thus there would be benefit from attempting sendfile\n+                FdMeta::Metadata(meta)\n+                    if meta.file_type().is_file() && meta.len() > 0\n+                        || meta.file_type().is_block_device() =>\n+                {\n+                    true\n+                }\n+                _ => false,\n+            }\n+        }\n+\n+        fn copy_file_range_candidate(&self) -> bool {\n+            match self {\n+                // copy_file_range will fail on empty procfs files. `read` can determine whether EOF has been reached\n+                // without extra cost and skip the write, thus there is no benefit in attempting copy_file_range\n+                FdMeta::Metadata(meta) if meta.is_file() && meta.len() > 0 => true,\n+                FdMeta::NoneObtained => true,\n+                _ => false,\n             }\n         }\n     }\n@@ -149,66 +185,65 @@ mod kernel_copy {\n             let r_cfg = reader.properties();\n             let w_cfg = writer.properties();\n \n-            // before direct operations  on file descriptors ensure that all source and sink buffers are emtpy\n+            // before direct operations on file descriptors ensure that all source and sink buffers are emtpy\n             let mut flush = || -> crate::io::Result<u64> {\n                 let bytes = reader.drain_to(writer, u64::MAX)?;\n+                // BufWriter buffered bytes have already been accounted for in earlier write() calls\n                 writer.flush()?;\n                 Ok(bytes)\n             };\n \n-            match (r_cfg, w_cfg) {\n-                (\n-                    CopyParams(FdMeta::Metadata(reader_meta), Some(readfd)),\n-                    CopyParams(FdMeta::Metadata(writer_meta), Some(writefd)),\n-                ) if reader_meta.is_file() && writer_meta.is_file() => {\n-                    let bytes_flushed = flush()?;\n-                    let max_write = reader.min_limit();\n-                    let (mut reader, mut writer) =\n-                        unsafe { (fd_as_file(readfd), fd_as_file(writefd)) };\n-                    let len = reader_meta.len();\n-                    crate::sys::fs::copy_regular_files(\n-                        &mut reader,\n-                        &mut writer,\n-                        min(len, max_write),\n-                    )\n-                    .map(|bytes_copied| bytes_copied + bytes_flushed)\n+            let mut written = 0u64;\n+\n+            if let (CopyParams(input_meta, Some(readfd)), CopyParams(output_meta, Some(writefd))) =\n+                (r_cfg, w_cfg)\n+            {\n+                written += flush()?;\n+                let max_write = reader.min_limit();\n+\n+                if input_meta.copy_file_range_candidate() && output_meta.copy_file_range_candidate()\n+                {\n+                    let result = copy_regular_files(readfd, writefd, max_write);\n+\n+                    match result {\n+                        CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n+                        CopyResult::Ended(err) => return err,\n+                        CopyResult::Fallback(bytes) => written += bytes,\n+                    }\n                 }\n-                (\n-                    CopyParams(FdMeta::Metadata(reader_meta), Some(readfd)),\n-                    CopyParams(_, Some(writefd)),\n-                ) if reader_meta.is_file() => {\n-                    // try sendfile, most modern systems it should work with any target as long as the source is a mmapable file.\n-                    // in the rare cases where it's no supported the wrapper function will fall back to a normal copy loop\n-                    let bytes_flushed = flush()?;\n-                    let (mut reader, mut writer) =\n-                        unsafe { (fd_as_file(readfd), fd_as_file(writefd)) };\n-                    let len = reader_meta.len();\n-                    let max_write = reader.min_limit();\n-                    crate::sys::fs::sendfile_splice(\n-                        crate::sys::fs::SpliceMode::Sendfile,\n-                        &mut reader,\n-                        &mut writer,\n-                        min(len, max_write),\n-                    )\n-                        .map(|bytes_sent| bytes_sent + bytes_flushed)\n+\n+                // on modern kernels sendfile can copy from any mmapable type (some but not all regular files and block devices)\n+                // to any writable file descriptor. On older kernels the writer side can only be a socket.\n+                // So we just try and fallback if needed.\n+                // If current file offsets + write sizes overflow it may also fail, we do not try to fix that and instead\n+                // fall back to the generic copy loop.\n+                if input_meta.potential_sendfile_source() {\n+                    let result = sendfile_splice(SpliceMode::Sendfile, readfd, writefd, max_write);\n+\n+                    match result {\n+                        CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n+                        CopyResult::Ended(err) => return err,\n+                        CopyResult::Fallback(bytes) => written += bytes,\n+                    }\n                 }\n-                (CopyParams(reader_meta, Some(readfd)), CopyParams(writer_meta, Some(writefd)))\n-                    if reader_meta.is_fifo() || writer_meta.is_fifo() =>\n-                {\n-                    // splice\n-                    let bytes_flushed = flush()?;\n-                    let max_write = reader.min_limit();\n-                    let (mut reader, mut writer) =\n-                        unsafe { (fd_as_file(readfd), fd_as_file(writefd)) };\n-                    crate::sys::fs::sendfile_splice(\n-                        crate::sys::fs::SpliceMode::Splice,\n-                        &mut reader,\n-                        &mut writer,\n-                        max_write,\n-                    )\n-                    .map(|bytes_sent| bytes_sent + bytes_flushed)\n+\n+                if input_meta.maybe_fifo() || output_meta.maybe_fifo() {\n+                    let result = sendfile_splice(SpliceMode::Splice, readfd, writefd, max_write);\n+\n+                    match result {\n+                        CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n+                        CopyResult::Ended(err) => return err,\n+                        CopyResult::Fallback(0) => { /* use fallback */ }\n+                        CopyResult::Fallback(_) => {\n+                            unreachable!(\"splice should not return > 0 bytes on the fallback path\")\n+                        }\n+                    }\n                 }\n-                _ => super::generic_copy(reader, writer),\n+            }\n+\n+            match super::generic_copy(reader, writer) {\n+                Ok(bytes) => Ok(bytes + written),\n+                err => err,\n             }\n         }\n     }\n@@ -235,7 +270,10 @@ mod kernel_copy {\n         fn properties(&self) -> CopyParams;\n     }\n \n-    impl<T> CopyRead for &mut T where T: CopyRead {\n+    impl<T> CopyRead for &mut T\n+    where\n+        T: CopyRead,\n+    {\n         fn drain_to<W: Write>(&mut self, writer: &mut W, limit: u64) -> Result<u64> {\n             (**self).drain_to(writer, limit)\n         }\n@@ -249,13 +287,15 @@ mod kernel_copy {\n         }\n     }\n \n-    impl<T> CopyWrite for &mut T where T: CopyWrite {\n+    impl<T> CopyWrite for &mut T\n+    where\n+        T: CopyWrite,\n+    {\n         fn properties(&self) -> CopyParams {\n             (**self).properties()\n         }\n     }\n \n-\n     impl CopyRead for File {\n         fn properties(&self) -> CopyParams {\n             CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n@@ -270,13 +310,13 @@ mod kernel_copy {\n \n     impl CopyWrite for File {\n         fn properties(&self) -> CopyParams {\n-            CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n+            CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n         }\n     }\n \n     impl CopyWrite for &File {\n         fn properties(&self) -> CopyParams {\n-            CopyParams(fd_to_meta(*self), Some(self.as_raw_fd()))\n+            CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n         }\n     }\n \n@@ -345,13 +385,13 @@ mod kernel_copy {\n \n     impl CopyWrite for StdoutLock<'_> {\n         fn properties(&self) -> CopyParams {\n-            CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n+            CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n         }\n     }\n \n     impl CopyWrite for StderrLock<'_> {\n         fn properties(&self) -> CopyParams {\n-            CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n+            CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n         }\n     }\n \n@@ -411,11 +451,7 @@ mod kernel_copy {\n         let file: ManuallyDrop<File> = ManuallyDrop::new(unsafe { File::from_raw_fd(fd) });\n         match file.metadata() {\n             Ok(meta) => FdMeta::Metadata(meta),\n-            Err(_) => FdMeta::None,\n+            Err(_) => FdMeta::NoneObtained,\n         }\n     }\n-\n-    unsafe fn fd_as_file(fd: RawFd) -> ManuallyDrop<File> {\n-        ManuallyDrop::new(File::from_raw_fd(fd))\n-    }\n }"}, {"sha": "0bab95053a499f33112d19e876a7720eb19d448b", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/46e7fbe60b53e486ff39d29c571428c8a345e925/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46e7fbe60b53e486ff39d29c571428c8a345e925/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=46e7fbe60b53e486ff39d29c571428c8a345e925", "patch": "@@ -1195,17 +1195,26 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     let max_len = u64::MAX;\n     let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;\n \n-    copy_regular_files(&mut reader, &mut writer, max_len)\n+    return match copy_regular_files(reader.as_raw_fd(), writer.as_raw_fd(), max_len) {\n+        CopyResult::Ended(result) => result,\n+        CopyResult::Fallback(written) => {\n+            // fallback is only > 0 on EOVERFLOW, which shouldn't happen\n+            // because the copy loop starts at a file offset 0 and countns down from `len`\n+            assert_eq!(0, written);\n+            io::copy::generic_copy(&mut reader, &mut writer)\n+        }\n+    };\n }\n \n /// linux-specific implementation that will attempt to use copy_file_range for copy offloading\n /// as the name says, it only works on regular files\n+///\n+/// Callers must handle fallback to a generic copy loop.\n+/// `Fallback` may indicate non-zero number of bytes already written\n+/// if one of the files' cursor +`max_len` would exceed u64::MAX (`EOVERFLOW`).\n+/// If the initial file offset was 0 then `Fallback` will only contain `0`.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub(crate) fn copy_regular_files(\n-    reader: &mut crate::fs::File,\n-    writer: &mut crate::fs::File,\n-    max_len: u64,\n-) -> io::Result<u64> {\n+pub(crate) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) -> CopyResult {\n     use crate::cmp;\n     use crate::sync::atomic::{AtomicBool, Ordering};\n \n@@ -1228,14 +1237,18 @@ pub(crate) fn copy_regular_files(\n     let mut written = 0u64;\n     while written < max_len {\n         let copy_result = if has_copy_file_range {\n-            let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64) as usize;\n+            let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64);\n+            // cap to 2GB chunks in case u64::MAX is passed in as file size and the file has a non-zero offset\n+            // this allows us to copy large chunks without hitting the limit,\n+            // unless someone sets a file offset close to u64::MAX - 2GB, in which case the fallback would kick in\n+            let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x8000_0000usize);\n             let copy_result = unsafe {\n                 // We actually don't have to adjust the offsets,\n                 // because copy_file_range adjusts the file offset automatically\n                 cvt(copy_file_range(\n-                    reader.as_raw_fd(),\n+                    reader,\n                     ptr::null_mut(),\n-                    writer.as_raw_fd(),\n+                    writer,\n                     ptr::null_mut(),\n                     bytes_to_copy,\n                     0,\n@@ -1260,12 +1273,14 @@ pub(crate) fn copy_regular_files(\n                 // - reading virtual files from the proc filesystem which appear to have 0 size\n                 //   but are not empty. noted in coreutils to affect kernels at least up to 5.6.19.\n                 // - copying from an overlay filesystem in docker. reported to occur on fedora 32.\n-                return io::copy(reader, writer);\n+                return CopyResult::Fallback(0);\n             }\n-            Ok(0) => return Ok(written), // reached EOF\n+            Ok(0) => return CopyResult::Ended(Ok(written)), // reached EOF\n             Ok(ret) => written += ret as u64,\n             Err(err) => {\n                 match err.raw_os_error() {\n+                    // when file offset + max_length > u64::MAX\n+                    Some(libc::EOVERFLOW) => return CopyResult::Fallback(written),\n                     Some(\n                         libc::ENOSYS | libc::EXDEV | libc::EINVAL | libc::EPERM | libc::EOPNOTSUPP,\n                     ) => {\n@@ -1276,43 +1291,55 @@ pub(crate) fn copy_regular_files(\n                         // - copy_file_range is disallowed, for example by seccomp (EPERM)\n                         // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n                         assert_eq!(written, 0);\n-                        return io::copy::generic_copy(reader, writer);\n+                        return CopyResult::Fallback(0);\n                     }\n-                    _ => return Err(err),\n+                    _ => return CopyResult::Ended(Err(err)),\n                 }\n             }\n         }\n     }\n-    Ok(written)\n+    CopyResult::Ended(Ok(written))\n }\n \n+#[derive(PartialEq)]\n pub(crate) enum SpliceMode {\n     Sendfile,\n     Splice,\n }\n \n+pub(crate) enum CopyResult {\n+    Ended(io::Result<u64>),\n+    Fallback(u64),\n+}\n+\n /// performs splice or sendfile between file descriptors\n+/// Does _not_ fall back to a generic copy loop.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub(crate) fn sendfile_splice(\n     mode: SpliceMode,\n-    reader: &mut crate::fs::File,\n-    writer: &mut crate::fs::File,\n+    reader: RawFd,\n+    writer: RawFd,\n     len: u64,\n-) -> io::Result<u64> {\n+) -> CopyResult {\n     let mut written = 0u64;\n     while written < len {\n         let chunk_size = crate::cmp::min(len - written, 0x7ffff000_u64) as usize;\n \n         let result = match mode {\n-            SpliceMode::Sendfile => cvt(unsafe {\n-                libc::sendfile(writer.as_raw_fd(), reader.as_raw_fd(), ptr::null_mut(), chunk_size)\n-            }),\n+            SpliceMode::Sendfile => {\n+                cvt(unsafe { libc::sendfile(writer, reader, ptr::null_mut(), chunk_size) })\n+            }\n             SpliceMode::Splice => cvt(unsafe {\n                 libc::splice(\n-                    reader.as_raw_fd(),\n+                    reader,\n                     ptr::null_mut(),\n-                    writer.as_raw_fd(),\n+                    writer,\n                     ptr::null_mut(),\n+                    // default pipe size is 64KiB. try to only fill/drain half of that capacity\n+                    // so that the next loop iteration won't be put to sleep.\n+                    // If reader and writer operate at the same pace they will experience fewer blocking waits.\n+                    // This is only needed for splice since sendfile stays in kernel space when it has to block.\n+                    //crate::cmp::min(32*1024, chunk_size),\n                     chunk_size,\n                     0,\n                 )\n@@ -1325,17 +1352,19 @@ pub(crate) fn sendfile_splice(\n             Err(err) => {\n                 match err.raw_os_error() {\n                     Some(os_err) if os_err == libc::EINVAL => {\n-                        // Try fallback io::copy if splice/sendfile do not support this particular\n-                        // file descritor (EINVAL)\n+                        // splice/sendfile do not support this particular file descritor (EINVAL)\n                         assert_eq!(written, 0);\n-                        return io::copy::generic_copy(reader, writer);\n+                        return CopyResult::Fallback(0);\n+                    }\n+                    Some(os_err) if mode == SpliceMode::Sendfile && os_err == libc::EOVERFLOW => {\n+                        return CopyResult::Fallback(written);\n                     }\n-                    _ => return Err(err),\n+                    _ => return CopyResult::Ended(Err(err)),\n                 }\n             }\n         }\n     }\n-    Ok(written)\n+    CopyResult::Ended(Ok(written))\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]"}]}