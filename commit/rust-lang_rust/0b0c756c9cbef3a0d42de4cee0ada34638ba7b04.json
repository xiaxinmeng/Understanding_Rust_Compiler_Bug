{"sha": "0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMGM3NTZjOWNiZWYzYTBkNDJkZTRjZWUwYWRhMzQ2MzhiYTdiMDQ=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-16T11:11:17Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-22T00:38:40Z"}, "message": "Fix warnings in trans", "tree": {"sha": "c071bde0acaaa4f47f13a3520525408194371b01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c071bde0acaaa4f47f13a3520525408194371b01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "html_url": "https://github.com/rust-lang/rust/commit/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/comments", "author": null, "committer": null, "parents": [{"sha": "81cf72c264efae4a16616ba6fc998ae862068d8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/81cf72c264efae4a16616ba6fc998ae862068d8b", "html_url": "https://github.com/rust-lang/rust/commit/81cf72c264efae4a16616ba6fc998ae862068d8b"}], "stats": {"total": 393, "additions": 166, "deletions": 227}, "files": [{"sha": "4bc96117ff51aa7ae63a5144910ce9f59be73f41", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -13,9 +13,7 @@ use core::prelude::*;\n use core::hashmap::HashMap;\n use core::libc::{c_uint, c_ushort};\n use core::option;\n-use core::ptr;\n use core::str;\n-use core::vec;\n \n use middle::trans::type_::Type;\n "}, {"sha": "b94442c85ef7d10e83cc660d17471fb30aad9cf5", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -30,7 +30,7 @@ use back::{link, abi};\n use driver::session;\n use driver::session::Session;\n use lib::llvm::{ContextRef, ModuleRef, ValueRef, BasicBlockRef};\n-use lib::llvm::{llvm, True, False};\n+use lib::llvm::{llvm, True};\n use lib;\n use metadata::common::LinkMeta;\n use metadata::{csearch, cstore, encoder};\n@@ -1462,7 +1462,7 @@ pub fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) {\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n+pub fn memzero(cx: block, llptr: ValueRef, ty: Type) {\n     let _icx = cx.insn_ctxt(\"memzero\");\n     let ccx = cx.ccx();\n \n@@ -1493,7 +1493,7 @@ pub fn alloca(cx: block, ty: Type) -> ValueRef {\n     alloca_maybe_zeroed(cx, ty, false)\n }\n \n-pub fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n+pub fn alloca_maybe_zeroed(cx: block, ty: Type, zero: bool) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"alloca\");\n     if cx.unreachable {\n         unsafe {\n@@ -1506,7 +1506,7 @@ pub fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n     p\n }\n \n-pub fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n+pub fn arrayalloca(cx: block, ty: Type, v: ValueRef) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"arrayalloca\");\n     if cx.unreachable {\n         unsafe {\n@@ -2885,8 +2885,7 @@ pub fn write_metadata(cx: &mut CrateContext, crate: &ast::crate) {\n \n // Writes the current ABI version into the crate.\n pub fn write_abi_version(ccx: &mut CrateContext) {\n-    mk_global(ccx, \"rust_abi_version\", C_uint(ccx, abi::abi_version),\n-                     false);\n+    mk_global(ccx, \"rust_abi_version\", C_uint(ccx, abi::abi_version), false);\n }\n \n pub fn trans_crate(sess: session::Session,"}, {"sha": "f1ccfba5b30d8299a9d89ada4d0a5f4118ecff71", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -22,8 +22,8 @@ use syntax::codemap::span;\n use middle::trans::type_::Type;\n \n use core::cast;\n-use core::hashmap::HashMap;\n use core::libc::{c_uint, c_ulonglong, c_char};\n+use core::hashmap::HashMap;\n use core::str;\n use core::vec;\n \n@@ -619,15 +619,12 @@ pub fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     return InBoundsGEP(cx, base, v);\n }\n \n-pub fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) ->\n-   ValueRef {\n+pub fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         count_insn(cx, \"inboundsgep\");\n-        return llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n-                                           vec::raw::to_ptr(Indices),\n-                                           Indices.len() as c_uint,\n-                                           noname());\n+        return llvm::LLVMBuildInBoundsGEP(\n+            B(cx), Pointer, vec::raw::to_ptr(Indices), Indices.len() as c_uint, noname());\n     }\n }\n \n@@ -1077,8 +1074,7 @@ pub fn Trap(cx: block) {\n         assert!((T as int != 0));\n         let Args: ~[ValueRef] = ~[];\n         count_insn(cx, \"trap\");\n-        llvm::LLVMBuildCall(b, T, vec::raw::to_ptr(Args),\n-                            Args.len() as c_uint, noname());\n+        llvm::LLVMBuildCall(b, T, vec::raw::to_ptr(Args), Args.len() as c_uint, noname());\n     }\n }\n \n@@ -1088,8 +1084,8 @@ pub fn LandingPad(cx: block, Ty: Type, PersFn: ValueRef,\n         check_not_terminated(cx);\n         assert!(!cx.unreachable);\n         count_insn(cx, \"landingpad\");\n-        return llvm::LLVMBuildLandingPad(B(cx), Ty.to_ref(), PersFn,\n-                                      NumClauses as c_uint, noname());\n+        return llvm::LLVMBuildLandingPad(\n+            B(cx), Ty.to_ref(), PersFn, NumClauses as c_uint, noname());\n     }\n }\n "}, {"sha": "2f4579afe9c1f0cf997dff25c3b0ff9e10251d7c", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -10,7 +10,6 @@\n \n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::{Attribute, StructRetAttribute};\n-use lib::llvm::True;\n use middle::trans::cabi::{ABIInfo, FnType, LLVMType};\n \n use middle::trans::type_::Type;\n@@ -116,14 +115,12 @@ fn classify_arg_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n }\n \n fn is_reg_ty(ty: Type) -> bool {\n-    unsafe {\n-        match ty.kind() {\n-            Integer\n-            | Pointer\n-            | Float\n-            | Double => true,\n-            _ => false\n-        }\n+    match ty.kind() {\n+        Integer\n+        | Pointer\n+        | Float\n+        | Double => true,\n+        _ => false\n     }\n }\n "}, {"sha": "ab5296b0c7a02910156d0294dfd71dc524bb15ee", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -11,14 +11,11 @@\n use core::prelude::*;\n \n use core::libc::c_uint;\n-use core::ptr;\n use core::uint;\n use core::vec;\n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::{Attribute, StructRetAttribute};\n-use lib::llvm::True;\n use middle::trans::context::task_llcx;\n-use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n use middle::trans::type_::Type;\n@@ -122,15 +119,13 @@ fn classify_arg_ty(ty: Type, offset: &mut uint) -> (LLVMType, Option<Attribute>)\n }\n \n fn is_reg_ty(ty: Type) -> bool {\n-    unsafe {\n-        return match ty.kind() {\n-            Integer\n-            | Pointer\n-            | Float\n-            | Double => true,\n-            _ => false\n-        };\n-    }\n+    return match ty.kind() {\n+        Integer\n+        | Pointer\n+        | Float\n+        | Double => true,\n+        _ => false\n+    };\n }\n \n fn padding_ty(align: uint, offset: uint) -> Option<Type> {"}, {"sha": "e2f4cef5a111166e84772347adbad35e82ccf1e4", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -12,7 +12,6 @@ use core::prelude::*;\n \n use driver::session::{os_win32, os_macos};\n use lib::llvm::*;\n-use lib::llvm::llvm::*;\n use super::cabi::*;\n use super::common::*;\n use super::machine::*;\n@@ -43,7 +42,7 @@ impl ABIInfo for X86_ABIInfo {\n         // http://www.angelcode.com/dev/callconv/callconv.html\n         // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n         let sret = {\n-            let returning_a_struct = unsafe { rty.kind() == Struct && ret_def };\n+            let returning_a_struct = rty.kind() == Struct && ret_def;\n             let big_struct = match self.ccx.sess.targ_cfg.os {\n                 os_win32 | os_macos => llsize_of_alloc(self.ccx, rty) > 8,\n                 _ => true"}, {"sha": "4a92b940190a4c37d90c975cca9e3e706f2088c6", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 98, "deletions": 107, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -14,13 +14,10 @@\n use lib::llvm::{llvm, Integer, Pointer, Float, Double};\n use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute, ByValAttribute};\n-use lib::llvm::True;\n-use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n use middle::trans::type_::Type;\n \n-use core::libc::c_uint;\n use core::option;\n use core::option::Option;\n use core::uint;\n@@ -189,98 +186,94 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n     fn classify(ty: Type,\n                 cls: &mut [RegClass], ix: uint,\n                 off: uint) {\n-        unsafe {\n-            let t_align = ty_align(ty);\n-            let t_size = ty_size(ty);\n-\n-            let misalign = off % t_align;\n-            if misalign != 0u {\n-                let mut i = off / 8u;\n-                let e = (off + t_size + 7u) / 8u;\n-                while i < e {\n-                    unify(cls, ix + i, Memory);\n-                    i += 1u;\n-                }\n-                return;\n+        let t_align = ty_align(ty);\n+        let t_size = ty_size(ty);\n+\n+        let misalign = off % t_align;\n+        if misalign != 0u {\n+            let mut i = off / 8u;\n+            let e = (off + t_size + 7u) / 8u;\n+            while i < e {\n+                unify(cls, ix + i, Memory);\n+                i += 1u;\n             }\n+            return;\n+        }\n \n-            match ty.kind() {\n-                Integer |\n-                Pointer => {\n-                    unify(cls, ix + off / 8u, Int);\n-                }\n-                Float => {\n-                    if off % 8u == 4u {\n-                        unify(cls, ix + off / 8u, SSEFv);\n-                    } else {\n-                        unify(cls, ix + off / 8u, SSEFs);\n-                    }\n-                }\n-                Double => {\n-                    unify(cls, ix + off / 8u, SSEDs);\n-                }\n-                Struct => {\n-                    classify_struct(ty.field_types(), cls, ix, off);\n+        match ty.kind() {\n+            Integer |\n+            Pointer => {\n+                unify(cls, ix + off / 8u, Int);\n+            }\n+            Float => {\n+                if off % 8u == 4u {\n+                    unify(cls, ix + off / 8u, SSEFv);\n+                } else {\n+                    unify(cls, ix + off / 8u, SSEFs);\n                 }\n-                Array => {\n-                    let len = ty.array_length();\n-                    let elt = ty.element_type();\n-                    let eltsz = ty_size(elt);\n-                    let mut i = 0u;\n-                    while i < len {\n-                        classify(elt, cls, ix, off + i * eltsz);\n-                        i += 1u;\n-                    }\n+            }\n+            Double => {\n+                unify(cls, ix + off / 8u, SSEDs);\n+            }\n+            Struct => {\n+                classify_struct(ty.field_types(), cls, ix, off);\n+            }\n+            Array => {\n+                let len = ty.array_length();\n+                let elt = ty.element_type();\n+                let eltsz = ty_size(elt);\n+                let mut i = 0u;\n+                while i < len {\n+                    classify(elt, cls, ix, off + i * eltsz);\n+                    i += 1u;\n                 }\n-                _ => fail!(\"classify: unhandled type\")\n             }\n+            _ => fail!(\"classify: unhandled type\")\n         }\n     }\n \n     fn fixup(ty: Type, cls: &mut [RegClass]) {\n-        unsafe {\n-            let mut i = 0u;\n-            let ty_kind = ty.kind();\n-            let e = cls.len();\n-            if cls.len() > 2u &&\n-               (ty_kind == Struct ||\n-                ty_kind == Array) {\n-                if cls[i].is_sse() {\n-                    i += 1u;\n-                    while i < e {\n-                        if cls[i] != SSEUp {\n-                            all_mem(cls);\n-                            return;\n-                        }\n-                        i += 1u;\n-                    }\n-                } else {\n-                    all_mem(cls);\n-                    return\n-                }\n-            } else {\n+        let mut i = 0u;\n+        let ty_kind = ty.kind();\n+        let e = cls.len();\n+        if cls.len() > 2u &&\n+           (ty_kind == Struct ||\n+            ty_kind == Array) {\n+            if cls[i].is_sse() {\n+                i += 1u;\n                 while i < e {\n-                    if cls[i] == Memory {\n+                    if cls[i] != SSEUp {\n                         all_mem(cls);\n                         return;\n                     }\n-                    if cls[i] == X87Up {\n-                        // for darwin\n-                        // cls[i] = SSEDs;\n-                        all_mem(cls);\n-                        return;\n-                    }\n-                    if cls[i] == SSEUp {\n-                        cls[i] = SSEInt;\n-                    } else if cls[i].is_sse() {\n-                        i += 1;\n-                        while i != e && cls[i] == SSEUp { i += 1u; }\n-                    } else if cls[i] == X87 {\n-                        i += 1;\n-                        while i != e && cls[i] == X87Up { i += 1u; }\n-                    } else {\n-                        i += 1;\n-                    }\n+                    i += 1u;\n+                }\n+            } else {\n+                all_mem(cls);\n+                return\n+            }\n+        } else {\n+            while i < e {\n+                if cls[i] == Memory {\n+                    all_mem(cls);\n+                    return;\n+                }\n+                if cls[i] == X87Up {\n+                    // for darwin\n+                    // cls[i] = SSEDs;\n+                    all_mem(cls);\n+                    return;\n+                }\n+                if cls[i] == SSEUp {\n+                    cls[i] = SSEInt;\n+                } else if cls[i].is_sse() {\n+                    i += 1;\n+                    while i != e && cls[i] == SSEUp { i += 1u; }\n+                } else if cls[i] == X87 {\n+                    i += 1;\n+                    while i != e && cls[i] == X87Up { i += 1u; }\n+                } else {\n+                    i += 1;\n                 }\n             }\n         }\n@@ -310,34 +303,32 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n         return len;\n     }\n \n-    unsafe {\n-        let mut tys = ~[];\n-        let mut i = 0u;\n-        let e = cls.len();\n-        while i < e {\n-            match cls[i] {\n-                Int => {\n-                    tys.push(Type::i64());\n-                }\n-                SSEFv => {\n-                    let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n-                    let vec_ty = Type::vector(&Type::f32(), vec_len as u64);\n-                    tys.push(vec_ty);\n-                    i += vec_len;\n-                    loop;\n-                }\n-                SSEFs => {\n-                    tys.push(Type::f32());\n-                }\n-                SSEDs => {\n-                    tys.push(Type::f64());\n-                }\n-                _ => fail!(\"llregtype: unhandled class\")\n+    let mut tys = ~[];\n+    let mut i = 0u;\n+    let e = cls.len();\n+    while i < e {\n+        match cls[i] {\n+            Int => {\n+                tys.push(Type::i64());\n+            }\n+            SSEFv => {\n+                let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n+                let vec_ty = Type::vector(&Type::f32(), vec_len as u64);\n+                tys.push(vec_ty);\n+                i += vec_len;\n+                loop;\n+            }\n+            SSEFs => {\n+                tys.push(Type::f32());\n+            }\n+            SSEDs => {\n+                tys.push(Type::f64());\n             }\n-            i += 1u;\n+            _ => fail!(\"llregtype: unhandled class\")\n         }\n-        return Type::struct_(tys, false);\n+        i += 1u;\n     }\n+    return Type::struct_(tys, false);\n }\n \n fn x86_64_tys(atys: &[Type],"}, {"sha": "c8b5b00d62460808d093e9e932baff6c94409de7", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -12,18 +12,16 @@\n \n use core::prelude::*;\n \n-use back::{abi};\n use driver::session;\n use driver::session::Session;\n-use lib::llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n+use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef};\n use lib::llvm::{True, False, Bool};\n-use lib::llvm::{llvm, TypeNames};\n+use lib::llvm::{llvm};\n use lib;\n use middle::trans::base;\n use middle::trans::build;\n use middle::trans::datum;\n use middle::trans::glue;\n-use middle::trans::type_of;\n use middle::trans::write_guard;\n use middle::ty::substs;\n use middle::ty;\n@@ -37,16 +35,13 @@ use core::cast::transmute;\n use core::cast;\n use core::hashmap::{HashMap};\n use core::libc::{c_uint, c_longlong, c_ulonglong};\n-use core::str;\n use core::to_bytes;\n-use core::vec::raw::to_ptr;\n use core::vec;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt};\n use syntax::codemap::span;\n use syntax::parse::token;\n use syntax::{ast, ast_map};\n-use syntax::abi::{X86, X86_64, Arm, Mips};\n \n pub use middle::trans::context::CrateContext;\n "}, {"sha": "b688ca66c2b323f085489ccbc9bf092f1b6503c8", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -11,8 +11,7 @@\n use core::prelude::*;\n \n use back::abi;\n-use lib::llvm::{llvm, ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool,\n-    True, False};\n+use lib::llvm::{llvm, ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool, True};\n use lib::llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, IntSLT, IntSLE,\n     RealOEQ, RealOGT, RealOGE, RealOLT, RealOLE, RealONE};\n "}, {"sha": "ee6ead72c1e0a2de1a83aaa4fc8e636ee3c96fc4", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -15,7 +15,6 @@ use driver::session;\n use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n use lib::llvm::{llvm, TargetData, TypeNames};\n use lib::llvm::{mk_target_data};\n-use lib;\n use metadata::common::LinkMeta;\n use middle::astencode;\n use middle::resolve;"}, {"sha": "43d434b9d33dd6eacebad8bb1088220ce139cf4a", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -693,7 +693,7 @@ fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: ui\n }\n \n /// Set current debug location at the beginning of the span\n-pub fn update_source_pos(bcx: block, span: span) {\n+pub fn update_source_pos(bcx: @mut Block, span: span) {\n     if !bcx.sess().opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n         return;\n     }"}, {"sha": "913a857e0fb903ebc8123cb3eca7a853e0046031", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -217,23 +217,21 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     tie_up_header_blocks(fcx, lltop);\n \n     // Then return according to the C ABI.\n-    unsafe {\n-        let return_context = raw_block(fcx, false, fcx.llreturn);\n-\n-        let llfunctiontype = val_ty(llwrapfn);\n-        let llfunctiontype = llfunctiontype.element_type();\n-        let return_type = llfunctiontype.return_type();\n-        if return_type.kind() == ::lib::llvm::Void {\n-            // XXX: This might be wrong if there are any functions for which\n-            // the C ABI specifies a void output pointer and the Rust ABI\n-            // does not.\n-            RetVoid(return_context);\n-        } else {\n-            // Cast if we have to...\n-            // XXX: This is ugly.\n-            let llretptr = BitCast(return_context, fcx.llretptr.get(), return_type.ptr_to());\n-            Ret(return_context, Load(return_context, llretptr));\n-        }\n+    let return_context = raw_block(fcx, false, fcx.llreturn);\n+\n+    let llfunctiontype = val_ty(llwrapfn);\n+    let llfunctiontype = llfunctiontype.element_type();\n+    let return_type = llfunctiontype.return_type();\n+    if return_type.kind() == ::lib::llvm::Void {\n+        // XXX: This might be wrong if there are any functions for which\n+        // the C ABI specifies a void output pointer and the Rust ABI\n+        // does not.\n+        RetVoid(return_context);\n+    } else {\n+        // Cast if we have to...\n+        // XXX: This is ugly.\n+        let llretptr = BitCast(return_context, fcx.llretptr.get(), return_type.ptr_to());\n+        Ret(return_context, Load(return_context, llretptr));\n     }\n }\n "}, {"sha": "6fcab95996e8de5c3216238ccb42641ba2573c3b", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -10,7 +10,7 @@\n \n // Information concerning the machine representation of various types.\n \n-use lib::llvm::{ValueRef, TypeRef};\n+use lib::llvm::{ValueRef};\n use lib::llvm::False;\n use lib::llvm::llvm;\n use middle::trans::common::*;"}, {"sha": "4118291dca0d6875529a60d03a164682138bd793", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -15,7 +15,6 @@\n use lib::llvm::llvm;\n use lib::llvm::{True, ModuleRef, ValueRef};\n use middle::trans::common::*;\n-use middle::trans;\n \n use middle::trans::type_::Type;\n \n@@ -62,16 +61,3 @@ pub fn mk_ctxt(llmod: ModuleRef) -> Ctxt {\n         }\n     }\n }\n-\n-/*\n-Although these two functions are never called, they are here\n-for a VERY GOOD REASON. See #3670\n-pub fn add_u16(dest: &mut ~[u8], val: u16) {\n-    *dest += [(val & 0xffu16) as u8, (val >> 8u16) as u8];\n-}\n-\n-pub fn add_substr(dest: &mut ~[u8], src: ~[u8]) {\n-    add_u16(&mut *dest, src.len() as u16);\n-    *dest += src;\n-}\n-*/"}, {"sha": "34a15033109129d69a0d1bbd276baf83da9dfca0", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -350,9 +350,7 @@ impl Type {\n     }\n \n     pub fn return_type(&self) -> Type {\n-        unsafe {\n-            ty!(llvm::LLVMGetReturnType(self.to_ref()))\n-        }\n+        ty!(llvm::LLVMGetReturnType(self.to_ref()))\n     }\n \n     pub fn func_params(&self) -> ~[Type] {"}, {"sha": "5b85209219cd1ad682ff0050d6b9e0b9fbaa9fef", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 21, "deletions": 32, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0c756c9cbef3a0d42de4cee0ada34638ba7b04/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=0b0c756c9cbef3a0d42de4cee0ada34638ba7b04", "patch": "@@ -10,11 +10,8 @@\n \n use core::prelude::*;\n \n-use lib::llvm::llvm;\n use middle::trans::adt;\n-use middle::trans::base;\n use middle::trans::common::*;\n-use middle::trans::common;\n use middle::ty;\n use util::ppaux;\n \n@@ -40,36 +37,28 @@ pub fn type_of_explicit_args(ccx: &mut CrateContext,\n     inputs.map(|arg_ty| type_of_explicit_arg(ccx, arg_ty))\n }\n \n-pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t)\n-               -> Type {\n-    unsafe {\n-        let mut atys: ~[Type] = ~[];\n-\n-        // Arg 0: Output pointer.\n-        // (if the output type is non-immediate)\n-        let output_is_immediate = ty::type_is_immediate(output);\n-        let lloutputtype = type_of(cx, output);\n-        if !output_is_immediate {\n-            atys.push(lloutputtype.ptr_to());\n-        }\n+pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t) -> Type {\n+    let mut atys: ~[Type] = ~[];\n \n-        // Arg 1: Environment\n-        atys.push(Type::opaque_box(cx).ptr_to());\n-\n-        // ... then explicit args.\n-        atys.push_all(type_of_explicit_args(cx, inputs));\n-\n-        // Use the output as the actual return value if it's immediate.\n-<<<<<<< HEAD\n-        if output_is_immediate && !ty::type_is_nil(output) {\n-            Type::func(atys, lloutputtype)\n-=======\n-        if output_is_immediate {\n-            Type::func(atys, &lloutputtype)\n->>>>>>> Finish up Type refactoring\n-        } else {\n-            Type::func(atys, &Type::void())\n-        }\n+    // Arg 0: Output pointer.\n+    // (if the output type is non-immediate)\n+    let output_is_immediate = ty::type_is_immediate(output);\n+    let lloutputtype = type_of(cx, output);\n+    if !output_is_immediate {\n+        atys.push(lloutputtype.ptr_to());\n+    }\n+\n+    // Arg 1: Environment\n+    atys.push(Type::opaque_box(cx).ptr_to());\n+\n+    // ... then explicit args.\n+    atys.push_all(type_of_explicit_args(cx, inputs));\n+\n+    // Use the output as the actual return value if it's immediate.\n+    if output_is_immediate && !ty::type_is_nil(output) {\n+        Type::func(atys, &lloutputtype)\n+    } else {\n+        Type::func(atys, &Type::void())\n     }\n }\n "}]}