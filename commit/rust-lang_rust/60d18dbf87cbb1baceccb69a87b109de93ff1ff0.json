{"sha": "60d18dbf87cbb1baceccb69a87b109de93ff1ff0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwZDE4ZGJmODdjYmIxYmFjZWNjYjY5YTg3YjEwOWRlOTNmZjFmZjA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-07-15T19:03:52Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-07-15T19:03:52Z"}, "message": "handle all foreign items like we handle C ABI shims", "tree": {"sha": "66654b397821ed3bcd7a1a644bd5b64909e2afff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66654b397821ed3bcd7a1a644bd5b64909e2afff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60d18dbf87cbb1baceccb69a87b109de93ff1ff0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60d18dbf87cbb1baceccb69a87b109de93ff1ff0", "html_url": "https://github.com/rust-lang/rust/commit/60d18dbf87cbb1baceccb69a87b109de93ff1ff0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60d18dbf87cbb1baceccb69a87b109de93ff1ff0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe4f62ab4ab8a0eb522436dc7562a253183e865e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe4f62ab4ab8a0eb522436dc7562a253183e865e", "html_url": "https://github.com/rust-lang/rust/commit/fe4f62ab4ab8a0eb522436dc7562a253183e865e"}], "stats": {"total": 167, "additions": 83, "deletions": 84}, "files": [{"sha": "8105330b3263ed209dd8238a30078cec16e27df9", "filename": "src/fn_call.rs", "status": "modified", "additions": 83, "deletions": 84, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/60d18dbf87cbb1baceccb69a87b109de93ff1ff0/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60d18dbf87cbb1baceccb69a87b109de93ff1ff0/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=60d18dbf87cbb1baceccb69a87b109de93ff1ff0", "patch": "@@ -3,7 +3,6 @@ use rustc::ty::layout::{self, Align, LayoutOf, Size};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_target::spec::abi::Abi;\n use syntax::attr;\n use syntax::codemap::Span;\n \n@@ -60,7 +59,7 @@ fn write_discriminant_value<'a, 'mir, 'tcx: 'a + 'mir>(\n     }\n \n pub trait EvalContextExt<'tcx> {\n-    fn call_c_abi(\n+    fn call_foreign_item(\n         &mut self,\n         def_id: DefId,\n         args: &[ValTy<'tcx>],\n@@ -105,9 +104,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n \n         let def_id = instance.def_id();\n         let item_path = self.tcx.absolute_item_path_str(def_id);\n-        if item_path.starts_with(\"std::\") {\n-            //println!(\"{}\", item_path);\n-        }\n         match &*item_path {\n             \"std::sys::unix::thread::guard::init\" | \"std::sys::unix::thread::guard::current\" => {\n                 // Return None, as it doesn't make sense to return Some, because miri detects stack overflow itself.\n@@ -178,7 +174,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n         Ok(false)\n     }\n \n-    fn call_c_abi(\n+    fn call_foreign_item(\n         &mut self,\n         def_id: DefId,\n         args: &[ValTy<'tcx>],\n@@ -215,6 +211,73 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 }\n             }\n \n+            \"__rust_alloc\" => {\n+                let size = self.value_to_scalar(args[0])?.to_usize(self)?;\n+                let align = self.value_to_scalar(args[1])?.to_usize(self)?;\n+                if size == 0 {\n+                    return err!(HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(Size::from_bytes(size),\n+                                               Align::from_bytes(align, align).unwrap(),\n+                                               MemoryKind::Rust.into())?;\n+                self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n+            }\n+            \"__rust_alloc_zeroed\" => {\n+                let size = self.value_to_scalar(args[0])?.to_usize(self)?;\n+                let align = self.value_to_scalar(args[1])?.to_usize(self)?;\n+                if size == 0 {\n+                    return err!(HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(Size::from_bytes(size),\n+                                               Align::from_bytes(align, align).unwrap(),\n+                                               MemoryKind::Rust.into())?;\n+                self.memory.write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n+                self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n+            }\n+            \"__rust_dealloc\" => {\n+                let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n+                let old_size = self.value_to_scalar(args[1])?.to_usize(self)?;\n+                let align = self.value_to_scalar(args[2])?.to_usize(self)?;\n+                if old_size == 0 {\n+                    return err!(HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                self.memory.deallocate(\n+                    ptr,\n+                    Some((Size::from_bytes(old_size), Align::from_bytes(align, align).unwrap())),\n+                    MemoryKind::Rust.into(),\n+                )?;\n+            }\n+            \"__rust_realloc\" => {\n+                let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n+                let old_size = self.value_to_scalar(args[1])?.to_usize(self)?;\n+                let align = self.value_to_scalar(args[2])?.to_usize(self)?;\n+                let new_size = self.value_to_scalar(args[3])?.to_usize(self)?;\n+                if old_size == 0 || new_size == 0 {\n+                    return err!(HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let new_ptr = self.memory.reallocate(\n+                    ptr,\n+                    Size::from_bytes(old_size),\n+                    Align::from_bytes(align, align).unwrap(),\n+                    Size::from_bytes(new_size),\n+                    Align::from_bytes(align, align).unwrap(),\n+                    MemoryKind::Rust.into(),\n+                )?;\n+                self.write_scalar(dest, Scalar::Ptr(new_ptr), dest_ty)?;\n+            }\n+\n             \"syscall\" => {\n                 // TODO: read `syscall` ids like `sysconf` ids and\n                 // figure out some way to actually process some of them\n@@ -559,9 +622,18 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 self.write_ptr(dest, addr, dest_ty)?;\n             }\n \n+            // Windows API subs\n+            \"AddVectoredExceptionHandler\" |\n+            \"SetThreadStackGuarantee\" => {\n+                let usize = self.tcx.types.usize;\n+                // any non zero value works for the stdlib. This is just used for stackoverflows anyway\n+                self.write_scalar(dest, Scalar::from_u128(1), usize)?;\n+            },\n+\n+            // We can't execute anything else\n             _ => {\n                 return err!(Unimplemented(\n-                    format!(\"can't call C ABI function: {}\", link_name),\n+                    format!(\"can't call foreign function: {}\", link_name),\n                 ));\n             }\n         }\n@@ -629,11 +701,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             || EvalErrorKind::NoMirFor(path.clone()),\n         )?;\n \n-        if sig.abi == Abi::C {\n-            // An external C function\n+        if self.tcx.is_foreign_item(instance.def_id()) {\n+            // An external function\n             // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n             // unify these two mechanisms for \"hooking into missing functions\".\n-            self.call_c_abi(\n+            self.call_foreign_item(\n                 instance.def_id(),\n                 args,\n                 dest,\n@@ -644,74 +716,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n         }\n \n         match &path[..] {\n-            // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n-            \"alloc::alloc::::__rust_alloc\" => {\n-                let size = self.value_to_scalar(args[0])?.to_usize(self)?;\n-                let align = self.value_to_scalar(args[1])?.to_usize(self)?;\n-                if size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(Size::from_bytes(size),\n-                                               Align::from_bytes(align, align).unwrap(),\n-                                               MemoryKind::Rust.into())?;\n-                self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n-            }\n-            \"alloc::alloc::::__rust_alloc_zeroed\" => {\n-                let size = self.value_to_scalar(args[0])?.to_usize(self)?;\n-                let align = self.value_to_scalar(args[1])?.to_usize(self)?;\n-                if size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(Size::from_bytes(size),\n-                                               Align::from_bytes(align, align).unwrap(),\n-                                               MemoryKind::Rust.into())?;\n-                self.memory.write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n-                self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n-            }\n-            \"alloc::alloc::::__rust_dealloc\" => {\n-                let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n-                let old_size = self.value_to_scalar(args[1])?.to_usize(self)?;\n-                let align = self.value_to_scalar(args[2])?.to_usize(self)?;\n-                if old_size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                self.memory.deallocate(\n-                    ptr,\n-                    Some((Size::from_bytes(old_size), Align::from_bytes(align, align).unwrap())),\n-                    MemoryKind::Rust.into(),\n-                )?;\n-            }\n-            \"alloc::alloc::::__rust_realloc\" => {\n-                let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n-                let old_size = self.value_to_scalar(args[1])?.to_usize(self)?;\n-                let align = self.value_to_scalar(args[2])?.to_usize(self)?;\n-                let new_size = self.value_to_scalar(args[3])?.to_usize(self)?;\n-                if old_size == 0 || new_size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let new_ptr = self.memory.reallocate(\n-                    ptr,\n-                    Size::from_bytes(old_size),\n-                    Align::from_bytes(align, align).unwrap(),\n-                    Size::from_bytes(new_size),\n-                    Align::from_bytes(align, align).unwrap(),\n-                    MemoryKind::Rust.into(),\n-                )?;\n-                self.write_scalar(dest, Scalar::Ptr(new_ptr), dest_ty)?;\n-            }\n-\n             // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n             // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n             \"std::io::_print\" => {\n@@ -733,12 +737,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 let bool = self.tcx.types.bool;\n                 self.write_scalar(dest, Scalar::from_bool(false), bool)?;\n             }\n-            \"std::sys::imp::c::::AddVectoredExceptionHandler\" |\n-            \"std::sys::imp::c::::SetThreadStackGuarantee\" => {\n-                let usize = self.tcx.types.usize;\n-                // any non zero value works for the stdlib. This is just used for stackoverflows anyway\n-                self.write_scalar(dest, Scalar::from_u128(1), usize)?;\n-            },\n+\n             _ => return err!(NoMirFor(path)),\n         }\n "}]}