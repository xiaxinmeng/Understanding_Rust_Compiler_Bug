{"sha": "625405562c278cb2e45bec6805f13d2c1de8049e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNTQwNTU2MmMyNzhjYjJlNDViZWM2ODA1ZjEzZDJjMWRlODA0OWU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-24T04:38:20Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-24T04:38:20Z"}, "message": "Revert \"Merge pull request #4590 from crabtw/abi\"\n\nThis reverts commit e4e5d986fa424c00389bd2520ebce7276f58a6e0, reversing\nchanges made to ab8d77474c474a672873b3edc467323fcf992279.", "tree": {"sha": "cf3ead371f47440313c73360e2a88fea0a46bcb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf3ead371f47440313c73360e2a88fea0a46bcb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/625405562c278cb2e45bec6805f13d2c1de8049e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/625405562c278cb2e45bec6805f13d2c1de8049e", "html_url": "https://github.com/rust-lang/rust/commit/625405562c278cb2e45bec6805f13d2c1de8049e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/625405562c278cb2e45bec6805f13d2c1de8049e/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a202dcccca09e49f65251f012f55c93f92c869a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a202dcccca09e49f65251f012f55c93f92c869a7", "html_url": "https://github.com/rust-lang/rust/commit/a202dcccca09e49f65251f012f55c93f92c869a7"}], "stats": {"total": 1265, "additions": 605, "deletions": 660}, "files": [{"sha": "07c12d08e1baca6c5b88c2995a9b678495cfbd98", "filename": "src/librustc/middle/trans/cabi.rs", "status": "removed", "additions": 0, "deletions": 214, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -1,214 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use lib::llvm::{llvm, TypeRef, ValueRef, Attribute};\n-use middle::trans::base::*;\n-use middle::trans::build::*;\n-use middle::trans::common::*;\n-\n-export ABIInfo, LLVMType, FnType;\n-export llvm_abi_info;\n-\n-trait ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n-                    ret_def: bool) -> FnType;\n-}\n-\n-struct LLVMType {\n-    cast: bool,\n-    ty: TypeRef\n-}\n-\n-struct FnType {\n-    arg_tys: ~[LLVMType],\n-    ret_ty: LLVMType,\n-    attrs: ~[Option<Attribute>],\n-    sret: bool\n-}\n-\n-impl FnType {\n-    fn decl_fn(&self, decl: fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n-        let atys = vec::map(self.arg_tys, |t| t.ty);\n-        let rty = self.ret_ty.ty;\n-        let fnty = T_fn(atys, rty);\n-        let llfn = decl(fnty);\n-\n-        for vec::eachi(self.attrs) |i, a| {\n-            match *a {\n-                option::Some(attr) => {\n-                    unsafe {\n-                        let llarg = get_param(llfn, i);\n-                        llvm::LLVMAddAttribute(llarg, attr as c_uint);\n-                    }\n-                }\n-                _ => ()\n-            }\n-        }\n-        return llfn;\n-    }\n-\n-    fn build_shim_args(&self, bcx: block,\n-                       arg_tys: &[TypeRef],\n-                       llargbundle: ValueRef) -> ~[ValueRef] {\n-        let mut atys = /*bad*/copy self.arg_tys;\n-        let mut attrs = /*bad*/copy self.attrs;\n-\n-        let mut llargvals = ~[];\n-        let mut i = 0u;\n-        let n = vec::len(arg_tys);\n-\n-        if self.sret {\n-            let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n-            let llretloc = Load(bcx, llretptr);\n-                llargvals = ~[llretloc];\n-                atys = vec::tail(atys);\n-                attrs = vec::tail(attrs);\n-        }\n-\n-        while i < n {\n-            let llargval = if atys[i].cast {\n-                let arg_ptr = GEPi(bcx, llargbundle, [0u, i]);\n-                let arg_ptr = BitCast(bcx, arg_ptr, T_ptr(atys[i].ty));\n-                Load(bcx, arg_ptr)\n-            } else if attrs[i].is_some() {\n-                GEPi(bcx, llargbundle, [0u, i])\n-            } else {\n-                load_inbounds(bcx, llargbundle, [0u, i])\n-            };\n-            llargvals.push(llargval);\n-            i += 1u;\n-        }\n-\n-        return llargvals;\n-    }\n-\n-    fn build_shim_ret(&self, bcx: block,\n-                      arg_tys: &[TypeRef], ret_def: bool,\n-                      llargbundle: ValueRef, llretval: ValueRef) {\n-        for vec::eachi(self.attrs) |i, a| {\n-            match *a {\n-                Some(attr) => {\n-                    unsafe {\n-                        llvm::LLVMAddInstrAttribute(\n-                            llretval, (i + 1u) as c_uint,\n-                                        attr as c_uint);\n-                    }\n-                }\n-                _ => ()\n-            }\n-        }\n-        if self.sret || !ret_def {\n-            return;\n-        }\n-        let n = vec::len(arg_tys);\n-        // R** llretptr = &args->r;\n-        let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n-        // R* llretloc = *llretptr; /* (args->r) */\n-        let llretloc = Load(bcx, llretptr);\n-        if self.ret_ty.cast {\n-            let tmp_ptr = BitCast(bcx, llretloc, T_ptr(self.ret_ty.ty));\n-            // *args->r = r;\n-            Store(bcx, llretval, tmp_ptr);\n-        } else {\n-            // *args->r = r;\n-            Store(bcx, llretval, llretloc);\n-        };\n-    }\n-\n-    fn build_wrap_args(&self, bcx: block, ret_ty: TypeRef,\n-                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n-        let mut atys = /*bad*/copy self.arg_tys;\n-        let mut attrs = /*bad*/copy self.attrs;\n-        let mut j = 0u;\n-        let llretptr = if self.sret {\n-            atys = vec::tail(atys);\n-            attrs = vec::tail(attrs);\n-            j = 1u;\n-            get_param(llwrapfn, 0u)\n-        } else if self.ret_ty.cast {\n-            let retptr = alloca(bcx, self.ret_ty.ty);\n-            BitCast(bcx, retptr, T_ptr(ret_ty))\n-        } else {\n-            alloca(bcx, ret_ty)\n-        };\n-\n-        let mut i = 0u;\n-        let n = vec::len(atys);\n-        while i < n {\n-            let mut argval = get_param(llwrapfn, i + j);\n-            if attrs[i].is_some() {\n-                argval = Load(bcx, argval);\n-                store_inbounds(bcx, argval, llargbundle, [0u, i]);\n-            } else if atys[i].cast {\n-                let argptr = GEPi(bcx, llargbundle, [0u, i]);\n-                let argptr = BitCast(bcx, argptr, T_ptr(atys[i].ty));\n-                Store(bcx, argval, argptr);\n-            } else {\n-                store_inbounds(bcx, argval, llargbundle, [0u, i]);\n-            }\n-            i += 1u;\n-        }\n-        store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n-    }\n-\n-    fn build_wrap_ret(&self, bcx: block,\n-                      arg_tys: &[TypeRef], ret_def: bool,\n-                      llargbundle: ValueRef) {\n-        if self.sret || !ret_def {\n-            RetVoid(bcx);\n-            return;\n-        }\n-        let n = vec::len(arg_tys);\n-        let llretval = load_inbounds(bcx, llargbundle, ~[0u, n]);\n-        let llretval = if self.ret_ty.cast {\n-            let retptr = BitCast(bcx, llretval, T_ptr(self.ret_ty.ty));\n-            Load(bcx, retptr)\n-        } else {\n-            Load(bcx, llretval)\n-        };\n-        Ret(bcx, llretval);\n-    }\n-}\n-\n-enum LLVM_ABIInfo { LLVM_ABIInfo }\n-\n-impl LLVM_ABIInfo: ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n-                    _ret_def: bool) -> FnType {\n-        let arg_tys = do atys.map |a| {\n-            LLVMType { cast: false, ty: *a }\n-        };\n-        let ret_ty = LLVMType {\n-            cast: false,\n-            ty: rty\n-        };\n-        let attrs = do atys.map |_| {\n-            option::None\n-        };\n-        let sret = false;\n-\n-        return FnType {\n-            arg_tys: arg_tys,\n-            ret_ty: ret_ty,\n-            attrs: attrs,\n-            sret: sret\n-        };\n-    }\n-}\n-\n-fn llvm_abi_info() -> ABIInfo {\n-    return LLVM_ABIInfo as ABIInfo;\n-}\n-\n-"}, {"sha": "7125764e74798a4fae9c77f72f3c3ce4c4813e4c", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "removed", "additions": 0, "deletions": 417, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -1,417 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// The classification code for the x86_64 ABI is taken from the clay language\n-// https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n-\n-use lib::llvm::{llvm, TypeRef, ValueRef, Integer, Pointer, Float, Double};\n-use lib::llvm::{Struct, Array, Attribute};\n-use lib::llvm::{StructRetAttribute, ByValAttribute};\n-use middle::trans::common::*;\n-use middle::trans::cabi::*;\n-\n-export x86_64_abi_info;\n-\n-enum x86_64_reg_class {\n-    no_class,\n-    integer_class,\n-    sse_fs_class,\n-    sse_fv_class,\n-    sse_ds_class,\n-    sse_dv_class,\n-    sse_int_class,\n-    sseup_class,\n-    x87_class,\n-    x87up_class,\n-    complex_x87_class,\n-    memory_class\n-}\n-\n-impl x86_64_reg_class : cmp::Eq {\n-    pure fn eq(&self, other: &x86_64_reg_class) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &x86_64_reg_class) -> bool { !(*self).eq(other) }\n-}\n-\n-fn is_sse(++c: x86_64_reg_class) -> bool {\n-    return match c {\n-        sse_fs_class | sse_fv_class |\n-        sse_ds_class | sse_dv_class => true,\n-        _ => false\n-    };\n-}\n-\n-fn is_ymm(cls: &[x86_64_reg_class]) -> bool {\n-    let len = vec::len(cls);\n-    return (len > 2u &&\n-         is_sse(cls[0]) &&\n-         cls[1] == sseup_class &&\n-         cls[2] == sseup_class) ||\n-        (len > 3u &&\n-         is_sse(cls[1]) &&\n-         cls[2] == sseup_class &&\n-         cls[3] == sseup_class);\n-}\n-\n-fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n-    fn align(off: uint, ty: TypeRef) -> uint {\n-        let a = ty_align(ty);\n-        return (off + a - 1u) / a * a;\n-    }\n-\n-    fn struct_tys(ty: TypeRef) -> ~[TypeRef] {\n-        unsafe {\n-            let n = llvm::LLVMCountStructElementTypes(ty);\n-        if (n == 0) {\n-            return ~[];\n-        }\n-            let mut elts = vec::from_elem(n as uint, ptr::null());\n-            llvm::LLVMGetStructElementTypes(ty,\n-                ptr::to_mut_unsafe_ptr(&mut elts[0]));\n-            return elts;\n-        }\n-    }\n-\n-    fn ty_align(ty: TypeRef) -> uint {\n-        unsafe {\n-            return match llvm::LLVMGetTypeKind(ty) {\n-                Integer => {\n-                    ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n-                }\n-                Pointer => 8,\n-                Float => 4,\n-                Double => 8,\n-                Struct => {\n-                  do vec::foldl(1, struct_tys(ty)) |a, t| {\n-                      uint::max(a, ty_align(*t))\n-                  }\n-                }\n-                Array => {\n-                    let elt = llvm::LLVMGetElementType(ty);\n-                    ty_align(elt)\n-                }\n-                _ => fail ~\"ty_size: unhandled type\"\n-            };\n-        }\n-    }\n-\n-    fn ty_size(ty: TypeRef) -> uint {\n-        unsafe {\n-            return match llvm::LLVMGetTypeKind(ty) {\n-                Integer => {\n-                    ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n-                }\n-                Pointer => 8,\n-                Float => 4,\n-                Double => 8,\n-                Struct => {\n-                  let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                      align(s, *t) + ty_size(*t)\n-                  };\n-                  align(size, ty)\n-                }\n-                Array => {\n-                  let len = llvm::LLVMGetArrayLength(ty) as uint;\n-                  let elt = llvm::LLVMGetElementType(ty);\n-                  let eltsz = ty_size(elt);\n-                  len * eltsz\n-                }\n-                _ => fail ~\"ty_size: unhandled type\"\n-            };\n-        }\n-    }\n-\n-    fn all_mem(cls: &[mut x86_64_reg_class]) {\n-        for uint::range(0, cls.len()) |i| {\n-            cls[i] = memory_class;\n-        }\n-    }\n-\n-    fn unify(cls: &[mut x86_64_reg_class],\n-             i: uint,\n-             newv: x86_64_reg_class) {\n-        if cls[i] == newv {\n-            return;\n-        } else if cls[i] == no_class {\n-            cls[i] = newv;\n-        } else if newv == no_class {\n-            return;\n-        } else if cls[i] == memory_class || newv == memory_class {\n-            cls[i] = memory_class;\n-        } else if cls[i] == integer_class || newv == integer_class {\n-            cls[i] = integer_class;\n-        } else if cls[i] == x87_class ||\n-                  cls[i] == x87up_class ||\n-                  cls[i] == complex_x87_class ||\n-                  newv == x87_class ||\n-                  newv == x87up_class ||\n-                  newv == complex_x87_class {\n-            cls[i] = memory_class;\n-        } else {\n-            cls[i] = newv;\n-        }\n-    }\n-\n-    fn classify_struct(tys: &[TypeRef],\n-                       cls: &[mut x86_64_reg_class], i: uint,\n-                       off: uint) {\n-        let mut field_off = off;\n-        for vec::each(tys) |ty| {\n-            field_off = align(field_off, *ty);\n-            classify(*ty, cls, i, field_off);\n-            field_off += ty_size(*ty);\n-        }\n-    }\n-\n-    fn classify(ty: TypeRef,\n-                cls: &[mut x86_64_reg_class], ix: uint,\n-                off: uint) {\n-        unsafe {\n-            let t_align = ty_align(ty);\n-            let t_size = ty_size(ty);\n-\n-            let misalign = off % t_align;\n-            if misalign != 0u {\n-                let mut i = off / 8u;\n-                let e = (off + t_size + 7u) / 8u;\n-                while i < e {\n-                    unify(cls, ix + i, memory_class);\n-                    i += 1u;\n-                }\n-                return;\n-            }\n-\n-            match llvm::LLVMGetTypeKind(ty) as int {\n-                8 /* integer */ |\n-                12 /* pointer */ => {\n-                    unify(cls, ix + off / 8u, integer_class);\n-                }\n-                2 /* float */ => {\n-                    if off % 8u == 4u {\n-                        unify(cls, ix + off / 8u, sse_fv_class);\n-                    } else {\n-                        unify(cls, ix + off / 8u, sse_fs_class);\n-                    }\n-                }\n-                3 /* double */ => {\n-                    unify(cls, ix + off / 8u, sse_ds_class);\n-                }\n-                10 /* struct */ => {\n-                    classify_struct(struct_tys(ty), cls, ix, off);\n-                }\n-                11 /* array */ => {\n-                    let elt = llvm::LLVMGetElementType(ty);\n-                    let eltsz = ty_size(elt);\n-                    let len = llvm::LLVMGetArrayLength(ty) as uint;\n-                    let mut i = 0u;\n-                    while i < len {\n-                        classify(elt, cls, ix, off + i * eltsz);\n-                        i += 1u;\n-                    }\n-                }\n-                _ => fail ~\"classify: unhandled type\"\n-            }\n-        }\n-    }\n-\n-    fn fixup(ty: TypeRef, cls: &[mut x86_64_reg_class]) {\n-        unsafe {\n-            let mut i = 0u;\n-            let llty = llvm::LLVMGetTypeKind(ty) as int;\n-            let e = vec::len(cls);\n-            if vec::len(cls) > 2u &&\n-               (llty == 10 /* struct */ ||\n-                llty == 11 /* array */) {\n-                if is_sse(cls[i]) {\n-                    i += 1u;\n-                    while i < e {\n-                        if cls[i] != sseup_class {\n-                            all_mem(cls);\n-                            return;\n-                        }\n-                        i += 1u;\n-                    }\n-                } else {\n-                    all_mem(cls);\n-                    return\n-                }\n-            } else {\n-                while i < e {\n-                    if cls[i] == memory_class {\n-                        all_mem(cls);\n-                        return;\n-                    }\n-                    if cls[i] == x87up_class {\n-                        // for darwin\n-                        // cls[i] = sse_ds_class;\n-                        all_mem(cls);\n-                        return;\n-                    }\n-                    if cls[i] == sseup_class {\n-                        cls[i] = sse_int_class;\n-                    } else if is_sse(cls[i]) {\n-                        i += 1;\n-                        while cls[i] == sseup_class { i += 1u; }\n-                    } else if cls[i] == x87_class {\n-                        i += 1;\n-                        while cls[i] == x87up_class { i += 1u; }\n-                    } else {\n-                        i += 1;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    let words = (ty_size(ty) + 7) / 8;\n-    let cls = vec::cast_to_mut(vec::from_elem(words, no_class));\n-    if words > 4 {\n-        all_mem(cls);\n-        return vec::cast_from_mut(move cls);\n-    }\n-    classify(ty, cls, 0, 0);\n-    fixup(ty, cls);\n-    return vec::cast_from_mut(move cls);\n-}\n-\n-fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {\n-    fn llvec_len(cls: &[x86_64_reg_class]) -> uint {\n-        let mut len = 1u;\n-        for vec::each(cls) |c| {\n-            if *c != sseup_class {\n-                break;\n-            }\n-            len += 1u;\n-        }\n-        return len;\n-    }\n-\n-    unsafe {\n-        let mut tys = ~[];\n-        let mut i = 0u;\n-        let e = vec::len(cls);\n-        while i < e {\n-            match cls[i] {\n-                integer_class => {\n-                    tys.push(T_i64());\n-                }\n-                sse_fv_class => {\n-                    let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n-                    let vec_ty = llvm::LLVMVectorType(T_f32(),\n-                                                      vec_len as c_uint);\n-                    tys.push(vec_ty);\n-                    i += vec_len;\n-                    loop;\n-                }\n-                sse_fs_class => {\n-                    tys.push(T_f32());\n-                }\n-                sse_ds_class => {\n-                    tys.push(T_f64());\n-                }\n-                _ => fail ~\"llregtype: unhandled class\"\n-            }\n-            i += 1u;\n-        }\n-        return T_struct(tys);\n-    }\n-}\n-\n-fn x86_64_tys(atys: &[TypeRef],\n-              rty: TypeRef,\n-              ret_def: bool) -> FnType {\n-    fn is_reg_ty(ty: TypeRef) -> bool {\n-        unsafe {\n-            return match llvm::LLVMGetTypeKind(ty) as int {\n-                8 /* integer */ |\n-                12 /* pointer */ |\n-                2 /* float */ |\n-                3 /* double */ => true,\n-                _ => false\n-            };\n-        }\n-    }\n-\n-    fn is_pass_byval(cls: &[x86_64_reg_class]) -> bool {\n-        return cls.len() > 0 &&\n-            (cls[0] == memory_class ||\n-             cls[0] == x87_class ||\n-             cls[0] == complex_x87_class);\n-    }\n-\n-    fn is_ret_bysret(cls: &[x86_64_reg_class]) -> bool {\n-        return cls.len() > 0 && cls[0] == memory_class;\n-    }\n-\n-    fn x86_64_ty(ty: TypeRef,\n-                 is_mem_cls: fn(cls: &[x86_64_reg_class]) -> bool,\n-                 attr: Attribute) -> (LLVMType, Option<Attribute>) {\n-        let mut cast = false;\n-        let mut ty_attr = option::None;\n-        let mut llty = ty;\n-        if !is_reg_ty(ty) {\n-            let cls = classify_ty(ty);\n-            if is_mem_cls(cls) {\n-                llty = T_ptr(ty);\n-                ty_attr = option::Some(attr);\n-            } else {\n-                cast = true;\n-                llty = llreg_ty(cls);\n-            }\n-        }\n-        return (LLVMType { cast: cast, ty: llty }, ty_attr);\n-    }\n-\n-    let mut arg_tys = ~[];\n-    let mut attrs = ~[];\n-    for vec::each(atys) |t| {\n-        let (ty, attr) = x86_64_ty(*t, is_pass_byval, ByValAttribute);\n-        arg_tys.push(ty);\n-        attrs.push(attr);\n-    }\n-    let mut (ret_ty, ret_attr) = x86_64_ty(rty, is_ret_bysret,\n-                                       StructRetAttribute);\n-    let sret = ret_attr.is_some();\n-    if sret {\n-        arg_tys = vec::append(~[ret_ty], arg_tys);\n-        ret_ty = LLVMType {\n-                   cast:  false,\n-                   ty: T_void()\n-                 };\n-        attrs = vec::append(~[ret_attr], attrs);\n-    } else if !ret_def {\n-        ret_ty = LLVMType {\n-                   cast: false,\n-                   ty: T_void()\n-                 };\n-    }\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-        attrs: attrs,\n-        sret: sret\n-    };\n-}\n-\n-enum X86_64_ABIInfo { X86_64_ABIInfo }\n-\n-impl X86_64_ABIInfo: ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n-                    ret_def: bool) -> FnType {\n-        return x86_64_tys(atys, rty, ret_def);\n-    }\n-}\n-\n-fn x86_64_abi_info() -> ABIInfo {\n-    return X86_64_ABIInfo as ABIInfo;\n-}"}, {"sha": "b92950488d1975a0f47a708fcbf57a5c1668b6f2", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 605, "deletions": 25, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/625405562c278cb2e45bec6805f13d2c1de8049e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/625405562c278cb2e45bec6805f13d2c1de8049e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=625405562c278cb2e45bec6805f13d2c1de8049e", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// The classification code for the x86_64 ABI is taken from the clay language\n+// https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n+\n use core::prelude::*;\n \n use back::{link, abi};\n@@ -19,8 +22,6 @@ use lib::llvm::{StructRetAttribute, ByValAttribute};\n use lib::llvm::{llvm, TypeRef, ValueRef, Integer, Pointer, Float, Double};\n use lib;\n use middle::trans::base::*;\n-use middle::trans::cabi;\n-use middle::trans::cabi_x86_64::*;\n use middle::trans::build::*;\n use middle::trans::callee::*;\n use middle::trans::common::*;\n@@ -43,11 +44,417 @@ use syntax::parse::token::special_idents;\n export link_name, trans_foreign_mod, register_foreign_fn, trans_foreign_fn,\n        trans_intrinsic;\n \n-fn abi_info(arch: session::arch) -> cabi::ABIInfo {\n-    return match arch {\n-        arch_x86_64 => x86_64_abi_info(),\n-        _ => cabi::llvm_abi_info()\n+enum x86_64_reg_class {\n+    no_class,\n+    integer_class,\n+    sse_fs_class,\n+    sse_fv_class,\n+    sse_ds_class,\n+    sse_dv_class,\n+    sse_int_class,\n+    sseup_class,\n+    x87_class,\n+    x87up_class,\n+    complex_x87_class,\n+    memory_class\n+}\n+\n+impl x86_64_reg_class : cmp::Eq {\n+    pure fn eq(&self, other: &x86_64_reg_class) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(&self, other: &x86_64_reg_class) -> bool { !(*self).eq(other) }\n+}\n+\n+fn is_sse(++c: x86_64_reg_class) -> bool {\n+    return match c {\n+        sse_fs_class | sse_fv_class |\n+        sse_ds_class | sse_dv_class => true,\n+        _ => false\n+    };\n+}\n+\n+fn is_ymm(cls: &[x86_64_reg_class]) -> bool {\n+    let len = vec::len(cls);\n+    return (len > 2u &&\n+         is_sse(cls[0]) &&\n+         cls[1] == sseup_class &&\n+         cls[2] == sseup_class) ||\n+        (len > 3u &&\n+         is_sse(cls[1]) &&\n+         cls[2] == sseup_class &&\n+         cls[3] == sseup_class);\n+}\n+\n+fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n+    fn align(off: uint, ty: TypeRef) -> uint {\n+        let a = ty_align(ty);\n+        return (off + a - 1u) / a * a;\n+    }\n+\n+    fn struct_tys(ty: TypeRef) -> ~[TypeRef] {\n+        unsafe {\n+            let n = llvm::LLVMCountStructElementTypes(ty);\n+        if (n == 0) {\n+            return ~[];\n+        }\n+            let mut elts = vec::from_elem(n as uint, ptr::null());\n+            llvm::LLVMGetStructElementTypes(ty,\n+                ptr::to_mut_unsafe_ptr(&mut elts[0]));\n+            return elts;\n+        }\n+    }\n+\n+    fn ty_align(ty: TypeRef) -> uint {\n+        unsafe {\n+            return match llvm::LLVMGetTypeKind(ty) {\n+                Integer => {\n+                    ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n+                }\n+                Pointer => 8,\n+                Float => 4,\n+                Double => 8,\n+                Struct => {\n+                  do vec::foldl(1, struct_tys(ty)) |a, t| {\n+                      uint::max(a, ty_align(*t))\n+                  }\n+                }\n+                Array => {\n+                    let elt = llvm::LLVMGetElementType(ty);\n+                    ty_align(elt)\n+                }\n+                _ => fail ~\"ty_size: unhandled type\"\n+            };\n+        }\n+    }\n+\n+    fn ty_size(ty: TypeRef) -> uint {\n+        unsafe {\n+            return match llvm::LLVMGetTypeKind(ty) {\n+                Integer => {\n+                    ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n+                }\n+                Pointer => 8,\n+                Float => 4,\n+                Double => 8,\n+                Struct => {\n+                  let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n+                      align(s, *t) + ty_size(*t)\n+                  };\n+                  align(size, ty)\n+                }\n+                Array => {\n+                  let len = llvm::LLVMGetArrayLength(ty) as uint;\n+                  let elt = llvm::LLVMGetElementType(ty);\n+                  let eltsz = ty_size(elt);\n+                  len * eltsz\n+                }\n+                _ => fail ~\"ty_size: unhandled type\"\n+            };\n+        }\n+    }\n+\n+    fn all_mem(cls: &[mut x86_64_reg_class]) {\n+        for uint::range(0, cls.len()) |i| {\n+            cls[i] = memory_class;\n+        }\n+    }\n+\n+    fn unify(cls: &[mut x86_64_reg_class],\n+             i: uint,\n+             newv: x86_64_reg_class) {\n+        if cls[i] == newv {\n+            return;\n+        } else if cls[i] == no_class {\n+            cls[i] = newv;\n+        } else if newv == no_class {\n+            return;\n+        } else if cls[i] == memory_class || newv == memory_class {\n+            cls[i] = memory_class;\n+        } else if cls[i] == integer_class || newv == integer_class {\n+            cls[i] = integer_class;\n+        } else if cls[i] == x87_class ||\n+                  cls[i] == x87up_class ||\n+                  cls[i] == complex_x87_class ||\n+                  newv == x87_class ||\n+                  newv == x87up_class ||\n+                  newv == complex_x87_class {\n+            cls[i] = memory_class;\n+        } else {\n+            cls[i] = newv;\n+        }\n+    }\n+\n+    fn classify_struct(tys: &[TypeRef],\n+                       cls: &[mut x86_64_reg_class], i: uint,\n+                       off: uint) {\n+        let mut field_off = off;\n+        for vec::each(tys) |ty| {\n+            field_off = align(field_off, *ty);\n+            classify(*ty, cls, i, field_off);\n+            field_off += ty_size(*ty);\n+        }\n+    }\n+\n+    fn classify(ty: TypeRef,\n+                cls: &[mut x86_64_reg_class], ix: uint,\n+                off: uint) {\n+        unsafe {\n+            let t_align = ty_align(ty);\n+            let t_size = ty_size(ty);\n+\n+            let misalign = off % t_align;\n+            if misalign != 0u {\n+                let mut i = off / 8u;\n+                let e = (off + t_size + 7u) / 8u;\n+                while i < e {\n+                    unify(cls, ix + i, memory_class);\n+                    i += 1u;\n+                }\n+                return;\n+            }\n+\n+            match llvm::LLVMGetTypeKind(ty) as int {\n+                8 /* integer */ |\n+                12 /* pointer */ => {\n+                    unify(cls, ix + off / 8u, integer_class);\n+                }\n+                2 /* float */ => {\n+                    if off % 8u == 4u {\n+                        unify(cls, ix + off / 8u, sse_fv_class);\n+                    } else {\n+                        unify(cls, ix + off / 8u, sse_fs_class);\n+                    }\n+                }\n+                3 /* double */ => {\n+                    unify(cls, ix + off / 8u, sse_ds_class);\n+                }\n+                10 /* struct */ => {\n+                    classify_struct(struct_tys(ty), cls, ix, off);\n+                }\n+                11 /* array */ => {\n+                    let elt = llvm::LLVMGetElementType(ty);\n+                    let eltsz = ty_size(elt);\n+                    let len = llvm::LLVMGetArrayLength(ty) as uint;\n+                    let mut i = 0u;\n+                    while i < len {\n+                        classify(elt, cls, ix, off + i * eltsz);\n+                        i += 1u;\n+                    }\n+                }\n+                _ => fail ~\"classify: unhandled type\"\n+            }\n+        }\n+    }\n+\n+    fn fixup(ty: TypeRef, cls: &[mut x86_64_reg_class]) {\n+        unsafe {\n+            let mut i = 0u;\n+            let llty = llvm::LLVMGetTypeKind(ty) as int;\n+            let e = vec::len(cls);\n+            if vec::len(cls) > 2u &&\n+               (llty == 10 /* struct */ ||\n+                llty == 11 /* array */) {\n+                if is_sse(cls[i]) {\n+                    i += 1u;\n+                    while i < e {\n+                        if cls[i] != sseup_class {\n+                            all_mem(cls);\n+                            return;\n+                        }\n+                        i += 1u;\n+                    }\n+                } else {\n+                    all_mem(cls);\n+                    return\n+                }\n+            } else {\n+                while i < e {\n+                    if cls[i] == memory_class {\n+                        all_mem(cls);\n+                        return;\n+                    }\n+                    if cls[i] == x87up_class {\n+                        // for darwin\n+                        // cls[i] = sse_ds_class;\n+                        all_mem(cls);\n+                        return;\n+                    }\n+                    if cls[i] == sseup_class {\n+                        cls[i] = sse_int_class;\n+                    } else if is_sse(cls[i]) {\n+                        i += 1;\n+                        while cls[i] == sseup_class { i += 1u; }\n+                    } else if cls[i] == x87_class {\n+                        i += 1;\n+                        while cls[i] == x87up_class { i += 1u; }\n+                    } else {\n+                        i += 1;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    let words = (ty_size(ty) + 7) / 8;\n+    let cls = vec::cast_to_mut(vec::from_elem(words, no_class));\n+    if words > 4 {\n+        all_mem(cls);\n+        return vec::cast_from_mut(move cls);\n+    }\n+    classify(ty, cls, 0, 0);\n+    fixup(ty, cls);\n+    return vec::cast_from_mut(move cls);\n+}\n+\n+fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {\n+    fn llvec_len(cls: &[x86_64_reg_class]) -> uint {\n+        let mut len = 1u;\n+        for vec::each(cls) |c| {\n+            if *c != sseup_class {\n+                break;\n+            }\n+            len += 1u;\n+        }\n+        return len;\n+    }\n+\n+    unsafe {\n+        let mut tys = ~[];\n+        let mut i = 0u;\n+        let e = vec::len(cls);\n+        while i < e {\n+            match cls[i] {\n+                integer_class => {\n+                    tys.push(T_i64());\n+                }\n+                sse_fv_class => {\n+                    let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n+                    let vec_ty = llvm::LLVMVectorType(T_f32(),\n+                                                      vec_len as c_uint);\n+                    tys.push(vec_ty);\n+                    i += vec_len;\n+                    loop;\n+                }\n+                sse_fs_class => {\n+                    tys.push(T_f32());\n+                }\n+                sse_ds_class => {\n+                    tys.push(T_f64());\n+                }\n+                _ => fail ~\"llregtype: unhandled class\"\n+            }\n+            i += 1u;\n+        }\n+        return T_struct(tys);\n+    }\n+}\n+\n+type x86_64_llty = {\n+    cast: bool,\n+    ty: TypeRef\n+};\n+\n+type x86_64_tys = {\n+    arg_tys: ~[x86_64_llty],\n+    ret_ty: x86_64_llty,\n+    attrs: ~[Option<Attribute>],\n+    sret: bool\n+};\n+\n+fn x86_64_tys(atys: &[TypeRef],\n+              rty: TypeRef,\n+              ret_def: bool) -> x86_64_tys {\n+    fn is_reg_ty(ty: TypeRef) -> bool {\n+        unsafe {\n+            return match llvm::LLVMGetTypeKind(ty) as int {\n+                8 /* integer */ |\n+                12 /* pointer */ |\n+                2 /* float */ |\n+                3 /* double */ => true,\n+                _ => false\n+            };\n+        }\n+    }\n+\n+    fn is_pass_byval(cls: &[x86_64_reg_class]) -> bool {\n+        return cls.len() > 0 &&\n+            (cls[0] == memory_class ||\n+             cls[0] == x87_class ||\n+             cls[0] == complex_x87_class);\n+    }\n+\n+    fn is_ret_bysret(cls: &[x86_64_reg_class]) -> bool {\n+        return cls.len() > 0 && cls[0] == memory_class;\n+    }\n+\n+    fn x86_64_ty(ty: TypeRef,\n+                 is_mem_cls: fn(cls: &[x86_64_reg_class]) -> bool,\n+                 attr: Attribute) -> (x86_64_llty, Option<Attribute>) {\n+        let mut cast = false;\n+        let mut ty_attr = option::None;\n+        let mut llty = ty;\n+        if !is_reg_ty(ty) {\n+            let cls = classify_ty(ty);\n+            if is_mem_cls(cls) {\n+                llty = T_ptr(ty);\n+                ty_attr = option::Some(attr);\n+            } else {\n+                cast = true;\n+                llty = llreg_ty(cls);\n+            }\n+        }\n+        return ({ cast: cast, ty: llty }, ty_attr);\n+    }\n+\n+    let mut arg_tys = ~[];\n+    let mut attrs = ~[];\n+    for vec::each(atys) |t| {\n+        let (ty, attr) = x86_64_ty(*t, is_pass_byval, ByValAttribute);\n+        arg_tys.push(ty);\n+        attrs.push(attr);\n+    }\n+    let mut (ret_ty, ret_attr) = x86_64_ty(rty, is_ret_bysret,\n+                                       StructRetAttribute);\n+    let sret = ret_attr.is_some();\n+    if sret {\n+        arg_tys = vec::append(~[ret_ty], arg_tys);\n+        ret_ty = { cast:  false,\n+                   ty: T_void()\n+                 };\n+        attrs = vec::append(~[ret_attr], attrs);\n+    } else if !ret_def {\n+        ret_ty = { cast: false,\n+                   ty: T_void()\n+                 };\n+    }\n+    return {\n+        arg_tys: arg_tys,\n+        ret_ty: ret_ty,\n+        attrs: attrs,\n+        sret: sret\n+    };\n+}\n+\n+fn decl_x86_64_fn(tys: x86_64_tys,\n+                  decl: fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n+    let atys = vec::map(tys.arg_tys, |t| t.ty);\n+    let rty = tys.ret_ty.ty;\n+    let fnty = T_fn(atys, rty);\n+    let llfn = decl(fnty);\n+\n+    for vec::eachi(tys.attrs) |i, a| {\n+        match *a {\n+            option::Some(attr) => {\n+                unsafe {\n+                    let llarg = get_param(llfn, i);\n+                    llvm::LLVMAddAttribute(llarg, attr as c_uint);\n+                }\n+            }\n+            _ => ()\n+        }\n     }\n+    return llfn;\n }\n \n fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> ~str {\n@@ -63,7 +470,7 @@ type c_stack_tys = {\n     ret_def: bool,\n     bundle_ty: TypeRef,\n     shim_fn_ty: TypeRef,\n-    fn_ty: cabi::FnType\n+    x86_64_tys: Option<x86_64_tys>\n };\n \n fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n@@ -86,15 +493,20 @@ fn c_stack_tys(ccx: @crate_ctxt,\n     // XXX: Bad copy.\n     let bundle_ty = T_struct(vec::append_one(copy llargtys, T_ptr(llretty)));\n     let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n-    let fn_ty = abi_info(ccx.sess.targ_cfg.arch).\n-                    compute_info(llargtys, llretty, ret_def);\n+    let x86_64 = if ccx.sess.targ_cfg.arch == arch_x86_64 {\n+        option::Some(x86_64_tys(llargtys, llretty, ret_def))\n+    } else if ccx.sess.targ_cfg.arch == arch_arm {\n+        option::Some(x86_64_tys(llargtys, llretty, ret_def))\n+    } else {\n+        option::None\n+    };\n     return @{\n         arg_tys: llargtys,\n         ret_ty: llretty,\n         ret_def: ret_def,\n         bundle_ty: bundle_ty,\n         shim_fn_ty: T_fn(~[T_ptr(bundle_ty)], T_void()),\n-        fn_ty: fn_ty\n+        x86_64_tys: x86_64\n     };\n }\n \n@@ -221,14 +633,92 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llargbundle: ValueRef) -> ~[ValueRef] {\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_args\");\n-            return tys.fn_ty.build_shim_args(bcx, tys.arg_tys, llargbundle);\n+            let mut llargvals = ~[];\n+            let mut i = 0u;\n+            let n = vec::len(tys.arg_tys);\n+\n+            match tys.x86_64_tys {\n+                Some(ref x86_64) => {\n+                    let mut atys = /*bad*/copy (*x86_64).arg_tys;\n+                    let mut attrs = /*bad*/copy (*x86_64).attrs;\n+                    if (*x86_64).sret {\n+                        let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n+                        let llretloc = Load(bcx, llretptr);\n+                        llargvals = ~[llretloc];\n+                        atys = vec::tail(atys);\n+                        attrs = vec::tail(attrs);\n+                    }\n+                    while i < n {\n+                        let llargval = if atys[i].cast {\n+                            let arg_ptr = GEPi(bcx, llargbundle, [0u, i]);\n+                            let arg_ptr = BitCast(bcx, arg_ptr,\n+                                              T_ptr(atys[i].ty));\n+                            Load(bcx, arg_ptr)\n+                        } else if attrs[i].is_some() {\n+                            GEPi(bcx, llargbundle, [0u, i])\n+                        } else {\n+                            load_inbounds(bcx, llargbundle, [0u, i])\n+                        };\n+                        llargvals.push(llargval);\n+                        i += 1u;\n+                    }\n+                }\n+                _ => {\n+                    while i < n {\n+                        let llargval = load_inbounds(bcx, llargbundle,\n+                                                          [0u, i]);\n+                        llargvals.push(llargval);\n+                        i += 1u;\n+                    }\n+                }\n+            }\n+            return llargvals;\n         }\n \n         fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef, llretval: ValueRef)  {\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n-            tys.fn_ty.build_shim_ret(bcx, tys.arg_tys, tys.ret_def,\n-                                     llargbundle, llretval);\n+            match tys.x86_64_tys {\n+                Some(ref x86_64) => {\n+                  for vec::eachi((*x86_64).attrs) |i, a| {\n+                        match *a {\n+                            Some(attr) => {\n+                                unsafe {\n+                                    llvm::LLVMAddInstrAttribute(\n+                                        llretval, (i + 1u) as c_uint,\n+                                                  attr as c_uint);\n+                                }\n+                            }\n+                            _ => ()\n+                        }\n+                    }\n+                    if (*x86_64).sret || !tys.ret_def {\n+                        return;\n+                    }\n+                    let n = vec::len(tys.arg_tys);\n+                    let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n+                    let llretloc = Load(bcx, llretptr);\n+                    if (*x86_64).ret_ty.cast {\n+                        let tmp_ptr = BitCast(bcx,\n+                                              llretloc,\n+                                              T_ptr((*x86_64).ret_ty.ty));\n+                        Store(bcx, llretval, tmp_ptr);\n+                    } else {\n+                        Store(bcx, llretval, llretloc);\n+                    };\n+                }\n+                _ => {\n+                    if tys.ret_def {\n+                        let n = vec::len(tys.arg_tys);\n+                        // R** llretptr = &args->r;\n+                        let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n+                        // R* llretloc = *llretptr; /* (args->r) */\n+                        let llretloc = Load(bcx, llretptr);\n+                        // *args->r = r;\n+                        Store(bcx, llretval, llretloc);\n+                    }\n+                }\n+            }\n         }\n \n         let lname = link_name(ccx, foreign_item);\n@@ -242,8 +732,16 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n     fn base_fn(ccx: @crate_ctxt, +lname: ~str, tys: @c_stack_tys,\n                cc: lib::llvm::CallConv) -> ValueRef {\n         // Declare the \"prototype\" for the base function F:\n-        do tys.fn_ty.decl_fn |fnty| {\n-            decl_fn(ccx.llmod, /*bad*/copy lname, cc, fnty)\n+        match tys.x86_64_tys {\n+          Some(ref x86_64) => {\n+            do decl_x86_64_fn((*x86_64)) |fnty| {\n+                decl_fn(ccx.llmod, /*bad*/copy lname, cc, fnty)\n+            }\n+          }\n+          _ => {\n+            let llbasefnty = T_fn(/*bad*/copy tys.arg_tys, tys.ret_ty);\n+            decl_fn(ccx.llmod, lname, cc, llbasefnty)\n+          }\n         }\n     }\n \n@@ -885,15 +1383,84 @@ fn trans_foreign_fn(ccx: @crate_ctxt, +path: ast_map::path,\n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_args\");\n-            tys.fn_ty.build_wrap_args(bcx, tys.ret_ty,\n-                                      llwrapfn, llargbundle);\n+            match tys.x86_64_tys {\n+                option::Some(ref x86_64) => {\n+                    let mut atys = /*bad*/copy (*x86_64).arg_tys;\n+                    let mut attrs = /*bad*/copy (*x86_64).attrs;\n+                    let mut j = 0u;\n+                    let llretptr = if (*x86_64).sret {\n+                        atys = vec::tail(atys);\n+                        attrs = vec::tail(attrs);\n+                        j = 1u;\n+                        get_param(llwrapfn, 0u)\n+                    } else if (*x86_64).ret_ty.cast {\n+                        let retptr = alloca(bcx, (*x86_64).ret_ty.ty);\n+                        BitCast(bcx, retptr, T_ptr(tys.ret_ty))\n+                    } else {\n+                        alloca(bcx, tys.ret_ty)\n+                    };\n+\n+                    let mut i = 0u;\n+                    let n = vec::len(atys);\n+                    while i < n {\n+                        let mut argval = get_param(llwrapfn, i + j);\n+                        if attrs[i].is_some() {\n+                            argval = Load(bcx, argval);\n+                            store_inbounds(bcx, argval, llargbundle,\n+                                           [0u, i]);\n+                        } else if atys[i].cast {\n+                            let argptr = GEPi(bcx, llargbundle, [0u, i]);\n+                            let argptr = BitCast(bcx, argptr,\n+                                                 T_ptr(atys[i].ty));\n+                            Store(bcx, argval, argptr);\n+                        } else {\n+                            store_inbounds(bcx, argval, llargbundle,\n+                                           [0u, i]);\n+                        }\n+                        i += 1u;\n+                    }\n+                    store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n+                }\n+                _ => {\n+                    let llretptr = alloca(bcx, tys.ret_ty);\n+                    let n = vec::len(tys.arg_tys);\n+                  for uint::range(0u, n) |i| {\n+                        let llargval = get_param(llwrapfn, i);\n+                        store_inbounds(bcx, llargval, llargbundle,\n+                                                      [0u, i]);\n+                    };\n+                    store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n+                }\n+            }\n         }\n \n         fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_ret\");\n-            tys.fn_ty.build_wrap_ret(bcx, tys.arg_tys, tys.ret_def,\n-                                     llargbundle);\n+            match tys.x86_64_tys {\n+                option::Some(ref x86_64) => {\n+                    if (*x86_64).sret || !tys.ret_def {\n+                        RetVoid(bcx);\n+                        return;\n+                    }\n+                    let n = vec::len(tys.arg_tys);\n+                    let llretval = load_inbounds(bcx, llargbundle, ~[0u, n]);\n+                    let llretval = if (*x86_64).ret_ty.cast {\n+                        let retptr = BitCast(bcx, llretval,\n+                                                  T_ptr((*x86_64).ret_ty.ty));\n+                        Load(bcx, retptr)\n+                    } else {\n+                        Load(bcx, llretval)\n+                    };\n+                    Ret(bcx, llretval);\n+                }\n+                _ => {\n+                    let n = vec::len(tys.arg_tys);\n+                    let llretval = load_inbounds(bcx, llargbundle, ~[0u, n]);\n+                    let llretval = Load(bcx, llretval);\n+                    Ret(bcx, llretval);\n+                }\n+            }\n         }\n \n         build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n@@ -920,12 +1487,25 @@ fn register_foreign_fn(ccx: @crate_ctxt,\n     let _icx = ccx.insn_ctxt(\"foreign::register_foreign_fn\");\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, node_id);\n-    let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n-    let fn_ty = abi_info(ccx.sess.targ_cfg.arch).\n-                    compute_info(llargtys, llretty, ret_def);\n-    do fn_ty.decl_fn |fnty| {\n-        register_fn_fuller(ccx, sp, /*bad*/copy path, node_id, attrs,\n-                           t, lib::llvm::CCallConv, fnty)\n+    return if ccx.sess.targ_cfg.arch == arch_x86_64 {\n+        let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n+        let x86_64 = x86_64_tys(llargtys, llretty, ret_def);\n+        do decl_x86_64_fn(x86_64) |fnty| {\n+            register_fn_fuller(ccx, sp, /*bad*/copy path, node_id, attrs,\n+                               t, lib::llvm::CCallConv, fnty)\n+        }\n+    } else if ccx.sess.targ_cfg.arch == arch_arm {\n+        let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n+        let x86_64 = x86_64_tys(llargtys, llretty, ret_def);\n+        do decl_x86_64_fn(x86_64) |fnty| {\n+            register_fn_fuller(ccx, sp, /*bad*/copy path, node_id, attrs,\n+                               t, lib::llvm::CCallConv, fnty)\n+        }\n+\n+    } else {\n+        let llfty = T_fn(llargtys, llretty);\n+        register_fn_fuller(ccx, sp, path, node_id, attrs,\n+                           t, lib::llvm::CCallConv, llfty)\n     }\n }\n "}, {"sha": "4e101eb5bb7089fca45349aa1802f7bf6d983f94", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/625405562c278cb2e45bec6805f13d2c1de8049e/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/625405562c278cb2e45bec6805f13d2c1de8049e/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=625405562c278cb2e45bec6805f13d2c1de8049e", "patch": "@@ -86,10 +86,6 @@ mod middle {\n         #[legacy_exports]\n         mod meth;\n         #[legacy_exports]\n-        mod cabi;\n-        #[legacy_exports]\n-        mod cabi_x86_64;\n-        #[legacy_exports]\n         mod foreign;\n         #[legacy_exports]\n         mod reflect;"}]}