{"sha": "bd61bec67d23e11a37a19a3a554753419c734947", "node_id": "C_kwDOAAsO6NoAKGJkNjFiZWM2N2QyM2UxMWEzN2ExOWEzYTU1NDc1MzQxOWM3MzQ5NDc", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-04-06T10:50:02Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-04-12T06:44:38Z"}, "message": "Add futex-based ReentrantMutex on Linux.", "tree": {"sha": "53fd86c91baaa8025d32d75479db5523cdeaa5d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53fd86c91baaa8025d32d75479db5523cdeaa5d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd61bec67d23e11a37a19a3a554753419c734947", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd61bec67d23e11a37a19a3a554753419c734947", "html_url": "https://github.com/rust-lang/rust/commit/bd61bec67d23e11a37a19a3a554753419c734947", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd61bec67d23e11a37a19a3a554753419c734947/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c62c8cb82d18ee36bc47e12e5722d51cc011f133", "url": "https://api.github.com/repos/rust-lang/rust/commits/c62c8cb82d18ee36bc47e12e5722d51cc011f133", "html_url": "https://github.com/rust-lang/rust/commit/c62c8cb82d18ee36bc47e12e5722d51cc011f133"}], "stats": {"total": 94, "additions": 88, "deletions": 6}, "files": [{"sha": "f49fbda0d82bd8302c22f5b24bf52454d5b5652c", "filename": "library/std/src/sys/unix/locks/futex.rs", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/bd61bec67d23e11a37a19a3a554753419c734947/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd61bec67d23e11a37a19a3a554753419c734947/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs?ref=bd61bec67d23e11a37a19a3a554753419c734947", "patch": "@@ -1,8 +1,10 @@\n+use crate::cell::UnsafeCell;\n use crate::sync::atomic::{\n-    AtomicI32,\n+    AtomicI32, AtomicUsize,\n     Ordering::{Acquire, Relaxed, Release},\n };\n use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n+use crate::sys_common::thread_info::current_thread_unique_ptr;\n use crate::time::Duration;\n \n pub type MovableMutex = Mutex;\n@@ -162,3 +164,87 @@ impl Condvar {\n         r\n     }\n }\n+\n+/// A reentrant mutex. Used by stdout().lock() and friends.\n+///\n+/// The 'owner' field tracks which thread has locked the mutex.\n+///\n+/// We use current_thread_unique_ptr() as the thread identifier,\n+/// which is just the address of a thread local variable.\n+///\n+/// If `owner` is set to the identifier of the current thread,\n+/// we assume the mutex is already locked and instead of locking it again,\n+/// we increment `lock_count`.\n+///\n+/// When unlocking, we decrement `lock_count`, and only unlock the mutex when\n+/// it reaches zero.\n+///\n+/// `lock_count` is protected by the mutex and only accessed by the thread that has\n+/// locked the mutex, so needs no synchronization.\n+///\n+/// `owner` can be checked by other threads that want to see if they already\n+/// hold the lock, so needs to be atomic. If it compares equal, we're on the\n+/// same thread that holds the mutex and memory access can use relaxed ordering\n+/// since we're not dealing with multiple threads. If it compares unequal,\n+/// synchronization is left to the mutex, making relaxed memory ordering for\n+/// the `owner` field fine in all cases.\n+pub struct ReentrantMutex {\n+    mutex: Mutex,\n+    owner: AtomicUsize,\n+    lock_count: UnsafeCell<u32>,\n+}\n+\n+unsafe impl Send for ReentrantMutex {}\n+unsafe impl Sync for ReentrantMutex {}\n+\n+impl ReentrantMutex {\n+    #[inline]\n+    pub const unsafe fn uninitialized() -> Self {\n+        Self { mutex: Mutex::new(), owner: AtomicUsize::new(0), lock_count: UnsafeCell::new(0) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&self) {}\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {}\n+\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let this_thread = current_thread_unique_ptr();\n+        if self.owner.load(Relaxed) == this_thread {\n+            self.increment_lock_count();\n+            true\n+        } else if self.mutex.try_lock() {\n+            self.owner.store(this_thread, Relaxed);\n+            *self.lock_count.get() = 1;\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        let this_thread = current_thread_unique_ptr();\n+        if self.owner.load(Relaxed) == this_thread {\n+            self.increment_lock_count();\n+        } else {\n+            self.mutex.lock();\n+            self.owner.store(this_thread, Relaxed);\n+            *self.lock_count.get() = 1;\n+        }\n+    }\n+\n+    unsafe fn increment_lock_count(&self) {\n+        *self.lock_count.get() = (*self.lock_count.get())\n+            .checked_add(1)\n+            .expect(\"lock count overflow in reentrant mutex\");\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        *self.lock_count.get() -= 1;\n+        if *self.lock_count.get() == 0 {\n+            self.owner.store(0, Relaxed);\n+            self.mutex.unlock();\n+        }\n+    }\n+}"}, {"sha": "e0404f40c69bfbdcd0b9fddce862b4d5af2f2ade", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd61bec67d23e11a37a19a3a554753419c734947/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd61bec67d23e11a37a19a3a554753419c734947/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=bd61bec67d23e11a37a19a3a554753419c734947", "patch": "@@ -5,11 +5,7 @@ cfg_if::cfg_if! {\n     ))] {\n         mod futex;\n         mod futex_rwlock;\n-        #[allow(dead_code)]\n-        mod pthread_mutex; // Only used for PthreadMutexAttr, needed by pthread_remutex.\n-        mod pthread_remutex; // FIXME: Implement this using a futex\n-        pub use futex::{Mutex, MovableMutex, Condvar, MovableCondvar};\n-        pub use pthread_remutex::ReentrantMutex;\n+        pub use futex::{Mutex, MovableMutex, Condvar, MovableCondvar, ReentrantMutex};\n         pub use futex_rwlock::{RwLock, MovableRwLock};\n     } else {\n         mod pthread_mutex;"}]}