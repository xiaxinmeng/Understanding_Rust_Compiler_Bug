{"sha": "f909dd114d675a1d1bd8e0676991f052be85237f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MDlkZDExNGQ2NzVhMWQxYmQ4ZTA2NzY5OTFmMDUyYmU4NTIzN2Y=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-05-18T22:34:21Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-19T18:40:16Z"}, "message": "Remove dead file (typestate_check is now a bunch of modules under middle/tstate)", "tree": {"sha": "b42e46c6a953b3bdb93f9d35ca158721b57959e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b42e46c6a953b3bdb93f9d35ca158721b57959e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f909dd114d675a1d1bd8e0676991f052be85237f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f909dd114d675a1d1bd8e0676991f052be85237f", "html_url": "https://github.com/rust-lang/rust/commit/f909dd114d675a1d1bd8e0676991f052be85237f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f909dd114d675a1d1bd8e0676991f052be85237f/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b624b43e4774d1dd421979946a09a36162a0aff1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b624b43e4774d1dd421979946a09a36162a0aff1", "html_url": "https://github.com/rust-lang/rust/commit/b624b43e4774d1dd421979946a09a36162a0aff1"}], "stats": {"total": 2377, "additions": 0, "deletions": 2377}, "files": [{"sha": "a183ed3d1221a088c0d32eae592980d77de8bc07", "filename": "src/comp/middle/typestate_check.rs", "status": "removed", "additions": 0, "deletions": 2377, "changes": 2377, "blob_url": "https://github.com/rust-lang/rust/blob/b624b43e4774d1dd421979946a09a36162a0aff1/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b624b43e4774d1dd421979946a09a36162a0aff1/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=b624b43e4774d1dd421979946a09a36162a0aff1", "patch": "@@ -1,2377 +0,0 @@\n-import front::ast;\n-import front::ast::ann;\n-import front::ast::method;\n-import front::ast::ty;\n-import front::ast::mutability;\n-import front::ast::item;\n-import front::ast::block;\n-import front::ast::block_;\n-import front::ast::obj_field;\n-import front::ast::decl;\n-import front::ast::arm;\n-import front::ast::stmt;\n-import front::ast::stmt_;\n-import front::ast::stmt_decl;\n-import front::ast::stmt_expr;\n-import front::ast::stmt_crate_directive;\n-import front::ast::decl_local;\n-import front::ast::decl_item;\n-import front::ast::ident;\n-import front::ast::def_id;\n-import front::ast::ann;\n-import front::ast::field;\n-import front::ast::expr;\n-import front::ast::expr_call;\n-import front::ast::expr_vec;\n-import front::ast::expr_tup;\n-import front::ast::expr_path;\n-import front::ast::expr_field;\n-import front::ast::expr_index;\n-import front::ast::expr_log;\n-import front::ast::expr_block;\n-import front::ast::expr_rec;\n-import front::ast::expr_if;\n-import front::ast::expr_binary;\n-import front::ast::expr_unary;\n-import front::ast::expr_assign;\n-import front::ast::expr_assign_op;\n-import front::ast::expr_while;\n-import front::ast::expr_do_while;\n-import front::ast::expr_alt;\n-import front::ast::expr_lit;\n-import front::ast::expr_ret;\n-import front::ast::expr_self_method;\n-import front::ast::expr_bind;\n-import front::ast::expr_spawn;\n-import front::ast::expr_ext;\n-import front::ast::expr_fail;\n-import front::ast::expr_break;\n-import front::ast::expr_cont;\n-import front::ast::expr_send;\n-import front::ast::expr_recv;\n-import front::ast::expr_put;\n-import front::ast::expr_port;\n-import front::ast::expr_chan;\n-import front::ast::expr_be;\n-import front::ast::expr_check;\n-import front::ast::expr_assert;\n-import front::ast::expr_cast;\n-import front::ast::expr_for;\n-import front::ast::expr_for_each;\n-import front::ast::path;\n-import front::ast::elt;\n-import front::ast::crate_directive;\n-import front::ast::fn_decl;\n-import front::ast::_obj;\n-import front::ast::native_mod;\n-import front::ast::variant;\n-import front::ast::ty_param;\n-import front::ast::ty;\n-import front::ast::proto;\n-import front::ast::pat;\n-import front::ast::binop;\n-import front::ast::unop;\n-import front::ast::def;\n-import front::ast::lit;\n-import front::ast::init_op;\n-import front::ast::initializer;\n-import front::ast::local;\n-import front::ast::_fn;\n-import front::ast::_obj;\n-import front::ast::_mod;\n-import front::ast::crate;\n-import front::ast::item_fn;\n-import front::ast::item_obj;\n-import front::ast::def_local;\n-\n-import middle::fold;\n-import middle::fold::respan;\n-import driver::session;\n-import util::common;\n-import util::common::span;\n-import util::common::spanned;\n-import util::common::new_str_hash;\n-import util::common::new_def_hash;\n-import util::common::uistr;\n-import util::common::elt_exprs;\n-import util::common::field_exprs;\n-import util::common::log_expr;\n-import util::common::log_expr_err;\n-import util::common::log_stmt;\n-import util::common::log_block;\n-import util::common::log_stmt_err;\n-import util::common::log_fn_err;\n-import util::common::log_fn;\n-import util::common::log_block_err;\n-import util::common::has_nonlocal_exits;\n-import util::common::decl_lhs;\n-import util::typestate_ann;\n-import util::typestate_ann::ts_ann;\n-import util::typestate_ann::empty_pre_post;\n-import util::typestate_ann::empty_poststate;\n-import util::typestate_ann::true_precond;\n-import util::typestate_ann::true_postcond;\n-import util::typestate_ann::false_postcond;\n-import util::typestate_ann::postcond;\n-import util::typestate_ann::precond;\n-import util::typestate_ann::poststate;\n-import util::typestate_ann::prestate;\n-import util::typestate_ann::pre_and_post;\n-import util::typestate_ann::get_pre;\n-import util::typestate_ann::get_post;\n-import util::typestate_ann::ann_precond;\n-import util::typestate_ann::ann_prestate;\n-import util::typestate_ann::set_precondition;\n-import util::typestate_ann::set_postcondition;\n-import util::typestate_ann::set_prestate;\n-import util::typestate_ann::set_poststate;\n-import util::typestate_ann::set_in_postcond;\n-import util::typestate_ann::set_in_poststate;\n-import util::typestate_ann::implies;\n-import util::typestate_ann::pre_and_post_state;\n-import util::typestate_ann::empty_states;\n-import util::typestate_ann::empty_prestate;\n-import util::typestate_ann::empty_ann;\n-import util::typestate_ann::extend_prestate;\n-import util::typestate_ann::extend_poststate;\n-import util::typestate_ann::relax_prestate;\n-import util::typestate_ann::intersect;\n-import util::typestate_ann::pp_clone;\n-import util::typestate_ann::clone;\n-\n-import middle::ty;\n-import middle::ty::ann_to_type;\n-import middle::ty::arg;\n-import middle::ty::expr_ann;\n-import middle::ty::ty_to_str;\n-\n-import pretty::pprust::print_block;\n-import pretty::pprust::print_expr;\n-import pretty::pprust::print_decl;\n-import pretty::pp::mkstate;\n-import std::io::stdout;\n-import std::io::str_writer;\n-import std::io::string_writer;\n-import std::vec::map;\n-import std::vec;\n-import std::vec::len;\n-import std::vec::pop;\n-import std::vec::push;\n-import std::vec::slice;\n-import std::vec::unzip;\n-import std::vec::plus_option;\n-import std::vec::cat_options;\n-import std::option;\n-import std::option::t;\n-import std::option::some;\n-import std::option::none;\n-import std::option::from_maybe;\n-import std::option::maybe;\n-import std::option::is_none;\n-import std::option::get;\n-import std::map::hashmap;\n-import std::list;\n-import std::list::list;\n-import std::list::cons;\n-import std::list::nil;\n-import std::list::foldl;\n-import std::list::find;\n-import std::uint;\n-import std::bitv;\n-import std::util::fst;\n-import std::util::snd;\n-\n-import util::typestate_ann;\n-import util::typestate_ann::difference;\n-import util::typestate_ann::union;\n-import util::typestate_ann::pps_len;\n-import util::typestate_ann::require_and_preserve;\n-\n-import resolve::def_map;\n-\n-/**** debugging junk  ****/\n-\n-fn bitv_to_str(fn_info enclosing, bitv::t v) -> str {\n-  auto s = \"\";\n-\n-  for each (@tup(def_id, tup(uint, ident)) p in enclosing.items()) {\n-    if (bitv::get(v, p._1._0)) {\n-      s += \" \" + p._1._1 + \" \";\n-    }\n-  }\n-  ret s;\n-}\n-\n-fn log_bitv(fn_info enclosing, bitv::t v) {\n-    log(bitv_to_str(enclosing, v));\n-}\n-\n-fn log_bitv_err(fn_info enclosing, bitv::t v) {\n-    log_err(bitv_to_str(enclosing, v));\n-}\n-\n-fn tos (vec[uint] v) -> str {\n-  auto res = \"\";\n-  for (uint i in v) {\n-    if (i == 0u) {\n-      res += \"0\";\n-    }\n-    else {\n-      res += \"1\";\n-    }\n-  }\n-  ret res;\n-}\n-\n-fn log_cond(vec[uint] v) -> () {\n-    log(tos(v));\n-}\n-fn log_cond_err(vec[uint] v) -> () {\n-    log_err(tos(v));\n-}\n-\n-fn log_pp(&pre_and_post pp) -> () {\n-  auto p1 = bitv::to_vec(pp.precondition);\n-  auto p2 = bitv::to_vec(pp.postcondition);\n-  log(\"pre:\");\n-  log_cond(p1);\n-  log(\"post:\");\n-  log_cond(p2);\n-}\n-\n-fn log_pp_err(&pre_and_post pp) -> () {\n-  auto p1 = bitv::to_vec(pp.precondition);\n-  auto p2 = bitv::to_vec(pp.postcondition);\n-  log_err(\"pre:\");\n-  log_cond_err(p1);\n-  log_err(\"post:\");\n-  log_cond_err(p2);\n-}\n-\n-fn log_states(&pre_and_post_state pp) -> () {\n-  auto p1 = bitv::to_vec(pp.prestate);\n-  auto p2 = bitv::to_vec(pp.poststate);\n-  log(\"prestate:\");\n-  log_cond(p1);\n-  log(\"poststate:\");\n-  log_cond(p2);\n-}\n-\n-fn log_states_err(&pre_and_post_state pp) -> () {\n-  auto p1 = bitv::to_vec(pp.prestate);\n-  auto p2 = bitv::to_vec(pp.poststate);\n-  log_err(\"prestate:\");\n-  log_cond_err(p1);\n-  log_err(\"poststate:\");\n-  log_cond_err(p2);\n-}\n-\n-fn print_ident(&ident i) -> () {\n-  log(\" \" + i + \" \");\n-}\n-\n-fn print_idents(vec[ident] idents) -> () {\n-  if(len[ident](idents) == 0u) {\n-    ret;\n-  }\n-  else {\n-    log(\"an ident: \" + pop[ident](idents));\n-    print_idents(idents);\n-  }\n-}\n-/**********************************************************************/\n-/* mapping from variable name (def_id is assumed to be for a local\n-   variable in a given function) to bit number \n-   (also remembers the ident for error-logging purposes) */\n-type var_info     = tup(uint, ident);\n-type fn_info      = std::map::hashmap[def_id, var_info];\n-/* mapping from function name to fn_info map */\n-type fn_info_map = std::map::hashmap[def_id, fn_info];\n- \n-fn bit_num(def_id v, fn_info m) -> uint {\n-  assert (m.contains_key(v));\n-  ret m.get(v)._0;\n-}\n-fn get_fn_info(fn_info_map fm, def_id did) -> fn_info {\n-    assert (fm.contains_key(did));\n-    ret fm.get(did);\n-}\n-\n-fn var_is_local(def_id v, fn_info m) -> bool {\n-  ret (m.contains_key(v));\n-}\n-\n-fn num_locals(fn_info m) -> uint {\n-  ret m.size();\n-}\n-\n-fn collect_local(&@vec[tup(ident, def_id)] vars, &span sp, &@ast::local loc)\n-    -> @decl {\n-    log(\"collect_local: pushing \" + loc.ident);\n-    vec::push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n-    ret @respan(sp, decl_local(loc));\n-}\n-\n-fn find_locals(_fn f) -> @vec[tup(ident,def_id)] {\n-  auto res = @vec::alloc[tup(ident,def_id)](0u);\n-\n-  auto fld = fold::new_identity_fold[@vec[tup(ident, def_id)]]();\n-  fld = @rec(fold_decl_local = bind collect_local(_,_,_) with *fld);\n-  auto ignore = fold::fold_fn[@vec[tup(ident, def_id)]](res, fld, f);\n-\n-  ret res;\n-}\n-\n-fn add_var(def_id v, ident nm, uint next, fn_info tbl) -> uint {\n-    log(nm + \" |-> \" + util::common::uistr(next));\n-  tbl.insert(v, tup(next,nm));\n-  ret (next + 1u);\n-}\n-\n-/* builds a table mapping each local var defined in f\n- to a bit number in the precondition/postcondition vectors */\n-fn mk_fn_info(_fn f) -> fn_info {\n-  auto res = new_def_hash[var_info]();\n-  let uint next = 0u;\n-  let vec[ast::arg] f_args = f.decl.inputs;\n-\n-  /* ignore args, which we know are initialized;\n-     just collect locally declared vars */\n-\n-  let @vec[tup(ident,def_id)] locals = find_locals(f);\n-  log(uistr(vec::len[tup(ident, def_id)](*locals)) + \" locals\");\n-  for (tup(ident,def_id) p in *locals) {\n-    next = add_var(p._1, p._0, next, res);\n-  }\n-\n-  ret res;\n-}\n-\n-/* extends mk_fn_info to a function item, side-effecting the map fi from\n-   function IDs to fn_info maps */\n-fn mk_fn_info_item_fn(&fn_info_map fi, &span sp, &ident i, &ast::_fn f,\n-                 &vec[ast::ty_param] ty_params, &def_id id, &ann a) -> @item {\n-  fi.insert(id, mk_fn_info(f));\n-  log(i + \" has \" + uistr(num_locals(mk_fn_info(f))) + \" local vars\");\n-  ret @respan(sp, item_fn(i, f, ty_params, id, a));\n-}\n-\n-/* extends mk_fn_info to an obj item, side-effecting the map fi from\n-   function IDs to fn_info maps */\n-fn mk_fn_info_item_obj(&fn_info_map fi, &span sp, &ident i, &ast::_obj o,\n-                       &vec[ast::ty_param] ty_params,\n-                       &ast::obj_def_ids odid, &ann a) -> @item {\n-    auto all_methods = vec::clone[@method](o.methods);\n-    plus_option[@method](all_methods, o.dtor);\n-    for (@method m in all_methods) {\n-        fi.insert(m.node.id, mk_fn_info(m.node.meth));\n-        log(m.node.ident + \" has \" +\n-            uistr(num_locals(mk_fn_info(m.node.meth))) + \" local vars\");\n-    }\n-    ret @respan(sp, item_obj(i, o, ty_params, odid, a));\n-}\n-\n-/* initializes the global fn_info_map (mapping each function ID, including\n-   nested locally defined functions, onto a mapping from local variable name\n-   to bit number) */\n-fn mk_f_to_fn_info(@ast::crate c) -> fn_info_map {\n-  auto res = new_def_hash[fn_info]();\n-\n-  auto fld = fold::new_identity_fold[fn_info_map]();\n-  fld = @rec(fold_item_fn  = bind mk_fn_info_item_fn(_,_,_,_,_,_,_),\n-             fold_item_obj = bind mk_fn_info_item_obj(_,_,_,_,_,_,_)\n-               with *fld);\n-  fold::fold_crate[fn_info_map](res, fld, c);\n-\n-  ret res;\n-}\n-/**** Helpers ****/\n-fn ann_to_ts_ann(ann a, uint nv) -> ts_ann {\n-    alt (a.ts) {\n-        /* Kind of inconsistent. empty_ann()s everywhere\n-           or an option of a ts_ann? */\n-        case (none[@ts_ann])     { ret empty_ann(nv); }\n-        case (some[@ts_ann](?t)) { ret *t; }\n-    }\n-}\n-\n-fn ann_to_ts_ann_fail(ann a) -> option::t[@ts_ann] { ret a.ts; }\n-\n-fn ann_to_ts_ann_fail_more(ann a) -> @ts_ann {\n-    assert (! is_none[@ts_ann](a.ts));\n-    ret get[@ts_ann](a.ts);\n-}\n-\n-fn ann_to_poststate(ann a) -> poststate {\n-    ret (ann_to_ts_ann_fail_more(a)).states.poststate;\n-}\n-\n-fn stmt_to_ann(&stmt s) -> option::t[@ts_ann] {\n-  alt (s.node) {\n-    case (stmt_decl(_,?a)) {\n-        ret ann_to_ts_ann_fail(a);\n-    }\n-    case (stmt_expr(_,?a)) {\n-        ret ann_to_ts_ann_fail(a);\n-    }\n-    case (stmt_crate_directive(_)) {\n-      ret none[@ts_ann];\n-    }\n-  }\n-}\n-\n-/* fails if e has no annotation */\n-fn expr_states(@expr e) -> pre_and_post_state {\n-    alt (a.ts) {\n-        case (none[@ts_ann]) {\n-            log_err \"expr_pp: the impossible happened (no pre/post)\";\n-            fail;\n-        }\n-        case (some[@ts_ann](?p)) { ret p.states; }\n-    }\n-}\n-\n-/* fails if e has no annotation */\n-fn expr_pp(@expr e) -> pre_and_post {\n-    alt (expr_ann(e).ts) {\n-        case (none[@ts_ann]) {\n-            log_err \"expr_pp: the impossible happened (no pre/post)\";\n-            fail;\n-        }\n-        case (some[@ts_ann](?p)) { ret p.conditions; }\n-    }\n-}\n-\n-fn stmt_pp(&stmt s) -> pre_and_post {\n-    alt (stmt_to_ann(s)) {\n-        case (none[@ts_ann]) {\n-            log \"stmt_pp: the impossible happened (no annotation)\";\n-            fail;\n-        }\n-        case (some[@ts_ann](?p)) {\n-            ret p.conditions;\n-        }\n-    }\n-}\n-\n-/* fails if b has no annotation */\n-/* FIXME: factor out code in the following two functions (block_ts_ann) */\n-fn block_pp(&block b) -> pre_and_post {\n-    alt (b.node.a.ts) {\n-        case (none[@ts_ann]) {\n-            log_err \"block_pp: the impossible happened (no ty)\";\n-            fail;\n-        }\n-        case (some[@ts_ann](?ts)) { ret ts.conditions; }\n-    }\n-}\n-\n-fn block_states(&block b) -> pre_and_post_state {\n-    alt (b.node.a.ts) {\n-       case (none[@ts_ann]) {\n-           log_err \"block_states: the impossible happened (no ty)\";\n-           fail;\n-       }\n-       case (some[@ts_ann](?ts)) { ret ts.states; }\n-    }\n-}\n-\n-fn stmt_states(&stmt s, uint nv) -> pre_and_post_state {\n-  alt (stmt_to_ann(s)) {\n-    case (none[@ts_ann]) {\n-      ret empty_states(nv);\n-    }\n-    case (some[@ts_ann](?a)) {\n-      ret a.states;\n-    }\n-  }\n-}\n-\n-\n-fn expr_precond(@expr e) -> precond {\n-  ret (expr_pp(e)).precondition;\n-}\n-\n-fn expr_postcond(@expr e) -> postcond {\n-  ret (expr_pp(e)).postcondition;\n-}\n-\n-fn expr_prestate(@expr e) -> prestate {\n-  ret (expr_states(e)).prestate;\n-}\n-\n-fn expr_poststate(@expr e) -> poststate {\n-  ret (expr_states(e)).poststate;\n-}\n-\n-/*\n-fn stmt_precond(&stmt s) -> precond {\n-  ret (stmt_pp(s)).precondition;\n-}\n-\n-fn stmt_postcond(&stmt s) -> postcond {\n-  ret (stmt_pp(s)).postcondition;\n-}\n-*/\n-\n-fn states_to_poststate(&pre_and_post_state ss) -> poststate {\n-  ret ss.poststate;\n-}\n-\n-/*\n-fn stmt_prestate(&stmt s) -> prestate {\n-  ret (stmt_states(s)).prestate;\n-}\n-*/\n-fn stmt_poststate(&stmt s, uint nv) -> poststate {\n-  ret (stmt_states(s, nv)).poststate;\n-}\n-\n-fn block_postcond(&block b) -> postcond {\n-    ret (block_pp(b)).postcondition;\n-}\n-\n-fn block_poststate(&block b) -> poststate {\n-    ret (block_states(b)).poststate;\n-}\n-\n-/* returns a new annotation where the pre_and_post is p */\n-fn with_pp(ann a, pre_and_post p) -> ann {\n-    ret rec(id=ann.id, ty=ann.ty, tps=ann.tps,\n-            ts=some[@ts_ann](@rec(conditions=p,\n-                                  states=empty_states(pps_len(p)))));\n-}\n-\n-// Given a list of pres and posts for exprs e0 ... en,\n-// return the precondition for evaluating each expr in order.\n-// So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n-// precondition shouldn't include x.\n-fn seq_preconds(fn_info enclosing, vec[pre_and_post] pps) -> precond {\n-  let uint sz = len[pre_and_post](pps);\n-  let uint num_vars = num_locals(enclosing);\n-\n-  if (sz >= 1u) {\n-    auto first   = pps.(0);\n-    assert (pps_len(first) == num_vars);\n-    let precond rest = seq_preconds(enclosing,\n-                         slice[pre_and_post](pps, 1u, sz));\n-    difference(rest, first.postcondition);\n-    auto res = clone(first.precondition);\n-    union(res, rest);\n-\n-    log(\"seq_preconds:\");\n-    log(\"first.postcondition =\");\n-    log_bitv(enclosing, first.postcondition);\n-    log(\"rest =\");\n-    log_bitv(enclosing, rest);\n-    log(\"returning\");\n-    log_bitv(enclosing, res);\n-\n-    ret res;\n-  }\n-  else {\n-      ret true_precond(num_vars);\n-  }\n-}\n-\n-/* works on either postconds or preconds\n- should probably rethink the whole type synonym situation */\n-fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-  auto sz = vec::len[postcond](rest);\n-\n-  if (sz > 0u) {\n-    auto other = rest.(0);\n-    union(first, other);\n-    union_postconds_go(first, slice[postcond](rest, 1u, len[postcond](rest)));\n-  }\n-\n-  ret first;\n-}\n-\n-fn union_postconds(uint nv, &vec[postcond] pcs) -> postcond {\n-  if (len[postcond](pcs) > 0u) {\n-      ret union_postconds_go(bitv::clone(pcs.(0)), pcs);\n-  }\n-  else {\n-      ret empty_prestate(nv);\n-  }\n-}\n-\n-/* Gee, maybe we could use foldl or something */\n-fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-  auto sz = vec::len[postcond](rest);\n-\n-  if (sz > 0u) {\n-    auto other = rest.(0);\n-    intersect(first, other);\n-    intersect_postconds_go(first, slice[postcond](rest, 1u,\n-                                                  len[postcond](rest)));\n-  }\n-\n-  ret first;\n-}\n-\n-fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n-  assert (len[postcond](pcs) > 0u);\n-\n-  ret intersect_postconds_go(bitv::clone(pcs.(0)), pcs);\n-}\n-\n-/******* AST-traversing code ********/\n-\n-fn find_pre_post_mod(&_mod m) -> _mod {\n-    log(\"implement find_pre_post_mod!\");\n-    fail;\n-}\n-\n-fn find_pre_post_state_mod(&_mod m) -> bool {\n-    log(\"implement find_pre_post_state_mod!\");\n-    fail;\n-}\n-\n-fn find_pre_post_native_mod(&native_mod m) -> native_mod {\n-    log(\"implement find_pre_post_native_mod\");\n-    fail;\n-}\n-\n-fn find_pre_post_state_native_mod(&native_mod m) -> bool {\n-    log(\"implement find_pre_post_state_native_mod!\");\n-    fail;\n-}\n- \n-fn find_pre_post_obj(&def_map dm, &fn_info_map fm, _obj o) -> () {\n-    fn do_a_method(def_map dm, fn_info_map fm, &@method m) -> () {\n-        assert (fm.contains_key(m.node.id));\n-        find_pre_post_fn(dm, fm, fm.get(m.node.id), m.node.meth);\n-    }\n-    auto f = bind do_a_method(dm, fm, _);\n-    vec::map[@method, ()](f, o.methods);\n-    option::map[@method, ()](f, o.dtor);\n-}\n-\n-fn find_pre_post_state_obj(&def_map dm, &fn_info_map fm, _obj o) -> bool {\n-    fn do_a_method(def_map dm, fn_info_map fm, &@method m) -> bool {\n-        assert (fm.contains_key(m.node.id));\n-        ret find_pre_post_state_fn(dm, fm, fm.get(m.node.id), m.node.meth);\n-    }\n-    auto f = bind do_a_method(dm, fm, _);\n-    auto flags = vec::map[@method, bool](f, o.methods);\n-    auto changed = vec::or(flags);\n-    changed = changed || maybe[@method, bool](false, f, o.dtor);\n-    ret changed;\n-}\n-\n-fn find_pre_post_item(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n-                      &item i) -> () {\n-  alt (i.node) {\n-    case (ast::item_const(?id, ?t, ?e, ?di, ?a)) {\n-        find_pre_post_expr(dm, fm, enclosing, e);\n-    }\n-    case (ast::item_fn(?id, ?f, ?ps, ?di, ?a)) {\n-      assert (fm.contains_key(di));\n-      find_pre_post_fn(dm, fm, fm.get(di), f);\n-    }\n-    case (ast::item_mod(?id, ?m, ?di)) {\n-      find_pre_post_mod(m);\n-    }\n-    case (ast::item_native_mod(?id, ?nm, ?di)) {\n-      find_pre_post_native_mod(nm);\n-    }\n-    case (ast::item_ty(_,_,_,_,_)) {\n-      ret;\n-    }\n-    case (ast::item_tag(_,_,_,_,_)) {\n-      ret;\n-    }\n-    case (ast::item_obj(?id, ?o, ?ps, ?di, ?a)) {\n-        find_pre_post_obj(dm, fm, o);\n-    }\n-  }\n-}\n-\n-/* Finds the pre and postcondition for each expr in <args>;\n-   sets the precondition in a to be the result of combining\n-   the preconditions for <args>, and the postcondition in a to \n-   be the union of all postconditions for <args> */\n-fn find_pre_post_exprs(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n-                       &vec[@expr] args, ann a) {\n-    auto nv = num_locals(enclosing);\n-\n-    fn do_one(def_map dm, fn_info_map fm, fn_info enclosing,\n-              &@expr e) -> () {\n-        find_pre_post_expr(dm, fm, enclosing, e);\n-    }\n-    auto f = bind do_one(dm, fm, enclosing, _);\n-\n-    vec::map[@expr, ()](f, args);\n-\n-    fn get_pp(&@expr e) -> pre_and_post {\n-        ret expr_pp(e);\n-    }\n-    auto g = get_pp;\n-    auto pps = vec::map[@expr, pre_and_post](g, args);\n-    auto h = get_post;\n-\n-    set_pre_and_post(a,\n-       rec(precondition=seq_preconds(enclosing, pps),\n-           postcondition=union_postconds\n-           (nv, (vec::map[pre_and_post, postcond](h, pps)))));\n-}\n-\n-fn find_pre_post_loop(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n-                      &@decl d, &@expr index, &block body, &ann a) -> () {\n-    find_pre_post_expr(dm, fm, enclosing, index);\n-    find_pre_post_block(dm, fm, enclosing, body);\n-    auto loop_precond = declare_var(enclosing, decl_lhs(d),\n-           seq_preconds(enclosing, [expr_pp(index),\n-                                       block_pp(body)]));\n-    auto loop_postcond = intersect_postconds\n-        ([expr_postcond(index), block_postcond(body)]);\n-    set_pre_and_post(a, rec(precondition=loop_precond,\n-                            postcondition=loop_postcond));\n-}\n-\n-/* Fills in annotations as a side effect. Does not rebuild the expr */\n-fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n-                      @expr e) -> () {\n-    auto num_local_vars = num_locals(enclosing);\n-\n-    log(\"find_pre_post_expr (num_locals =\" +\n-        uistr(num_local_vars) + \"):\");\n-    log_expr(*e);\n-    \n-    alt (e.node) {\n-        case (expr_call(?operator, ?operands, ?a)) {\n-            auto args = vec::clone[@expr](operands);\n-            vec::push[@expr](args, operator);\n-            find_pre_post_exprs(dm, fm, enclosing, args, a);\n-        }\n-        case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n-            auto args = vec::clone[@expr](operands);\n-            vec::push[@expr](args, operator);\n-            find_pre_post_exprs(dm, fm, enclosing, args, a);\n-        }\n-        case (expr_vec(?args, _, ?a)) {\n-            find_pre_post_exprs(dm, fm, enclosing, args, a);\n-        }\n-        case (expr_tup(?elts, ?a)) {\n-            find_pre_post_exprs(dm, fm, enclosing, elt_exprs(elts), a);\n-        }\n-        case (expr_path(?p, ?a)) {\n-            auto res = empty_pre_post(num_local_vars);\n-\n-            alt (dm.get(a.id)) {\n-                case (def_local(?d_id)) {\n-                    auto i = bit_num(d_id, enclosing);\n-                    require_and_preserve(i, res);\n-                }\n-                case (_) { /* nothing to check */ }\n-            }\n-\n-            // Otherwise, variable is global, so it must be initialized\n-            set_pre_and_post(a, res);\n-        }\n-        case (expr_self_method(?v, ?a)) {\n-            /* v is a method of the enclosing obj, so it must be\n-               initialized, right? */\n-            set_pre_and_post(a, empty_pre_post(num_local_vars));\n-        }\n-        case(expr_log(_, ?arg, ?a)) {\n-            find_pre_post_expr(dm, fm, enclosing, arg);\n-            set_pre_and_post(a, expr_pp(arg));\n-        }\n-        case (expr_chan(?arg, ?a)) {\n-            find_pre_post_expr(dm, fm, enclosing, arg);\n-            set_pre_and_post(a, expr_pp(arg));\n-        }\n-        case(expr_put(?opt, ?a)) {\n-            alt (opt) {\n-                case (some[@expr](?arg)) {\n-                    find_pre_post_expr(dm, fm, enclosing, arg);\n-                    set_pre_and_post(a, expr_pp(arg));\n-                }\n-                case (none[@expr]) {\n-                    set_pre_and_post(a, empty_pre_post(num_local_vars));\n-                }\n-            }\n-        }\n-        case (expr_block(?b, ?a)) {\n-            find_pre_post_block(dm, fm, enclosing, b);\n-            set_pre_and_post(a, block_pp(b));\n-        }\n-        case (expr_rec(?fields,?maybe_base,?a)) {\n-            auto es = field_exprs(fields);\n-            vec::plus_option[@expr](es, maybe_base);\n-            find_pre_post_exprs(dm, fm, enclosing, es, a);\n-        }\n-        case (expr_assign(?lhs, ?rhs, ?a)) {\n-            alt (lhs.node) {\n-                case (expr_path(?p, ?a_lhs)) {\n-                    alt (dm.get(a_lhs.id))) {\n-                        case (def_local(?d_id)) {\n-                            find_pre_post_expr(dm, fm, enclosing, rhs);\n-                            set_pre_and_post(a, expr_pp(rhs));\n-                            log(\"gen:\");\n-                            log_expr(*e);\n-                            gen(enclosing, a, d_id);\n-                            ret;\n-                        }\n-                        case (_) {}\n-                    }\n-                }\n-                case (_) {}\n-            }\n-            // doesn't check that lhs is an lval, but\n-            // that's probably ok\n-            find_pre_post_exprs(dm, fm, enclosing, [lhs, rhs], a);\n-        }\n-        case (expr_recv(?lhs, ?rhs, ?a)) {\n-            alt (lhs.node) {\n-                case (expr_path(?p, ?a_lhs)) {\n-                    alt (dm.get(a_lhs.id)) {\n-                        case (def_local(?d_id)) {\n-                            find_pre_post_expr(dm, fm, enclosing, rhs);\n-                            set_pre_and_post(a, expr_pp(rhs));\n-                            log(\"gen:\");\n-                            log_expr(*e);\n-                            gen(enclosing, a, d_id);\n-                            ret;\n-                        }\n-                        case (_) {}\n-                    }\n-                }\n-                case (_) {}\n-            }\n-            // doesn't check that lhs is an lval, but\n-            // that's probably ok\n-            find_pre_post_exprs(dm, fm, enclosing, [lhs, rhs], a);\n-        }\n-        case (expr_assign_op(_, ?lhs, ?rhs, ?a)) {\n-            /* Different from expr_assign in that the lhs *must*\n-               already be initialized */\n-            find_pre_post_exprs(dm, fm, enclosing, [lhs, rhs], a);\n-        }\n-        case (expr_lit(_,?a)) {\n-            set_pre_and_post(a, empty_pre_post(num_local_vars));\n-        }\n-        case (expr_ret(?maybe_val, ?a)) {\n-            alt (maybe_val) {\n-                case (none[@expr]) {\n-                    set_pre_and_post(a,\n-                      rec(precondition=true_precond(num_local_vars),\n-                          postcondition=false_postcond(num_local_vars)));\n-                }\n-                case (some[@expr](?ret_val)) {\n-                    find_pre_post_expr(dm, fm, enclosing, ret_val);\n-                    let pre_and_post pp =\n-                        rec(precondition=expr_precond(ret_val),\n-                            postcondition=false_postcond(num_local_vars));\n-                    set_pre_and_post(a, pp);\n-                }\n-            }\n-        }\n-        case (expr_be(?e, ?a)) {\n-            find_pre_post_expr(dm, fm, enclosing, e);\n-            set_pre_and_post(a, rec(precondition=expr_prestate(e),\n-                          postcondition=false_postcond(num_local_vars)));\n-        }\n-        case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n-            find_pre_post_expr(dm, fm, enclosing, antec);\n-            find_pre_post_block(dm, fm, enclosing, conseq);\n-            alt (maybe_alt) {\n-                case (none[@expr]) {\n-                    auto precond_res = seq_preconds(enclosing,\n-                                                    [expr_pp(antec),\n-                                                        block_pp(conseq)]);\n-                    set_pre_and_post(a, rec(precondition=precond_res,\n-                                            postcondition=\n-                                            expr_poststate(antec)));\n-                }\n-                case (some[@expr](?altern)) {\n-                    find_pre_post_expr(dm, fm, enclosing, altern);\n-                    auto precond_true_case =\n-                        seq_preconds(enclosing,\n-                                     [expr_pp(antec), block_pp(conseq)]);\n-                    auto postcond_true_case = union_postconds\n-                        (num_local_vars,\n-                         [expr_postcond(antec), block_postcond(conseq)]);\n-                    auto precond_false_case = seq_preconds\n-                        (enclosing,\n-                         [expr_pp(antec), expr_pp(altern)]);\n-                    auto postcond_false_case = union_postconds\n-                        (num_local_vars,\n-                         [expr_postcond(antec), expr_postcond(altern)]);\n-                    auto precond_res = union_postconds\n-                        (num_local_vars,\n-                         [precond_true_case, precond_false_case]);\n-                    auto postcond_res = intersect_postconds\n-                        ([postcond_true_case, postcond_false_case]);\n-                    set_pre_and_post(a, rec(precondition=precond_res,\n-                                            postcondition=postcond_res));\n-                }\n-            }\n-        }\n-        case (expr_binary(?bop,?l,?r,?a)) {\n-            /* *unless* bop is lazy (e.g. and, or)? \n-             FIXME */\n-            find_pre_post_exprs(dm, fm, enclosing, [l, r], a);\n-        }\n-        case (expr_send(?l, ?r, ?a)) {\n-            find_pre_post_exprs(dm, fm, enclosing, [l, r], a);\n-        }\n-        case (expr_unary(_,?operand,?a)) {\n-            find_pre_post_expr(dm, fm, enclosing, operand);\n-            set_pre_and_post(a, expr_pp(operand));\n-        }\n-        case (expr_cast(?operand, _, ?a)) {\n-            find_pre_post_expr(dm, fm, enclosing, operand);\n-            set_pre_and_post(a, expr_pp(operand));\n-        }\n-        case (expr_while(?test, ?body, ?a)) {\n-            find_pre_post_expr(dm, fm, enclosing, test);\n-            find_pre_post_block(dm, fm, enclosing, body);\n-            set_pre_and_post(a,\n-              rec(precondition=\n-                  seq_preconds(enclosing,\n-                                 [expr_pp(test), \n-                                     block_pp(body)]),\n-                  postcondition=\n-                  intersect_postconds([expr_postcond(test),\n-                                          block_postcond(body)])));\n-        }\n-        case (expr_do_while(?body, ?test, ?a)) {\n-            find_pre_post_block(dm, fm, enclosing, body);\n-            find_pre_post_expr(dm, fm, enclosing, test);\n-   \n-            auto loop_postcond = union_postconds(num_local_vars,\n-                            [block_postcond(body), expr_postcond(test)]);\n-            /* conservative approximination: if the body\n-               could break or cont, the test may never be executed */\n-            if (has_nonlocal_exits(body)) {\n-                loop_postcond = empty_poststate(num_local_vars);\n-            }\n-\n-            set_pre_and_post(a, \n-                             rec(precondition=seq_preconds(enclosing,\n-                                             [block_pp(body),\n-                                                 expr_pp(test)]),\n-                   postcondition=loop_postcond));\n-        }\n-        case (expr_for(?d, ?index, ?body, ?a)) {\n-            find_pre_post_loop(dm, fm, enclosing, d, index, body, a);\n-        }\n-        case (expr_for_each(?d, ?index, ?body, ?a)) {\n-            find_pre_post_loop(dm, fm, enclosing, d, index, body, a);\n-        }\n-        case (expr_index(?e, ?sub, ?a)) {\n-            find_pre_post_exprs(dm, fm, enclosing, [e, sub], a);\n-        }\n-        case (expr_alt(?e, ?alts, ?a)) {\n-            find_pre_post_expr(dm, fm, enclosing, e);\n-            fn do_an_alt(def_map dm, fn_info_map fm, fn_info enc, &arm an_alt)\n-                -> pre_and_post {\n-                find_pre_post_block(dm, fm, enc, an_alt.block);\n-                ret block_pp(an_alt.block);\n-            }\n-            auto f = bind do_an_alt(dm, fm, enclosing, _);\n-            auto alt_pps = vec::map[arm, pre_and_post](f, alts);\n-            fn combine_pp(pre_and_post antec, \n-                          fn_info enclosing, &pre_and_post pp,\n-                          &pre_and_post next) -> pre_and_post {\n-                union(pp.precondition, seq_preconds(enclosing,\n-                                         [antec, next]));\n-                intersect(pp.postcondition, next.postcondition);\n-                ret pp;\n-            }\n-            auto antec_pp = pp_clone(expr_pp(e)); \n-            auto e_pp  = rec(precondition=empty_prestate(num_local_vars),\n-                             postcondition=false_postcond(num_local_vars));\n-            auto g = bind combine_pp(antec_pp, enclosing, _, _);\n-\n-            auto alts_overall_pp = vec::foldl[pre_and_post, pre_and_post]\n-                                    (g, e_pp, alt_pps);\n-\n-            set_pre_and_post(a, alts_overall_pp);\n-        }\n-        case (expr_field(?operator, _, ?a)) {\n-            find_pre_post_expr(dm, fm, enclosing, operator);\n-            set_pre_and_post(a, expr_pp(operator));\n-        }\n-        case (expr_fail(?a)) {\n-            set_pre_and_post(a,\n-                             /* if execution continues after fail,\n-                                then everything is true! */\n-               rec(precondition=empty_prestate(num_local_vars),\n-                   postcondition=false_postcond(num_local_vars)));\n-        }\n-        case (expr_assert(?p, ?a)) {\n-            find_pre_post_expr(dm, fm, enclosing, p);\n-            set_pre_and_post(a, expr_pp(p));\n-        }\n-        case (expr_check(?p, ?a)) {\n-            /* will need to change when we support arbitrary predicates... */\n-            find_pre_post_expr(dm, fm, enclosing, p);\n-            set_pre_and_post(a, expr_pp(p));\n-        }\n-        case(expr_bind(?operator, ?maybe_args, ?a)) {\n-            auto args = vec::cat_options[@expr](maybe_args);\n-            vec::push[@expr](args, operator); /* ??? order of eval? */\n-            find_pre_post_exprs(dm, fm, enclosing, args, a);\n-        }\n-        case (expr_break(?a)) {\n-            set_pre_and_post(a, empty_pre_post(num_local_vars));\n-        }\n-        case (expr_cont(?a)) {\n-            set_pre_and_post(a, empty_pre_post(num_local_vars));\n-        }\n-        case (expr_port(?a)) {\n-            set_pre_and_post(a, empty_pre_post(num_local_vars));\n-        }\n-        case (expr_ext(_, _, _, ?expanded, ?a)) {\n-            find_pre_post_expr(dm, fm, enclosing, expanded);\n-            set_pre_and_post(a, expr_pp(expanded));\n-        }\n-    }\n-}\n-\n-fn gen(&fn_info enclosing, &ann a, def_id id) -> bool {\n-  assert (enclosing.contains_key(id));\n-  let uint i = (enclosing.get(id))._0;\n-  ret set_in_postcond(i, (ann_to_ts_ann_fail_more(a)).conditions);\n-}\n-\n-fn declare_var(&fn_info enclosing, def_id id, prestate pre)\n-   -> prestate {\n-    assert (enclosing.contains_key(id));\n-    let uint i = (enclosing.get(id))._0;\n-    auto res = clone(pre);\n-    relax_prestate(i, res);\n-    ret res;\n-}\n-\n-fn gen_poststate(&fn_info enclosing, &ann a, def_id id) -> bool {\n-  assert (enclosing.contains_key(id));\n-  let uint i = (enclosing.get(id))._0;\n-\n-  ret set_in_poststate(i, (ann_to_ts_ann_fail_more(a)).states);\n-}\n-\n-fn find_pre_post_stmt(&def_map dm, fn_info_map fm, &fn_info enclosing,\n-                      &ast::stmt s) -> () {\n-    log(\"stmt =\");\n-    log_stmt(s);\n-\n-  auto num_local_vars = num_locals(enclosing);\n-  alt(s.node) {\n-    case(ast::stmt_decl(?adecl, ?a)) {\n-        alt(adecl.node) {\n-            case(ast::decl_local(?alocal)) {\n-                alt(alocal.init) {\n-                    case(some[ast::initializer](?an_init)) {\n-                        find_pre_post_expr(dm, fm, enclosing, an_init.expr);\n-                        auto rhs_pp = expr_pp(an_init.expr);\n-                        set_pre_and_post(alocal.ann, rhs_pp);\n-\n-                        /* Inherit ann from initializer, and add var being\n-                           initialized to the postcondition */\n-                        set_pre_and_post(a, rhs_pp);\n-                        /*  log(\"gen (decl):\");\n-                            log_stmt(s); */\n-                        gen(enclosing, a, alocal.id); \n-                        /*                     log_err(\"for stmt\");\n-                        log_stmt(s);\n-                        log_err(\"pp = \");\n-                        log_pp(stmt_pp(s)); */\n-                    }\n-                    case(none[ast::initializer]) {\n-                        auto pp = empty_pre_post(num_local_vars);\n-                        set_pre_and_post(alocal.ann, pp);\n-                        set_pre_and_post(a, pp);\n-                    }\n-                }\n-            }\n-            case(decl_item(?anitem)) {\n-                auto pp = empty_pre_post(num_local_vars);\n-                set_pre_and_post(a, pp);\n-                find_pre_post_item(dm, fm, enclosing, *anitem);\n-            }\n-        }\n-    }\n-    case(stmt_expr(?e,?a)) {\n-        find_pre_post_expr(dm, fm, enclosing, e);\n-        set_pre_and_post(a, expr_pp(e));\n-    }    \n-  }\n-}\n-\n-fn find_pre_post_block(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n-                       block b) -> () {\n-    /* Want to say that if there is a break or cont in this\n-     block, then that invalidates the poststate upheld by\n-    any of the stmts after it. \n-    Given that the typechecker has run, we know any break will be in\n-    a block that forms a loop body. So that's ok. There'll never be an\n-    expr_break outside a loop body, therefore, no expr_break outside a block.\n-    */\n-\n-    /* Conservative approximation for now: This says that if a block contains\n-     *any* breaks or conts, then its postcondition doesn't promise anything.\n-     This will mean that:\n-     x = 0;\n-     break;\n-\n-     won't have a postcondition that says x is initialized, but that's ok.\n-     */\n-    auto nv = num_locals(enclosing);\n-\n-    fn do_one_(def_map dm, fn_info_map fm, fn_info i, &@stmt s) -> () {\n-        find_pre_post_stmt(dm, fm, i, *s);\n-        log(\"pre_post for stmt:\");\n-        log_stmt(*s);\n-        log(\"is:\");\n-        log_pp(stmt_pp(*s));\n-    }\n-    auto do_one = bind do_one_(dm, fm, enclosing, _);\n-    \n-    vec::map[@stmt, ()](do_one, b.node.stmts);\n-    fn do_inner_(def_map dm, fn_info_map fm, fn_info i, &@expr e) -> () {\n-        find_pre_post_expr(dm, fm, i, e);\n-    }\n-    auto do_inner = bind do_inner_(dm, fm, enclosing, _);\n-    option::map[@expr, ()](do_inner, b.node.expr);\n-\n-    let vec[pre_and_post] pps = [];\n-\n-    fn get_pp_stmt(&@stmt s) -> pre_and_post {\n-        ret stmt_pp(*s);\n-    }\n-    auto f = get_pp_stmt;\n-    pps += vec::map[@stmt, pre_and_post](f, b.node.stmts);\n-    fn get_pp_expr(&@expr e) -> pre_and_post {\n-        ret expr_pp(e);\n-    }\n-    auto g = get_pp_expr;\n-    plus_option[pre_and_post](pps,\n-       option::map[@expr, pre_and_post](g, b.node.expr));\n-\n-    auto block_precond  = seq_preconds(enclosing, pps);\n-    auto h = get_post;\n-    auto postconds =  vec::map[pre_and_post, postcond](h, pps);\n-    /* A block may be empty, so this next line ensures that the postconds\n-       vector is non-empty. */\n-    vec::push[postcond](postconds, block_precond);\n-    auto block_postcond = empty_poststate(nv);\n-    /* conservative approximation */\n-    if (! has_nonlocal_exits(b)) {\n-        block_postcond = union_postconds(nv, postconds);\n-    }\n-\n-    set_pre_and_post(b.node.a, rec(precondition=block_precond,\n-                                   postcondition=block_postcond));\n-}\n-\n-fn find_pre_post_fn(&def_map dm, &fn_info_map fm, &fn_info fi, &_fn f) -> () {\n-    find_pre_post_block(dm, fm, fi, f.body);\n-}\n-\n-fn check_item_fn(&def_map dm, &fn_info_map fm, &span sp, &ident i,\n-                 &ast::_fn f, &vec[ast::ty_param] ty_params,\n-                 &def_id id, &ann a) -> @item {\n-\n-    log(\"check_item_fn:\");\n-    log_fn(f, i, ty_params);\n-\n-  assert (fm.contains_key(id));\n-  find_pre_post_fn(dm, fm, fm.get(id), f);\n-\n-  ret @respan(sp, ast::item_fn(i, f, ty_params, id, a));\n-}\n-\n-fn find_pre_post_state_item(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n-                            @item i) -> bool {\n- alt (i.node) {\n-    case (ast::item_const(?id, ?t, ?e, ?di, ?a)) {\n-        ret find_pre_post_state_expr(dm, fm, enclosing,\n-              empty_prestate(num_locals(enclosing)), e);\n-    }\n-    case (ast::item_fn(?id, ?f, ?ps, ?di, ?a)) {\n-      assert (fm.contains_key(di));\n-      ret find_pre_post_state_fn(dm, fm, fm.get(di), f);\n-    }\n-    case (ast::item_mod(?id, ?m, ?di)) {\n-      ret find_pre_post_state_mod(m);\n-    }\n-    case (ast::item_native_mod(?id, ?nm, ?di)) {\n-      ret find_pre_post_state_native_mod(nm);\n-    }\n-    case (ast::item_ty(_,_,_,_,_)) {\n-      ret false;\n-    }\n-    case (ast::item_tag(_,_,_,_,_)) {\n-      ret false;\n-    }\n-    case (ast::item_obj(?id, ?o, ?ps, ?di, ?a)) {\n-        ret find_pre_post_state_obj(dm, fm, o);\n-    }\n-  }\n-}\n-\n-fn set_prestate_ann(@ann a, prestate pre) -> bool {\n-    assert (! is_none[@ts_ann](a.ts));\n-    ret set_prestate(get[@ts_ann](a.ts), pre);\n-}\n-\n-\n-fn extend_prestate_ann(ann a, prestate pre) -> bool {\n-    assert (! is_none[@ts_ann](a.ts));\n-    ret extend_prestate((get[@ts_ann](a.ts)).states.prestate, pre);\n-}\n-\n-fn set_poststate_ann(ann a, poststate post) -> bool {\n-    assert (! is_none[@ts_ann](a.ts));\n-    ret set_poststate(get[@ts_ann](a.ts), post);\n-}\n-\n-fn extend_poststate_ann(ann a, poststate post) -> bool {\n-    assert (! is_none[@ts_ann](a.ts));\n-    ret extend_poststate((*get[@ts_ann](a.ts)).states.poststate, post);\n-}\n-\n-fn set_pre_and_post(&ann a, pre_and_post pp) -> () {\n-    assert (! is_none[@ts_ann](a.ts));\n-    auto t = *get[@ts_ann](a.ts);\n-    /*  log(\"set_pre_and_post, old =\");\n-    log_pp(t.conditions);\n-    log(\"new =\");\n-    log_pp(pp);\n-    */\n-    set_precondition(t, pp.precondition);\n-    set_postcondition(t, pp.postcondition);\n-}\n-\n-fn seq_states(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n-    prestate pres, vec[@expr] exprs) -> tup(bool, poststate) {\n-  auto changed = false;\n-  auto post = pres;\n-\n-  for (@expr e in exprs) {\n-      changed = find_pre_post_state_expr(dm, fm, enclosing, post, e)\n-                || changed;\n-    post = expr_poststate(e);\n-  }\n-\n-  ret tup(changed, post);\n-}\n-\n-fn find_pre_post_state_exprs(&def_map dm,\n-                             &fn_info_map fm,\n-                             &fn_info enclosing,\n-                             &prestate pres,\n-                             &ann a, &vec[@expr] es) -> bool {\n-  auto res = seq_states(dm, fm, enclosing, pres, es);\n-  auto changed = res._0;\n-  changed = extend_prestate_ann(a, pres) || changed;\n-  changed = extend_poststate_ann(a, res._1) || changed;\n-  ret changed;\n-}\n-\n-fn pure_exp(&ann a, &prestate p) -> bool {\n-  auto changed = false;\n-  changed = extend_prestate_ann(a, p) || changed;\n-  changed = extend_poststate_ann(a, p) || changed;\n-  ret changed;\n-}\n-\n-fn find_pre_post_state_loop(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n-   &prestate pres, &@decl d, &@expr index, &block body, &ann a) -> bool {\n-    auto changed = false;\n-\n-    /* same issues as while */\n-    changed = extend_prestate_ann(a, pres) || changed;\n-    changed = find_pre_post_state_expr(dm, fm, enclosing, pres, index)\n-        || changed;\n-    /* in general, would need the intersection of\n-       (poststate of index, poststate of body) */\n-    changed = find_pre_post_state_block(dm, fm, enclosing,\n-                expr_poststate(index), body) || changed;\n-    auto res_p = intersect_postconds([expr_poststate(index),\n-                                         block_poststate(body)]);\n-  \n-    changed = extend_poststate_ann(a, res_p) || changed;\n-    ret changed;\n-}\n-\n-fn find_pre_post_state_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n-                            &prestate pres, @expr e) -> bool {\n-  auto changed = false;\n-  auto num_local_vars = num_locals(enclosing);\n-\n-  /* FIXME could get rid of some of the copy/paste */\n-  alt (e.node) {\n-    case (expr_vec(?elts, _, ?a)) {\n-      ret find_pre_post_state_exprs(dm, fm, enclosing, pres, a, elts); \n-    }\n-    case (expr_tup(?elts, ?a)) {\n-      ret find_pre_post_state_exprs(dm, fm, enclosing, pres, a,\n-                                    elt_exprs(elts));\n-    }\n-    case (expr_call(?operator, ?operands, ?a)) {\n-      /* do the prestate for the rator */\n-      changed = find_pre_post_state_expr(dm, fm, enclosing, pres, operator)\n-        || changed;\n-      /* rands go left-to-right */\n-      ret(find_pre_post_state_exprs(dm, fm, enclosing,\n-                                    expr_poststate(operator), a, operands)\n-          || changed);\n-    }\n-    case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, operator);\n-        ret(find_pre_post_state_exprs(dm, fm, enclosing,\n-                 expr_poststate(operator), a, operands)\n-          || changed);\n-    }\n-    case (expr_bind(?operator, ?maybe_args, ?a)) {\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, operator)\n-            || changed;\n-        ret (find_pre_post_state_exprs(dm, fm, enclosing,\n-          expr_poststate(operator), a, cat_options[@expr](maybe_args))\n-            || changed);\n-    }\n-    case (expr_path(_,?a)) {\n-      ret pure_exp(a, pres);\n-    }\n-    case (expr_log(_,?e,?a)) {\n-        /* factor out the \"one exp\" pattern */\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, e);\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n-        ret changed;\n-    }\n-    case (expr_chan(?e, ?a)) {\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, e);\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n-        ret changed;\n-    }\n-    case (expr_ext(_, _, _, ?expanded, ?a)) {\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, expanded);\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(expanded))\n-           || changed;\n-        ret changed;\n-    }\n-    case (expr_put(?maybe_e, ?a)) {\n-        alt (maybe_e) {\n-            case (some[@expr](?arg)) {\n-                changed = find_pre_post_state_expr(dm, fm, enclosing,\n-                                                   pres, arg);\n-                changed = extend_prestate_ann(a, pres) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(arg))\n-                    || changed;\n-                ret changed;\n-            }\n-            case (none[@expr]) {\n-                ret pure_exp(a, pres);\n-            }\n-        }\n-    }\n-    case (expr_lit(?l,?a)) {\n-        ret pure_exp(a, pres);\n-    }\n-    case (expr_block(?b,?a)) {\n-        changed = find_pre_post_state_block(dm, fm, enclosing, pres, b)\n-           || changed;\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, block_poststate(b)) || changed;\n-        ret changed;\n-    }\n-    case (expr_rec(?fields,?maybe_base,?a)) {\n-        changed = find_pre_post_state_exprs(dm, fm, enclosing, pres, a,\n-                                            field_exprs(fields)) || changed;\n-        alt (maybe_base) {\n-            case (none[@expr]) { /* do nothing */ }\n-            case (some[@expr](?base)) {\n-                changed = find_pre_post_state_expr\n-                    (dm, fm, enclosing, pres, base) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(base))\n-                    || changed;\n-            }\n-        }\n-        ret changed;\n-    }\n-    case (expr_assign(?lhs, ?rhs, ?a)) {\n-        extend_prestate_ann(a, pres);\n-\n-        alt (lhs.node) {\n-            case (expr_path(_, ?a_lhs)) {\n-                alt (dm.get(a_lhs.id)) {\n-                    case (def_local(?d_id)) {\n-                        // assignment to local var\n-                        changed = pure_exp(a_lhs, pres) || changed;\n-                        changed = find_pre_post_state_expr\n-                            (dm, fm, enclosing, pres, rhs) || changed;\n-                        changed = extend_poststate_ann\n-                            (a, expr_poststate(rhs)) || changed;\n-                        ret gen_poststate(enclosing, a, d_id)\n-                            || changed;\n-                    }\n-                    case (_) {}\n-                }\n-            }\n-            case (_) {}\n-        }\n-        // assignment to something that must already have been init'd\n-        changed = find_pre_post_state_expr\n-            (dm, fm, enclosing, pres, lhs) || changed;\n-        changed = find_pre_post_state_expr\n-            (dm, fm, enclosing, expr_poststate(lhs), rhs) || changed;\n-        ret extend_poststate_ann(a, expr_poststate(rhs)) || changed;\n-    }\n-    case (expr_recv(?lhs, ?rhs, ?a)) {\n-        extend_prestate_ann(a, pres);\n-\n-        alt (lhs.node) {\n-            case (expr_path(?p, ?a_lhs)) {\n-                alt (dm.get(a_lhs.id)) {\n-                    case (def_local(?d_id)) {\n-                        // receive to local var\n-                        changed = pure_exp(a_lhs, pres) || changed;\n-                        changed = find_pre_post_state_expr\n-                            (dm, fm, enclosing, pres, rhs) || changed;\n-                        changed = extend_poststate_ann(a, expr_poststate(rhs))\n-                            || changed;\n-                        ret gen_poststate(enclosing, a, d_id) || changed;\n-                    }\n-                    case (_) {}\n-                }\n-            }\n-            case (_) {}\n-        }\n-        // receive to something that must already have been init'd\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, lhs)\n-            || changed;\n-        changed = find_pre_post_state_expr\n-            (dm, fm, enclosing, expr_poststate(lhs), rhs) || changed;\n-        ret extend_poststate_ann(a, expr_poststate(rhs)) || changed;\n-    }\n-\n-    case (expr_ret(?maybe_ret_val, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        set_poststate_ann(a, false_postcond(num_local_vars));\n-        alt(maybe_ret_val) {\n-            case (none[@expr]) { /* do nothing */ }\n-            case (some[@expr](?ret_val)) {\n-                changed = find_pre_post_state_expr(dm, fm, enclosing,\n-                             pres, ret_val) || changed;\n-            }\n-        }\n-        ret changed;\n-    }\n-    case (expr_be(?e, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        set_poststate_ann(a, false_postcond(num_local_vars));\n-        changed = find_pre_post_state_expr\n-            (dm, fm, enclosing, pres, e) || changed;\n-        ret changed;\n-    }\n-    case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, antec)\n-            || changed;\n-        changed = find_pre_post_state_block(dm, fm, enclosing,\n-          expr_poststate(antec), conseq) || changed;\n-        alt (maybe_alt) {\n-            case (none[@expr]) {\n-                changed = extend_poststate_ann(a, expr_poststate(antec))\n-                    || changed;\n-            }\n-            case (some[@expr](?altern)) {\n-                changed = find_pre_post_state_expr(dm, fm, enclosing,\n-                   expr_poststate(antec), altern) || changed;\n-                auto poststate_res = intersect_postconds\n-                    ([block_poststate(conseq), expr_poststate(altern)]);\n-                changed = extend_poststate_ann(a, poststate_res) || changed;\n-            }\n-        }\n-        log(\"if:\");\n-        log_expr(*e);\n-        log(\"new prestate:\");\n-        log_bitv(enclosing, pres);\n-        log(\"new poststate:\");\n-        log_bitv(enclosing, expr_poststate(e));\n-\n-        ret changed;\n-    }\n-    case (expr_binary(?bop, ?l, ?r, ?a)) {\n-        /* FIXME: what if bop is lazy? */\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, l)\n-                    || changed;\n-        changed = find_pre_post_state_expr(dm, fm,\n-                    enclosing, expr_poststate(l), r) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(r)) || changed;\n-        ret changed;\n-    }\n-    case (expr_send(?l, ?r, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, l)\n-                    || changed;\n-        changed = find_pre_post_state_expr(dm, fm,\n-                    enclosing, expr_poststate(l), r) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(r)) || changed;\n-        ret changed;\n-    }\n-    case (expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n-        /* quite similar to binary -- should abstract this */\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, lhs)\n-                    || changed;\n-        changed = find_pre_post_state_expr(dm, fm,\n-                    enclosing, expr_poststate(lhs), rhs) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(rhs)) || changed;\n-        ret changed;\n-    }\n-    case (expr_while(?test, ?body, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        /* to handle general predicates, we need to pass in\n-            pres `intersect` (poststate(a)) \n-         like: auto test_pres = intersect_postconds(pres, expr_postcond(a));\n-         However, this doesn't work right now because we would be passing\n-         in an all-zero prestate initially\n-           FIXME\n-           maybe need a \"don't know\" state in addition to 0 or 1?\n-        */\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, test)\n-            || changed;\n-        changed = find_pre_post_state_block(dm, fm, \n-                   enclosing, expr_poststate(test), body) || changed; \n-        changed = extend_poststate_ann(a,\n-                    intersect_postconds([expr_poststate(test),\n-                                        block_poststate(body)])) || changed;\n-        ret changed;\n-    }\n-    case (expr_do_while(?body, ?test, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = find_pre_post_state_block(dm, fm, enclosing, pres, body)\n-            || changed;\n-        changed = find_pre_post_state_expr(dm, fm, enclosing,\n-                     block_poststate(body), test) || changed;\n-\n-        /* conservative approximination: if the body of the loop\n-           could break or cont, we revert to the prestate\n-           (TODO: could treat cont differently from break, since\n-           if there's a cont, the test will execute) */\n-        if (has_nonlocal_exits(body)) {\n-            changed = set_poststate_ann(a, pres) || changed;\n-        }\n-        else {\n-            changed = extend_poststate_ann(a, expr_poststate(test))\n-              || changed;\n-        }\n-\n-        ret changed;\n-    }\n-    case (expr_for(?d, ?index, ?body, ?a)) {\n-        ret find_pre_post_state_loop(dm, fm, enclosing, pres, d, index,\n-                                     body, a);\n-    }\n-    case (expr_for_each(?d, ?index, ?body, ?a)) {\n-        ret find_pre_post_state_loop(dm, fm, enclosing, pres, d, index,\n-                                     body, a);\n-    }\n-    case (expr_index(?e, ?sub, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed; \n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, e)\n-                  || changed;\n-        changed = find_pre_post_state_expr(dm, fm, enclosing,\n-                     expr_poststate(e), sub) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(sub));\n-        ret changed;\n-    }\n-    case (expr_alt(?e, ?alts, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed; \n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, e)\n-                  || changed;\n-        auto e_post = expr_poststate(e);\n-        auto a_post;\n-        if (vec::len[arm](alts) > 0u) {\n-            a_post = false_postcond(num_local_vars);\n-            for (arm an_alt in alts) {\n-                changed = find_pre_post_state_block(dm, fm, enclosing, e_post,\n-                                                    an_alt.block) || changed;\n-                changed = intersect(a_post, block_poststate(an_alt.block))\n-                    || changed; \n-            }\n-        }\n-        else {\n-            // No alts; poststate is the poststate of the test\n-            a_post = e_post;\n-        }\n-        changed = extend_poststate_ann(a, a_post);\n-        ret changed;\n-    }\n-    case (expr_field(?e,_,?a)) {\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, e);\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n-        ret changed;\n-    }\n-    case (expr_unary(_,?operand,?a)) {\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, operand)\n-          || changed;\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(operand))\n-          || changed;\n-        ret changed;\n-    }\n-    case (expr_cast(?operand, _, ?a)) {\n-          changed = find_pre_post_state_expr(dm, fm, enclosing, pres, operand)\n-          || changed;\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(operand))\n-          || changed;\n-        ret changed;\n-    }\n-    case (expr_fail(?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        /* if execution continues after fail, then everything is true! woo! */\n-        changed = set_poststate_ann(a, false_postcond(num_local_vars))\n-          || changed;\n-        ret changed;\n-    }\n-    case (expr_assert(?p, ?a)) {\n-        ret pure_exp(a, pres);\n-    }\n-    case (expr_check(?p, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, p)\n-                  || changed;\n-        /* FIXME: update the postcondition to reflect that p holds */\n-        changed = extend_poststate_ann(a, pres) || changed;\n-        ret changed;\n-    }\n-    case (expr_break(?a)) {\n-        ret pure_exp(a, pres);\n-    }\n-    case (expr_cont(?a)) {\n-        ret pure_exp(a, pres);\n-    }\n-    case (expr_port(?a)) {\n-        ret pure_exp(a, pres);\n-    }\n-    case (expr_self_method(_, ?a)) {\n-        ret pure_exp(a, pres);\n-    }\n-  }\n-}\n-\n-fn find_pre_post_state_stmt(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n-                            &prestate pres, @stmt s) -> bool {\n-  auto changed = false;\n-  auto stmt_ann_ = stmt_to_ann(*s);\n-  assert (!is_none[@ts_ann](stmt_ann_));\n-  auto stmt_ann = *(get[@ts_ann](stmt_ann_));\n-              log(\"*At beginning: stmt = \");\n-              log_stmt(*s);\n-              log(\"*prestate = \");\n-              log(bitv::to_str(stmt_ann.states.prestate));\n-              log(\"*poststate =\");\n-              log(bitv::to_str(stmt_ann.states.poststate));\n-              log(\"*changed =\");\n-              log(changed);\n-  \n-  alt (s.node) {\n-    case (stmt_decl(?adecl, ?a)) {\n-      alt (adecl.node) {\n-        case (ast::decl_local(?alocal)) {\n-          alt (alocal.init) {\n-            case (some[ast::initializer](?an_init)) {\n-                changed = extend_prestate(stmt_ann.states.prestate, pres)\n-                    || changed;\n-                changed = find_pre_post_state_expr\n-                    (dm, fm, enclosing, pres, an_init.expr) || changed;\n-                changed = extend_poststate(stmt_ann.states.poststate,\n-                                           expr_poststate(an_init.expr))\n-                    || changed;\n-                changed = gen_poststate(enclosing, a, alocal.id) || changed;\n-              log(\"Summary: stmt = \");\n-              log_stmt(*s);\n-              log(\"prestate = \");\n-              log(bitv::to_str(stmt_ann.states.prestate));\n-              log_bitv(enclosing, stmt_ann.states.prestate);\n-              log(\"poststate =\");\n-              log_bitv(enclosing, stmt_ann.states.poststate);\n-              log(\"changed =\");\n-              log(changed);\n-  \n-              ret changed;\n-            }\n-            case (none[ast::initializer]) {\n-              changed = extend_prestate(stmt_ann.states.prestate, pres)\n-                  || changed;\n-              changed = extend_poststate(stmt_ann.states.poststate, pres)\n-                  || changed;\n-              ret changed;\n-            }\n-          }\n-        }\n-        case (ast::decl_item(?an_item)) {\n-            changed = extend_prestate(stmt_ann.states.prestate, pres)\n-               || changed;\n-            changed = extend_poststate(stmt_ann.states.poststate, pres)\n-               || changed;\n-            ret find_pre_post_state_item(dm, fm, enclosing, an_item)\n-                || changed;\n-        }\n-      }\n-    }\n-    case (stmt_expr(?e, _)) {\n-      changed = find_pre_post_state_expr(dm, fm, enclosing, pres, e)\n-                || changed;\n-      changed = extend_prestate(stmt_ann.states.prestate, expr_prestate(e))\n-          || changed;\n-      changed = extend_poststate(stmt_ann.states.poststate,\n-                                 expr_poststate(e)) || changed;\n-      /*\n-                    log(\"Summary: stmt = \");\n-              log_stmt(*s);\n-              log(\"prestate = \");\n-              log(bitv::to_str(stmt_ann.states.prestate));\n-              log_bitv(enclosing, stmt_ann.states.prestate);\n-              log(\"poststate =\");\n-              log(bitv::to_str(stmt_ann.states.poststate));\n-              log_bitv(enclosing, stmt_ann.states.poststate);\n-              log(\"changed =\");\n-              log(changed);\n-      */\n-      ret changed;\n-    }\n-    case (_) { ret false; }\n-  }\n-}\n-\n-/* Updates the pre- and post-states of statements in the block,\n-   returns a boolean flag saying whether any pre- or poststates changed */\n-fn find_pre_post_state_block(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n-                             &prestate pres0, &block b)\n-  -> bool {\n-    \n-  auto changed = false;\n-  auto num_local_vars = num_locals(enclosing);\n-\n-  /* First, set the pre-states and post-states for every expression */\n-  auto pres = pres0;\n-  \n-  /* Iterate over each stmt. The new prestate is <pres>. The poststate\n-   consist of improving <pres> with whatever variables this stmt initializes.\n-  Then <pres> becomes the new poststate. */ \n-  for (@stmt s in b.node.stmts) {\n-    changed = find_pre_post_state_stmt(dm, fm, enclosing, pres, s) || changed;\n-    pres = stmt_poststate(*s, num_local_vars);\n-  }\n-\n-  auto post = pres;\n-\n-  alt (b.node.expr) {\n-    case (none[@expr]) {}\n-    case (some[@expr](?e)) {\n-      changed = find_pre_post_state_expr(dm,fm, enclosing, pres, e)\n-                || changed;\n-      post = expr_poststate(e);\n-    }\n-  }\n-\n-  /*\n-  log_err(\"block:\");\n-  log_block_err(b);\n-  log_err(\"has non-local exits?\");\n-  log_err(has_nonlocal_exits(b));\n-  */\n-\n-  /* conservative approximation: if a block contains a break\n-     or cont, we assume nothing about the poststate */\n-  if (has_nonlocal_exits(b)) {\n-      post = pres0;\n-  }\n-  \n-  set_prestate_ann(@b.node.a, pres0);\n-  set_poststate_ann(b.node.a, post);\n-\n-\n-  log(\"For block:\");\n-  log_block(b);\n-  log(\"poststate = \");\n-  log_states(block_states(b));\n-  log(\"pres0:\");\n-  log_bitv(enclosing, pres0);\n-  log(\"post:\");\n-  log_bitv(enclosing, post);\n-\n-\n-  ret changed;\n-}\n-\n-fn find_pre_post_state_fn(&def_map dm, &fn_info_map f_info, &fn_info fi,\n-                          &ast::_fn f) -> bool {\n-    /* FIXME: where do we set args as being initialized?\n-       What about for methods? */\n-    auto num_local_vars = num_locals(fi);\n-    ret find_pre_post_state_block(dm, f_info, fi,\n-                                  empty_prestate(num_local_vars), f.body);\n-}\n-\n-fn check_states_expr(fn_info enclosing, @expr e) -> () {\n-  let precond prec    = expr_precond(e);\n-  let prestate pres   = expr_prestate(e);\n-\n-  if (!implies(pres, prec)) {\n-      log_err(\"check_states_expr: Unsatisfied precondition constraint for \");\n-      log_expr_err(*e);\n-      log_err(\"Precondition: \");\n-      log_bitv_err(enclosing, prec);\n-      log_err(\"Prestate: \");\n-      log_bitv_err(enclosing, pres);\n-      fail;\n-  }\n-}\n-\n-fn check_states_stmt(fn_info enclosing, &stmt s) -> () {\n-  alt (stmt_to_ann(s)) {\n-    case (none[@ts_ann]) {\n-      ret;\n-    }\n-    case (some[@ts_ann](?a)) {\n-      let precond prec    = ann_precond(*a);\n-      let prestate pres   = ann_prestate(*a);\n-\n-      /*\n-      log(\"check_states_stmt:\");\n-      log_stmt(s);\n-      log(\"prec = \");\n-      log_bitv(enclosing, prec);\n-      log(\"pres = \");\n-      log_bitv(enclosing, pres);\n-      */\n-\n-      if (!implies(pres, prec)) {\n-        log_err(\"check_states_stmt: \"\n-              + \"Unsatisfied precondition constraint for \");\n-        log_stmt_err(s);\n-        log_err(\"Precondition: \");\n-        log_bitv_err(enclosing, prec);\n-        log_err(\"Prestate: \");\n-        log_bitv_err(enclosing, pres);\n-        fail;\n-      }\n-    }\n-  }\n-}\n-\n-fn check_states_against_conditions(fn_info enclosing, &ast::_fn f) -> () {\n-  fn do_one_(fn_info i, &@stmt s) -> () {\n-    check_states_stmt(i, *s);\n-  }\n-  auto do_one = bind do_one_(enclosing, _);\n- \n-  vec::map[@stmt, ()](do_one, f.body.node.stmts);\n-  fn do_inner_(fn_info i, &@expr e) -> () {\n-    check_states_expr(i, e);\n-  }\n-  auto do_inner = bind do_inner_(enclosing, _);\n-  option::map[@expr, ()](do_inner, f.body.node.expr);\n-  \n-}\n-\n-fn check_fn_states(&def_map dm, &fn_info_map f_info_map, &fn_info f_info,\n-                   &ast::_fn f) -> () {\n-    /* Compute the pre- and post-states for this function */\n-    // (Fixpoint iteration)\n-    while (find_pre_post_state_fn(dm, f_info_map, f_info, f)) {}\n-    \n-  /* Now compare each expr's pre-state to its precondition\n-     and post-state to its postcondition */\n-    check_states_against_conditions(f_info, f);\n-}\n-\n-fn check_item_fn_state(def_map dm, &fn_info_map f_info_map, &span sp,\n-                       &ident i, &ast::_fn f, &vec[ast::ty_param] ty_params,\n-                       &def_id id, &ann a) -> @item {\n-\n-  /* Look up the var-to-bit-num map for this function */\n-  assert (f_info_map.contains_key(id));\n-  auto f_info = f_info_map.get(id);\n-\n-  check_fn_states(dm, f_info_map, f_info, f);\n-\n-  /* Rebuild the same function */\n-  ret @respan(sp, ast::item_fn(i, f, ty_params, id, a));\n-}\n-\n-fn check_method_states(&def_map dm, &fn_info_map f_info_map, @method m) {\n-    assert (f_info_map.contains_key(m.node.id));\n-    auto f_info = f_info_map.get(m.node.id);\n-    check_fn_states(dm, f_info_map, f_info, m.node.meth);\n-}\n-\n-fn check_obj_state(def_map dm, &fn_info_map f_info_map,\n-                   &vec[obj_field] fields, &vec[@method] methods,\n-                   &option::t[@method] dtor) -> ast::_obj {\n-    fn one(def_map dm, fn_info_map fm, &@method m) -> () {\n-        ret check_method_states(dm, fm, m);\n-    }\n-    auto f = bind one(dm, f_info_map,_);\n-    vec::map[@method, ()](f, methods);\n-    option::map[@method, ()](f, dtor);\n-    ret rec(fields=fields, methods=methods, dtor=dtor);\n-}\n-\n-fn init_ann(&fn_info fi, &ann a) -> ann {\n-    ret rec(id=a.id, ty=a.ty, tps=a.tps,\n-            ts=some[@ts_ann](@empty_ann(num_locals(fi))));\n-}\n-\n-fn init_blank_ann(&() ignore, &ann a) -> ann {\n-    ret rec(id=a.id, ty=a.ty, tps=a.tps, ts=some[@ts_ann](@empty_ann(0u)));\n-}\n-\n-fn init_block(&fn_info fi, &span sp, &block_ b) -> block {\n-    log(\"init_block:\");\n-    log_block(respan(sp, b));\n-\n-    auto fld0 = fold::new_identity_fold[fn_info]();\n-\n-    fld0 = @rec(fold_ann = bind init_ann(_,_) with *fld0);\n-    ret fold::fold_block[fn_info](fi, fld0, respan(sp, b)); \n-}\n-\n-fn item_fn_anns(&fn_info_map fm, &span sp, ident i, &ast::_fn f,\n-                vec[ast::ty_param] ty_params, def_id id, ann a) -> @item {\n-\n-    assert (fm.contains_key(id));\n-    auto f_info = fm.get(id);\n-\n-    log(i + \" has \" + uistr(num_locals(f_info)) + \" local vars\");\n-\n-    auto fld0 = fold::new_identity_fold[fn_info]();\n-\n-    fld0 = @rec(fold_ann = bind init_ann(_,_) \n-                    with *fld0);\n-\n-    ret fold::fold_item[fn_info]\n-           (f_info, fld0, @respan(sp, item_fn(i, f, ty_params, id, a))); \n-}\n-\n-/* This is painstakingly written as an explicit recursion b/c the\n-   standard ast::fold doesn't traverse in the correct order:\n-   consider\n-   fn foo() {\n-      fn bar() {\n-        auto x = 5;\n-        log(x);\n-      }\n-   }\n-   With fold, first bar() would be processed and its subexps would\n-   correctly be annotated with length-1 bit vectors.\n-   But then, the process would be repeated with (fn bar()...) as\n-   a subexp of foo, which has 0 local variables -- so then\n-   the body of bar() would be incorrectly annotated with length-0 bit\n-   vectors. */\n-fn annotate_exprs(&fn_info_map fm, &vec[@expr] es) -> vec[@expr] {\n-    fn one(fn_info_map fm, &@expr e) -> @expr {\n-        ret annotate_expr(fm, e);\n-    }\n-    auto f = bind one(fm,_);\n-    ret vec::map[@expr, @expr](f, es);\n-}\n-fn annotate_elts(&fn_info_map fm, &vec[elt] es) -> vec[elt] {\n-    fn one(fn_info_map fm, &elt e) -> elt {\n-        ret rec(mut=e.mut,\n-                expr=annotate_expr(fm, e.expr));\n-    }\n-    auto f = bind one(fm,_);\n-    ret vec::map[elt, elt](f, es);\n-}\n-fn annotate_fields(&fn_info_map fm, &vec[field] fs) -> vec[field] {\n-    fn one(fn_info_map fm, &field f) -> field {\n-        ret rec(mut=f.mut,\n-                 ident=f.ident,\n-                 expr=annotate_expr(fm, f.expr));\n-    }\n-    auto f = bind one(fm,_);\n-    ret vec::map[field, field](f, fs);\n-}\n-fn annotate_option_exp(&fn_info_map fm, &option::t[@expr] o)\n-  -> option::t[@expr] {\n-    fn one(fn_info_map fm, &@expr e) -> @expr {\n-        ret annotate_expr(fm, e);\n-    }\n-    auto f = bind one(fm,_);\n-    ret option::map[@expr, @expr](f, o);\n-}\n-fn annotate_option_exprs(&fn_info_map fm, &vec[option::t[@expr]] es)\n-  -> vec[option::t[@expr]] {\n-    fn one(fn_info_map fm, &option::t[@expr] o) -> option::t[@expr] {\n-        ret annotate_option_exp(fm, o);\n-    }\n-    auto f = bind one(fm,_);\n-    ret vec::map[option::t[@expr], option::t[@expr]](f, es);\n-}\n-fn annotate_decl(&fn_info_map fm, &@decl d) -> @decl {\n-    auto d1 = d.node;\n-    alt (d.node) {\n-        case (decl_local(?l)) {\n-            alt(l.init) {\n-                case (some[initializer](?init)) {\n-                    let option::t[initializer] an_i =\n-                        some[initializer]\n-                          (rec(expr=annotate_expr(fm, init.expr)\n-                                 with init));\n-                    let @local new_l = @rec(init=an_i with *l);\n-                    d1 = decl_local(new_l);\n-                }\n-                case (_) { /* do nothing */ }\n-            }\n-        }\n-        case (decl_item(?item)) {\n-            d1 = decl_item(annotate_item(fm, item));\n-        }\n-    }\n-    ret @respan(d.span, d1);\n-}\n-fn annotate_alts(&fn_info_map fm, &vec[arm] alts) -> vec[arm] {\n-    fn one(fn_info_map fm, &arm a) -> arm {\n-        ret rec(pat=a.pat,\n-                 block=annotate_block(fm, a.block));\n-    }\n-    auto f = bind one(fm,_);\n-    ret vec::map[arm, arm](f, alts);\n-\n-}\n-fn annotate_expr(&fn_info_map fm, &@expr e) -> @expr {\n-    auto e1 = e.node;\n-    alt (e.node) {\n-        case (expr_vec(?es, ?m, ?a)) {\n-            e1 = expr_vec(annotate_exprs(fm, es), m, a);\n-        }\n-        case (expr_tup(?es, ?a)) {\n-            e1 = expr_tup(annotate_elts(fm, es), a);\n-        }\n-        case (expr_rec(?fs, ?maybe_e, ?a)) {\n-            e1 = expr_rec(annotate_fields(fm, fs),\n-                          annotate_option_exp(fm, maybe_e), a);\n-        }\n-        case (expr_call(?e, ?es, ?a)) {\n-            e1 = expr_call(annotate_expr(fm, e),\n-                          annotate_exprs(fm, es), a);\n-        }\n-        case (expr_self_method(_,_)) {\n-            // no change\n-        }\n-        case (expr_bind(?e, ?maybe_es, ?a)) {\n-            e1 = expr_bind(annotate_expr(fm, e),\n-                           annotate_option_exprs(fm, maybe_es),\n-                           a);\n-        }\n-        case (expr_spawn(?s, ?maybe_s, ?e, ?es, ?a)) {\n-            e1 = expr_spawn(s, maybe_s, annotate_expr(fm, e),\n-                            annotate_exprs(fm, es), a);\n-        }\n-        case (expr_binary(?bop, ?w, ?x, ?a)) {\n-            e1 = expr_binary(bop, annotate_expr(fm, w),\n-                             annotate_expr(fm, x), a);\n-        }\n-        case (expr_unary(?uop, ?w, ?a)) {\n-            e1 = expr_unary(uop, annotate_expr(fm, w), a);\n-        }\n-        case (expr_lit(_,_)) {\n-            /* no change */\n-        }\n-        case (expr_cast(?e,?t,?a)) {\n-            e1 = expr_cast(annotate_expr(fm, e), t, a);\n-        }\n-        case (expr_if(?e, ?b, ?maybe_e, ?a)) {\n-            e1 = expr_if(annotate_expr(fm, e),\n-                         annotate_block(fm, b),\n-                         annotate_option_exp(fm, maybe_e), a);\n-        }\n-        case (expr_while(?e, ?b, ?a)) {\n-            e1 = expr_while(annotate_expr(fm, e),\n-                            annotate_block(fm, b), a);\n-        }\n-        case (expr_for(?d, ?e, ?b, ?a)) {\n-            e1 = expr_for(annotate_decl(fm, d),\n-                          annotate_expr(fm, e),\n-                          annotate_block(fm, b), a);\n-        }\n-        case (expr_for_each(?d, ?e, ?b, ?a)) {\n-            e1 = expr_for_each(annotate_decl(fm, d),\n-                          annotate_expr(fm, e),\n-                          annotate_block(fm, b), a);\n-        }\n-        case (expr_do_while(?b, ?e, ?a)) {\n-            e1 = expr_do_while(annotate_block(fm, b),\n-                               annotate_expr(fm, e), a);\n-        }\n-        case (expr_alt(?e, ?alts, ?a)) {\n-            e1 = expr_alt(annotate_expr(fm, e),\n-                          annotate_alts(fm, alts), a);\n-        }\n-        case (expr_block(?b, ?a)) {\n-            e1 = expr_block(annotate_block(fm, b), a);\n-        }\n-        case (expr_assign(?l, ?r, ?a)) {\n-            e1 = expr_assign(annotate_expr(fm, l), annotate_expr(fm, r), a);\n-        }\n-        case (expr_assign_op(?bop, ?l, ?r, ?a)) {\n-            e1 = expr_assign_op(bop,\n-               annotate_expr(fm, l), annotate_expr(fm, r), a);\n-        }\n-        case (expr_send(?l, ?r, ?a)) {\n-            e1 = expr_send(annotate_expr(fm, l),\n-                           annotate_expr(fm, r), a);\n-        }\n-        case (expr_recv(?l, ?r, ?a)) {\n-           e1 = expr_recv(annotate_expr(fm, l),\n-                           annotate_expr(fm, r), a);\n-        }\n-        case (expr_field(?e, ?i, ?a)) {\n-            e1 = expr_field(annotate_expr(fm, e),\n-                            i, a);\n-        }\n-        case (expr_index(?e, ?sub, ?a)) {\n-            e1 = expr_index(annotate_expr(fm, e),\n-                            annotate_expr(fm, sub), a);\n-        }\n-        case (expr_path(_,_)) {\n-            /* no change */\n-        }\n-        case (expr_ext(?p, ?es, ?s_opt, ?e, ?a)) {\n-            e1 = expr_ext(p, annotate_exprs(fm, es),\n-                          s_opt,\n-                          annotate_expr(fm, e), a);\n-        }\n-        /* no change, next 3 cases */\n-        case (expr_fail(_)) { }\n-        case (expr_break(_)) { }\n-        case (expr_cont(_)) { }\n-        case (expr_ret(?maybe_e, ?a)) {\n-            e1 = expr_ret(annotate_option_exp(fm, maybe_e), a);\n-        }\n-        case (expr_put(?maybe_e, ?a)) {\n-            e1 = expr_put(annotate_option_exp(fm, maybe_e), a);\n-        }\n-        case (expr_be(?e, ?a)) {\n-            e1 = expr_be(annotate_expr(fm, e), a);\n-        }\n-        case (expr_log(?n, ?e, ?a)) {\n-            e1 = expr_log(n, annotate_expr(fm, e), a);\n-        }\n-        case (expr_assert(?e, ?a)) {\n-            e1 = expr_assert(annotate_expr(fm, e), a);\n-        }\n-        case (expr_check(?e, ?a)) {\n-            e1 = expr_check(annotate_expr(fm, e), a);\n-        }\n-        case (expr_port(_)) { /* no change */ }\n-        case (expr_chan(?e, ?a)) {\n-            e1 = expr_chan(annotate_expr(fm, e), a);\n-        }\n-    }\n-    ret @respan(e.span, e1);\n-}\n-\n-fn annotate_stmt(&fn_info_map fm, &@stmt s) -> @stmt {\n-    alt (s.node) {\n-        case (stmt_decl(?d, ?a)) {\n-            ret @respan(s.span, stmt_decl(annotate_decl(fm, d), a));\n-        }\n-        case (stmt_expr(?e, ?a)) {\n-            ret @respan(s.span, stmt_expr(annotate_expr(fm, e), a));\n-        }\n-    }\n-}\n-fn annotate_block(&fn_info_map fm, &block b) -> block {\n-    let vec[@stmt] new_stmts = [];\n-\n-    for (@stmt s in b.node.stmts) {\n-        auto new_s = annotate_stmt(fm, s);\n-        vec::push[@stmt](new_stmts, new_s);\n-    }\n-    fn ann_e(fn_info_map fm, &@expr e) -> @expr {\n-        ret annotate_expr(fm, e);\n-    }\n-    auto f = bind ann_e(fm,_);\n-\n-    auto new_e = option::map[@expr, @expr](f, b.node.expr);\n-\n-    ret respan(b.span,\n-          rec(stmts=new_stmts, expr=new_e with b.node));\n-}\n-fn annotate_fn(&fn_info_map fm, &ast::_fn f) -> ast::_fn {\n-    // subexps have *already* been annotated based on\n-    // f's number-of-locals\n-    ret rec(body=annotate_block(fm, f.body) with f);\n-}\n-fn annotate_mod(&fn_info_map fm, &ast::_mod m) -> ast::_mod {\n-    let vec[@item] new_items = [];\n-\n-    for (@item i in m.items) {\n-        auto new_i = annotate_item(fm, i);\n-        vec::push[@item](new_items, new_i);\n-    }\n-    ret rec(items=new_items with m);\n-}\n-fn annotate_method(&fn_info_map fm, &@method m) -> @method {\n-    auto f_info = get_fn_info(fm, m.node.id);\n-    auto fld0 = fold::new_identity_fold[fn_info]();\n-    fld0 = @rec(fold_ann = bind init_ann(_,_) \n-                with *fld0);\n-    auto outer = fold::fold_method[fn_info](f_info, fld0, m);\n-    auto new_fn = annotate_fn(fm, outer.node.meth);\n-    ret @respan(m.span,\n-                rec(meth=new_fn with m.node));\n-}\n-\n-fn annotate_obj(&fn_info_map fm, &ast::_obj o) -> ast::_obj {\n-    fn one(fn_info_map fm, &@method m) -> @method {\n-        ret annotate_method(fm, m);\n-    }\n-    auto f = bind one(fm,_);\n-    auto new_methods = vec::map[@method, @method](f, o.methods);\n-    auto new_dtor    = option::map[@method, @method](f, o.dtor);\n-    ret rec(methods=new_methods, dtor=new_dtor with o);\n-}\n-\n- \n-// Only annotates the components of the item recursively.\n-fn annotate_item_inner(&fn_info_map fm, &@ast::item item) -> @ast::item {\n-    alt (item.node) {\n-        /* FIXME can't skip this case -- exprs contain blocks contain stmts,\n-         which contain decls */\n-        case (ast::item_const(_,_,_,_,_)) {\n-            // this has already been annotated by annotate_item\n-            ret item;\n-        }\n-        case (ast::item_fn(?ident, ?ff, ?tps, ?id, ?ann)) {\n-            ret @respan(item.span,\n-                        ast::item_fn(ident, annotate_fn(fm, ff),\n-                                     tps, id, ann));\n-        }\n-        case (ast::item_mod(?ident, ?mm, ?id)) {\n-            ret @respan(item.span,\n-                       ast::item_mod(ident, annotate_mod(fm, mm), id));\n-        }\n-        case (ast::item_native_mod(?ident, ?mm, ?id)) {\n-            ret item;\n-        }\n-        case (ast::item_ty(_,_,_,_,_)) {\n-            ret item;\n-        }\n-        case (ast::item_tag(_,_,_,_,_)) {\n-            ret item;\n-        }\n-        case (ast::item_obj(?ident, ?ob, ?tps, ?odid, ?ann)) {\n-            ret @respan(item.span,\n-              ast::item_obj(ident, annotate_obj(fm, ob), tps, odid, ann));\n-        }\n-    } \n-}\n-\n-fn annotate_item(&fn_info_map fm, &@ast::item item) -> @ast::item {\n-    // Using a fold, recursively set all anns in this item\n-    // to be blank.\n-    // *Then*, call annotate_item recursively to do the right\n-    // thing for any nested items inside this one.\n-    \n-    alt (item.node) {\n-        case (ast::item_const(_,_,_,_,_)) {\n-            auto fld0 = fold::new_identity_fold[()]();\n-            fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n-                        with *fld0);\n-            ret fold::fold_item[()]((), fld0, item);\n-        }\n-        case (ast::item_fn(?i,?ff,?tps,?id,?ann)) {\n-            auto f_info = get_fn_info(fm, id);\n-            auto fld0 = fold::new_identity_fold[fn_info]();\n-            fld0 = @rec(fold_ann = bind init_ann(_,_) \n-                        with *fld0);\n-            auto outer = fold::fold_item[fn_info](f_info, fld0, item);\n-            // now recurse into any nested items\n-            ret annotate_item_inner(fm, outer);\n-         }\n-        case (ast::item_mod(?i, ?mm, ?id)) {\n-            auto fld0 = fold::new_identity_fold[()]();\n-            fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n-                        with *fld0);\n-            auto outer = fold::fold_item[()]((), fld0, item);\n-            ret annotate_item_inner(fm, outer);\n-        }\n-        case (ast::item_native_mod(?i, ?nm, ?id)) {\n-            ret item;\n-        }\n-        case (ast::item_ty(_,_,_,_,_)) {\n-            ret item;\n-        }\n-        case (ast::item_tag(_,_,_,_,_)) {\n-            ret item;\n-        }\n-        case (ast::item_obj(?i,?ob,?tps,?odid,?ann)) {\n-            auto fld0 = fold::new_identity_fold[()]();\n-            fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n-                        with *fld0);\n-            auto outer = fold::fold_item[()]((), fld0, item);\n-            ret annotate_item_inner(fm, outer);\n-        }\n-    }\n-}\n-\n-fn annotate_module(&fn_info_map fm, &ast::_mod module) -> ast::_mod {\n-    let vec[@item] new_items = [];\n-\n-    for (@item i in module.items) {\n-        auto new_item = annotate_item(fm, i);\n-        vec::push[@item](new_items, new_item);\n-    }\n-\n-    ret rec(items = new_items with module);\n-}\n-\n-fn annotate_crate(&fn_info_map fm, &@ast::crate crate) -> @ast::crate {\n-    ret @respan(crate.span,\n-               rec(module = annotate_module(fm, crate.node.module)\n-                   with crate.node));\n-}\n-\n-fn check_crate(@ast::crate crate, def_map dm) -> @ast::crate {\n-  /* Build the global map from function id to var-to-bit-num-map */\n-  auto fm = mk_f_to_fn_info(crate);\n-\n-  /* Add a blank ts_ann to every statement (and expression) */\n-  auto with_anns = annotate_crate(fm, crate);\n-\n-  /* Compute the pre and postcondition for every subexpression */\n-  auto fld = fold::new_identity_fold[fn_info_map]();\n-  fld = @rec(fold_item_fn = bind check_item_fn(dm,_,_,_,_,_,_,_) with *fld);\n-  auto with_pre_postconditions = fold::fold_crate[fn_info_map]\n-    (fm, fld, with_anns);\n-\n-  auto fld1 = fold::new_identity_fold[fn_info_map]();\n-\n-  fld1 = @rec(fold_item_fn = bind check_item_fn_state(dm,_,_,_,_,_,_,_),\n-              fold_obj     = bind check_obj_state(dm,_,_,_,_)\n-              with *fld1);\n-\n-  ret fold::fold_crate[fn_info_map](fm, fld1,\n-                                    with_pre_postconditions);\n-}\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//"}]}