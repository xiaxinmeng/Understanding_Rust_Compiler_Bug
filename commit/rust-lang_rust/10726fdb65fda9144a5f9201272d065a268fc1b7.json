{"sha": "10726fdb65fda9144a5f9201272d065a268fc1b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNzI2ZmRiNjVmZGE5MTQ0YTVmOTIwMTI3MmQwNjVhMjY4ZmMxYjc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-10T07:46:43Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-10T07:48:15Z"}, "message": "type-safer source-map for bindings", "tree": {"sha": "f5640991cbf0db2bfdad29b911435827cadfb4a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5640991cbf0db2bfdad29b911435827cadfb4a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10726fdb65fda9144a5f9201272d065a268fc1b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10726fdb65fda9144a5f9201272d065a268fc1b7", "html_url": "https://github.com/rust-lang/rust/commit/10726fdb65fda9144a5f9201272d065a268fc1b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10726fdb65fda9144a5f9201272d065a268fc1b7/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cd184d6539478c7e54c92835902921976dce5d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cd184d6539478c7e54c92835902921976dce5d1", "html_url": "https://github.com/rust-lang/rust/commit/1cd184d6539478c7e54c92835902921976dce5d1"}], "stats": {"total": 75, "additions": 45, "deletions": 30}, "files": [{"sha": "4073cc82e17fd250fc11c83799a7c14436a525e9", "filename": "crates/ra_hir/src/either.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_hir%2Fsrc%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_hir%2Fsrc%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Feither.rs?ref=10726fdb65fda9144a5f9201272d065a268fc1b7", "patch": "@@ -5,6 +5,16 @@ pub enum Either<A, B> {\n }\n \n impl<A, B> Either<A, B> {\n+    pub fn either<R, F1, F2>(self, f1: F1, f2: F2) -> R\n+    where\n+        F1: FnOnce(A) -> R,\n+        F2: FnOnce(B) -> R,\n+    {\n+        match self {\n+            Either::A(a) => f1(a),\n+            Either::B(b) => f2(b),\n+        }\n+    }\n     pub fn map<U, V, F1, F2>(self, f1: F1, f2: F2) -> Either<U, V>\n     where\n         F1: FnOnce(A) -> U,"}, {"sha": "a2840c15d6f2a6ea11c44cd420d89269cbef8972", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=10726fdb65fda9144a5f9201272d065a268fc1b7", "patch": "@@ -10,7 +10,7 @@ use ra_syntax::{\n };\n \n use crate::{\n-    Path, Name, HirDatabase, Resolver,DefWithBody,\n+    Path, Name, HirDatabase, Resolver,DefWithBody, Either,\n     name::AsName,\n     type_ref::{Mutability, TypeRef},\n };\n@@ -51,11 +51,13 @@ pub struct Body {\n pub struct BodySourceMap {\n     expr_map: FxHashMap<SyntaxNodePtr, ExprId>,\n     expr_map_back: ArenaMap<ExprId, SyntaxNodePtr>,\n-    pat_map: FxHashMap<SyntaxNodePtr, PatId>,\n-    pat_map_back: ArenaMap<PatId, SyntaxNodePtr>,\n+    pat_map: FxHashMap<PatPrr, PatId>,\n+    pat_map_back: ArenaMap<PatId, PatPrr>,\n     field_map: FxHashMap<(ExprId, usize), AstPtr<ast::NamedField>>,\n }\n \n+type PatPrr = Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>;\n+\n impl Body {\n     pub fn params(&self) -> &[PatId] {\n         &self.params\n@@ -127,16 +129,16 @@ impl BodySourceMap {\n         self.expr_map.get(&SyntaxNodePtr::new(node.syntax())).cloned()\n     }\n \n-    pub fn pat_syntax(&self, pat: PatId) -> Option<SyntaxNodePtr> {\n+    pub fn pat_syntax(&self, pat: PatId) -> Option<PatPrr> {\n         self.pat_map_back.get(pat).cloned()\n     }\n \n-    pub fn syntax_pat(&self, ptr: SyntaxNodePtr) -> Option<PatId> {\n+    pub fn syntax_pat(&self, ptr: PatPrr) -> Option<PatId> {\n         self.pat_map.get(&ptr).cloned()\n     }\n \n     pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n-        self.pat_map.get(&SyntaxNodePtr::new(node.syntax())).cloned()\n+        self.pat_map.get(&Either::A(AstPtr::new(node))).cloned()\n     }\n \n     pub fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::NamedField> {\n@@ -504,10 +506,10 @@ impl ExprCollector {\n         id\n     }\n \n-    fn alloc_pat(&mut self, pat: Pat, syntax_ptr: SyntaxNodePtr) -> PatId {\n+    fn alloc_pat(&mut self, pat: Pat, ptr: PatPrr) -> PatId {\n         let id = self.pats.alloc(pat);\n-        self.source_map.pat_map.insert(syntax_ptr, id);\n-        self.source_map.pat_map_back.insert(id, syntax_ptr);\n+        self.source_map.pat_map.insert(ptr, id);\n+        self.source_map.pat_map_back.insert(id, ptr);\n         id\n     }\n \n@@ -886,8 +888,8 @@ impl ExprCollector {\n             ast::PatKind::LiteralPat(_) => Pat::Missing,\n             ast::PatKind::SlicePat(_) | ast::PatKind::RangePat(_) => Pat::Missing,\n         };\n-        let syntax_ptr = SyntaxNodePtr::new(pat.syntax());\n-        self.alloc_pat(pattern, syntax_ptr)\n+        let ptr = AstPtr::new(pat);\n+        self.alloc_pat(pattern, Either::A(ptr))\n     }\n \n     fn collect_pat_opt(&mut self, pat: Option<&ast::Pat>) -> PatId {\n@@ -911,14 +913,14 @@ impl ExprCollector {\n     fn collect_fn_body(&mut self, node: &ast::FnDef) {\n         if let Some(param_list) = node.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n-                let self_param = SyntaxNodePtr::new(self_param.syntax());\n+                let ptr = AstPtr::new(self_param);\n                 let param_pat = self.alloc_pat(\n                     Pat::Bind {\n                         name: Name::self_param(),\n                         mode: BindingAnnotation::Unannotated,\n                         subpat: None,\n                     },\n-                    self_param,\n+                    Either::B(ptr),\n                 );\n                 self.params.push(param_pat);\n             }"}, {"sha": "725b6c00eed72daa86c7dd79850c999ef3e384fb", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=10726fdb65fda9144a5f9201272d065a268fc1b7", "patch": "@@ -3,14 +3,14 @@ use std::sync::Arc;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{\n-    AstNode, SyntaxNode, TextUnit, TextRange, SyntaxNodePtr,\n+    AstNode, SyntaxNode, TextUnit, TextRange, SyntaxNodePtr, AstPtr,\n     algo::generate,\n     ast,\n };\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n use crate::{\n-    Name, AsName,DefWithBody,\n+    Name, AsName,DefWithBody, Either,\n     expr::{PatId, ExprId, Pat, Expr, Body, Statement, BodySourceMap},\n     HirDatabase,\n };\n@@ -116,15 +116,15 @@ pub struct ScopesWithSourceMap {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ScopeEntryWithSyntax {\n     name: Name,\n-    ptr: SyntaxNodePtr,\n+    ptr: Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>,\n }\n \n impl ScopeEntryWithSyntax {\n     pub fn name(&self) -> &Name {\n         &self.name\n     }\n \n-    pub fn ptr(&self) -> SyntaxNodePtr {\n+    pub fn ptr(&self) -> Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>> {\n         self.ptr\n     }\n }\n@@ -192,14 +192,14 @@ impl ScopesWithSourceMap {\n \n     pub fn find_all_refs(&self, pat: &ast::BindPat) -> Vec<ReferenceDescriptor> {\n         let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n-        let name_ptr = SyntaxNodePtr::new(pat.syntax());\n+        let ptr = Either::A(AstPtr::new(pat.into()));\n         fn_def\n             .syntax()\n             .descendants()\n             .filter_map(ast::NameRef::cast)\n             .filter(|name_ref| match self.resolve_local_name(*name_ref) {\n                 None => false,\n-                Some(entry) => entry.ptr() == name_ptr,\n+                Some(entry) => entry.ptr() == ptr,\n             })\n             .map(|name_ref| ReferenceDescriptor {\n                 name: name_ref.syntax().text().to_string(),\n@@ -429,7 +429,8 @@ mod tests {\n         let scopes =\n             ScopesWithSourceMap { scopes: Arc::new(scopes), source_map: Arc::new(source_map) };\n         let local_name_entry = scopes.resolve_local_name(name_ref).unwrap();\n-        let local_name = local_name_entry.ptr();\n+        let local_name =\n+            local_name_entry.ptr().either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n         assert_eq!(local_name.range(), expected_name.syntax().range());\n     }\n "}, {"sha": "ecc63f37629e1dcc7307405060601bb9dd02a735", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=10726fdb65fda9144a5f9201272d065a268fc1b7", "patch": "@@ -2324,7 +2324,7 @@ fn infer(content: &str) -> String {\n \n         for (pat, ty) in inference_result.type_of_pat.iter() {\n             let syntax_ptr = match body_source_map.pat_syntax(pat) {\n-                Some(sp) => sp,\n+                Some(sp) => sp.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr()),\n                 None => continue,\n             };\n             types.push((syntax_ptr, ty));"}, {"sha": "7e47fa6bdf73561eba2bcd7b9a1a34b56ea772af", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=10726fdb65fda9144a5f9201272d065a268fc1b7", "patch": "@@ -1,4 +1,4 @@\n-use hir::Resolution;\n+use hir::{Resolution, Either};\n use ra_syntax::AstNode;\n use test_utils::tested_by;\n \n@@ -19,10 +19,8 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n             for (name, res) in module_scope.entries() {\n                 if Some(module) == ctx.module {\n                     if let Some(import) = res.import {\n-                        if let hir::ImportSource::UseTree(tree) =\n-                            module.import_source(ctx.db, import)\n-                        {\n-                            if tree.syntax().range().contains_inclusive(ctx.offset) {\n+                        if let Either::A(use_tree) = module.import_source(ctx.db, import) {\n+                            if use_tree.syntax().range().contains_inclusive(ctx.offset) {\n                                 // for `use self::foo<|>`, don't suggest `foo` as a completion\n                                 tested_by!(dont_complete_current_use);\n                                 continue;"}, {"sha": "60c1f50856ae8989a11630ce0ae7d2ac857150d6", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=10726fdb65fda9144a5f9201272d065a268fc1b7", "patch": "@@ -113,6 +113,7 @@ pub(crate) fn reference_definition(\n                 let ptr = source_map.pat_syntax(pat).expect(\"pattern not found in syntax mapping\");\n                 let name =\n                     path.as_ident().cloned().expect(\"local binding from a multi-segment path\");\n+                let ptr = ptr.either(|it| it.into(), |it| it.into());\n                 let nav = NavigationTarget::from_scope_entry(file_id, name, ptr);\n                 return Exact(nav);\n             }"}, {"sha": "3e30e047c69847f70d36a06c5ccfb1b393c29a69", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10726fdb65fda9144a5f9201272d065a268fc1b7/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=10726fdb65fda9144a5f9201272d065a268fc1b7", "patch": "@@ -1,5 +1,5 @@\n use relative_path::{RelativePath, RelativePathBuf};\n-use hir::{ModuleSource, source_binder};\n+use hir::{ModuleSource, source_binder, Either};\n use ra_db::{SourceDatabase};\n use ra_syntax::{\n     AstNode, SyntaxNode, SourceFile,\n@@ -89,9 +89,12 @@ pub(crate) fn find_all_refs(\n             source_binder::function_from_child_node(db, position.file_id, name_ref.syntax())?;\n         let scope = descr.scopes(db);\n         let resolved = scope.resolve_local_name(name_ref)?;\n-        let resolved = resolved.ptr().to_node(source_file);\n-        let binding = find_node_at_offset::<ast::BindPat>(syntax, resolved.range().end())?;\n-        Some((binding, descr))\n+        if let Either::A(ptr) = resolved.ptr() {\n+            if let ast::PatKind::BindPat(binding) = ptr.to_node(source_file).kind() {\n+                return Some((binding, descr));\n+            }\n+        }\n+        None\n     }\n }\n "}]}