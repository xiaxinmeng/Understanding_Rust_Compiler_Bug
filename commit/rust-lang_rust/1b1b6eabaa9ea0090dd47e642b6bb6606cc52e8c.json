{"sha": "1b1b6eabaa9ea0090dd47e642b6bb6606cc52e8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMWI2ZWFiYWE5ZWEwMDkwZGQ0N2U2NDJiNmJiNjYwNmNjNTJlOGM=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-09-23T14:28:45Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-09-23T14:28:45Z"}, "message": "Remove the \"lift constant to reference\" logic", "tree": {"sha": "3a317758030c6dc059d37d9c9f38e011bfdec3cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a317758030c6dc059d37d9c9f38e011bfdec3cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b1b6eabaa9ea0090dd47e642b6bb6606cc52e8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b1b6eabaa9ea0090dd47e642b6bb6606cc52e8c", "html_url": "https://github.com/rust-lang/rust/commit/1b1b6eabaa9ea0090dd47e642b6bb6606cc52e8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b1b6eabaa9ea0090dd47e642b6bb6606cc52e8c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f12583a3302df829d2cf55f25303a74531067a97", "url": "https://api.github.com/repos/rust-lang/rust/commits/f12583a3302df829d2cf55f25303a74531067a97", "html_url": "https://github.com/rust-lang/rust/commit/f12583a3302df829d2cf55f25303a74531067a97"}], "stats": {"total": 74, "additions": 28, "deletions": 46}, "files": [{"sha": "d81c3b68f4853d27f3c1ce63d821a9b3f64013d4", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b6eabaa9ea0090dd47e642b6bb6606cc52e8c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b6eabaa9ea0090dd47e642b6bb6606cc52e8c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=1b1b6eabaa9ea0090dd47e642b6bb6606cc52e8c", "patch": "@@ -409,40 +409,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let deref_ty = match *ty.kind() {\n             ty::Ref(_, deref_ty, _) => deref_ty,\n-            _ => {\n-                trace!(\"non_scalar_compare called on non-reference type: {}\", ty);\n-                // Backcompat hack: due to non-structural matches not being a hard error, we can\n-                // reach this for types that have manual `Eq` or `PartialEq` impls.\n-                assert!(!ty.is_structural_eq_shallow(self.hir.tcx()));\n-                let ref_ty = self.hir.tcx().mk_imm_ref(self.hir.tcx().lifetimes.re_erased, ty);\n-                // let y = &place;\n-                let y = self.temp(ref_ty, source_info.span);\n-                self.cfg.push_assign(\n-                    block,\n-                    source_info,\n-                    y,\n-                    Rvalue::Ref(self.hir.tcx().lifetimes.re_erased, BorrowKind::Shared, place),\n-                );\n-                val = Operand::Move(y);\n-                // let temp = expect;\n-                let temp = self.temp(ty, source_info.span);\n-                self.cfg.push_assign(\n-                    block,\n-                    source_info,\n-                    temp,\n-                    Rvalue::Use(expect),\n-                );\n-                // reftemp = &temp;\n-                let reftemp = self.temp(ref_ty, source_info.span);\n-                self.cfg.push_assign(\n-                    block,\n-                    source_info,\n-                    reftemp,\n-                    Rvalue::Ref(self.hir.tcx().lifetimes.re_erased, BorrowKind::Shared, temp),\n-                );\n-                expect = Operand::Move(reftemp);\n-                ty\n-            },\n+            _ => bug!(\"non_scalar_compare called on non-reference type: {}\", ty),\n         };\n \n         let eq_def_id = self.hir.tcx().require_lang_item(LangItem::PartialEq, None);"}, {"sha": "4a50bbca066749dd3761e944673e648a7ea625bb", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b6eabaa9ea0090dd47e642b6bb6606cc52e8c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b6eabaa9ea0090dd47e642b6bb6606cc52e8c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=1b1b6eabaa9ea0090dd47e642b6bb6606cc52e8c", "patch": "@@ -58,6 +58,9 @@ struct ConstToPat<'a, 'tcx> {\n     include_lint_checks: bool,\n }\n \n+#[derive(Debug)]\n+struct FallbackToConstRef;\n+\n impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     fn new(\n         pat_ctxt: &PatCtxt<'_, 'tcx>,\n@@ -103,7 +106,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         // once indirect_structural_match is a full fledged error, this\n         // level of indirection can be eliminated\n \n-        let inlined_const_as_pat = self.recur(cv, mir_structural_match_violation);\n+        let inlined_const_as_pat = self.recur(cv, mir_structural_match_violation).unwrap();\n \n         if self.include_lint_checks && !self.saw_const_match_error.get() {\n             // If we were able to successfully convert the const to some pat,\n@@ -216,18 +219,22 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     }\n \n     // Recursive helper for `to_pat`; invoke that (instead of calling this directly).\n-    fn recur(&self, cv: &'tcx ty::Const<'tcx>, mir_structural_match_violation: bool) -> Pat<'tcx> {\n+    fn recur(\n+        &self,\n+        cv: &'tcx ty::Const<'tcx>,\n+        mir_structural_match_violation: bool,\n+    ) -> Result<Pat<'tcx>, FallbackToConstRef> {\n         let id = self.id;\n         let span = self.span;\n         let tcx = self.tcx();\n         let param_env = self.param_env;\n \n-        let field_pats = |vals: &[&'tcx ty::Const<'tcx>]| {\n+        let field_pats = |vals: &[&'tcx ty::Const<'tcx>]| -> Result<_, _> {\n             vals.iter()\n                 .enumerate()\n                 .map(|(idx, val)| {\n                     let field = Field::new(idx);\n-                    FieldPat { field, pattern: self.recur(val, false) }\n+                    Ok(FieldPat { field, pattern: self.recur(val, false)? })\n                 })\n                 .collect()\n         };\n@@ -287,7 +294,10 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                         |lint| lint.build(&msg).emit(),\n                     );\n                 }\n-                PatKind::Constant { value: cv }\n+                // Since we are behind a reference, we can just bubble the error up so we get a\n+                // constant at reference type, making it easy to let the fallback call\n+                // `PartialEq::eq` on it.\n+                return Err(FallbackToConstRef);\n             }\n             ty::Adt(adt_def, _) if !self.type_marked_structural(cv.ty) => {\n                 debug!(\"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\", adt_def, cv.ty);\n@@ -309,20 +319,20 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     variant_index: destructured\n                         .variant\n                         .expect(\"destructed const of adt without variant id\"),\n-                    subpatterns: field_pats(destructured.fields),\n+                    subpatterns: field_pats(destructured.fields)?,\n                 }\n             }\n             ty::Tuple(_) | ty::Adt(_, _) => {\n                 let destructured = tcx.destructure_const(param_env.and(cv));\n-                PatKind::Leaf { subpatterns: field_pats(destructured.fields) }\n+                PatKind::Leaf { subpatterns: field_pats(destructured.fields)? }\n             }\n             ty::Array(..) => PatKind::Array {\n                 prefix: tcx\n                     .destructure_const(param_env.and(cv))\n                     .fields\n                     .iter()\n                     .map(|val| self.recur(val, false))\n-                    .collect(),\n+                    .collect::<Result<_, _>>()?,\n                 slice: None,\n                 suffix: Vec::new(),\n             },\n@@ -355,7 +365,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                                     .fields\n                                     .iter()\n                                     .map(|val| self.recur(val, false))\n-                                    .collect(),\n+                                    .collect::<Result<_, _>>()?,\n                                 slice: None,\n                                 suffix: vec![],\n                             }),\n@@ -379,8 +389,13 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // deref pattern.\n                 _ => {\n                     let old = self.behind_reference.replace(true);\n-                    let val = PatKind::Deref {\n-                        subpattern: self.recur(tcx.deref_const(self.param_env.and(cv)), false),\n+                    // In case there are structural-match violations somewhere in this subpattern,\n+                    // we fall back to a const pattern. If we do not do this, we may end up with\n+                    // a !structural-match constant that is not of reference type, which makes it\n+                    // very hard to invoke `PartialEq::eq` on it as a fallback.\n+                    let val = match self.recur(tcx.deref_const(self.param_env.and(cv)), false) {\n+                        Ok(subpattern) => PatKind::Deref { subpattern },\n+                        Err(FallbackToConstRef) => PatKind::Constant { value: cv },\n                     };\n                     self.behind_reference.set(old);\n                     val\n@@ -439,6 +454,6 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             );\n         }\n \n-        Pat { span, ty: cv.ty, kind: Box::new(kind) }\n+        Ok(Pat { span, ty: cv.ty, kind: Box::new(kind) })\n     }\n }"}]}