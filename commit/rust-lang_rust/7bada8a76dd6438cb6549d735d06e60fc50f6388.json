{"sha": "7bada8a76dd6438cb6549d735d06e60fc50f6388", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYWRhOGE3NmRkNjQzOGNiNjU0OWQ3MzVkMDZlNjBmYzUwZjYzODg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-23T13:58:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-23T13:58:45Z"}, "message": "Merge #5473\n\n5473: Changes to rust-project.json r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "31e30e51dc863c01a3e1befa43ef58c6089c41dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31e30e51dc863c01a3e1befa43ef58c6089c41dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bada8a76dd6438cb6549d735d06e60fc50f6388", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGZeVCRBK7hj4Ov3rIwAAdHIIALJPdCBIYYa80lJ1pJG0adgr\n4Ga532aUoeLSDJmhDy1wcTGre7pORI+7FTtQU8Pooy7t/mY/IK8lsRkVnmIzK7ee\nXPH1n3PFITIwESwFDq6LGfhHJ2LTxUQUm9z3kYM9uSG3HAKDtZG9nvOw8sNBUplV\n9Ha4hQh/6zl476X5MSJAxRabvwcNlJYQrWVxyuPYc/wGXaYr/z5OzAEDgWP1hRWY\nKNsXYyxYU9hg8eYD01DynjeW0/c3edzbjEeO310bU8QApaQTaAClUk+sINk1ioTH\nsaN7d/0HY6IX8zvl3+8k3x0dGidMHPLzH+F4nnb4sxz8T7qj+kE1B17a+CVliLU=\n=LljZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 31e30e51dc863c01a3e1befa43ef58c6089c41dd\nparent 83f364523f6874e52ed8db50be00fd28bdb57b94\nparent b68ef1231daf6eb1abeb06a30dc89af1254b833d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1595512725 +0000\ncommitter GitHub <noreply@github.com> 1595512725 +0000\n\nMerge #5473\n\n5473: Changes to rust-project.json r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bada8a76dd6438cb6549d735d06e60fc50f6388", "html_url": "https://github.com/rust-lang/rust/commit/7bada8a76dd6438cb6549d735d06e60fc50f6388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bada8a76dd6438cb6549d735d06e60fc50f6388/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83f364523f6874e52ed8db50be00fd28bdb57b94", "url": "https://api.github.com/repos/rust-lang/rust/commits/83f364523f6874e52ed8db50be00fd28bdb57b94", "html_url": "https://github.com/rust-lang/rust/commit/83f364523f6874e52ed8db50be00fd28bdb57b94"}, {"sha": "b68ef1231daf6eb1abeb06a30dc89af1254b833d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b68ef1231daf6eb1abeb06a30dc89af1254b833d", "html_url": "https://github.com/rust-lang/rust/commit/b68ef1231daf6eb1abeb06a30dc89af1254b833d"}], "stats": {"total": 228, "additions": 117, "deletions": 111}, "files": [{"sha": "2aafb99654917096833e0d5e85044c651bc036c3", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=7bada8a76dd6438cb6549d735d06e60fc50f6388", "patch": "@@ -222,7 +222,7 @@ impl From<Fixture> for FileMeta {\n                 .edition\n                 .as_ref()\n                 .map_or(Edition::Edition2018, |v| Edition::from_str(&v).unwrap()),\n-            env: Env::from(f.env.iter()),\n+            env: f.env.into_iter().collect(),\n         }\n     }\n }"}, {"sha": "6f2e5cfc76e72dde42ebfea049fb6c1387ffbc0c", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=7bada8a76dd6438cb6549d735d06e60fc50f6388", "patch": "@@ -6,7 +6,7 @@\n //! actual IO. See `vfs` and `project_model` in the `rust-analyzer` crate for how\n //! actual IO is done and lowered to input.\n \n-use std::{fmt, ops, str::FromStr, sync::Arc};\n+use std::{fmt, iter::FromIterator, ops, str::FromStr, sync::Arc};\n \n use ra_cfg::CfgOptions;\n use ra_syntax::SmolStr;\n@@ -298,18 +298,9 @@ impl fmt::Display for Edition {\n     }\n }\n \n-impl<'a, T> From<T> for Env\n-where\n-    T: Iterator<Item = (&'a String, &'a String)>,\n-{\n-    fn from(iter: T) -> Self {\n-        let mut result = Self::default();\n-\n-        for (k, v) in iter {\n-            result.entries.insert(k.to_owned(), v.to_owned());\n-        }\n-\n-        result\n+impl FromIterator<(String, String)> for Env {\n+    fn from_iter<T: IntoIterator<Item = (String, String)>>(iter: T) -> Self {\n+        Env { entries: FromIterator::from_iter(iter) }\n     }\n }\n "}, {"sha": "c7e0f4b58fbeca0088ffc4530ece1dc72d699445", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=7bada8a76dd6438cb6549d735d06e60fc50f6388", "patch": "@@ -2,7 +2,7 @@\n use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n-use ra_db::{CrateName, Env, FileSet, SourceRoot, VfsPath};\n+use ra_db::{CrateName, FileSet, SourceRoot, VfsPath};\n use test_utils::{\n     extract_annotations, extract_range_or_offset, Fixture, RangeOrOffset, CURSOR_MARKER,\n };\n@@ -110,7 +110,7 @@ impl MockAnalysis {\n                 data.edition.and_then(|it| it.parse().ok()).unwrap_or(Edition::Edition2018);\n \n             let file_id = FileId(i as u32 + 1);\n-            let env = Env::from(data.env.iter());\n+            let env = data.env.into_iter().collect();\n             if path == \"/lib.rs\" || path == \"/main.rs\" {\n                 root_crate = Some(crate_graph.add_crate_root(\n                     file_id,"}, {"sha": "6da4d7928afb80d005c1ea2554d618efaaaa3861", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 36, "deletions": 51, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=7bada8a76dd6438cb6549d735d06e60fc50f6388", "patch": "@@ -7,7 +7,6 @@ mod sysroot;\n use std::{\n     fs::{self, read_dir, ReadDir},\n     io,\n-    path::Path,\n     process::{Command, Output},\n };\n \n@@ -35,30 +34,12 @@ pub enum ProjectWorkspace {\n /// `PackageRoot` describes a package root folder.\n /// Which may be an external dependency, or a member of\n /// the current workspace.\n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, Eq, PartialEq, Hash)]\n pub struct PackageRoot {\n-    /// Path to the root folder\n-    path: AbsPathBuf,\n     /// Is a member of the current workspace\n-    is_member: bool,\n-    out_dir: Option<AbsPathBuf>,\n-}\n-impl PackageRoot {\n-    pub fn new_member(path: AbsPathBuf) -> PackageRoot {\n-        Self { path, is_member: true, out_dir: None }\n-    }\n-    pub fn new_non_member(path: AbsPathBuf) -> PackageRoot {\n-        Self { path, is_member: false, out_dir: None }\n-    }\n-    pub fn path(&self) -> &AbsPath {\n-        &self.path\n-    }\n-    pub fn out_dir(&self) -> Option<&AbsPath> {\n-        self.out_dir.as_deref()\n-    }\n-    pub fn is_member(&self) -> bool {\n-        self.is_member\n-    }\n+    pub is_member: bool,\n+    pub include: Vec<AbsPathBuf>,\n+    pub exclude: Vec<AbsPathBuf>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n@@ -195,18 +176,40 @@ impl ProjectWorkspace {\n     /// the root is a member of the current workspace\n     pub fn to_roots(&self) -> Vec<PackageRoot> {\n         match self {\n-            ProjectWorkspace::Json { project } => {\n-                project.roots.iter().map(|r| PackageRoot::new_member(r.path.clone())).collect()\n-            }\n+            ProjectWorkspace::Json { project } => project\n+                .crates\n+                .iter()\n+                .map(|krate| PackageRoot {\n+                    is_member: krate.is_workspace_member,\n+                    include: krate.include.clone(),\n+                    exclude: krate.exclude.clone(),\n+                })\n+                .collect::<FxHashSet<_>>()\n+                .into_iter()\n+                .collect::<Vec<_>>(),\n             ProjectWorkspace::Cargo { cargo, sysroot } => cargo\n                 .packages()\n-                .map(|pkg| PackageRoot {\n-                    path: cargo[pkg].root().to_path_buf(),\n-                    is_member: cargo[pkg].is_member,\n-                    out_dir: cargo[pkg].out_dir.clone(),\n+                .map(|pkg| {\n+                    let is_member = cargo[pkg].is_member;\n+                    let pkg_root = cargo[pkg].root().to_path_buf();\n+\n+                    let mut include = vec![pkg_root.clone()];\n+                    include.extend(cargo[pkg].out_dir.clone());\n+\n+                    let mut exclude = vec![pkg_root.join(\".git\")];\n+                    if is_member {\n+                        exclude.push(pkg_root.join(\"target\"));\n+                    } else {\n+                        exclude.push(pkg_root.join(\"tests\"));\n+                        exclude.push(pkg_root.join(\"examples\"));\n+                        exclude.push(pkg_root.join(\"benches\"));\n+                    }\n+                    PackageRoot { is_member, include, exclude }\n                 })\n-                .chain(sysroot.crates().map(|krate| {\n-                    PackageRoot::new_non_member(sysroot[krate].root_dir().to_path_buf())\n+                .chain(sysroot.crates().map(|krate| PackageRoot {\n+                    is_member: false,\n+                    include: vec![sysroot[krate].root_dir().to_path_buf()],\n+                    exclude: Vec::new(),\n                 }))\n                 .collect(),\n         }\n@@ -255,13 +258,7 @@ impl ProjectWorkspace {\n                         let file_path = &krate.root_module;\n                         let file_id = load(&file_path)?;\n \n-                        let mut env = Env::default();\n-                        if let Some(out_dir) = &krate.out_dir {\n-                            // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n-                            if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n-                                env.set(\"OUT_DIR\", out_dir);\n-                            }\n-                        }\n+                        let env = krate.env.clone().into_iter().collect();\n                         let proc_macro = krate\n                             .proc_macro_dylib_path\n                             .clone()\n@@ -503,18 +500,6 @@ impl ProjectWorkspace {\n         }\n         crate_graph\n     }\n-\n-    pub fn workspace_root_for(&self, path: &Path) -> Option<&AbsPath> {\n-        match self {\n-            ProjectWorkspace::Cargo { cargo, .. } => {\n-                Some(cargo.workspace_root()).filter(|root| path.starts_with(root))\n-            }\n-            ProjectWorkspace::Json { project: ProjectJson { roots, .. }, .. } => roots\n-                .iter()\n-                .find(|root| path.starts_with(&root.path))\n-                .map(|root| root.path.as_path()),\n-        }\n-    }\n }\n \n fn get_rustc_cfg_options(target: Option<&str>) -> CfgOptions {"}, {"sha": "e9a3331913e00e7d1315c5d2b7705bb90bc7c1d2", "filename": "crates/ra_project_model/src/project_json.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Fra_project_model%2Fsrc%2Fproject_json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Fra_project_model%2Fsrc%2Fproject_json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fproject_json.rs?ref=7bada8a76dd6438cb6549d735d06e60fc50f6388", "patch": "@@ -5,24 +5,16 @@ use std::path::PathBuf;\n use paths::{AbsPath, AbsPathBuf};\n use ra_cfg::CfgOptions;\n use ra_db::{CrateId, CrateName, Dependency, Edition};\n-use rustc_hash::FxHashSet;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use serde::{de, Deserialize};\n use stdx::split_delim;\n \n /// Roots and crates that compose this Rust project.\n #[derive(Clone, Debug, Eq, PartialEq)]\n pub struct ProjectJson {\n-    pub(crate) roots: Vec<Root>,\n     pub(crate) crates: Vec<Crate>,\n }\n \n-/// A root points to the directory which contains Rust crates. rust-analyzer watches all files in\n-/// all roots. Roots might be nested.\n-#[derive(Clone, Debug, Eq, PartialEq)]\n-pub struct Root {\n-    pub(crate) path: AbsPathBuf,\n-}\n-\n /// A crate points to the root module of a crate and lists the dependencies of the crate. This is\n /// useful in creating the crate graph.\n #[derive(Clone, Debug, Eq, PartialEq)]\n@@ -32,15 +24,16 @@ pub struct Crate {\n     pub(crate) deps: Vec<Dependency>,\n     pub(crate) cfg: CfgOptions,\n     pub(crate) target: Option<String>,\n-    pub(crate) out_dir: Option<AbsPathBuf>,\n+    pub(crate) env: FxHashMap<String, String>,\n     pub(crate) proc_macro_dylib_path: Option<AbsPathBuf>,\n     pub(crate) is_workspace_member: bool,\n+    pub(crate) include: Vec<AbsPathBuf>,\n+    pub(crate) exclude: Vec<AbsPathBuf>,\n }\n \n impl ProjectJson {\n     pub fn new(base: &AbsPath, data: ProjectJsonData) -> ProjectJson {\n         ProjectJson {\n-            roots: data.roots.into_iter().map(|path| Root { path: base.join(path) }).collect(),\n             crates: data\n                 .crates\n                 .into_iter()\n@@ -50,8 +43,19 @@ impl ProjectJson {\n                             && !crate_data.root_module.starts_with(\"..\")\n                             || crate_data.root_module.starts_with(base)\n                     });\n+                    let root_module = base.join(crate_data.root_module);\n+                    let (include, exclude) = match crate_data.source {\n+                        Some(src) => {\n+                            let absolutize = |dirs: Vec<PathBuf>| {\n+                                dirs.into_iter().map(|it| base.join(it)).collect::<Vec<_>>()\n+                            };\n+                            (absolutize(src.include_dirs), absolutize(src.exclude_dirs))\n+                        }\n+                        None => (vec![root_module.parent().unwrap().to_path_buf()], Vec::new()),\n+                    };\n+\n                     Crate {\n-                        root_module: base.join(crate_data.root_module),\n+                        root_module,\n                         edition: crate_data.edition.into(),\n                         deps: crate_data\n                             .deps\n@@ -74,11 +78,13 @@ impl ProjectJson {\n                             cfg\n                         },\n                         target: crate_data.target,\n-                        out_dir: crate_data.out_dir.map(|it| base.join(it)),\n+                        env: crate_data.env,\n                         proc_macro_dylib_path: crate_data\n                             .proc_macro_dylib_path\n                             .map(|it| base.join(it)),\n                         is_workspace_member,\n+                        include,\n+                        exclude,\n                     }\n                 })\n                 .collect::<Vec<_>>(),\n@@ -88,7 +94,6 @@ impl ProjectJson {\n \n #[derive(Deserialize)]\n pub struct ProjectJsonData {\n-    roots: Vec<PathBuf>,\n     crates: Vec<CrateData>,\n }\n \n@@ -100,9 +105,11 @@ struct CrateData {\n     #[serde(default)]\n     cfg: FxHashSet<String>,\n     target: Option<String>,\n-    out_dir: Option<PathBuf>,\n+    #[serde(default)]\n+    env: FxHashMap<String, String>,\n     proc_macro_dylib_path: Option<PathBuf>,\n     is_workspace_member: Option<bool>,\n+    source: Option<CrateSource>,\n }\n \n #[derive(Deserialize)]\n@@ -132,6 +139,12 @@ struct DepData {\n     name: CrateName,\n }\n \n+#[derive(Deserialize)]\n+struct CrateSource {\n+    include_dirs: Vec<PathBuf>,\n+    exclude_dirs: Vec<PathBuf>,\n+}\n+\n fn deserialize_crate_name<'de, D>(de: D) -> Result<CrateName, D::Error>\n where\n     D: de::Deserializer<'de>,"}, {"sha": "1907f2f132d65b6931b68a95ca4ba117dfcb9942", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=7bada8a76dd6438cb6549d735d06e60fc50f6388", "patch": "@@ -5,7 +5,7 @@ use flycheck::FlycheckHandle;\n use ra_db::{CrateGraph, SourceRoot, VfsPath};\n use ra_ide::AnalysisChange;\n use ra_prof::profile;\n-use ra_project_model::{PackageRoot, ProcMacroClient, ProjectWorkspace};\n+use ra_project_model::{ProcMacroClient, ProjectWorkspace};\n use vfs::{file_set::FileSetConfig, AbsPath, AbsPathBuf, ChangeKind};\n \n use crate::{\n@@ -149,8 +149,10 @@ impl GlobalState {\n                 watchers: workspaces\n                     .iter()\n                     .flat_map(ProjectWorkspace::to_roots)\n-                    .filter(PackageRoot::is_member)\n-                    .map(|root| format!(\"{}/**/*.rs\", root.path().display()))\n+                    .filter(|it| it.is_member)\n+                    .flat_map(|root| {\n+                        root.include.into_iter().map(|it| format!(\"{}/**/*.rs\", it.display()))\n+                    })\n                     .map(|glob_pattern| lsp_types::FileSystemWatcher { glob_pattern, kind: None })\n                     .collect(),\n             };\n@@ -261,31 +263,23 @@ impl ProjectFolders {\n         let mut local_filesets = vec![];\n \n         for root in workspaces.iter().flat_map(|it| it.to_roots()) {\n-            let path = root.path().to_owned();\n-\n-            let mut file_set_roots: Vec<VfsPath> = vec![];\n+            let file_set_roots: Vec<VfsPath> =\n+                root.include.iter().cloned().map(VfsPath::from).collect();\n \n-            let entry = if root.is_member() {\n-                vfs::loader::Entry::local_cargo_package(path.to_path_buf())\n-            } else {\n-                vfs::loader::Entry::cargo_package_dependency(path.to_path_buf())\n+            let entry = {\n+                let mut dirs = vfs::loader::Directories::default();\n+                dirs.extensions.push(\"rs\".into());\n+                dirs.include.extend(root.include);\n+                dirs.exclude.extend(root.exclude);\n+                vfs::loader::Entry::Directories(dirs)\n             };\n-            res.load.push(entry);\n-            if root.is_member() {\n-                res.watch.push(res.load.len() - 1);\n-            }\n \n-            if let Some(out_dir) = root.out_dir() {\n-                let out_dir = out_dir.to_path_buf();\n-                res.load.push(vfs::loader::Entry::rs_files_recursively(out_dir.clone()));\n-                if root.is_member() {\n-                    res.watch.push(res.load.len() - 1);\n-                }\n-                file_set_roots.push(out_dir.into());\n+            if root.is_member {\n+                res.watch.push(res.load.len());\n             }\n-            file_set_roots.push(path.to_path_buf().into());\n+            res.load.push(entry);\n \n-            if root.is_member() {\n+            if root.is_member {\n                 local_filesets.push(fsc.len());\n             }\n             fsc.add_file_set(file_set_roots)"}, {"sha": "40cf9602083d922d7137d04418d204df86b1b207", "filename": "crates/vfs/src/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Fvfs%2Fsrc%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bada8a76dd6438cb6549d735d06e60fc50f6388/crates%2Fvfs%2Fsrc%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Floader.rs?ref=7bada8a76dd6438cb6549d735d06e60fc50f6388", "patch": "@@ -17,7 +17,7 @@ pub enum Entry {\n ///   * it is not under `exclude` path\n ///\n /// If many include/exclude paths match, the longest one wins.\n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, Default)]\n pub struct Directories {\n     pub extensions: Vec<String>,\n     pub include: Vec<AbsPathBuf>,"}, {"sha": "4b31145deb36076dd7503cdbcdb4db4e85d64a01", "filename": "docs/user/manual.adoc", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7bada8a76dd6438cb6549d735d06e60fc50f6388/docs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/7bada8a76dd6438cb6549d735d06e60fc50f6388/docs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fmanual.adoc?ref=7bada8a76dd6438cb6549d735d06e60fc50f6388", "patch": "@@ -273,9 +273,6 @@ However, if you use some other build system, you'll have to describe the structu\n [source,TypeScript]\n ----\n interface JsonProject {\n-   /// The set of paths containing the crates for this project.\n-   /// Any `Crate` must be nested inside some `root`.\n-   roots: string[];\n    /// The set of crates comprising the current project.\n    /// Must include all transitive dependencies as well as sysroot crate (libstd, libcore and such).\n    crates: Crate[];\n@@ -288,11 +285,37 @@ interface Crate {\n     edition: \"2015\" | \"2018\";\n     /// Dependencies\n     deps: Dep[];\n+    /// Should this crate be treated as a member of current \"workspace\".\n+    ///\n+    /// By default, inferred from the `root_module` (members are the crates which reside\n+    /// inside the directory opened in the editor).\n+    ///\n+    /// Set this to `false` for things like standard library and 3rd party crates to\n+    /// enable performance optimizations (rust-analyzer assumes that non-member crates\n+    /// don't change).\n+    is_workspace_member?: boolean;\n+    /// Optionally specify the (super)set of `.rs` files comprising this crate.\n+    ///\n+    /// By default, rust-analyzer assumes that only files under `root_module.parent` can belong to a crate.\n+    /// `include_dirs` are included recursively, unless a subdirectory is in `exclude_dirs`.\n+    ///\n+    /// Different crates can share the same `source`.\n+\n+    /// If two crates share an `.rs` file in common, they *must* have the same `source`.\n+    /// rust-analyzer assumes that files from one source can't refer to files in another source.\n+    source?: {\n+        include_dirs: string[],\n+        exclude_dirs: string[],\n+    },\n     /// The set of cfgs activated for a given crate, like `[\"unix\", \"feature=foo\", \"feature=bar\"]`.\n     cfg: string[];\n+    /// Target triple for this Crate.\n+    ///\n+    /// Used when running `rustc --print cfg` to get target-specific cfgs.\n+    target?: string;\n+    /// Environment variables, used for the `env!` macro\n+    env: : { [key: string]: string; },\n \n-    /// value of the OUT_DIR env variable.\n-    out_dir?: string;\n     /// For proc-macro crates, path to compiles proc-macro (.so file).\n     proc_macro_dylib_path?: string;\n }"}]}