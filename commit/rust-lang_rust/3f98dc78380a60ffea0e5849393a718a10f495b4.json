{"sha": "3f98dc78380a60ffea0e5849393a718a10f495b4", "node_id": "C_kwDOAAsO6NoAKDNmOThkYzc4MzgwYTYwZmZlYTBlNTg0OTM5M2E3MThhMTBmNDk1YjQ", "commit": {"author": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-09-01T11:50:31Z"}, "committer": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-07T09:35:11Z"}, "message": "Clarify place expressions vs place objects", "tree": {"sha": "b0e57a94f57d3ecd1e0cafd695b1dc2c5d028556", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0e57a94f57d3ecd1e0cafd695b1dc2c5d028556"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f98dc78380a60ffea0e5849393a718a10f495b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f98dc78380a60ffea0e5849393a718a10f495b4", "html_url": "https://github.com/rust-lang/rust/commit/3f98dc78380a60ffea0e5849393a718a10f495b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f98dc78380a60ffea0e5849393a718a10f495b4/comments", "author": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1da30333406f0de9df70159d423d0196f164d8ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/1da30333406f0de9df70159d423d0196f164d8ac", "html_url": "https://github.com/rust-lang/rust/commit/1da30333406f0de9df70159d423d0196f164d8ac"}], "stats": {"total": 25, "additions": 16, "deletions": 9}, "files": [{"sha": "bc367de4baa5f0ac2280fde91d2a138785f5b11d", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3f98dc78380a60ffea0e5849393a718a10f495b4/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f98dc78380a60ffea0e5849393a718a10f495b4/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=3f98dc78380a60ffea0e5849393a718a10f495b4", "patch": "@@ -20,27 +20,34 @@\n //! # Correctness\n //!\n //! Warning: This is a semi-formal attempt to argue for the correctness of this analysis. If you\n-//! find any weak spots, let me know! Recommended reading: Abstract Interpretation.\n+//! find any weak spots, let me know! Recommended reading: Abstract Interpretation. We will use the\n+//! term \"place\" to refer to a place expression (like `mir::Place`), and we will call the\n+//! underlying entity \"object\". For instance, `*_1` and `*_2` are not the same place, but depending\n+//! on the value of `_1` and `_2`, they could refer to the same object. Also, the same place can\n+//! refer to different objects during execution. If `_1` is reassigned, then `*_1` may refer to\n+//! different objects before and after assignment. Additionally, when saying \"access to a place\",\n+//! what we really mean is \"access to an object denoted by arbitrary projections of that place\".\n //!\n //! In the following, we will assume a constant propagation analysis. Our analysis is correct if\n //! every transfer function is correct. This is the case if for every pair (f, f#) and abstract\n //! state s, we have f(y(s)) <= y(f#(s)), where s is a mapping from tracked place to top, bottom or\n //! a constant. Since pointers (and mutable references) are not tracked, but can be used to change\n //! values in the concrete domain, f# must assume that all places that can be affected in this way\n-//! for a given program point are marked with top (otherwise many assignments and function calls\n-//! would have no choice but to mark all tracked places with top). This leads us to an invariant:\n-//! For all possible program points where there could possibly exist a mutable reference or pointer\n-//! to a tracked place (in the concrete domain), this place must be assigned to top (in the\n+//! for a given program point are already marked with top in s (otherwise many assignments and\n+//! function calls would have no choice but to mark all tracked places with top). This leads us to\n+//! an invariant: For all possible program points where there could possibly exist means of mutable\n+//! access to a tracked place (in the concrete domain), this place must be assigned to top (in the\n //! abstract domain). The concretization function y can be defined as expected for the constant\n //! propagation analysis, although the concrete state of course contains all kinds of non-tracked\n-//! data. However, by the invariant above, no mutable references or pointers to tracked places that\n-//! are not marked with top may be introduced.\n+//! data. However, by the invariant above, no mutable access to tracked places that are not marked\n+//! with top may be introduced.\n //!\n //! Note that we (at least currently) do not differentiate between \"this place may assume different\n //! values\" and \"a pointer to this place escaped the analysis\". However, we still want to handle\n //! assignments to constants as usual for f#. This adds an assumption: Whenever we have an\n-//! assignment, all mutable access to the underlying place (which is not observed by the analysis)\n-//! must be invalidated. This is (hopefully) covered by Stacked Borrows.\n+//! assignment that is captured by the analysis, all mutable access to the underlying place (which\n+//! is not observable by the analysis) must be invalidated. This is (hopefully) covered by Stacked\n+//! Borrows.\n //!\n //! To be continued...\n "}]}