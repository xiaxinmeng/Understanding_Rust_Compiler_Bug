{"sha": "f1f25c0f8145c45078ff628dedae6aa4b28d962d", "node_id": "C_kwDOAAsO6NoAKGYxZjI1YzBmODE0NWM0NTA3OGZmNjI4ZGVkYWU2YWE0YjI4ZDk2MmQ", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-03-26T00:00:16Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-04-11T19:22:32Z"}, "message": "Improve documentation for MIR terminators", "tree": {"sha": "4d5b645cb91b3c0ee353cb8541f0b885317edb6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d5b645cb91b3c0ee353cb8541f0b885317edb6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1f25c0f8145c45078ff628dedae6aa4b28d962d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f25c0f8145c45078ff628dedae6aa4b28d962d", "html_url": "https://github.com/rust-lang/rust/commit/f1f25c0f8145c45078ff628dedae6aa4b28d962d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1f25c0f8145c45078ff628dedae6aa4b28d962d/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e01cd612787f2aab5ee7e4650b13941fc0b1707", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e01cd612787f2aab5ee7e4650b13941fc0b1707", "html_url": "https://github.com/rust-lang/rust/commit/8e01cd612787f2aab5ee7e4650b13941fc0b1707"}], "stats": {"total": 148, "additions": 121, "deletions": 27}, "files": [{"sha": "bf68835235da6288eb613fc7592c94a0177b47b9", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 121, "deletions": 27, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/f1f25c0f8145c45078ff628dedae6aa4b28d962d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f25c0f8145c45078ff628dedae6aa4b28d962d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=f1f25c0f8145c45078ff628dedae6aa4b28d962d", "patch": "@@ -105,13 +105,34 @@ impl<'a> Iterator for SwitchTargetsIter<'a> {\n \n impl<'a> ExactSizeIterator for SwitchTargetsIter<'a> {}\n \n+/// A note on unwinding: Panics may occur during the execution of some terminators. Depending on the\n+/// `-C panic` flag, this may either cause the program to abort or the call stack to unwind. Such\n+/// terminators have a `cleanup: Option<BasicBlock>` field on them. If stack unwinding occurs, then\n+/// once the current function is reached, execution continues at the given basic block, if any. If\n+/// `cleanup` is `None` then no cleanup is performed, and the stack continues unwinding. This is\n+/// equivalent to the execution of a `Resume` terminator.\n+///\n+/// The basic block pointed to by a `cleanup` field must have its `cleanup` flag set. `cleanup`\n+/// basic blocks have a couple restrictions:\n+///  1. All `cleanup` fields in them must be `None`.\n+///  2. `Return` terminators are not allowed in them. `Abort` and `Unwind` terminators are.\n+///  3. All other basic blocks (in the current body) that are reachable from `cleanup` basic blocks\n+///     must also be `cleanup`. This is a part of the type system and checked statically, so it is\n+///     still an error to have such an edge in the CFG even if it's known that it won't be taken at\n+///     runtime.\n #[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n pub enum TerminatorKind<'tcx> {\n-    /// Block should have one successor in the graph; we jump there.\n+    /// Block has one successor; we continue execution there.\n     Goto { target: BasicBlock },\n \n-    /// Operand evaluates to an integer; jump depending on its value\n-    /// to one of the targets, and otherwise fallback to `otherwise`.\n+    /// Switches based on the computed value.\n+    ///\n+    /// First, evaluates the `discr` operand. The type of the operand must be a signed or unsigned\n+    /// integer, char, or bool, and must match the given type. Then, if the list of switch targets\n+    /// contains the computed value, continues execution at the associated basic block. Otherwise,\n+    /// continues execution at the \"otherwise\" basic block.\n+    ///\n+    /// Target values may not appear more than once.\n     SwitchInt {\n         /// The discriminant value being tested.\n         discr: Operand<'tcx>,\n@@ -124,29 +145,62 @@ pub enum TerminatorKind<'tcx> {\n         targets: SwitchTargets,\n     },\n \n-    /// Indicates that the landing pad is finished and unwinding should\n-    /// continue. Emitted by `build::scope::diverge_cleanup`.\n+    /// Indicates that the landing pad is finished and that the process should continue unwinding.\n+    ///\n+    /// Like a return, this marks the end of this invocation of the function.\n+    ///\n+    /// Only permitted in cleanup blocks. `Resume` is not permitted with `-C unwind=abort` after\n+    /// deaggregation runs.\n     Resume,\n \n-    /// Indicates that the landing pad is finished and that the process\n-    /// should abort. Used to prevent unwinding for foreign items.\n+    /// Indicates that the landing pad is finished and that the process should abort.\n+    ///\n+    /// Used to prevent unwinding for foreign items or with `-C unwind=abort`. Only permitted in\n+    /// cleanup blocks.\n     Abort,\n \n-    /// Indicates a normal return. The return place should have\n-    /// been filled in before this executes. This can occur multiple times\n-    /// in different basic blocks.\n+    /// Returns from the function.\n+    ///\n+    /// Like function calls, the exact semantics of returns in Rust are unclear. Returning very\n+    /// likely at least assigns the value currently in the return place (`_0`) to the place\n+    /// specified in the associated `Call` terminator in the calling function, as if assigned via\n+    /// `dest = move _0`. It might additionally do other things, like have side-effects in the\n+    /// aliasing model.\n+    ///\n+    /// If the body is a generator body, this has slightly different semantics; it instead causes a\n+    /// `GeneratorState::Returned(_0)` to be created (as if by an `Aggregate` rvalue) and assigned\n+    /// to the return place.\n     Return,\n \n     /// Indicates a terminator that can never be reached.\n+    ///\n+    /// Executing this terminator is UB.\n     Unreachable,\n \n-    /// Drop the `Place`.\n+    /// The behavior of this statement differs significantly before and after drop elaboration.\n+    /// After drop elaboration, `Drop` executes the drop glue for the specified place, after which\n+    /// it continues execution/unwinds at the given basic blocks. It is possible that executing drop\n+    /// glue is special - this would be part of Rust's memory model. (**FIXME**: due we have an\n+    /// issue tracking if drop glue has any interesting semantics in addition to those of a function\n+    /// call?)\n+    ///\n+    /// `Drop` before drop elaboration is a *conditional* execution of the drop glue. Specifically, the\n+    /// `Drop` will be executed if...\n+    ///\n+    /// **Needs clarification**: End of that sentence. This in effect should document the exact\n+    /// behavior of drop elaboration. The following sounds vaguely right, but I'm not quite sure:\n+    ///\n+    /// > The drop glue is executed if, among all statements executed within this `Body`, an assignment to\n+    /// > the place or one of its \"parents\" occurred more recently than a move out of it. This does not\n+    /// > consider indirect assignments.\n     Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n \n-    /// Drop the `Place` and assign the new value over it. This ensures\n-    /// that the assignment to `P` occurs *even if* the destructor for\n-    /// place unwinds. Its semantics are best explained by the\n-    /// elaboration:\n+    /// Drops the place and assigns a new value to it.\n+    ///\n+    /// This first performs the exact same operation as the pre drop-elaboration `Drop` terminator;\n+    /// it then additionally assigns the `value` to the `place` as if by an assignment statement.\n+    /// This assignment occurs both in the unwind and the regular code paths. The semantics are best\n+    /// explained by the elaboration:\n     ///\n     /// ```\n     /// BB0 {\n@@ -170,15 +224,22 @@ pub enum TerminatorKind<'tcx> {\n     /// }\n     /// ```\n     ///\n-    /// Note that DropAndReplace is eliminated as part of the `ElaborateDrops` pass.\n+    /// Disallowed after drop elaboration.\n     DropAndReplace {\n         place: Place<'tcx>,\n         value: Operand<'tcx>,\n         target: BasicBlock,\n         unwind: Option<BasicBlock>,\n     },\n \n-    /// Block ends with a call of a function.\n+    /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of\n+    /// the referred to function. The operand types must match the argument types of the function.\n+    /// The return place type must exactly match the return type. The type of the `func` operand\n+    /// must be callable, meaning either a function pointer, a function type, or a closure type.\n+    ///\n+    /// **Needs clarification**: The exact semantics of this, see [#71117].\n+    ///\n+    /// [#71117]: https://github.com/rust-lang/rust/issues/71117\n     Call {\n         /// The function that\u2019s being called.\n         func: Operand<'tcx>,\n@@ -187,7 +248,7 @@ pub enum TerminatorKind<'tcx> {\n         /// This allows the memory occupied by \"by-value\" arguments to be\n         /// reused across function calls without duplicating the contents.\n         args: Vec<Operand<'tcx>>,\n-        /// Destination for the return value. If some, the call is converging.\n+        /// Destination for the return value. If none, the call necessarily diverges.\n         destination: Option<(Place<'tcx>, BasicBlock)>,\n         /// Cleanups to be done if the call unwinds.\n         cleanup: Option<BasicBlock>,\n@@ -199,8 +260,12 @@ pub enum TerminatorKind<'tcx> {\n         fn_span: Span,\n     },\n \n-    /// Jump to the target if the condition has the expected value,\n-    /// otherwise panic with a message and a cleanup target.\n+    /// Evaluates the operand, which must have type `bool`. If it is not equal to `expected`,\n+    /// initiates a panic. Initiating a panic corresponds to a `Call` terminator with some\n+    /// unspecified constant as the function to call, all the operands stored in the `AssertMessage`\n+    /// as parameters, and `None` for the destination. Keep in mind that the `cleanup` path is not\n+    /// necessarily executed even in the case of a panic, for example in `-C panic=abort`. If the\n+    /// assertion does not fail, execution continues at the specified basic block.\n     Assert {\n         cond: Operand<'tcx>,\n         expected: bool,\n@@ -209,7 +274,18 @@ pub enum TerminatorKind<'tcx> {\n         cleanup: Option<BasicBlock>,\n     },\n \n-    /// A suspend point.\n+    /// Marks a suspend point.\n+    ///\n+    /// Like `Return` terminators in generator bodies, this computes `value` and then a\n+    /// `GeneratorState::Yielded(value)` as if by `Aggregate` rvalue. That value is then assigned to\n+    /// the return place of the function calling this one, and execution continues in the calling\n+    /// function. When next invoked with the same first argument, execution of this function\n+    /// continues at the `resume` basic block, with the second argument written to the `resume_arg`\n+    /// place. If the generator is dropped before then, the `drop` basic block is invoked.\n+    ///\n+    /// Not permitted in bodies that are not generator bodies, or after generator lowering.\n+    ///\n+    /// **Needs clarification**: What about the evaluation order of the `resume_arg` and `value`?\n     Yield {\n         /// The value to return.\n         value: Operand<'tcx>,\n@@ -221,21 +297,39 @@ pub enum TerminatorKind<'tcx> {\n         drop: Option<BasicBlock>,\n     },\n \n-    /// Indicates the end of the dropping of a generator.\n+    /// Indicates the end of dropping a generator.\n+    ///\n+    /// Semantically just a `return` (from the generators drop glue). Only permitted in the same situations\n+    /// as `yield`.\n+    ///\n+    /// **Needs clarification**: Is that even correct? The generator drop code is always confusing\n+    /// to me, because it's not even really in the current body.\n+    ///\n+    /// **Needs clarification**: Are there type system constraints on these terminators? Should\n+    /// there be a \"block type\" like `cleanup` blocks for them?\n     GeneratorDrop,\n \n-    /// A block where control flow only ever takes one real path, but borrowck\n-    /// needs to be more conservative.\n+    /// A block where control flow only ever takes one real path, but borrowck needs to be more\n+    /// conservative.\n+    ///\n+    /// At runtime this is semantically just a goto.\n+    ///\n+    /// Disallowed after drop elaboration.\n     FalseEdge {\n         /// The target normal control flow will take.\n         real_target: BasicBlock,\n         /// A block control flow could conceptually jump to, but won't in\n         /// practice.\n         imaginary_target: BasicBlock,\n     },\n-    /// A terminator for blocks that only take one path in reality, but where we\n-    /// reserve the right to unwind in borrowck, even if it won't happen in practice.\n-    /// This can arise in infinite loops with no function calls for example.\n+\n+    /// A terminator for blocks that only take one path in reality, but where we reserve the right\n+    /// to unwind in borrowck, even if it won't happen in practice. This can arise in infinite loops\n+    /// with no function calls for example.\n+    ///\n+    /// At runtime this is semantically just a goto.\n+    ///\n+    /// Disallowed after drop elaboration.\n     FalseUnwind {\n         /// The target normal control flow will take.\n         real_target: BasicBlock,"}]}