{"sha": "0a049fd30d564d1cbc2d60398de848612a6c8125", "node_id": "C_kwDOAAsO6NoAKDBhMDQ5ZmQzMGQ1NjRkMWNiYzJkNjAzOThkZTg0ODYxMmE2YzgxMjU", "commit": {"author": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2021-07-01T19:03:51Z"}, "committer": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-06-17T04:42:26Z"}, "message": "proc_macro: reduce the number of messages required to create, extend, and iterate TokenStreams\n\nThis significantly reduces the cost of common interactions with TokenStream\nwhen running with the CrossThread execution strategy, by reducing the number of\nRPC calls required.", "tree": {"sha": "37a5523717874543f56043dafe0a725a4366f0ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37a5523717874543f56043dafe0a725a4366f0ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a049fd30d564d1cbc2d60398de848612a6c8125", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a049fd30d564d1cbc2d60398de848612a6c8125", "html_url": "https://github.com/rust-lang/rust/commit/0a049fd30d564d1cbc2d60398de848612a6c8125", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a049fd30d564d1cbc2d60398de848612a6c8125/comments", "author": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b172194686f0769e70d95cf6d8f571bc29a023e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b172194686f0769e70d95cf6d8f571bc29a023e", "html_url": "https://github.com/rust-lang/rust/commit/2b172194686f0769e70d95cf6d8f571bc29a023e"}], "stats": {"total": 224, "additions": 128, "deletions": 96}, "files": [{"sha": "8b6d5bcd935e1a6d9ae1779be3eba6dc1eaa1b24", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 54, "deletions": 44, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/0a049fd30d564d1cbc2d60398de848612a6c8125/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a049fd30d564d1cbc2d60398de848612a6c8125/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=0a049fd30d564d1cbc2d60398de848612a6c8125", "patch": "@@ -277,12 +277,6 @@ impl ToInternal<rustc_errors::Level> for Level {\n \n pub struct FreeFunctions;\n \n-#[derive(Clone)]\n-pub struct TokenStreamIter {\n-    cursor: tokenstream::Cursor,\n-    stack: Vec<TokenTree<Group, Punct, Ident, Literal>>,\n-}\n-\n #[derive(Clone)]\n pub struct Group {\n     delimiter: Delimiter,\n@@ -382,8 +376,6 @@ impl<'a, 'b> Rustc<'a, 'b> {\n impl server::Types for Rustc<'_, '_> {\n     type FreeFunctions = FreeFunctions;\n     type TokenStream = TokenStream;\n-    type TokenStreamBuilder = tokenstream::TokenStreamBuilder;\n-    type TokenStreamIter = TokenStreamIter;\n     type Group = Group;\n     type Punct = Punct;\n     type Ident = Ident;\n@@ -408,9 +400,6 @@ impl server::FreeFunctions for Rustc<'_, '_> {\n }\n \n impl server::TokenStream for Rustc<'_, '_> {\n-    fn new(&mut self) -> Self::TokenStream {\n-        TokenStream::default()\n-    }\n     fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n         stream.is_empty()\n     }\n@@ -481,53 +470,74 @@ impl server::TokenStream for Rustc<'_, '_> {\n     ) -> Self::TokenStream {\n         tree.to_internal()\n     }\n-    fn into_iter(&mut self, stream: Self::TokenStream) -> Self::TokenStreamIter {\n-        TokenStreamIter { cursor: stream.into_trees(), stack: vec![] }\n-    }\n-}\n-\n-impl server::TokenStreamBuilder for Rustc<'_, '_> {\n-    fn new(&mut self) -> Self::TokenStreamBuilder {\n-        tokenstream::TokenStreamBuilder::new()\n-    }\n-    fn push(&mut self, builder: &mut Self::TokenStreamBuilder, stream: Self::TokenStream) {\n-        builder.push(stream);\n+    fn concat_trees(\n+        &mut self,\n+        base: Option<Self::TokenStream>,\n+        trees: Vec<TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>>,\n+    ) -> Self::TokenStream {\n+        let mut builder = tokenstream::TokenStreamBuilder::new();\n+        if let Some(base) = base {\n+            builder.push(base);\n+        }\n+        for tree in trees {\n+            builder.push(tree.to_internal());\n+        }\n+        builder.build()\n     }\n-    fn build(&mut self, builder: Self::TokenStreamBuilder) -> Self::TokenStream {\n+    fn concat_streams(\n+        &mut self,\n+        base: Option<Self::TokenStream>,\n+        streams: Vec<Self::TokenStream>,\n+    ) -> Self::TokenStream {\n+        let mut builder = tokenstream::TokenStreamBuilder::new();\n+        if let Some(base) = base {\n+            builder.push(base);\n+        }\n+        for stream in streams {\n+            builder.push(stream);\n+        }\n         builder.build()\n     }\n-}\n-\n-impl server::TokenStreamIter for Rustc<'_, '_> {\n-    fn next(\n+    fn into_iter(\n         &mut self,\n-        iter: &mut Self::TokenStreamIter,\n-    ) -> Option<TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n+        stream: Self::TokenStream,\n+    ) -> Vec<TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n+        // XXX: This is a raw port of the previous approach, and can probably be\n+        // optimized.\n+        let mut cursor = stream.into_trees();\n+        let mut stack = Vec::new();\n+        let mut tts = Vec::new();\n         loop {\n-            let tree = iter.stack.pop().or_else(|| {\n-                let next = iter.cursor.next_with_spacing()?;\n-                Some(TokenTree::from_internal((next, &mut iter.stack, self)))\n-            })?;\n-            // A hack used to pass AST fragments to attribute and derive macros\n-            // as a single nonterminal token instead of a token stream.\n-            // Such token needs to be \"unwrapped\" and not represented as a delimited group.\n-            // FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n-            if let TokenTree::Group(ref group) = tree {\n-                if group.flatten {\n-                    iter.cursor.append(group.stream.clone());\n-                    continue;\n+            let next = stack.pop().or_else(|| {\n+                let next = cursor.next_with_spacing()?;\n+                Some(TokenTree::from_internal((next, &mut stack, self)))\n+            });\n+            match next {\n+                Some(TokenTree::Group(group)) => {\n+                    // A hack used to pass AST fragments to attribute and derive\n+                    // macros as a single nonterminal token instead of a token\n+                    // stream.  Such token needs to be \"unwrapped\" and not\n+                    // represented as a delimited group.\n+                    // FIXME: It needs to be removed, but there are some\n+                    // compatibility issues (see #73345).\n+                    if group.flatten {\n+                        cursor.append(group.stream);\n+                        continue;\n+                    }\n+                    tts.push(TokenTree::Group(group));\n                 }\n+                Some(tt) => tts.push(tt),\n+                None => return tts,\n             }\n-            return Some(tree);\n         }\n     }\n }\n \n impl server::Group for Rustc<'_, '_> {\n-    fn new(&mut self, delimiter: Delimiter, stream: Self::TokenStream) -> Self::Group {\n+    fn new(&mut self, delimiter: Delimiter, stream: Option<Self::TokenStream>) -> Self::Group {\n         Group {\n             delimiter,\n-            stream,\n+            stream: stream.unwrap_or_default(),\n             span: DelimSpan::from_single(server::Span::call_site(self)),\n             flatten: false,\n         }"}, {"sha": "421dd30273fd8a7407b22de83eb0ec95819a8898", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a049fd30d564d1cbc2d60398de848612a6c8125/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a049fd30d564d1cbc2d60398de848612a6c8125/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=0a049fd30d564d1cbc2d60398de848612a6c8125", "patch": "@@ -178,8 +178,6 @@ define_handles! {\n     'owned:\n     FreeFunctions,\n     TokenStream,\n-    TokenStreamBuilder,\n-    TokenStreamIter,\n     Group,\n     Literal,\n     SourceFile,\n@@ -204,12 +202,6 @@ impl Clone for TokenStream {\n     }\n }\n \n-impl Clone for TokenStreamIter {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n impl Clone for Group {\n     fn clone(&self) -> Self {\n         self.clone()\n@@ -435,7 +427,11 @@ impl Client<crate::TokenStream, crate::TokenStream> {\n         Client {\n             get_handle_counters: HandleCounters::get,\n             run: super::selfless_reify::reify_to_extern_c_fn_hrt_bridge(move |bridge| {\n-                run_client(bridge, |input| f(crate::TokenStream(input)).0)\n+                run_client(bridge, |input| {\n+                    f(crate::TokenStream(Some(input)))\n+                        .0\n+                        .unwrap_or_else(|| TokenStream::concat_streams(None, vec![]))\n+                })\n             }),\n             _marker: PhantomData,\n         }\n@@ -450,7 +446,9 @@ impl Client<(crate::TokenStream, crate::TokenStream), crate::TokenStream> {\n             get_handle_counters: HandleCounters::get,\n             run: super::selfless_reify::reify_to_extern_c_fn_hrt_bridge(move |bridge| {\n                 run_client(bridge, |(input, input2)| {\n-                    f(crate::TokenStream(input), crate::TokenStream(input2)).0\n+                    f(crate::TokenStream(Some(input)), crate::TokenStream(Some(input2)))\n+                        .0\n+                        .unwrap_or_else(|| TokenStream::concat_streams(None, vec![]))\n                 })\n             }),\n             _marker: PhantomData,"}, {"sha": "c6d0635df576d4b2a30b9ba64981f5b9e04efa34", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0a049fd30d564d1cbc2d60398de848612a6c8125/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a049fd30d564d1cbc2d60398de848612a6c8125/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=0a049fd30d564d1cbc2d60398de848612a6c8125", "patch": "@@ -60,33 +60,29 @@ macro_rules! with_api {\n             TokenStream {\n                 fn drop($self: $S::TokenStream);\n                 fn clone($self: &$S::TokenStream) -> $S::TokenStream;\n-                fn new() -> $S::TokenStream;\n                 fn is_empty($self: &$S::TokenStream) -> bool;\n                 fn expand_expr($self: &$S::TokenStream) -> Result<$S::TokenStream, ()>;\n                 fn from_str(src: &str) -> $S::TokenStream;\n                 fn to_string($self: &$S::TokenStream) -> String;\n                 fn from_token_tree(\n                     tree: TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>,\n                 ) -> $S::TokenStream;\n-                fn into_iter($self: $S::TokenStream) -> $S::TokenStreamIter;\n-            },\n-            TokenStreamBuilder {\n-                fn drop($self: $S::TokenStreamBuilder);\n-                fn new() -> $S::TokenStreamBuilder;\n-                fn push($self: &mut $S::TokenStreamBuilder, stream: $S::TokenStream);\n-                fn build($self: $S::TokenStreamBuilder) -> $S::TokenStream;\n-            },\n-            TokenStreamIter {\n-                fn drop($self: $S::TokenStreamIter);\n-                fn clone($self: &$S::TokenStreamIter) -> $S::TokenStreamIter;\n-                fn next(\n-                    $self: &mut $S::TokenStreamIter,\n-                ) -> Option<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>;\n+                fn concat_trees(\n+                    base: Option<$S::TokenStream>,\n+                    trees: Vec<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>,\n+                ) -> $S::TokenStream;\n+                fn concat_streams(\n+                    base: Option<$S::TokenStream>,\n+                    trees: Vec<$S::TokenStream>,\n+                ) -> $S::TokenStream;\n+                fn into_iter(\n+                    $self: $S::TokenStream\n+                ) -> Vec<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>;\n             },\n             Group {\n                 fn drop($self: $S::Group);\n                 fn clone($self: &$S::Group) -> $S::Group;\n-                fn new(delimiter: Delimiter, stream: $S::TokenStream) -> $S::Group;\n+                fn new(delimiter: Delimiter, stream: Option<$S::TokenStream>) -> $S::Group;\n                 fn delimiter($self: &$S::Group) -> Delimiter;\n                 fn stream($self: &$S::Group) -> $S::TokenStream;\n                 fn span($self: &$S::Group) -> $S::Span;"}, {"sha": "d98def36a3ca73ebdbafd83d32d7996ae9186ccd", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a049fd30d564d1cbc2d60398de848612a6c8125/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a049fd30d564d1cbc2d60398de848612a6c8125/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=0a049fd30d564d1cbc2d60398de848612a6c8125", "patch": "@@ -8,8 +8,6 @@ use super::client::HandleStore;\n pub trait Types {\n     type FreeFunctions: 'static;\n     type TokenStream: 'static + Clone;\n-    type TokenStreamBuilder: 'static;\n-    type TokenStreamIter: 'static + Clone;\n     type Group: 'static + Clone;\n     type Punct: 'static + Copy + Eq + Hash;\n     type Ident: 'static + Copy + Eq + Hash;"}, {"sha": "c21f365391c3b08560724f3e1063e86ebba6532e", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 54, "deletions": 24, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0a049fd30d564d1cbc2d60398de848612a6c8125/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a049fd30d564d1cbc2d60398de848612a6c8125/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=0a049fd30d564d1cbc2d60398de848612a6c8125", "patch": "@@ -43,7 +43,7 @@ use std::cmp::Ordering;\n use std::ops::RangeBounds;\n use std::path::PathBuf;\n use std::str::FromStr;\n-use std::{error, fmt, iter, mem};\n+use std::{error, fmt, iter};\n \n /// Determines whether proc_macro has been made accessible to the currently\n /// running program.\n@@ -72,7 +72,7 @@ pub fn is_available() -> bool {\n /// and `#[proc_macro_derive]` definitions.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n #[derive(Clone)]\n-pub struct TokenStream(bridge::client::TokenStream);\n+pub struct TokenStream(Option<bridge::client::TokenStream>);\n \n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl !Send for TokenStream {}\n@@ -126,13 +126,13 @@ impl TokenStream {\n     /// Returns an empty `TokenStream` containing no token trees.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new() -> TokenStream {\n-        TokenStream(bridge::client::TokenStream::new())\n+        TokenStream(None)\n     }\n \n     /// Checks if this `TokenStream` is empty.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n+        self.0.as_ref().map(|h| h.is_empty()).unwrap_or(true)\n     }\n \n     /// Parses this `TokenStream` as an expression and attempts to expand any\n@@ -147,8 +147,9 @@ impl TokenStream {\n     /// considered errors, is unspecified and may change in the future.\n     #[unstable(feature = \"proc_macro_expand\", issue = \"90765\")]\n     pub fn expand_expr(&self) -> Result<TokenStream, ExpandError> {\n-        match bridge::client::TokenStream::expand_expr(&self.0) {\n-            Ok(stream) => Ok(TokenStream(stream)),\n+        let stream = self.0.as_ref().ok_or(ExpandError)?;\n+        match bridge::client::TokenStream::expand_expr(stream) {\n+            Ok(stream) => Ok(TokenStream(Some(stream))),\n             Err(_) => Err(ExpandError),\n         }\n     }\n@@ -166,7 +167,7 @@ impl FromStr for TokenStream {\n     type Err = LexError;\n \n     fn from_str(src: &str) -> Result<TokenStream, LexError> {\n-        Ok(TokenStream(bridge::client::TokenStream::from_str(src)))\n+        Ok(TokenStream(Some(bridge::client::TokenStream::from_str(src))))\n     }\n }\n \n@@ -175,7 +176,7 @@ impl FromStr for TokenStream {\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for TokenStream {\n     fn to_string(&self) -> String {\n-        self.0.to_string()\n+        self.0.as_ref().map(|t| t.to_string()).unwrap_or_default()\n     }\n }\n \n@@ -208,24 +209,38 @@ impl Default for TokenStream {\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n pub use quote::{quote, quote_span};\n \n+fn tree_to_bridge_tree(\n+    tree: TokenTree,\n+) -> bridge::TokenTree<\n+    bridge::client::Group,\n+    bridge::client::Punct,\n+    bridge::client::Ident,\n+    bridge::client::Literal,\n+> {\n+    match tree {\n+        TokenTree::Group(tt) => bridge::TokenTree::Group(tt.0),\n+        TokenTree::Punct(tt) => bridge::TokenTree::Punct(tt.0),\n+        TokenTree::Ident(tt) => bridge::TokenTree::Ident(tt.0),\n+        TokenTree::Literal(tt) => bridge::TokenTree::Literal(tt.0),\n+    }\n+}\n+\n /// Creates a token stream containing a single token tree.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream(bridge::client::TokenStream::from_token_tree(match tree {\n-            TokenTree::Group(tt) => bridge::TokenTree::Group(tt.0),\n-            TokenTree::Punct(tt) => bridge::TokenTree::Punct(tt.0),\n-            TokenTree::Ident(tt) => bridge::TokenTree::Ident(tt.0),\n-            TokenTree::Literal(tt) => bridge::TokenTree::Literal(tt.0),\n-        }))\n+        TokenStream(Some(bridge::client::TokenStream::from_token_tree(tree_to_bridge_tree(tree))))\n     }\n }\n \n /// Collects a number of token trees into a single stream.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl iter::FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n-        trees.into_iter().map(TokenStream::from).collect()\n+        TokenStream(Some(bridge::client::TokenStream::concat_trees(\n+            None,\n+            trees.into_iter().map(tree_to_bridge_tree).collect(),\n+        )))\n     }\n }\n \n@@ -234,24 +249,30 @@ impl iter::FromIterator<TokenTree> for TokenStream {\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl iter::FromIterator<TokenStream> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n-        let mut builder = bridge::client::TokenStreamBuilder::new();\n-        streams.into_iter().for_each(|stream| builder.push(stream.0));\n-        TokenStream(builder.build())\n+        TokenStream(Some(bridge::client::TokenStream::concat_streams(\n+            None,\n+            streams.into_iter().filter_map(|stream| stream.0).collect(),\n+        )))\n     }\n }\n \n #[stable(feature = \"token_stream_extend\", since = \"1.30.0\")]\n impl Extend<TokenTree> for TokenStream {\n     fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n-        self.extend(trees.into_iter().map(TokenStream::from));\n+        *self = TokenStream(Some(bridge::client::TokenStream::concat_trees(\n+            self.0.take(),\n+            trees.into_iter().map(|tree| tree_to_bridge_tree(tree)).collect(),\n+        )));\n     }\n }\n \n #[stable(feature = \"token_stream_extend\", since = \"1.30.0\")]\n impl Extend<TokenStream> for TokenStream {\n     fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n-        // FIXME(eddyb) Use an optimized implementation if/when possible.\n-        *self = iter::once(mem::replace(self, Self::new())).chain(streams).collect();\n+        *self = TokenStream(Some(bridge::client::TokenStream::concat_streams(\n+            self.0.take(),\n+            streams.into_iter().filter_map(|stream| stream.0).collect(),\n+        )));\n     }\n }\n \n@@ -265,7 +286,16 @@ pub mod token_stream {\n     /// and returns whole groups as token trees.\n     #[derive(Clone)]\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-    pub struct IntoIter(bridge::client::TokenStreamIter);\n+    pub struct IntoIter(\n+        std::vec::IntoIter<\n+            bridge::TokenTree<\n+                bridge::client::Group,\n+                bridge::client::Punct,\n+                bridge::client::Ident,\n+                bridge::client::Literal,\n+            >,\n+        >,\n+    );\n \n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     impl Iterator for IntoIter {\n@@ -287,7 +317,7 @@ pub mod token_stream {\n         type IntoIter = IntoIter;\n \n         fn into_iter(self) -> IntoIter {\n-            IntoIter(self.0.into_iter())\n+            IntoIter(self.0.map(|v| v.into_iter()).unwrap_or_default().into_iter())\n         }\n     }\n }\n@@ -734,7 +764,7 @@ impl Group {\n     /// returned above.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn stream(&self) -> TokenStream {\n-        TokenStream(self.0.stream())\n+        TokenStream(Some(self.0.stream()))\n     }\n \n     /// Returns the span for the delimiters of this token stream, spanning the"}]}