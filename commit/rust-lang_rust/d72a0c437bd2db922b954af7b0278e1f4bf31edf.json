{"sha": "d72a0c437bd2db922b954af7b0278e1f4bf31edf", "node_id": "C_kwDOAAsO6NoAKGQ3MmEwYzQzN2JkMmRiOTIyYjk1NGFmN2IwMjc4ZTFmNGJmMzFlZGY", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-11T20:46:30Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-12T16:05:27Z"}, "message": "Properly calculate best failure in macro matching\n\nPreviously, we used spans. This was not good. Sometimes, the span of the\ntoken that failed to match may come from a position later in the file\nwhich has been transcribed into a token stream way earlier in the file.\nIf precisely this token fails to match, we think that it was the best\nmatch because its span is so high, even though other arms might have\ngotten further in the token stream.\n\nWe now try to properly use the location in the token stream.", "tree": {"sha": "64c689e5201e810e2bcc3fa2a5482dc73dd49e15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64c689e5201e810e2bcc3fa2a5482dc73dd49e15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d72a0c437bd2db922b954af7b0278e1f4bf31edf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d72a0c437bd2db922b954af7b0278e1f4bf31edf", "html_url": "https://github.com/rust-lang/rust/commit/d72a0c437bd2db922b954af7b0278e1f4bf31edf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d72a0c437bd2db922b954af7b0278e1f4bf31edf/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32da2305880765a4c76180086959a2d5da131565", "url": "https://api.github.com/repos/rust-lang/rust/commits/32da2305880765a4c76180086959a2d5da131565", "html_url": "https://github.com/rust-lang/rust/commit/32da2305880765a4c76180086959a2d5da131565"}], "stats": {"total": 95, "additions": 80, "deletions": 15}, "files": [{"sha": "40aa64d9d40401719d595629467aaa9aa7544f44", "filename": "compiler/rustc_expand/src/mbe/diagnostics.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d72a0c437bd2db922b954af7b0278e1f4bf31edf/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72a0c437bd2db922b954af7b0278e1f4bf31edf/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs?ref=d72a0c437bd2db922b954af7b0278e1f4bf31edf", "patch": "@@ -43,7 +43,7 @@ pub(super) fn failed_to_match_macro<'cx>(\n         return result;\n     }\n \n-    let Some((token, label, remaining_matcher)) = tracker.best_failure else {\n+    let Some(BestFailure { token, msg: label, remaining_matcher, .. }) = tracker.best_failure else {\n         return DummyResult::any(sp);\n     };\n \n@@ -95,11 +95,24 @@ struct CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n     cx: &'a mut ExtCtxt<'cx>,\n     remaining_matcher: Option<&'matcher MatcherLoc>,\n     /// Which arm's failure should we report? (the one furthest along)\n-    best_failure: Option<(Token, &'static str, MatcherLoc)>,\n+    best_failure: Option<BestFailure>,\n     root_span: Span,\n     result: Option<Box<dyn MacResult + 'cx>>,\n }\n \n+struct BestFailure {\n+    token: Token,\n+    position_in_tokenstream: usize,\n+    msg: &'static str,\n+    remaining_matcher: MatcherLoc,\n+}\n+\n+impl BestFailure {\n+    fn is_better_position(&self, position: usize) -> bool {\n+        position > self.position_in_tokenstream\n+    }\n+}\n+\n impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n     fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc) {\n         if self.remaining_matcher.is_none()\n@@ -119,18 +132,25 @@ impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx,\n                     \"should not collect detailed info for successful macro match\",\n                 );\n             }\n-            Failure(token, msg) => match self.best_failure {\n-                Some((ref best_token, _, _)) if best_token.span.lo() >= token.span.lo() => {}\n-                _ => {\n-                    self.best_failure = Some((\n-                        token.clone(),\n+            Failure(token, approx_position, msg) => {\n+                debug!(?token, ?msg, \"a new failure of an arm\");\n+\n+                if self\n+                    .best_failure\n+                    .as_ref()\n+                    .map_or(true, |failure| failure.is_better_position(*approx_position))\n+                {\n+                    self.best_failure = Some(BestFailure {\n+                        token: token.clone(),\n+                        position_in_tokenstream: *approx_position,\n                         msg,\n-                        self.remaining_matcher\n+                        remaining_matcher: self\n+                            .remaining_matcher\n                             .expect(\"must have collected matcher already\")\n                             .clone(),\n-                    ))\n+                    })\n                 }\n-            },\n+            }\n             Error(err_sp, msg) => {\n                 let span = err_sp.substitute_dummy(self.root_span);\n                 self.cx.struct_span_err(span, msg).emit();"}, {"sha": "df1c1834c1dc0d48b64c14c13e3c3ae950acd97a", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d72a0c437bd2db922b954af7b0278e1f4bf31edf/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72a0c437bd2db922b954af7b0278e1f4bf31edf/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=d72a0c437bd2db922b954af7b0278e1f4bf31edf", "patch": "@@ -310,7 +310,8 @@ pub(crate) enum ParseResult<T> {\n     Success(T),\n     /// Arm failed to match. If the second parameter is `token::Eof`, it indicates an unexpected\n     /// end of macro invocation. Otherwise, it indicates that no rules expected the given token.\n-    Failure(Token, &'static str),\n+    /// The usize is the approximate position of the token in the input token stream.\n+    Failure(Token, usize, &'static str),\n     /// Fatal error (malformed macro?). Abort compilation.\n     Error(rustc_span::Span, String),\n     ErrorReported(ErrorGuaranteed),\n@@ -455,6 +456,7 @@ impl TtParser {\n         &mut self,\n         matcher: &'matcher [MatcherLoc],\n         token: &Token,\n+        approx_position: usize,\n         track: &mut T,\n     ) -> Option<NamedParseResult> {\n         // Matcher positions that would be valid if the macro invocation was over now. Only\n@@ -598,6 +600,7 @@ impl TtParser {\n                         token::Eof,\n                         if token.span.is_dummy() { token.span } else { token.span.shrink_to_hi() },\n                     ),\n+                    approx_position,\n                     \"missing tokens in macro arguments\",\n                 ),\n             })\n@@ -627,7 +630,12 @@ impl TtParser {\n \n             // Process `cur_mps` until either we have finished the input or we need to get some\n             // parsing from the black-box parser done.\n-            let res = self.parse_tt_inner(matcher, &parser.token, track);\n+            let res = self.parse_tt_inner(\n+                matcher,\n+                &parser.token,\n+                parser.approx_token_stream_pos(),\n+                track,\n+            );\n             if let Some(res) = res {\n                 return res;\n             }\n@@ -642,6 +650,7 @@ impl TtParser {\n                     // parser: syntax error.\n                     return Failure(\n                         parser.token.clone(),\n+                        parser.approx_token_stream_pos(),\n                         \"no rules expected this token in macro call\",\n                     );\n                 }"}, {"sha": "b4001a497afa8ccbb960b61602b4b094825efba1", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d72a0c437bd2db922b954af7b0278e1f4bf31edf/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72a0c437bd2db922b954af7b0278e1f4bf31edf/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=d72a0c437bd2db922b954af7b0278e1f4bf31edf", "patch": "@@ -326,8 +326,8 @@ pub(super) fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n \n                 return Ok((i, named_matches));\n             }\n-            Failure(_, _) => {\n-                trace!(\"Failed to match arm, trying the next one\");\n+            Failure(_, reached_position, _) => {\n+                trace!(%reached_position, \"Failed to match arm, trying the next one\");\n                 // Try the next arm.\n             }\n             Error(_, _) => {\n@@ -432,7 +432,7 @@ pub fn compile_declarative_macro(\n     let argument_map =\n         match tt_parser.parse_tt(&mut Cow::Owned(parser), &argument_gram, &mut NoopTracker) {\n             Success(m) => m,\n-            Failure(token, msg) => {\n+            Failure(token, _, msg) => {\n                 let s = parse_failure_msg(&token);\n                 let sp = token.span.substitute_dummy(def.span);\n                 let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, &s);"}, {"sha": "008388e3da340c0628d1b4947b1b6b2359554a6d", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d72a0c437bd2db922b954af7b0278e1f4bf31edf/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72a0c437bd2db922b954af7b0278e1f4bf31edf/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=d72a0c437bd2db922b954af7b0278e1f4bf31edf", "patch": "@@ -1503,6 +1503,10 @@ impl<'a> Parser<'a> {\n     pub fn clear_expected_tokens(&mut self) {\n         self.expected_tokens.clear();\n     }\n+\n+    pub fn approx_token_stream_pos(&self) -> usize {\n+        self.token_cursor.num_next_calls\n+    }\n }\n \n pub(crate) fn make_unclosed_delims_error("}, {"sha": "bbdd465d5ec96b7896b187427f3e60d29099cdac", "filename": "src/test/ui/macros/best-failure.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d72a0c437bd2db922b954af7b0278e1f4bf31edf/src%2Ftest%2Fui%2Fmacros%2Fbest-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72a0c437bd2db922b954af7b0278e1f4bf31edf/src%2Ftest%2Fui%2Fmacros%2Fbest-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbest-failure.rs?ref=d72a0c437bd2db922b954af7b0278e1f4bf31edf", "patch": "@@ -0,0 +1,11 @@\n+macro_rules! number {\n+    (neg false, $self:ident) => { $self };\n+    ($signed:tt => $ty:ty;) => {\n+        number!(neg $signed, $self);\n+        //~^ ERROR no rules expected the token `$`\n+    };\n+}\n+\n+number! { false => u8; }\n+\n+fn main() {}"}, {"sha": "a52fc5e3da6a576d95df1db8812690b0dafe3b62", "filename": "src/test/ui/macros/best-failure.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d72a0c437bd2db922b954af7b0278e1f4bf31edf/src%2Ftest%2Fui%2Fmacros%2Fbest-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d72a0c437bd2db922b954af7b0278e1f4bf31edf/src%2Ftest%2Fui%2Fmacros%2Fbest-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbest-failure.stderr?ref=d72a0c437bd2db922b954af7b0278e1f4bf31edf", "patch": "@@ -0,0 +1,21 @@\n+error: no rules expected the token `$`\n+  --> $DIR/best-failure.rs:4:30\n+   |\n+LL | macro_rules! number {\n+   | ------------------- when calling this macro\n+...\n+LL |         number!(neg $signed, $self);\n+   |                              ^^^^^ no rules expected this token in macro call\n+...\n+LL | number! { false => u8; }\n+   | ------------------------ in this macro invocation\n+   |\n+note: while trying to match meta-variable `$self:ident`\n+  --> $DIR/best-failure.rs:2:17\n+   |\n+LL |     (neg false, $self:ident) => { $self };\n+   |                 ^^^^^^^^^^^\n+   = note: this error originates in the macro `number` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}]}