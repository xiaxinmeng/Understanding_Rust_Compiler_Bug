{"sha": "5f1aeb52c22e3784928765e34be6dc0d17a350b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMWFlYjUyYzIyZTM3ODQ5Mjg3NjVlMzRiZTZkYzBkMTdhMzUwYjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-22T18:17:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-22T18:17:23Z"}, "message": "Auto merge of #84440 - Dylan-DPC:rollup-0xjb8oi, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #84343 (Remove `ScopeTree::closure_tree`)\n - #84376 (Uses flex to fix formatting of h1 at any width)\n - #84377 (Followup to #83944)\n - #84396 (Update LLVM submodule)\n - #84402 (Move `sys_common::rwlock::StaticRWLock` etc. to `sys::unix::rwlock`)\n - #84404 (Check for intrinsics before coercing to a function pointer)\n - #84413 (Remove `sys::args::Args::inner_debug` and use `Debug` instead)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7852b8984f156016a1645303378df9b4fac9399c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7852b8984f156016a1645303378df9b4fac9399c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f1aeb52c22e3784928765e34be6dc0d17a350b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f1aeb52c22e3784928765e34be6dc0d17a350b4", "html_url": "https://github.com/rust-lang/rust/commit/5f1aeb52c22e3784928765e34be6dc0d17a350b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f1aeb52c22e3784928765e34be6dc0d17a350b4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccf171242bb00dd17ac4b844e6afe77fabd04b78", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccf171242bb00dd17ac4b844e6afe77fabd04b78", "html_url": "https://github.com/rust-lang/rust/commit/ccf171242bb00dd17ac4b844e6afe77fabd04b78"}, {"sha": "d1f5fc601770b7d579904c5b8fe554b184587b66", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1f5fc601770b7d579904c5b8fe554b184587b66", "html_url": "https://github.com/rust-lang/rust/commit/d1f5fc601770b7d579904c5b8fe554b184587b66"}], "stats": {"total": 939, "additions": 372, "deletions": 567}, "files": [{"sha": "8a3f76415968ec84955837b9e75fde29ea6e15b2", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -1213,8 +1213,41 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 deny_equality_constraints(self, predicate, generics);\n             }\n         }\n-\n-        visit::walk_generics(self, generics)\n+        walk_list!(self, visit_generic_param, &generics.params);\n+        for predicate in &generics.where_clause.predicates {\n+            match predicate {\n+                WherePredicate::BoundPredicate(bound_pred) => {\n+                    // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n+                    self.check_late_bound_lifetime_defs(&bound_pred.bound_generic_params);\n+\n+                    // This is slightly complicated. Our representation for poly-trait-refs contains a single\n+                    // binder and thus we only allow a single level of quantification. However,\n+                    // the syntax of Rust permits quantification in two places in where clauses,\n+                    // e.g., `T: for <'a> Foo<'a>` and `for <'a, 'b> &'b T: Foo<'a>`. If both are\n+                    // defined, then error.\n+                    if !bound_pred.bound_generic_params.is_empty() {\n+                        for bound in &bound_pred.bounds {\n+                            match bound {\n+                                GenericBound::Trait(t, _) => {\n+                                    if !t.bound_generic_params.is_empty() {\n+                                        struct_span_err!(\n+                                            self.err_handler(),\n+                                            t.span,\n+                                            E0316,\n+                                            \"nested quantification of lifetimes\"\n+                                        )\n+                                        .emit();\n+                                    }\n+                                }\n+                                GenericBound::Outlives(_) => {}\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+            self.visit_where_predicate(predicate);\n+        }\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n@@ -1263,14 +1296,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_pat(self, pat)\n     }\n \n-    fn visit_where_predicate(&mut self, p: &'a WherePredicate) {\n-        if let &WherePredicate::BoundPredicate(ref bound_predicate) = p {\n-            // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n-            self.check_late_bound_lifetime_defs(&bound_predicate.bound_generic_params);\n-        }\n-        visit::walk_where_predicate(self, p);\n-    }\n-\n     fn visit_poly_trait_ref(&mut self, t: &'a PolyTraitRef, m: &'a TraitBoundModifier) {\n         self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n         visit::walk_poly_trait_ref(self, t, m);"}, {"sha": "f44267a404bf301ae3ea8ebf884f52b91319617d", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -235,18 +235,6 @@ pub struct ScopeTree {\n     /// escape into 'static and should have no local cleanup scope.\n     rvalue_scopes: FxHashMap<hir::ItemLocalId, Option<Scope>>,\n \n-    /// Encodes the hierarchy of fn bodies. Every fn body (including\n-    /// closures) forms its own distinct region hierarchy, rooted in\n-    /// the block that is the fn body. This map points from the ID of\n-    /// that root block to the ID of the root block for the enclosing\n-    /// fn, if any. Thus the map structures the fn bodies into a\n-    /// hierarchy based on their lexical mapping. This is used to\n-    /// handle the relationships between regions in a fn and in a\n-    /// closure defined by that fn. See the \"Modeling closures\"\n-    /// section of the README in infer::region_constraints for\n-    /// more details.\n-    closure_tree: FxHashMap<hir::ItemLocalId, hir::ItemLocalId>,\n-\n     /// If there are any `yield` nested within a scope, this map\n     /// stores the `Span` of the last one and its index in the\n     /// postorder of the Visitor traversal on the HIR.\n@@ -356,23 +344,6 @@ impl ScopeTree {\n         self.destruction_scopes.get(&n).cloned()\n     }\n \n-    /// Records that `sub_closure` is defined within `sup_closure`. These IDs\n-    /// should be the ID of the block that is the fn body, which is\n-    /// also the root of the region hierarchy for that fn.\n-    pub fn record_closure_parent(\n-        &mut self,\n-        sub_closure: hir::ItemLocalId,\n-        sup_closure: hir::ItemLocalId,\n-    ) {\n-        debug!(\n-            \"record_closure_parent(sub_closure={:?}, sup_closure={:?})\",\n-            sub_closure, sup_closure\n-        );\n-        assert!(sub_closure != sup_closure);\n-        let previous = self.closure_tree.insert(sub_closure, sup_closure);\n-        assert!(previous.is_none());\n-    }\n-\n     pub fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: Scope) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.item_local_id());\n@@ -474,7 +445,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for ScopeTree {\n             ref var_map,\n             ref destruction_scopes,\n             ref rvalue_scopes,\n-            ref closure_tree,\n             ref yield_in_scope,\n         } = *self;\n \n@@ -488,7 +458,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for ScopeTree {\n         var_map.hash_stable(hcx, hasher);\n         destruction_scopes.hash_stable(hcx, hasher);\n         rvalue_scopes.hash_stable(hcx, hasher);\n-        closure_tree.hash_stable(hcx, hasher);\n         yield_in_scope.hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "14a373c59423fbbdeef6940bca513eb8d63fd551", "filename": "compiler/rustc_passes/src/region.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fregion.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -23,14 +23,6 @@ use std::mem;\n \n #[derive(Debug, Copy, Clone)]\n pub struct Context {\n-    /// The root of the current region tree. This is typically the id\n-    /// of the innermost fn body. Each fn forms its own disjoint tree\n-    /// in the region hierarchy. These fn bodies are themselves\n-    /// arranged into a tree. See the \"Modeling closures\" section of\n-    /// the README in `rustc_trait_selection::infer::region_constraints`\n-    /// for more details.\n-    root_id: Option<hir::ItemLocalId>,\n-\n     /// The scope that contains any new variables declared, plus its depth in\n     /// the scope tree.\n     var_parent: Option<(Scope, ScopeDepth)>,\n@@ -743,11 +735,6 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         let outer_pessimistic_yield = mem::replace(&mut self.pessimistic_yield, false);\n         self.terminating_scopes.insert(body.value.hir_id.local_id);\n \n-        if let Some(root_id) = self.cx.root_id {\n-            self.scope_tree.record_closure_parent(body.value.hir_id.local_id, root_id);\n-        }\n-        self.cx.root_id = Some(body.value.hir_id.local_id);\n-\n         self.enter_scope(Scope { id: body.value.hir_id.local_id, data: ScopeData::CallSite });\n         self.enter_scope(Scope { id: body.value.hir_id.local_id, data: ScopeData::Arguments });\n \n@@ -824,7 +811,7 @@ fn region_scope_tree(tcx: TyCtxt<'_>, def_id: DefId) -> &ScopeTree {\n             tcx,\n             scope_tree: ScopeTree::default(),\n             expr_and_pat_count: 0,\n-            cx: Context { root_id: None, parent: None, var_parent: None },\n+            cx: Context { parent: None, var_parent: None },\n             terminating_scopes: Default::default(),\n             pessimistic_yield: false,\n             fixup_scopes: vec![],"}, {"sha": "174df09cbdbb2b5e4dcea4cb05da17b9f6974f5e", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 219, "deletions": 412, "changes": 631, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -165,29 +165,6 @@ crate struct LifetimeContext<'a, 'tcx> {\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n-    /// This is slightly complicated. Our representation for poly-trait-refs contains a single\n-    /// binder and thus we only allow a single level of quantification. However,\n-    /// the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n-    /// and `for <'a, 'b> &'b T: Foo<'a>`. In order to get the De Bruijn indices\n-    /// correct when representing these constraints, we should only introduce one\n-    /// scope. However, we want to support both locations for the quantifier and\n-    /// during lifetime resolution we want precise information (so we can't\n-    /// desugar in an earlier phase). Moreso, an error here doesn't cause a bail\n-    /// from type checking, so we need to be extra careful that we don't lose\n-    /// any bound var information.\n-    ///\n-    /// So, if we encounter a quantifier at the outer scope, we set\n-    /// `trait_ref_hack` to the hir id of the bounded type (and introduce a scope).\n-    /// Then, if we encounter a quantifier at the inner scope, then we know to\n-    /// emit an error. Importantly though, we do have to track the lifetimes\n-    /// defined on the outer scope (i.e. the bounded ty), since we continue\n-    /// to type check after emitting an error; we therefore assume that the bound\n-    /// vars on the inner trait refs come from both quantifiers.\n-    ///\n-    /// If we encounter a quantifier in the inner scope `trait_ref_hack` being\n-    /// `None`, then we just introduce the scope at the inner quantifier as normal.\n-    trait_ref_hack: Option<hir::HirId>,\n-\n     /// Used to disallow the use of in-band lifetimes in `fn` or `Fn` syntax.\n     is_in_fn_syntax: bool,\n \n@@ -244,10 +221,7 @@ enum Scope<'a> {\n         /// of the resulting opaque type.\n         opaque_type_parent: bool,\n \n-        /// True only if this `Binder` scope is from the quantifiers on a\n-        /// `PolyTraitRef`. This is necessary for `associated_type_bounds`, which\n-        /// requires binders of nested trait refs to be merged.\n-        from_poly_trait_ref: bool,\n+        scope_type: BinderScopeType,\n \n         /// The late bound vars for a given item are stored by `HirId` to be\n         /// queried later. However, if we enter an elision scope, we have to\n@@ -282,41 +256,6 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n-    /// This is a particularly interesting consequence of how we handle poly\n-    /// trait refs. See `trait_ref_hack` for additional info. This bit is\n-    /// important w.r.t. querying late-bound vars.\n-    ///\n-    /// To completely understand why this is necessary, first it's important to\n-    /// realize that `T: for<'a> U + for<'a, 'b> V` is actually two separate\n-    /// trait refs: `T: for<'a> U` and `T: for<'b> V` and as such, the late\n-    /// bound vars on each needs to be tracked separately. Also, in this case,\n-    /// are *three* relevant `HirId`s: one for the entire bound and one\n-    /// for each separate one.\n-    ///\n-    /// Next, imagine three different poly trait refs:\n-    ///   1) `for<'a, 'b> T: U<'a, 'b>`\n-    ///   2) `T: for<'a, 'b> U<'a, 'b>`\n-    ///   3) `for<'a> T: for<'b> U<'a, 'b>`\n-    ///\n-    /// First, note that the third example is semantically invalid and an error,\n-    /// but we *must* handle it as valid, since type checking isn't bailed out\n-    /// of. Other than that, if ask for bound vars for each, we expect\n-    /// `['a, 'b]`. If we *didn't* allow binders before `T`, then we would\n-    /// always introduce a binder scope at the inner trait ref. This is great,\n-    /// because later on during type-checking, we will ask \"what are the late\n-    /// bound vars on this trait ref\". However, because we allow bound vars on\n-    /// the bound itself, we have to have some way of keeping track of the fact\n-    /// that we actually want to store the late bound vars as being associated\n-    /// with the trait ref; this is that.\n-    ///\n-    /// One alternative way to handle this would be to just introduce a new\n-    /// `Binder` scope, but that's semantically a bit different, since bound\n-    /// vars from both `for<...>`s *do* share the same binder level.\n-    TraitRefHackInner {\n-        hir_id: hir::HirId,\n-        s: ScopeRef<'a>,\n-    },\n-\n     /// When we have nested trait refs, we concanetate late bound vars for inner\n     /// trait refs from outer ones. But we also need to include any HRTB\n     /// lifetimes encountered when identifying the trait that an associated type\n@@ -333,6 +272,22 @@ enum Scope<'a> {\n     Root,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+enum BinderScopeType {\n+    /// Any non-concatenating binder scopes.\n+    Normal,\n+    /// Within a syntactic trait ref, there may be multiple poly trait refs that\n+    /// are nested (under the `associcated_type_bounds` feature). The binders of\n+    /// the innner poly trait refs are extended from the outer poly trait refs\n+    /// and don't increase the late bound depth. If you had\n+    /// `T: for<'a>  Foo<Bar: for<'b> Baz<'a, 'b>>`, then the `for<'b>` scope\n+    /// would be `Concatenating`. This also used in trait refs in where clauses\n+    /// where we have two binders `for<> T: for<> Foo` (I've intentionally left\n+    /// out any lifetimes because they aren't needed to show the two scopes).\n+    /// The inner `for<>` has a scope of `Concatenating`.\n+    Concatenating,\n+}\n+\n // A helper struct for debugging scopes without printing parent scopes\n struct TruncatedScopeDebug<'a>(&'a Scope<'a>);\n \n@@ -344,7 +299,7 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 next_early_index,\n                 track_lifetime_uses,\n                 opaque_type_parent,\n-                from_poly_trait_ref,\n+                scope_type,\n                 hir_id,\n                 s: _,\n             } => f\n@@ -353,7 +308,7 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"next_early_index\", next_early_index)\n                 .field(\"track_lifetime_uses\", track_lifetime_uses)\n                 .field(\"opaque_type_parent\", opaque_type_parent)\n-                .field(\"from_poly_trait_ref\", from_poly_trait_ref)\n+                .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n@@ -368,11 +323,6 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"lifetime\", lifetime)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n-            Scope::TraitRefHackInner { hir_id, s: _ } => f\n-                .debug_struct(\"TraitRefHackInner\")\n-                .field(\"hir_id\", hir_id)\n-                .field(\"s\", &\"..\")\n-                .finish(),\n             Scope::Supertrait { lifetimes, s: _ } => f\n                 .debug_struct(\"Supertrait\")\n                 .field(\"lifetimes\", lifetimes)\n@@ -495,7 +445,6 @@ fn do_resolve(\n         tcx,\n         map: &mut named_region_map,\n         scope: ROOT_SCOPE,\n-        trait_ref_hack: None,\n         is_in_fn_syntax: false,\n         is_in_const_generic: false,\n         trait_definition_only,\n@@ -618,6 +567,43 @@ fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::\n     }\n }\n \n+impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n+    /// Returns the binders in scope and the type of `Binder` that should be created for a poly trait ref.\n+    fn poly_trait_ref_binder_info(&mut self) -> (Vec<ty::BoundVariableKind>, BinderScopeType) {\n+        let mut scope = self.scope;\n+        let mut supertrait_lifetimes = vec![];\n+        loop {\n+            match scope {\n+                Scope::Body { .. } | Scope::Root => {\n+                    break (vec![], BinderScopeType::Normal);\n+                }\n+\n+                Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n+                    scope = s;\n+                }\n+\n+                Scope::Supertrait { s, lifetimes } => {\n+                    supertrait_lifetimes = lifetimes.clone();\n+                    scope = s;\n+                }\n+\n+                Scope::TraitRefBoundary { .. } => {\n+                    // We should only see super trait lifetimes if there is a `Binder` above\n+                    assert!(supertrait_lifetimes.is_empty());\n+                    break (vec![], BinderScopeType::Normal);\n+                }\n+\n+                Scope::Binder { hir_id, .. } => {\n+                    // Nested poly trait refs have the binders concatenated\n+                    let mut full_binders =\n+                        self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n+                    full_binders.extend(supertrait_lifetimes.into_iter());\n+                    break (full_binders, BinderScopeType::Concatenating);\n+                }\n+            }\n+        }\n+    }\n+}\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n@@ -675,7 +661,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    from_poly_trait_ref: false,\n+                    scope_type: BinderScopeType::Normal,\n                 };\n                 self.with(scope, move |_old_scope, this| {\n                     intravisit::walk_fn(this, fk, fd, b, s, hir_id)\n@@ -800,12 +786,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index: index + non_lifetime_count,\n                     opaque_type_parent: true,\n                     track_lifetime_uses,\n-                    from_poly_trait_ref: false,\n+                    scope_type: BinderScopeType::Normal,\n                     s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n-                    intravisit::walk_item(this, item);\n+                    let scope = Scope::TraitRefBoundary { s: this.scope };\n+                    this.with(scope, |_, this| {\n+                        intravisit::walk_item(this, item);\n+                    });\n                 });\n                 self.missing_named_lifetime_spots.pop();\n             }\n@@ -869,7 +858,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    from_poly_trait_ref: false,\n+                    scope_type: BinderScopeType::Normal,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -939,9 +928,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                         // Elided lifetimes are not allowed in non-return\n                         // position impl Trait\n-                        let scope = Scope::Elision { elide: Elide::Forbid, s: self.scope };\n+                        let scope = Scope::TraitRefBoundary { s: self.scope };\n                         self.with(scope, |_, this| {\n-                            intravisit::walk_item(this, opaque_ty);\n+                            let scope = Scope::Elision { elide: Elide::Forbid, s: this.scope };\n+                            this.with(scope, |_, this| {\n+                                intravisit::walk_item(this, opaque_ty);\n+                            })\n                         });\n \n                         return;\n@@ -1062,7 +1054,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             s: this.scope,\n                             track_lifetime_uses: true,\n                             opaque_type_parent: false,\n-                            from_poly_trait_ref: false,\n+                            scope_type: BinderScopeType::Normal,\n                         };\n                         this.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n@@ -1082,7 +1074,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         s: self.scope,\n                         track_lifetime_uses: true,\n                         opaque_type_parent: false,\n-                        from_poly_trait_ref: false,\n+                        scope_type: BinderScopeType::Normal,\n                     };\n                     self.with(scope, |_old_scope, this| {\n                         let scope = Scope::TraitRefBoundary { s: this.scope };\n@@ -1141,7 +1133,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n-                    from_poly_trait_ref: false,\n+                    scope_type: BinderScopeType::Normal,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n@@ -1210,7 +1202,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n-                    from_poly_trait_ref: false,\n+                    scope_type: BinderScopeType::Normal,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n@@ -1270,106 +1262,110 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         if !self.trait_definition_only {\n             check_mixed_explicit_and_in_band_defs(self.tcx, &generics.params);\n         }\n-        for param in generics.params {\n-            match param.kind {\n-                GenericParamKind::Lifetime { .. } => {}\n-                GenericParamKind::Type { ref default, .. } => {\n-                    walk_list!(self, visit_param_bound, param.bounds);\n-                    if let Some(ref ty) = default {\n-                        self.visit_ty(&ty);\n+        let scope = Scope::TraitRefBoundary { s: self.scope };\n+        self.with(scope, |_, this| {\n+            for param in generics.params {\n+                match param.kind {\n+                    GenericParamKind::Lifetime { .. } => {}\n+                    GenericParamKind::Type { ref default, .. } => {\n+                        walk_list!(this, visit_param_bound, param.bounds);\n+                        if let Some(ref ty) = default {\n+                            this.visit_ty(&ty);\n+                        }\n+                    }\n+                    GenericParamKind::Const { ref ty, .. } => {\n+                        let was_in_const_generic = this.is_in_const_generic;\n+                        this.is_in_const_generic = true;\n+                        walk_list!(this, visit_param_bound, param.bounds);\n+                        this.visit_ty(&ty);\n+                        this.is_in_const_generic = was_in_const_generic;\n                     }\n                 }\n-                GenericParamKind::Const { ref ty, .. } => {\n-                    let was_in_const_generic = self.is_in_const_generic;\n-                    self.is_in_const_generic = true;\n-                    walk_list!(self, visit_param_bound, param.bounds);\n-                    self.visit_ty(&ty);\n-                    self.is_in_const_generic = was_in_const_generic;\n-                }\n-            }\n-        }\n-        for predicate in generics.where_clause.predicates {\n-            match predicate {\n-                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                    ref bounded_ty,\n-                    bounds,\n-                    ref bound_generic_params,\n-                    ..\n-                }) => {\n-                    let (lifetimes, binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) =\n-                        bound_generic_params\n-                            .iter()\n-                            .filter_map(|param| match param.kind {\n-                                GenericParamKind::Lifetime { .. } => Some(param),\n-                                _ => None,\n-                            })\n-                            .enumerate()\n-                            .map(|(late_bound_idx, param)| {\n-                                let pair =\n-                                    Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n-                                let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                                (pair, r)\n-                            })\n-                            .unzip();\n-                    self.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n-                    let scope = Scope::TraitRefBoundary { s: self.scope };\n-                    self.with(scope, |_, this| {\n-                        if !lifetimes.is_empty() {\n-                            let next_early_index = this.next_early_index();\n-                            let scope = Scope::Binder {\n-                                hir_id: bounded_ty.hir_id,\n-                                lifetimes,\n-                                s: this.scope,\n-                                next_early_index,\n-                                track_lifetime_uses: true,\n-                                opaque_type_parent: false,\n-                                from_poly_trait_ref: true,\n-                            };\n-                            this.with(scope, |old_scope, this| {\n-                                this.check_lifetime_params(old_scope, &bound_generic_params);\n-                                this.visit_ty(&bounded_ty);\n-                                this.trait_ref_hack = Some(bounded_ty.hir_id);\n-                                walk_list!(this, visit_param_bound, bounds);\n-                                this.trait_ref_hack = None;\n-                            })\n-                        } else {\n+            }\n+            for predicate in generics.where_clause.predicates {\n+                match predicate {\n+                    &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                        ref bounded_ty,\n+                        bounds,\n+                        ref bound_generic_params,\n+                        ..\n+                    }) => {\n+                        let (lifetimes, binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) =\n+                            bound_generic_params\n+                                .iter()\n+                                .filter_map(|param| match param.kind {\n+                                    GenericParamKind::Lifetime { .. } => Some(param),\n+                                    _ => None,\n+                                })\n+                                .enumerate()\n+                                .map(|(late_bound_idx, param)| {\n+                                    let pair =\n+                                        Region::late(late_bound_idx as u32, &this.tcx.hir(), param);\n+                                    let r = late_region_as_bound_region(this.tcx, &pair.1);\n+                                    (pair, r)\n+                                })\n+                                .unzip();\n+                        this.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n+                        let next_early_index = this.next_early_index();\n+                        // Even if there are no lifetimes defined here, we still wrap it in a binder\n+                        // scope. If there happens to be a nested poly trait ref (an error), that\n+                        // will be `Concatenating` anyways, so we don't have to worry about the depth\n+                        // being wrong.\n+                        let scope = Scope::Binder {\n+                            hir_id: bounded_ty.hir_id,\n+                            lifetimes,\n+                            s: this.scope,\n+                            next_early_index,\n+                            track_lifetime_uses: true,\n+                            opaque_type_parent: false,\n+                            scope_type: BinderScopeType::Normal,\n+                        };\n+                        this.with(scope, |old_scope, this| {\n+                            this.check_lifetime_params(old_scope, &bound_generic_params);\n                             this.visit_ty(&bounded_ty);\n                             walk_list!(this, visit_param_bound, bounds);\n-                        }\n-                    })\n-                }\n-                &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                    ref lifetime,\n-                    bounds,\n-                    ..\n-                }) => {\n-                    self.visit_lifetime(lifetime);\n-                    walk_list!(self, visit_param_bound, bounds);\n-                }\n-                &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                    ref lhs_ty,\n-                    ref rhs_ty,\n-                    ..\n-                }) => {\n-                    self.visit_ty(lhs_ty);\n-                    self.visit_ty(rhs_ty);\n+                        })\n+                    }\n+                    &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                        ref lifetime,\n+                        bounds,\n+                        ..\n+                    }) => {\n+                        this.visit_lifetime(lifetime);\n+                        walk_list!(this, visit_param_bound, bounds);\n+                    }\n+                    &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n+                        ref lhs_ty,\n+                        ref rhs_ty,\n+                        ..\n+                    }) => {\n+                        this.visit_ty(lhs_ty);\n+                        this.visit_ty(rhs_ty);\n+                    }\n                 }\n             }\n-        }\n+        })\n     }\n \n     fn visit_param_bound(&mut self, bound: &'tcx hir::GenericBound<'tcx>) {\n         match bound {\n-            hir::GenericBound::LangItemTrait(_, _, hir_id, _) if self.trait_ref_hack.is_none() => {\n-                self.map.late_bound_vars.insert(*hir_id, vec![]);\n+            hir::GenericBound::LangItemTrait(_, _, hir_id, _) => {\n+                // FIXME(jackh726): This is pretty weird. `LangItemTrait` doesn't go\n+                // through the regular poly trait ref code, so we don't get another\n+                // chance to introduce a binder. For now, I'm keeping the existing logic\n+                // of \"if there isn't a Binder scope above us, add one\", but I\n+                // imagine there's a better way to go about this.\n+                let (binders, scope_type) = self.poly_trait_ref_binder_info();\n+\n+                self.map.late_bound_vars.insert(*hir_id, binders);\n                 let scope = Scope::Binder {\n                     hir_id: *hir_id,\n                     lifetimes: FxHashMap::default(),\n                     s: self.scope,\n                     next_early_index: self.next_early_index(),\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    from_poly_trait_ref: false,\n+                    scope_type,\n                 };\n                 self.with(scope, |_, this| {\n                     intravisit::walk_param_bound(this, bound);\n@@ -1388,148 +1384,53 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n         let should_pop_missing_lt = self.is_trait_ref_fn_scope(trait_ref);\n \n-        let trait_ref_hack = self.trait_ref_hack.take();\n         let next_early_index = self.next_early_index();\n-        // See note on `trait_ref_hack`. If `for<..>` has been defined in both\n-        // the outer and inner part of the trait ref, emit an error.\n-        let has_lifetimes = trait_ref.bound_generic_params.iter().any(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => true,\n-            _ => false,\n-        });\n-        if trait_ref_hack.is_some() && has_lifetimes {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                trait_ref.span,\n-                E0316,\n-                \"nested quantification of lifetimes\"\n-            )\n-            .emit();\n-        }\n-\n-        let (binders, lifetimes) = if let Some(hir_id) = trait_ref_hack {\n-            let mut binders = self.map.late_bound_vars.entry(hir_id).or_default().clone();\n-            let initial_bound_vars = binders.len() as u32;\n-            let mut lifetimes: FxHashMap<hir::ParamName, Region> = FxHashMap::default();\n-            let binders_iter = trait_ref\n-                .bound_generic_params\n-                .iter()\n-                .filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => Some(param),\n-                    _ => None,\n-                })\n-                .enumerate()\n-                .map(|(late_bound_idx, param)| {\n-                    let pair = Region::late(\n-                        initial_bound_vars + late_bound_idx as u32,\n-                        &self.tcx.hir(),\n-                        param,\n-                    );\n-                    let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                    lifetimes.insert(pair.0, pair.1);\n-                    r\n-                });\n-            binders.extend(binders_iter);\n-\n-            (binders, lifetimes)\n-        } else {\n-            let mut supertrait_lifetimes = vec![];\n-            let mut scope = self.scope;\n-            let mut outer_binders = loop {\n-                match scope {\n-                    Scope::Body { .. } | Scope::Root => {\n-                        break vec![];\n-                    }\n-\n-                    Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n-                        scope = s;\n-                    }\n-\n-                    Scope::TraitRefHackInner { hir_id, .. } => {\n-                        // Nested poly trait refs have the binders concatenated\n-                        // If we reach `TraitRefHackInner`, then there is only one more `Binder` above us,\n-                        // over all the bounds. We don't want this, since all the lifetimes we care about\n-                        // are here anyways.\n-                        let mut full_binders =\n-                            self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                        full_binders.extend(supertrait_lifetimes.into_iter());\n-                        break full_binders;\n-                    }\n-\n-                    Scope::Supertrait { s, lifetimes } => {\n-                        supertrait_lifetimes = lifetimes.clone();\n-                        scope = s;\n-                    }\n-\n-                    Scope::TraitRefBoundary { .. } => {\n-                        // We should only see super trait lifetimes if there is a `Binder` above\n-                        assert!(supertrait_lifetimes.is_empty());\n-                        break vec![];\n-                    }\n-\n-                    Scope::Binder { hir_id, from_poly_trait_ref, .. } => {\n-                        if !from_poly_trait_ref {\n-                            // We should only see super trait lifetimes if there is a `Binder` above\n-                            assert!(supertrait_lifetimes.is_empty());\n-                            break vec![];\n-                        }\n-                        // Nested poly trait refs have the binders concatenated\n-                        let mut full_binders =\n-                            self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                        full_binders.extend(supertrait_lifetimes.into_iter());\n-                        break full_binders;\n-                    }\n-                }\n-            };\n-            let (lifetimes, local_binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) = trait_ref\n-                .bound_generic_params\n-                .iter()\n-                .filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => Some(param),\n-                    _ => None,\n-                })\n-                .enumerate()\n-                .map(|(late_bound_idx, param)| {\n-                    let pair = Region::late(\n-                        outer_binders.len() as u32 + late_bound_idx as u32,\n-                        &self.tcx.hir(),\n-                        param,\n-                    );\n-                    let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                    (pair, r)\n-                })\n-                .unzip();\n-\n-            outer_binders.extend(local_binders.into_iter());\n+        let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n-            (outer_binders, lifetimes)\n-        };\n+        let initial_bound_vars = binders.len() as u32;\n+        let mut lifetimes: FxHashMap<hir::ParamName, Region> = FxHashMap::default();\n+        let binders_iter = trait_ref\n+            .bound_generic_params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => Some(param),\n+                _ => None,\n+            })\n+            .enumerate()\n+            .map(|(late_bound_idx, param)| {\n+                let pair = Region::late(\n+                    initial_bound_vars + late_bound_idx as u32,\n+                    &self.tcx.hir(),\n+                    param,\n+                );\n+                let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                lifetimes.insert(pair.0, pair.1);\n+                r\n+            });\n+        binders.extend(binders_iter);\n \n         debug!(?binders);\n         self.map.late_bound_vars.insert(trait_ref.trait_ref.hir_ref_id, binders);\n \n-        if trait_ref_hack.is_none() || has_lifetimes {\n-            let scope = Scope::Binder {\n-                hir_id: trait_ref.trait_ref.hir_ref_id,\n-                lifetimes,\n-                s: self.scope,\n-                next_early_index,\n-                track_lifetime_uses: true,\n-                opaque_type_parent: false,\n-                from_poly_trait_ref: true,\n-            };\n-            self.with(scope, |old_scope, this| {\n-                this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n-                walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n-                this.visit_trait_ref(&trait_ref.trait_ref);\n-            });\n-        } else {\n-            let scope =\n-                Scope::TraitRefHackInner { hir_id: trait_ref.trait_ref.hir_ref_id, s: self.scope };\n-            self.with(scope, |_old_scope, this| {\n-                this.visit_trait_ref(&trait_ref.trait_ref);\n-            });\n-        }\n-        self.trait_ref_hack = trait_ref_hack;\n+        // Always introduce a scope here, even if this is in a where clause and\n+        // we introduced the binders around the bounded Ty. In that case, we\n+        // just reuse the concatenation functionality also present in nested trait\n+        // refs.\n+        let scope = Scope::Binder {\n+            hir_id: trait_ref.trait_ref.hir_ref_id,\n+            lifetimes,\n+            s: self.scope,\n+            next_early_index,\n+            track_lifetime_uses: true,\n+            opaque_type_parent: false,\n+            scope_type,\n+        };\n+        self.with(scope, |old_scope, this| {\n+            this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n+            walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n+            this.visit_trait_ref(&trait_ref.trait_ref);\n+        });\n+\n         if should_pop_missing_lt {\n             self.missing_named_lifetime_spots.pop();\n         }\n@@ -1680,7 +1581,6 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n                 Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n@@ -1871,12 +1771,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let labels_in_fn = take(&mut self.labels_in_fn);\n         let xcrate_object_lifetime_defaults = take(&mut self.xcrate_object_lifetime_defaults);\n         let missing_named_lifetime_spots = take(&mut self.missing_named_lifetime_spots);\n-        let trait_ref_hack = take(&mut self.trait_ref_hack);\n         let mut this = LifetimeContext {\n             tcx: *tcx,\n             map,\n             scope: &wrap_scope,\n-            trait_ref_hack,\n             is_in_fn_syntax: self.is_in_fn_syntax,\n             is_in_const_generic: self.is_in_const_generic,\n             trait_definition_only: self.trait_definition_only,\n@@ -1896,7 +1794,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         self.labels_in_fn = this.labels_in_fn;\n         self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n         self.missing_named_lifetime_spots = this.missing_named_lifetime_spots;\n-        self.trait_ref_hack = this.trait_ref_hack;\n     }\n \n     /// helper method to determine the span to remove when suggesting the\n@@ -2265,7 +2162,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             s: self.scope,\n             opaque_type_parent: true,\n             track_lifetime_uses: false,\n-            from_poly_trait_ref: false,\n+            scope_type: BinderScopeType::Normal,\n         };\n         self.with(scope, move |old_scope, this| {\n             this.check_lifetime_params(old_scope, &generics.params);\n@@ -2289,7 +2186,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 | Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => scope = s,\n             }\n@@ -2323,7 +2219,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // given name or we run out of scopes.\n         // search.\n         let mut late_depth = 0;\n-        let mut in_poly_trait_ref = false;\n         let mut scope = self.scope;\n         let mut outermost_body = None;\n         let result = loop {\n@@ -2341,25 +2236,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n-                Scope::TraitRefBoundary { s, .. } => {\n-                    // We've exited nested poly trait refs; mark that we are no longer in nested trait refs.\n-                    // We don't increase the late depth because this isn't a `Binder` scope.\n-                    //\n-                    // This came up in #83737, which boiled down to a case like this:\n-                    //\n-                    // ```\n-                    // F: for<> Fn(&()) -> Box<dyn for<> Future<Output = ()> + Unpin>,\n-                    //                         //  ^^^^^\n-\n-                    // ```\n-                    //\n-                    // Here, as we traverse upwards from the `dyn for<>` binder, we want to reset `in_poly_trait_ref`\n-                    // to false, so that we avoid excess contaenation when we encounter the outer `for<>`  binder.\n-                    in_poly_trait_ref = false;\n-                    scope = s;\n-                }\n-\n-                Scope::Binder { ref lifetimes, from_poly_trait_ref, s, .. } => {\n+                Scope::Binder { ref lifetimes, scope_type, s, .. } => {\n                     match lifetime_ref.name {\n                         LifetimeName::Param(param_name) => {\n                             if let Some(&def) = lifetimes.get(&param_name.normalize_to_macros_2_0())\n@@ -2369,47 +2246,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n                         _ => bug!(\"expected LifetimeName::Param\"),\n                     }\n-\n-                    match (from_poly_trait_ref, in_poly_trait_ref) {\n-                        // This is the first binder we see that is a poly trait ref; add one to the\n-                        // late depth and mark that we're potentially in nested trait refs.\n-                        (true, false) => {\n-                            in_poly_trait_ref = true;\n-                            late_depth += 1;\n-                        }\n-                        // We've already seen a binder that is a poly trait ref and this one is too,\n-                        // that means that they are nested and we are concatenating the bound vars;\n-                        // don't increase the late depth.\n-                        //\n-                        // This happens specifically with associated trait bounds like the following:\n-                        //\n-                        // ```\n-                        // for<'a> T: Iterator<Item: for<'b> Foo<'a, 'b>>\n-                        // ```\n-                        //\n-                        // In this case, as we traverse `for<'b>`, we would increment `late_depth` but\n-                        // set `in_poly_trait_ref` to true. Then when we traverse `for<'a>`, we would\n-                        // not increment `late_depth` again. (NB: Niko thinks this logic is actually\n-                        // wrong.)\n-                        (true, true) => {}\n-                        // We've exited nested poly trait refs; add one to the late depth and mark\n-                        // that we are no longer in nested trait refs\n-                        (false, true) => {\n-                            in_poly_trait_ref = false;\n-                            late_depth += 1;\n-                        }\n-                        // Any other kind of nested binders: just increase late depth.\n-                        (false, false) => {\n-                            late_depth += 1;\n-                        }\n+                    match scope_type {\n+                        BinderScopeType::Normal => late_depth += 1,\n+                        BinderScopeType::Concatenating => {}\n                     }\n                     scope = s;\n                 }\n \n                 Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n-                | Scope::Supertrait { s, .. } => {\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -2562,7 +2409,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         Scope::Binder { s, .. }\n                         | Scope::Elision { s, .. }\n                         | Scope::ObjectLifetimeDefault { s, .. }\n-                        | Scope::TraitRefHackInner { s, .. }\n                         | Scope::Supertrait { s, .. }\n                         | Scope::TraitRefBoundary { s, .. } => {\n                             scope = s;\n@@ -2761,7 +2607,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut scope = &*self.scope;\n         let hir_id = loop {\n             match scope {\n-                Scope::Binder { hir_id, .. } | Scope::TraitRefHackInner { hir_id, .. } => {\n+                Scope::Binder { hir_id, .. } => {\n                     break *hir_id;\n                 }\n                 Scope::Body { id, .. } => break id.hir_id,\n@@ -3112,7 +2958,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let span = lifetime_refs[0].span;\n         let mut late_depth = 0;\n-        let mut in_poly_trait_ref = false;\n         let mut scope = self.scope;\n         let mut lifetime_names = FxHashSet::default();\n         let mut lifetime_spans = vec![];\n@@ -3123,35 +2968,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Root => break None,\n \n-                Scope::TraitRefBoundary { s, .. } => {\n-                    // We've exited nested poly trait refs; mark that we are no longer in nested trait refs.\n-                    // We don't increase the late depth because this isn't a `Binder` scope\n-                    in_poly_trait_ref = false;\n-                    scope = s;\n-                }\n-\n-                Scope::Binder { s, ref lifetimes, from_poly_trait_ref, .. } => {\n+                Scope::Binder { s, ref lifetimes, scope_type, .. } => {\n                     // collect named lifetimes for suggestions\n                     for name in lifetimes.keys() {\n                         if let hir::ParamName::Plain(name) = name {\n                             lifetime_names.insert(name.name);\n                             lifetime_spans.push(name.span);\n                         }\n                     }\n-                    // See comments in `resolve_lifetime_ref`\n-                    match (from_poly_trait_ref, in_poly_trait_ref) {\n-                        (true, false) => {\n-                            in_poly_trait_ref = true;\n-                            late_depth += 1;\n-                        }\n-                        (true, true) => {}\n-                        (false, true) => {\n-                            in_poly_trait_ref = false;\n-                            late_depth += 1;\n-                        }\n-                        (false, false) => {\n-                            late_depth += 1;\n-                        }\n+                    match scope_type {\n+                        BinderScopeType::Normal => late_depth += 1,\n+                        BinderScopeType::Concatenating => {}\n                     }\n                     scope = s;\n                 }\n@@ -3201,8 +3028,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n \n                 Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n-                | Scope::Supertrait { s, .. } => {\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -3308,31 +3135,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn resolve_object_lifetime_default(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         debug!(\"resolve_object_lifetime_default(lifetime_ref={:?})\", lifetime_ref);\n         let mut late_depth = 0;\n-        let mut in_poly_trait_ref = false;\n         let mut scope = self.scope;\n         let lifetime = loop {\n             match *scope {\n-                Scope::TraitRefBoundary { s, .. } => {\n-                    // We've exited nested poly trait refs; mark that we are no longer in nested trait refs.\n-                    // We don't increase the late depth because this isn't a `Binder` scope\n-                    in_poly_trait_ref = false;\n-                    scope = s;\n-                }\n-\n-                Scope::Binder { s, from_poly_trait_ref, .. } => {\n-                    match (from_poly_trait_ref, in_poly_trait_ref) {\n-                        (true, false) => {\n-                            in_poly_trait_ref = true;\n-                            late_depth += 1;\n-                        }\n-                        (true, true) => {}\n-                        (false, true) => {\n-                            in_poly_trait_ref = false;\n-                            late_depth += 1;\n-                        }\n-                        (false, false) => {\n-                            late_depth += 1;\n-                        }\n+                Scope::Binder { s, scope_type, .. } => {\n+                    match scope_type {\n+                        BinderScopeType::Normal => late_depth += 1,\n+                        BinderScopeType::Concatenating => {}\n                     }\n                     scope = s;\n                 }\n@@ -3343,7 +3152,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l,\n \n-                Scope::TraitRefHackInner { s, .. } | Scope::Supertrait { s, .. } => {\n+                Scope::Supertrait { s, .. } | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -3470,7 +3279,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => {\n                     old_scope = s;\n@@ -3529,7 +3337,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 } => break false,\n \n                 Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => scope = s,\n             }"}, {"sha": "ac5ec24eeeeb53eee69ab3c17a50a7a4c3efb9f5", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -439,8 +439,7 @@ fn virtual_call_violation_for_method<'tcx>(\n         return Some(MethodViolationCode::WhereClauseReferencesSelf);\n     }\n \n-    let receiver_ty =\n-        tcx.liberate_late_bound_regions(method.def_id, sig.map_bound(|sig| sig.inputs()[0]));\n+    let receiver_ty = tcx.liberate_late_bound_regions(method.def_id, sig.input(0));\n \n     // Until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n     // However, this is already considered object-safe. We allow it as a special case here."}, {"sha": "427f967a9b6bd3184a796bfdb092c989ad9f5c14", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -973,6 +973,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n         if let (Some(a_sig), Some(b_sig)) = (a_sig, b_sig) {\n+            // Intrinsics are not coercible to function pointers.\n+            if a_sig.abi() == Abi::RustIntrinsic\n+                || a_sig.abi() == Abi::PlatformIntrinsic\n+                || b_sig.abi() == Abi::RustIntrinsic\n+                || b_sig.abi() == Abi::PlatformIntrinsic\n+            {\n+                return Err(TypeError::IntrinsicCast);\n+            }\n             // The signature must match.\n             let a_sig = self.normalize_associated_types_in(new.span, a_sig);\n             let b_sig = self.normalize_associated_types_in(new.span, b_sig);"}, {"sha": "5fa092af1da020a2055865407587199d5e1651a7", "filename": "library/std/src/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fenv.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -799,7 +799,7 @@ impl DoubleEndedIterator for Args {\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Args {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Args\").field(\"inner\", &self.inner.inner.inner_debug()).finish()\n+        f.debug_struct(\"Args\").field(\"inner\", &self.inner.inner).finish()\n     }\n }\n \n@@ -840,7 +840,7 @@ impl DoubleEndedIterator for ArgsOs {\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for ArgsOs {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"ArgsOs\").field(\"inner\", &self.inner.inner_debug()).finish()\n+        f.debug_struct(\"ArgsOs\").field(\"inner\", &self.inner).finish()\n     }\n }\n "}, {"sha": "4794f89a5aee327da89f538ce3d5bb4634379e83", "filename": "library/std/src/sys/hermit/args.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -1,4 +1,5 @@\n use crate::ffi::OsString;\n+use crate::fmt;\n use crate::marker::PhantomData;\n use crate::vec;\n \n@@ -22,9 +23,9 @@ pub struct Args {\n     _dont_send_or_sync_me: PhantomData<*mut ()>,\n }\n \n-impl Args {\n-    pub fn inner_debug(&self) -> &[OsString] {\n-        self.iter.as_slice()\n+impl fmt::Debug for Args {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.iter.as_slice().fmt(f)\n     }\n }\n "}, {"sha": "463188ad7c0c33c347661f694373c85bd0592d42", "filename": "library/std/src/sys/sgx/args.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fargs.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -1,5 +1,6 @@\n use super::abi::usercalls::{alloc, raw::ByteBuffer};\n use crate::ffi::OsString;\n+use crate::fmt;\n use crate::slice;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::os_str::Buf;\n@@ -31,9 +32,9 @@ pub fn args() -> Args {\n \n pub struct Args(slice::Iter<'static, OsString>);\n \n-impl Args {\n-    pub fn inner_debug(&self) -> &[OsString] {\n-        self.0.as_slice()\n+impl fmt::Debug for Args {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.as_slice().fmt(f)\n     }\n }\n "}, {"sha": "cba0627e93a8504823e10c6fda1e7b1b18ff8ea7", "filename": "library/std/src/sys/unix/args.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -6,6 +6,7 @@\n #![allow(dead_code)] // runtime init functions not used during testing\n \n use crate::ffi::OsString;\n+use crate::fmt;\n use crate::marker::PhantomData;\n use crate::vec;\n \n@@ -29,9 +30,9 @@ pub struct Args {\n     _dont_send_or_sync_me: PhantomData<*mut ()>,\n }\n \n-impl Args {\n-    pub fn inner_debug(&self) -> &[OsString] {\n-        self.iter.as_slice()\n+impl fmt::Debug for Args {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.iter.as_slice().fmt(f)\n     }\n }\n "}, {"sha": "503ba410097c8a503f3d17a8de1a2d357fa93f1f", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -21,8 +21,8 @@ use crate::slice;\n use crate::str;\n use crate::sys::cvt;\n use crate::sys::fd;\n+use crate::sys::rwlock::{RWLockReadGuard, StaticRWLock};\n use crate::sys_common::mutex::{StaticMutex, StaticMutexGuard};\n-use crate::sys_common::rwlock::{RWLockReadGuard, StaticRWLock};\n use crate::vec;\n \n use libc::{c_char, c_int, c_void};"}, {"sha": "d97d9d712fc93a383450b3f270fb5bdfb5a662e7", "filename": "library/std/src/sys/unix/rwlock.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frwlock.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -139,3 +139,55 @@ impl RWLock {\n         }\n     }\n }\n+\n+pub struct StaticRWLock(RWLock);\n+\n+impl StaticRWLock {\n+    pub const fn new() -> StaticRWLock {\n+        StaticRWLock(RWLock::new())\n+    }\n+\n+    /// Acquires shared access to the underlying lock, blocking the current\n+    /// thread to do so.\n+    ///\n+    /// The lock is automatically unlocked when the returned guard is dropped.\n+    #[inline]\n+    pub fn read_with_guard(&'static self) -> RWLockReadGuard {\n+        // SAFETY: All methods require static references, therefore self\n+        // cannot be moved between invocations.\n+        unsafe {\n+            self.0.read();\n+        }\n+        RWLockReadGuard(&self.0)\n+    }\n+\n+    /// Acquires write access to the underlying lock, blocking the current thread\n+    /// to do so.\n+    ///\n+    /// The lock is automatically unlocked when the returned guard is dropped.\n+    #[inline]\n+    pub fn write_with_guard(&'static self) -> RWLockWriteGuard {\n+        // SAFETY: All methods require static references, therefore self\n+        // cannot be moved between invocations.\n+        unsafe {\n+            self.0.write();\n+        }\n+        RWLockWriteGuard(&self.0)\n+    }\n+}\n+\n+pub struct RWLockReadGuard(&'static RWLock);\n+\n+impl Drop for RWLockReadGuard {\n+    fn drop(&mut self) {\n+        unsafe { self.0.read_unlock() }\n+    }\n+}\n+\n+pub struct RWLockWriteGuard(&'static RWLock);\n+\n+impl Drop for RWLockWriteGuard {\n+    fn drop(&mut self) {\n+        unsafe { self.0.write_unlock() }\n+    }\n+}"}, {"sha": "360bb65af69535e234a3a15c526ce58fa7f65d4d", "filename": "library/std/src/sys/unsupported/args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fargs.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -9,9 +9,9 @@ pub fn args() -> Args {\n     Args {}\n }\n \n-impl Args {\n-    pub fn inner_debug(&self) -> &[OsString] {\n-        &[]\n+impl fmt::Debug for Args {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list().finish()\n     }\n }\n "}, {"sha": "86405dede4277f609a92228e7a7a1bf9fe70f958", "filename": "library/std/src/sys/wasi/args.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fargs.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -1,6 +1,7 @@\n #![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::ffi::{CStr, OsStr, OsString};\n+use crate::fmt;\n use crate::marker::PhantomData;\n use crate::os::wasi::ffi::OsStrExt;\n use crate::vec;\n@@ -38,9 +39,9 @@ fn maybe_args() -> Option<Vec<OsString>> {\n     }\n }\n \n-impl Args {\n-    pub fn inner_debug(&self) -> &[OsString] {\n-        self.iter.as_slice()\n+impl fmt::Debug for Args {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.iter.as_slice().fmt(f)\n     }\n }\n "}, {"sha": "99d300b53b3b91b56aa28412f8ad99364e1980cd", "filename": "library/std/src/sys/wasm/args.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fargs.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -1,4 +1,5 @@\n use crate::ffi::OsString;\n+use crate::fmt;\n use crate::marker::PhantomData;\n use crate::vec;\n \n@@ -17,9 +18,9 @@ pub struct Args {\n     _dont_send_or_sync_me: PhantomData<*mut ()>,\n }\n \n-impl Args {\n-    pub fn inner_debug(&self) -> &[OsString] {\n-        self.iter.as_slice()\n+impl fmt::Debug for Args {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.iter.as_slice().fmt(f)\n     }\n }\n "}, {"sha": "31197e4accc6d13730dea0e82b93ef9e18b993ad", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -164,19 +164,9 @@ pub struct Args {\n     parsed_args_list: vec::IntoIter<OsString>,\n }\n \n-pub struct ArgsInnerDebug<'a> {\n-    args: &'a Args,\n-}\n-\n-impl<'a> fmt::Debug for ArgsInnerDebug<'a> {\n+impl fmt::Debug for Args {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.args.parsed_args_list.as_slice().fmt(f)\n-    }\n-}\n-\n-impl Args {\n-    pub fn inner_debug(&self) -> ArgsInnerDebug<'_> {\n-        ArgsInnerDebug { args: self }\n+        self.parsed_args_list.as_slice().fmt(f)\n     }\n }\n "}, {"sha": "3705d641a1be646ab38436b8aaed032a6ef3e312", "filename": "library/std/src/sys_common/rwlock.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -86,62 +86,3 @@ impl RWLock {\n         self.0.destroy()\n     }\n }\n-\n-// the cfg annotations only exist due to dead code warnings. the code itself is portable\n-#[cfg(unix)]\n-pub struct StaticRWLock(RWLock);\n-\n-#[cfg(unix)]\n-impl StaticRWLock {\n-    pub const fn new() -> StaticRWLock {\n-        StaticRWLock(RWLock::new())\n-    }\n-\n-    /// Acquires shared access to the underlying lock, blocking the current\n-    /// thread to do so.\n-    ///\n-    /// The lock is automatically unlocked when the returned guard is dropped.\n-    #[inline]\n-    pub fn read_with_guard(&'static self) -> RWLockReadGuard {\n-        // SAFETY: All methods require static references, therefore self\n-        // cannot be moved between invocations.\n-        unsafe {\n-            self.0.read();\n-        }\n-        RWLockReadGuard(&self.0)\n-    }\n-\n-    /// Acquires write access to the underlying lock, blocking the current thread\n-    /// to do so.\n-    ///\n-    /// The lock is automatically unlocked when the returned guard is dropped.\n-    #[inline]\n-    pub fn write_with_guard(&'static self) -> RWLockWriteGuard {\n-        // SAFETY: All methods require static references, therefore self\n-        // cannot be moved between invocations.\n-        unsafe {\n-            self.0.write();\n-        }\n-        RWLockWriteGuard(&self.0)\n-    }\n-}\n-\n-#[cfg(unix)]\n-pub struct RWLockReadGuard(&'static RWLock);\n-\n-#[cfg(unix)]\n-impl Drop for RWLockReadGuard {\n-    fn drop(&mut self) {\n-        unsafe { self.0.read_unlock() }\n-    }\n-}\n-\n-#[cfg(unix)]\n-pub struct RWLockWriteGuard(&'static RWLock);\n-\n-#[cfg(unix)]\n-impl Drop for RWLockWriteGuard {\n-    fn drop(&mut self) {\n-        unsafe { self.0.write_unlock() }\n-    }\n-}"}, {"sha": "213ca9ec9e3ea5a14faf30a4540a64e589af64b6", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -116,6 +116,8 @@ h4:not(.method):not(.type):not(.tymethod):not(.associatedconstant) {\n \tpadding-bottom: 6px;\n }\n h1.fqn {\n+\tdisplay: flex;\n+\twidth: 100%;\n \tborder-bottom: 1px dashed;\n \tmargin-top: 0;\n }\n@@ -458,6 +460,13 @@ nav.sub {\n \tfont-weight: normal;\n }\n \n+h1.fqn > .out-of-band {\n+\tfloat: unset;\n+\tflex: 1;\n+\ttext-align: right;\n+\tmargin-left: 8px;\n+}\n+\n h3.impl > .out-of-band {\n \tfont-size: 21px;\n }\n@@ -1450,10 +1459,6 @@ h4 > .notable-traits {\n \t\tpadding: 0;\n \t}\n \n-\t.content .in-band {\n-\t\twidth: 100%;\n-\t}\n-\n \t.content h4 > .out-of-band {\n \t\tposition: inherit;\n \t}"}, {"sha": "0ed6038a318e34e3d76a9e55bdebc4cfd17f902a", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -1 +1 @@\n-Subproject commit ea6bb2615f04d53db11b6a43a14be5c9d1eaebe1\n+Subproject commit 0ed6038a318e34e3d76a9e55bdebc4cfd17f902a"}, {"sha": "05535b92cca73eca6c261557bf57402aad41a551", "filename": "src/test/ui/reify-intrinsic.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/src%2Ftest%2Fui%2Freify-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/src%2Ftest%2Fui%2Freify-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freify-intrinsic.rs?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -12,4 +12,12 @@ fn b() {\n     //~^ ERROR casting\n }\n \n+fn c() {\n+    let _ = [\n+        std::intrinsics::copy_nonoverlapping::<i32>,\n+        std::intrinsics::copy::<i32>,\n+        //~^ ERROR cannot coerce\n+    ];\n+}\n+\n fn main() {}"}, {"sha": "5d82fdbd31190bfdecbe4f57f95c87bfdd4e07ca", "filename": "src/test/ui/reify-intrinsic.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f1aeb52c22e3784928765e34be6dc0d17a350b4/src%2Ftest%2Fui%2Freify-intrinsic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f1aeb52c22e3784928765e34be6dc0d17a350b4/src%2Ftest%2Fui%2Freify-intrinsic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freify-intrinsic.stderr?ref=5f1aeb52c22e3784928765e34be6dc0d17a350b4", "patch": "@@ -19,7 +19,16 @@ error[E0606]: casting `unsafe extern \"rust-intrinsic\" fn(_) -> _ {transmute::<_,\n LL |     let _ = std::mem::transmute as unsafe extern \"rust-intrinsic\" fn(isize) -> usize;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error[E0308]: cannot coerce intrinsics to function pointers\n+  --> $DIR/reify-intrinsic.rs:18:9\n+   |\n+LL |         std::intrinsics::copy::<i32>,\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot coerce intrinsics to function pointers\n+   |\n+   = note: expected type `unsafe extern \"rust-intrinsic\" fn(_, _, _) {copy_nonoverlapping::<i32>}`\n+           found fn item `unsafe extern \"rust-intrinsic\" fn(_, _, _) {std::intrinsics::copy::<i32>}`\n+\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0308, E0606.\n For more information about an error, try `rustc --explain E0308`."}]}