{"sha": "a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "node_id": "C_kwDOAAsO6NoAKGE5ZWI5YzUyZjNlOGQ4YjY0MDJlNmFjYzY5YjliY2ZjNGYzNzFkNTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-30T03:50:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-30T03:50:35Z"}, "message": "Auto merge of #98649 - RalfJung:guardians-of-mir, r=oli-obk\n\nmove MIR syntax into a dedicated file and ping some people whenever it changes\n\nAdding or changing MIR operations/statements/whatever should be under significant scrutiny wrt their wider impact, specified semantics, and so on. So let's start by putting all that into a dedicated file and pinging some people whenever that file changes.\n\nThis PR only moves definitions around, and then fiddles with imports until it all works again.", "tree": {"sha": "ccef84a7db1aca346d0f29ae094da63d6440faee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccef84a7db1aca346d0f29ae094da63d6440faee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "html_url": "https://github.com/rust-lang/rust/commit/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d3c6d6c83edc4ef245e77397c8e32d3ee453b67", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d3c6d6c83edc4ef245e77397c8e32d3ee453b67", "html_url": "https://github.com/rust-lang/rust/commit/5d3c6d6c83edc4ef245e77397c8e32d3ee453b67"}, {"sha": "6c990f48af3dfacee975aef6c879c1ca20219c68", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c990f48af3dfacee975aef6c879c1ca20219c68", "html_url": "https://github.com/rust-lang/rust/commit/6c990f48af3dfacee975aef6c879c1ca20219c68"}], "stats": {"total": 2336, "additions": 1187, "deletions": 1149}, "files": [{"sha": "ad33a54e0a2d1d4480c95d5fde033fc1d0e3c679", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 35, "deletions": 877, "changes": 912, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -2,18 +2,17 @@\n //!\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n-use crate::mir::coverage::{CodeRegion, CoverageKind};\n use crate::mir::interpret::{\n     AllocRange, ConstAllocation, ConstValue, GlobalAlloc, LitToConstInput, Scalar,\n };\n+use crate::mir::traversal::PostorderCache;\n use crate::mir::visit::MirVisitable;\n-use crate::ty::adjustment::PointerCast;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::{self, List, Ty, TyCtxt};\n-use crate::ty::{AdtDef, InstanceDef, Region, ScalarInt, UserTypeAnnotationIndex};\n+use crate::ty::{AdtDef, InstanceDef, ScalarInt, UserTypeAnnotationIndex};\n \n use rustc_data_structures::captures::Captures;\n use rustc_errors::ErrorGuaranteed;\n@@ -34,16 +33,14 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n-use rustc_target::asm::InlineAsmRegOrRegClass;\n \n use either::Either;\n \n use std::borrow::Cow;\n use std::convert::TryInto;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n use std::ops::{ControlFlow, Index, IndexMut};\n-use std::slice;\n-use std::{iter, mem, option};\n+use std::{iter, mem};\n \n use self::graph_cyclic_cache::GraphIsCyclicCache;\n use self::predecessors::{PredecessorCache, Predecessors};\n@@ -62,10 +59,11 @@ mod predecessors;\n pub mod pretty;\n mod query;\n pub mod spanview;\n+mod syntax;\n+pub use syntax::*;\n mod switch_sources;\n pub mod tcx;\n-pub mod terminator;\n-use crate::mir::traversal::PostorderCache;\n+mod terminator;\n pub use terminator::*;\n \n pub mod traversal;\n@@ -129,77 +127,6 @@ pub trait MirPass<'tcx> {\n     }\n }\n \n-/// The various \"big phases\" that MIR goes through.\n-///\n-/// These phases all describe dialects of MIR. Since all MIR uses the same datastructures, the\n-/// dialects forbid certain variants or values in certain phases. The sections below summarize the\n-/// changes, but do not document them thoroughly. The full documentation is found in the appropriate\n-/// documentation for the thing the change is affecting.\n-///\n-/// Warning: ordering of variants is significant.\n-#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n-#[derive(HashStable)]\n-pub enum MirPhase {\n-    /// The dialect of MIR used during all phases before `DropsLowered` is the same. This is also\n-    /// the MIR that analysis such as borrowck uses.\n-    ///\n-    /// One important thing to remember about the behavior of this section of MIR is that drop terminators\n-    /// (including drop and replace) are *conditional*. The elaborate drops pass will then replace each\n-    /// instance of a drop terminator with a nop, an unconditional drop, or a drop conditioned on a drop\n-    /// flag. Of course, this means that it is important that the drop elaboration can accurately recognize\n-    /// when things are initialized and when things are de-initialized. That means any code running on this\n-    /// version of MIR must be sure to produce output that drop elaboration can reason about. See the\n-    /// section on the drop terminatorss for more details.\n-    Built = 0,\n-    // FIXME(oli-obk): it's unclear whether we still need this phase (and its corresponding query).\n-    // We used to have this for pre-miri MIR based const eval.\n-    Const = 1,\n-    /// This phase checks the MIR for promotable elements and takes them out of the main MIR body\n-    /// by creating a new MIR body per promoted element. After this phase (and thus the termination\n-    /// of the `mir_promoted` query), these promoted elements are available in the `promoted_mir`\n-    /// query.\n-    ConstsPromoted = 2,\n-    /// Beginning with this phase, the following variants are disallowed:\n-    /// * [`TerminatorKind::DropAndReplace`](terminator::TerminatorKind::DropAndReplace)\n-    /// * [`TerminatorKind::FalseUnwind`](terminator::TerminatorKind::FalseUnwind)\n-    /// * [`TerminatorKind::FalseEdge`](terminator::TerminatorKind::FalseEdge)\n-    /// * [`StatementKind::FakeRead`]\n-    /// * [`StatementKind::AscribeUserType`]\n-    /// * [`Rvalue::Ref`] with `BorrowKind::Shallow`\n-    ///\n-    /// And the following variant is allowed:\n-    /// * [`StatementKind::Retag`]\n-    ///\n-    /// Furthermore, `Drop` now uses explicit drop flags visible in the MIR and reaching a `Drop`\n-    /// terminator means that the auto-generated drop glue will be invoked. Also, `Copy` operands\n-    /// are allowed for non-`Copy` types.\n-    DropsLowered = 3,\n-    /// After this projections may only contain deref projections as the first element.\n-    Derefered = 4,\n-    /// Beginning with this phase, the following variant is disallowed:\n-    /// * [`Rvalue::Aggregate`] for any `AggregateKind` except `Array`\n-    ///\n-    /// And the following variant is allowed:\n-    /// * [`StatementKind::SetDiscriminant`]\n-    Deaggregated = 5,\n-    /// Before this phase, generators are in the \"source code\" form, featuring `yield` statements\n-    /// and such. With this phase change, they are transformed into a proper state machine. Running\n-    /// optimizations before this change can be potentially dangerous because the source code is to\n-    /// some extent a \"lie.\" In particular, `yield` terminators effectively make the value of all\n-    /// locals visible to the caller. This means that dead store elimination before them, or code\n-    /// motion across them, is not correct in general. This is also exasperated by type checking\n-    /// having pre-computed a list of the types that it thinks are ok to be live across a yield\n-    /// point - this is necessary to decide eg whether autotraits are implemented. Introducing new\n-    /// types across a yield point will lead to ICEs becaues of this.\n-    ///\n-    /// Beginning with this phase, the following variants are disallowed:\n-    /// * [`TerminatorKind::Yield`](terminator::TerminatorKind::Yield)\n-    /// * [`TerminatorKind::GeneratorDrop`](terminator::TerminatorKind::GeneratorDrop)\n-    /// * [`ProjectionElem::Deref`] of `Box`\n-    GeneratorsLowered = 6,\n-    Optimized = 7,\n-}\n-\n impl MirPhase {\n     /// Gets the index of the current MirPhase within the set of all `MirPhase`s.\n     pub fn phase_index(&self) -> usize {\n@@ -731,102 +658,6 @@ impl SourceInfo {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Borrow kinds\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n-#[derive(Hash, HashStable)]\n-pub enum BorrowKind {\n-    /// Data must be immutable and is aliasable.\n-    Shared,\n-\n-    /// The immediately borrowed place must be immutable, but projections from\n-    /// it don't need to be. For example, a shallow borrow of `a.b` doesn't\n-    /// conflict with a mutable borrow of `a.b.c`.\n-    ///\n-    /// This is used when lowering matches: when matching on a place we want to\n-    /// ensure that place have the same value from the start of the match until\n-    /// an arm is selected. This prevents this code from compiling:\n-    /// ```compile_fail,E0510\n-    /// let mut x = &Some(0);\n-    /// match *x {\n-    ///     None => (),\n-    ///     Some(_) if { x = &None; false } => (),\n-    ///     Some(_) => (),\n-    /// }\n-    /// ```\n-    /// This can't be a shared borrow because mutably borrowing (*x as Some).0\n-    /// should not prevent `if let None = x { ... }`, for example, because the\n-    /// mutating `(*x as Some).0` can't affect the discriminant of `x`.\n-    /// We can also report errors with this kind of borrow differently.\n-    Shallow,\n-\n-    /// Data must be immutable but not aliasable. This kind of borrow\n-    /// cannot currently be expressed by the user and is used only in\n-    /// implicit closure bindings. It is needed when the closure is\n-    /// borrowing or mutating a mutable referent, e.g.:\n-    /// ```\n-    /// let mut z = 3;\n-    /// let x: &mut isize = &mut z;\n-    /// let y = || *x += 5;\n-    /// ```\n-    /// If we were to try to translate this closure into a more explicit\n-    /// form, we'd encounter an error with the code as written:\n-    /// ```compile_fail,E0594\n-    /// struct Env<'a> { x: &'a &'a mut isize }\n-    /// let mut z = 3;\n-    /// let x: &mut isize = &mut z;\n-    /// let y = (&mut Env { x: &x }, fn_ptr);  // Closure is pair of env and fn\n-    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n-    /// ```\n-    /// This is then illegal because you cannot mutate an `&mut` found\n-    /// in an aliasable location. To solve, you'd have to translate with\n-    /// an `&mut` borrow:\n-    /// ```compile_fail,E0596\n-    /// struct Env<'a> { x: &'a mut &'a mut isize }\n-    /// let mut z = 3;\n-    /// let x: &mut isize = &mut z;\n-    /// let y = (&mut Env { x: &mut x }, fn_ptr); // changed from &x to &mut x\n-    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n-    /// ```\n-    /// Now the assignment to `**env.x` is legal, but creating a\n-    /// mutable pointer to `x` is not because `x` is not mutable. We\n-    /// could fix this by declaring `x` as `let mut x`. This is ok in\n-    /// user code, if awkward, but extra weird for closures, since the\n-    /// borrow is hidden.\n-    ///\n-    /// So we introduce a \"unique imm\" borrow -- the referent is\n-    /// immutable, but not aliasable. This solves the problem. For\n-    /// simplicity, we don't give users the way to express this\n-    /// borrow, it's just used when translating closures.\n-    Unique,\n-\n-    /// Data is mutable and not aliasable.\n-    Mut {\n-        /// `true` if this borrow arose from method-call auto-ref\n-        /// (i.e., `adjustment::Adjust::Borrow`).\n-        allow_two_phase_borrow: bool,\n-    },\n-}\n-\n-impl BorrowKind {\n-    pub fn allows_two_phase_borrow(&self) -> bool {\n-        match *self {\n-            BorrowKind::Shared | BorrowKind::Shallow | BorrowKind::Unique => false,\n-            BorrowKind::Mut { allow_two_phase_borrow } => allow_two_phase_borrow,\n-        }\n-    }\n-\n-    pub fn describe_mutability(&self) -> String {\n-        match *self {\n-            BorrowKind::Shared | BorrowKind::Shallow | BorrowKind::Unique => {\n-                \"immutable\".to_string()\n-            }\n-            BorrowKind::Mut { .. } => \"mutable\".to_string(),\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Variables and temps\n \n@@ -1295,7 +1126,7 @@ impl BasicBlock {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// BasicBlockData and Terminator\n+// BasicBlockData\n \n /// See [`BasicBlock`] for documentation on what basic blocks are at a high level.\n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n@@ -1320,53 +1151,6 @@ pub struct BasicBlockData<'tcx> {\n     pub is_cleanup: bool,\n }\n \n-/// Information about an assertion failure.\n-#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, PartialOrd)]\n-pub enum AssertKind<O> {\n-    BoundsCheck { len: O, index: O },\n-    Overflow(BinOp, O, O),\n-    OverflowNeg(O),\n-    DivisionByZero(O),\n-    RemainderByZero(O),\n-    ResumedAfterReturn(GeneratorKind),\n-    ResumedAfterPanic(GeneratorKind),\n-}\n-\n-#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n-pub enum InlineAsmOperand<'tcx> {\n-    In {\n-        reg: InlineAsmRegOrRegClass,\n-        value: Operand<'tcx>,\n-    },\n-    Out {\n-        reg: InlineAsmRegOrRegClass,\n-        late: bool,\n-        place: Option<Place<'tcx>>,\n-    },\n-    InOut {\n-        reg: InlineAsmRegOrRegClass,\n-        late: bool,\n-        in_value: Operand<'tcx>,\n-        out_place: Option<Place<'tcx>>,\n-    },\n-    Const {\n-        value: Box<Constant<'tcx>>,\n-    },\n-    SymFn {\n-        value: Box<Constant<'tcx>>,\n-    },\n-    SymStatic {\n-        def_id: DefId,\n-    },\n-}\n-\n-/// Type for MIR `Assert` terminator error messages.\n-pub type AssertMessage<'tcx> = AssertKind<Operand<'tcx>>;\n-\n-pub type Successors<'a> = impl Iterator<Item = BasicBlock> + 'a;\n-pub type SuccessorsMut<'a> =\n-    iter::Chain<option::IntoIter<&'a mut BasicBlock>, slice::IterMut<'a, BasicBlock>>;\n-\n impl<'tcx> BasicBlockData<'tcx> {\n     pub fn new(terminator: Option<Terminator<'tcx>>) -> BasicBlockData<'tcx> {\n         BasicBlockData { statements: vec![], terminator, is_cleanup: false }\n@@ -1609,223 +1393,6 @@ impl Statement<'_> {\n     }\n }\n \n-/// The various kinds of statements that can appear in MIR.\n-///\n-/// Not all of these are allowed at every [`MirPhase`]. Check the documentation there to see which\n-/// ones you do not have to worry about. The MIR validator will generally enforce such restrictions,\n-/// causing an ICE if they are violated.\n-#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n-pub enum StatementKind<'tcx> {\n-    /// Assign statements roughly correspond to an assignment in Rust proper (`x = ...`) except\n-    /// without the possibility of dropping the previous value (that must be done separately, if at\n-    /// all). The *exact* way this works is undecided. It probably does something like evaluating\n-    /// the LHS to a place and the RHS to a value, and then storing the value to the place. Various\n-    /// parts of this may do type specific things that are more complicated than simply copying\n-    /// bytes.\n-    ///\n-    /// **Needs clarification**: The implication of the above idea would be that assignment implies\n-    /// that the resulting value is initialized. I believe we could commit to this separately from\n-    /// committing to whatever part of the memory model we would need to decide on to make the above\n-    /// paragragh precise. Do we want to?\n-    ///\n-    /// Assignments in which the types of the place and rvalue differ are not well-formed.\n-    ///\n-    /// **Needs clarification**: Do we ever want to worry about non-free (in the body) lifetimes for\n-    /// the typing requirement in post drop-elaboration MIR? I think probably not - I'm not sure we\n-    /// could meaningfully require this anyway. How about free lifetimes? Is ignoring this\n-    /// interesting for optimizations? Do we want to allow such optimizations?\n-    ///\n-    /// **Needs clarification**: We currently require that the LHS place not overlap with any place\n-    /// read as part of computation of the RHS for some rvalues (generally those not producing\n-    /// primitives). This requirement is under discussion in [#68364]. As a part of this discussion,\n-    /// it is also unclear in what order the components are evaluated.\n-    ///\n-    /// [#68364]: https://github.com/rust-lang/rust/issues/68364\n-    ///\n-    /// See [`Rvalue`] documentation for details on each of those.\n-    Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n-\n-    /// This represents all the reading that a pattern match may do (e.g., inspecting constants and\n-    /// discriminant values), and the kind of pattern it comes from. This is in order to adapt\n-    /// potential error messages to these specific patterns.\n-    ///\n-    /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n-    /// never accessed still get some sanity checks for, e.g., `let x: ! = ..;`\n-    ///\n-    /// When executed at runtime this is a nop.\n-    ///\n-    /// Disallowed after drop elaboration.\n-    FakeRead(Box<(FakeReadCause, Place<'tcx>)>),\n-\n-    /// Write the discriminant for a variant to the enum Place.\n-    ///\n-    /// This is permitted for both generators and ADTs. This does not necessarily write to the\n-    /// entire place; instead, it writes to the minimum set of bytes as required by the layout for\n-    /// the type.\n-    SetDiscriminant { place: Box<Place<'tcx>>, variant_index: VariantIdx },\n-\n-    /// Deinitializes the place.\n-    ///\n-    /// This writes `uninit` bytes to the entire place.\n-    Deinit(Box<Place<'tcx>>),\n-\n-    /// `StorageLive` and `StorageDead` statements mark the live range of a local.\n-    ///\n-    /// Using a local before a `StorageLive` or after a `StorageDead` is not well-formed. These\n-    /// statements are not required. If the entire MIR body contains no `StorageLive`/`StorageDead`\n-    /// statements for a particular local, the local is always considered live.\n-    ///\n-    /// More precisely, the MIR validator currently does a `MaybeStorageLiveLocals` analysis to\n-    /// check validity of each use of a local. I believe this is equivalent to requiring for every\n-    /// use of a local, there exist at least one path from the root to that use that contains a\n-    /// `StorageLive` more recently than a `StorageDead`.\n-    ///\n-    /// **Needs clarification**: Is it permitted to have two `StorageLive`s without an intervening\n-    /// `StorageDead`? Two `StorageDead`s without an intervening `StorageLive`? LLVM says poison,\n-    /// yes. If the answer to any of these is \"no,\" is breaking that rule UB or is it an error to\n-    /// have a path in the CFG that might do this?\n-    StorageLive(Local),\n-\n-    /// See `StorageLive` above.\n-    StorageDead(Local),\n-\n-    /// Retag references in the given place, ensuring they got fresh tags.\n-    ///\n-    /// This is part of the Stacked Borrows model. These statements are currently only interpreted\n-    /// by miri and only generated when `-Z mir-emit-retag` is passed. See\n-    /// <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/> for\n-    /// more details.\n-    ///\n-    /// For code that is not specific to stacked borrows, you should consider retags to read\n-    /// and modify the place in an opaque way.\n-    Retag(RetagKind, Box<Place<'tcx>>),\n-\n-    /// Encodes a user's type ascription. These need to be preserved\n-    /// intact so that NLL can respect them. For example:\n-    /// ```ignore (illustrative)\n-    /// let a: T = y;\n-    /// ```\n-    /// The effect of this annotation is to relate the type `T_y` of the place `y`\n-    /// to the user-given type `T`. The effect depends on the specified variance:\n-    ///\n-    /// - `Covariant` -- requires that `T_y <: T`\n-    /// - `Contravariant` -- requires that `T_y :> T`\n-    /// - `Invariant` -- requires that `T_y == T`\n-    /// - `Bivariant` -- no effect\n-    ///\n-    /// When executed at runtime this is a nop.\n-    ///\n-    /// Disallowed after drop elaboration.\n-    AscribeUserType(Box<(Place<'tcx>, UserTypeProjection)>, ty::Variance),\n-\n-    /// Marks the start of a \"coverage region\", injected with '-Cinstrument-coverage'. A\n-    /// `Coverage` statement carries metadata about the coverage region, used to inject a coverage\n-    /// map into the binary. If `Coverage::kind` is a `Counter`, the statement also generates\n-    /// executable code, to increment a counter variable at runtime, each time the code region is\n-    /// executed.\n-    Coverage(Box<Coverage>),\n-\n-    /// Denotes a call to the intrinsic function `copy_nonoverlapping`.\n-    ///\n-    /// First, all three operands are evaluated. `src` and `dest` must each be a reference, pointer,\n-    /// or `Box` pointing to the same type `T`. `count` must evaluate to a `usize`. Then, `src` and\n-    /// `dest` are dereferenced, and `count * size_of::<T>()` bytes beginning with the first byte of\n-    /// the `src` place are copied to the continguous range of bytes beginning with the first byte\n-    /// of `dest`.\n-    ///\n-    /// **Needs clarification**: In what order are operands computed and dereferenced? It should\n-    /// probably match the order for assignment, but that is also undecided.\n-    ///\n-    /// **Needs clarification**: Is this typed or not, ie is there a typed load and store involved?\n-    /// I vaguely remember Ralf saying somewhere that he thought it should not be.\n-    CopyNonOverlapping(Box<CopyNonOverlapping<'tcx>>),\n-\n-    /// No-op. Useful for deleting instructions without affecting statement indices.\n-    Nop,\n-}\n-\n-impl<'tcx> StatementKind<'tcx> {\n-    pub fn as_assign_mut(&mut self) -> Option<&mut (Place<'tcx>, Rvalue<'tcx>)> {\n-        match self {\n-            StatementKind::Assign(x) => Some(x),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_assign(&self) -> Option<&(Place<'tcx>, Rvalue<'tcx>)> {\n-        match self {\n-            StatementKind::Assign(x) => Some(x),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-/// Describes what kind of retag is to be performed.\n-#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, Hash, HashStable)]\n-pub enum RetagKind {\n-    /// The initial retag when entering a function.\n-    FnEntry,\n-    /// Retag preparing for a two-phase borrow.\n-    TwoPhase,\n-    /// Retagging raw pointers.\n-    Raw,\n-    /// A \"normal\" retag.\n-    Default,\n-}\n-\n-/// The `FakeReadCause` describes the type of pattern why a FakeRead statement exists.\n-#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, Hash, HashStable, PartialEq)]\n-pub enum FakeReadCause {\n-    /// Inject a fake read of the borrowed input at the end of each guards\n-    /// code.\n-    ///\n-    /// This should ensure that you cannot change the variant for an enum while\n-    /// you are in the midst of matching on it.\n-    ForMatchGuard,\n-\n-    /// `let x: !; match x {}` doesn't generate any read of x so we need to\n-    /// generate a read of x to check that it is initialized and safe.\n-    ///\n-    /// If a closure pattern matches a Place starting with an Upvar, then we introduce a\n-    /// FakeRead for that Place outside the closure, in such a case this option would be\n-    /// Some(closure_def_id).\n-    /// Otherwise, the value of the optional DefId will be None.\n-    ForMatchedPlace(Option<DefId>),\n-\n-    /// A fake read of the RefWithinGuard version of a bind-by-value variable\n-    /// in a match guard to ensure that its value hasn't change by the time\n-    /// we create the OutsideGuard version.\n-    ForGuardBinding,\n-\n-    /// Officially, the semantics of\n-    ///\n-    /// `let pattern = <expr>;`\n-    ///\n-    /// is that `<expr>` is evaluated into a temporary and then this temporary is\n-    /// into the pattern.\n-    ///\n-    /// However, if we see the simple pattern `let var = <expr>`, we optimize this to\n-    /// evaluate `<expr>` directly into the variable `var`. This is mostly unobservable,\n-    /// but in some cases it can affect the borrow checker, as in #53695.\n-    /// Therefore, we insert a \"fake read\" here to ensure that we get\n-    /// appropriate errors.\n-    ///\n-    /// If a closure pattern matches a Place starting with an Upvar, then we introduce a\n-    /// FakeRead for that Place outside the closure, in such a case this option would be\n-    /// Some(closure_def_id).\n-    /// Otherwise, the value of the optional DefId will be None.\n-    ForLet(Option<DefId>),\n-\n-    /// If we have an index expression like\n-    ///\n-    /// (*x)[1][{ x = y; 4}]\n-    ///\n-    /// then the first bounds check is invalidated when we evaluate the second\n-    /// index expression. Thus we create a fake borrow of `x` across the second\n-    /// indexer, which will cause a borrow check error.\n-    ForIndex,\n-}\n-\n impl Debug for Statement<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::StatementKind::*;\n@@ -1870,169 +1437,25 @@ impl Debug for Statement<'_> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n-pub struct Coverage {\n-    pub kind: CoverageKind,\n-    pub code_region: Option<CodeRegion>,\n-}\n+impl<'tcx> StatementKind<'tcx> {\n+    pub fn as_assign_mut(&mut self) -> Option<&mut (Place<'tcx>, Rvalue<'tcx>)> {\n+        match self {\n+            StatementKind::Assign(x) => Some(x),\n+            _ => None,\n+        }\n+    }\n \n-#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n-pub struct CopyNonOverlapping<'tcx> {\n-    pub src: Operand<'tcx>,\n-    pub dst: Operand<'tcx>,\n-    /// Number of elements to copy from src to dest, not bytes.\n-    pub count: Operand<'tcx>,\n+    pub fn as_assign(&self) -> Option<&(Place<'tcx>, Rvalue<'tcx>)> {\n+        match self {\n+            StatementKind::Assign(x) => Some(x),\n+            _ => None,\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Places\n \n-/// Places roughly correspond to a \"location in memory.\" Places in MIR are the same mathematical\n-/// object as places in Rust. This of course means that what exactly they are is undecided and part\n-/// of the Rust memory model. However, they will likely contain at least the following pieces of\n-/// information in some form:\n-///\n-///  1. The address in memory that the place refers to.\n-///  2. The provenance with which the place is being accessed.\n-///  3. The type of the place and an optional variant index. See [`PlaceTy`][tcx::PlaceTy].\n-///  4. Optionally, some metadata. This exists if and only if the type of the place is not `Sized`.\n-///\n-/// We'll give a description below of how all pieces of the place except for the provenance are\n-/// calculated. We cannot give a description of the provenance, because that is part of the\n-/// undecided aliasing model - we only include it here at all to acknowledge its existence.\n-///\n-/// Each local naturally corresponds to the place `Place { local, projection: [] }`. This place has\n-/// the address of the local's allocation and the type of the local.\n-///\n-/// **Needs clarification:** Unsized locals seem to present a bit of an issue. Their allocation\n-/// can't actually be created on `StorageLive`, because it's unclear how big to make the allocation.\n-/// Furthermore, MIR produces assignments to unsized locals, although that is not permitted under\n-/// `#![feature(unsized_locals)]` in Rust. Besides just putting \"unsized locals are special and\n-/// different\" in a bunch of places, I (JakobDegen) don't know how to incorporate this behavior into\n-/// the current MIR semantics in a clean way - possibly this needs some design work first.\n-///\n-/// For places that are not locals, ie they have a non-empty list of projections, we define the\n-/// values as a function of the parent place, that is the place with its last [`ProjectionElem`]\n-/// stripped. The way this is computed of course depends on the kind of that last projection\n-/// element:\n-///\n-///  - [`Downcast`](ProjectionElem::Downcast): This projection sets the place's variant index to the\n-///    given one, and makes no other changes. A `Downcast` projection on a place with its variant\n-///    index already set is not well-formed.\n-///  - [`Field`](ProjectionElem::Field): `Field` projections take their parent place and create a\n-///    place referring to one of the fields of the type. The resulting address is the parent\n-///    address, plus the offset of the field. The type becomes the type of the field. If the parent\n-///    was unsized and so had metadata associated with it, then the metadata is retained if the\n-///    field is unsized and thrown out if it is sized.\n-///\n-///    These projections are only legal for tuples, ADTs, closures, and generators. If the ADT or\n-///    generator has more than one variant, the parent place's variant index must be set, indicating\n-///    which variant is being used. If it has just one variant, the variant index may or may not be\n-///    included - the single possible variant is inferred if it is not included.\n-///  - [`ConstantIndex`](ProjectionElem::ConstantIndex): Computes an offset in units of `T` into the\n-///    place as described in the documentation for the `ProjectionElem`. The resulting address is\n-///    the parent's address plus that offset, and the type is `T`. This is only legal if the parent\n-///    place has type `[T;  N]` or `[T]` (*not* `&[T]`). Since such a `T` is always sized, any\n-///    resulting metadata is thrown out.\n-///  - [`Subslice`](ProjectionElem::Subslice): This projection calculates an offset and a new\n-///    address in a similar manner as `ConstantIndex`. It is also only legal on `[T; N]` and `[T]`.\n-///    However, this yields a `Place` of type `[T]`, and additionally sets the metadata to be the\n-///    length of the subslice.\n-///  - [`Index`](ProjectionElem::Index): Like `ConstantIndex`, only legal on `[T; N]` or `[T]`.\n-///    However, `Index` additionally takes a local from which the value of the index is computed at\n-///    runtime. Computing the value of the index involves interpreting the `Local` as a\n-///    `Place { local, projection: [] }`, and then computing its value as if done via\n-///    [`Operand::Copy`]. The array/slice is then indexed with the resulting value. The local must\n-///    have type `usize`.\n-///  - [`Deref`](ProjectionElem::Deref): Derefs are the last type of projection, and the most\n-///    complicated. They are only legal on parent places that are references, pointers, or `Box`. A\n-///    `Deref` projection begins by loading a value from the parent place, as if by\n-///    [`Operand::Copy`]. It then dereferences the resulting pointer, creating a place of the\n-///    pointee's type. The resulting address is the address that was stored in the pointer. If the\n-///    pointee type is unsized, the pointer additionally stored the value of the metadata.\n-///\n-/// Computing a place may cause UB. One possibility is that the pointer used for a `Deref` may not\n-/// be suitably aligned. Another possibility is that the place is not in bounds, meaning it does not\n-/// point to an actual allocation.\n-///\n-/// However, if this is actually UB and when the UB kicks in is undecided. This is being discussed\n-/// in [UCG#319]. The options include that every place must obey those rules, that only some places\n-/// must obey them, or that places impose no rules of their own.\n-///\n-/// [UCG#319]: https://github.com/rust-lang/unsafe-code-guidelines/issues/319\n-///\n-/// Rust currently requires that every place obey those two rules. This is checked by MIRI and taken\n-/// advantage of by codegen (via `gep inbounds`). That is possibly subject to change.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, HashStable)]\n-pub struct Place<'tcx> {\n-    pub local: Local,\n-\n-    /// projection out of a place (access a field, deref a pointer, etc)\n-    pub projection: &'tcx List<PlaceElem<'tcx>>,\n-}\n-\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(Place<'_>, 16);\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[derive(TyEncodable, TyDecodable, HashStable)]\n-pub enum ProjectionElem<V, T> {\n-    Deref,\n-    Field(Field, T),\n-    /// Index into a slice/array.\n-    ///\n-    /// Note that this does not also dereference, and so it does not exactly correspond to slice\n-    /// indexing in Rust. In other words, in the below Rust code:\n-    ///\n-    /// ```rust\n-    /// let x = &[1, 2, 3, 4];\n-    /// let i = 2;\n-    /// x[i];\n-    /// ```\n-    ///\n-    /// The `x[i]` is turned into a `Deref` followed by an `Index`, not just an `Index`. The same\n-    /// thing is true of the `ConstantIndex` and `Subslice` projections below.\n-    Index(V),\n-\n-    /// These indices are generated by slice patterns. Easiest to explain\n-    /// by example:\n-    ///\n-    /// ```ignore (illustrative)\n-    /// [X, _, .._, _, _] => { offset: 0, min_length: 4, from_end: false },\n-    /// [_, X, .._, _, _] => { offset: 1, min_length: 4, from_end: false },\n-    /// [_, _, .._, X, _] => { offset: 2, min_length: 4, from_end: true },\n-    /// [_, _, .._, _, X] => { offset: 1, min_length: 4, from_end: true },\n-    /// ```\n-    ConstantIndex {\n-        /// index or -index (in Python terms), depending on from_end\n-        offset: u64,\n-        /// The thing being indexed must be at least this long. For arrays this\n-        /// is always the exact length.\n-        min_length: u64,\n-        /// Counting backwards from end? This is always false when indexing an\n-        /// array.\n-        from_end: bool,\n-    },\n-\n-    /// These indices are generated by slice patterns.\n-    ///\n-    /// If `from_end` is true `slice[from..slice.len() - to]`.\n-    /// Otherwise `array[from..to]`.\n-    Subslice {\n-        from: u64,\n-        to: u64,\n-        /// Whether `to` counts from the start or end of the array/slice.\n-        /// For `PlaceElem`s this is `true` if and only if the base is a slice.\n-        /// For `ProjectionKind`, this can also be `true` for arrays.\n-        from_end: bool,\n-    },\n-\n-    /// \"Downcast\" to a variant of an enum or a generator.\n-    ///\n-    /// The included Symbol is the name of the variant, used for printing MIR.\n-    Downcast(Option<Symbol>, VariantIdx),\n-}\n-\n impl<V, T> ProjectionElem<V, T> {\n     /// Returns `true` if the target of this projection may refer to a different region of memory\n     /// than the base.\n@@ -2059,15 +1482,6 @@ impl<V, T> ProjectionElem<V, T> {\n     }\n }\n \n-/// Alias for projections as they appear in places, where the base is a place\n-/// and the index is a local.\n-pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n-\n-// This type is fairly frequently used, so we shouldn't unintentionally increase\n-// its size.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(PlaceElem<'_>, 24);\n-\n /// Alias for projections as they appear in `UserTypeProjection`, where we\n /// need neither the `V` parameter for `Index` nor the `T` for `Field`.\n pub type ProjectionKind = ProjectionElem<(), ()>;\n@@ -2349,48 +1763,6 @@ pub struct SourceScopeLocalData {\n ///////////////////////////////////////////////////////////////////////////\n // Operands\n \n-/// An operand in MIR represents a \"value\" in Rust, the definition of which is undecided and part of\n-/// the memory model. One proposal for a definition of values can be found [on UCG][value-def].\n-///\n-/// [value-def]: https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\n-///\n-/// The most common way to create values is via loading a place. Loading a place is an operation\n-/// which reads the memory of the place and converts it to a value. This is a fundamentally *typed*\n-/// operation. The nature of the value produced depends on the type of the conversion. Furthermore,\n-/// there may be other effects: if the type has a validity constraint loading the place might be UB\n-/// if the validity constraint is not met.\n-///\n-/// **Needs clarification:** Ralf proposes that loading a place not have side-effects.\n-/// This is what is implemented in miri today. Are these the semantics we want for MIR? Is this\n-/// something we can even decide without knowing more about Rust's memory model?\n-///\n-/// **Needs clarifiation:** Is loading a place that has its variant index set well-formed? Miri\n-/// currently implements it, but it seems like this may be something to check against in the\n-/// validator.\n-#[derive(Clone, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n-pub enum Operand<'tcx> {\n-    /// Creates a value by loading the given place.\n-    ///\n-    /// Before drop elaboration, the type of the place must be `Copy`. After drop elaboration there\n-    /// is no such requirement.\n-    Copy(Place<'tcx>),\n-\n-    /// Creates a value by performing loading the place, just like the `Copy` operand.\n-    ///\n-    /// This *may* additionally overwrite the place with `uninit` bytes, depending on how we decide\n-    /// in [UCG#188]. You should not emit MIR that may attempt a subsequent second load of this\n-    /// place without first re-initializing it.\n-    ///\n-    /// [UCG#188]: https://github.com/rust-lang/unsafe-code-guidelines/issues/188\n-    Move(Place<'tcx>),\n-\n-    /// Constants are already semantically values, and remain unchanged.\n-    Constant(Box<Constant<'tcx>>),\n-}\n-\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(Operand<'_>, 24);\n-\n impl<'tcx> Debug for Operand<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::Operand::*;\n@@ -2489,138 +1861,6 @@ impl<'tcx> Operand<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n /// Rvalues\n \n-#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n-/// The various kinds of rvalues that can appear in MIR.\n-///\n-/// Not all of these are allowed at every [`MirPhase`] - when this is the case, it's stated below.\n-///\n-/// Computing any rvalue begins by evaluating the places and operands in some order (**Needs\n-/// clarification**: Which order?). These are then used to produce a \"value\" - the same kind of\n-/// value that an [`Operand`] produces.\n-pub enum Rvalue<'tcx> {\n-    /// Yields the operand unchanged\n-    Use(Operand<'tcx>),\n-\n-    /// Creates an array where each element is the value of the operand.\n-    ///\n-    /// This is the cause of a bug in the case where the repetition count is zero because the value\n-    /// is not dropped, see [#74836].\n-    ///\n-    /// Corresponds to source code like `[x; 32]`.\n-    ///\n-    /// [#74836]: https://github.com/rust-lang/rust/issues/74836\n-    Repeat(Operand<'tcx>, ty::Const<'tcx>),\n-\n-    /// Creates a reference of the indicated kind to the place.\n-    ///\n-    /// There is not much to document here, because besides the obvious parts the semantics of this\n-    /// are essentially entirely a part of the aliasing model. There are many UCG issues discussing\n-    /// exactly what the behavior of this operation should be.\n-    ///\n-    /// `Shallow` borrows are disallowed after drop lowering.\n-    Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n-\n-    /// Creates a pointer/reference to the given thread local.\n-    ///\n-    /// The yielded type is a `*mut T` if the static is mutable, otherwise if the static is extern a\n-    /// `*const T`, and if neither of those apply a `&T`.\n-    ///\n-    /// **Note:** This is a runtime operation that actually executes code and is in this sense more\n-    /// like a function call. Also, eliminating dead stores of this rvalue causes `fn main() {}` to\n-    /// SIGILL for some reason that I (JakobDegen) never got a chance to look into.\n-    ///\n-    /// **Needs clarification**: Are there weird additional semantics here related to the runtime\n-    /// nature of this operation?\n-    ThreadLocalRef(DefId),\n-\n-    /// Creates a pointer with the indicated mutability to the place.\n-    ///\n-    /// This is generated by pointer casts like `&v as *const _` or raw address of expressions like\n-    /// `&raw v` or `addr_of!(v)`.\n-    ///\n-    /// Like with references, the semantics of this operation are heavily dependent on the aliasing\n-    /// model.\n-    AddressOf(Mutability, Place<'tcx>),\n-\n-    /// Yields the length of the place, as a `usize`.\n-    ///\n-    /// If the type of the place is an array, this is the array length. For slices (`[T]`, not\n-    /// `&[T]`) this accesses the place's metadata to determine the length. This rvalue is\n-    /// ill-formed for places of other types.\n-    Len(Place<'tcx>),\n-\n-    /// Performs essentially all of the casts that can be performed via `as`.\n-    ///\n-    /// This allows for casts from/to a variety of types.\n-    ///\n-    /// **FIXME**: Document exactly which `CastKind`s allow which types of casts. Figure out why\n-    /// `ArrayToPointer` and `MutToConstPointer` are special.\n-    Cast(CastKind, Operand<'tcx>, Ty<'tcx>),\n-\n-    /// * `Offset` has the same semantics as [`offset`](pointer::offset), except that the second\n-    ///   parameter may be a `usize` as well.\n-    /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,\n-    ///   raw pointers, or function pointers and return a `bool`. The types of the operands must be\n-    ///   matching, up to the usual caveat of the lifetimes in function pointers.\n-    /// * Left and right shift operations accept signed or unsigned integers not necessarily of the\n-    ///   same type and return a value of the same type as their LHS. Like in Rust, the RHS is\n-    ///   truncated as needed.\n-    /// * The `Bit*` operations accept signed integers, unsigned integers, or bools with matching\n-    ///   types and return a value of that type.\n-    /// * The remaining operations accept signed integers, unsigned integers, or floats with\n-    ///   matching types and return a value of that type.\n-    BinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n-\n-    /// Same as `BinaryOp`, but yields `(T, bool)` instead of `T`. In addition to performing the\n-    /// same computation as the matching `BinaryOp`, checks if the infinite precison result would be\n-    /// unequal to the actual result and sets the `bool` if this is the case.\n-    ///\n-    /// This only supports addition, subtraction, multiplication, and shift operations on integers.\n-    CheckedBinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n-\n-    /// Computes a value as described by the operation.\n-    NullaryOp(NullOp, Ty<'tcx>),\n-\n-    /// Exactly like `BinaryOp`, but less operands.\n-    ///\n-    /// Also does two's-complement arithmetic. Negation requires a signed integer or a float;\n-    /// bitwise not requires a signed integer, unsigned integer, or bool. Both operation kinds\n-    /// return a value with the same type as their operand.\n-    UnaryOp(UnOp, Operand<'tcx>),\n-\n-    /// Computes the discriminant of the place, returning it as an integer of type\n-    /// [`discriminant_ty`]. Returns zero for types without discriminant.\n-    ///\n-    /// The validity requirements for the underlying value are undecided for this rvalue, see\n-    /// [#91095]. Note too that the value of the discriminant is not the same thing as the\n-    /// variant index; use [`discriminant_for_variant`] to convert.\n-    ///\n-    /// [`discriminant_ty`]: crate::ty::Ty::discriminant_ty\n-    /// [#91095]: https://github.com/rust-lang/rust/issues/91095\n-    /// [`discriminant_for_variant`]: crate::ty::Ty::discriminant_for_variant\n-    Discriminant(Place<'tcx>),\n-\n-    /// Creates an aggregate value, like a tuple or struct.\n-    ///\n-    /// This is needed because dataflow analysis needs to distinguish\n-    /// `dest = Foo { x: ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case that `Foo`\n-    /// has a destructor.\n-    ///\n-    /// Disallowed after deaggregation for all aggregate kinds except `Array` and `Generator`. After\n-    /// generator lowering, `Generator` aggregate kinds are disallowed too.\n-    Aggregate(Box<AggregateKind<'tcx>>, Vec<Operand<'tcx>>),\n-\n-    /// Transmutes a `*mut u8` into shallow-initialized `Box<T>`.\n-    ///\n-    /// This is different from a normal transmute because dataflow analysis will treat the box as\n-    /// initialized but its content as uninitialized. Like other pointer casts, this in general\n-    /// affects alias analysis.\n-    ShallowInitBox(Operand<'tcx>, Ty<'tcx>),\n-}\n-\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(Rvalue<'_>, 40);\n-\n impl<'tcx> Rvalue<'tcx> {\n     /// Returns true if rvalue can be safely removed when the result is unused.\n     #[inline]\n@@ -2653,88 +1893,22 @@ impl<'tcx> Rvalue<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n-pub enum CastKind {\n-    /// An exposing pointer to address cast. A cast between a pointer and an integer type, or\n-    /// between a function pointer and an integer type.\n-    /// See the docs on `expose_addr` for more details.\n-    PointerExposeAddress,\n-    /// An address-to-pointer cast that picks up an exposed provenance.\n-    /// See the docs on `from_exposed_addr` for more details.\n-    PointerFromExposedAddress,\n-    /// All sorts of pointer-to-pointer casts. Note that reference-to-raw-ptr casts are\n-    /// translated into `&raw mut/const *r`, i.e., they are not actually casts.\n-    Pointer(PointerCast),\n-    /// Remaining unclassified casts.\n-    Misc,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n-pub enum AggregateKind<'tcx> {\n-    /// The type is of the element\n-    Array(Ty<'tcx>),\n-    Tuple,\n-\n-    /// The second field is the variant index. It's equal to 0 for struct\n-    /// and union expressions. The fourth field is\n-    /// active field number and is present only for union expressions\n-    /// -- e.g., for a union expression `SomeUnion { c: .. }`, the\n-    /// active field index would identity the field `c`\n-    Adt(DefId, VariantIdx, SubstsRef<'tcx>, Option<UserTypeAnnotationIndex>, Option<usize>),\n-\n-    Closure(DefId, SubstsRef<'tcx>),\n-    Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n-}\n+impl BorrowKind {\n+    pub fn allows_two_phase_borrow(&self) -> bool {\n+        match *self {\n+            BorrowKind::Shared | BorrowKind::Shallow | BorrowKind::Unique => false,\n+            BorrowKind::Mut { allow_two_phase_borrow } => allow_two_phase_borrow,\n+        }\n+    }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(AggregateKind<'_>, 48);\n-\n-#[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n-pub enum BinOp {\n-    /// The `+` operator (addition)\n-    Add,\n-    /// The `-` operator (subtraction)\n-    Sub,\n-    /// The `*` operator (multiplication)\n-    Mul,\n-    /// The `/` operator (division)\n-    ///\n-    /// Division by zero is UB, because the compiler should have inserted checks\n-    /// prior to this.\n-    Div,\n-    /// The `%` operator (modulus)\n-    ///\n-    /// Using zero as the modulus (second operand) is UB, because the compiler\n-    /// should have inserted checks prior to this.\n-    Rem,\n-    /// The `^` operator (bitwise xor)\n-    BitXor,\n-    /// The `&` operator (bitwise and)\n-    BitAnd,\n-    /// The `|` operator (bitwise or)\n-    BitOr,\n-    /// The `<<` operator (shift left)\n-    ///\n-    /// The offset is truncated to the size of the first operand before shifting.\n-    Shl,\n-    /// The `>>` operator (shift right)\n-    ///\n-    /// The offset is truncated to the size of the first operand before shifting.\n-    Shr,\n-    /// The `==` operator (equality)\n-    Eq,\n-    /// The `<` operator (less than)\n-    Lt,\n-    /// The `<=` operator (less than or equal to)\n-    Le,\n-    /// The `!=` operator (not equal to)\n-    Ne,\n-    /// The `>=` operator (greater than or equal to)\n-    Ge,\n-    /// The `>` operator (greater than)\n-    Gt,\n-    /// The `ptr.offset` operator\n-    Offset,\n+    pub fn describe_mutability(&self) -> String {\n+        match *self {\n+            BorrowKind::Shared | BorrowKind::Shallow | BorrowKind::Unique => {\n+                \"immutable\".to_string()\n+            }\n+            BorrowKind::Mut { .. } => \"mutable\".to_string(),\n+        }\n+    }\n }\n \n impl BinOp {\n@@ -2744,22 +1918,6 @@ impl BinOp {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n-pub enum NullOp {\n-    /// Returns the size of a value of that type\n-    SizeOf,\n-    /// Returns the minimum alignment of a type\n-    AlignOf,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n-pub enum UnOp {\n-    /// The `!` operator for logical inversion\n-    Not,\n-    /// The `-` operator for negation\n-    Neg,\n-}\n-\n impl<'tcx> Debug for Rvalue<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::Rvalue::*;"}, {"sha": "f8ee59f306fbf6e59266fc1b220e3b8cc12b5cef", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "added", "additions": 1141, "deletions": 0, "changes": 1141, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -0,0 +1,1141 @@\n+//! This defines the syntax of MIR, i.e., the set of available MIR operations, and other definitions\n+//! closely related to MIR semantics.\n+//! This is in a dedicated file so that changes to this file can be reviewed more carefully.\n+//! The intention is that this file only contains datatype declarations, no code.\n+\n+use super::{BasicBlock, Constant, Field, Local, SwitchTargets, UserTypeProjection};\n+\n+use crate::mir::coverage::{CodeRegion, CoverageKind};\n+use crate::ty::adjustment::PointerCast;\n+use crate::ty::subst::SubstsRef;\n+use crate::ty::{self, List, Ty};\n+use crate::ty::{Region, UserTypeAnnotationIndex};\n+\n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{self as hir};\n+use rustc_hir::{self, GeneratorKind};\n+use rustc_target::abi::VariantIdx;\n+\n+use rustc_ast::Mutability;\n+use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n+use rustc_target::asm::InlineAsmRegOrRegClass;\n+\n+/// The various \"big phases\" that MIR goes through.\n+///\n+/// These phases all describe dialects of MIR. Since all MIR uses the same datastructures, the\n+/// dialects forbid certain variants or values in certain phases. The sections below summarize the\n+/// changes, but do not document them thoroughly. The full documentation is found in the appropriate\n+/// documentation for the thing the change is affecting.\n+///\n+/// Warning: ordering of variants is significant.\n+#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(HashStable)]\n+pub enum MirPhase {\n+    /// The dialect of MIR used during all phases before `DropsLowered` is the same. This is also\n+    /// the MIR that analysis such as borrowck uses.\n+    ///\n+    /// One important thing to remember about the behavior of this section of MIR is that drop terminators\n+    /// (including drop and replace) are *conditional*. The elaborate drops pass will then replace each\n+    /// instance of a drop terminator with a nop, an unconditional drop, or a drop conditioned on a drop\n+    /// flag. Of course, this means that it is important that the drop elaboration can accurately recognize\n+    /// when things are initialized and when things are de-initialized. That means any code running on this\n+    /// version of MIR must be sure to produce output that drop elaboration can reason about. See the\n+    /// section on the drop terminatorss for more details.\n+    Built = 0,\n+    // FIXME(oli-obk): it's unclear whether we still need this phase (and its corresponding query).\n+    // We used to have this for pre-miri MIR based const eval.\n+    Const = 1,\n+    /// This phase checks the MIR for promotable elements and takes them out of the main MIR body\n+    /// by creating a new MIR body per promoted element. After this phase (and thus the termination\n+    /// of the `mir_promoted` query), these promoted elements are available in the `promoted_mir`\n+    /// query.\n+    ConstsPromoted = 2,\n+    /// Beginning with this phase, the following variants are disallowed:\n+    /// * [`TerminatorKind::DropAndReplace`]\n+    /// * [`TerminatorKind::FalseUnwind`]\n+    /// * [`TerminatorKind::FalseEdge`]\n+    /// * [`StatementKind::FakeRead`]\n+    /// * [`StatementKind::AscribeUserType`]\n+    /// * [`Rvalue::Ref`] with `BorrowKind::Shallow`\n+    ///\n+    /// And the following variant is allowed:\n+    /// * [`StatementKind::Retag`]\n+    ///\n+    /// Furthermore, `Drop` now uses explicit drop flags visible in the MIR and reaching a `Drop`\n+    /// terminator means that the auto-generated drop glue will be invoked. Also, `Copy` operands\n+    /// are allowed for non-`Copy` types.\n+    DropsLowered = 3,\n+    /// After this projections may only contain deref projections as the first element.\n+    Derefered = 4,\n+    /// Beginning with this phase, the following variant is disallowed:\n+    /// * [`Rvalue::Aggregate`] for any `AggregateKind` except `Array`\n+    ///\n+    /// And the following variant is allowed:\n+    /// * [`StatementKind::SetDiscriminant`]\n+    Deaggregated = 5,\n+    /// Before this phase, generators are in the \"source code\" form, featuring `yield` statements\n+    /// and such. With this phase change, they are transformed into a proper state machine. Running\n+    /// optimizations before this change can be potentially dangerous because the source code is to\n+    /// some extent a \"lie.\" In particular, `yield` terminators effectively make the value of all\n+    /// locals visible to the caller. This means that dead store elimination before them, or code\n+    /// motion across them, is not correct in general. This is also exasperated by type checking\n+    /// having pre-computed a list of the types that it thinks are ok to be live across a yield\n+    /// point - this is necessary to decide eg whether autotraits are implemented. Introducing new\n+    /// types across a yield point will lead to ICEs becaues of this.\n+    ///\n+    /// Beginning with this phase, the following variants are disallowed:\n+    /// * [`TerminatorKind::Yield`]\n+    /// * [`TerminatorKind::GeneratorDrop`]\n+    /// * [`ProjectionElem::Deref`] of `Box`\n+    GeneratorsLowered = 6,\n+    Optimized = 7,\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Borrow kinds\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n+#[derive(Hash, HashStable)]\n+pub enum BorrowKind {\n+    /// Data must be immutable and is aliasable.\n+    Shared,\n+\n+    /// The immediately borrowed place must be immutable, but projections from\n+    /// it don't need to be. For example, a shallow borrow of `a.b` doesn't\n+    /// conflict with a mutable borrow of `a.b.c`.\n+    ///\n+    /// This is used when lowering matches: when matching on a place we want to\n+    /// ensure that place have the same value from the start of the match until\n+    /// an arm is selected. This prevents this code from compiling:\n+    /// ```compile_fail,E0510\n+    /// let mut x = &Some(0);\n+    /// match *x {\n+    ///     None => (),\n+    ///     Some(_) if { x = &None; false } => (),\n+    ///     Some(_) => (),\n+    /// }\n+    /// ```\n+    /// This can't be a shared borrow because mutably borrowing (*x as Some).0\n+    /// should not prevent `if let None = x { ... }`, for example, because the\n+    /// mutating `(*x as Some).0` can't affect the discriminant of `x`.\n+    /// We can also report errors with this kind of borrow differently.\n+    Shallow,\n+\n+    /// Data must be immutable but not aliasable. This kind of borrow\n+    /// cannot currently be expressed by the user and is used only in\n+    /// implicit closure bindings. It is needed when the closure is\n+    /// borrowing or mutating a mutable referent, e.g.:\n+    /// ```\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = || *x += 5;\n+    /// ```\n+    /// If we were to try to translate this closure into a more explicit\n+    /// form, we'd encounter an error with the code as written:\n+    /// ```compile_fail,E0594\n+    /// struct Env<'a> { x: &'a &'a mut isize }\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = (&mut Env { x: &x }, fn_ptr);  // Closure is pair of env and fn\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n+    /// This is then illegal because you cannot mutate an `&mut` found\n+    /// in an aliasable location. To solve, you'd have to translate with\n+    /// an `&mut` borrow:\n+    /// ```compile_fail,E0596\n+    /// struct Env<'a> { x: &'a mut &'a mut isize }\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = (&mut Env { x: &mut x }, fn_ptr); // changed from &x to &mut x\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n+    /// Now the assignment to `**env.x` is legal, but creating a\n+    /// mutable pointer to `x` is not because `x` is not mutable. We\n+    /// could fix this by declaring `x` as `let mut x`. This is ok in\n+    /// user code, if awkward, but extra weird for closures, since the\n+    /// borrow is hidden.\n+    ///\n+    /// So we introduce a \"unique imm\" borrow -- the referent is\n+    /// immutable, but not aliasable. This solves the problem. For\n+    /// simplicity, we don't give users the way to express this\n+    /// borrow, it's just used when translating closures.\n+    Unique,\n+\n+    /// Data is mutable and not aliasable.\n+    Mut {\n+        /// `true` if this borrow arose from method-call auto-ref\n+        /// (i.e., `adjustment::Adjust::Borrow`).\n+        allow_two_phase_borrow: bool,\n+    },\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Statements\n+\n+/// The various kinds of statements that can appear in MIR.\n+///\n+/// Not all of these are allowed at every [`MirPhase`]. Check the documentation there to see which\n+/// ones you do not have to worry about. The MIR validator will generally enforce such restrictions,\n+/// causing an ICE if they are violated.\n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n+pub enum StatementKind<'tcx> {\n+    /// Assign statements roughly correspond to an assignment in Rust proper (`x = ...`) except\n+    /// without the possibility of dropping the previous value (that must be done separately, if at\n+    /// all). The *exact* way this works is undecided. It probably does something like evaluating\n+    /// the LHS to a place and the RHS to a value, and then storing the value to the place. Various\n+    /// parts of this may do type specific things that are more complicated than simply copying\n+    /// bytes.\n+    ///\n+    /// **Needs clarification**: The implication of the above idea would be that assignment implies\n+    /// that the resulting value is initialized. I believe we could commit to this separately from\n+    /// committing to whatever part of the memory model we would need to decide on to make the above\n+    /// paragragh precise. Do we want to?\n+    ///\n+    /// Assignments in which the types of the place and rvalue differ are not well-formed.\n+    ///\n+    /// **Needs clarification**: Do we ever want to worry about non-free (in the body) lifetimes for\n+    /// the typing requirement in post drop-elaboration MIR? I think probably not - I'm not sure we\n+    /// could meaningfully require this anyway. How about free lifetimes? Is ignoring this\n+    /// interesting for optimizations? Do we want to allow such optimizations?\n+    ///\n+    /// **Needs clarification**: We currently require that the LHS place not overlap with any place\n+    /// read as part of computation of the RHS for some rvalues (generally those not producing\n+    /// primitives). This requirement is under discussion in [#68364]. As a part of this discussion,\n+    /// it is also unclear in what order the components are evaluated.\n+    ///\n+    /// [#68364]: https://github.com/rust-lang/rust/issues/68364\n+    ///\n+    /// See [`Rvalue`] documentation for details on each of those.\n+    Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n+\n+    /// This represents all the reading that a pattern match may do (e.g., inspecting constants and\n+    /// discriminant values), and the kind of pattern it comes from. This is in order to adapt\n+    /// potential error messages to these specific patterns.\n+    ///\n+    /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n+    /// never accessed still get some sanity checks for, e.g., `let x: ! = ..;`\n+    ///\n+    /// When executed at runtime this is a nop.\n+    ///\n+    /// Disallowed after drop elaboration.\n+    FakeRead(Box<(FakeReadCause, Place<'tcx>)>),\n+\n+    /// Write the discriminant for a variant to the enum Place.\n+    ///\n+    /// This is permitted for both generators and ADTs. This does not necessarily write to the\n+    /// entire place; instead, it writes to the minimum set of bytes as required by the layout for\n+    /// the type.\n+    SetDiscriminant { place: Box<Place<'tcx>>, variant_index: VariantIdx },\n+\n+    /// Deinitializes the place.\n+    ///\n+    /// This writes `uninit` bytes to the entire place.\n+    Deinit(Box<Place<'tcx>>),\n+\n+    /// `StorageLive` and `StorageDead` statements mark the live range of a local.\n+    ///\n+    /// Using a local before a `StorageLive` or after a `StorageDead` is not well-formed. These\n+    /// statements are not required. If the entire MIR body contains no `StorageLive`/`StorageDead`\n+    /// statements for a particular local, the local is always considered live.\n+    ///\n+    /// More precisely, the MIR validator currently does a `MaybeStorageLiveLocals` analysis to\n+    /// check validity of each use of a local. I believe this is equivalent to requiring for every\n+    /// use of a local, there exist at least one path from the root to that use that contains a\n+    /// `StorageLive` more recently than a `StorageDead`.\n+    ///\n+    /// **Needs clarification**: Is it permitted to have two `StorageLive`s without an intervening\n+    /// `StorageDead`? Two `StorageDead`s without an intervening `StorageLive`? LLVM says poison,\n+    /// yes. If the answer to any of these is \"no,\" is breaking that rule UB or is it an error to\n+    /// have a path in the CFG that might do this?\n+    StorageLive(Local),\n+\n+    /// See `StorageLive` above.\n+    StorageDead(Local),\n+\n+    /// Retag references in the given place, ensuring they got fresh tags.\n+    ///\n+    /// This is part of the Stacked Borrows model. These statements are currently only interpreted\n+    /// by miri and only generated when `-Z mir-emit-retag` is passed. See\n+    /// <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/> for\n+    /// more details.\n+    ///\n+    /// For code that is not specific to stacked borrows, you should consider retags to read\n+    /// and modify the place in an opaque way.\n+    Retag(RetagKind, Box<Place<'tcx>>),\n+\n+    /// Encodes a user's type ascription. These need to be preserved\n+    /// intact so that NLL can respect them. For example:\n+    /// ```ignore (illustrative)\n+    /// let a: T = y;\n+    /// ```\n+    /// The effect of this annotation is to relate the type `T_y` of the place `y`\n+    /// to the user-given type `T`. The effect depends on the specified variance:\n+    ///\n+    /// - `Covariant` -- requires that `T_y <: T`\n+    /// - `Contravariant` -- requires that `T_y :> T`\n+    /// - `Invariant` -- requires that `T_y == T`\n+    /// - `Bivariant` -- no effect\n+    ///\n+    /// When executed at runtime this is a nop.\n+    ///\n+    /// Disallowed after drop elaboration.\n+    AscribeUserType(Box<(Place<'tcx>, UserTypeProjection)>, ty::Variance),\n+\n+    /// Marks the start of a \"coverage region\", injected with '-Cinstrument-coverage'. A\n+    /// `Coverage` statement carries metadata about the coverage region, used to inject a coverage\n+    /// map into the binary. If `Coverage::kind` is a `Counter`, the statement also generates\n+    /// executable code, to increment a counter variable at runtime, each time the code region is\n+    /// executed.\n+    Coverage(Box<Coverage>),\n+\n+    /// Denotes a call to the intrinsic function `copy_nonoverlapping`.\n+    ///\n+    /// First, all three operands are evaluated. `src` and `dest` must each be a reference, pointer,\n+    /// or `Box` pointing to the same type `T`. `count` must evaluate to a `usize`. Then, `src` and\n+    /// `dest` are dereferenced, and `count * size_of::<T>()` bytes beginning with the first byte of\n+    /// the `src` place are copied to the continguous range of bytes beginning with the first byte\n+    /// of `dest`.\n+    ///\n+    /// **Needs clarification**: In what order are operands computed and dereferenced? It should\n+    /// probably match the order for assignment, but that is also undecided.\n+    ///\n+    /// **Needs clarification**: Is this typed or not, ie is there a typed load and store involved?\n+    /// I vaguely remember Ralf saying somewhere that he thought it should not be.\n+    CopyNonOverlapping(Box<CopyNonOverlapping<'tcx>>),\n+\n+    /// No-op. Useful for deleting instructions without affecting statement indices.\n+    Nop,\n+}\n+\n+/// Describes what kind of retag is to be performed.\n+#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, Hash, HashStable)]\n+pub enum RetagKind {\n+    /// The initial retag when entering a function.\n+    FnEntry,\n+    /// Retag preparing for a two-phase borrow.\n+    TwoPhase,\n+    /// Retagging raw pointers.\n+    Raw,\n+    /// A \"normal\" retag.\n+    Default,\n+}\n+\n+/// The `FakeReadCause` describes the type of pattern why a FakeRead statement exists.\n+#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, Hash, HashStable, PartialEq)]\n+pub enum FakeReadCause {\n+    /// Inject a fake read of the borrowed input at the end of each guards\n+    /// code.\n+    ///\n+    /// This should ensure that you cannot change the variant for an enum while\n+    /// you are in the midst of matching on it.\n+    ForMatchGuard,\n+\n+    /// `let x: !; match x {}` doesn't generate any read of x so we need to\n+    /// generate a read of x to check that it is initialized and safe.\n+    ///\n+    /// If a closure pattern matches a Place starting with an Upvar, then we introduce a\n+    /// FakeRead for that Place outside the closure, in such a case this option would be\n+    /// Some(closure_def_id).\n+    /// Otherwise, the value of the optional DefId will be None.\n+    ForMatchedPlace(Option<DefId>),\n+\n+    /// A fake read of the RefWithinGuard version of a bind-by-value variable\n+    /// in a match guard to ensure that its value hasn't change by the time\n+    /// we create the OutsideGuard version.\n+    ForGuardBinding,\n+\n+    /// Officially, the semantics of\n+    ///\n+    /// `let pattern = <expr>;`\n+    ///\n+    /// is that `<expr>` is evaluated into a temporary and then this temporary is\n+    /// into the pattern.\n+    ///\n+    /// However, if we see the simple pattern `let var = <expr>`, we optimize this to\n+    /// evaluate `<expr>` directly into the variable `var`. This is mostly unobservable,\n+    /// but in some cases it can affect the borrow checker, as in #53695.\n+    /// Therefore, we insert a \"fake read\" here to ensure that we get\n+    /// appropriate errors.\n+    ///\n+    /// If a closure pattern matches a Place starting with an Upvar, then we introduce a\n+    /// FakeRead for that Place outside the closure, in such a case this option would be\n+    /// Some(closure_def_id).\n+    /// Otherwise, the value of the optional DefId will be None.\n+    ForLet(Option<DefId>),\n+\n+    /// If we have an index expression like\n+    ///\n+    /// (*x)[1][{ x = y; 4}]\n+    ///\n+    /// then the first bounds check is invalidated when we evaluate the second\n+    /// index expression. Thus we create a fake borrow of `x` across the second\n+    /// indexer, which will cause a borrow check error.\n+    ForIndex,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n+pub struct Coverage {\n+    pub kind: CoverageKind,\n+    pub code_region: Option<CodeRegion>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n+pub struct CopyNonOverlapping<'tcx> {\n+    pub src: Operand<'tcx>,\n+    pub dst: Operand<'tcx>,\n+    /// Number of elements to copy from src to dest, not bytes.\n+    pub count: Operand<'tcx>,\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Terminators\n+\n+/// A note on unwinding: Panics may occur during the execution of some terminators. Depending on the\n+/// `-C panic` flag, this may either cause the program to abort or the call stack to unwind. Such\n+/// terminators have a `cleanup: Option<BasicBlock>` field on them. If stack unwinding occurs, then\n+/// once the current function is reached, execution continues at the given basic block, if any. If\n+/// `cleanup` is `None` then no cleanup is performed, and the stack continues unwinding. This is\n+/// equivalent to the execution of a `Resume` terminator.\n+///\n+/// The basic block pointed to by a `cleanup` field must have its `cleanup` flag set. `cleanup`\n+/// basic blocks have a couple restrictions:\n+///  1. All `cleanup` fields in them must be `None`.\n+///  2. `Return` terminators are not allowed in them. `Abort` and `Unwind` terminators are.\n+///  3. All other basic blocks (in the current body) that are reachable from `cleanup` basic blocks\n+///     must also be `cleanup`. This is a part of the type system and checked statically, so it is\n+///     still an error to have such an edge in the CFG even if it's known that it won't be taken at\n+///     runtime.\n+#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n+pub enum TerminatorKind<'tcx> {\n+    /// Block has one successor; we continue execution there.\n+    Goto { target: BasicBlock },\n+\n+    /// Switches based on the computed value.\n+    ///\n+    /// First, evaluates the `discr` operand. The type of the operand must be a signed or unsigned\n+    /// integer, char, or bool, and must match the given type. Then, if the list of switch targets\n+    /// contains the computed value, continues execution at the associated basic block. Otherwise,\n+    /// continues execution at the \"otherwise\" basic block.\n+    ///\n+    /// Target values may not appear more than once.\n+    SwitchInt {\n+        /// The discriminant value being tested.\n+        discr: Operand<'tcx>,\n+\n+        /// The type of value being tested.\n+        /// This is always the same as the type of `discr`.\n+        /// FIXME: remove this redundant information. Currently, it is relied on by pretty-printing.\n+        switch_ty: Ty<'tcx>,\n+\n+        targets: SwitchTargets,\n+    },\n+\n+    /// Indicates that the landing pad is finished and that the process should continue unwinding.\n+    ///\n+    /// Like a return, this marks the end of this invocation of the function.\n+    ///\n+    /// Only permitted in cleanup blocks. `Resume` is not permitted with `-C unwind=abort` after\n+    /// deaggregation runs.\n+    Resume,\n+\n+    /// Indicates that the landing pad is finished and that the process should abort.\n+    ///\n+    /// Used to prevent unwinding for foreign items or with `-C unwind=abort`. Only permitted in\n+    /// cleanup blocks.\n+    Abort,\n+\n+    /// Returns from the function.\n+    ///\n+    /// Like function calls, the exact semantics of returns in Rust are unclear. Returning very\n+    /// likely at least assigns the value currently in the return place (`_0`) to the place\n+    /// specified in the associated `Call` terminator in the calling function, as if assigned via\n+    /// `dest = move _0`. It might additionally do other things, like have side-effects in the\n+    /// aliasing model.\n+    ///\n+    /// If the body is a generator body, this has slightly different semantics; it instead causes a\n+    /// `GeneratorState::Returned(_0)` to be created (as if by an `Aggregate` rvalue) and assigned\n+    /// to the return place.\n+    Return,\n+\n+    /// Indicates a terminator that can never be reached.\n+    ///\n+    /// Executing this terminator is UB.\n+    Unreachable,\n+\n+    /// The behavior of this statement differs significantly before and after drop elaboration.\n+    /// After drop elaboration, `Drop` executes the drop glue for the specified place, after which\n+    /// it continues execution/unwinds at the given basic blocks. It is possible that executing drop\n+    /// glue is special - this would be part of Rust's memory model. (**FIXME**: due we have an\n+    /// issue tracking if drop glue has any interesting semantics in addition to those of a function\n+    /// call?)\n+    ///\n+    /// `Drop` before drop elaboration is a *conditional* execution of the drop glue. Specifically, the\n+    /// `Drop` will be executed if...\n+    ///\n+    /// **Needs clarification**: End of that sentence. This in effect should document the exact\n+    /// behavior of drop elaboration. The following sounds vaguely right, but I'm not quite sure:\n+    ///\n+    /// > The drop glue is executed if, among all statements executed within this `Body`, an assignment to\n+    /// > the place or one of its \"parents\" occurred more recently than a move out of it. This does not\n+    /// > consider indirect assignments.\n+    Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n+\n+    /// Drops the place and assigns a new value to it.\n+    ///\n+    /// This first performs the exact same operation as the pre drop-elaboration `Drop` terminator;\n+    /// it then additionally assigns the `value` to the `place` as if by an assignment statement.\n+    /// This assignment occurs both in the unwind and the regular code paths. The semantics are best\n+    /// explained by the elaboration:\n+    ///\n+    /// ```ignore (MIR)\n+    /// BB0 {\n+    ///   DropAndReplace(P <- V, goto BB1, unwind BB2)\n+    /// }\n+    /// ```\n+    ///\n+    /// becomes\n+    ///\n+    /// ```ignore (MIR)\n+    /// BB0 {\n+    ///   Drop(P, goto BB1, unwind BB2)\n+    /// }\n+    /// BB1 {\n+    ///   // P is now uninitialized\n+    ///   P <- V\n+    /// }\n+    /// BB2 {\n+    ///   // P is now uninitialized -- its dtor panicked\n+    ///   P <- V\n+    /// }\n+    /// ```\n+    ///\n+    /// Disallowed after drop elaboration.\n+    DropAndReplace {\n+        place: Place<'tcx>,\n+        value: Operand<'tcx>,\n+        target: BasicBlock,\n+        unwind: Option<BasicBlock>,\n+    },\n+\n+    /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of\n+    /// the referred to function. The operand types must match the argument types of the function.\n+    /// The return place type must match the return type. The type of the `func` operand must be\n+    /// callable, meaning either a function pointer, a function type, or a closure type.\n+    ///\n+    /// **Needs clarification**: The exact semantics of this. Current backends rely on `move`\n+    /// operands not aliasing the return place. It is unclear how this is justified in MIR, see\n+    /// [#71117].\n+    ///\n+    /// [#71117]: https://github.com/rust-lang/rust/issues/71117\n+    Call {\n+        /// The function that\u2019s being called.\n+        func: Operand<'tcx>,\n+        /// Arguments the function is called with.\n+        /// These are owned by the callee, which is free to modify them.\n+        /// This allows the memory occupied by \"by-value\" arguments to be\n+        /// reused across function calls without duplicating the contents.\n+        args: Vec<Operand<'tcx>>,\n+        /// Where the returned value will be written\n+        destination: Place<'tcx>,\n+        /// Where to go after this call returns. If none, the call necessarily diverges.\n+        target: Option<BasicBlock>,\n+        /// Cleanups to be done if the call unwinds.\n+        cleanup: Option<BasicBlock>,\n+        /// `true` if this is from a call in HIR rather than from an overloaded\n+        /// operator. True for overloaded function call.\n+        from_hir_call: bool,\n+        /// This `Span` is the span of the function, without the dot and receiver\n+        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n+        fn_span: Span,\n+    },\n+\n+    /// Evaluates the operand, which must have type `bool`. If it is not equal to `expected`,\n+    /// initiates a panic. Initiating a panic corresponds to a `Call` terminator with some\n+    /// unspecified constant as the function to call, all the operands stored in the `AssertMessage`\n+    /// as parameters, and `None` for the destination. Keep in mind that the `cleanup` path is not\n+    /// necessarily executed even in the case of a panic, for example in `-C panic=abort`. If the\n+    /// assertion does not fail, execution continues at the specified basic block.\n+    Assert {\n+        cond: Operand<'tcx>,\n+        expected: bool,\n+        msg: AssertMessage<'tcx>,\n+        target: BasicBlock,\n+        cleanup: Option<BasicBlock>,\n+    },\n+\n+    /// Marks a suspend point.\n+    ///\n+    /// Like `Return` terminators in generator bodies, this computes `value` and then a\n+    /// `GeneratorState::Yielded(value)` as if by `Aggregate` rvalue. That value is then assigned to\n+    /// the return place of the function calling this one, and execution continues in the calling\n+    /// function. When next invoked with the same first argument, execution of this function\n+    /// continues at the `resume` basic block, with the second argument written to the `resume_arg`\n+    /// place. If the generator is dropped before then, the `drop` basic block is invoked.\n+    ///\n+    /// Not permitted in bodies that are not generator bodies, or after generator lowering.\n+    ///\n+    /// **Needs clarification**: What about the evaluation order of the `resume_arg` and `value`?\n+    Yield {\n+        /// The value to return.\n+        value: Operand<'tcx>,\n+        /// Where to resume to.\n+        resume: BasicBlock,\n+        /// The place to store the resume argument in.\n+        resume_arg: Place<'tcx>,\n+        /// Cleanup to be done if the generator is dropped at this suspend point.\n+        drop: Option<BasicBlock>,\n+    },\n+\n+    /// Indicates the end of dropping a generator.\n+    ///\n+    /// Semantically just a `return` (from the generators drop glue). Only permitted in the same situations\n+    /// as `yield`.\n+    ///\n+    /// **Needs clarification**: Is that even correct? The generator drop code is always confusing\n+    /// to me, because it's not even really in the current body.\n+    ///\n+    /// **Needs clarification**: Are there type system constraints on these terminators? Should\n+    /// there be a \"block type\" like `cleanup` blocks for them?\n+    GeneratorDrop,\n+\n+    /// A block where control flow only ever takes one real path, but borrowck needs to be more\n+    /// conservative.\n+    ///\n+    /// At runtime this is semantically just a goto.\n+    ///\n+    /// Disallowed after drop elaboration.\n+    FalseEdge {\n+        /// The target normal control flow will take.\n+        real_target: BasicBlock,\n+        /// A block control flow could conceptually jump to, but won't in\n+        /// practice.\n+        imaginary_target: BasicBlock,\n+    },\n+\n+    /// A terminator for blocks that only take one path in reality, but where we reserve the right\n+    /// to unwind in borrowck, even if it won't happen in practice. This can arise in infinite loops\n+    /// with no function calls for example.\n+    ///\n+    /// At runtime this is semantically just a goto.\n+    ///\n+    /// Disallowed after drop elaboration.\n+    FalseUnwind {\n+        /// The target normal control flow will take.\n+        real_target: BasicBlock,\n+        /// The imaginary cleanup block link. This particular path will never be taken\n+        /// in practice, but in order to avoid fragility we want to always\n+        /// consider it in borrowck. We don't want to accept programs which\n+        /// pass borrowck only when `panic=abort` or some assertions are disabled\n+        /// due to release vs. debug mode builds. This needs to be an `Option` because\n+        /// of the `remove_noop_landing_pads` and `abort_unwinding_calls` passes.\n+        unwind: Option<BasicBlock>,\n+    },\n+\n+    /// Block ends with an inline assembly block. This is a terminator since\n+    /// inline assembly is allowed to diverge.\n+    InlineAsm {\n+        /// The template for the inline assembly, with placeholders.\n+        template: &'tcx [InlineAsmTemplatePiece],\n+\n+        /// The operands for the inline assembly, as `Operand`s or `Place`s.\n+        operands: Vec<InlineAsmOperand<'tcx>>,\n+\n+        /// Miscellaneous options for the inline assembly.\n+        options: InlineAsmOptions,\n+\n+        /// Source spans for each line of the inline assembly code. These are\n+        /// used to map assembler errors back to the line in the source code.\n+        line_spans: &'tcx [Span],\n+\n+        /// Destination block after the inline assembly returns, unless it is\n+        /// diverging (InlineAsmOptions::NORETURN).\n+        destination: Option<BasicBlock>,\n+\n+        /// Cleanup to be done if the inline assembly unwinds. This is present\n+        /// if and only if InlineAsmOptions::MAY_UNWIND is set.\n+        cleanup: Option<BasicBlock>,\n+    },\n+}\n+\n+/// Information about an assertion failure.\n+#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, PartialOrd)]\n+pub enum AssertKind<O> {\n+    BoundsCheck { len: O, index: O },\n+    Overflow(BinOp, O, O),\n+    OverflowNeg(O),\n+    DivisionByZero(O),\n+    RemainderByZero(O),\n+    ResumedAfterReturn(GeneratorKind),\n+    ResumedAfterPanic(GeneratorKind),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n+pub enum InlineAsmOperand<'tcx> {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        value: Operand<'tcx>,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        place: Option<Place<'tcx>>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        in_value: Operand<'tcx>,\n+        out_place: Option<Place<'tcx>>,\n+    },\n+    Const {\n+        value: Box<Constant<'tcx>>,\n+    },\n+    SymFn {\n+        value: Box<Constant<'tcx>>,\n+    },\n+    SymStatic {\n+        def_id: DefId,\n+    },\n+}\n+\n+/// Type for MIR `Assert` terminator error messages.\n+pub type AssertMessage<'tcx> = AssertKind<Operand<'tcx>>;\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Places\n+\n+/// Places roughly correspond to a \"location in memory.\" Places in MIR are the same mathematical\n+/// object as places in Rust. This of course means that what exactly they are is undecided and part\n+/// of the Rust memory model. However, they will likely contain at least the following pieces of\n+/// information in some form:\n+///\n+///  1. The address in memory that the place refers to.\n+///  2. The provenance with which the place is being accessed.\n+///  3. The type of the place and an optional variant index. See [`PlaceTy`][super::tcx::PlaceTy].\n+///  4. Optionally, some metadata. This exists if and only if the type of the place is not `Sized`.\n+///\n+/// We'll give a description below of how all pieces of the place except for the provenance are\n+/// calculated. We cannot give a description of the provenance, because that is part of the\n+/// undecided aliasing model - we only include it here at all to acknowledge its existence.\n+///\n+/// Each local naturally corresponds to the place `Place { local, projection: [] }`. This place has\n+/// the address of the local's allocation and the type of the local.\n+///\n+/// **Needs clarification:** Unsized locals seem to present a bit of an issue. Their allocation\n+/// can't actually be created on `StorageLive`, because it's unclear how big to make the allocation.\n+/// Furthermore, MIR produces assignments to unsized locals, although that is not permitted under\n+/// `#![feature(unsized_locals)]` in Rust. Besides just putting \"unsized locals are special and\n+/// different\" in a bunch of places, I (JakobDegen) don't know how to incorporate this behavior into\n+/// the current MIR semantics in a clean way - possibly this needs some design work first.\n+///\n+/// For places that are not locals, ie they have a non-empty list of projections, we define the\n+/// values as a function of the parent place, that is the place with its last [`ProjectionElem`]\n+/// stripped. The way this is computed of course depends on the kind of that last projection\n+/// element:\n+///\n+///  - [`Downcast`](ProjectionElem::Downcast): This projection sets the place's variant index to the\n+///    given one, and makes no other changes. A `Downcast` projection on a place with its variant\n+///    index already set is not well-formed.\n+///  - [`Field`](ProjectionElem::Field): `Field` projections take their parent place and create a\n+///    place referring to one of the fields of the type. The resulting address is the parent\n+///    address, plus the offset of the field. The type becomes the type of the field. If the parent\n+///    was unsized and so had metadata associated with it, then the metadata is retained if the\n+///    field is unsized and thrown out if it is sized.\n+///\n+///    These projections are only legal for tuples, ADTs, closures, and generators. If the ADT or\n+///    generator has more than one variant, the parent place's variant index must be set, indicating\n+///    which variant is being used. If it has just one variant, the variant index may or may not be\n+///    included - the single possible variant is inferred if it is not included.\n+///  - [`ConstantIndex`](ProjectionElem::ConstantIndex): Computes an offset in units of `T` into the\n+///    place as described in the documentation for the `ProjectionElem`. The resulting address is\n+///    the parent's address plus that offset, and the type is `T`. This is only legal if the parent\n+///    place has type `[T;  N]` or `[T]` (*not* `&[T]`). Since such a `T` is always sized, any\n+///    resulting metadata is thrown out.\n+///  - [`Subslice`](ProjectionElem::Subslice): This projection calculates an offset and a new\n+///    address in a similar manner as `ConstantIndex`. It is also only legal on `[T; N]` and `[T]`.\n+///    However, this yields a `Place` of type `[T]`, and additionally sets the metadata to be the\n+///    length of the subslice.\n+///  - [`Index`](ProjectionElem::Index): Like `ConstantIndex`, only legal on `[T; N]` or `[T]`.\n+///    However, `Index` additionally takes a local from which the value of the index is computed at\n+///    runtime. Computing the value of the index involves interpreting the `Local` as a\n+///    `Place { local, projection: [] }`, and then computing its value as if done via\n+///    [`Operand::Copy`]. The array/slice is then indexed with the resulting value. The local must\n+///    have type `usize`.\n+///  - [`Deref`](ProjectionElem::Deref): Derefs are the last type of projection, and the most\n+///    complicated. They are only legal on parent places that are references, pointers, or `Box`. A\n+///    `Deref` projection begins by loading a value from the parent place, as if by\n+///    [`Operand::Copy`]. It then dereferences the resulting pointer, creating a place of the\n+///    pointee's type. The resulting address is the address that was stored in the pointer. If the\n+///    pointee type is unsized, the pointer additionally stored the value of the metadata.\n+///\n+/// Computing a place may cause UB. One possibility is that the pointer used for a `Deref` may not\n+/// be suitably aligned. Another possibility is that the place is not in bounds, meaning it does not\n+/// point to an actual allocation.\n+///\n+/// However, if this is actually UB and when the UB kicks in is undecided. This is being discussed\n+/// in [UCG#319]. The options include that every place must obey those rules, that only some places\n+/// must obey them, or that places impose no rules of their own.\n+///\n+/// [UCG#319]: https://github.com/rust-lang/unsafe-code-guidelines/issues/319\n+///\n+/// Rust currently requires that every place obey those two rules. This is checked by MIRI and taken\n+/// advantage of by codegen (via `gep inbounds`). That is possibly subject to change.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, HashStable)]\n+pub struct Place<'tcx> {\n+    pub local: Local,\n+\n+    /// projection out of a place (access a field, deref a pointer, etc)\n+    pub projection: &'tcx List<PlaceElem<'tcx>>,\n+}\n+\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+static_assert_size!(Place<'_>, 16);\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n+pub enum ProjectionElem<V, T> {\n+    Deref,\n+    Field(Field, T),\n+    /// Index into a slice/array.\n+    ///\n+    /// Note that this does not also dereference, and so it does not exactly correspond to slice\n+    /// indexing in Rust. In other words, in the below Rust code:\n+    ///\n+    /// ```rust\n+    /// let x = &[1, 2, 3, 4];\n+    /// let i = 2;\n+    /// x[i];\n+    /// ```\n+    ///\n+    /// The `x[i]` is turned into a `Deref` followed by an `Index`, not just an `Index`. The same\n+    /// thing is true of the `ConstantIndex` and `Subslice` projections below.\n+    Index(V),\n+\n+    /// These indices are generated by slice patterns. Easiest to explain\n+    /// by example:\n+    ///\n+    /// ```ignore (illustrative)\n+    /// [X, _, .._, _, _] => { offset: 0, min_length: 4, from_end: false },\n+    /// [_, X, .._, _, _] => { offset: 1, min_length: 4, from_end: false },\n+    /// [_, _, .._, X, _] => { offset: 2, min_length: 4, from_end: true },\n+    /// [_, _, .._, _, X] => { offset: 1, min_length: 4, from_end: true },\n+    /// ```\n+    ConstantIndex {\n+        /// index or -index (in Python terms), depending on from_end\n+        offset: u64,\n+        /// The thing being indexed must be at least this long. For arrays this\n+        /// is always the exact length.\n+        min_length: u64,\n+        /// Counting backwards from end? This is always false when indexing an\n+        /// array.\n+        from_end: bool,\n+    },\n+\n+    /// These indices are generated by slice patterns.\n+    ///\n+    /// If `from_end` is true `slice[from..slice.len() - to]`.\n+    /// Otherwise `array[from..to]`.\n+    Subslice {\n+        from: u64,\n+        to: u64,\n+        /// Whether `to` counts from the start or end of the array/slice.\n+        /// For `PlaceElem`s this is `true` if and only if the base is a slice.\n+        /// For `ProjectionKind`, this can also be `true` for arrays.\n+        from_end: bool,\n+    },\n+\n+    /// \"Downcast\" to a variant of an enum or a generator.\n+    ///\n+    /// The included Symbol is the name of the variant, used for printing MIR.\n+    Downcast(Option<Symbol>, VariantIdx),\n+}\n+\n+/// Alias for projections as they appear in places, where the base is a place\n+/// and the index is a local.\n+pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n+\n+// This type is fairly frequently used, so we shouldn't unintentionally increase\n+// its size.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+static_assert_size!(PlaceElem<'_>, 24);\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Operands\n+\n+/// An operand in MIR represents a \"value\" in Rust, the definition of which is undecided and part of\n+/// the memory model. One proposal for a definition of values can be found [on UCG][value-def].\n+///\n+/// [value-def]: https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\n+///\n+/// The most common way to create values is via loading a place. Loading a place is an operation\n+/// which reads the memory of the place and converts it to a value. This is a fundamentally *typed*\n+/// operation. The nature of the value produced depends on the type of the conversion. Furthermore,\n+/// there may be other effects: if the type has a validity constraint loading the place might be UB\n+/// if the validity constraint is not met.\n+///\n+/// **Needs clarification:** Ralf proposes that loading a place not have side-effects.\n+/// This is what is implemented in miri today. Are these the semantics we want for MIR? Is this\n+/// something we can even decide without knowing more about Rust's memory model?\n+///\n+/// **Needs clarifiation:** Is loading a place that has its variant index set well-formed? Miri\n+/// currently implements it, but it seems like this may be something to check against in the\n+/// validator.\n+#[derive(Clone, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n+pub enum Operand<'tcx> {\n+    /// Creates a value by loading the given place.\n+    ///\n+    /// Before drop elaboration, the type of the place must be `Copy`. After drop elaboration there\n+    /// is no such requirement.\n+    Copy(Place<'tcx>),\n+\n+    /// Creates a value by performing loading the place, just like the `Copy` operand.\n+    ///\n+    /// This *may* additionally overwrite the place with `uninit` bytes, depending on how we decide\n+    /// in [UCG#188]. You should not emit MIR that may attempt a subsequent second load of this\n+    /// place without first re-initializing it.\n+    ///\n+    /// [UCG#188]: https://github.com/rust-lang/unsafe-code-guidelines/issues/188\n+    Move(Place<'tcx>),\n+\n+    /// Constants are already semantically values, and remain unchanged.\n+    Constant(Box<Constant<'tcx>>),\n+}\n+\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+static_assert_size!(Operand<'_>, 24);\n+\n+///////////////////////////////////////////////////////////////////////////\n+/// Rvalues\n+\n+/// The various kinds of rvalues that can appear in MIR.\n+///\n+/// Not all of these are allowed at every [`MirPhase`] - when this is the case, it's stated below.\n+///\n+/// Computing any rvalue begins by evaluating the places and operands in some order (**Needs\n+/// clarification**: Which order?). These are then used to produce a \"value\" - the same kind of\n+/// value that an [`Operand`] produces.\n+#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n+pub enum Rvalue<'tcx> {\n+    /// Yields the operand unchanged\n+    Use(Operand<'tcx>),\n+\n+    /// Creates an array where each element is the value of the operand.\n+    ///\n+    /// This is the cause of a bug in the case where the repetition count is zero because the value\n+    /// is not dropped, see [#74836].\n+    ///\n+    /// Corresponds to source code like `[x; 32]`.\n+    ///\n+    /// [#74836]: https://github.com/rust-lang/rust/issues/74836\n+    Repeat(Operand<'tcx>, ty::Const<'tcx>),\n+\n+    /// Creates a reference of the indicated kind to the place.\n+    ///\n+    /// There is not much to document here, because besides the obvious parts the semantics of this\n+    /// are essentially entirely a part of the aliasing model. There are many UCG issues discussing\n+    /// exactly what the behavior of this operation should be.\n+    ///\n+    /// `Shallow` borrows are disallowed after drop lowering.\n+    Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n+\n+    /// Creates a pointer/reference to the given thread local.\n+    ///\n+    /// The yielded type is a `*mut T` if the static is mutable, otherwise if the static is extern a\n+    /// `*const T`, and if neither of those apply a `&T`.\n+    ///\n+    /// **Note:** This is a runtime operation that actually executes code and is in this sense more\n+    /// like a function call. Also, eliminating dead stores of this rvalue causes `fn main() {}` to\n+    /// SIGILL for some reason that I (JakobDegen) never got a chance to look into.\n+    ///\n+    /// **Needs clarification**: Are there weird additional semantics here related to the runtime\n+    /// nature of this operation?\n+    ThreadLocalRef(DefId),\n+\n+    /// Creates a pointer with the indicated mutability to the place.\n+    ///\n+    /// This is generated by pointer casts like `&v as *const _` or raw address of expressions like\n+    /// `&raw v` or `addr_of!(v)`.\n+    ///\n+    /// Like with references, the semantics of this operation are heavily dependent on the aliasing\n+    /// model.\n+    AddressOf(Mutability, Place<'tcx>),\n+\n+    /// Yields the length of the place, as a `usize`.\n+    ///\n+    /// If the type of the place is an array, this is the array length. For slices (`[T]`, not\n+    /// `&[T]`) this accesses the place's metadata to determine the length. This rvalue is\n+    /// ill-formed for places of other types.\n+    Len(Place<'tcx>),\n+\n+    /// Performs essentially all of the casts that can be performed via `as`.\n+    ///\n+    /// This allows for casts from/to a variety of types.\n+    ///\n+    /// **FIXME**: Document exactly which `CastKind`s allow which types of casts. Figure out why\n+    /// `ArrayToPointer` and `MutToConstPointer` are special.\n+    Cast(CastKind, Operand<'tcx>, Ty<'tcx>),\n+\n+    /// * `Offset` has the same semantics as [`offset`](pointer::offset), except that the second\n+    ///   parameter may be a `usize` as well.\n+    /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,\n+    ///   raw pointers, or function pointers and return a `bool`. The types of the operands must be\n+    ///   matching, up to the usual caveat of the lifetimes in function pointers.\n+    /// * Left and right shift operations accept signed or unsigned integers not necessarily of the\n+    ///   same type and return a value of the same type as their LHS. Like in Rust, the RHS is\n+    ///   truncated as needed.\n+    /// * The `Bit*` operations accept signed integers, unsigned integers, or bools with matching\n+    ///   types and return a value of that type.\n+    /// * The remaining operations accept signed integers, unsigned integers, or floats with\n+    ///   matching types and return a value of that type.\n+    BinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n+\n+    /// Same as `BinaryOp`, but yields `(T, bool)` instead of `T`. In addition to performing the\n+    /// same computation as the matching `BinaryOp`, checks if the infinite precison result would be\n+    /// unequal to the actual result and sets the `bool` if this is the case.\n+    ///\n+    /// This only supports addition, subtraction, multiplication, and shift operations on integers.\n+    CheckedBinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n+\n+    /// Computes a value as described by the operation.\n+    NullaryOp(NullOp, Ty<'tcx>),\n+\n+    /// Exactly like `BinaryOp`, but less operands.\n+    ///\n+    /// Also does two's-complement arithmetic. Negation requires a signed integer or a float;\n+    /// bitwise not requires a signed integer, unsigned integer, or bool. Both operation kinds\n+    /// return a value with the same type as their operand.\n+    UnaryOp(UnOp, Operand<'tcx>),\n+\n+    /// Computes the discriminant of the place, returning it as an integer of type\n+    /// [`discriminant_ty`]. Returns zero for types without discriminant.\n+    ///\n+    /// The validity requirements for the underlying value are undecided for this rvalue, see\n+    /// [#91095]. Note too that the value of the discriminant is not the same thing as the\n+    /// variant index; use [`discriminant_for_variant`] to convert.\n+    ///\n+    /// [`discriminant_ty`]: crate::ty::Ty::discriminant_ty\n+    /// [#91095]: https://github.com/rust-lang/rust/issues/91095\n+    /// [`discriminant_for_variant`]: crate::ty::Ty::discriminant_for_variant\n+    Discriminant(Place<'tcx>),\n+\n+    /// Creates an aggregate value, like a tuple or struct.\n+    ///\n+    /// This is needed because dataflow analysis needs to distinguish\n+    /// `dest = Foo { x: ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case that `Foo`\n+    /// has a destructor.\n+    ///\n+    /// Disallowed after deaggregation for all aggregate kinds except `Array` and `Generator`. After\n+    /// generator lowering, `Generator` aggregate kinds are disallowed too.\n+    Aggregate(Box<AggregateKind<'tcx>>, Vec<Operand<'tcx>>),\n+\n+    /// Transmutes a `*mut u8` into shallow-initialized `Box<T>`.\n+    ///\n+    /// This is different from a normal transmute because dataflow analysis will treat the box as\n+    /// initialized but its content as uninitialized. Like other pointer casts, this in general\n+    /// affects alias analysis.\n+    ShallowInitBox(Operand<'tcx>, Ty<'tcx>),\n+}\n+\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+static_assert_size!(Rvalue<'_>, 40);\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+pub enum CastKind {\n+    /// An exposing pointer to address cast. A cast between a pointer and an integer type, or\n+    /// between a function pointer and an integer type.\n+    /// See the docs on `expose_addr` for more details.\n+    PointerExposeAddress,\n+    /// An address-to-pointer cast that picks up an exposed provenance.\n+    /// See the docs on `from_exposed_addr` for more details.\n+    PointerFromExposedAddress,\n+    /// All sorts of pointer-to-pointer casts. Note that reference-to-raw-ptr casts are\n+    /// translated into `&raw mut/const *r`, i.e., they are not actually casts.\n+    Pointer(PointerCast),\n+    /// Remaining unclassified casts.\n+    Misc,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+pub enum AggregateKind<'tcx> {\n+    /// The type is of the element\n+    Array(Ty<'tcx>),\n+    Tuple,\n+\n+    /// The second field is the variant index. It's equal to 0 for struct\n+    /// and union expressions. The fourth field is\n+    /// active field number and is present only for union expressions\n+    /// -- e.g., for a union expression `SomeUnion { c: .. }`, the\n+    /// active field index would identity the field `c`\n+    Adt(DefId, VariantIdx, SubstsRef<'tcx>, Option<UserTypeAnnotationIndex>, Option<usize>),\n+\n+    Closure(DefId, SubstsRef<'tcx>),\n+    Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n+}\n+\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+static_assert_size!(AggregateKind<'_>, 48);\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+pub enum NullOp {\n+    /// Returns the size of a value of that type\n+    SizeOf,\n+    /// Returns the minimum alignment of a type\n+    AlignOf,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+pub enum UnOp {\n+    /// The `!` operator for logical inversion\n+    Not,\n+    /// The `-` operator for negation\n+    Neg,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+pub enum BinOp {\n+    /// The `+` operator (addition)\n+    Add,\n+    /// The `-` operator (subtraction)\n+    Sub,\n+    /// The `*` operator (multiplication)\n+    Mul,\n+    /// The `/` operator (division)\n+    ///\n+    /// Division by zero is UB, because the compiler should have inserted checks\n+    /// prior to this.\n+    Div,\n+    /// The `%` operator (modulus)\n+    ///\n+    /// Using zero as the modulus (second operand) is UB, because the compiler\n+    /// should have inserted checks prior to this.\n+    Rem,\n+    /// The `^` operator (bitwise xor)\n+    BitXor,\n+    /// The `&` operator (bitwise and)\n+    BitAnd,\n+    /// The `|` operator (bitwise or)\n+    BitOr,\n+    /// The `<<` operator (shift left)\n+    ///\n+    /// The offset is truncated to the size of the first operand before shifting.\n+    Shl,\n+    /// The `>>` operator (shift right)\n+    ///\n+    /// The offset is truncated to the size of the first operand before shifting.\n+    Shr,\n+    /// The `==` operator (equality)\n+    Eq,\n+    /// The `<` operator (less than)\n+    Lt,\n+    /// The `<=` operator (less than or equal to)\n+    Le,\n+    /// The `!=` operator (not equal to)\n+    Ne,\n+    /// The `>=` operator (greater than or equal to)\n+    Ge,\n+    /// The `>` operator (greater than)\n+    Gt,\n+    /// The `ptr.offset` operator\n+    Offset,\n+}"}, {"sha": "9ccf5aea63ca83c634f4e6969894ef4bb4ea0984", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 6, "deletions": 272, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -1,16 +1,12 @@\n use crate::mir;\n use crate::mir::interpret::Scalar;\n use crate::ty::{self, Ty, TyCtxt};\n-use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use smallvec::{smallvec, SmallVec};\n \n-use super::{\n-    AssertMessage, BasicBlock, InlineAsmOperand, Operand, Place, SourceInfo, Successors,\n-    SuccessorsMut,\n-};\n+use super::{BasicBlock, InlineAsmOperand, Operand, SourceInfo, TerminatorKind};\n+use rustc_ast::InlineAsmTemplatePiece;\n pub use rustc_ast::Mutability;\n use rustc_macros::HashStable;\n-use rustc_span::Span;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Formatter, Write};\n use std::iter;\n@@ -106,278 +102,16 @@ impl<'a> Iterator for SwitchTargetsIter<'a> {\n \n impl<'a> ExactSizeIterator for SwitchTargetsIter<'a> {}\n \n-/// A note on unwinding: Panics may occur during the execution of some terminators. Depending on the\n-/// `-C panic` flag, this may either cause the program to abort or the call stack to unwind. Such\n-/// terminators have a `cleanup: Option<BasicBlock>` field on them. If stack unwinding occurs, then\n-/// once the current function is reached, execution continues at the given basic block, if any. If\n-/// `cleanup` is `None` then no cleanup is performed, and the stack continues unwinding. This is\n-/// equivalent to the execution of a `Resume` terminator.\n-///\n-/// The basic block pointed to by a `cleanup` field must have its `cleanup` flag set. `cleanup`\n-/// basic blocks have a couple restrictions:\n-///  1. All `cleanup` fields in them must be `None`.\n-///  2. `Return` terminators are not allowed in them. `Abort` and `Unwind` terminators are.\n-///  3. All other basic blocks (in the current body) that are reachable from `cleanup` basic blocks\n-///     must also be `cleanup`. This is a part of the type system and checked statically, so it is\n-///     still an error to have such an edge in the CFG even if it's known that it won't be taken at\n-///     runtime.\n-#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n-pub enum TerminatorKind<'tcx> {\n-    /// Block has one successor; we continue execution there.\n-    Goto { target: BasicBlock },\n-\n-    /// Switches based on the computed value.\n-    ///\n-    /// First, evaluates the `discr` operand. The type of the operand must be a signed or unsigned\n-    /// integer, char, or bool, and must match the given type. Then, if the list of switch targets\n-    /// contains the computed value, continues execution at the associated basic block. Otherwise,\n-    /// continues execution at the \"otherwise\" basic block.\n-    ///\n-    /// Target values may not appear more than once.\n-    SwitchInt {\n-        /// The discriminant value being tested.\n-        discr: Operand<'tcx>,\n-\n-        /// The type of value being tested.\n-        /// This is always the same as the type of `discr`.\n-        /// FIXME: remove this redundant information. Currently, it is relied on by pretty-printing.\n-        switch_ty: Ty<'tcx>,\n-\n-        targets: SwitchTargets,\n-    },\n-\n-    /// Indicates that the landing pad is finished and that the process should continue unwinding.\n-    ///\n-    /// Like a return, this marks the end of this invocation of the function.\n-    ///\n-    /// Only permitted in cleanup blocks. `Resume` is not permitted with `-C unwind=abort` after\n-    /// deaggregation runs.\n-    Resume,\n-\n-    /// Indicates that the landing pad is finished and that the process should abort.\n-    ///\n-    /// Used to prevent unwinding for foreign items or with `-C unwind=abort`. Only permitted in\n-    /// cleanup blocks.\n-    Abort,\n-\n-    /// Returns from the function.\n-    ///\n-    /// Like function calls, the exact semantics of returns in Rust are unclear. Returning very\n-    /// likely at least assigns the value currently in the return place (`_0`) to the place\n-    /// specified in the associated `Call` terminator in the calling function, as if assigned via\n-    /// `dest = move _0`. It might additionally do other things, like have side-effects in the\n-    /// aliasing model.\n-    ///\n-    /// If the body is a generator body, this has slightly different semantics; it instead causes a\n-    /// `GeneratorState::Returned(_0)` to be created (as if by an `Aggregate` rvalue) and assigned\n-    /// to the return place.\n-    Return,\n-\n-    /// Indicates a terminator that can never be reached.\n-    ///\n-    /// Executing this terminator is UB.\n-    Unreachable,\n-\n-    /// The behavior of this statement differs significantly before and after drop elaboration.\n-    /// After drop elaboration, `Drop` executes the drop glue for the specified place, after which\n-    /// it continues execution/unwinds at the given basic blocks. It is possible that executing drop\n-    /// glue is special - this would be part of Rust's memory model. (**FIXME**: due we have an\n-    /// issue tracking if drop glue has any interesting semantics in addition to those of a function\n-    /// call?)\n-    ///\n-    /// `Drop` before drop elaboration is a *conditional* execution of the drop glue. Specifically, the\n-    /// `Drop` will be executed if...\n-    ///\n-    /// **Needs clarification**: End of that sentence. This in effect should document the exact\n-    /// behavior of drop elaboration. The following sounds vaguely right, but I'm not quite sure:\n-    ///\n-    /// > The drop glue is executed if, among all statements executed within this `Body`, an assignment to\n-    /// > the place or one of its \"parents\" occurred more recently than a move out of it. This does not\n-    /// > consider indirect assignments.\n-    Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n-\n-    /// Drops the place and assigns a new value to it.\n-    ///\n-    /// This first performs the exact same operation as the pre drop-elaboration `Drop` terminator;\n-    /// it then additionally assigns the `value` to the `place` as if by an assignment statement.\n-    /// This assignment occurs both in the unwind and the regular code paths. The semantics are best\n-    /// explained by the elaboration:\n-    ///\n-    /// ```ignore (MIR)\n-    /// BB0 {\n-    ///   DropAndReplace(P <- V, goto BB1, unwind BB2)\n-    /// }\n-    /// ```\n-    ///\n-    /// becomes\n-    ///\n-    /// ```ignore (MIR)\n-    /// BB0 {\n-    ///   Drop(P, goto BB1, unwind BB2)\n-    /// }\n-    /// BB1 {\n-    ///   // P is now uninitialized\n-    ///   P <- V\n-    /// }\n-    /// BB2 {\n-    ///   // P is now uninitialized -- its dtor panicked\n-    ///   P <- V\n-    /// }\n-    /// ```\n-    ///\n-    /// Disallowed after drop elaboration.\n-    DropAndReplace {\n-        place: Place<'tcx>,\n-        value: Operand<'tcx>,\n-        target: BasicBlock,\n-        unwind: Option<BasicBlock>,\n-    },\n-\n-    /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of\n-    /// the referred to function. The operand types must match the argument types of the function.\n-    /// The return place type must match the return type. The type of the `func` operand must be\n-    /// callable, meaning either a function pointer, a function type, or a closure type.\n-    ///\n-    /// **Needs clarification**: The exact semantics of this. Current backends rely on `move`\n-    /// operands not aliasing the return place. It is unclear how this is justified in MIR, see\n-    /// [#71117].\n-    ///\n-    /// [#71117]: https://github.com/rust-lang/rust/issues/71117\n-    Call {\n-        /// The function that\u2019s being called.\n-        func: Operand<'tcx>,\n-        /// Arguments the function is called with.\n-        /// These are owned by the callee, which is free to modify them.\n-        /// This allows the memory occupied by \"by-value\" arguments to be\n-        /// reused across function calls without duplicating the contents.\n-        args: Vec<Operand<'tcx>>,\n-        /// Where the returned value will be written\n-        destination: Place<'tcx>,\n-        /// Where to go after this call returns. If none, the call necessarily diverges.\n-        target: Option<BasicBlock>,\n-        /// Cleanups to be done if the call unwinds.\n-        cleanup: Option<BasicBlock>,\n-        /// `true` if this is from a call in HIR rather than from an overloaded\n-        /// operator. True for overloaded function call.\n-        from_hir_call: bool,\n-        /// This `Span` is the span of the function, without the dot and receiver\n-        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n-        fn_span: Span,\n-    },\n-\n-    /// Evaluates the operand, which must have type `bool`. If it is not equal to `expected`,\n-    /// initiates a panic. Initiating a panic corresponds to a `Call` terminator with some\n-    /// unspecified constant as the function to call, all the operands stored in the `AssertMessage`\n-    /// as parameters, and `None` for the destination. Keep in mind that the `cleanup` path is not\n-    /// necessarily executed even in the case of a panic, for example in `-C panic=abort`. If the\n-    /// assertion does not fail, execution continues at the specified basic block.\n-    Assert {\n-        cond: Operand<'tcx>,\n-        expected: bool,\n-        msg: AssertMessage<'tcx>,\n-        target: BasicBlock,\n-        cleanup: Option<BasicBlock>,\n-    },\n-\n-    /// Marks a suspend point.\n-    ///\n-    /// Like `Return` terminators in generator bodies, this computes `value` and then a\n-    /// `GeneratorState::Yielded(value)` as if by `Aggregate` rvalue. That value is then assigned to\n-    /// the return place of the function calling this one, and execution continues in the calling\n-    /// function. When next invoked with the same first argument, execution of this function\n-    /// continues at the `resume` basic block, with the second argument written to the `resume_arg`\n-    /// place. If the generator is dropped before then, the `drop` basic block is invoked.\n-    ///\n-    /// Not permitted in bodies that are not generator bodies, or after generator lowering.\n-    ///\n-    /// **Needs clarification**: What about the evaluation order of the `resume_arg` and `value`?\n-    Yield {\n-        /// The value to return.\n-        value: Operand<'tcx>,\n-        /// Where to resume to.\n-        resume: BasicBlock,\n-        /// The place to store the resume argument in.\n-        resume_arg: Place<'tcx>,\n-        /// Cleanup to be done if the generator is dropped at this suspend point.\n-        drop: Option<BasicBlock>,\n-    },\n-\n-    /// Indicates the end of dropping a generator.\n-    ///\n-    /// Semantically just a `return` (from the generators drop glue). Only permitted in the same situations\n-    /// as `yield`.\n-    ///\n-    /// **Needs clarification**: Is that even correct? The generator drop code is always confusing\n-    /// to me, because it's not even really in the current body.\n-    ///\n-    /// **Needs clarification**: Are there type system constraints on these terminators? Should\n-    /// there be a \"block type\" like `cleanup` blocks for them?\n-    GeneratorDrop,\n-\n-    /// A block where control flow only ever takes one real path, but borrowck needs to be more\n-    /// conservative.\n-    ///\n-    /// At runtime this is semantically just a goto.\n-    ///\n-    /// Disallowed after drop elaboration.\n-    FalseEdge {\n-        /// The target normal control flow will take.\n-        real_target: BasicBlock,\n-        /// A block control flow could conceptually jump to, but won't in\n-        /// practice.\n-        imaginary_target: BasicBlock,\n-    },\n-\n-    /// A terminator for blocks that only take one path in reality, but where we reserve the right\n-    /// to unwind in borrowck, even if it won't happen in practice. This can arise in infinite loops\n-    /// with no function calls for example.\n-    ///\n-    /// At runtime this is semantically just a goto.\n-    ///\n-    /// Disallowed after drop elaboration.\n-    FalseUnwind {\n-        /// The target normal control flow will take.\n-        real_target: BasicBlock,\n-        /// The imaginary cleanup block link. This particular path will never be taken\n-        /// in practice, but in order to avoid fragility we want to always\n-        /// consider it in borrowck. We don't want to accept programs which\n-        /// pass borrowck only when `panic=abort` or some assertions are disabled\n-        /// due to release vs. debug mode builds. This needs to be an `Option` because\n-        /// of the `remove_noop_landing_pads` and `abort_unwinding_calls` passes.\n-        unwind: Option<BasicBlock>,\n-    },\n-\n-    /// Block ends with an inline assembly block. This is a terminator since\n-    /// inline assembly is allowed to diverge.\n-    InlineAsm {\n-        /// The template for the inline assembly, with placeholders.\n-        template: &'tcx [InlineAsmTemplatePiece],\n-\n-        /// The operands for the inline assembly, as `Operand`s or `Place`s.\n-        operands: Vec<InlineAsmOperand<'tcx>>,\n-\n-        /// Miscellaneous options for the inline assembly.\n-        options: InlineAsmOptions,\n-\n-        /// Source spans for each line of the inline assembly code. These are\n-        /// used to map assembler errors back to the line in the source code.\n-        line_spans: &'tcx [Span],\n-\n-        /// Destination block after the inline assembly returns, unless it is\n-        /// diverging (InlineAsmOptions::NORETURN).\n-        destination: Option<BasicBlock>,\n-\n-        /// Cleanup to be done if the inline assembly unwinds. This is present\n-        /// if and only if InlineAsmOptions::MAY_UNWIND is set.\n-        cleanup: Option<BasicBlock>,\n-    },\n-}\n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct Terminator<'tcx> {\n     pub source_info: SourceInfo,\n     pub kind: TerminatorKind<'tcx>,\n }\n \n+pub type Successors<'a> = impl Iterator<Item = BasicBlock> + 'a;\n+pub type SuccessorsMut<'a> =\n+    iter::Chain<std::option::IntoIter<&'a mut BasicBlock>, slice::IterMut<'a, BasicBlock>>;\n+\n impl<'tcx> Terminator<'tcx> {\n     pub fn successors(&self) -> Successors<'_> {\n         self.kind.successors()"}, {"sha": "e165dd4f17c15d73c5e5ff1fbf7f516e1895ae7e", "filename": "triagebot.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -316,7 +316,12 @@ cc = [\"@ehuss\"]\n cc = [\"@rust-lang/clippy\"]\n \n [mentions.\"src/tools/miri\"]\n+message = \"The Miri submodule was changed\"\n cc = [\"@rust-lang/miri\"]\n \n [mentions.\"src/tools/rustfmt\"]\n cc = [\"@rust-lang/rustfmt\"]\n+\n+[mentions.\"compiler/rustc_middle/src/mir/syntax.rs\"]\n+message = \"This PR changes MIR\"\n+cc = [\"@oli-obk\", \"@RalfJung\", \"@JakobDegen\", \"@davidtwco\"]"}]}