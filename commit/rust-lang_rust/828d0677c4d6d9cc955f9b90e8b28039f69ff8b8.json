{"sha": "828d0677c4d6d9cc955f9b90e8b28039f69ff8b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyOGQwNjc3YzRkNmQ5Y2M5NTVmOWI5MGU4YjI4MDM5ZjY5ZmY4Yjg=", "commit": {"author": {"name": "Haitao Li", "email": "lihaitao@gmail.com", "date": "2012-04-11T12:39:15Z"}, "committer": {"name": "Haitao Li", "email": "lihaitao@gmail.com", "date": "2012-04-12T09:33:01Z"}, "message": "libstd: Handle test results in serial\n\nIssue #782", "tree": {"sha": "95bcd05b731cb1e37f75c7a12005b1c152f083d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95bcd05b731cb1e37f75c7a12005b1c152f083d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/828d0677c4d6d9cc955f9b90e8b28039f69ff8b8", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/828d0677c4d6d9cc955f9b90e8b28039f69ff8b8", "html_url": "https://github.com/rust-lang/rust/commit/828d0677c4d6d9cc955f9b90e8b28039f69ff8b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/828d0677c4d6d9cc955f9b90e8b28039f69ff8b8/comments", "author": {"login": "lht", "id": 19508, "node_id": "MDQ6VXNlcjE5NTA4", "avatar_url": "https://avatars.githubusercontent.com/u/19508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lht", "html_url": "https://github.com/lht", "followers_url": "https://api.github.com/users/lht/followers", "following_url": "https://api.github.com/users/lht/following{/other_user}", "gists_url": "https://api.github.com/users/lht/gists{/gist_id}", "starred_url": "https://api.github.com/users/lht/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lht/subscriptions", "organizations_url": "https://api.github.com/users/lht/orgs", "repos_url": "https://api.github.com/users/lht/repos", "events_url": "https://api.github.com/users/lht/events{/privacy}", "received_events_url": "https://api.github.com/users/lht/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lht", "id": 19508, "node_id": "MDQ6VXNlcjE5NTA4", "avatar_url": "https://avatars.githubusercontent.com/u/19508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lht", "html_url": "https://github.com/lht", "followers_url": "https://api.github.com/users/lht/followers", "following_url": "https://api.github.com/users/lht/following{/other_user}", "gists_url": "https://api.github.com/users/lht/gists{/gist_id}", "starred_url": "https://api.github.com/users/lht/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lht/subscriptions", "organizations_url": "https://api.github.com/users/lht/orgs", "repos_url": "https://api.github.com/users/lht/repos", "events_url": "https://api.github.com/users/lht/events{/privacy}", "received_events_url": "https://api.github.com/users/lht/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "891dc84be28639b659e332ab007894b3032f9ce8", "url": "https://api.github.com/repos/rust-lang/rust/commits/891dc84be28639b659e332ab007894b3032f9ce8", "html_url": "https://github.com/rust-lang/rust/commit/891dc84be28639b659e332ab007894b3032f9ce8"}], "stats": {"total": 77, "additions": 44, "deletions": 33}, "files": [{"sha": "d0814c01f377a258b7cea069b5e21d947e1da350", "filename": "src/libstd/test.rs", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/828d0677c4d6d9cc955f9b90e8b28039f69ff8b8/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/828d0677c4d6d9cc955f9b90e8b28039f69ff8b8/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=828d0677c4d6d9cc955f9b90e8b28039f69ff8b8", "patch": "@@ -102,13 +102,44 @@ type console_test_state =\n fn run_tests_console(opts: test_opts,\n                      tests: [test_desc]) -> bool {\n \n-    fn callback(event: testevent, st: console_test_state) {\n-        alt event {\n+    let log_out = alt opts.logfile {\n+        some(path) {\n+            alt io::file_writer(path, [io::create, io::truncate]) {\n+                result::ok(w) { some(w) }\n+                result::err(s) {\n+                    fail(#fmt(\"can't open output file: %s\", s))\n+                }\n+            }\n+        }\n+        none { none }\n+    };\n+\n+    let st =\n+        @{out: io::stdout(),\n+          log_out: log_out,\n+          use_color: use_color(),\n+          mut total: 0u,\n+          mut passed: 0u,\n+          mut failed: 0u,\n+          mut ignored: 0u,\n+          mut failures: []};\n+\n+    let p = comm::port::<testevent>();\n+    let reporter = comm::chan(p);\n+\n+    task::spawn {||\n+      run_tests(opts, tests, reporter);\n+    };\n+\n+    while true {\n+        alt comm::recv(p) {\n           te_filtered(filtered_tests) {\n             st.total = vec::len(filtered_tests);\n             st.out.write_line(#fmt[\"\\nrunning %u tests\", st.total]);\n           }\n-          te_wait(test) { st.out.write_str(#fmt[\"test %s ... \", test.name]); }\n+          te_wait(test) {\n+            st.out.write_str(#fmt[\"test %s ... \", test.name]);\n+          }\n           te_result(test, result) {\n             alt st.log_out {\n                 some(f) {\n@@ -135,33 +166,12 @@ fn run_tests_console(opts: test_opts,\n               }\n             }\n           }\n+          te_done {\n+              break;\n+          }\n         }\n     }\n \n-    let log_out = alt opts.logfile {\n-        some(path) {\n-            alt io::file_writer(path, [io::create, io::truncate]) {\n-                result::ok(w) { some(w) }\n-                result::err(s) {\n-                    fail(#fmt(\"can't open output file: %s\", s))\n-                }\n-            }\n-        }\n-        none { none }\n-    };\n-\n-    let st =\n-        @{out: io::stdout(),\n-          log_out: log_out,\n-          use_color: use_color(),\n-          mut total: 0u,\n-          mut passed: 0u,\n-          mut failed: 0u,\n-          mut ignored: 0u,\n-          mut failures: []};\n-\n-    run_tests(opts, tests, bind callback(_, st));\n-\n     assert (st.passed + st.failed + st.ignored == st.total);\n     let success = st.failed == 0u;\n \n@@ -171,7 +181,6 @@ fn run_tests_console(opts: test_opts,\n \n     st.out.write_str(#fmt[\"\\nresult: \"]);\n     if success {\n-        // There's no parallelism at this point so it's safe to use color\n         write_ok(st.out, true);\n     } else { write_failed(st.out, true); }\n     st.out.write_str(#fmt[\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n@@ -264,15 +273,16 @@ enum testevent {\n     te_filtered([test_desc]),\n     te_wait(test_desc),\n     te_result(test_desc, test_result),\n+    te_done,\n }\n \n type monitor_msg = (test_desc, test_result);\n \n fn run_tests(opts: test_opts, tests: [test_desc],\n-             callback: fn@(testevent)) {\n+             reporter: comm::chan<testevent>) {\n \n     let mut filtered_tests = filter_tests(opts, tests);\n-    callback(te_filtered(filtered_tests));\n+    comm::send(reporter, te_filtered(filtered_tests));\n \n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n@@ -294,7 +304,7 @@ fn run_tests(opts: test_opts, tests: [test_desc],\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                callback(te_wait(test));\n+                comm::send(reporter, te_wait(test));\n             }\n             run_test(test, ch);\n             wait_idx += 1u;\n@@ -303,12 +313,13 @@ fn run_tests(opts: test_opts, tests: [test_desc],\n \n         let (test, result) = comm::recv(p);\n         if concurrency != 1u {\n-            callback(te_wait(test));\n+            comm::send(reporter, te_wait(test));\n         }\n-        callback(te_result(test, result));\n+        comm::send(reporter, te_result(test, result));\n         wait_idx -= 1u;\n         done_idx += 1u;\n     }\n+    comm::send(reporter, te_done);\n }\n \n // Windows tends to dislike being overloaded with threads."}]}