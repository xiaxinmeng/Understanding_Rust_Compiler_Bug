{"sha": "416e62924e200eb75dff4b7d622b5aa7ea8b691a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNmU2MjkyNGUyMDBlYjc1ZGZmNGI3ZDYyMmI1YWE3ZWE4YjY5MWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-12T11:13:42Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-19T08:29:30Z"}, "message": "Rename the code that replaces unbound variables to \"freshen\" rather than \"skolemize\" -- strictly speaking, this is not skolemization, because it is not discharging quantifiers. Also, the trait selection code will still be doing true skolemization, so it would be a confusing overlap of names.", "tree": {"sha": "4c28b2cd130ce8d1eb30e7ab3b7eb5ed48b81f67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c28b2cd130ce8d1eb30e7ab3b7eb5ed48b81f67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/416e62924e200eb75dff4b7d622b5aa7ea8b691a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/416e62924e200eb75dff4b7d622b5aa7ea8b691a", "html_url": "https://github.com/rust-lang/rust/commit/416e62924e200eb75dff4b7d622b5aa7ea8b691a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/416e62924e200eb75dff4b7d622b5aa7ea8b691a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "html_url": "https://github.com/rust-lang/rust/commit/3cf0fbeee9b6e90de6e7d44ab9461963729f0365"}], "stats": {"total": 204, "additions": 104, "deletions": 100}, "files": [{"sha": "ebff854060caec7cfb107e4ad1db2aeb2b9af9bd", "filename": "src/librustc/middle/infer/freshen.rs", "status": "renamed", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/416e62924e200eb75dff4b7d622b5aa7ea8b691a/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416e62924e200eb75dff4b7d622b5aa7ea8b691a/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=416e62924e200eb75dff4b7d622b5aa7ea8b691a", "patch": "@@ -8,21 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Skolemization is the process of replacing unknown variables with fresh types. The idea is that\n-//! the type, after skolemization, contains no inference variables but instead contains either a\n+//! Freshening is the process of replacing unknown variables with fresh types. The idea is that\n+//! the type, after freshening, contains no inference variables but instead contains either a\n //! value for each variable or fresh \"arbitrary\" types wherever a variable would have been.\n //!\n-//! Skolemization is used primarily to get a good type for inserting into a cache. The result\n+//! Freshening is used primarily to get a good type for inserting into a cache. The result\n //! summarizes what the type inferencer knows \"so far\". The primary place it is used right now is\n //! in the trait matching algorithm, which needs to be able to cache whether an `impl` self type\n //! matches some other type X -- *without* affecting `X`. That means if that if the type `X` is in\n //! fact an unbound type variable, we want the match to be regarded as ambiguous, because depending\n //! on what type that type variable is ultimately assigned, the match may or may not succeed.\n //!\n-//! Note that you should be careful not to allow the output of skolemization to leak to the user in\n-//! error messages or in any other form. Skolemization is only really useful as an internal detail.\n+//! Note that you should be careful not to allow the output of freshening to leak to the user in\n+//! error messages or in any other form. Freshening is only really useful as an internal detail.\n //!\n-//! __An important detail concerning regions.__ The skolemizer also replaces *all* regions with\n+//! __An important detail concerning regions.__ The freshener also replaces *all* regions with\n //! 'static. The reason behind this is that, in general, we do not take region relationships into\n //! account when making type-overloaded decisions. This is important because of the design of the\n //! region inferencer, which is not based on unification but rather on accumulating and then\n@@ -39,47 +39,47 @@ use std::collections::hash_map;\n use super::InferCtxt;\n use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n \n-pub struct TypeSkolemizer<'a, 'tcx:'a> {\n+pub struct TypeFreshener<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    skolemization_count: uint,\n-    skolemization_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n+    freshen_count: uint,\n+    freshen_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n-impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeSkolemizer<'a, 'tcx> {\n-        TypeSkolemizer {\n+impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeFreshener<'a, 'tcx> {\n+        TypeFreshener {\n             infcx: infcx,\n-            skolemization_count: 0,\n-            skolemization_map: hash_map::HashMap::new(),\n+            freshen_count: 0,\n+            freshen_map: hash_map::HashMap::new(),\n         }\n     }\n \n-    fn skolemize<F>(&mut self,\n-                    opt_ty: Option<Ty<'tcx>>,\n-                    key: ty::InferTy,\n-                    skolemizer: F)\n-                    -> Ty<'tcx> where\n+    fn freshen<F>(&mut self,\n+                  opt_ty: Option<Ty<'tcx>>,\n+                  key: ty::InferTy,\n+                  freshener: F)\n+                  -> Ty<'tcx> where\n         F: FnOnce(uint) -> ty::InferTy,\n     {\n         match opt_ty {\n             Some(ty) => { return ty.fold_with(self); }\n             None => { }\n         }\n \n-        match self.skolemization_map.entry(key) {\n+        match self.freshen_map.entry(key) {\n             hash_map::Occupied(entry) => *entry.get(),\n             hash_map::Vacant(entry) => {\n-                let index = self.skolemization_count;\n-                self.skolemization_count += 1;\n-                let t = ty::mk_infer(self.infcx.tcx, skolemizer(index));\n+                let index = self.freshen_count;\n+                self.freshen_count += 1;\n+                let t = ty::mk_infer(self.infcx.tcx, freshener(index));\n                 entry.set(t);\n                 t\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n+impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> &'b ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -106,37 +106,37 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n-                self.skolemize(self.infcx.type_variables.borrow().probe(v),\n+                self.freshen(self.infcx.type_variables.borrow().probe(v),\n                                ty::TyVar(v),\n-                               ty::SkolemizedTy)\n+                               ty::FreshTy)\n             }\n \n             ty::ty_infer(ty::IntVar(v)) => {\n-                self.skolemize(self.infcx.probe_var(v),\n-                               ty::IntVar(v),\n-                               ty::SkolemizedIntTy)\n+                self.freshen(self.infcx.probe_var(v),\n+                             ty::IntVar(v),\n+                             ty::FreshIntTy)\n             }\n \n             ty::ty_infer(ty::FloatVar(v)) => {\n-                self.skolemize(self.infcx.probe_var(v),\n-                               ty::FloatVar(v),\n-                               ty::SkolemizedIntTy)\n+                self.freshen(self.infcx.probe_var(v),\n+                             ty::FloatVar(v),\n+                             ty::FreshIntTy)\n             }\n \n-            ty::ty_infer(ty::SkolemizedTy(c)) |\n-            ty::ty_infer(ty::SkolemizedIntTy(c)) => {\n-                if c >= self.skolemization_count {\n+            ty::ty_infer(ty::FreshTy(c)) |\n+            ty::ty_infer(ty::FreshIntTy(c)) => {\n+                if c >= self.freshen_count {\n                     self.tcx().sess.bug(\n-                        format!(\"Encountered a skolemized type with id {} \\\n+                        format!(\"Encountered a freshend type with id {} \\\n                                  but our counter is only at {}\",\n                                 c,\n-                                self.skolemization_count).as_slice());\n+                                self.freshen_count).as_slice());\n                 }\n                 t\n             }\n \n             ty::ty_open(..) => {\n-                self.tcx().sess.bug(\"Cannot skolemize an open existential type\");\n+                self.tcx().sess.bug(\"Cannot freshen an open existential type\");\n             }\n \n             ty::ty_bool |", "previous_filename": "src/librustc/middle/infer/skolemize.rs"}, {"sha": "c58b99e0ae2b71906eccb4a45ee8cef89c55f488", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/416e62924e200eb75dff4b7d622b5aa7ea8b691a/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416e62924e200eb75dff4b7d622b5aa7ea8b691a/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=416e62924e200eb75dff4b7d622b5aa7ea8b691a", "patch": "@@ -19,7 +19,7 @@ pub use self::TypeOrigin::*;\n pub use self::ValuePairs::*;\n pub use self::fixup_err::*;\n pub use middle::ty::IntVarValue;\n-pub use self::skolemize::TypeSkolemizer;\n+pub use self::freshen::TypeFreshener;\n \n use middle::subst;\n use middle::subst::Substs;\n@@ -57,7 +57,7 @@ pub mod lattice;\n pub mod lub;\n pub mod region_inference;\n pub mod resolve;\n-mod skolemize;\n+mod freshen;\n pub mod sub;\n pub mod type_variable;\n pub mod unify;\n@@ -505,8 +505,8 @@ pub struct CombinedSnapshot {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn skolemize<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n-        t.fold_with(&mut self.skolemizer())\n+    pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n+        t.fold_with(&mut self.freshener())\n     }\n \n     pub fn type_var_diverges(&'a self, ty: Ty) -> bool {\n@@ -516,8 +516,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn skolemizer<'b>(&'b self) -> TypeSkolemizer<'b, 'tcx> {\n-        skolemize::TypeSkolemizer::new(self)\n+    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n+        freshen::TypeFreshener::new(self)\n     }\n \n     pub fn combine_fields<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)"}, {"sha": "ce59f5285dbc7b94ad08938c561459f1648b601d", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/416e62924e200eb75dff4b7d622b5aa7ea8b691a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416e62924e200eb75dff4b7d622b5aa7ea8b691a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=416e62924e200eb75dff4b7d622b5aa7ea8b691a", "patch": "@@ -30,7 +30,7 @@ use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::ty::{mod, Ty, RegionEscape};\n use middle::infer;\n-use middle::infer::{InferCtxt, TypeSkolemizer};\n+use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n use std::cell::RefCell;\n use std::collections::hash_map::HashMap;\n@@ -44,12 +44,12 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n     param_env: &'cx ty::ParameterEnvironment<'tcx>,\n     typer: &'cx (Typer<'tcx>+'cx),\n \n-    /// Skolemizer used specifically for skolemizing entries on the\n+    /// Freshener used specifically for skolemizing entries on the\n     /// obligation stack. This ensures that all entries on the stack\n     /// at one time will have the same set of skolemized entries,\n     /// which is important for checking for trait bounds that\n     /// recursively require themselves.\n-    skolemizer: TypeSkolemizer<'cx, 'tcx>,\n+    freshener: TypeFreshener<'cx, 'tcx>,\n \n     /// If true, indicates that the evaluation should be conservative\n     /// and consider the possibility of types outside this crate.\n@@ -73,8 +73,8 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     obligation: &'prev TraitObligation<'tcx>,\n \n     /// Trait ref from `obligation` but skolemized with the\n-    /// selection-context's skolemizer. Used to check for recursion.\n-    skol_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+    /// selection-context's freshener. Used to check for recursion.\n+    fresh_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n \n     previous: Option<&'prev TraitObligationStack<'prev, 'tcx>>\n }\n@@ -172,7 +172,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             infcx: infcx,\n             param_env: param_env,\n             typer: typer,\n-            skolemizer: infcx.skolemizer(),\n+            freshener: infcx.freshener(),\n             intercrate: false,\n         }\n     }\n@@ -185,7 +185,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             infcx: infcx,\n             param_env: param_env,\n             typer: typer,\n-            skolemizer: infcx.skolemizer(),\n+            freshener: infcx.freshener(),\n             intercrate: true,\n         }\n     }\n@@ -347,16 +347,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // This suffices to allow chains like `FnMut` implemented in\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n-        let input_types = stack.skol_trait_ref.value.input_types();\n-        let unbound_input_types = input_types.iter().any(|&t| ty::type_is_skolemized(t));\n+        let input_types = stack.fresh_trait_ref.value.input_types();\n+        let unbound_input_types = input_types.iter().any(|&t| ty::type_is_fresh(t));\n         if\n             unbound_input_types &&\n              (self.intercrate ||\n               stack.iter().skip(1).any(\n-                  |prev| stack.skol_trait_ref.value.def_id == prev.skol_trait_ref.value.def_id))\n+                  |prev| stack.fresh_trait_ref.value.def_id == prev.fresh_trait_ref.value.def_id))\n         {\n             debug!(\"evaluate_stack({}) --> unbound argument, recursion -->  ambiguous\",\n-                   stack.skol_trait_ref.repr(self.tcx()));\n+                   stack.fresh_trait_ref.repr(self.tcx()));\n             return EvaluatedToAmbig;\n         }\n \n@@ -373,19 +373,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // `Option<Box<List<T>>>` is `Send` if `Box<List<T>>` is\n         // `Send`.\n         //\n-        // Note that we do this comparison using the `skol_trait_ref`\n+        // Note that we do this comparison using the `fresh_trait_ref`\n         // fields. Because these have all been skolemized using\n-        // `self.skolemizer`, we can be sure that (a) this will not\n+        // `self.freshener`, we can be sure that (a) this will not\n         // affect the inferencer state and (b) that if we see two\n         // skolemized types with the same index, they refer to the\n         // same unbound type variable.\n         if\n             stack.iter()\n             .skip(1) // skip top-most frame\n-            .any(|prev| stack.skol_trait_ref == prev.skol_trait_ref)\n+            .any(|prev| stack.fresh_trait_ref == prev.fresh_trait_ref)\n         {\n             debug!(\"evaluate_stack({}) --> recursive\",\n-                   stack.skol_trait_ref.repr(self.tcx()));\n+                   stack.fresh_trait_ref.repr(self.tcx()));\n             return EvaluatedToOk;\n         }\n \n@@ -445,20 +445,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // Check the cache. Note that we skolemize the trait-ref\n-        // separately rather than using `stack.skol_trait_ref` -- this\n+        // separately rather than using `stack.fresh_trait_ref` -- this\n         // is because we want the unbound variables to be replaced\n         // with fresh skolemized types starting from index 0.\n-        let cache_skol_trait_ref =\n-            self.infcx.skolemize(stack.obligation.trait_ref.clone());\n-        debug!(\"candidate_from_obligation(cache_skol_trait_ref={}, obligation={})\",\n-               cache_skol_trait_ref.repr(self.tcx()),\n+        let cache_fresh_trait_ref =\n+            self.infcx.freshen(stack.obligation.trait_ref.clone());\n+        debug!(\"candidate_from_obligation(cache_fresh_trait_ref={}, obligation={})\",\n+               cache_fresh_trait_ref.repr(self.tcx()),\n                stack.repr(self.tcx()));\n         assert!(!stack.obligation.trait_ref.has_escaping_regions());\n \n-        match self.check_candidate_cache(cache_skol_trait_ref.clone()) {\n+        match self.check_candidate_cache(cache_fresh_trait_ref.clone()) {\n             Some(c) => {\n-                debug!(\"CACHE HIT: cache_skol_trait_ref={}, candidate={}\",\n-                       cache_skol_trait_ref.repr(self.tcx()),\n+                debug!(\"CACHE HIT: cache_fresh_trait_ref={}, candidate={}\",\n+                       cache_fresh_trait_ref.repr(self.tcx()),\n                        c.repr(self.tcx()));\n                 return c;\n             }\n@@ -467,9 +467,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // If no match, compute result and insert into cache.\n         let candidate = self.candidate_from_obligation_no_cache(stack);\n-        debug!(\"CACHE MISS: cache_skol_trait_ref={}, candidate={}\",\n-               cache_skol_trait_ref.repr(self.tcx()), candidate.repr(self.tcx()));\n-        self.insert_candidate_cache(cache_skol_trait_ref, candidate.clone());\n+        debug!(\"CACHE MISS: cache_fresh_trait_ref={}, candidate={}\",\n+               cache_fresh_trait_ref.repr(self.tcx()), candidate.repr(self.tcx()));\n+        self.insert_candidate_cache(cache_fresh_trait_ref, candidate.clone());\n         candidate\n     }\n \n@@ -569,7 +569,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn pick_candidate_cache(&self,\n-                            cache_skol_trait_ref: &Rc<ty::PolyTraitRef<'tcx>>)\n+                            cache_fresh_trait_ref: &Rc<ty::PolyTraitRef<'tcx>>)\n                             -> &SelectionCache<'tcx>\n     {\n         // High-level idea: we have to decide whether to consult the\n@@ -591,7 +591,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // If the trait refers to any parameters in scope, then use\n         // the cache of the param-environment.\n         if\n-            cache_skol_trait_ref.value.input_types().iter().any(\n+            cache_fresh_trait_ref.value.input_types().iter().any(\n                 |&t| ty::type_has_self(t) || ty::type_has_params(t))\n         {\n             return &self.param_env.selection_cache;\n@@ -604,7 +604,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // See the discussion in doc.rs for more details.\n         if\n             !self.param_env.caller_bounds.is_empty() &&\n-            cache_skol_trait_ref.value.input_types().iter().any(\n+            cache_fresh_trait_ref.value.input_types().iter().any(\n                 |&t| ty::type_has_ty_infer(t))\n         {\n             return &self.param_env.selection_cache;\n@@ -615,21 +615,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn check_candidate_cache(&mut self,\n-                             cache_skol_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                             cache_fresh_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                              -> Option<SelectionResult<'tcx, Candidate<'tcx>>>\n     {\n-        let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n+        let cache = self.pick_candidate_cache(&cache_fresh_trait_ref);\n         let hashmap = cache.hashmap.borrow();\n-        hashmap.get(&cache_skol_trait_ref).map(|c| (*c).clone())\n+        hashmap.get(&cache_fresh_trait_ref).map(|c| (*c).clone())\n     }\n \n     fn insert_candidate_cache(&mut self,\n-                              cache_skol_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+                              cache_fresh_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n                               candidate: SelectionResult<'tcx, Candidate<'tcx>>)\n     {\n-        let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n+        let cache = self.pick_candidate_cache(&cache_fresh_trait_ref);\n         let mut hashmap = cache.hashmap.borrow_mut();\n-        hashmap.insert(cache_skol_trait_ref, candidate);\n+        hashmap.insert(cache_fresh_trait_ref, candidate);\n     }\n \n     fn assemble_candidates<'o>(&mut self,\n@@ -1269,8 +1269,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::ty_open(_) |\n-            ty::ty_infer(ty::SkolemizedTy(_)) |\n-            ty::ty_infer(ty::SkolemizedIntTy(_)) => {\n+            ty::ty_infer(ty::FreshTy(_)) |\n+            ty::ty_infer(ty::FreshIntTy(_)) => {\n                 self.tcx().sess.bug(\n                     format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n@@ -1831,11 +1831,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             obligation: &'o TraitObligation<'tcx>)\n                             -> TraitObligationStack<'o, 'tcx>\n     {\n-        let skol_trait_ref = obligation.trait_ref.fold_with(&mut self.skolemizer);\n+        let fresh_trait_ref = obligation.trait_ref.fold_with(&mut self.freshener);\n \n         TraitObligationStack {\n             obligation: obligation,\n-            skol_trait_ref: skol_trait_ref,\n+            fresh_trait_ref: fresh_trait_ref,\n             previous: previous_stack.map(|p| p), // FIXME variance\n         }\n     }"}, {"sha": "a25e4087905dde5bd3e162890f750d87545d9086", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/416e62924e200eb75dff4b7d622b5aa7ea8b691a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416e62924e200eb75dff4b7d622b5aa7ea8b691a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=416e62924e200eb75dff4b7d622b5aa7ea8b691a", "patch": "@@ -1538,12 +1538,16 @@ pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n     FloatVar(FloatVid),\n-    SkolemizedTy(uint),\n+\n+    /// A `FreshTy` is one that is generated as a replacement for an\n+    /// unbound type variable. This is convenient for caching etc. See\n+    /// `middle::infer::freshen` for more details.\n+    FreshTy(uint),\n \n     // FIXME -- once integral fallback is impl'd, we should remove\n     // this type. It's only needed to prevent spurious errors for\n     // integers whose type winds up never being constrained.\n-    SkolemizedIntTy(uint),\n+    FreshIntTy(uint),\n }\n \n impl Copy for InferTy {}\n@@ -1610,8 +1614,8 @@ impl fmt::Show for InferTy {\n             TyVar(ref v) => v.fmt(f),\n             IntVar(ref v) => v.fmt(f),\n             FloatVar(ref v) => v.fmt(f),\n-            SkolemizedTy(v) => write!(f, \"SkolemizedTy({})\", v),\n-            SkolemizedIntTy(v) => write!(f, \"SkolemizedIntTy({})\", v),\n+            FreshTy(v) => write!(f, \"FreshTy({})\", v),\n+            FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n         }\n     }\n }\n@@ -2986,7 +2990,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             // Scalar and unique types are sendable, and durable\n-            ty_infer(ty::SkolemizedIntTy(_)) |\n+            ty_infer(ty::FreshIntTy(_)) |\n             ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(_) | ty::ty_char => {\n                 TC::None\n@@ -3592,10 +3596,10 @@ pub fn type_is_integral(ty: Ty) -> bool {\n     }\n }\n \n-pub fn type_is_skolemized(ty: Ty) -> bool {\n+pub fn type_is_fresh(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_infer(SkolemizedTy(_)) => true,\n-      ty_infer(SkolemizedIntTy(_)) => true,\n+      ty_infer(FreshTy(_)) => true,\n+      ty_infer(FreshIntTy(_)) => true,\n       _ => false\n     }\n }\n@@ -4428,8 +4432,8 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_infer(TyVar(_)) => \"inferred type\".to_string(),\n         ty_infer(IntVar(_)) => \"integral variable\".to_string(),\n         ty_infer(FloatVar(_)) => \"floating-point variable\".to_string(),\n-        ty_infer(SkolemizedTy(_)) => \"skolemized type\".to_string(),\n-        ty_infer(SkolemizedIntTy(_)) => \"skolemized integral type\".to_string(),\n+        ty_infer(FreshTy(_)) => \"skolemized type\".to_string(),\n+        ty_infer(FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n         ty_param(ref p) => {\n             if p.space == subst::SelfSpace {\n                 \"Self\".to_string()\n@@ -5594,7 +5598,7 @@ pub fn object_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a skolemized type.\n-    let open_ty = ty::mk_infer(tcx, SkolemizedTy(0));\n+    let open_ty = ty::mk_infer(tcx, FreshTy(0));\n \n     let opt_trait_ref = opt_principal.map_or(Vec::new(), |principal| {\n         let substs = principal.substs().with_self_ty(open_ty);"}, {"sha": "6c00aa546f3874164bd971f95db58f8a86e451d7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/416e62924e200eb75dff4b7d622b5aa7ea8b691a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416e62924e200eb75dff4b7d622b5aa7ea8b691a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=416e62924e200eb75dff4b7d622b5aa7ea8b691a", "patch": "@@ -374,8 +374,8 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             ty::IntVar(ref vid) if print_var_ids => vid.repr(cx),\n             ty::FloatVar(ref vid) if print_var_ids => vid.repr(cx),\n             ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => format!(\"_\"),\n-            ty::SkolemizedTy(v) => format!(\"SkolemizedTy({})\", v),\n-            ty::SkolemizedIntTy(v) => format!(\"SkolemizedIntTy({})\", v)\n+            ty::FreshTy(v) => format!(\"FreshTy({})\", v),\n+            ty::FreshIntTy(v) => format!(\"FreshIntTy({})\", v)\n         }\n     }\n "}, {"sha": "a8e88eca0e19f1f49216bf8d44d71d9628377fb2", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/416e62924e200eb75dff4b7d622b5aa7ea8b691a/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/416e62924e200eb75dff4b7d622b5aa7ea8b691a/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=416e62924e200eb75dff4b7d622b5aa7ea8b691a", "patch": "@@ -848,12 +848,12 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    // Use skolemize to simultaneously replace all type variables with\n+    // Use freshen to simultaneously replace all type variables with\n     // their bindings and replace all regions with 'static.  This is\n     // sort of overkill because we do not expect there to be any\n-    // unbound type variables, hence no skolemized types should ever\n-    // be inserted.\n-    let vtable = vtable.fold_with(&mut infcx.skolemizer());\n+    // unbound type variables, hence no `TyFresh` types should ever be\n+    // inserted.\n+    let vtable = vtable.fold_with(&mut infcx.freshener());\n \n     info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n     ccx.trait_cache().borrow_mut().insert(trait_ref,"}]}