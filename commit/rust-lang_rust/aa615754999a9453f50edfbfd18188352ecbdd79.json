{"sha": "aa615754999a9453f50edfbfd18188352ecbdd79", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNjE1NzU0OTk5YTk0NTNmNTBlZGZiZmQxODE4ODM1MmVjYmRkNzk=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-08-29T14:25:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-29T14:25:28Z"}, "message": "Rollup merge of #88173 - camelid:refactor-markdown-length-limit, r=GuillaumeGomez\n\nRefactor Markdown length-limited summary implementation\n\nThis PR is a new approach to #79749.\n\nThis PR refactors the implementation of `markdown_summary_with_limit()`,\nseparating the logic of determining when the limit has been reached from\nthe actual rendering process.\n\nThe main advantage of the new approach is that it guarantees that all\nHTML tags are closed, whereas the previous implementation could generate\ntags that were never closed. It also ensures that no empty tags are\ngenerated (e.g., `<em></em>`).\n\nThe new implementation consists of a general-purpose struct\n`HtmlWithLimit` that manages the length-limiting logic and a function\n`markdown_summary_with_limit()` that renders Markdown to HTML using the\nstruct.\n\nr? `@GuillaumeGomez`", "tree": {"sha": "30fe20ce7ca7d88a25ed03028446e730655cc86f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30fe20ce7ca7d88a25ed03028446e730655cc86f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa615754999a9453f50edfbfd18188352ecbdd79", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhK5jZCRBK7hj4Ov3rIwAAb0wIAEZfiQ0jiwjuKx1/octoFGP9\ni27Op54kh/XoUQ0slJpJQAT88N2WqIJTFiPFTJ/BsN4jUzG0TQ3FgqLaCyF4qyFU\nW8TopLt8ActZ9EGa6sjBJQ1KpUC3iGvIWYujc4syFPQOAkobLJ80IlD2BBzAuPEo\n4qsIpvBdRgF9vE7Nrv5goN5Z05PB01fV5pJAmP6m3+tGAd5giGIEHWTihSWYQyk6\n94iTKnYifzyqOUFeE8rExDgu7DW9To0JTnkiruqGl7EjrZiHEXdiSrvIjUJYyBa0\nMRXUYp0Gb1E8FXwei2ARW8PQSJbPauU87i4HlNhFGJhHomBTpxA/D6UiBXO+a6U=\n=e7qQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 30fe20ce7ca7d88a25ed03028446e730655cc86f\nparent 63cfbf5d9f402357c0eaf8923363a4ea26942ec0\nparent 4478ecc352d6f3f12c1cb4b9dd5e7e06762286ee\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1630247128 +0200\ncommitter GitHub <noreply@github.com> 1630247128 +0200\n\nRollup merge of #88173 - camelid:refactor-markdown-length-limit, r=GuillaumeGomez\n\nRefactor Markdown length-limited summary implementation\n\nThis PR is a new approach to #79749.\n\nThis PR refactors the implementation of `markdown_summary_with_limit()`,\nseparating the logic of determining when the limit has been reached from\nthe actual rendering process.\n\nThe main advantage of the new approach is that it guarantees that all\nHTML tags are closed, whereas the previous implementation could generate\ntags that were never closed. It also ensures that no empty tags are\ngenerated (e.g., `<em></em>`).\n\nThe new implementation consists of a general-purpose struct\n`HtmlWithLimit` that manages the length-limiting logic and a function\n`markdown_summary_with_limit()` that renders Markdown to HTML using the\nstruct.\n\nr? `@GuillaumeGomez`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa615754999a9453f50edfbfd18188352ecbdd79", "html_url": "https://github.com/rust-lang/rust/commit/aa615754999a9453f50edfbfd18188352ecbdd79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa615754999a9453f50edfbfd18188352ecbdd79/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63cfbf5d9f402357c0eaf8923363a4ea26942ec0", "url": "https://api.github.com/repos/rust-lang/rust/commits/63cfbf5d9f402357c0eaf8923363a4ea26942ec0", "html_url": "https://github.com/rust-lang/rust/commit/63cfbf5d9f402357c0eaf8923363a4ea26942ec0"}, {"sha": "4478ecc352d6f3f12c1cb4b9dd5e7e06762286ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/4478ecc352d6f3f12c1cb4b9dd5e7e06762286ee", "html_url": "https://github.com/rust-lang/rust/commit/4478ecc352d6f3f12c1cb4b9dd5e7e06762286ee"}], "stats": {"total": 314, "additions": 271, "deletions": 43}, "files": [{"sha": "bbdc91c8d2ec8fbbe3b686002cd0bf34e249c32b", "filename": "src/librustdoc/html/length_limit.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/aa615754999a9453f50edfbfd18188352ecbdd79/src%2Flibrustdoc%2Fhtml%2Flength_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa615754999a9453f50edfbfd18188352ecbdd79/src%2Flibrustdoc%2Fhtml%2Flength_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flength_limit.rs?ref=aa615754999a9453f50edfbfd18188352ecbdd79", "patch": "@@ -0,0 +1,119 @@\n+//! See [`HtmlWithLimit`].\n+\n+use std::fmt::Write;\n+use std::ops::ControlFlow;\n+\n+use crate::html::escape::Escape;\n+\n+/// A buffer that allows generating HTML with a length limit.\n+///\n+/// This buffer ensures that:\n+///\n+/// * all tags are closed,\n+/// * tags are closed in the reverse order of when they were opened (i.e., the correct HTML order),\n+/// * no tags are left empty (e.g., `<em></em>`) due to the length limit being reached,\n+/// * all text is escaped.\n+#[derive(Debug)]\n+pub(super) struct HtmlWithLimit {\n+    buf: String,\n+    len: usize,\n+    limit: usize,\n+    /// A list of tags that have been requested to be opened via [`Self::open_tag()`]\n+    /// but have not actually been pushed to `buf` yet. This ensures that tags are not\n+    /// left empty (e.g., `<em></em>`) due to the length limit being reached.\n+    queued_tags: Vec<&'static str>,\n+    /// A list of all tags that have been opened but not yet closed.\n+    unclosed_tags: Vec<&'static str>,\n+}\n+\n+impl HtmlWithLimit {\n+    /// Create a new buffer, with a limit of `length_limit`.\n+    pub(super) fn new(length_limit: usize) -> Self {\n+        let buf = if length_limit > 1000 {\n+            // If the length limit is really large, don't preallocate tons of memory.\n+            String::new()\n+        } else {\n+            // The length limit is actually a good heuristic for initial allocation size.\n+            // Measurements showed that using it as the initial capacity ended up using less memory\n+            // than `String::new`.\n+            // See https://github.com/rust-lang/rust/pull/88173#discussion_r692531631 for more.\n+            String::with_capacity(length_limit)\n+        };\n+        Self {\n+            buf,\n+            len: 0,\n+            limit: length_limit,\n+            unclosed_tags: Vec::new(),\n+            queued_tags: Vec::new(),\n+        }\n+    }\n+\n+    /// Finish using the buffer and get the written output.\n+    /// This function will close all unclosed tags for you.\n+    pub(super) fn finish(mut self) -> String {\n+        self.close_all_tags();\n+        self.buf\n+    }\n+\n+    /// Write some plain text to the buffer, escaping as needed.\n+    ///\n+    /// This function skips writing the text if the length limit was reached\n+    /// and returns [`ControlFlow::Break`].\n+    pub(super) fn push(&mut self, text: &str) -> ControlFlow<(), ()> {\n+        if self.len + text.len() > self.limit {\n+            return ControlFlow::BREAK;\n+        }\n+\n+        self.flush_queue();\n+        write!(self.buf, \"{}\", Escape(text)).unwrap();\n+        self.len += text.len();\n+\n+        ControlFlow::CONTINUE\n+    }\n+\n+    /// Open an HTML tag.\n+    ///\n+    /// **Note:** HTML attributes have not yet been implemented.\n+    /// This function will panic if called with a non-alphabetic `tag_name`.\n+    pub(super) fn open_tag(&mut self, tag_name: &'static str) {\n+        assert!(\n+            tag_name.chars().all(|c| ('a'..='z').contains(&c)),\n+            \"tag_name contained non-alphabetic chars: {:?}\",\n+            tag_name\n+        );\n+        self.queued_tags.push(tag_name);\n+    }\n+\n+    /// Close the most recently opened HTML tag.\n+    pub(super) fn close_tag(&mut self) {\n+        match self.unclosed_tags.pop() {\n+            // Close the most recently opened tag.\n+            Some(tag_name) => write!(self.buf, \"</{}>\", tag_name).unwrap(),\n+            // There are valid cases where `close_tag()` is called without\n+            // there being any tags to close. For example, this occurs when\n+            // a tag is opened after the length limit is exceeded;\n+            // `flush_queue()` will never be called, and thus, the tag will\n+            // not end up being added to `unclosed_tags`.\n+            None => {}\n+        }\n+    }\n+\n+    /// Write all queued tags and add them to the `unclosed_tags` list.\n+    fn flush_queue(&mut self) {\n+        for tag_name in self.queued_tags.drain(..) {\n+            write!(self.buf, \"<{}>\", tag_name).unwrap();\n+\n+            self.unclosed_tags.push(tag_name);\n+        }\n+    }\n+\n+    /// Close all unclosed tags.\n+    fn close_all_tags(&mut self) {\n+        while !self.unclosed_tags.is_empty() {\n+            self.close_tag();\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "2d02b8a16da67415c0e6b8f8016a318bfe117f89", "filename": "src/librustdoc/html/length_limit/tests.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/aa615754999a9453f50edfbfd18188352ecbdd79/src%2Flibrustdoc%2Fhtml%2Flength_limit%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa615754999a9453f50edfbfd18188352ecbdd79/src%2Flibrustdoc%2Fhtml%2Flength_limit%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flength_limit%2Ftests.rs?ref=aa615754999a9453f50edfbfd18188352ecbdd79", "patch": "@@ -0,0 +1,120 @@\n+use super::*;\n+\n+#[test]\n+fn empty() {\n+    assert_eq!(HtmlWithLimit::new(0).finish(), \"\");\n+    assert_eq!(HtmlWithLimit::new(60).finish(), \"\");\n+}\n+\n+#[test]\n+fn basic() {\n+    let mut buf = HtmlWithLimit::new(60);\n+    buf.push(\"Hello \");\n+    buf.open_tag(\"em\");\n+    buf.push(\"world\");\n+    buf.close_tag();\n+    buf.push(\"!\");\n+    assert_eq!(buf.finish(), \"Hello <em>world</em>!\");\n+}\n+\n+#[test]\n+fn no_tags() {\n+    let mut buf = HtmlWithLimit::new(60);\n+    buf.push(\"Hello\");\n+    buf.push(\" world!\");\n+    assert_eq!(buf.finish(), \"Hello world!\");\n+}\n+\n+#[test]\n+fn limit_0() {\n+    let mut buf = HtmlWithLimit::new(0);\n+    buf.push(\"Hello \");\n+    buf.open_tag(\"em\");\n+    buf.push(\"world\");\n+    buf.close_tag();\n+    buf.push(\"!\");\n+    assert_eq!(buf.finish(), \"\");\n+}\n+\n+#[test]\n+fn exactly_limit() {\n+    let mut buf = HtmlWithLimit::new(12);\n+    buf.push(\"Hello \");\n+    buf.open_tag(\"em\");\n+    buf.push(\"world\");\n+    buf.close_tag();\n+    buf.push(\"!\");\n+    assert_eq!(buf.finish(), \"Hello <em>world</em>!\");\n+}\n+\n+#[test]\n+fn multiple_nested_tags() {\n+    let mut buf = HtmlWithLimit::new(60);\n+    buf.open_tag(\"p\");\n+    buf.push(\"This is a \");\n+    buf.open_tag(\"em\");\n+    buf.push(\"paragraph\");\n+    buf.open_tag(\"strong\");\n+    buf.push(\"!\");\n+    buf.close_tag();\n+    buf.close_tag();\n+    buf.close_tag();\n+    assert_eq!(buf.finish(), \"<p>This is a <em>paragraph<strong>!</strong></em></p>\");\n+}\n+\n+#[test]\n+fn forgot_to_close_tags() {\n+    let mut buf = HtmlWithLimit::new(60);\n+    buf.open_tag(\"p\");\n+    buf.push(\"This is a \");\n+    buf.open_tag(\"em\");\n+    buf.push(\"paragraph\");\n+    buf.open_tag(\"strong\");\n+    buf.push(\"!\");\n+    assert_eq!(buf.finish(), \"<p>This is a <em>paragraph<strong>!</strong></em></p>\");\n+}\n+\n+#[test]\n+fn past_the_limit() {\n+    let mut buf = HtmlWithLimit::new(20);\n+    buf.open_tag(\"p\");\n+    (0..10).try_for_each(|n| {\n+        buf.open_tag(\"strong\");\n+        buf.push(\"word#\")?;\n+        buf.push(&n.to_string())?;\n+        buf.close_tag();\n+        ControlFlow::CONTINUE\n+    });\n+    buf.close_tag();\n+    assert_eq!(\n+        buf.finish(),\n+        \"<p>\\\n+             <strong>word#0</strong>\\\n+             <strong>word#1</strong>\\\n+             <strong>word#2</strong>\\\n+             </p>\"\n+    );\n+}\n+\n+#[test]\n+fn quickly_past_the_limit() {\n+    let mut buf = HtmlWithLimit::new(6);\n+    buf.open_tag(\"p\");\n+    buf.push(\"Hello\");\n+    buf.push(\" World\");\n+    // intentionally not closing <p> before finishing\n+    assert_eq!(buf.finish(), \"<p>Hello</p>\");\n+}\n+\n+#[test]\n+fn close_too_many() {\n+    let mut buf = HtmlWithLimit::new(60);\n+    buf.open_tag(\"p\");\n+    buf.push(\"Hello\");\n+    buf.close_tag();\n+    // This call does not panic because there are valid cases\n+    // where `close_tag()` is called with no tags left to close.\n+    // So `close_tag()` does nothing in this case.\n+    buf.close_tag();\n+    assert_eq!(buf.finish(), \"<p>Hello</p>\");\n+}"}, {"sha": "aa3723eddfcce9473e0bae8107b9945c32882c4a", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 28, "deletions": 43, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/aa615754999a9453f50edfbfd18188352ecbdd79/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa615754999a9453f50edfbfd18188352ecbdd79/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=aa615754999a9453f50edfbfd18188352ecbdd79", "patch": "@@ -23,19 +23,21 @@ use rustc_hir::HirId;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::edition::Edition;\n use rustc_span::Span;\n+\n use std::borrow::Cow;\n use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::default::Default;\n use std::fmt::Write;\n-use std::ops::Range;\n+use std::ops::{ControlFlow, Range};\n use std::str;\n \n use crate::clean::RenderedLink;\n use crate::doctest;\n use crate::html::escape::Escape;\n use crate::html::format::Buffer;\n use crate::html::highlight;\n+use crate::html::length_limit::HtmlWithLimit;\n use crate::html::toc::TocBuilder;\n \n use pulldown_cmark::{\n@@ -1081,15 +1083,6 @@ fn markdown_summary_with_limit(\n         return (String::new(), false);\n     }\n \n-    let mut s = String::with_capacity(md.len() * 3 / 2);\n-    let mut text_length = 0;\n-    let mut stopped_early = false;\n-\n-    fn push(s: &mut String, text_length: &mut usize, text: &str) {\n-        write!(s, \"{}\", Escape(text)).unwrap();\n-        *text_length += text.len();\n-    }\n-\n     let mut replacer = |broken_link: BrokenLink<'_>| {\n         if let Some(link) =\n             link_names.iter().find(|link| &*link.original_text == broken_link.reference)\n@@ -1101,56 +1094,48 @@ fn markdown_summary_with_limit(\n     };\n \n     let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut replacer));\n-    let p = LinkReplacer::new(p, link_names);\n+    let mut p = LinkReplacer::new(p, link_names);\n \n-    'outer: for event in p {\n+    let mut buf = HtmlWithLimit::new(length_limit);\n+    let mut stopped_early = false;\n+    p.try_for_each(|event| {\n         match &event {\n             Event::Text(text) => {\n-                for word in text.split_inclusive(char::is_whitespace) {\n-                    if text_length + word.len() >= length_limit {\n-                        stopped_early = true;\n-                        break 'outer;\n-                    }\n-\n-                    push(&mut s, &mut text_length, word);\n+                let r =\n+                    text.split_inclusive(char::is_whitespace).try_for_each(|word| buf.push(word));\n+                if r.is_break() {\n+                    stopped_early = true;\n                 }\n+                return r;\n             }\n             Event::Code(code) => {\n-                if text_length + code.len() >= length_limit {\n+                buf.open_tag(\"code\");\n+                let r = buf.push(code);\n+                if r.is_break() {\n                     stopped_early = true;\n-                    break;\n+                } else {\n+                    buf.close_tag();\n                 }\n-\n-                s.push_str(\"<code>\");\n-                push(&mut s, &mut text_length, code);\n-                s.push_str(\"</code>\");\n+                return r;\n             }\n             Event::Start(tag) => match tag {\n-                Tag::Emphasis => s.push_str(\"<em>\"),\n-                Tag::Strong => s.push_str(\"<strong>\"),\n-                Tag::CodeBlock(..) => break,\n+                Tag::Emphasis => buf.open_tag(\"em\"),\n+                Tag::Strong => buf.open_tag(\"strong\"),\n+                Tag::CodeBlock(..) => return ControlFlow::BREAK,\n                 _ => {}\n             },\n             Event::End(tag) => match tag {\n-                Tag::Emphasis => s.push_str(\"</em>\"),\n-                Tag::Strong => s.push_str(\"</strong>\"),\n-                Tag::Paragraph => break,\n-                Tag::Heading(..) => break,\n+                Tag::Emphasis | Tag::Strong => buf.close_tag(),\n+                Tag::Paragraph | Tag::Heading(..) => return ControlFlow::BREAK,\n                 _ => {}\n             },\n-            Event::HardBreak | Event::SoftBreak => {\n-                if text_length + 1 >= length_limit {\n-                    stopped_early = true;\n-                    break;\n-                }\n-\n-                push(&mut s, &mut text_length, \" \");\n-            }\n+            Event::HardBreak | Event::SoftBreak => buf.push(\" \")?,\n             _ => {}\n-        }\n-    }\n+        };\n+        ControlFlow::CONTINUE\n+    });\n \n-    (s, stopped_early)\n+    (buf.finish(), stopped_early)\n }\n \n /// Renders a shortened first paragraph of the given Markdown as a subset of Markdown,"}, {"sha": "eca75ef013aae89ea567c29552b16541de9c5799", "filename": "src/librustdoc/html/markdown/tests.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa615754999a9453f50edfbfd18188352ecbdd79/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa615754999a9453f50edfbfd18188352ecbdd79/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs?ref=aa615754999a9453f50edfbfd18188352ecbdd79", "patch": "@@ -225,6 +225,7 @@ fn test_short_markdown_summary() {\n         assert_eq!(output, expect, \"original: {}\", input);\n     }\n \n+    t(\"\", \"\");\n     t(\"hello [Rust](https://www.rust-lang.org) :)\", \"hello Rust :)\");\n     t(\"*italic*\", \"<em>italic</em>\");\n     t(\"**bold**\", \"<strong>bold</strong>\");\n@@ -264,6 +265,7 @@ fn test_plain_text_summary() {\n         assert_eq!(output, expect, \"original: {}\", input);\n     }\n \n+    t(\"\", \"\");\n     t(\"hello [Rust](https://www.rust-lang.org) :)\", \"hello Rust :)\");\n     t(\"**bold**\", \"bold\");\n     t(\"Multi-line\\nsummary\", \"Multi-line summary\");"}, {"sha": "109b0a356db5ff26f352701edea20ba12f152462", "filename": "src/librustdoc/html/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa615754999a9453f50edfbfd18188352ecbdd79/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa615754999a9453f50edfbfd18188352ecbdd79/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=aa615754999a9453f50edfbfd18188352ecbdd79", "patch": "@@ -2,6 +2,7 @@ crate mod escape;\n crate mod format;\n crate mod highlight;\n crate mod layout;\n+mod length_limit;\n // used by the error-index generator, so it needs to be public\n pub mod markdown;\n crate mod render;"}, {"sha": "de32e31ca872fd05a1a0ebf9ade93e58060a5da8", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa615754999a9453f50edfbfd18188352ecbdd79/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa615754999a9453f50edfbfd18188352ecbdd79/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=aa615754999a9453f50edfbfd18188352ecbdd79", "patch": "@@ -5,6 +5,7 @@\n #![feature(rustc_private)]\n #![feature(array_methods)]\n #![feature(box_patterns)]\n+#![feature(control_flow_enum)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(test)]"}]}