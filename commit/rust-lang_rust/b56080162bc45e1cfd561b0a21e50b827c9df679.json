{"sha": "b56080162bc45e1cfd561b0a21e50b827c9df679", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NjA4MDE2MmJjNDVlMWNmZDU2MWIwYTIxZTUwYjgyN2M5ZGY2Nzk=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-07-03T14:53:42Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-07-08T09:51:39Z"}, "message": "Rewrite with future-compat lint for indirect pattern omitting\n`#[structural_match]`.\n\nOutline of changes:\n\n * Recur as deeply as necessary when searching for `#[structural_match]`.\n\n * `#[structural_match]`: handle case of `const A: & &Wrap(NoDerive)`\n   by including the fields of an ADT during traversal of input\n   type. (We continue to not traverse the substs of an ADT, though, so\n   that we continue to handle `PhantomData<NoDerive>` and `*NoDerive`\n   properly.)\n\n * Refactored code to use `match` instead of `if let`. This ends up\n   *with less* right-ward drift by moving the handling of the main\n   *`ty::Adt` case *outside* the match.\n\n * Using lint (rather than hard error) mmeans we need to check that\n   type is `PartialEq` to avoid ICE'ing the compiler in scneario where\n   MIR codegen dispatches to `PartialEq::eq`. Added said check, and\n   fatal error in that case.", "tree": {"sha": "a071403bb95a4910651d72f8bd8433dab7cc7dc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a071403bb95a4910651d72f8bd8433dab7cc7dc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b56080162bc45e1cfd561b0a21e50b827c9df679", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b56080162bc45e1cfd561b0a21e50b827c9df679", "html_url": "https://github.com/rust-lang/rust/commit/b56080162bc45e1cfd561b0a21e50b827c9df679", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b56080162bc45e1cfd561b0a21e50b827c9df679/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36777f157b1f30f208e913c0ec04f9ac6b567a4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/36777f157b1f30f208e913c0ec04f9ac6b567a4e", "html_url": "https://github.com/rust-lang/rust/commit/36777f157b1f30f208e913c0ec04f9ac6b567a4e"}], "stats": {"total": 191, "additions": 185, "deletions": 6}, "files": [{"sha": "a619a5c35a7ca307f712c9c84af6022c216c562f", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b56080162bc45e1cfd561b0a21e50b827c9df679/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b56080162bc45e1cfd561b0a21e50b827c9df679/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=b56080162bc45e1cfd561b0a21e50b827c9df679", "patch": "@@ -170,6 +170,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                     let mut patcx = PatternContext::new(self.tcx,\n                                                         self.param_env.and(self.identity_substs),\n                                                         self.tables);\n+                    patcx.include_lint_checks();\n                     let pattern = expand_pattern(cx, patcx.lower_pattern(&pat));\n                     if !patcx.errors.is_empty() {\n                         patcx.report_inlining_errors(pat.span);\n@@ -266,6 +267,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             let mut patcx = PatternContext::new(self.tcx,\n                                                 self.param_env.and(self.identity_substs),\n                                                 self.tables);\n+            patcx.include_lint_checks();\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;\n             let pats: Matrix<'_, '_> = vec![smallvec!["}, {"sha": "a15452043b35d3994c9d90552f3cf5b53d2180fc", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 183, "deletions": 6, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/b56080162bc45e1cfd561b0a21e50b827c9df679/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b56080162bc45e1cfd561b0a21e50b827c9df679/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=b56080162bc45e1cfd561b0a21e50b827c9df679", "patch": "@@ -10,9 +10,11 @@ use crate::const_eval::const_variant_index;\n use crate::hair::util::UserAnnotatedTyHelpers;\n use crate::hair::constant::*;\n \n+use rustc::lint;\n use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::mir::{UserTypeProjection};\n use rustc::mir::interpret::{GlobalId, ConstValue, sign_extend, AllocId, Pointer};\n+use rustc::traits::{ObligationCause, PredicateObligation};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, UserType, DefIdTree};\n use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n use rustc::ty::subst::{SubstsRef, Kind};\n@@ -22,6 +24,7 @@ use rustc::hir::def::{CtorOf, Res, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::fx::FxHashSet;\n \n use std::cmp::Ordering;\n use std::fmt;\n@@ -332,6 +335,7 @@ pub struct PatternContext<'a, 'tcx> {\n     pub tables: &'a ty::TypeckTables<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n     pub errors: Vec<PatternError>,\n+    include_lint_checks: bool,\n }\n \n impl<'a, 'tcx> Pattern<'tcx> {\n@@ -363,10 +367,16 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             param_env: param_env_and_substs.param_env,\n             tables,\n             substs: param_env_and_substs.value,\n-            errors: vec![]\n+            errors: vec![],\n+            include_lint_checks: false,\n         }\n     }\n \n+    pub fn include_lint_checks(&mut self) -> &mut Self {\n+        self.include_lint_checks = true;\n+        self\n+    }\n+\n     pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n@@ -942,23 +952,94 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n     /// Converts an evaluated constant to a pattern (if possible).\n     /// This means aggregate values (like structs and enums) are converted\n-    /// to a pattern that matches the value (as if you'd compared via equality).\n+    /// to a pattern that matches the value (as if you'd compared via structural equality).\n     fn const_to_pat(\n         &self,\n         instance: ty::Instance<'tcx>,\n         cv: &'tcx ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n     ) -> Pattern<'tcx> {\n+        // This method is just a warpper handling a validity check; the heavy lifting is\n+        // performed by the recursive const_to_pat_inner method, which is not meant to be\n+        // invoked except by this method.\n+        //\n+        // once indirect_structural_match is a full fledged error, this\n+        // level of indirection can be eliminated\n+\n         debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n-        let adt_subpattern = |i, variant_opt| {\n+        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n+\n+        let mut saw_error = false;\n+        let inlined_const_as_pat = self.const_to_pat_inner(instance, cv, id, span, &mut saw_error);\n+\n+        if self.include_lint_checks && !saw_error {\n+            // If we were able to successfully convert the const to some pat, double-check\n+            // that the type of the const obeys `#[structural_match]` constraint.\n+            if let Some(adt_def) = search_for_adt_without_structural_match(self.tcx, cv.ty) {\n+\n+                let path = self.tcx.def_path_str(adt_def.did);\n+                let msg = format!(\n+                    \"to use a constant of type `{}` in a pattern, \\\n+                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                    path,\n+                    path,\n+                );\n+\n+                // before issuing lint, double-check there even *is* a\n+                // semantic PartialEq for us to dispatch to.\n+                //\n+                // (If there isn't, then we can safely issue a hard\n+                // error, because that's never worked, due to compiler\n+                // using PartialEq::eq in this scenario in the past.)\n+\n+                let ty_is_partial_eq: bool = {\n+                    let partial_eq_trait_id = self.tcx.lang_items().eq_trait().unwrap();\n+                    let obligation: PredicateObligation<'_> =\n+                        self.tcx.predicate_for_trait_def(self.param_env,\n+                                                         ObligationCause::misc(span, id),\n+                                                         partial_eq_trait_id,\n+                                                         0,\n+                                                         cv.ty,\n+                                                         &[]);\n+                    self.tcx\n+                        .infer_ctxt()\n+                        .enter(|infcx| infcx.predicate_may_hold(&obligation))\n+                };\n+\n+                if !ty_is_partial_eq {\n+                    // span_fatal avoids ICE from resolution of non-existent method (rare case).\n+                    self.tcx.sess.span_fatal(span, &msg);\n+                } else {\n+                    self.tcx.lint_hir(lint::builtin::INDIRECT_STRUCTURAL_MATCH, id, span, &msg);\n+                }\n+            }\n+        }\n+\n+        inlined_const_as_pat\n+    }\n+\n+    /// Recursive helper for `const_to_pat`; invoke that (instead of calling this directly).\n+    fn const_to_pat_inner(\n+        &self,\n+        instance: ty::Instance<'tcx>,\n+        cv: &'tcx ty::Const<'tcx>,\n+        id: hir::HirId,\n+        span: Span,\n+        // This tracks if we signal some hard error for a given const\n+        // value, so that we will not subsequently issue an irrelevant\n+        // lint for the same const value.\n+        saw_const_match_error: &mut bool,\n+    ) -> Pattern<'tcx> {\n+\n+        let mut adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n             let val = crate::const_eval::const_field(\n                 self.tcx, self.param_env, variant_opt, field, cv\n             );\n-            self.const_to_pat(instance, val, id, span)\n+            self.const_to_pat_inner(instance, val, id, span, saw_const_match_error)\n         };\n-        let adt_subpatterns = |n, variant_opt| {\n+        let mut adt_subpatterns = |n, variant_opt| {\n             (0..n).map(|i| {\n                 let field = Field::new(i);\n                 FieldPattern {\n@@ -967,7 +1048,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }).collect::<Vec<_>>()\n         };\n-        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n+\n+\n         let kind = match cv.ty.sty {\n             ty::Float(_) => {\n                 self.tcx.lint_hir(\n@@ -982,9 +1064,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n+                *saw_const_match_error = true;\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n                 PatternKind::Wild\n             }\n+            // keep old code until future-compat upgraded to errors.\n             ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 let path = self.tcx.def_path_str(adt_def.did);\n                 let msg = format!(\n@@ -993,9 +1077,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     path,\n                     path,\n                 );\n+                *saw_const_match_error = true;\n                 self.tcx.sess.span_err(span, &msg);\n                 PatternKind::Wild\n             }\n+            // keep old code until future-compat upgraded to errors.\n             ty::Ref(_, ty::TyS { sty: ty::Adt(adt_def, _), .. }, _)\n             if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n@@ -1007,6 +1093,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     path,\n                     path,\n                 );\n+                *saw_const_match_error = true;\n                 self.tcx.sess.span_err(span, &msg);\n                 PatternKind::Wild\n             }\n@@ -1058,6 +1145,96 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n }\n \n+fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n+                                                 ty: Ty<'tcx>)\n+                                                 -> Option<&'tcx AdtDef>\n+{\n+    // Import here (not mod level), because `TypeFoldable::fold_with`\n+    // conflicts with `PatternFoldable::fold_with`\n+    use crate::rustc::ty::fold::TypeVisitor;\n+    use crate::rustc::ty::TypeFoldable;\n+\n+    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n+    ty.visit_with(&mut search);\n+    return search.found;\n+\n+    struct Search<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+\n+        // records the first ADT we find without `#[structural_match`\n+        found: Option<&'tcx AdtDef>,\n+\n+        // tracks ADT's previously encountered during search, so that\n+        // we will not recur on them again.\n+        seen: FxHashSet<&'tcx AdtDef>,\n+    }\n+\n+    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n+        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+            debug!(\"Search visiting ty: {:?}\", ty);\n+\n+            let (adt_def, substs) = match ty.sty {\n+                ty::Adt(adt_def, substs) => (adt_def, substs),\n+                ty::RawPtr(..) => {\n+                    // `#[structural_match]` ignores substructure of\n+                    // `*const _`/`*mut _`, so skip super_visit_with\n+\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::Array(_, n) if n.assert_usize(self.tcx) == Some(0) => {\n+                    // rust-lang/rust#62336: ignore type of contents\n+                    // for empty array.\n+                    return false;\n+                }\n+                _ => {\n+                    ty.super_visit_with(self);\n+                    return false;\n+                }\n+            };\n+\n+            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n+                self.found = Some(&adt_def);\n+                debug!(\"Search found adt_def: {:?}\", adt_def);\n+                return true // Halt visiting!\n+            }\n+\n+            if self.seen.contains(adt_def) {\n+                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n+                // let caller continue its search\n+                return false;\n+            }\n+\n+            self.seen.insert(adt_def);\n+\n+            // `#[structural_match]` does not care about the\n+            // instantiation of the generics in an ADT (it\n+            // instead looks directly at its fields outside\n+            // this match), so we skip super_visit_with.\n+            //\n+            // (Must not recur on substs for `PhantomData<T>` cf\n+            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n+            // want to skip substs when only uses of generic are\n+            // behind unsafe pointers `*const T`/`*mut T`.)\n+\n+            // even though we skip super_visit_with, we must recur on\n+            // fields of ADT.\n+            let tcx = self.tcx;\n+            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n+                if field_ty.visit_with(self) {\n+                    // found an ADT without `#[structural_match]`; halt visiting!\n+                    assert!(self.found.is_some());\n+                    return true;\n+                }\n+            }\n+\n+            // Even though we do not want to recur on substs, we do\n+            // want our caller to continue its own search.\n+            false\n+        }\n+    }\n+}\n+\n impl UserAnnotatedTyHelpers<'tcx> for PatternContext<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx"}]}