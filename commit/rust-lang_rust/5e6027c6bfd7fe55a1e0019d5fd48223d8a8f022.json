{"sha": "5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNjAyN2M2YmZkN2ZlNTVhMWUwMDE5ZDVmZDQ4MjIzZDhhOGYwMjI=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2021-03-07T14:41:45Z"}, "committer": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2021-08-15T07:10:46Z"}, "message": "Track causes for universes created during borrowck", "tree": {"sha": "2940deab94829afcf24f14bf5dfe3e6fab4d0602", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2940deab94829afcf24f14bf5dfe3e6fab4d0602"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "html_url": "https://github.com/rust-lang/rust/commit/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e271383c6b0cd234512d495fe499875b6f0288aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e271383c6b0cd234512d495fe499875b6f0288aa", "html_url": "https://github.com/rust-lang/rust/commit/e271383c6b0cd234512d495fe499875b6f0288aa"}], "stats": {"total": 458, "additions": 329, "deletions": 129}, "files": [{"sha": "8c7a792eaa25842f1c7fc2ff166c04c2f802b0b8", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "patch": "@@ -1506,7 +1506,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.inner.borrow_mut().projection_cache().clear();\n     }\n \n-    fn universe(&self) -> ty::UniverseIndex {\n+    pub fn universe(&self) -> ty::UniverseIndex {\n         self.universe.get()\n     }\n "}, {"sha": "c771b71fc7f51247a131a41e8f261e266d823168", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/bound_region_errors.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fbound_region_errors.rs?ref=5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "patch": "@@ -0,0 +1,110 @@\n+use rustc_infer::infer::canonical::Canonical;\n+use rustc_middle::ty::{self, Ty, TypeFoldable};\n+use rustc_span::Span;\n+use rustc_trait_selection::traits::query::type_op;\n+\n+use std::fmt;\n+use std::rc::Rc;\n+\n+use crate::borrow_check::region_infer::values::RegionElement;\n+use crate::borrow_check::MirBorrowckCtxt;\n+\n+#[derive(Clone)]\n+crate struct UniverseInfo<'tcx>(UniverseInfoInner<'tcx>);\n+\n+/// What operation a universe was created for.\n+#[derive(Clone)]\n+enum UniverseInfoInner<'tcx> {\n+    /// Relating two types which have binders.\n+    RelateTys { expected: Ty<'tcx>, found: Ty<'tcx> },\n+    /// Created from performing a `TypeOp`.\n+    TypeOp(Rc<dyn TypeOpInfo<'tcx> + 'tcx>),\n+    /// Any other reason.\n+    Other,\n+}\n+\n+impl UniverseInfo<'tcx> {\n+    crate fn other() -> UniverseInfo<'tcx> {\n+        UniverseInfo(UniverseInfoInner::Other)\n+    }\n+\n+    crate fn relate(expected: Ty<'tcx>, found: Ty<'tcx>) -> UniverseInfo<'tcx> {\n+        UniverseInfo(UniverseInfoInner::RelateTys { expected, found })\n+    }\n+\n+    crate fn _report_error(\n+        &self,\n+        _mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n+        _placeholder: ty::PlaceholderRegion,\n+        _error_element: RegionElement,\n+        _span: Span,\n+    ) {\n+        todo!();\n+    }\n+}\n+\n+crate trait ToUniverseInfo<'tcx> {\n+    fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx>;\n+}\n+\n+impl<'tcx> ToUniverseInfo<'tcx>\n+    for Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::prove_predicate::ProvePredicate<'tcx>>>\n+{\n+    fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        UniverseInfo(UniverseInfoInner::TypeOp(Rc::new(PredicateQuery {\n+            _canonical_query: self,\n+            _base_universe: base_universe,\n+        })))\n+    }\n+}\n+\n+impl<'tcx, T: Copy + fmt::Display + TypeFoldable<'tcx> + 'tcx> ToUniverseInfo<'tcx>\n+    for Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Normalize<T>>>\n+{\n+    fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        UniverseInfo(UniverseInfoInner::TypeOp(Rc::new(NormalizeQuery {\n+            _canonical_query: self,\n+            _base_universe: base_universe,\n+        })))\n+    }\n+}\n+\n+impl<'tcx> ToUniverseInfo<'tcx>\n+    for Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::AscribeUserType<'tcx>>>\n+{\n+    fn to_universe_info(self, _base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        // Ascribe user type isn't usually called on types that have different\n+        // bound regions.\n+        UniverseInfo::other()\n+    }\n+}\n+\n+impl<'tcx, F, G> ToUniverseInfo<'tcx> for Canonical<'tcx, type_op::custom::CustomTypeOp<F, G>> {\n+    fn to_universe_info(self, _base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        // We can't rerun custom type ops.\n+        UniverseInfo::other()\n+    }\n+}\n+\n+#[allow(unused_lifetimes)]\n+trait TypeOpInfo<'tcx> {\n+    // TODO: Methods for rerunning type op and reporting an error\n+}\n+\n+struct PredicateQuery<'tcx> {\n+    _canonical_query:\n+        Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::prove_predicate::ProvePredicate<'tcx>>>,\n+    _base_universe: ty::UniverseIndex,\n+}\n+\n+impl TypeOpInfo<'tcx> for PredicateQuery<'tcx> {}\n+\n+struct NormalizeQuery<'tcx, T> {\n+    _canonical_query: Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Normalize<T>>>,\n+    _base_universe: ty::UniverseIndex,\n+}\n+\n+impl<T> TypeOpInfo<'tcx> for NormalizeQuery<'tcx, T> where\n+    T: Copy + fmt::Display + TypeFoldable<'tcx> + 'tcx\n+{\n+}"}, {"sha": "55c6410ed320497730f7e1f90ae03f61a682e139", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "patch": "@@ -28,12 +28,14 @@ mod outlives_suggestion;\n mod region_name;\n mod var_name;\n \n+mod bound_region_errors;\n mod conflict_errors;\n mod explain_borrow;\n mod move_errors;\n mod mutability_errors;\n mod region_errors;\n \n+crate use bound_region_errors::{ToUniverseInfo, UniverseInfo};\n crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};"}, {"sha": "7df4f5cfdb6db3f756f746ecc64a2332910984d8", "filename": "compiler/rustc_mir/src/borrow_check/nll.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs?ref=5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "patch": "@@ -239,6 +239,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         outlives_constraints,\n         member_constraints,\n         closure_bounds_mapping,\n+        universe_causes,\n         type_tests,\n     } = constraints;\n     let placeholder_indices = Rc::new(placeholder_indices);\n@@ -260,6 +261,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         outlives_constraints,\n         member_constraints,\n         closure_bounds_mapping,\n+        universe_causes,\n         type_tests,\n         liveness_constraints,\n         elements,"}, {"sha": "bd6831108dcf8f7b162af31507505bee383287dd", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "patch": "@@ -21,7 +21,7 @@ use crate::borrow_check::{\n     constraints::{\n         graph::NormalConstraintGraph, ConstraintSccIndex, OutlivesConstraint, OutlivesConstraintSet,\n     },\n-    diagnostics::{RegionErrorKind, RegionErrors},\n+    diagnostics::{RegionErrorKind, RegionErrors, UniverseInfo},\n     member_constraints::{MemberConstraintSet, NllMemberConstraintIndex},\n     nll::{PoloniusOutput, ToRegionVid},\n     region_infer::reverse_sccs::ReverseSccGraph,\n@@ -84,6 +84,9 @@ pub struct RegionInferenceContext<'tcx> {\n     closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n+    /// Map universe indexes to information on why we created it.\n+    _universe_causes: IndexVec<ty::UniverseIndex, UniverseInfo<'tcx>>,\n+\n     /// Contains the minimum universe of any variable within the same\n     /// SCC. We will ensure that no SCC contains values that are not\n     /// visible from this index.\n@@ -253,6 +256,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             Location,\n             FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n         >,\n+        universe_causes: IndexVec<ty::UniverseIndex, UniverseInfo<'tcx>>,\n         type_tests: Vec<TypeTest<'tcx>>,\n         liveness_constraints: LivenessValues<RegionVid>,\n         elements: &Rc<RegionValueElements>,\n@@ -293,6 +297,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             member_constraints,\n             member_constraints_applied: Vec::new(),\n             closure_bounds_mapping,\n+            _universe_causes: universe_causes,\n             scc_universes,\n             scc_representatives,\n             scc_values,"}, {"sha": "9fafcfafe67cdba8ba3b20619ffcfd1dd6361fc7", "filename": "compiler/rustc_mir/src/borrow_check/type_check/canonical.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fcanonical.rs?ref=5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "patch": "@@ -0,0 +1,158 @@\n+use std::fmt;\n+\n+use rustc_hir as hir;\n+use rustc_infer::infer::canonical::Canonical;\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::mir::ConstraintCategory;\n+use rustc_middle::ty::{self, ToPredicate, TypeFoldable};\n+use rustc_span::Span;\n+use rustc_trait_selection::traits::query::type_op::{self, TypeOpOutput};\n+use rustc_trait_selection::traits::query::Fallible;\n+\n+use crate::borrow_check::diagnostics::{ToUniverseInfo, UniverseInfo};\n+\n+use super::{Locations, NormalizeLocation, TypeChecker};\n+\n+impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n+    /// Given some operation `op` that manipulates types, proves\n+    /// predicates, or otherwise uses the inference context, executes\n+    /// `op` and then executes all the further obligations that `op`\n+    /// returns. This will yield a set of outlives constraints amongst\n+    /// regions which are extracted and stored as having occurred at\n+    /// `locations`.\n+    ///\n+    /// **Any `rustc_infer::infer` operations that might generate region\n+    /// constraints should occur within this method so that those\n+    /// constraints can be properly localized!**\n+    pub(super) fn fully_perform_op<R, Op>(\n+        &mut self,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+        op: Op,\n+    ) -> Fallible<R>\n+    where\n+        Op: type_op::TypeOp<'tcx, Output = R>,\n+        Canonical<'tcx, Op>: ToUniverseInfo<'tcx>,\n+    {\n+        let old_universe = self.infcx.universe();\n+\n+        let TypeOpOutput { output, constraints, canonicalized_query } =\n+            op.fully_perform(self.infcx)?;\n+\n+        if let Some(data) = &constraints {\n+            self.push_region_constraints(locations, category, data);\n+        }\n+\n+        let universe = self.infcx.universe();\n+\n+        if old_universe != universe {\n+            let universe_info = match canonicalized_query {\n+                Some(canonicalized_query) => canonicalized_query.to_universe_info(old_universe),\n+                None => UniverseInfo::other(),\n+            };\n+            for u in old_universe..universe {\n+                let info_universe =\n+                    self.borrowck_context.constraints.universe_causes.push(universe_info.clone());\n+                assert_eq!(u.as_u32() + 1, info_universe.as_u32());\n+            }\n+        }\n+\n+        Ok(output)\n+    }\n+\n+    pub(super) fn instantiate_canonical_with_fresh_inference_vars<T>(\n+        &mut self,\n+        span: Span,\n+        canonical: &Canonical<'tcx, T>,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let (instantiated, _) =\n+            self.infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);\n+\n+        for _ in 0..canonical.max_universe.as_u32() {\n+            let info = UniverseInfo::other();\n+            self.borrowck_context.constraints.universe_causes.push(info);\n+        }\n+\n+        instantiated\n+    }\n+\n+    pub(super) fn prove_trait_ref(\n+        &mut self,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) {\n+        self.prove_predicates(\n+            Some(ty::PredicateKind::Trait(ty::TraitPredicate {\n+                trait_ref,\n+                constness: hir::Constness::NotConst,\n+            })),\n+            locations,\n+            category,\n+        );\n+    }\n+\n+    pub(super) fn normalize_and_prove_instantiated_predicates(\n+        &mut self,\n+        instantiated_predicates: ty::InstantiatedPredicates<'tcx>,\n+        locations: Locations,\n+    ) {\n+        for predicate in instantiated_predicates.predicates {\n+            let predicate = self.normalize(predicate, locations);\n+            self.prove_predicate(predicate, locations, ConstraintCategory::Boring);\n+        }\n+    }\n+\n+    pub(super) fn prove_predicates(\n+        &mut self,\n+        predicates: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) {\n+        for predicate in predicates {\n+            let predicate = predicate.to_predicate(self.tcx());\n+            debug!(\"prove_predicates(predicate={:?}, locations={:?})\", predicate, locations,);\n+\n+            self.prove_predicate(predicate, locations, category);\n+        }\n+    }\n+\n+    pub(super) fn prove_predicate(\n+        &mut self,\n+        predicate: ty::Predicate<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) {\n+        debug!(\"prove_predicate(predicate={:?}, location={:?})\", predicate, locations,);\n+\n+        let param_env = self.param_env;\n+        self.fully_perform_op(\n+            locations,\n+            category,\n+            param_env.and(type_op::prove_predicate::ProvePredicate::new(predicate)),\n+        )\n+        .unwrap_or_else(|NoSolution| {\n+            span_mirbug!(self, NoSolution, \"could not prove {:?}\", predicate);\n+        })\n+    }\n+\n+    pub(super) fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n+    where\n+        T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,\n+    {\n+        debug!(\"normalize(value={:?}, location={:?})\", value, location);\n+        let param_env = self.param_env;\n+        self.fully_perform_op(\n+            location.to_locations(),\n+            ConstraintCategory::Boring,\n+            param_env.and(type_op::normalize::Normalize::new(value)),\n+        )\n+        .unwrap_or_else(|NoSolution| {\n+            span_mirbug!(self, NoSolution, \"failed to normalize `{:?}`\", value);\n+            value\n+        })\n+    }\n+}"}, {"sha": "f8989a7d9df1c2be7e7c018fbdafe2e15651e1a8", "filename": "compiler/rustc_mir/src/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     // Instantiate the canonicalized variables from\n                     // user-provided signature (e.g., the `_` in the code\n                     // above) with fresh variables.\n-                    let (poly_sig, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+                    let poly_sig = self.instantiate_canonical_with_fresh_inference_vars(\n                         body.span,\n                         &user_provided_poly_sig,\n                     );"}, {"sha": "b6b25a759913a913a7a41e64354a8dda5393e5d5", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 29, "deletions": 123, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "patch": "@@ -38,9 +38,8 @@ use rustc_trait_selection::opaque_types::{GenerateMemberConstraints, InferCtxtEx\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n-use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n+use rustc_trait_selection::traits::query::Fallible;\n use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligations};\n-use type_op::TypeOpOutput;\n \n use crate::dataflow::impls::MaybeInitializedPlaces;\n use crate::dataflow::move_paths::MoveData;\n@@ -52,6 +51,7 @@ use crate::transform::{\n use crate::borrow_check::{\n     borrow_set::BorrowSet,\n     constraints::{OutlivesConstraint, OutlivesConstraintSet},\n+    diagnostics::UniverseInfo,\n     facts::AllFacts,\n     location::LocationTable,\n     member_constraints::MemberConstraintSet,\n@@ -90,6 +90,7 @@ macro_rules! span_mirbug_and_err {\n     })\n }\n \n+mod canonical;\n mod constraint_conversion;\n pub mod free_region_relations;\n mod input_output;\n@@ -143,6 +144,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         member_constraints: MemberConstraintSet::default(),\n         closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n+        universe_causes: IndexVec::from_elem_n(UniverseInfo::other(), 1),\n     };\n \n     let CreateResult {\n@@ -157,6 +159,11 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         &mut constraints,\n     );\n \n+    for _ in ty::UniverseIndex::ROOT..infcx.universe() {\n+        let info = UniverseInfo::other();\n+        constraints.universe_causes.push(info);\n+    }\n+\n     let mut borrowck_context = BorrowCheckContext {\n         universal_regions,\n         location_table,\n@@ -377,8 +384,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                                      ty,\n                                      san_ty| {\n                         if let Err(terr) = verifier.cx.eq_types(\n-                            san_ty,\n                             ty,\n+                            san_ty,\n                             location.to_locations(),\n                             ConstraintCategory::Boring,\n                         ) {\n@@ -426,8 +433,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                 let literal_ty = constant.literal.ty().builtin_deref(true).unwrap().ty;\n \n                 if let Err(terr) = self.cx.eq_types(\n-                    normalized_ty,\n                     literal_ty,\n+                    normalized_ty,\n                     locations,\n                     ConstraintCategory::Boring,\n                 ) {\n@@ -543,7 +550,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     return PlaceTy::from_ty(self.tcx().ty_error());\n                 }\n             }\n-            place_ty = self.sanitize_projection(place_ty, elem, place, location)\n+            place_ty = self.sanitize_projection(place_ty, elem, place, location);\n         }\n \n         if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n@@ -917,6 +924,8 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     crate closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n+    crate universe_causes: IndexVec<ty::UniverseIndex, UniverseInfo<'tcx>>,\n+\n     crate type_tests: Vec<TypeTest<'tcx>>,\n }\n \n@@ -1044,8 +1053,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n         for user_annotation in self.user_type_annotations {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n-            let (annotation, _) =\n-                self.infcx.instantiate_canonical_with_fresh_inference_vars(span, user_ty);\n+            let annotation = self.instantiate_canonical_with_fresh_inference_vars(span, user_ty);\n             match annotation {\n                 UserType::Ty(mut ty) => {\n                     ty = self.normalize(ty, Locations::All(span));\n@@ -1098,31 +1106,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n-    /// Given some operation `op` that manipulates types, proves\n-    /// predicates, or otherwise uses the inference context, executes\n-    /// `op` and then executes all the further obligations that `op`\n-    /// returns. This will yield a set of outlives constraints amongst\n-    /// regions which are extracted and stored as having occurred at\n-    /// `locations`.\n-    ///\n-    /// **Any `rustc_infer::infer` operations that might generate region\n-    /// constraints should occur within this method so that those\n-    /// constraints can be properly localized!**\n-    fn fully_perform_op<R>(\n-        &mut self,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-        op: impl type_op::TypeOp<'tcx, Output = R>,\n-    ) -> Fallible<R> {\n-        let TypeOpOutput { output, constraints, .. } = op.fully_perform(self.infcx)?;\n-\n-        if let Some(data) = &constraints {\n-            self.push_region_constraints(locations, category, data);\n-        }\n-\n-        Ok(output)\n-    }\n-\n     fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n@@ -1174,17 +1157,19 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        self.relate_types(sub, ty::Variance::Covariant, sup, locations, category)\n+        // Use this order of parameters because the sup type is usually the\n+        // \"expected\" type in diagnostics.\n+        self.relate_types(sup, ty::Variance::Contravariant, sub, locations, category)\n     }\n \n     fn eq_types(\n         &mut self,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        self.relate_types(a, ty::Variance::Invariant, b, locations, category)\n+        self.relate_types(expected, ty::Variance::Invariant, found, locations, category)\n     }\n \n     fn relate_type_and_user_type(\n@@ -1223,7 +1208,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n \n         let ty = curr_projected_ty.ty;\n-        self.relate_types(a, v, ty, locations, category)?;\n+        self.relate_types(ty, v.xform(ty::Variance::Contravariant), a, locations, category)?;\n \n         Ok(())\n     }\n@@ -2054,8 +2039,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n \n                         if let Err(terr) = self.eq_types(\n-                            ty_fn_ptr_from,\n                             ty,\n+                            ty_fn_ptr_from,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n                         ) {\n@@ -2078,8 +2063,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_fn_ptr_from = tcx.mk_fn_ptr(tcx.signature_unclosure(sig, *unsafety));\n \n                         if let Err(terr) = self.eq_types(\n-                            ty_fn_ptr_from,\n                             ty,\n+                            ty_fn_ptr_from,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n                         ) {\n@@ -2107,8 +2092,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n \n                         if let Err(terr) = self.eq_types(\n-                            ty_fn_ptr_from,\n                             ty,\n+                            ty_fn_ptr_from,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n                         ) {\n@@ -2295,20 +2280,18 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             kind: TypeVariableOriginKind::MiscVariable,\n                             span: body.source_info(location).span,\n                         });\n-                        self.relate_types(\n-                            common_ty,\n-                            ty::Variance::Contravariant,\n+                        self.sub_types(\n                             ty_left,\n+                            common_ty,\n                             location.to_locations(),\n                             ConstraintCategory::Boring,\n                         )\n                         .unwrap_or_else(|err| {\n                             bug!(\"Could not equate type variable with {:?}: {:?}\", ty_left, err)\n                         });\n-                        if let Err(terr) = self.relate_types(\n-                            common_ty,\n-                            ty::Variance::Contravariant,\n+                        if let Err(terr) = self.sub_types(\n                             ty_right,\n+                            common_ty,\n                             location.to_locations(),\n                             ConstraintCategory::Boring,\n                         ) {\n@@ -2683,66 +2666,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         tcx.predicates_of(def_id).instantiate(tcx, substs)\n     }\n \n-    fn prove_trait_ref(\n-        &mut self,\n-        trait_ref: ty::TraitRef<'tcx>,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-    ) {\n-        self.prove_predicates(\n-            Some(ty::PredicateKind::Trait(ty::TraitPredicate {\n-                trait_ref,\n-                constness: hir::Constness::NotConst,\n-            })),\n-            locations,\n-            category,\n-        );\n-    }\n-\n-    fn normalize_and_prove_instantiated_predicates(\n-        &mut self,\n-        instantiated_predicates: ty::InstantiatedPredicates<'tcx>,\n-        locations: Locations,\n-    ) {\n-        for predicate in instantiated_predicates.predicates {\n-            let predicate = self.normalize(predicate, locations);\n-            self.prove_predicate(predicate, locations, ConstraintCategory::Boring);\n-        }\n-    }\n-\n-    fn prove_predicates(\n-        &mut self,\n-        predicates: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-    ) {\n-        for predicate in predicates {\n-            let predicate = predicate.to_predicate(self.tcx());\n-            debug!(\"prove_predicates(predicate={:?}, locations={:?})\", predicate, locations,);\n-\n-            self.prove_predicate(predicate, locations, category);\n-        }\n-    }\n-\n-    fn prove_predicate(\n-        &mut self,\n-        predicate: ty::Predicate<'tcx>,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-    ) {\n-        debug!(\"prove_predicate(predicate={:?}, location={:?})\", predicate, locations,);\n-\n-        let param_env = self.param_env;\n-        self.fully_perform_op(\n-            locations,\n-            category,\n-            param_env.and(type_op::prove_predicate::ProvePredicate::new(predicate)),\n-        )\n-        .unwrap_or_else(|NoSolution| {\n-            span_mirbug!(self, NoSolution, \"could not prove {:?}\", predicate);\n-        })\n-    }\n-\n     fn typeck_mir(&mut self, body: &Body<'tcx>) {\n         self.last_span = body.span;\n         debug!(\"run_on_mir: {:?}\", body.span);\n@@ -2765,23 +2688,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             self.check_iscleanup(&body, block_data);\n         }\n     }\n-\n-    fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n-    where\n-        T: type_op::normalize::Normalizable<'tcx> + Copy + 'tcx,\n-    {\n-        debug!(\"normalize(value={:?}, location={:?})\", value, location);\n-        let param_env = self.param_env;\n-        self.fully_perform_op(\n-            location.to_locations(),\n-            ConstraintCategory::Boring,\n-            param_env.and(type_op::normalize::Normalize::new(value)),\n-        )\n-        .unwrap_or_else(|NoSolution| {\n-            span_mirbug!(self, NoSolution, \"failed to normalize `{:?}`\", value);\n-            value\n-        })\n-    }\n }\n \n trait NormalizeLocation: fmt::Debug + Copy {"}, {"sha": "971c4daa6b311ae49ce41629b202f1fba271d230", "filename": "compiler/rustc_mir/src/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=5e6027c6bfd7fe55a1e0019d5fd48223d8a8f022", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::ty::{self, Const, Ty};\n use rustc_trait_selection::traits::query::Fallible;\n \n use crate::borrow_check::constraints::OutlivesConstraint;\n+use crate::borrow_check::diagnostics::UniverseInfo;\n use crate::borrow_check::type_check::{BorrowCheckContext, Locations};\n \n /// Adds sufficient constraints to ensure that `a R b` where `R` depends on `v`:\n@@ -29,7 +30,14 @@ pub(super) fn relate_types<'tcx>(\n     debug!(\"relate_types(a={:?}, v={:?}, b={:?}, locations={:?})\", a, v, b, locations);\n     TypeRelating::new(\n         infcx,\n-        NllTypeRelatingDelegate::new(infcx, borrowck_context, param_env, locations, category),\n+        NllTypeRelatingDelegate::new(\n+            infcx,\n+            borrowck_context,\n+            param_env,\n+            locations,\n+            category,\n+            UniverseInfo::relate(a, b),\n+        ),\n         v,\n     )\n     .relate(a, b)?;\n@@ -47,6 +55,10 @@ struct NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n \n     /// What category do we assign the resulting `'a: 'b` relationships?\n     category: ConstraintCategory,\n+\n+    /// Information so that error reporting knows what types we are relating\n+    /// when reporting a bound region error.\n+    universe_info: UniverseInfo<'tcx>,\n }\n \n impl NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n@@ -56,8 +68,9 @@ impl NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n+        universe_info: UniverseInfo<'tcx>,\n     ) -> Self {\n-        Self { infcx, borrowck_context, param_env, locations, category }\n+        Self { infcx, borrowck_context, param_env, locations, category, universe_info }\n     }\n }\n \n@@ -67,7 +80,11 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n     }\n \n     fn create_next_universe(&mut self) -> ty::UniverseIndex {\n-        self.infcx.create_next_universe()\n+        let info_universe =\n+            self.borrowck_context.constraints.universe_causes.push(self.universe_info.clone());\n+        let universe = self.infcx.create_next_universe();\n+        assert_eq!(info_universe, universe);\n+        universe\n     }\n \n     fn next_existential_region_var(&mut self, from_forall: bool) -> ty::Region<'tcx> {"}]}