{"sha": "a302f88d23c8e7095e675049bc07a7872da52e13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMDJmODhkMjNjOGU3MDk1ZTY3NTA0OWJjMDdhNzg3MmRhNTJlMTM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-26T10:19:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-26T10:19:24Z"}, "message": "Merge pull request #627 from bjorn3/wip_i128\n\nSupport 128bit numbers", "tree": {"sha": "7dcc94078f16009388a013c40c86657f62a69591", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dcc94078f16009388a013c40c86657f62a69591"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a302f88d23c8e7095e675049bc07a7872da52e13", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdOtOsCRBK7hj4Ov3rIwAAdHIIACJaXx1n13Buho270Hm5qBiK\no42LMcUEtfV8RL5EhKGyqqqw3W5kNloEXfAa/jIubSUCeQKC9D+c1qZxTg2fbS5B\naSYmmGa6BUf51iJGnZI8Sg8DdY/+PXAf3JlUp6KuVE+md4OI5UFjJc0ms+JJXPLm\nEqiSqg5Rhsmk4mkcsbr7wJCo0EsVDI+eqe92woceWCAxFa8f3ir2XXjzsWtL8O8u\nnF92K/RScCLACP+RBDPfPVEQ/V+nXI6enwSsaaBGfELKwMpvBDDrSVuwyo4hI332\nG77EorftomBt3Hyf7bjYgpACLk0uXS67w952di90lEG+eDqQiUtIxJIbNmgSRys=\n=H+WN\n-----END PGP SIGNATURE-----\n", "payload": "tree 7dcc94078f16009388a013c40c86657f62a69591\nparent bba11f61727e936afd1dc628cf0611ee20acdb9a\nparent 770c12ac9723cd4ecfa549a0903adf68a6c2be48\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1564136364 +0200\ncommitter GitHub <noreply@github.com> 1564136364 +0200\n\nMerge pull request #627 from bjorn3/wip_i128\n\nSupport 128bit numbers"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a302f88d23c8e7095e675049bc07a7872da52e13", "html_url": "https://github.com/rust-lang/rust/commit/a302f88d23c8e7095e675049bc07a7872da52e13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a302f88d23c8e7095e675049bc07a7872da52e13/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bba11f61727e936afd1dc628cf0611ee20acdb9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bba11f61727e936afd1dc628cf0611ee20acdb9a", "html_url": "https://github.com/rust-lang/rust/commit/bba11f61727e936afd1dc628cf0611ee20acdb9a"}, {"sha": "770c12ac9723cd4ecfa549a0903adf68a6c2be48", "url": "https://api.github.com/repos/rust-lang/rust/commits/770c12ac9723cd4ecfa549a0903adf68a6c2be48", "html_url": "https://github.com/rust-lang/rust/commit/770c12ac9723cd4ecfa549a0903adf68a6c2be48"}], "stats": {"total": 687, "additions": 455, "deletions": 232}, "files": [{"sha": "139fb70fd05b752fa146935a8a6943ad8b2e3f48", "filename": "Cargo.lock", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -117,28 +117,28 @@ dependencies = [\n [[package]]\n name = \"cranelift\"\n version = \"0.36.0\"\n-source = \"git+https://github.com/CraneStation/cranelift.git#e7f2b719eebfb9280c3e38eae42a9ee25221a4e3\"\n+source = \"git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128#ca836a8e0d0b62e2ddecb5902cd5091b468a4db3\"\n dependencies = [\n- \"cranelift-codegen 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n- \"cranelift-frontend 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n+ \"cranelift-codegen 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n+ \"cranelift-frontend 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n ]\n \n [[package]]\n name = \"cranelift-bforest\"\n version = \"0.36.0\"\n-source = \"git+https://github.com/CraneStation/cranelift.git#e7f2b719eebfb9280c3e38eae42a9ee25221a4e3\"\n+source = \"git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128#ca836a8e0d0b62e2ddecb5902cd5091b468a4db3\"\n dependencies = [\n- \"cranelift-entity 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n+ \"cranelift-entity 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n version = \"0.36.0\"\n-source = \"git+https://github.com/CraneStation/cranelift.git#e7f2b719eebfb9280c3e38eae42a9ee25221a4e3\"\n+source = \"git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128#ca836a8e0d0b62e2ddecb5902cd5091b468a4db3\"\n dependencies = [\n- \"cranelift-bforest 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n- \"cranelift-codegen-meta 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n- \"cranelift-entity 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n+ \"cranelift-bforest 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n+ \"cranelift-codegen-meta 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n+ \"cranelift-entity 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -148,23 +148,23 @@ dependencies = [\n [[package]]\n name = \"cranelift-codegen-meta\"\n version = \"0.36.0\"\n-source = \"git+https://github.com/CraneStation/cranelift.git#e7f2b719eebfb9280c3e38eae42a9ee25221a4e3\"\n+source = \"git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128#ca836a8e0d0b62e2ddecb5902cd5091b468a4db3\"\n dependencies = [\n- \"cranelift-entity 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n+ \"cranelift-entity 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n ]\n \n [[package]]\n name = \"cranelift-entity\"\n version = \"0.36.0\"\n-source = \"git+https://github.com/CraneStation/cranelift.git#e7f2b719eebfb9280c3e38eae42a9ee25221a4e3\"\n+source = \"git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128#ca836a8e0d0b62e2ddecb5902cd5091b468a4db3\"\n \n [[package]]\n name = \"cranelift-faerie\"\n version = \"0.36.0\"\n-source = \"git+https://github.com/CraneStation/cranelift.git#e7f2b719eebfb9280c3e38eae42a9ee25221a4e3\"\n+source = \"git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128#ca836a8e0d0b62e2ddecb5902cd5091b468a4db3\"\n dependencies = [\n- \"cranelift-codegen 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n- \"cranelift-module 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n+ \"cranelift-codegen 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n+ \"cranelift-module 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n  \"faerie 0.10.1 (git+https://github.com/m4b/faerie.git)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"goblin 0.0.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -174,42 +174,42 @@ dependencies = [\n [[package]]\n name = \"cranelift-frontend\"\n version = \"0.36.0\"\n-source = \"git+https://github.com/CraneStation/cranelift.git#e7f2b719eebfb9280c3e38eae42a9ee25221a4e3\"\n+source = \"git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128#ca836a8e0d0b62e2ddecb5902cd5091b468a4db3\"\n dependencies = [\n- \"cranelift-codegen 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n+ \"cranelift-codegen 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n  \"log 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"target-lexicon 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"cranelift-module\"\n version = \"0.36.0\"\n-source = \"git+https://github.com/CraneStation/cranelift.git#e7f2b719eebfb9280c3e38eae42a9ee25221a4e3\"\n+source = \"git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128#ca836a8e0d0b62e2ddecb5902cd5091b468a4db3\"\n dependencies = [\n- \"cranelift-codegen 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n- \"cranelift-entity 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n+ \"cranelift-codegen 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n+ \"cranelift-entity 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n version = \"0.36.0\"\n-source = \"git+https://github.com/CraneStation/cranelift.git#e7f2b719eebfb9280c3e38eae42a9ee25221a4e3\"\n+source = \"git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128#ca836a8e0d0b62e2ddecb5902cd5091b468a4db3\"\n dependencies = [\n- \"cranelift-codegen 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n+ \"cranelift-codegen 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n  \"raw-cpuid 6.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"target-lexicon 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"cranelift-simplejit\"\n version = \"0.36.0\"\n-source = \"git+https://github.com/CraneStation/cranelift.git#e7f2b719eebfb9280c3e38eae42a9ee25221a4e3\"\n+source = \"git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128#ca836a8e0d0b62e2ddecb5902cd5091b468a4db3\"\n dependencies = [\n- \"cranelift-codegen 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n- \"cranelift-module 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n- \"cranelift-native 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n+ \"cranelift-codegen 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n+ \"cranelift-module 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n+ \"cranelift-native 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n  \"errno 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"region 2.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -611,10 +611,10 @@ dependencies = [\n  \"ar 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cranelift 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n- \"cranelift-faerie 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n- \"cranelift-module 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n- \"cranelift-simplejit 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\",\n+ \"cranelift 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n+ \"cranelift-faerie 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n+ \"cranelift-module 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n+ \"cranelift-simplejit 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\",\n  \"faerie 0.10.1 (git+https://github.com/m4b/faerie.git)\",\n  \"gimli 0.19.0 (git+https://github.com/gimli-rs/gimli.git)\",\n  \"indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -882,16 +882,16 @@ dependencies = [\n \"checksum cc 1.0.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"39f75544d7bbaf57560d2168f28fd649ff9c76153874db88bdbdfd839b1a7e7d\"\n \"checksum cfg-if 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b486ce3ccf7ffd79fdeb678eac06a9e6c09fc88d33836340becb8fffe87c5e33\"\n \"checksum clap 2.33.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9\"\n-\"checksum cranelift 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n-\"checksum cranelift-bforest 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n-\"checksum cranelift-codegen 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n-\"checksum cranelift-codegen-meta 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n-\"checksum cranelift-entity 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n-\"checksum cranelift-faerie 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n-\"checksum cranelift-frontend 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n-\"checksum cranelift-module 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n-\"checksum cranelift-native 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n-\"checksum cranelift-simplejit 0.36.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n+\"checksum cranelift 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\" = \"<none>\"\n+\"checksum cranelift-bforest 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\" = \"<none>\"\n+\"checksum cranelift-codegen 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\" = \"<none>\"\n+\"checksum cranelift-codegen-meta 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\" = \"<none>\"\n+\"checksum cranelift-entity 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\" = \"<none>\"\n+\"checksum cranelift-faerie 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\" = \"<none>\"\n+\"checksum cranelift-frontend 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\" = \"<none>\"\n+\"checksum cranelift-module 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\" = \"<none>\"\n+\"checksum cranelift-native 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\" = \"<none>\"\n+\"checksum cranelift-simplejit 0.36.0 (git+https://github.com/bjorn3/cretonne.git?branch=do_not_remove_cg_clif_i128)\" = \"<none>\"\n \"checksum crc32fast 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ba125de2af0df55319f41944744ad91c71113bf74a4646efff39afe1f6842db1\"\n \"checksum env_logger 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aafcde04e90a5226a6443b7aabdb016ba2f8307c847d524724bd9b346dd1a2d3\"\n \"checksum errno 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c2a071601ed01b988f896ab14b95e67335d1eeb50190932a1320f7fe3cadc84e\""}, {"sha": "414423d72b975e8c0ca72a28dad83a6745f4edf1", "filename": "Cargo.toml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -27,6 +27,12 @@ gimli = { git = \"https://github.com/gimli-rs/gimli.git\" }\n indexmap = \"1.0.2\"\n object = \"0.12.0\"\n \n+[patch.\"https://github.com/CraneStation/cranelift.git\"]\n+cranelift = { git = \"https://github.com/bjorn3/cretonne.git\", branch = \"do_not_remove_cg_clif_i128\" }\n+cranelift-module = { git = \"https://github.com/bjorn3/cretonne.git\", branch = \"do_not_remove_cg_clif_i128\" }\n+cranelift-simplejit = { git = \"https://github.com/bjorn3/cretonne.git\", branch = \"do_not_remove_cg_clif_i128\" }\n+cranelift-faerie = { git = \"https://github.com/bjorn3/cretonne.git\", branch = \"do_not_remove_cg_clif_i128\" }\n+\n # Uncomment to use local checkout of cranelift\n #[patch.\"https://github.com/CraneStation/cranelift.git\"]\n #cranelift = { path = \"../cranelift/cranelift-umbrella\" }"}, {"sha": "56b65cf3efeabdf931755eb1ea7cba6b8239470d", "filename": "Readme.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -29,10 +29,9 @@ $ RUSTFLAGS=\"-Cpanic=abort -Zcodegen-backend=$cg_clif_dir/target/debug/librustc_\n \n ## Not yet supported\n \n-* Good non-rust abi support ([scalar pair and vector are passed by-ref](https://github.com/bjorn3/rustc_codegen_cranelift/issues/10))\n+* Good non-rust abi support ([vectors are passed by-ref](https://github.com/bjorn3/rustc_codegen_cranelift/issues/10))\n * Checked binops ([some missing instructions in cranelift](https://github.com/CraneStation/cranelift/issues/460))\n * Inline assembly ([no cranelift support](https://github.com/CraneStation/cranelift/issues/444))\n-* u128 and i128 ([no cranelift support](https://github.com/CraneStation/cranelift/issues/354))\n * SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171))\n \n ## Troubleshooting"}, {"sha": "90d245522f60fab393864474f9ef4478c38fa58e", "filename": "build_sysroot/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/build_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/build_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.toml?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -14,7 +14,6 @@ alloc_system = { path = \"./alloc_system\" }\n [patch.crates-io]\n rustc-std-workspace-core = { path = \"./sysroot_src/src/tools/rustc-std-workspace-core\" }\n rustc-std-workspace-alloc = { path = \"./rustc-std-workspace-alloc\" }\n-compiler_builtins = { path = \"./compiler_builtins\" }\n \n [profile.release]\n debug = true"}, {"sha": "724a637a2013514608beeaf9f094a64771f20394", "filename": "build_sysroot/compiler_builtins/Cargo.toml", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bba11f61727e936afd1dc628cf0611ee20acdb9a/build_sysroot%2Fcompiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bba11f61727e936afd1dc628cf0611ee20acdb9a/build_sysroot%2Fcompiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Fcompiler_builtins%2FCargo.toml?ref=bba11f61727e936afd1dc628cf0611ee20acdb9a", "patch": "@@ -1,20 +0,0 @@\n-[package]\n-name = \"compiler_builtins\"\n-# Make sure the `compiler_builtins` from crates.io doesn't take precedence over this\n-# replacement by specifying a higher version than the one on crates.io.\n-version = \"0.1.100\"\n-authors = [\"bjorn3 <bjorn3@users.noreply.github.com>\"]\n-edition = \"2018\"\n-\n-[lib]\n-name = \"compiler_builtins\"\n-path = \"lib.rs\"\n-test = false\n-doc = false\n-\n-[dependencies]\n-core = { path = \"../sysroot_src/src/libcore\" }\n-\n-[features]\n-rustc-dep-of-std = []\n-c = []"}, {"sha": "79a54a3a4b8971750913793423de1501915ba18b", "filename": "build_sysroot/compiler_builtins/lib.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bba11f61727e936afd1dc628cf0611ee20acdb9a/build_sysroot%2Fcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba11f61727e936afd1dc628cf0611ee20acdb9a/build_sysroot%2Fcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Fcompiler_builtins%2Flib.rs?ref=bba11f61727e936afd1dc628cf0611ee20acdb9a", "patch": "@@ -1,9 +0,0 @@\n-#![feature(compiler_builtins, staged_api)]\n-#![compiler_builtins]\n-#![no_std]\n-\n-#![unstable(\n-    feature = \"compiler_builtins_lib\",\n-    reason = \"Compiler builtins. Will never become stable.\",\n-    issue = \"0\"\n-)]"}, {"sha": "069a930e0a2c6410d03dec8cb5cd859ef7556ef4", "filename": "example/mini_core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/example%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/example%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core.rs?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -314,7 +314,7 @@ impl Neg for i16 {\n     type Output = i16;\n \n     fn neg(self) -> i16 {\n-        -self\n+        self\n     }\n }\n "}, {"sha": "e51f257f6b46a4924b0c49c4c425add01a6c2b80", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -236,21 +236,4 @@ fn main() {\n     unsafe { assert_eq!(ABC as usize, 0); }\n \n     &mut (|| Some(0 as *const ())) as &mut FnMut() -> Option<*const ()>;\n-\n-    // checked binops\n-    let zeroi8 = 0i8;\n-    let oneu8 = 1u8;\n-    let onei8 = 1i8;\n-    zeroi8 - 1;\n-    oneu8 - 1;\n-    zeroi8 - -2i8;\n-    #[allow(unreachable_code)]\n-    {\n-        if false {\n-            let minustwoi8 = -2i8;\n-            oneu8 + 255;\n-            onei8 + 127;\n-            minustwoi8 - 127;\n-        }\n-    }\n }"}, {"sha": "a09e050ce3b9078b3821d42a35bd508026b4d2c4", "filename": "example/std_example.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -1,6 +1,7 @@\n #![feature(core_intrinsics)]\n \n use std::io::Write;\n+use std::intrinsics;\n \n fn main() {\n     let _ = ::std::iter::repeat('a' as u8).take(10).collect::<Vec<_>>();\n@@ -29,6 +30,18 @@ fn main() {\n     println!(\"{}\", 2.3f32.ceil());\n     println!(\"{}\", 2.3f32.min(1.0));\n     println!(\"{}\", 2.3f32.max(1.0));\n+\n+    assert_eq!(0b0000000000000000000000000010000010000000000000000000000000000000_0000000000100000000000000000000000001000000000000100000000000000u128.leading_zeros(), 26);\n+    assert_eq!(0b0000000000000000000000000010000000000000000000000000000000000000_0000000000000000000000000000000000001000000000000000000010000000u128.trailing_zeros(), 7);\n+\n+    0i128.checked_div(2i128);\n+    0u128.checked_div(2u128);\n+    assert_eq!(1u128 + 2, 3);\n+\n+    assert_eq!(0b100010000000000000000000000000000u128 >> 10, 0b10001000000000000000000u128);\n+    assert_eq!(0xFEDCBA987654321123456789ABCDEFu128 >> 64, 0xFEDCBA98765432u128);\n+    assert_eq!(0xFEDCBA987654321123456789ABCDEFu128 as i128 >> 64, 0xFEDCBA98765432i128);\n+    assert_eq!(353985398u128 * 932490u128, 330087843781020u128);\n }\n \n #[derive(PartialEq)]"}, {"sha": "5e041e6c6d37d7f82d3c5d5dd5d1ef6596533eec", "filename": "src/abi.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -87,7 +87,7 @@ pub fn scalar_to_clif_type(tcx: TyCtxt, scalar: Scalar) -> Type {\n             Integer::I16 => types::I16,\n             Integer::I32 => types::I32,\n             Integer::I64 => types::I64,\n-            Integer::I128 => unimpl!(\"u/i128\"),\n+            Integer::I128 => types::I128,\n         },\n         Primitive::Float(flt) => match flt {\n             FloatTy::F32 => types::F32,\n@@ -252,14 +252,12 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n         &mut self,\n         name: &str,\n         input_tys: Vec<types::Type>,\n-        output_ty: Option<types::Type>,\n+        output_tys: Vec<types::Type>,\n         args: &[Value],\n-    ) -> Option<Value> {\n+    ) -> &[Value] {\n         let sig = Signature {\n             params: input_tys.iter().cloned().map(AbiParam::new).collect(),\n-            returns: output_ty\n-                .map(|output_ty| vec![AbiParam::new(output_ty)])\n-                .unwrap_or(Vec::new()),\n+            returns: output_tys.iter().cloned().map(AbiParam::new).collect(),\n             call_conv: CallConv::SystemV,\n         };\n         let func_id = self\n@@ -270,12 +268,10 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n             .module\n             .declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n-        if output_ty.is_none() {\n-            return None;\n-        }\n+        self.add_comment(call_inst, format!(\"easy_call {}\", name));\n         let results = self.bcx.inst_results(call_inst);\n-        assert_eq!(results.len(), 1);\n-        Some(results[0])\n+        assert!(results.len() <= 2, \"{}\", results.len());\n+        results\n     }\n \n     pub fn easy_call(\n@@ -294,23 +290,22 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n             })\n             .unzip();\n         let return_layout = self.layout_of(return_ty);\n-        let return_ty = if let ty::Tuple(tup) = return_ty.sty {\n-            if !tup.is_empty() {\n-                bug!(\"easy_call( (...) -> <non empty tuple> ) is not allowed\");\n-            }\n-            None\n+        let return_tys = if let ty::Tuple(tup) = return_ty.sty {\n+            tup.types().map(|ty| self.clif_type(ty).unwrap()).collect()\n         } else {\n-            Some(self.clif_type(return_ty).unwrap())\n+            vec![self.clif_type(return_ty).unwrap()]\n         };\n-        if let Some(val) = self.lib_call(name, input_tys, return_ty, &args) {\n-            CValue::by_val(val, return_layout)\n-        } else {\n-            CValue::by_ref(\n+        let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n+        match *ret_vals {\n+            [] => CValue::by_ref(\n                 self.bcx\n                     .ins()\n                     .iconst(self.pointer_type, self.pointer_type.bytes() as i64),\n                 return_layout,\n-            )\n+            ),\n+            [val] => CValue::by_val(val, return_layout),\n+            [val, extra] => CValue::by_val_pair(val, extra, return_layout),\n+            _ => unreachable!(),\n         }\n     }\n \n@@ -346,7 +341,7 @@ fn add_arg_comment<'a, 'tcx: 'a>(\n     };\n     let pass_mode = format!(\"{:?}\", pass_mode);\n     fx.add_global_comment(format!(\n-        \"{msg:5} {local:>3}{local_field:<5} {params:10} {pass_mode:20} {ssa:10} {ty:?}\",\n+        \"{msg:5} {local:>3}{local_field:<5} {params:10} {pass_mode:36} {ssa:10} {ty:?}\",\n         msg = msg,\n         local = format!(\"{:?}\", local),\n         local_field = local_field,\n@@ -360,7 +355,7 @@ fn add_arg_comment<'a, 'tcx: 'a>(\n #[cfg(debug_assertions)]\n fn add_local_header_comment(fx: &mut FunctionCx<impl Backend>) {\n     fx.add_global_comment(format!(\n-        \"msg   loc.idx    param    pass mode            ssa flags  ty\"\n+        \"msg   loc.idx    param    pass mode                            ssa flags  ty\"\n     ));\n }\n \n@@ -846,7 +841,7 @@ pub fn codegen_drop<'a, 'tcx: 'a>(\n                 );\n                 drop_place.write_place_ref(fx, arg_place);\n                 let arg_value = arg_place.to_cvalue(fx);\n-                crate::abi::codegen_call_inner(\n+                codegen_call_inner(\n                     fx,\n                     None,\n                     drop_fn_ty,"}, {"sha": "3d09b7cefc5604b4282be6777e2c61c46720c6e8", "filename": "src/base.rs", "status": "modified", "additions": 34, "deletions": 89, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -11,83 +11,6 @@ pub fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n \n     let mir = tcx.instance_mir(instance.def);\n \n-    // Check fn sig for u128 and i128 and replace those functions with a trap.\n-    {\n-        // FIXME implement u128 and i128 support\n-\n-        // Check sig for u128 and i128\n-        let fn_sig = tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &instance.fn_sig(tcx));\n-\n-        struct UI128Visitor<'tcx>(TyCtxt<'tcx>, bool);\n-\n-        impl<'tcx> rustc::ty::fold::TypeVisitor<'tcx> for UI128Visitor<'tcx> {\n-            fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-                if t.sty == self.0.types.u128.sty || t.sty == self.0.types.i128.sty {\n-                    self.1 = true;\n-                    return false; // stop visiting\n-                }\n-\n-                t.super_visit_with(self)\n-            }\n-        }\n-\n-        let mut visitor = UI128Visitor(tcx, false);\n-        fn_sig.visit_with(&mut visitor);\n-\n-        //If found replace function with a trap.\n-        if visitor.1 {\n-            tcx.sess.warn(\"u128 and i128 are not yet supported. \\\n-            Functions using these as args will be replaced with a trap.\");\n-\n-            // Declare function with fake signature\n-            let sig = Signature {\n-                params: vec![AbiParam::new(types::INVALID)],\n-                returns: vec![],\n-                call_conv: CallConv::Fast,\n-            };\n-            let name = tcx.symbol_name(instance).as_str();\n-            let func_id = cx.module.declare_function(&*name, linkage, &sig).unwrap();\n-\n-            // Create trapping function\n-            let mut func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n-            let mut func_ctx = FunctionBuilderContext::new();\n-            let mut bcx = FunctionBuilder::new(&mut func, &mut func_ctx);\n-            let start_ebb = bcx.create_ebb();\n-            bcx.append_ebb_params_for_function_params(start_ebb);\n-            bcx.switch_to_block(start_ebb);\n-\n-            let mut fx = FunctionCx {\n-                tcx,\n-                module: cx.module,\n-                pointer_type: pointer_ty(tcx),\n-\n-                instance,\n-                mir,\n-\n-                bcx,\n-                ebb_map: HashMap::new(),\n-                local_map: HashMap::new(),\n-\n-                clif_comments: crate::pretty_clif::CommentWriter::new(tcx, instance),\n-                constants: &mut cx.ccx,\n-                caches: &mut cx.caches,\n-                source_info_set: indexmap::IndexSet::new(),\n-            };\n-\n-            crate::trap::trap_unreachable(&mut fx, \"[unimplemented] Called function with u128 or i128 as argument.\");\n-            fx.bcx.seal_all_blocks();\n-            fx.bcx.finalize();\n-\n-            // Define function\n-            cx.caches.context.func = func;\n-            cx.module\n-                .define_function(func_id, &mut cx.caches.context)\n-                .unwrap();\n-            cx.caches.context.clear();\n-            return;\n-        }\n-    }\n-\n     // Declare function\n     let (name, sig) = get_function_name_and_sig(tcx, instance, false);\n     let func_id = cx.module.declare_function(&name, linkage, &sig).unwrap();\n@@ -241,7 +164,7 @@ fn codegen_fn_content<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx, impl Backend>)\n                 } else {\n                     fx.bcx.ins().brz(cond, target, &[]);\n                 };\n-                trap_panic(fx, format!(\"[panic] Assert {:?} failed at {:?}.\", msg, bb_data.terminator().source_info.span));\n+                trap_panic(fx, format!(\"[panic] Assert {:?} at {:?} failed.\", msg, bb_data.terminator().source_info.span));\n             }\n \n             TerminatorKind::SwitchInt {\n@@ -343,7 +266,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                         .discriminant_for_variant(fx.tcx, *variant_index)\n                         .unwrap()\n                         .val;\n-                    let discr = CValue::const_val(fx, ptr.layout().ty, to as u64 as i64);\n+                    let discr = CValue::const_val(fx, ptr.layout().ty, to);\n                     ptr.write_cvalue(fx, discr);\n                 }\n                 layout::Variants::Multiple {\n@@ -366,7 +289,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                         let niche_llval = if niche_value == 0 {\n                             CValue::const_val(fx, niche.layout().ty, 0)\n                         } else {\n-                            CValue::const_val(fx, niche.layout().ty, niche_value as u64 as i64)\n+                            CValue::const_val(fx, niche.layout().ty, niche_value)\n                         };\n                         niche.write_cvalue(fx, niche_llval);\n                     }\n@@ -391,7 +314,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     let rhs = trans_operand(fx, rhs);\n \n                     let res = match ty.sty {\n-                        ty::Bool => trans_bool_binop(fx, *bin_op, lhs, rhs, lval.layout().ty),\n+                        ty::Bool => trans_bool_binop(fx, *bin_op, lhs, rhs),\n                         ty::Uint(_) => {\n                             trans_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, false)\n                         }\n@@ -434,15 +357,21 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                                     let res = fx.bcx.ins().icmp_imm(IntCC::Equal, val, 0);\n                                     fx.bcx.ins().bint(types::I8, res)\n                                 }\n-                                ty::Uint(_) | ty::Int(_) => fx.bcx.ins().bnot(val),\n+                                ty::Uint(_) | ty::Int(_) => {\n+                                    fx.bcx.ins().bnot(val)\n+                                }\n                                 _ => unimplemented!(\"un op Not for {:?}\", layout.ty),\n                             }\n                         }\n                         UnOp::Neg => match layout.ty.sty {\n                             ty::Int(_) => {\n                                 let clif_ty = fx.clif_type(layout.ty).unwrap();\n-                                let zero = fx.bcx.ins().iconst(clif_ty, 0);\n-                                fx.bcx.ins().isub(zero, val)\n+                                if clif_ty == types::I128 {\n+                                    crate::trap::trap_unreachable_ret_value(fx, layout, \"i128 neg is not yet supported\").load_scalar(fx)\n+                                } else {\n+                                    let zero = fx.bcx.ins().iconst(clif_ty, 0);\n+                                    fx.bcx.ins().isub(zero, val)\n+                                }\n                             }\n                             ty::Float(_) => fx.bcx.ins().fneg(val),\n                             _ => unimplemented!(\"un op Neg for {:?}\", layout.ty),\n@@ -633,7 +562,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                         .ty\n                         .is_sized(fx.tcx.at(DUMMY_SP), ParamEnv::reveal_all()));\n                     let ty_size = fx.layout_of(ty).size.bytes();\n-                    let val = CValue::const_val(fx, fx.tcx.types.usize, ty_size as i64);\n+                    let val = CValue::const_val(fx, fx.tcx.types.usize, ty_size.into());\n                     lval.write_cvalue(fx, val);\n                 }\n                 Rvalue::Aggregate(kind, operands) => match **kind {\n@@ -666,7 +595,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                 clobbers, // Vec<Name>\n                 volatile, // bool\n                 alignstack, // bool\n-                dialect, // syntax::ast::AsmDialect\n+                dialect: _, // syntax::ast::AsmDialect\n                 asm_str_style: _,\n                 ctxt: _,\n             } = asm;\n@@ -705,6 +634,9 @@ fn trans_stmt<'a, 'tcx: 'a>(\n \n                     crate::trap::trap_unimplemented(fx, \"_xgetbv arch intrinsic is not supported\");\n                 }\n+                _ if fx.tcx.symbol_name(fx.instance).as_str() == \"__rust_probestack\" => {\n+                    crate::trap::trap_unimplemented(fx, \"__rust_probestack is not supported\");\n+                }\n                 _ => unimpl!(\"Inline assembly is not supported\"),\n             }\n         }\n@@ -747,7 +679,7 @@ pub fn trans_get_discriminant<'a, 'tcx: 'a>(\n                 .map_or(index.as_u32() as u128, |def| {\n                     def.discriminant_for_variant(fx.tcx, *index).val\n                 });\n-            return CValue::const_val(fx, dest_layout.ty, discr_val as u64 as i64);\n+            return CValue::const_val(fx, dest_layout.ty, discr_val);\n         }\n         layout::Variants::Multiple { discr, discr_index, discr_kind, variants: _ } => {\n             (discr, *discr_index, discr_kind)\n@@ -856,10 +788,9 @@ fn trans_bool_binop<'a, 'tcx: 'a>(\n     bin_op: BinOp,\n     lhs: CValue<'tcx>,\n     rhs: CValue<'tcx>,\n-    ty: Ty<'tcx>,\n ) -> CValue<'tcx> {\n     let res = binop_match! {\n-        fx, bin_op, false, lhs, rhs, ty, \"bool\";\n+        fx, bin_op, false, lhs, rhs, fx.tcx.types.bool, \"bool\";\n         Add (_) bug;\n         Sub (_) bug;\n         Mul (_) bug;\n@@ -899,6 +830,11 @@ pub fn trans_int_binop<'a, 'tcx: 'a>(\n             \"int binop requires lhs and rhs of same type\"\n         );\n     }\n+\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, false, signed, lhs, rhs, out_ty) {\n+        return res;\n+    }\n+\n     binop_match! {\n         fx, bin_op, signed, lhs, rhs, out_ty, \"int/uint\";\n         Add (_) iadd;\n@@ -938,6 +874,10 @@ pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n     out_ty: Ty<'tcx>,\n     signed: bool,\n ) -> CValue<'tcx> {\n+    if !fx.tcx.sess.overflow_checks() {\n+        return trans_int_binop(fx, bin_op, in_lhs, in_rhs, out_ty, signed);\n+    }\n+\n     if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n         assert_eq!(\n             in_lhs.layout().ty,\n@@ -948,6 +888,11 @@ pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n \n     let lhs = in_lhs.load_scalar(fx);\n     let rhs = in_rhs.load_scalar(fx);\n+\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, true, signed, in_lhs, in_rhs, out_ty) {\n+        return res;\n+    }\n+\n     let (res, has_overflow) = match bin_op {\n         BinOp::Add => {\n             /*let (val, c_out) = fx.bcx.ins().iadd_cout(lhs, rhs);"}, {"sha": "9cd6bc8c78687a2d7f1a5bfa1c5adf70d46f2815", "filename": "src/codegen_i128.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -0,0 +1,195 @@\n+//! Replaces 128-bit operators with lang item calls\n+\n+use crate::prelude::*;\n+\n+pub fn maybe_codegen<'a, 'tcx>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    bin_op: BinOp,\n+    checked: bool,\n+    is_signed: bool,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+    out_ty: Ty<'tcx>,\n+) -> Option<CValue<'tcx>> {\n+    if lhs.layout().ty != fx.tcx.types.u128 && lhs.layout().ty != fx.tcx.types.i128 {\n+        return None;\n+    }\n+\n+    let lhs_val = lhs.load_scalar(fx);\n+    let rhs_val = rhs.load_scalar(fx);\n+\n+    match bin_op {\n+        BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor => {\n+            assert!(!checked);\n+            return None;\n+        }\n+        BinOp::Add | BinOp::Sub if !checked => return None,\n+        BinOp::Add => {\n+            return Some(if is_signed {\n+                fx.easy_call(\"__rust_i128_addo\", &[lhs, rhs], out_ty)\n+            } else {\n+                fx.easy_call(\"__rust_u128_addo\", &[lhs, rhs], out_ty)\n+            })\n+        }\n+        BinOp::Sub => {\n+            return Some(if is_signed {\n+                fx.easy_call(\"__rust_i128_subo\", &[lhs, rhs], out_ty)\n+            } else {\n+                fx.easy_call(\"__rust_u128_subo\", &[lhs, rhs], out_ty)\n+            })\n+        }\n+        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n+        BinOp::Mul => {\n+            let res = if checked {\n+                if is_signed {\n+                    fx.easy_call(\"__rust_i128_mulo\", &[lhs, rhs], out_ty)\n+                } else {\n+                    fx.easy_call(\"__rust_u128_mulo\", &[lhs, rhs], out_ty)\n+                }\n+            } else {\n+                let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n+                fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty)\n+            };\n+            return Some(res);\n+        }\n+        BinOp::Div => {\n+            assert!(!checked);\n+            if is_signed {\n+                Some(fx.easy_call(\"__divti3\", &[lhs, rhs], fx.tcx.types.i128))\n+            } else {\n+                Some(fx.easy_call(\"__udivti3\", &[lhs, rhs], fx.tcx.types.u128))\n+            }\n+        }\n+        BinOp::Rem => {\n+            assert!(!checked);\n+            if is_signed {\n+                Some(fx.easy_call(\"__modti3\", &[lhs, rhs], fx.tcx.types.i128))\n+            } else {\n+                Some(fx.easy_call(\"__umodti3\", &[lhs, rhs], fx.tcx.types.u128))\n+            }\n+        }\n+        BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {\n+            assert!(!checked);\n+            let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs_val);\n+            let (rhs_lsb, rhs_msb) = fx.bcx.ins().isplit(rhs_val);\n+\n+            let res = match bin_op {\n+                BinOp::Eq => {\n+                    let lsb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_lsb, rhs_lsb);\n+                    let msb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_msb, rhs_msb);\n+                    fx.bcx.ins().band(lsb_eq, msb_eq)\n+                }\n+                BinOp::Ne => {\n+                    let lsb_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_lsb, rhs_lsb);\n+                    let msb_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_msb, rhs_msb);\n+                    fx.bcx.ins().bor(lsb_ne, msb_ne)\n+                }\n+                _ => {\n+                    // if msb_eq {\n+                    //     lhs_cc\n+                    // } else {\n+                    //     msb_cc\n+                    // }\n+                    let cc = match (bin_op, is_signed) {\n+                        (BinOp::Ge, false) => IntCC::UnsignedGreaterThanOrEqual,\n+                        (BinOp::Gt, false) => IntCC::UnsignedGreaterThan,\n+                        (BinOp::Lt, false) => IntCC::UnsignedLessThan,\n+                        (BinOp::Le, false) => IntCC::UnsignedLessThanOrEqual,\n+\n+                        (BinOp::Ge, true) => IntCC::SignedGreaterThanOrEqual,\n+                        (BinOp::Gt, true) => IntCC::SignedGreaterThan,\n+                        (BinOp::Lt, true) => IntCC::SignedLessThan,\n+                        (BinOp::Le, true) => IntCC::SignedLessThanOrEqual,\n+                        _ => unreachable!(),\n+                    };\n+\n+                    let msb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_msb, rhs_msb);\n+                    let lsb_cc = fx.bcx.ins().icmp(cc, lhs_lsb, rhs_lsb);\n+                    let msb_cc = fx.bcx.ins().icmp(cc, lhs_msb, rhs_msb);\n+\n+                    fx.bcx.ins().select(msb_eq, lsb_cc, msb_cc)\n+                }\n+            };\n+\n+            let res = fx.bcx.ins().bint(types::I8, res);\n+            let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.bool));\n+            return Some(res);\n+        }\n+        BinOp::Shl | BinOp::Shr => {\n+            let is_overflow = if checked {\n+                // rhs >= 128\n+\n+                // FIXME support non 128bit rhs\n+                /*let (rhs_lsb, rhs_msb) = fx.bcx.ins().isplit(rhs_val);\n+                let rhs_msb_gt_0 = fx.bcx.ins().icmp_imm(IntCC::NotEqual, rhs_msb, 0);\n+                let rhs_lsb_ge_128 = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThan, rhs_lsb, 127);\n+                let is_overflow = fx.bcx.ins().bor(rhs_msb_gt_0, rhs_lsb_ge_128);*/\n+                let is_overflow = fx.bcx.ins().bconst(types::B1, false);\n+\n+                Some(fx.bcx.ins().bint(types::I8, is_overflow))\n+            } else {\n+                None\n+            };\n+\n+            // Optimize `val >> 64`, because compiler_builtins uses it to deconstruct an 128bit\n+            // integer into its lsb and msb.\n+            // https://github.com/rust-lang-nursery/compiler-builtins/blob/79a6a1603d5672cbb9187ff41ff4d9b5048ac1cb/src/int/mod.rs#L217\n+            if let Some(64) = resolve_value_imm(fx.bcx.func, rhs_val) {\n+                let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs_val);\n+                let all_zeros = fx.bcx.ins().iconst(types::I64, 0);\n+                let val = match (bin_op, is_signed) {\n+                    (BinOp::Shr, false) => {\n+                        let val = fx.bcx.ins().iconcat(lhs_msb, all_zeros);\n+                        Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.u128)))\n+                    }\n+                    (BinOp::Shr, true) => {\n+                        let sign = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, lhs_msb, 0);\n+                        let all_ones = fx.bcx.ins().iconst(types::I64, u64::max_value() as i64);\n+                        let all_sign_bits = fx.bcx.ins().select(sign, all_zeros, all_ones);\n+\n+                        let val = fx.bcx.ins().iconcat(lhs_msb, all_sign_bits);\n+                        Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.i128)))\n+                    }\n+                    (BinOp::Shl, _) => {\n+                        let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n+                        let val = fx.bcx.ins().iconcat(all_zeros, lhs_lsb);\n+                        Some(CValue::by_val(val, fx.layout_of(val_ty)))\n+                    }\n+                    _ => None\n+                };\n+                if let Some(val) = val {\n+                    if let Some(is_overflow) = is_overflow {\n+                        let val = val.load_scalar(fx);\n+                        return Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)))\n+                    } else {\n+                        return Some(val);\n+                    }\n+                }\n+            }\n+\n+            let truncated_rhs = clif_intcast(fx, rhs_val, types::I32, false);\n+            let truncated_rhs = CValue::by_val(truncated_rhs, fx.layout_of(fx.tcx.types.u32));\n+            let val = match (bin_op, is_signed) {\n+                (BinOp::Shl, false) => {\n+                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.tcx.types.u128)\n+                }\n+                (BinOp::Shl, true) => {\n+                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.tcx.types.i128)\n+                }\n+                (BinOp::Shr, false) => {\n+                    fx.easy_call(\"__lshrti3\", &[lhs, truncated_rhs], fx.tcx.types.u128)\n+                }\n+                (BinOp::Shr, true) => {\n+                    fx.easy_call(\"__ashrti3\", &[lhs, truncated_rhs], fx.tcx.types.i128)\n+                }\n+                (_, _) => unreachable!(),\n+            };\n+            if let Some(is_overflow) = is_overflow {\n+                let val = val.load_scalar(fx);\n+                Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)))\n+            } else {\n+                Some(val)\n+            }\n+        }\n+    }\n+}"}, {"sha": "6a00d1341980b64094fe454b29ee6a27e63f513f", "filename": "src/common.rs", "status": "modified", "additions": 79, "deletions": 10, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -1,5 +1,6 @@\n use rustc_target::spec::{HasTargetSpec, Target};\n \n+use cranelift::codegen::ir::{Opcode, InstructionData, ValueDef};\n use cranelift_module::Module;\n \n use crate::prelude::*;\n@@ -28,15 +29,15 @@ pub fn clif_type_from_ty<'tcx>(\n             UintTy::U16 => types::I16,\n             UintTy::U32 => types::I32,\n             UintTy::U64 => types::I64,\n-            UintTy::U128 => unimpl!(\"u128\"),\n+            UintTy::U128 => types::I128,\n             UintTy::Usize => pointer_ty(tcx),\n         },\n         ty::Int(size) => match size {\n             IntTy::I8 => types::I8,\n             IntTy::I16 => types::I16,\n             IntTy::I32 => types::I32,\n             IntTy::I64 => types::I64,\n-            IntTy::I128 => unimpl!(\"i128\"),\n+            IntTy::I128 => types::I128,\n             IntTy::Isize => pointer_ty(tcx),\n         },\n         ty::Char => types::I32,\n@@ -62,7 +63,7 @@ pub fn codegen_select(bcx: &mut FunctionBuilder, cond: Value, lhs: Value, rhs: V\n     let rhs_ty = bcx.func.dfg.value_type(rhs);\n     assert_eq!(lhs_ty, rhs_ty);\n     if lhs_ty == types::I8 || lhs_ty == types::I16 {\n-        // FIXME workaround for missing enocding for select.i8\n+        // FIXME workaround for missing encoding for select.i8\n         let lhs = bcx.ins().uextend(types::I32, lhs);\n         let rhs = bcx.ins().uextend(types::I32, rhs);\n         let res = bcx.ins().select(cond, lhs, rhs);\n@@ -79,17 +80,85 @@ pub fn clif_intcast<'a, 'tcx: 'a>(\n     signed: bool,\n ) -> Value {\n     let from = fx.bcx.func.dfg.value_type(val);\n-    if from == to {\n-        return val;\n+    match (from, to) {\n+        // equal\n+        (_, _) if from == to => val,\n+\n+        // extend\n+        (_, types::I128) => {\n+            let wider = if from == types::I64 {\n+                val\n+            } else if signed {\n+                fx.bcx.ins().sextend(types::I64, val)\n+            } else {\n+                fx.bcx.ins().uextend(types::I64, val)\n+            };\n+            let zero = fx.bcx.ins().iconst(types::I64, 0);\n+            fx.bcx.ins().iconcat(wider, zero)\n+        }\n+        (_, _) if to.wider_or_equal(from) => {\n+            if signed {\n+                fx.bcx.ins().sextend(to, val)\n+            } else {\n+                fx.bcx.ins().uextend(to, val)\n+            }\n+        }\n+\n+        // reduce\n+        (types::I128, _) => {\n+            let (lsb, _msb) = fx.bcx.ins().isplit(val);\n+            if to == types::I64 {\n+                lsb\n+            } else {\n+                fx.bcx.ins().ireduce(to, lsb)\n+            }\n+        }\n+        (_, _) => {\n+            fx.bcx.ins().ireduce(to, val)\n+        }\n     }\n-    if to.wider_or_equal(from) {\n-        if signed {\n-            fx.bcx.ins().sextend(to, val)\n+}\n+\n+fn resolve_normal_value_imm(func: &Function, val: Value) -> Option<i64> {\n+    if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n+        if let InstructionData::UnaryImm {\n+            opcode: Opcode::Iconst,\n+            imm,\n+        } = func.dfg[inst] {\n+            Some(imm.into())\n         } else {\n-            fx.bcx.ins().uextend(to, val)\n+            None\n         }\n     } else {\n-        fx.bcx.ins().ireduce(to, val)\n+        None\n+    }\n+}\n+\n+fn resolve_128bit_value_imm(func: &Function, val: Value) -> Option<u128> {\n+    let (lsb, msb) = if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n+        if let InstructionData::Binary {\n+            opcode: Opcode::Iconcat,\n+            args: [lsb, msb],\n+        } = func.dfg[inst] {\n+            (lsb, msb)\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        return None;\n+    };\n+\n+    let lsb = resolve_normal_value_imm(func, lsb)? as u64 as u128;\n+    let msb = resolve_normal_value_imm(func, msb)? as u64 as u128;\n+\n+    Some(msb << 64 | lsb)\n+}\n+\n+pub fn resolve_value_imm(func: &Function, val: Value) -> Option<u128> {\n+    if func.dfg.value_type(val) == types::I128 {\n+        resolve_128bit_value_imm(func, val)\n+    } else {\n+        resolve_normal_value_imm(func, val).map(|imm| imm as u64 as u128)\n     }\n }\n "}, {"sha": "10f757ffce876b9c610c71c446ad3f28de5b1ee7", "filename": "src/constant.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -113,17 +113,13 @@ pub fn trans_const_value<'a, 'tcx: 'a>(\n     let ty = fx.monomorphize(&const_.ty);\n     let layout = fx.layout_of(ty);\n     match ty.sty {\n-        ty::Bool => {\n+        ty::Bool | ty::Uint(_) => {\n             let bits = const_.val.try_to_bits(layout.size).unwrap();\n-            CValue::const_val(fx, ty, bits as u64 as i64)\n-        }\n-        ty::Uint(_) => {\n-            let bits = const_.val.try_to_bits(layout.size).unwrap();\n-            CValue::const_val(fx, ty, bits as u64 as i64)\n+            CValue::const_val(fx, ty, bits)\n         }\n         ty::Int(_) => {\n             let bits = const_.val.try_to_bits(layout.size).unwrap();\n-            CValue::const_val(fx, ty, rustc::mir::interpret::sign_extend(bits, layout.size) as i128 as i64)\n+            CValue::const_val(fx, ty, rustc::mir::interpret::sign_extend(bits, layout.size))\n         }\n         ty::FnDef(_def_id, _substs) => CValue::by_ref(\n             fx.bcx"}, {"sha": "ee00924ad821dcdb0be7d5f16ebc281f17b851fc", "filename": "src/intrinsics.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -103,7 +103,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n             // Insert non returning intrinsics here\n             match intrinsic {\n                 \"abort\" => {\n-                    trap_panic(fx, \"Called intrinisc::abort.\");\n+                    trap_panic(fx, \"Called intrinsic::abort.\");\n                 }\n                 \"unreachable\" => {\n                     trap_unreachable(fx, \"[corruption] Called intrinsic::unreachable.\");\n@@ -150,7 +150,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         };\n         size_of, <T> () {\n             let size_of = fx.layout_of(T).size.bytes();\n-            let size_of = CValue::const_val(fx, usize_layout.ty, size_of as i64);\n+            let size_of = CValue::const_val(fx, usize_layout.ty, size_of.into());\n             ret.write_cvalue(fx, size_of);\n         };\n         size_of_val, <T> (c ptr) {\n@@ -169,7 +169,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         };\n         min_align_of, <T> () {\n             let min_align = fx.layout_of(T).align.abi.bytes();\n-            let min_align = CValue::const_val(fx, usize_layout.ty, min_align as i64);\n+            let min_align = CValue::const_val(fx, usize_layout.ty, min_align.into());\n             ret.write_cvalue(fx, min_align);\n         };\n         min_align_of_val, <T> (c ptr) {\n@@ -188,14 +188,14 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         };\n         pref_align_of, <T> () {\n             let pref_align = fx.layout_of(T).align.pref.bytes();\n-            let pref_align = CValue::const_val(fx, usize_layout.ty, pref_align as i64);\n+            let pref_align = CValue::const_val(fx, usize_layout.ty, pref_align.into());\n             ret.write_cvalue(fx, pref_align);\n         };\n \n \n         type_id, <T> () {\n             let type_id = fx.tcx.type_id_hash(T);\n-            let type_id = CValue::const_val(fx, u64_layout.ty, type_id as i64);\n+            let type_id = CValue::const_val(fx, u64_layout.ty, type_id.into());\n             ret.write_cvalue(fx, type_id);\n         };\n         type_name, <T> () {\n@@ -390,11 +390,33 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n             fx.bcx.call_memset(fx.module.target_config(), dst_ptr, val, count);\n         };\n         ctlz | ctlz_nonzero, <T> (v arg) {\n-            let res = CValue::by_val(fx.bcx.ins().clz(arg), fx.layout_of(T));\n+            let res = if T == fx.tcx.types.u128 || T == fx.tcx.types.i128 {\n+                // FIXME verify this algorithm is correct\n+                let (lsb, msb) = fx.bcx.ins().isplit(arg);\n+                let lsb_lz = fx.bcx.ins().clz(lsb);\n+                let msb_lz = fx.bcx.ins().clz(msb);\n+                let msb_is_zero = fx.bcx.ins().icmp_imm(IntCC::Equal, msb, 0);\n+                let lsb_lz_plus_64 = fx.bcx.ins().iadd_imm(lsb_lz, 64);\n+                fx.bcx.ins().select(msb_is_zero, lsb_lz_plus_64, msb_lz)\n+            } else {\n+                fx.bcx.ins().clz(arg)\n+            };\n+            let res = CValue::by_val(res, fx.layout_of(T));\n             ret.write_cvalue(fx, res);\n         };\n         cttz | cttz_nonzero, <T> (v arg) {\n-            let res = CValue::by_val(fx.bcx.ins().ctz(arg), fx.layout_of(T));\n+            let res = if T == fx.tcx.types.u128 || T == fx.tcx.types.i128 {\n+                // FIXME verify this algorithm is correct\n+                let (lsb, msb) = fx.bcx.ins().isplit(arg);\n+                let lsb_tz = fx.bcx.ins().ctz(lsb);\n+                let msb_tz = fx.bcx.ins().ctz(msb);\n+                let lsb_is_zero = fx.bcx.ins().icmp_imm(IntCC::Equal, lsb, 0);\n+                let msb_tz_plus_64 = fx.bcx.ins().iadd_imm(msb_tz, 64);\n+                fx.bcx.ins().select(lsb_is_zero, msb_tz_plus_64, lsb_tz)\n+            } else {\n+                fx.bcx.ins().ctz(arg)\n+            };\n+            let res = CValue::by_val(res, fx.layout_of(T));\n             ret.write_cvalue(fx, res);\n         };\n         ctpop, <T> (v arg) {\n@@ -472,7 +494,13 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                         let or_tmp6 = bcx.ins().bor(or_tmp3, or_tmp4);\n                         bcx.ins().bor(or_tmp5, or_tmp6)\n                     }\n-                    ty => unimplemented!(\"bwap {}\", ty),\n+                    types::I128 => {\n+                        let (lo, hi) = bcx.ins().isplit(v);\n+                        let lo = swap(bcx, lo);\n+                        let hi = swap(bcx, hi);\n+                        bcx.ins().iconcat(hi, lo)\n+                    }\n+                    ty => unimplemented!(\"bswap {}\", ty),\n                 }\n             };\n             let res = CValue::by_val(swap(&mut fx.bcx, arg), fx.layout_of(T));"}, {"sha": "8a4e79d544ba42821aaf6562956525699f8f7459", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -34,6 +34,7 @@ mod allocator;\n mod analyze;\n mod archive;\n mod base;\n+mod codegen_i128;\n mod common;\n mod constant;\n mod debuginfo;\n@@ -53,7 +54,7 @@ mod vtable;\n mod prelude {\n     pub use std::any::Any;\n     pub use std::collections::{HashMap, HashSet};\n-    pub use std::convert::TryInto;\n+    pub use std::convert::{TryFrom, TryInto};\n \n     pub use syntax::ast::{FloatTy, IntTy, UintTy};\n     pub use syntax::source_map::{Pos, Span, DUMMY_SP};\n@@ -242,6 +243,8 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n         \"false\"\n     }).unwrap();\n \n+    flags_builder.set(\"opt_level\", \"best\").unwrap();\n+\n     // FIXME enable again when https://github.com/CraneStation/cranelift/issues/664 is fixed\n     /*\n     use rustc::session::config::OptLevel;"}, {"sha": "a8b3a2954381f566d682d5dfda888a58aa3c06e5", "filename": "src/value_and_place.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302f88d23c8e7095e675049bc07a7872da52e13/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=a302f88d23c8e7095e675049bc07a7872da52e13", "patch": "@@ -137,17 +137,38 @@ impl<'tcx> CValue<'tcx> {\n         crate::unsize::coerce_unsized_into(fx, self, dest);\n     }\n \n+    /// If `ty` is signed, `const_val` must already be sign extended.\n     pub fn const_val<'a>(\n         fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n         ty: Ty<'tcx>,\n-        const_val: i64,\n+        const_val: u128,\n     ) -> CValue<'tcx>\n     where\n         'tcx: 'a,\n     {\n         let clif_ty = fx.clif_type(ty).unwrap();\n         let layout = fx.layout_of(ty);\n-        CValue::by_val(fx.bcx.ins().iconst(clif_ty, const_val), layout)\n+\n+        let val = match ty.sty {\n+            ty::TyKind::Uint(UintTy::U128) | ty::TyKind::Int(IntTy::I128) => {\n+                let lsb = fx.bcx.ins().iconst(types::I64, const_val as u64 as i64);\n+                let msb = fx.bcx.ins().iconst(types::I64, (const_val >> 64) as u64 as i64);\n+                fx.bcx.ins().iconcat(lsb, msb)\n+            }\n+            ty::TyKind::Bool => {\n+                assert!(const_val == 0 || const_val == 1, \"Invalid bool 0x{:032X}\", const_val);\n+                fx.bcx.ins().iconst(types::I8, const_val as i64)\n+            }\n+            ty::TyKind::Uint(_) | ty::TyKind::Ref(..) | ty::TyKind::RawPtr(.. )=> {\n+                fx.bcx.ins().iconst(clif_ty, u64::try_from(const_val).expect(\"uint\") as i64)\n+            }\n+            ty::TyKind::Int(_) => {\n+                fx.bcx.ins().iconst(clif_ty, const_val as i128 as i64)\n+            }\n+            _ => panic!(\"CValue::const_val for non bool/integer/pointer type {:?} is not allowed\", ty),\n+        };\n+\n+        CValue::by_val(val, layout)\n     }\n \n     pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {"}]}