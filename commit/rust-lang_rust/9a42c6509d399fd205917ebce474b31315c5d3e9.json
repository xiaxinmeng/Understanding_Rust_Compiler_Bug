{"sha": "9a42c6509d399fd205917ebce474b31315c5d3e9", "node_id": "C_kwDOAAsO6NoAKDlhNDJjNjUwOWQzOTlmZDIwNTkxN2ViY2U0NzRiMzEzMTVjNWQzZTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-27T03:27:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-27T03:27:04Z"}, "message": "Auto merge of #97444 - compiler-errors:rollup-2gvdav6, r=compiler-errors\n\nRollup of 3 pull requests\n\nSuccessful merges:\n\n - #96051 (Use rounding in float to Duration conversion methods)\n - #97066 (rustdoc: Remove `ItemFragment(Kind)`)\n - #97436 (Update `triagebot.toml` for macos ping group)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "39e254faebf071b3ad58aad161d8e0c4821abd18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39e254faebf071b3ad58aad161d8e0c4821abd18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a42c6509d399fd205917ebce474b31315c5d3e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a42c6509d399fd205917ebce474b31315c5d3e9", "html_url": "https://github.com/rust-lang/rust/commit/9a42c6509d399fd205917ebce474b31315c5d3e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a42c6509d399fd205917ebce474b31315c5d3e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f68efad64f6a54703521d465817b6103813694d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f68efad64f6a54703521d465817b6103813694d", "html_url": "https://github.com/rust-lang/rust/commit/4f68efad64f6a54703521d465817b6103813694d"}, {"sha": "036f62badf311de9906a58b547295469ed7a10c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/036f62badf311de9906a58b547295469ed7a10c1", "html_url": "https://github.com/rust-lang/rust/commit/036f62badf311de9906a58b547295469ed7a10c1"}], "stats": {"total": 310, "additions": 169, "deletions": 141}, "files": [{"sha": "756f1a1663ca718e227732ab7ae1b2a5234ae67d", "filename": "library/core/src/time.rs", "status": "modified", "additions": 109, "deletions": 27, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/9a42c6509d399fd205917ebce474b31315c5d3e9/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a42c6509d399fd205917ebce474b31315c5d3e9/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=9a42c6509d399fd205917ebce474b31315c5d3e9", "patch": "@@ -730,9 +730,9 @@ impl Duration {\n     /// // subnormal float\n     /// let res = Duration::from_secs_f64(f64::from_bits(1));\n     /// assert_eq!(res, Duration::new(0, 0));\n-    /// // conversion uses truncation, not rounding\n+    /// // conversion uses rounding\n     /// let res = Duration::from_secs_f64(0.999e-9);\n-    /// assert_eq!(res, Duration::new(0, 0));\n+    /// assert_eq!(res, Duration::new(0, 1));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use]\n@@ -760,17 +760,17 @@ impl Duration {\n     /// let res = Duration::from_secs_f32(1e-20);\n     /// assert_eq!(res, Duration::new(0, 0));\n     /// let res = Duration::from_secs_f32(4.2e-7);\n-    /// assert_eq!(res, Duration::new(0, 419));\n+    /// assert_eq!(res, Duration::new(0, 420));\n     /// let res = Duration::from_secs_f32(2.7);\n-    /// assert_eq!(res, Duration::new(2, 700_000_047));\n+    /// assert_eq!(res, Duration::new(2, 700_000_048));\n     /// let res = Duration::from_secs_f32(3e10);\n     /// assert_eq!(res, Duration::new(30_000_001_024, 0));\n     /// // subnormal float\n     /// let res = Duration::from_secs_f32(f32::from_bits(1));\n     /// assert_eq!(res, Duration::new(0, 0));\n-    /// // conversion uses truncation, not rounding\n+    /// // conversion uses rounding\n     /// let res = Duration::from_secs_f32(0.999e-9);\n-    /// assert_eq!(res, Duration::new(0, 0));\n+    /// assert_eq!(res, Duration::new(0, 1));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use]\n@@ -815,7 +815,7 @@ impl Duration {\n     /// use std::time::Duration;\n     ///\n     /// let dur = Duration::new(2, 700_000_000);\n-    /// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_640));\n+    /// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_641));\n     /// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847800, 0));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n@@ -838,8 +838,7 @@ impl Duration {\n     ///\n     /// let dur = Duration::new(2, 700_000_000);\n     /// assert_eq!(dur.div_f64(3.14), Duration::new(0, 859_872_611));\n-    /// // note that truncation is used, not rounding\n-    /// assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_598));\n+    /// assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_599));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use = \"this returns the result of the operation, \\\n@@ -862,9 +861,8 @@ impl Duration {\n     /// let dur = Duration::new(2, 700_000_000);\n     /// // note that due to rounding errors result is slightly\n     /// // different from 0.859_872_611\n-    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_579));\n-    /// // note that truncation is used, not rounding\n-    /// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_598));\n+    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_580));\n+    /// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_599));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use = \"this returns the result of the operation, \\\n@@ -1272,19 +1270,53 @@ macro_rules! try_from_secs {\n         let mant = (bits & MANT_MASK) | (MANT_MASK + 1);\n         let exp = ((bits >> $mant_bits) & EXP_MASK) as i16 + MIN_EXP;\n \n-        let (secs, nanos) = if exp < -30 {\n-            // the input represents less than 1ns.\n+        let (secs, nanos) = if exp < -31 {\n+            // the input represents less than 1ns and can not be rounded to it\n             (0u64, 0u32)\n         } else if exp < 0 {\n             // the input is less than 1 second\n             let t = <$double_ty>::from(mant) << ($offset + exp);\n-            let nanos = (u128::from(NANOS_PER_SEC) * u128::from(t)) >> ($mant_bits + $offset);\n-            (0, nanos as u32)\n+            let nanos_offset = $mant_bits + $offset;\n+            let nanos_tmp = u128::from(NANOS_PER_SEC) * u128::from(t);\n+            let nanos = (nanos_tmp >> nanos_offset) as u32;\n+\n+            let rem_mask = (1 << nanos_offset) - 1;\n+            let rem_msb_mask = 1 << (nanos_offset - 1);\n+            let rem = nanos_tmp & rem_mask;\n+            let is_tie = rem == rem_msb_mask;\n+            let is_even = (nanos & 1) == 0;\n+            let rem_msb = nanos_tmp & rem_msb_mask == 0;\n+            let add_ns = !(rem_msb || (is_even && is_tie));\n+\n+            // f32 does not have enough presicion to trigger the second branch\n+            // since it can not represent numbers between 0.999_999_940_395 and 1.0.\n+            let nanos = nanos + add_ns as u32;\n+            if ($mant_bits == 23) || (nanos != NANOS_PER_SEC) { (0, nanos) } else { (1, 0) }\n         } else if exp < $mant_bits {\n-            let secs = mant >> ($mant_bits - exp);\n+            let secs = u64::from(mant >> ($mant_bits - exp));\n             let t = <$double_ty>::from((mant << exp) & MANT_MASK);\n-            let nanos = (<$double_ty>::from(NANOS_PER_SEC) * t) >> $mant_bits;\n-            (u64::from(secs), nanos as u32)\n+            let nanos_offset = $mant_bits;\n+            let nanos_tmp = <$double_ty>::from(NANOS_PER_SEC) * t;\n+            let nanos = (nanos_tmp >> nanos_offset) as u32;\n+\n+            let rem_mask = (1 << nanos_offset) - 1;\n+            let rem_msb_mask = 1 << (nanos_offset - 1);\n+            let rem = nanos_tmp & rem_mask;\n+            let is_tie = rem == rem_msb_mask;\n+            let is_even = (nanos & 1) == 0;\n+            let rem_msb = nanos_tmp & rem_msb_mask == 0;\n+            let add_ns = !(rem_msb || (is_even && is_tie));\n+\n+            // f32 does not have enough presicion to trigger the second branch.\n+            // For example, it can not represent numbers between 1.999_999_880...\n+            // and 2.0. Bigger values result in even smaller presicion of the\n+            // fractional part.\n+            let nanos = nanos + add_ns as u32;\n+            if ($mant_bits == 23) || (nanos != NANOS_PER_SEC) {\n+                (secs, nanos)\n+            } else {\n+                (secs + 1, 0)\n+            }\n         } else if exp < 64 {\n             // the input has no fractional part\n             let secs = u64::from(mant) << (exp - $mant_bits);\n@@ -1315,24 +1347,45 @@ impl Duration {\n     /// let res = Duration::try_from_secs_f32(1e-20);\n     /// assert_eq!(res, Ok(Duration::new(0, 0)));\n     /// let res = Duration::try_from_secs_f32(4.2e-7);\n-    /// assert_eq!(res, Ok(Duration::new(0, 419)));\n+    /// assert_eq!(res, Ok(Duration::new(0, 420)));\n     /// let res = Duration::try_from_secs_f32(2.7);\n-    /// assert_eq!(res, Ok(Duration::new(2, 700_000_047)));\n+    /// assert_eq!(res, Ok(Duration::new(2, 700_000_048)));\n     /// let res = Duration::try_from_secs_f32(3e10);\n     /// assert_eq!(res, Ok(Duration::new(30_000_001_024, 0)));\n     /// // subnormal float:\n     /// let res = Duration::try_from_secs_f32(f32::from_bits(1));\n     /// assert_eq!(res, Ok(Duration::new(0, 0)));\n-    /// // conversion uses truncation, not rounding\n-    /// let res = Duration::try_from_secs_f32(0.999e-9);\n-    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n     ///\n     /// let res = Duration::try_from_secs_f32(-5.0);\n     /// assert!(res.is_err());\n     /// let res = Duration::try_from_secs_f32(f32::NAN);\n     /// assert!(res.is_err());\n     /// let res = Duration::try_from_secs_f32(2e19);\n     /// assert!(res.is_err());\n+    ///\n+    /// // the conversion uses rounding with tie resolution to even\n+    /// let res = Duration::try_from_secs_f32(0.999e-9);\n+    /// assert_eq!(res, Ok(Duration::new(0, 1)));\n+    ///\n+    /// // this float represents exactly 976562.5e-9\n+    /// let val = f32::from_bits(0x3A80_0000);\n+    /// let res = Duration::try_from_secs_f32(val);\n+    /// assert_eq!(res, Ok(Duration::new(0, 976_562)));\n+    ///\n+    /// // this float represents exactly 2929687.5e-9\n+    /// let val = f32::from_bits(0x3B40_0000);\n+    /// let res = Duration::try_from_secs_f32(val);\n+    /// assert_eq!(res, Ok(Duration::new(0, 2_929_688)));\n+    ///\n+    /// // this float represents exactly 1.000_976_562_5\n+    /// let val = f32::from_bits(0x3F802000);\n+    /// let res = Duration::try_from_secs_f32(val);\n+    /// assert_eq!(res, Ok(Duration::new(1, 976_562)));\n+    ///\n+    /// // this float represents exactly 1.002_929_687_5\n+    /// let val = f32::from_bits(0x3F806000);\n+    /// let res = Duration::try_from_secs_f32(val);\n+    /// assert_eq!(res, Ok(Duration::new(1, 2_929_688)));\n     /// ```\n     #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n     #[inline]\n@@ -1372,16 +1425,45 @@ impl Duration {\n     /// // subnormal float\n     /// let res = Duration::try_from_secs_f64(f64::from_bits(1));\n     /// assert_eq!(res, Ok(Duration::new(0, 0)));\n-    /// // conversion uses truncation, not rounding\n-    /// let res = Duration::try_from_secs_f32(0.999e-9);\n-    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n     ///\n     /// let res = Duration::try_from_secs_f64(-5.0);\n     /// assert!(res.is_err());\n     /// let res = Duration::try_from_secs_f64(f64::NAN);\n     /// assert!(res.is_err());\n     /// let res = Duration::try_from_secs_f64(2e19);\n     /// assert!(res.is_err());\n+    ///\n+    /// // the conversion uses rounding with tie resolution to even\n+    /// let res = Duration::try_from_secs_f64(0.999e-9);\n+    /// assert_eq!(res, Ok(Duration::new(0, 1)));\n+    /// let res = Duration::try_from_secs_f64(0.999_999_999_499);\n+    /// assert_eq!(res, Ok(Duration::new(0, 999_999_999)));\n+    /// let res = Duration::try_from_secs_f64(0.999_999_999_501);\n+    /// assert_eq!(res, Ok(Duration::new(1, 0)));\n+    /// let res = Duration::try_from_secs_f64(42.999_999_999_499);\n+    /// assert_eq!(res, Ok(Duration::new(42, 999_999_999)));\n+    /// let res = Duration::try_from_secs_f64(42.999_999_999_501);\n+    /// assert_eq!(res, Ok(Duration::new(43, 0)));\n+    ///\n+    /// // this float represents exactly 976562.5e-9\n+    /// let val = f64::from_bits(0x3F50_0000_0000_0000);\n+    /// let res = Duration::try_from_secs_f64(val);\n+    /// assert_eq!(res, Ok(Duration::new(0, 976_562)));\n+    ///\n+    /// // this float represents exactly 2929687.5e-9\n+    /// let val = f64::from_bits(0x3F68_0000_0000_0000);\n+    /// let res = Duration::try_from_secs_f64(val);\n+    /// assert_eq!(res, Ok(Duration::new(0, 2_929_688)));\n+    ///\n+    /// // this float represents exactly 1.000_976_562_5\n+    /// let val = f64::from_bits(0x3FF0_0400_0000_0000);\n+    /// let res = Duration::try_from_secs_f64(val);\n+    /// assert_eq!(res, Ok(Duration::new(1, 976_562)));\n+    ///\n+    /// // this float represents exactly 1.002_929_687_5\n+    /// let val = f64::from_bits(0x3_FF00_C000_0000_000);\n+    /// let res = Duration::try_from_secs_f64(val);\n+    /// assert_eq!(res, Ok(Duration::new(1, 2_929_688)));\n     /// ```\n     #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n     #[inline]"}, {"sha": "99b4eacedc222665045c95954e11ed9137c7659c", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a42c6509d399fd205917ebce474b31315c5d3e9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a42c6509d399fd205917ebce474b31315c5d3e9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=9a42c6509d399fd205917ebce474b31315c5d3e9", "patch": "@@ -525,7 +525,7 @@ impl Item {\n                 if let Ok((mut href, ..)) = href(*did, cx) {\n                     debug!(?href);\n                     if let Some(ref fragment) = *fragment {\n-                        fragment.render(&mut href, cx.tcx()).unwrap()\n+                        fragment.render(&mut href, cx.tcx())\n                     }\n                     Some(RenderedLink {\n                         original_text: s.clone(),"}, {"sha": "83d8fe9ef1110835bef6e47a4de37b2ad8ff04aa", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 52, "deletions": 113, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/9a42c6509d399fd205917ebce474b31315c5d3e9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a42c6509d399fd205917ebce474b31315c5d3e9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=9a42c6509d399fd205917ebce474b31315c5d3e9", "patch": "@@ -20,7 +20,6 @@ use rustc_span::BytePos;\n use smallvec::{smallvec, SmallVec};\n \n use std::borrow::Cow;\n-use std::fmt::Write;\n use std::mem;\n use std::ops::Range;\n \n@@ -220,80 +219,43 @@ enum MalformedGenerics {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub(crate) enum UrlFragment {\n-    Item(ItemFragment),\n+    Item(DefId),\n     UserWritten(String),\n }\n \n impl UrlFragment {\n     /// Render the fragment, including the leading `#`.\n-    pub(crate) fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n+    pub(crate) fn render(&self, s: &mut String, tcx: TyCtxt<'_>) {\n+        s.push('#');\n         match self {\n-            UrlFragment::Item(frag) => frag.render(s, tcx),\n-            UrlFragment::UserWritten(raw) => write!(s, \"#{}\", raw),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub(crate) struct ItemFragment(FragmentKind, DefId);\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub(crate) enum FragmentKind {\n-    Method,\n-    TyMethod,\n-    AssociatedConstant,\n-    AssociatedType,\n-\n-    StructField,\n-    Variant,\n-    VariantField,\n-}\n-\n-impl FragmentKind {\n-    fn from_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> FragmentKind {\n-        match tcx.def_kind(def_id) {\n-            DefKind::AssocFn => {\n-                if tcx.associated_item(def_id).defaultness.has_value() {\n-                    FragmentKind::Method\n-                } else {\n-                    FragmentKind::TyMethod\n-                }\n-            }\n-            DefKind::AssocConst => FragmentKind::AssociatedConstant,\n-            DefKind::AssocTy => FragmentKind::AssociatedType,\n-            DefKind::Variant => FragmentKind::Variant,\n-            DefKind::Field => {\n-                if tcx.def_kind(tcx.parent(def_id)) == DefKind::Variant {\n-                    FragmentKind::VariantField\n-                } else {\n-                    FragmentKind::StructField\n-                }\n-            }\n-            kind => bug!(\"unexpected associated item kind: {:?}\", kind),\n-        }\n-    }\n-}\n-\n-impl ItemFragment {\n-    /// Render the fragment, including the leading `#`.\n-    pub(crate) fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n-        write!(s, \"#\")?;\n-        match *self {\n-            ItemFragment(kind, def_id) => {\n-                let name = tcx.item_name(def_id);\n-                match kind {\n-                    FragmentKind::Method => write!(s, \"method.{}\", name),\n-                    FragmentKind::TyMethod => write!(s, \"tymethod.{}\", name),\n-                    FragmentKind::AssociatedConstant => write!(s, \"associatedconstant.{}\", name),\n-                    FragmentKind::AssociatedType => write!(s, \"associatedtype.{}\", name),\n-                    FragmentKind::StructField => write!(s, \"structfield.{}\", name),\n-                    FragmentKind::Variant => write!(s, \"variant.{}\", name),\n-                    FragmentKind::VariantField => {\n-                        let variant = tcx.item_name(tcx.parent(def_id));\n-                        write!(s, \"variant.{}.field.{}\", variant, name)\n+            &UrlFragment::Item(def_id) => {\n+                let kind = match tcx.def_kind(def_id) {\n+                    DefKind::AssocFn => {\n+                        if tcx.associated_item(def_id).defaultness.has_value() {\n+                            \"method.\"\n+                        } else {\n+                            \"tymethod.\"\n+                        }\n                     }\n-                }\n+                    DefKind::AssocConst => \"associatedconstant.\",\n+                    DefKind::AssocTy => \"associatedtype.\",\n+                    DefKind::Variant => \"variant.\",\n+                    DefKind::Field => {\n+                        let parent_id = tcx.parent(def_id);\n+                        if tcx.def_kind(parent_id) == DefKind::Variant {\n+                            s.push_str(\"variant.\");\n+                            s.push_str(tcx.item_name(parent_id).as_str());\n+                            \".field.\"\n+                        } else {\n+                            \"structfield.\"\n+                        }\n+                    }\n+                    kind => bug!(\"unexpected associated item kind: {:?}\", kind),\n+                };\n+                s.push_str(kind);\n+                s.push_str(tcx.item_name(def_id).as_str());\n             }\n+            UrlFragment::UserWritten(raw) => s.push_str(&raw),\n         }\n     }\n }\n@@ -315,11 +277,6 @@ struct DiagnosticInfo<'a> {\n     link_range: Range<usize>,\n }\n \n-#[derive(Clone, Debug, Hash)]\n-struct CachedLink {\n-    res: (Res, Option<UrlFragment>),\n-}\n-\n struct LinkCollector<'a, 'tcx> {\n     cx: &'a mut DocContext<'tcx>,\n     /// A stack of modules used to decide what scope to resolve in.\n@@ -329,7 +286,7 @@ struct LinkCollector<'a, 'tcx> {\n     mod_ids: Vec<DefId>,\n     /// Cache the resolved links so we can avoid resolving (and emitting errors for) the same link.\n     /// The link will be `None` if it could not be resolved (i.e. the error was cached).\n-    visited_links: FxHashMap<ResolutionInfo, Option<CachedLink>>,\n+    visited_links: FxHashMap<ResolutionInfo, Option<(Res, Option<UrlFragment>)>>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n@@ -1097,6 +1054,9 @@ impl LinkCollector<'_, '_> {\n                 extra_fragment: extra_fragment.clone(),\n             },\n             diag_info.clone(), // this struct should really be Copy, but Range is not :(\n+            // For reference-style links we want to report only one error so unsuccessful\n+            // resolutions are cached, for other links we want to report an error every\n+            // time so they are not cached.\n             matches!(ori_link.kind, LinkType::Reference | LinkType::Shortcut),\n         )?;\n \n@@ -1123,7 +1083,7 @@ impl LinkCollector<'_, '_> {\n \n         match res {\n             Res::Primitive(prim) => {\n-                if let Some(UrlFragment::Item(ItemFragment(_, id))) = fragment {\n+                if let Some(UrlFragment::Item(id)) = fragment {\n                     // We're actually resolving an associated item of a primitive, so we need to\n                     // verify the disambiguator (if any) matches the type of the associated item.\n                     // This case should really follow the same flow as the `Res::Def` branch below,\n@@ -1171,12 +1131,11 @@ impl LinkCollector<'_, '_> {\n                 })\n             }\n             Res::Def(kind, id) => {\n-                let (kind_for_dis, id_for_dis) =\n-                    if let Some(UrlFragment::Item(ItemFragment(_, id))) = fragment {\n-                        (self.cx.tcx.def_kind(id), id)\n-                    } else {\n-                        (kind, id)\n-                    };\n+                let (kind_for_dis, id_for_dis) = if let Some(UrlFragment::Item(id)) = fragment {\n+                    (self.cx.tcx.def_kind(id), id)\n+                } else {\n+                    (kind, id)\n+                };\n                 self.verify_disambiguator(\n                     path_str,\n                     ori_link,\n@@ -1294,53 +1253,33 @@ impl LinkCollector<'_, '_> {\n         &mut self,\n         key: ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n-        cache_resolution_failure: bool,\n+        // If errors are cached then they are only reported on first ocurrence\n+        // which we want in some cases but not in others.\n+        cache_errors: bool,\n     ) -> Option<(Res, Option<UrlFragment>)> {\n-        if let Some(ref cached) = self.visited_links.get(&key) {\n-            match cached {\n-                Some(cached) => {\n-                    return Some(cached.res.clone());\n-                }\n-                None if cache_resolution_failure => return None,\n-                None => {\n-                    // Although we hit the cache and found a resolution error, this link isn't\n-                    // supposed to cache those. Run link resolution again to emit the expected\n-                    // resolution error.\n-                }\n+        if let Some(res) = self.visited_links.get(&key) {\n+            if res.is_some() || cache_errors {\n+                return res.clone();\n             }\n         }\n \n         let res = self.resolve_with_disambiguator(&key, diag.clone()).and_then(|(res, def_id)| {\n             let fragment = match (&key.extra_fragment, def_id) {\n                 (Some(_), Some(def_id)) => {\n-                    report_anchor_conflict(self.cx, diag, Res::from_def_id(self.cx.tcx, def_id));\n+                    report_anchor_conflict(self.cx, diag, def_id);\n                     return None;\n                 }\n                 (Some(u_frag), None) => Some(UrlFragment::UserWritten(u_frag.clone())),\n-                (None, Some(def_id)) => Some(UrlFragment::Item(ItemFragment(\n-                    FragmentKind::from_def_id(self.cx.tcx, def_id),\n-                    def_id,\n-                ))),\n+                (None, Some(def_id)) => Some(UrlFragment::Item(def_id)),\n                 (None, None) => None,\n             };\n             Some((res, fragment))\n         });\n \n-        // Cache only if resolved successfully - don't silence duplicate errors\n-        if let Some(res) = res {\n-            // Store result for the actual namespace\n-            self.visited_links.insert(key, Some(CachedLink { res: res.clone() }));\n-\n-            Some(res)\n-        } else {\n-            if cache_resolution_failure {\n-                // For reference-style links we only want to report one resolution error\n-                // so let's cache them as well.\n-                self.visited_links.insert(key, None);\n-            }\n-\n-            None\n+        if res.is_some() || cache_errors {\n+            self.visited_links.insert(key, res.clone());\n         }\n+        res\n     }\n \n     /// After parsing the disambiguator, resolve the main part of the link.\n@@ -1916,8 +1855,8 @@ fn report_multiple_anchors(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>) {\n     anchor_failure(cx, diag_info, &msg, 1)\n }\n \n-fn report_anchor_conflict(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, res: Res) {\n-    let (link, kind) = (diag_info.ori_link, res.descr());\n+fn report_anchor_conflict(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, def_id: DefId) {\n+    let (link, kind) = (diag_info.ori_link, Res::from_def_id(cx.tcx, def_id).descr());\n     let msg = format!(\"`{link}` contains an anchor, but links to {kind}s are already anchored\");\n     anchor_failure(cx, diag_info, &msg, 0)\n }"}, {"sha": "e161adcd6e0244e002ee2acd7dac15e4a0023c42", "filename": "triagebot.toml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a42c6509d399fd205917ebce474b31315c5d3e9/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9a42c6509d399fd205917ebce474b31315c5d3e9/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=9a42c6509d399fd205917ebce474b31315c5d3e9", "patch": "@@ -80,6 +80,13 @@ resolved/implemented on Fuchsia. Could one of you weigh in?\n \"\"\"\n label = \"O-fuchsia\"\n \n+[ping.macos]\n+message = \"\"\"\\\n+Hey MacOS Group! This issue or PR could use some MacOS-specific guidance. Could one\n+of you weigh in? Thanks <3\n+\"\"\"\n+label = \"O-macos\"\n+\n [prioritize]\n label = \"I-prioritize\"\n "}]}