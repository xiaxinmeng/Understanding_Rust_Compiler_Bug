{"sha": "8d5a51e9d7f51ba9c80a34121b158c8c2ef9cdd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNWE1MWU5ZDdmNTFiYTljODBhMzQxMjFiMTU4YzhjMmVmOWNkZDc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-08-08T21:58:46Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-08-08T21:58:46Z"}, "message": "Merge pull request #3146 from alexrp/incoming\n\nDocumentation updates (typestate and pure functions).", "tree": {"sha": "b9ec6047750b9b8ec1c94d3a87bef61ead976da0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9ec6047750b9b8ec1c94d3a87bef61ead976da0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d5a51e9d7f51ba9c80a34121b158c8c2ef9cdd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d5a51e9d7f51ba9c80a34121b158c8c2ef9cdd7", "html_url": "https://github.com/rust-lang/rust/commit/8d5a51e9d7f51ba9c80a34121b158c8c2ef9cdd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d5a51e9d7f51ba9c80a34121b158c8c2ef9cdd7/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79b5f681765ae9d295f4ca8056a90dbbafbe1d9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/79b5f681765ae9d295f4ca8056a90dbbafbe1d9d", "html_url": "https://github.com/rust-lang/rust/commit/79b5f681765ae9d295f4ca8056a90dbbafbe1d9d"}, {"sha": "11c1baa883d95e790aaa1fd4f88bcb36517a27b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/11c1baa883d95e790aaa1fd4f88bcb36517a27b8", "html_url": "https://github.com/rust-lang/rust/commit/11c1baa883d95e790aaa1fd4f88bcb36517a27b8"}], "stats": {"total": 64, "additions": 16, "deletions": 48}, "files": [{"sha": "cbe4525eac1d83178ddce79015661857ff52124f", "filename": "doc/rust.md", "status": "modified", "additions": 16, "deletions": 48, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8d5a51e9d7f51ba9c80a34121b158c8c2ef9cdd7/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/8d5a51e9d7f51ba9c80a34121b158c8c2ef9cdd7/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=8d5a51e9d7f51ba9c80a34121b158c8c2ef9cdd7", "patch": "@@ -899,58 +899,51 @@ express that `f` requires no explicit `return`, as if it returns\n control to the caller, it returns a value (true because it never returns\n control).\n \n-#### Predicate functions\n+#### Pure functions\n \n-Any pure boolean function is called a *predicate function*, and may be used in\n-a [constraint](#constraints), as part of the static [typestate\n-system](#typestate-system). A predicate declaration is identical to a function\n-declaration, except that it is declared with the additional keyword `pure`. In\n-addition, the typechecker checks the body of a predicate with a restricted set\n-of typechecking rules. A predicate\n+A pure function declaration is identical to a function declaration, except that\n+it is declared with the additional keyword `pure`. In addition, the typechecker\n+checks the body of a pure function with a restricted set of typechecking rules.\n+A pure function\n \n * may not contain an assignment or self-call expression; and\n-* may only call other predicates, not general functions.\n+* may only call other pure functions, not general functions.\n \n-An example of a predicate:\n+An example of a pure function:\n \n ~~~~\n pure fn lt_42(x: int) -> bool {\n     return (x < 42);\n }\n ~~~~\n \n-A non-boolean function may also be declared with `pure fn`. This allows\n-predicates to call non-boolean functions as long as they are pure. For example:\n+Pure functions may call other pure functions:\n \n ~~~~{.xfail-test}\n pure fn pure_length<T>(ls: list<T>) -> uint { /* ... */ }\n \n pure fn nonempty_list<T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n ~~~~\n \n-In this example, `nonempty_list` is a predicate---it can be used in a\n-typestate constraint---but the auxiliary function `pure_length` is\n-not.\n-\n *TODO:* should actually define referential transparency.\n \n The effect checking rules previously enumerated are a restricted set of\n typechecking rules meant to approximate the universe of observably\n referentially transparent Rust procedures conservatively. Sometimes, these\n rules are *too* restrictive. Rust allows programmers to violate these rules by\n-writing predicates that the compiler cannot prove to be referentially\n+writing pure functions that the compiler cannot prove to be referentially\n transparent, using an escape-hatch feature called \"unchecked blocks\". When\n writing code that uses unchecked blocks, programmers should always be aware\n that they have an obligation to show that the code *behaves* referentially\n transparently at all times, even if the compiler cannot *prove* automatically\n that the code is referentially transparent. In the presence of unchecked\n blocks, the compiler provides no static guarantee that the code will behave as\n expected at runtime. Rather, the programmer has an independent obligation to\n-verify the semantics of the predicates they write.\n+verify the semantics of the pure functions they write.\n \n *TODO:* last two sentences are vague.\n \n-An example of a predicate that uses an unchecked block:\n+An example of a pure function that uses an unchecked block:\n \n ~~~~\n # import std::list::*;\n@@ -972,7 +965,7 @@ pure fn pure_length<T>(ls: list<T>) -> uint {\n \n Despite its name, `pure_foldl` is a `fn`, not a `pure fn`, because there is no\n way in Rust to specify that the higher-order function argument `f` is a pure\n-function. So, to use `foldl` in a pure list length function that a predicate\n+function. So, to use `foldl` in a pure list length function that a pure function\n could then use, we must use an `unchecked` block wrapped around the call to\n `pure_foldl` in the definition of `pure_length`.\n \n@@ -1136,8 +1129,8 @@ looks like:\n \n The only exception is that the body of the class constructor begins\n with all the class's fields uninitialized, and is allowed to -- in\n-fact, must -- initialize all the fields. A special case in the\n-typestate pass enforces this invariant.\n+fact, must -- initialize all the fields. The compiler enforces this\n+invariant.\n \n Usually, the class constructor stores its argument or arguments in the\n class's named fields. In this case, the `file_descriptor`'s data field\n@@ -2074,31 +2067,6 @@ A `loop` expression denotes an infinite loop:\n loop_expr : \"loop\" '{' block '}';\n ~~~~~~~~\n \n-For a block `b`, the expression `loop b` is semantically equivalent to\n-`while true b`. However, `loop`s differ from `while` loops in that the\n-typestate analysis pass takes into account that `loop`s are infinite.\n-\n-For example, the following (contrived) function uses a `loop` with a\n-`return` expression:\n-\n-~~~~\n-fn count() -> bool {\n-  let mut i = 0;\n-  loop {\n-    i += 1;\n-    if i == 20 { return true; }\n-  }\n-}\n-~~~~\n-\n-This function compiles, because typestate recognizes that the `loop`\n-never terminates (except non-locally, with `return`), thus there is no\n-need to insert a spurious `fail` or `return` after the `loop`. If `loop`\n-were replaced with `while true`, the function would be rejected\n-because from the compiler's perspective, there would be a control path\n-along which `count` does not return a value (that is, if the loop\n-condition is always false).\n-\n ### Break expressions\n \n ~~~~~~~~{.ebnf .gram}\n@@ -2540,7 +2508,7 @@ macro-generated and user-written code can cause unintentional capture.\n Future versions of Rust will address these issues.\n \n \n-# Types and typestates\n+# Type system\n \n ## Types\n \n@@ -2966,7 +2934,7 @@ Local variables are not initialized when allocated; the entire frame worth of\n local variables are allocated at once, on frame-entry, in an uninitialized\n state. Subsequent statements within a function may or may not initialize the\n local variables. Local variables can be used only after they have been\n-initialized; this condition is guaranteed by the typestate system.\n+initialized; this is enforced by the compiler.\n \n References are created for function arguments. If the compiler can not prove\n that the referred-to value will outlive the reference, it will try to set"}]}