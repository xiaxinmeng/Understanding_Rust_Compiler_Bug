{"sha": "2a65cbeea78c2c79b1030a0012cdea475104a44f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNjVjYmVlYTc4YzJjNzliMTAzMGEwMDEyY2RlYTQ3NTEwNGE0NGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-08T13:49:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-08T13:49:07Z"}, "message": "Auto merge of #58915 - ljedrz:deprecate_nodeid_methods, r=Zoxc\n\nHirIdification: almost there\n\nThe next iteration of HirIdification (#57578).\n\nReplaces a bunch of `NodeId` method calls (mostly `as_local_node_id`) with `HirId` ones.\n\nRemoves `NodeId` from:\n- [x] `PathSegment`\n- [x] `PatKind`\n- [x] `Destination` (replaces it with `HirId`)\n\nIn addition this PR also removes `Visitor::visit_def_mention`, which doesn't seem to be doing anything.", "tree": {"sha": "7d53ed7a5fec5e13e37e55db3784a778c68b784e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d53ed7a5fec5e13e37e55db3784a778c68b784e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a65cbeea78c2c79b1030a0012cdea475104a44f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a65cbeea78c2c79b1030a0012cdea475104a44f", "html_url": "https://github.com/rust-lang/rust/commit/2a65cbeea78c2c79b1030a0012cdea475104a44f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a65cbeea78c2c79b1030a0012cdea475104a44f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b58a0061a347532c55cd5eb27fd6f47f20889ec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b58a0061a347532c55cd5eb27fd6f47f20889ec6", "html_url": "https://github.com/rust-lang/rust/commit/b58a0061a347532c55cd5eb27fd6f47f20889ec6"}, {"sha": "24fad4c145122ba4abfdcb3bdafb3f4a2f429ba6", "url": "https://api.github.com/repos/rust-lang/rust/commits/24fad4c145122ba4abfdcb3bdafb3f4a2f429ba6", "html_url": "https://github.com/rust-lang/rust/commit/24fad4c145122ba4abfdcb3bdafb3f4a2f429ba6"}], "stats": {"total": 926, "additions": 438, "deletions": 488}, "files": [{"sha": "e96709f6d14e5bd57b373786582ab9b6034715dc", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -571,9 +571,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match destination.target_id {\n             Ok(loop_id) => {\n                 for b in &self.breakable_block_scopes {\n-                    if b.block_expr_id == self.tcx.hir().node_to_hir_id(loop_id).local_id {\n+                    if b.block_expr_id == loop_id.local_id {\n                         let scope = region::Scope {\n-                            id: self.tcx.hir().node_to_hir_id(loop_id).local_id,\n+                            id: loop_id.local_id,\n                             data: region::ScopeData::Node\n                         };\n                         return (scope, match scope_cf_kind {\n@@ -583,9 +583,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     }\n                 }\n                 for l in &self.loop_scopes {\n-                    if l.loop_id == self.tcx.hir().node_to_hir_id(loop_id).local_id {\n+                    if l.loop_id == loop_id.local_id {\n                         let scope = region::Scope {\n-                            id: self.tcx.hir().node_to_hir_id(loop_id).local_id,\n+                            id: loop_id.local_id,\n                             data: region::ScopeData::Node\n                         };\n                         return (scope, match scope_cf_kind {"}, {"sha": "977830315e23e893c74ea3dc240800bfcad33817", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -34,7 +34,6 @@\n use syntax::ast::{Ident, Name, Attribute};\n use syntax_pos::Span;\n use crate::hir::*;\n-use crate::hir::def::Def;\n use crate::hir::map::Map;\n use super::itemlikevisit::DeepVisitor;\n \n@@ -228,9 +227,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_id(&mut self, _hir_id: HirId) {\n         // Nothing to do.\n     }\n-    fn visit_def_mention(&mut self, _def: Def) {\n-        // Nothing to do.\n-    }\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n@@ -494,13 +490,10 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(typ);\n             visitor.visit_generics(type_parameters)\n         }\n-        ItemKind::Existential(ExistTy {ref generics, ref bounds, impl_trait_fn}) => {\n+        ItemKind::Existential(ExistTy { ref generics, ref bounds, impl_trait_fn: _ }) => {\n             visitor.visit_id(item.hir_id);\n             walk_generics(visitor, generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n-            if let Some(impl_trait_fn) = impl_trait_fn {\n-                visitor.visit_def_mention(Def::Fn(impl_trait_fn))\n-            }\n         }\n         ItemKind::Enum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n@@ -640,7 +633,6 @@ pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath, id: Hir\n }\n \n pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n-    visitor.visit_def_mention(path.def);\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n     }\n@@ -697,8 +689,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Ref(ref subpattern, _) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatKind::Binding(_, canonical_id, _hir_id, ident, ref optional_subpattern) => {\n-            visitor.visit_def_mention(Def::Local(canonical_id));\n+        PatKind::Binding(_, _hir_id, ident, ref optional_subpattern) => {\n             visitor.visit_ident(ident);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n@@ -1064,18 +1055,12 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprKind::Break(ref destination, ref opt_expr) => {\n             if let Some(ref label) = destination.label {\n                 visitor.visit_label(label);\n-                if let Ok(node_id) = destination.target_id {\n-                    visitor.visit_def_mention(Def::Label(node_id))\n-                }\n             }\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n         ExprKind::Continue(ref destination) => {\n             if let Some(ref label) = destination.label {\n                 visitor.visit_label(label);\n-                if let Ok(node_id) = destination.target_id {\n-                    visitor.visit_def_mention(Def::Label(node_id))\n-                }\n             }\n         }\n         ExprKind::Ret(ref optional_expression) => {"}, {"sha": "949fdd2682b96dfcc62d328f26b4af63ddc83560", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -1068,7 +1068,7 @@ impl<'a> LoweringContext<'a> {\n         let target_id = match destination {\n             Some((id, _)) => {\n                 if let Def::Label(loop_id) = self.expect_full_def(id) {\n-                    Ok(self.lower_node_id(loop_id).node_id)\n+                    Ok(self.lower_node_id(loop_id).hir_id)\n                 } else {\n                     Err(hir::LoopIdError::UnresolvedLabel)\n                 }\n@@ -1077,7 +1077,7 @@ impl<'a> LoweringContext<'a> {\n                 self.loop_scopes\n                     .last()\n                     .cloned()\n-                    .map(|id| Ok(self.lower_node_id(id).node_id))\n+                    .map(|id| Ok(self.lower_node_id(id).hir_id))\n                     .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope))\n                     .into()\n             }\n@@ -1932,7 +1932,6 @@ impl<'a> LoweringContext<'a> {\n \n         hir::PathSegment::new(\n             segment.ident,\n-            Some(id.node_id),\n             Some(id.hir_id),\n             Some(def),\n             generic_args,\n@@ -3276,10 +3275,8 @@ impl<'a> LoweringContext<'a> {\n         debug!(\"renumber_segment_ids(path = {:?})\", path);\n         let mut path = path.clone();\n         for seg in path.segments.iter_mut() {\n-            if seg.id.is_some() {\n-                let next_id = self.next_id();\n-                seg.id = Some(next_id.node_id);\n-                seg.hir_id = Some(next_id.hir_id);\n+            if seg.hir_id.is_some() {\n+                seg.hir_id = Some(self.next_id().hir_id);\n             }\n         }\n         path\n@@ -3682,11 +3679,10 @@ impl<'a> LoweringContext<'a> {\n                             Some(Def::Local(id)) => id,\n                             _ => p.id,\n                         };\n-                        let hir_id = self.lower_node_id(canonical_id).hir_id;\n+\n                         hir::PatKind::Binding(\n                             self.lower_binding_mode(binding_mode),\n-                            canonical_id,\n-                            hir_id,\n+                            self.lower_node_id(canonical_id).hir_id,\n                             ident,\n                             sub.as_ref().map(|x| self.lower_pat(x)),\n                         )\n@@ -4568,12 +4564,13 @@ impl<'a> LoweringContext<'a> {\n                     let thin_attrs = ThinVec::from(attrs);\n                     let catch_scope = self.catch_scopes.last().map(|x| *x);\n                     let ret_expr = if let Some(catch_node) = catch_scope {\n+                        let target_id = Ok(self.lower_node_id(catch_node).hir_id);\n                         P(self.expr(\n                             e.span,\n                             hir::ExprKind::Break(\n                                 hir::Destination {\n                                     label: None,\n-                                    target_id: Ok(catch_node),\n+                                    target_id,\n                                 },\n                                 Some(from_err_expr),\n                             ),\n@@ -4988,7 +4985,7 @@ impl<'a> LoweringContext<'a> {\n         (\n             P(hir::Pat {\n                 hir_id,\n-                node: hir::PatKind::Binding(bm, node_id, hir_id, ident.with_span_pos(span), None),\n+                node: hir::PatKind::Binding(bm, hir_id, ident.with_span_pos(span), None),\n                 span,\n             }),\n             node_id\n@@ -5024,8 +5021,8 @@ impl<'a> LoweringContext<'a> {\n \n \n         for seg in path.segments.iter_mut() {\n-            if let Some(id) = seg.id {\n-                seg.id = Some(self.lower_node_id(id).node_id);\n+            if seg.hir_id.is_some() {\n+                seg.hir_id = Some(self.next_id().hir_id);\n             }\n         }\n         path"}, {"sha": "86b6805cc9b4c39f600ddf7952e3217c27f501ee", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 32, "deletions": 46, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -501,10 +501,10 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Given a body owner's id, returns the `BodyId` associated with it.\n-    pub fn body_owned_by(&self, id: NodeId) -> BodyId {\n-        self.maybe_body_owned_by(id).unwrap_or_else(|| {\n-            span_bug!(self.span(id), \"body_owned_by: {} has no associated body\",\n-                      self.node_to_string(id));\n+    pub fn body_owned_by(&self, id: HirId) -> BodyId {\n+        self.maybe_body_owned_by_by_hir_id(id).unwrap_or_else(|| {\n+            span_bug!(self.span_by_hir_id(id), \"body_owned_by: {} has no associated body\",\n+                      self.hir_to_string(id));\n         })\n     }\n \n@@ -539,19 +539,19 @@ impl<'hir> Map<'hir> {\n         self.body_owner_kind(node_id)\n     }\n \n-    pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n-        match self.get(id) {\n+    pub fn ty_param_owner(&self, id: HirId) -> HirId {\n+        match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) => id,\n-            Node::GenericParam(_) => self.get_parent_node(id),\n-            _ => bug!(\"ty_param_owner: {} not a type parameter\", self.node_to_string(id))\n+            Node::GenericParam(_) => self.get_parent_node_by_hir_id(id),\n+            _ => bug!(\"ty_param_owner: {} not a type parameter\", self.hir_to_string(id))\n         }\n     }\n \n-    pub fn ty_param_name(&self, id: NodeId) -> Name {\n-        match self.get(id) {\n+    pub fn ty_param_name(&self, id: HirId) -> Name {\n+        match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfUpper.name(),\n             Node::GenericParam(param) => param.name.ident().name,\n-            _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n+            _ => bug!(\"ty_param_name: {} not a type parameter\", self.hir_to_string(id)),\n         }\n     }\n \n@@ -618,11 +618,11 @@ impl<'hir> Map<'hir> {\n         }\n \n         for id in &module.trait_items {\n-            visitor.visit_trait_item(self.expect_trait_item_by_hir_id(id.hir_id));\n+            visitor.visit_trait_item(self.expect_trait_item(id.hir_id));\n         }\n \n         for id in &module.impl_items {\n-            visitor.visit_impl_item(self.expect_impl_item_by_hir_id(id.hir_id));\n+            visitor.visit_impl_item(self.expect_impl_item(id.hir_id));\n         }\n     }\n \n@@ -929,66 +929,52 @@ impl<'hir> Map<'hir> {\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn expect_item_by_hir_id(&self, id: HirId) -> &'hir Item {\n-        let node_id = self.hir_to_node_id(id);\n-        self.expect_item(node_id)\n+        match self.find_by_hir_id(id) { // read recorded by `find`\n+            Some(Node::Item(item)) => item,\n+            _ => bug!(\"expected item, found {}\", self.hir_to_string(id))\n+        }\n     }\n \n-    pub fn expect_impl_item(&self, id: NodeId) -> &'hir ImplItem {\n-        match self.find(id) {\n+    pub fn expect_impl_item(&self, id: HirId) -> &'hir ImplItem {\n+        match self.find_by_hir_id(id) {\n             Some(Node::ImplItem(item)) => item,\n-            _ => bug!(\"expected impl item, found {}\", self.node_to_string(id))\n+            _ => bug!(\"expected impl item, found {}\", self.hir_to_string(id))\n         }\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn expect_impl_item_by_hir_id(&self, id: HirId) -> &'hir ImplItem {\n-        let node_id = self.hir_to_node_id(id);\n-        self.expect_impl_item(node_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn expect_trait_item_by_hir_id(&self, id: HirId) -> &'hir TraitItem {\n-        let node_id = self.hir_to_node_id(id);\n-        self.expect_trait_item(node_id)\n-    }\n-\n-    pub fn expect_trait_item(&self, id: NodeId) -> &'hir TraitItem {\n-        match self.find(id) {\n+    pub fn expect_trait_item(&self, id: HirId) -> &'hir TraitItem {\n+        match self.find_by_hir_id(id) {\n             Some(Node::TraitItem(item)) => item,\n-            _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n+            _ => bug!(\"expected trait item, found {}\", self.hir_to_string(id))\n         }\n     }\n \n     pub fn expect_variant_data(&self, id: HirId) -> &'hir VariantData {\n-        let id = self.hir_to_node_id(id); // FIXME(@ljedrz): remove when possible\n-\n-        match self.find(id) {\n+        match self.find_by_hir_id(id) {\n             Some(Node::Item(i)) => {\n                 match i.node {\n                     ItemKind::Struct(ref struct_def, _) |\n                     ItemKind::Union(ref struct_def, _) => struct_def,\n-                    _ => bug!(\"struct ID bound to non-struct {}\", self.node_to_string(id))\n+                    _ => bug!(\"struct ID bound to non-struct {}\", self.hir_to_string(id))\n                 }\n             }\n             Some(Node::StructCtor(data)) => data,\n             Some(Node::Variant(variant)) => &variant.node.data,\n-            _ => bug!(\"expected struct or variant, found {}\", self.node_to_string(id))\n+            _ => bug!(\"expected struct or variant, found {}\", self.hir_to_string(id))\n         }\n     }\n \n     pub fn expect_variant(&self, id: HirId) -> &'hir Variant {\n-        let id = self.hir_to_node_id(id); // FIXME(@ljedrz): remove when possible\n-\n-        match self.find(id) {\n+        match self.find_by_hir_id(id) {\n             Some(Node::Variant(variant)) => variant,\n-            _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n+            _ => bug!(\"expected variant, found {}\", self.hir_to_string(id)),\n         }\n     }\n \n-    pub fn expect_foreign_item(&self, id: NodeId) -> &'hir ForeignItem {\n-        match self.find(id) {\n+    pub fn expect_foreign_item(&self, id: HirId) -> &'hir ForeignItem {\n+        match self.find_by_hir_id(id) {\n             Some(Node::ForeignItem(item)) => item,\n-            _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id))\n+            _ => bug!(\"expected foreign item, found {}\", self.hir_to_string(id))\n         }\n     }\n \n@@ -1016,7 +1002,7 @@ impl<'hir> Map<'hir> {\n             Node::Field(f) => f.ident.name,\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n-            Node::Binding(&Pat { node: PatKind::Binding(_, _, _, l, _), .. }) => l.name,\n+            Node::Binding(&Pat { node: PatKind::Binding(_, _, l, _), .. }) => l.name,\n             Node::StructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }"}, {"sha": "b9db4523ce1d1a0c01b73b6b6c314591072e3f5c", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -328,7 +328,6 @@ pub struct PathSegment {\n     // therefore will not have 'jump to def' in IDEs, but otherwise will not be\n     // affected. (In general, we don't bother to get the defs for synthesized\n     // segments, only for segments which have come from the AST).\n-    pub id: Option<NodeId>,\n     pub hir_id: Option<HirId>,\n     pub def: Option<Def>,\n \n@@ -351,7 +350,6 @@ impl PathSegment {\n     pub fn from_ident(ident: Ident) -> PathSegment {\n         PathSegment {\n             ident,\n-            id: None,\n             hir_id: None,\n             def: None,\n             infer_types: true,\n@@ -361,15 +359,13 @@ impl PathSegment {\n \n     pub fn new(\n         ident: Ident,\n-        id: Option<NodeId>,\n         hir_id: Option<HirId>,\n         def: Option<Def>,\n         args: GenericArgs,\n         infer_types: bool,\n     ) -> Self {\n         PathSegment {\n             ident,\n-            id,\n             hir_id,\n             def,\n             infer_types,\n@@ -941,10 +937,10 @@ pub enum PatKind {\n     Wild,\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n-    /// The `NodeId` is the canonical ID for the variable being bound,\n+    /// The `HirId` is the canonical ID for the variable being bound,\n     /// (e.g., in `Ok(x) | Err(x)`, both `x` use the same canonical ID),\n     /// which is the pattern ID of the first `x`.\n-    Binding(BindingAnnotation, NodeId, HirId, Ident, Option<P<Pat>>),\n+    Binding(BindingAnnotation, HirId, Ident, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -1623,7 +1619,7 @@ pub struct Destination {\n \n     // These errors are caught and then reported during the diagnostics pass in\n     // librustc_passes/loops.rs\n-    pub target_id: Result<NodeId, LoopIdError>,\n+    pub target_id: Result<HirId, LoopIdError>,\n }\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "18a3d6708db64c815a1465b630b44a606c3bb58d", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -70,7 +70,7 @@ impl hir::Pat {\n         where F: FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n     {\n         self.walk(|p| {\n-            if let PatKind::Binding(binding_mode, _, _, ident, _) = p.node {\n+            if let PatKind::Binding(binding_mode, _, ident, _) = p.node {\n                 f(binding_mode, p.hir_id, p.span, ident);\n             }\n             true\n@@ -110,8 +110,8 @@ impl hir::Pat {\n \n     pub fn simple_ident(&self) -> Option<ast::Ident> {\n         match self.node {\n-            PatKind::Binding(hir::BindingAnnotation::Unannotated, _, _, ident, None) |\n-            PatKind::Binding(hir::BindingAnnotation::Mutable, _, _, ident, None) => Some(ident),\n+            PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, None) |\n+            PatKind::Binding(hir::BindingAnnotation::Mutable, _, ident, None) => Some(ident),\n             _ => None,\n         }\n     }"}, {"sha": "54a21f2ed5c2a8c519d020d525d2a55ca31c18c0", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -1765,7 +1765,7 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.node {\n             PatKind::Wild => self.s.word(\"_\")?,\n-            PatKind::Binding(binding_mode, _, _, ident, ref sub) => {\n+            PatKind::Binding(binding_mode, _, ident, ref sub) => {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\")?;"}, {"sha": "6fff16538044eb0984864b0af4f73e052cd9adfb", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -165,7 +165,6 @@ impl_stable_hash_for!(struct hir::Path {\n \n impl_stable_hash_for!(struct hir::PathSegment {\n     ident -> (ident.name),\n-    id,\n     hir_id,\n     def,\n     infer_types,\n@@ -443,7 +442,7 @@ impl_stable_hash_for!(enum hir::RangeEnd {\n \n impl_stable_hash_for!(enum hir::PatKind {\n     Wild,\n-    Binding(binding_mode, var, hir_id, name, sub),\n+    Binding(binding_mode, hir_id, name, sub),\n     Struct(path, field_pats, dotdot),\n     TupleStruct(path, field_pats, dotdot),\n     Path(path),"}, {"sha": "8bd20843163201d84419586d2af284c98e95f62b", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -4,7 +4,6 @@ use crate::hir::Node;\n use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n use crate::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc_data_structures::fx::FxHashMap;\n-use syntax::ast;\n use crate::traits::{self, PredicateObligation};\n use crate::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n@@ -686,13 +685,14 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                     //     let x = || foo(); // returns the Opaque assoc with `foo`\n                     // }\n                     // ```\n-                    if let Some(opaque_node_id) = tcx.hir().as_local_node_id(def_id) {\n+                    if let Some(opaque_hir_id) = tcx.hir().as_local_hir_id(def_id) {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n-                            let opaque_parent_node_id = tcx.hir().get_parent(opaque_node_id);\n-                            parent_def_id == tcx.hir().local_def_id(opaque_parent_node_id)\n+                            let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n+                            parent_def_id == tcx.hir()\n+                                                .local_def_id_from_hir_id(opaque_parent_hir_id)\n                         };\n-                        let in_definition_scope = match tcx.hir().find(opaque_node_id) {\n+                        let in_definition_scope = match tcx.hir().find_by_hir_id(opaque_hir_id) {\n                             Some(Node::Item(item)) => match item.node {\n                                 // impl trait\n                                 hir::ItemKind::Existential(hir::ExistTy {\n@@ -706,21 +706,21 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                                 }) => may_define_existential_type(\n                                     tcx,\n                                     self.parent_def_id,\n-                                    opaque_node_id,\n+                                    opaque_hir_id,\n                                 ),\n                                 _ => def_scope_default(),\n                             },\n                             Some(Node::ImplItem(item)) => match item.node {\n                                 hir::ImplItemKind::Existential(_) => may_define_existential_type(\n                                     tcx,\n                                     self.parent_def_id,\n-                                    opaque_node_id,\n+                                    opaque_hir_id,\n                                 ),\n                                 _ => def_scope_default(),\n                             },\n                             _ => bug!(\n                                 \"expected (impl) item, found {}\",\n-                                tcx.hir().node_to_string(opaque_node_id),\n+                                tcx.hir().hir_to_string(opaque_hir_id),\n                             ),\n                         };\n                         if in_definition_scope {\n@@ -839,20 +839,20 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n pub fn may_define_existential_type(\n     tcx: TyCtxt<'_, '_, '_>,\n     def_id: DefId,\n-    opaque_node_id: ast::NodeId,\n+    opaque_hir_id: hir::HirId,\n ) -> bool {\n-    let mut node_id = tcx\n+    let mut hir_id = tcx\n         .hir()\n-        .as_local_node_id(def_id)\n+        .as_local_hir_id(def_id)\n         .unwrap();\n     // named existential types can be defined by any siblings or\n     // children of siblings\n-    let mod_id = tcx.hir().get_parent(opaque_node_id);\n+    let mod_id = tcx.hir().get_parent_item(opaque_hir_id);\n     // so we walk up the node tree until we hit the root or the parent\n     // of the opaque type\n-    while node_id != mod_id && node_id != ast::CRATE_NODE_ID {\n-        node_id = tcx.hir().get_parent(node_id);\n+    while hir_id != mod_id && hir_id != hir::CRATE_HIR_ID {\n+        hir_id = tcx.hir().get_parent_item(hir_id);\n     }\n     // syntactically we are allowed to define the concrete type\n-    node_id == mod_id\n+    hir_id == mod_id\n }"}, {"sha": "78a9e406c95e9bc98c73ce0cb84230c361bf8d6e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -860,7 +860,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n                     // Each match binding is effectively an assignment to the\n                     // binding being produced.\n-                    let def = Def::Local(canonical_id);\n+                    let def = Def::Local(mc.tcx.hir().hir_to_node_id(canonical_id));\n                     if let Ok(ref binding_cmt) = mc.cat_def(pat.hir_id, pat.span, pat_ty, def) {\n                         delegate.mutate(pat.hir_id, pat.span, binding_cmt, MutateMode::Init);\n                     }\n@@ -918,9 +918,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_captures(&mut self, closure_expr: &hir::Expr, fn_decl_span: Span) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n-        let closure_node_id = self.tcx().hir().hir_to_node_id(closure_expr.hir_id);\n-        let closure_def_id = self.tcx().hir().local_def_id(closure_node_id);\n-        self.tcx().with_freevars(closure_node_id, |freevars| {\n+        let closure_def_id = self.tcx().hir().local_def_id_from_hir_id(closure_expr.hir_id);\n+        self.tcx().with_freevars(closure_expr.hir_id, |freevars| {\n             for freevar in freevars {\n                 let var_hir_id = self.tcx().hir().node_to_hir_id(freevar.var_id());\n                 let upvar_id = ty::UpvarId {"}, {"sha": "2fafc57ce4b2d193c5299d9126ab965ba346a042", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -102,7 +102,7 @@ use crate::hir::Node;\n use crate::ty::{self, TyCtxt};\n use crate::ty::query::Providers;\n use crate::lint;\n-use crate::util::nodemap::{NodeMap, HirIdMap, HirIdSet};\n+use crate::util::nodemap::{HirIdMap, HirIdSet};\n \n use errors::Applicability;\n use std::collections::{BTreeMap, VecDeque};\n@@ -407,7 +407,7 @@ fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n     while let Some(pat) = pats.pop_front() {\n         use crate::hir::PatKind::*;\n         match pat.node {\n-            Binding(_, _, _, _, ref inner_pat) => {\n+            Binding(_, _, _, ref inner_pat) => {\n                 pats.extend(inner_pat.iter());\n             }\n             Struct(_, ref fields, _) => {\n@@ -476,8 +476,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        let node_id = ir.tcx.hir().hir_to_node_id(expr.hir_id);\n-        ir.tcx.with_freevars(node_id, |freevars| {\n+        ir.tcx.with_freevars(expr.hir_id, |freevars| {\n             call_caps.extend(freevars.iter().filter_map(|fv| {\n                 if let Def::Local(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n@@ -670,8 +669,8 @@ struct Liveness<'a, 'tcx: 'a> {\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n-    break_ln: NodeMap<LiveNode>,\n-    cont_ln: NodeMap<LiveNode>,\n+    break_ln: HirIdMap<LiveNode>,\n+    cont_ln: HirIdMap<LiveNode>,\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n@@ -952,8 +951,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode)\n                                -> LiveNode {\n         if blk.targeted_by_break {\n-            let node_id = self.ir.tcx.hir().hir_to_node_id(blk.hir_id);\n-            self.break_ln.insert(node_id, succ);\n+            self.break_ln.insert(blk.hir_id, succ);\n         }\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n@@ -1112,7 +1110,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             hir::ExprKind::Break(label, ref opt_expr) => {\n                 // Find which label this break jumps to\n                 let target = match label.target_id {\n-                    Ok(node_id) => self.break_ln.get(&node_id),\n+                    Ok(hir_id) => self.break_ln.get(&hir_id),\n                     Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n                 }.cloned();\n \n@@ -1391,15 +1389,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.hir_id, self.ir.tcx.hir().hir_to_pretty_string(body.hir_id));\n \n-        let node_id = self.ir.tcx.hir().hir_to_node_id(expr.hir_id);\n-        self.break_ln.insert(node_id, succ);\n+        self.break_ln.insert(expr.hir_id, succ);\n \n         let cond_ln = match kind {\n             LoopLoop => ln,\n             WhileLoop(ref cond) => self.propagate_through_expr(&cond, ln),\n         };\n \n-        self.cont_ln.insert(node_id, cond_ln);\n+        self.cont_ln.insert(expr.hir_id, cond_ln);\n \n         let body_ln = self.propagate_through_block(body, cond_ln);\n "}, {"sha": "8ccf52b4efb2861b4276b9133020b04f2e8eea70", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -51,8 +51,8 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true\n     }\n-    if let Some(impl_node_id) = tcx.hir().as_local_node_id(impl_src) {\n-        match tcx.hir().find(impl_node_id) {\n+    if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_src) {\n+        match tcx.hir().find_by_hir_id(impl_hir_id) {\n             Some(Node::Item(item)) =>\n                 item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n             Some(..) | None =>\n@@ -141,12 +141,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n-        let node_id = match self.tcx.hir().as_local_node_id(def_id) {\n-            Some(node_id) => node_id,\n+        let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n+            Some(hir_id) => hir_id,\n             None => { return false; }\n         };\n \n-        match self.tcx.hir().find(node_id) {\n+        match self.tcx.hir().find_by_hir_id(hir_id) {\n             Some(Node::Item(item)) => {\n                 match item.node {\n                     hir::ItemKind::Fn(..) =>\n@@ -173,7 +173,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         } else {\n                             let impl_did = self.tcx\n                                                .hir()\n-                                               .get_parent_did(node_id);\n+                                               .get_parent_did_by_hir_id(hir_id);\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too."}, {"sha": "062742bca76084e3c4d5fc8043a64fe8cb443f29", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -223,7 +223,7 @@ pub struct ScopeTree {\n     /// The parent of the root body owner, if the latter is an\n     /// an associated const or method, as impls/traits can also\n     /// have lifetime parameters free in this body.\n-    root_parent: Option<ast::NodeId>,\n+    root_parent: Option<hir::HirId>,\n \n     /// `parent_map` maps from a scope ID to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n@@ -650,8 +650,8 @@ impl<'tcx> ScopeTree {\n                                       -> Scope {\n         let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n \n-        let param_owner_id = tcx.hir().as_local_node_id(param_owner).unwrap();\n-        let scope = tcx.hir().maybe_body_owned_by(param_owner_id).map(|body_id| {\n+        let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n+        let scope = tcx.hir().maybe_body_owned_by_by_hir_id(param_owner_id).map(|body_id| {\n             tcx.hir().body(body_id).value.hir_id.local_id\n         }).unwrap_or_else(|| {\n             // The lifetime was defined on node that doesn't own a body,\n@@ -661,7 +661,7 @@ impl<'tcx> ScopeTree {\n                        \"free_scope: {:?} not recognized by the \\\n                         region scope tree for {:?} / {:?}\",\n                        param_owner,\n-                       self.root_parent.map(|id| tcx.hir().local_def_id(id)),\n+                       self.root_parent.map(|id| tcx.hir().local_def_id_from_hir_id(id)),\n                        self.root_body.map(|hir_id| DefId::local(hir_id.owner)));\n \n             // The trait/impl lifetime is in scope for the method's body.\n@@ -686,7 +686,7 @@ impl<'tcx> ScopeTree {\n         // on the same function that they ended up being freed in.\n         assert_eq!(param_owner, fr.scope);\n \n-        let param_owner_id = tcx.hir().as_local_node_id(param_owner).unwrap();\n+        let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n         let body_id = tcx.hir().body_owned_by(param_owner_id);\n         Scope { id: tcx.hir().body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n     }\n@@ -1328,8 +1328,8 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         return tcx.region_scope_tree(closure_base_def_id);\n     }\n \n-    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by_by_hir_id(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n             scope_tree: ScopeTree::default(),\n@@ -1348,10 +1348,10 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         // If the item is an associated const or a method,\n         // record its impl/trait parent, as it can also have\n         // lifetime parameters free in this body.\n-        match tcx.hir().get(id) {\n+        match tcx.hir().get_by_hir_id(id) {\n             Node::ImplItem(_) |\n             Node::TraitItem(_) => {\n-                visitor.scope_tree.root_parent = Some(tcx.hir().get_parent(id));\n+                visitor.scope_tree.root_parent = Some(tcx.hir().get_parent_item(id));\n             }\n             _ => {}\n         }"}, {"sha": "f862b690f8806c490df35e6b3c0be23a9027e313", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -1585,9 +1585,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n-                    let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n-                    debug!(\"node id first={:?}\", node_id);\n-                    if let Some((id, span, name)) = match self.tcx.hir().get(node_id) {\n+                    let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    debug!(\"hir id first={:?}\", hir_id);\n+                    if let Some((id, span, name)) = match self.tcx.hir().get_by_hir_id(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n                             hir_lifetime.hir_id,\n                             hir_lifetime.span,\n@@ -1626,8 +1626,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"Not one use lifetime\");\n                 }\n                 None => {\n-                    let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n-                    if let Some((id, span, name)) = match self.tcx.hir().get(node_id) {\n+                    let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    if let Some((id, span, name)) = match self.tcx.hir().get_by_hir_id(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n                             hir_lifetime.hir_id,\n                             hir_lifetime.span,"}, {"sha": "7a91059b6bf45e0240bc0a5605bc9dbd0d378b40", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -2411,15 +2411,15 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }\n \n                     AggregateKind::Closure(def_id, _) => ty::tls::with(|tcx| {\n-                        if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+                        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n-                                format!(\"[closure@{:?}]\", node_id)\n+                                format!(\"[closure@{:?}]\", hir_id)\n                             } else {\n-                                format!(\"[closure@{:?}]\", tcx.hir().span(node_id))\n+                                format!(\"[closure@{:?}]\", tcx.hir().span_by_hir_id(hir_id))\n                             };\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n-                            tcx.with_freevars(node_id, |freevars| {\n+                            tcx.with_freevars(hir_id, |freevars| {\n                                 for (freevar, place) in freevars.iter().zip(places) {\n                                     let var_name = tcx.hir().name(freevar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n@@ -2433,11 +2433,12 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }),\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n-                        if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n-                            let name = format!(\"[generator@{:?}]\", tcx.hir().span(node_id));\n+                        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+                            let name = format!(\"[generator@{:?}]\",\n+                                               tcx.hir().span_by_hir_id(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n-                            tcx.with_freevars(node_id, |freevars| {\n+                            tcx.with_freevars(hir_id, |freevars| {\n                                 for (freevar, place) in freevars.iter().zip(places) {\n                                     let var_name = tcx.hir().name(freevar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);"}, {"sha": "c75f7d7d15946a8d02448b8b4ed1e63d0fe47503", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -1,5 +1,5 @@\n use crate::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n-use syntax::ast::NodeId;\n+use crate::hir::HirId;\n use syntax::symbol::{Symbol, InternedString};\n use crate::ty::{Instance, TyCtxt};\n use crate::util::nodemap::FxHashMap;\n@@ -14,7 +14,7 @@ use std::hash::Hash;\n pub enum MonoItem<'tcx> {\n     Fn(Instance<'tcx>),\n     Static(DefId),\n-    GlobalAsm(NodeId),\n+    GlobalAsm(HirId),\n }\n \n impl<'tcx> MonoItem<'tcx> {"}, {"sha": "448b0f26d56162a49b3d965e9db82b4cce86e34f", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -761,7 +761,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n                         let closure_span = self.tcx.sess.source_map()\n                             .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n-                        let node_id = self.tcx.hir().as_local_node_id(closure_def_id).unwrap();\n+                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n                         let mut err = struct_span_err!(\n                             self.tcx.sess, closure_span, E0525,\n                             \"expected a closure that implements the `{}` trait, \\\n@@ -780,8 +780,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         // a particular trait.\n                         if let Some(tables) = self.in_progress_tables {\n                             let tables = tables.borrow();\n-                            let closure_hir_id = self.tcx.hir().node_to_hir_id(node_id);\n-                            match (found_kind, tables.closure_kind_origins().get(closure_hir_id)) {\n+                            match (found_kind, tables.closure_kind_origins().get(hir_id)) {\n                                 (ty::ClosureKind::FnOnce, Some((span, name))) => {\n                                     err.span_label(*span, format!(\n                                         \"closure is `FnOnce` because it moves the \\"}, {"sha": "e33d0a74ea013ab99c408b322d2239d84a705c15", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -67,10 +67,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n     /// only checks whether the function has a `const` modifier\n     fn is_const_fn_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n-        let node_id = tcx.hir().as_local_node_id(def_id)\n-                             .expect(\"Non-local call to local provider is_const_fn\");\n+        let hir_id = tcx.hir().as_local_hir_id(def_id)\n+                              .expect(\"Non-local call to local provider is_const_fn\");\n \n-        if let Some(fn_like) = FnLikeNode::from_node(tcx.hir().get(node_id)) {\n+        if let Some(fn_like) = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)) {\n             fn_like.constness() == hir::Constness::Const\n         } else {\n             false"}, {"sha": "2a3a9d1f5f43b3acdda50a4d7fd80f80e898c370", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -1619,10 +1619,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             _ => return None, // not a free region\n         };\n \n-        let node_id = self.hir()\n-            .as_local_node_id(suitable_region_binding_scope)\n+        let hir_id = self.hir()\n+            .as_local_hir_id(suitable_region_binding_scope)\n             .unwrap();\n-        let is_impl_item = match self.hir().find(node_id) {\n+        let is_impl_item = match self.hir().find_by_hir_id(hir_id) {\n             Some(Node::Item(..)) | Some(Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n@@ -1642,8 +1642,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         scope_def_id: DefId,\n     ) -> Option<Ty<'tcx>> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return None\n-        let node_id = self.hir().as_local_node_id(scope_def_id).unwrap();\n-        match self.hir().get(node_id) {\n+        let hir_id = self.hir().as_local_hir_id(scope_def_id).unwrap();\n+        match self.hir().get_by_hir_id(hir_id) {\n             Node::Item(item) => {\n                 match item.node {\n                     ItemKind::Fn(..) => { /* type_of_def_id() will work */ }"}, {"sha": "356f9c32f03df1f56302463c5880f90b62653fa6", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -5,7 +5,7 @@ pub use self::IntVarValue::*;\n pub use self::fold::TypeFoldable;\n \n use crate::hir::{map as hir_map, FreevarMap, GlobMap, TraitMap};\n-use crate::hir::Node;\n+use crate::hir::{HirId, Node};\n use crate::hir::def::{Def, CtorKind, ExportMap};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::hir::map::DefPathData;\n@@ -2726,8 +2726,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssociatedItem> {\n-        let is_associated_item = if let Some(node_id) = self.hir().as_local_node_id(def_id) {\n-            match self.hir().get(node_id) {\n+        let is_associated_item = if let Some(hir_id) = self.hir().as_local_hir_id(def_id) {\n+            match self.hir().get_by_hir_id(hir_id) {\n                 Node::TraitItem(_) | Node::ImplItem(_) => true,\n                 _ => false,\n             }\n@@ -3048,10 +3048,10 @@ impl Iterator for AssociatedItemsIterator<'_, '_, '_> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n+    pub fn with_freevars<T, F>(self, fid: HirId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,\n     {\n-        let def_id = self.hir().local_def_id(fid);\n+        let def_id = self.hir().local_def_id_from_hir_id(fid);\n         match self.freevars(def_id) {\n             None => f(&[]),\n             Some(d) => f(&d),\n@@ -3163,8 +3163,8 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n \n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefId> {\n-    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n-        if let Node::Item(item) = tcx.hir().get(node_id) {\n+    if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+        if let Node::Item(item) = tcx.hir().get_by_hir_id(hir_id) {\n             if let hir::ItemKind::Existential(ref exist_ty) = item.node {\n                 return exist_ty.impl_trait_fn;\n             }"}, {"sha": "49aa6b9e9568aed6a0026f1bbe5892ca3b460e55", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -313,7 +313,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::erase_regions_ty<'tcx> {\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_param_predicates<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, (_, def_id): (DefId, DefId)) -> Cow<'static, str> {\n-        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         format!(\"computing the bounds for type parameter `{}`\",\n                 tcx.hir().ty_param_name(id)).into()\n     }"}, {"sha": "a1398c69ff0c59ea69732cbe4f5c269c948f914e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -1380,10 +1380,10 @@ define_print! {\n                         write!(f, \"[static generator\")?;\n                     }\n \n-                    if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n-                        write!(f, \"@{:?}\", tcx.hir().span(node_id))?;\n+                    if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n+                        write!(f, \"@{:?}\", tcx.hir().span_by_hir_id(hir_id))?;\n                         let mut sep = \" \";\n-                        tcx.with_freevars(node_id, |freevars| {\n+                        tcx.with_freevars(hir_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                                 print!(f, cx,\n                                        write(\"{}{}:\",\n@@ -1416,14 +1416,14 @@ define_print! {\n                     let upvar_tys = substs.upvar_tys(did, tcx);\n                     write!(f, \"[closure\")?;\n \n-                    if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n+                    if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n                         if tcx.sess.opts.debugging_opts.span_free_formats {\n-                            write!(f, \"@{:?}\", node_id)?;\n+                            write!(f, \"@{:?}\", hir_id)?;\n                         } else {\n-                            write!(f, \"@{:?}\", tcx.hir().span(node_id))?;\n+                            write!(f, \"@{:?}\", tcx.hir().span_by_hir_id(hir_id))?;\n                         }\n                         let mut sep = \" \";\n-                        tcx.with_freevars(node_id, |freevars| {\n+                        tcx.with_freevars(hir_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                                 print!(f, cx,\n                                        write(\"{}{}:\","}, {"sha": "d2d5c4fe85c90a8626418eb8bf82f028e4a68c14", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -188,8 +188,8 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n     let def_id = bccx.tcx.hir().body_owner_def_id(body.id());\n \n-    let node_id = bccx.tcx.hir().as_local_node_id(def_id).unwrap();\n-    let movable_generator = !match bccx.tcx.hir().get(node_id) {\n+    let hir_id = bccx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let movable_generator = !match bccx.tcx.hir().get_by_hir_id(hir_id) {\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             .."}, {"sha": "a15d3d10adf0ecce96df3fa11b57a83f0b406135", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -98,7 +98,7 @@ pub fn gather_move_from_pat<'a, 'c, 'tcx: 'c>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                               cmt: &'c mc::cmt_<'tcx>) {\n     let source = get_pattern_source(bccx.tcx,move_pat);\n     let pat_span_path_opt = match move_pat.node {\n-        PatKind::Binding(_, _, _, ident, _) => {\n+        PatKind::Binding(_, _, ident, _) => {\n             Some(MovePlace {\n                      span: move_pat.span,\n                      name: ident.name,"}, {"sha": "da065f9e05d9ed8f29ef155b9ee7a3b348f9bf0d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -83,9 +83,9 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n \n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n \n-    let owner_id = tcx.hir().as_local_node_id(owner_def_id).unwrap();\n+    let owner_id = tcx.hir().as_local_hir_id(owner_def_id).unwrap();\n \n-    match tcx.hir().get(owner_id) {\n+    match tcx.hir().get_by_hir_id(owner_id) {\n         Node::StructCtor(_) |\n         Node::Variant(_) => {\n             // We get invoked with anything that has MIR, but some of\n@@ -681,8 +681,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                              Origin::Ast);\n                 let need_note = match lp.ty.sty {\n                     ty::Closure(id, _) => {\n-                        let node_id = self.tcx.hir().as_local_node_id(id).unwrap();\n-                        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n+                        let hir_id = self.tcx.hir().as_local_hir_id(id).unwrap();\n                         if let Some((span, name)) = self.tables.closure_kind_origins().get(hir_id) {\n                             err.span_note(*span, &format!(\n                                 \"closure cannot be invoked more than once because \\\n@@ -1253,12 +1252,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n             Some(ImmutabilityBlame::AdtFieldDeref(_, field)) => {\n-                let node_id = match self.tcx.hir().as_local_node_id(field.did) {\n-                    Some(node_id) => node_id,\n+                let hir_id = match self.tcx.hir().as_local_hir_id(field.did) {\n+                    Some(hir_id) => hir_id,\n                     None => return\n                 };\n \n-                if let Node::Field(ref field) = self.tcx.hir().get(node_id) {\n+                if let Node::Field(ref field) = self.tcx.hir().get_by_hir_id(hir_id) {\n                     if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n                         db.span_label(field.ty.span, msg);\n                     }"}, {"sha": "8c83e9ef538e5dfc40481dac5cd7ae5f76f55d82", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -213,10 +213,10 @@ impl CodegenCx<'ll, 'tcx> {\n \n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n \n-        let g = if let Some(id) = self.tcx.hir().as_local_node_id(def_id) {\n+        let g = if let Some(id) = self.tcx.hir().as_local_hir_id(def_id) {\n \n             let llty = self.layout_of(ty).llvm_type(self);\n-            let (g, attrs) = match self.tcx.hir().get(id) {\n+            let (g, attrs) = match self.tcx.hir().get_by_hir_id(id) {\n                 Node::Item(&hir::Item {\n                     ref attrs, span, node: hir::ItemKind::Static(..), ..\n                 }) => {"}, {"sha": "48159d7979923803c69477df5ebae4877cf74fe0", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -31,8 +31,8 @@ pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                 };\n                 cx.codegen_static(def_id, is_mutable);\n             }\n-            MonoItem::GlobalAsm(node_id) => {\n-                let item = cx.tcx().hir().expect_item(node_id);\n+            MonoItem::GlobalAsm(hir_id) => {\n+                let item = cx.tcx().hir().expect_item_by_hir_id(hir_id);\n                 if let hir::ItemKind::GlobalAsm(ref ga) = item.node {\n                     cx.codegen_global_asm(ga);\n                 } else {"}, {"sha": "5de5c297c30e51acbec5875733e4dae6eed2e199", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -242,7 +242,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n \n     debug!(\"symbol_name(def_id={:?}, substs={:?})\", def_id, substs);\n \n-    let node_id = tcx.hir().as_local_node_id(def_id);\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n \n     if def_id.is_local() {\n         if tcx.plugin_registrar_fn(LOCAL_CRATE) == Some(def_id) {\n@@ -256,8 +256,8 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     }\n \n     // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n-    let is_foreign = if let Some(id) = node_id {\n-        match tcx.hir().get(id) {\n+    let is_foreign = if let Some(id) = hir_id {\n+        match tcx.hir().get_by_hir_id(id) {\n             Node::ForeignItem(_) => true,\n             _ => false,\n         }"}, {"sha": "aafae28b49ea55f84e78549228f362b37519e201", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                     // (Issue #49588)\n                     continue;\n                 }\n-                if let PatKind::Binding(_, _, _, ident, None) = fieldpat.node.pat.node {\n+                if let PatKind::Binding(_, _, ident, None) = fieldpat.node.pat.node {\n                     if cx.tcx.find_field_index(ident, &variant) ==\n                        Some(cx.tcx.field_index(fieldpat.node.hir_id, cx.tables)) {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n@@ -458,8 +458,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.def.def_id();\n-                if let Some(node_id) = cx.tcx.hir().as_local_node_id(real_trait) {\n-                    match cx.tcx.hir().find(node_id) {\n+                if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(real_trait) {\n+                    match cx.tcx.hir().find_by_hir_id(hir_id) {\n                         Some(Node::Item(item)) => {\n                             if let hir::VisibilityKind::Inherited = item.vis.node {\n                                 for impl_item_ref in impl_item_refs {"}, {"sha": "fa18dd1eb8ddbd062f37ed2fdafe019ead86019c", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -358,7 +358,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n-        if let &PatKind::Binding(_, _, _, ident, _) = &p.node {\n+        if let &PatKind::Binding(_, _, ident, _) = &p.node {\n             self.check_snake_case(cx, \"variable\", &ident);\n         }\n     }"}, {"sha": "ce0618d4599e714153e12ac551aee4331095632b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -783,8 +783,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-        let ast_item = tcx.hir().expect_trait_item(node_id);\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let ast_item = tcx.hir().expect_trait_item(hir_id);\n         let trait_item = tcx.associated_item(def_id);\n \n         let container = match trait_item.defaultness {\n@@ -893,8 +893,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n-        let ast_item = self.tcx.hir().expect_impl_item(node_id);\n+        let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let ast_item = self.tcx.hir().expect_impl_item(hir_id);\n         let impl_item = self.tcx.associated_item(def_id);\n \n         let container = match impl_item.defaultness {\n@@ -982,7 +982,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             let body = self.tcx.hir().body(body_id);\n             self.lazy_seq(body.arguments.iter().map(|arg| {\n                 match arg.pat.node {\n-                    PatKind::Binding(_, _, _, ident, _) => ident.name,\n+                    PatKind::Binding(_, _, ident, _) => ident.name,\n                     _ => keywords::Invalid.name(),\n                 }\n             }))\n@@ -1364,8 +1364,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let tcx = self.tcx;\n \n         let tables = self.tcx.typeck_tables_of(def_id);\n-        let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n-        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n+        let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n         let kind = match tables.node_type(hir_id).sty {\n             ty::Generator(def_id, ..) => {\n                 let layout = self.tcx.generator_layout(def_id);\n@@ -1407,7 +1406,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     fn encode_info_for_anon_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_anon_const({:?})\", def_id);\n         let tcx = self.tcx;\n-        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let body_id = tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n         let mir = tcx.mir_const_qualif(def_id).0;"}, {"sha": "fe07cc0698a0a0e4f17c6f8e201e3919fa4f75f2", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -191,8 +191,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let needs_note = match ty.sty {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck_tables_of(id);\n-                    let node_id = self.infcx.tcx.hir().as_local_node_id(id).unwrap();\n-                    let hir_id = self.infcx.tcx.hir().node_to_hir_id(node_id);\n+                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(id).unwrap();\n \n                     tables.closure_kind_origins().get(hir_id).is_none()\n                 }\n@@ -1525,8 +1524,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n                 if let ty::TyKind::Closure(did, _) = self.mir.local_decls[closure].ty.sty {\n-                    let node_id = self.infcx.tcx.hir().as_local_node_id(did).unwrap();\n-                    let hir_id = self.infcx.tcx.hir().node_to_hir_id(node_id);\n+                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n \n                     if let Some((span, name)) = self.infcx.tcx.typeck_tables_of(did)\n                         .closure_kind_origins()\n@@ -1549,8 +1547,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // Check if we are just moving a closure after it has been invoked.\n         if let Some(target) = target {\n             if let ty::TyKind::Closure(did, _) = self.mir.local_decls[target].ty.sty {\n-                let node_id = self.infcx.tcx.hir().as_local_node_id(did).unwrap();\n-                let hir_id = self.infcx.tcx.hir().node_to_hir_id(node_id);\n+                let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n \n                 if let Some((span, name)) = self.infcx.tcx.typeck_tables_of(did)\n                     .closure_kind_origins()\n@@ -1790,10 +1787,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // the local code in the current crate, so this returns an `Option` in case\n                     // the closure comes from another crate. But in that case we wouldn't\n                     // be borrowck'ing it, so we can just unwrap:\n-                    let node_id = self.infcx.tcx.hir().as_local_node_id(def_id).unwrap();\n+                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id).unwrap();\n                     let freevar = self.infcx\n                         .tcx\n-                        .with_freevars(node_id, |fv| fv[field.index()]);\n+                        .with_freevars(hir_id, |fv| fv[field.index()]);\n \n                     self.infcx.tcx.hir().name(freevar.var_id()).to_string()\n                 }\n@@ -2105,8 +2102,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> Option<AnnotatedBorrowFnSignature<'_>> {\n         debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n         let is_closure = self.infcx.tcx.is_closure(did);\n-        let fn_node_id = self.infcx.tcx.hir().as_local_node_id(did)?;\n-        let fn_decl = self.infcx.tcx.hir().fn_decl(fn_node_id)?;\n+        let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did)?;\n+        let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(fn_hir_id)?;\n \n         // We need to work out which arguments to highlight. We do this by looking\n         // at the return type, where there are three cases:\n@@ -2560,14 +2557,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"closure_span: def_id={:?} target_place={:?} places={:?}\",\n             def_id, target_place, places\n         );\n-        let node_id = self.infcx.tcx.hir().as_local_node_id(def_id)?;\n-        let expr = &self.infcx.tcx.hir().expect_expr(node_id).node;\n-        debug!(\"closure_span: node_id={:?} expr={:?}\", node_id, expr);\n+        let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id)?;\n+        let expr = &self.infcx.tcx.hir().expect_expr_by_hir_id(hir_id).node;\n+        debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(\n             .., args_span, _\n         ) = expr {\n             let var_span = self.infcx.tcx.with_freevars(\n-                node_id,\n+                hir_id,\n                 |freevars| {\n                     for (v, place) in freevars.iter().zip(places) {\n                         match place {"}, {"sha": "d5dfdf0add528860f15dd07ec1333b4a11530779", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -128,7 +128,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let param_env = tcx.param_env(def_id);\n     let id = tcx\n         .hir()\n-        .as_local_node_id(def_id)\n+        .as_local_hir_id(def_id)\n         .expect(\"do_mir_borrowck: non-local DefId\");\n \n     // Replace all regions with fresh inference variables. This\n@@ -163,7 +163,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n \n-    let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(id).is_fn_or_closure();\n+    let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind_by_hir_id(id).is_fn_or_closure();\n     let borrow_set = Rc::new(BorrowSet::build(\n             tcx, mir, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n@@ -216,7 +216,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n \n-    let movable_generator = match tcx.hir().get(id) {\n+    let movable_generator = match tcx.hir().get_by_hir_id(id) {\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             .."}, {"sha": "65703adfdff70c603e6d2f2e94f8061a4e157799", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -314,7 +314,6 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,\n-                        _,\n                         upvar_ident,\n                         _,\n                     ) = pat.node\n@@ -635,8 +634,8 @@ fn annotate_struct_field(\n         if let ty::TyKind::Adt(def, _) = ty.sty {\n             let field = def.all_fields().nth(field.index())?;\n             // Use the HIR types to construct the diagnostic message.\n-            let node_id = tcx.hir().as_local_node_id(field.did)?;\n-            let node = tcx.hir().find(node_id)?;\n+            let hir_id = tcx.hir().as_local_hir_id(field.did)?;\n+            let node = tcx.hir().find_by_hir_id(hir_id)?;\n             // Now we're dealing with the actual struct that we're going to suggest a change to,\n             // we can expect a field that is an immutable reference to a type.\n             if let hir::Node::Field(field) = node {"}, {"sha": "d3731e7c1274e3bfd5e4cf703937beab8a2af00c", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -10,12 +10,13 @@ use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::hair::{self, *};\n+use rustc::hir::HirId;\n use rustc::mir::*;\n use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty};\n use rustc::ty::layout::VariantIdx;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::Name;\n use syntax_pos::Span;\n \n // helper functions, broken out by category:\n@@ -530,7 +531,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn storage_live_binding(\n         &mut self,\n         block: BasicBlock,\n-        var: NodeId,\n+        var: HirId,\n         span: Span,\n         for_guard: ForGuard,\n     ) -> Place<'tcx> {\n@@ -545,17 +546,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         );\n         let place = Place::Base(PlaceBase::Local(local_id));\n         let var_ty = self.local_decls[local_id].ty;\n-        let hir_id = self.hir.tcx().hir().node_to_hir_id(var);\n-        let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n+        let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n         self.schedule_drop(span, region_scope, &place, var_ty, DropKind::Storage);\n         place\n     }\n \n-    pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span, for_guard: ForGuard) {\n+    pub fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n         let local_id = self.var_local_id(var, for_guard);\n         let var_ty = self.local_decls[local_id].ty;\n-        let hir_id = self.hir.tcx().hir().node_to_hir_id(var);\n-        let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n+        let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n         self.schedule_drop(\n             span,\n             region_scope,\n@@ -576,7 +575,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             Mutability,\n             Name,\n             BindingMode,\n-            NodeId,\n+            HirId,\n             Span,\n             Ty<'tcx>,\n             UserTypeProjections<'tcx>,\n@@ -703,7 +702,7 @@ struct Binding<'tcx> {\n     span: Span,\n     source: Place<'tcx>,\n     name: Name,\n-    var_id: NodeId,\n+    var_id: HirId,\n     var_ty: Ty<'tcx>,\n     mutability: Mutability,\n     binding_mode: BindingMode,\n@@ -1694,7 +1693,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         mutability: Mutability,\n         name: Name,\n         mode: BindingMode,\n-        var_id: NodeId,\n+        var_id: HirId,\n         var_ty: Ty<'tcx>,\n         user_ty: UserTypeProjections<'tcx>,\n         has_guard: ArmHasGuard,"}, {"sha": "c855940cada6796bb14d78088261918c47988df1", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -13,13 +13,12 @@ use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::SubstsRef;\n-use rustc::util::nodemap::NodeMap;\n+use rustc::util::nodemap::HirIdMap;\n use rustc_target::spec::PanicStrategy;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use std::mem;\n use std::u32;\n use rustc_target::spec::abi::Abi;\n-use syntax::ast;\n use syntax::attr::{self, UnwindAttr};\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n@@ -28,10 +27,10 @@ use super::lints;\n \n /// Construct the MIR for a given `DefId`.\n pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'tcx> {\n-    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n-    let (body_id, return_ty_span) = match tcx.hir().get(id) {\n+    let (body_id, return_ty_span) = match tcx.hir().get_by_hir_id(id) {\n         Node::Variant(variant) =>\n             return create_constructor_shim(tcx, id, &variant.node.data),\n         Node::StructCtor(ctor) =>\n@@ -68,19 +67,18 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             (*body, tcx.hir().span_by_hir_id(*hir_id))\n         }\n \n-        _ => span_bug!(tcx.hir().span(id), \"can't build MIR for {:?}\", def_id),\n+        _ => span_bug!(tcx.hir().span_by_hir_id(id), \"can't build MIR for {:?}\", def_id),\n     };\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let fn_hir_id = tcx.hir().node_to_hir_id(id);\n-        let cx = Cx::new(&infcx, fn_hir_id);\n+        let cx = Cx::new(&infcx, id);\n         let mut mir = if cx.tables().tainted_by_errors {\n             build::construct_error(cx, body_id)\n         } else if cx.body_owner_kind.is_fn_or_closure() {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n-            let fn_sig = cx.tables().liberated_fn_sigs()[fn_hir_id].clone();\n-            let fn_def_id = tcx.hir().local_def_id(id);\n+            let fn_sig = cx.tables().liberated_fn_sigs()[id].clone();\n+            let fn_def_id = tcx.hir().local_def_id_from_hir_id(id);\n \n             let ty = tcx.type_of(fn_def_id);\n             let mut abi = fn_sig.abi;\n@@ -92,7 +90,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                     Some(ArgInfo(liberated_closure_env_ty(tcx, id, body_id), None, None, None))\n                 }\n                 ty::Generator(..) => {\n-                    let gen_ty = tcx.body_tables(body_id).node_type(fn_hir_id);\n+                    let gen_ty = tcx.body_tables(body_id).node_type(id);\n                     Some(ArgInfo(gen_ty, None, None, None))\n                 }\n                 _ => None,\n@@ -141,7 +139,8 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                     ty::Generator(gen_def_id, gen_substs, ..) =>\n                         gen_substs.sig(gen_def_id, tcx),\n                     _ =>\n-                        span_bug!(tcx.hir().span(id), \"generator w/o generator type: {:?}\", ty),\n+                        span_bug!(tcx.hir().span_by_hir_id(id),\n+                                  \"generator w/o generator type: {:?}\", ty),\n                 };\n                 (Some(gen_sig.yield_ty), gen_sig.return_ty)\n             } else {\n@@ -224,11 +223,11 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n }\n \n fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     ctor_id: ast::NodeId,\n+                                     ctor_id: hir::HirId,\n                                      v: &'tcx hir::VariantData)\n                                      -> Mir<'tcx>\n {\n-    let span = tcx.hir().span(ctor_id);\n+    let span = tcx.hir().span_by_hir_id(ctor_id);\n     if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n         tcx.infer_ctxt().enter(|infcx| {\n             let mut mir = shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n@@ -259,11 +258,10 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n fn liberated_closure_env_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            closure_expr_id: ast::NodeId,\n+                                            closure_expr_id: hir::HirId,\n                                             body_id: hir::BodyId)\n                                             -> Ty<'tcx> {\n-    let closure_expr_hir_id = tcx.hir().node_to_hir_id(closure_expr_id);\n-    let closure_ty = tcx.body_tables(body_id).node_type(closure_expr_hir_id);\n+    let closure_ty = tcx.body_tables(body_id).node_type(closure_expr_id);\n \n     let (closure_def_id, closure_substs) = match closure_ty.sty {\n         ty::Closure(closure_def_id, closure_substs) => (closure_def_id, closure_substs),\n@@ -377,7 +375,7 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     /// Maps `NodeId`s of variable bindings to the `Local`s created for them.\n     /// (A match binding can have two locals; the 2nd is for the arm's guard.)\n-    var_indices: NodeMap<LocalsForNode>,\n+    var_indices: HirIdMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     canonical_user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n     upvar_decls: Vec<UpvarDecl>,\n@@ -393,11 +391,11 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n-    fn is_bound_var_in_guard(&self, id: ast::NodeId) -> bool {\n+    fn is_bound_var_in_guard(&self, id: hir::HirId) -> bool {\n         self.guard_context.iter().any(|frame| frame.locals.iter().any(|local| local.id == id))\n     }\n \n-    fn var_local_id(&self, id: ast::NodeId, for_guard: ForGuard) -> Local {\n+    fn var_local_id(&self, id: hir::HirId, for_guard: ForGuard) -> Local {\n         self.var_indices[&id].local_id(for_guard)\n     }\n }\n@@ -472,11 +470,11 @@ enum LocalsForNode {\n \n #[derive(Debug)]\n struct GuardFrameLocal {\n-    id: ast::NodeId,\n+    id: hir::HirId,\n }\n \n impl GuardFrameLocal {\n-    fn new(id: ast::NodeId, _binding_mode: BindingMode) -> Self {\n+    fn new(id: hir::HirId, _binding_mode: BindingMode) -> Self {\n         GuardFrameLocal {\n             id: id,\n         }\n@@ -606,7 +604,7 @@ struct ArgInfo<'gcx>(Ty<'gcx>,\n                      Option<ImplicitSelfKind>);\n \n fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n-                                   fn_id: ast::NodeId,\n+                                   fn_id: hir::HirId,\n                                    arguments: A,\n                                    safety: Safety,\n                                    abi: Abi,\n@@ -621,10 +619,10 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n \n     let tcx = hir.tcx();\n     let tcx_hir = tcx.hir();\n-    let span = tcx_hir.span(fn_id);\n+    let span = tcx_hir.span_by_hir_id(fn_id);\n \n     let hir_tables = hir.tables();\n-    let fn_def_id = tcx_hir.local_def_id(fn_id);\n+    let fn_def_id = tcx_hir.local_def_id_from_hir_id(fn_id);\n \n     // Gather the upvars of a closure, if any.\n     // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n@@ -651,7 +649,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 mutability: Mutability::Not,\n             };\n             if let Some(Node::Binding(pat)) = tcx_hir.find(var_node_id) {\n-                if let hir::PatKind::Binding(_, _, _, ident, _) = pat.node {\n+                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                     decl.debug_name = ident.name;\n                     if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n                         if bm == ty::BindByValue(hir::MutMutable) {\n@@ -718,9 +716,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         // RustCall pseudo-ABI untuples the last argument.\n         spread_arg = Some(Local::new(arguments.len()));\n     }\n-    let closure_expr_id = tcx_hir.local_def_id(fn_id);\n-    info!(\"fn_id {:?} has attrs {:?}\", closure_expr_id,\n-          tcx.get_attrs(closure_expr_id));\n+    info!(\"fn_id {:?} has attrs {:?}\", fn_def_id,\n+          tcx.get_attrs(fn_def_id));\n \n     let mut mir = builder.finish(yield_ty);\n     mir.spread_arg = spread_arg;\n@@ -857,8 +854,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let mut name = None;\n             if let Some(pat) = pattern {\n                 match pat.node {\n-                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, _, ident, _)\n-                    | hir::PatKind::Binding(hir::BindingAnnotation::Mutable, _, _, ident, _) => {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _)\n+                    | hir::PatKind::Binding(hir::BindingAnnotation::Mutable, _, ident, _) => {\n                         name = Some(ident.name);\n                     }\n                     _ => (),"}, {"sha": "3f5d82e5f091a8a6a1060c3fd5fcce39af67f2a6", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -617,15 +617,15 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n     let cid = key.value;\n     let def_id = cid.instance.def.def_id();\n \n-    if let Some(id) = tcx.hir().as_local_node_id(def_id) {\n+    if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n         let tables = tcx.typeck_tables_of(def_id);\n \n         // Do match-check before building MIR\n         if let Err(ErrorReported) = tcx.check_match(def_id) {\n             return Err(ErrorHandled::Reported)\n         }\n \n-        if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind(id) {\n+        if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind_by_hir_id(id) {\n             tcx.mir_const_qualif(def_id);\n         }\n "}, {"sha": "da9cc118f55215aedc3cbb48105b78f539a96b62", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -1,6 +1,6 @@\n //! Hook into libgraphviz for rendering dataflow graphs for MIR.\n \n-use syntax::ast::NodeId;\n+use rustc::hir::HirId;\n use rustc::mir::{BasicBlock, Mir};\n \n use std::fs;\n@@ -14,7 +14,7 @@ use super::DebugFormatted;\n \n pub trait MirWithFlowState<'tcx> {\n     type BD: BitDenotation<'tcx>;\n-    fn node_id(&self) -> NodeId;\n+    fn hir_id(&self) -> HirId;\n     fn mir(&self) -> &Mir<'tcx>;\n     fn flow_state(&self) -> &DataflowState<'tcx, Self::BD>;\n }\n@@ -23,7 +23,7 @@ impl<'a, 'tcx, BD> MirWithFlowState<'tcx> for DataflowBuilder<'a, 'tcx, BD>\n     where BD: BitDenotation<'tcx>\n {\n     type BD = BD;\n-    fn node_id(&self) -> NodeId { self.node_id }\n+    fn hir_id(&self) -> HirId { self.hir_id }\n     fn mir(&self) -> &Mir<'tcx> { self.flow_state.mir() }\n     fn flow_state(&self) -> &DataflowState<'tcx, Self::BD> { &self.flow_state.flow_state }\n }\n@@ -47,8 +47,8 @@ pub(crate) fn print_borrowck_graph_to<'a, 'tcx, BD, P>(\n     let g = Graph { mbcx, phantom: PhantomData, render_idx };\n     let mut v = Vec::new();\n     dot::render(&g, &mut v)?;\n-    debug!(\"print_borrowck_graph_to path: {} node_id: {}\",\n-           path.display(), mbcx.node_id);\n+    debug!(\"print_borrowck_graph_to path: {} hir_id: {}\",\n+           path.display(), mbcx.hir_id);\n     fs::write(path, v)\n }\n \n@@ -70,7 +70,7 @@ impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n     type Edge = Edge;\n     fn graph_id(&self) -> dot::Id<'_> {\n         dot::Id::new(format!(\"graph_for_node_{}\",\n-                             self.mbcx.node_id()))\n+                             self.mbcx.hir_id()))\n             .unwrap()\n     }\n "}, {"sha": "03f8ac67436173ccac325789f812a2bd4f0aa444", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -4,6 +4,7 @@ use rustc_data_structures::bit_set::{BitSet, BitSetOperator, HybridBitSet};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::work_queue::WorkQueue;\n \n+use rustc::hir::HirId;\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n use rustc::mir::traversal;\n@@ -38,7 +39,7 @@ pub(crate) struct DataflowBuilder<'a, 'tcx: 'a, BD>\n where\n     BD: BitDenotation<'tcx>\n {\n-    node_id: ast::NodeId,\n+    hir_id: HirId,\n     flow_state: DataflowAnalysis<'a, 'tcx, BD>,\n     print_preflow_to: Option<String>,\n     print_postflow_to: Option<String>,\n@@ -116,7 +117,7 @@ pub struct MoveDataParamEnv<'gcx, 'tcx> {\n \n pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                  mir: &'a Mir<'tcx>,\n-                                                 node_id: ast::NodeId,\n+                                                 hir_id: HirId,\n                                                  attributes: &[ast::Attribute],\n                                                  dead_unwinds: &BitSet<BasicBlock>,\n                                                  bd: BD,\n@@ -126,14 +127,14 @@ pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n           P: Fn(&BD, BD::Idx) -> DebugFormatted\n {\n     let flow_state = DataflowAnalysis::new(mir, dead_unwinds, bd);\n-    flow_state.run(tcx, node_id, attributes, p)\n+    flow_state.run(tcx, hir_id, attributes, p)\n }\n \n impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation<'tcx>\n {\n     pub(crate) fn run<P>(self,\n                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                         node_id: ast::NodeId,\n+                         hir_id: HirId,\n                          attributes: &[ast::Attribute],\n                          p: P) -> DataflowResults<'tcx, BD>\n         where P: Fn(&BD, BD::Idx) -> DebugFormatted\n@@ -158,7 +159,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitD\n             name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n \n         let mut mbcx = DataflowBuilder {\n-            node_id,\n+            hir_id,\n             print_preflow_to, print_postflow_to, flow_state: self,\n         };\n "}, {"sha": "6af45957acf0908984dedbe30f6efa6c05655423", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -530,8 +530,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n             };\n-            let expr_node_id = cx.tcx.hir().hir_to_node_id(expr.hir_id);\n-            let upvars = cx.tcx.with_freevars(expr_node_id, |freevars| {\n+            let upvars = cx.tcx.with_freevars(expr.hir_id, |freevars| {\n                 freevars.iter()\n                     .zip(substs.upvar_tys(def_id, cx.tcx))\n                     .map(|(fv, ty)| capture_freevar(cx, expr, fv, ty))\n@@ -592,7 +591,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 Ok(target_id) => ExprKind::Break {\n                     label: region::Scope {\n-                        id: cx.tcx.hir().node_to_hir_id(target_id).local_id,\n+                        id: target_id.local_id,\n                         data: region::ScopeData::Node\n                     },\n                     value: value.to_ref(),\n@@ -604,7 +603,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 Ok(loop_id) => ExprKind::Continue {\n                     label: region::Scope {\n-                        id: cx.tcx.hir().node_to_hir_id(loop_id).local_id,\n+                        id: loop_id.local_id,\n                         data: region::ScopeData::Node\n                     },\n                 },\n@@ -993,7 +992,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n     match def {\n-        Def::Local(id) => ExprKind::VarRef { id },\n+        Def::Local(id) => ExprKind::VarRef { id: cx.tcx.hir().node_to_hir_id(id) },\n \n         Def::Upvar(var_id, index, closure_expr_id) => {\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\","}, {"sha": "385249ec1c13b86a79889ec344f3daf11b9ad4e5", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -12,7 +12,6 @@ use rustc::ty::subst::SubstsRef;\n use rustc::ty::{AdtDef, UpvarSubsts, Ty, Const, LazyConst, UserType};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir;\n-use syntax::ast;\n use syntax_pos::Span;\n use self::cx::Cx;\n \n@@ -230,7 +229,7 @@ pub enum ExprKind<'tcx> {\n         index: ExprRef<'tcx>,\n     },\n     VarRef {\n-        id: ast::NodeId,\n+        id: hir::HirId,\n     },\n     /// first argument, used for self in a closure\n     SelfRef,"}, {"sha": "9768706b37eaac78e597197169224cda77998415", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -38,7 +38,7 @@ pub(crate) fn check_match<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> Result<(), ErrorReported> {\n-    let body_id = if let Some(id) = tcx.hir().as_local_node_id(def_id) {\n+    let body_id = if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n         tcx.hir().body_owned_by(id)\n     } else {\n         return Ok(());\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n     pat.walk(|p| {\n-        if let PatKind::Binding(_, _, _, ident, None) = p.node {\n+        if let PatKind::Binding(_, _, ident, None) = p.node {\n             if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n                 if bm != ty::BindByValue(hir::MutImmutable) {\n                     // Nothing to check.\n@@ -590,7 +590,7 @@ fn check_legality_of_move_bindings(\n \n     for pat in pats {\n         pat.walk(|p| {\n-            if let PatKind::Binding(_, _, _, _, ref sub) = p.node {\n+            if let PatKind::Binding(_, _, _, ref sub) = p.node {\n                 if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n                     match bm {\n                         ty::BindByValue(..) => {"}, {"sha": "55547cd0bc64e6b2a8c403800950cd7c30c38026", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -126,7 +126,7 @@ pub enum PatternKind<'tcx> {\n         mutability: Mutability,\n         name: ast::Name,\n         mode: BindingMode,\n-        var: ast::NodeId,\n+        var: hir::HirId,\n         ty: Ty<'tcx>,\n         subpattern: Option<Pattern<'tcx>>,\n     },\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Binding(_, id, _, ident, ref sub) => {\n+            PatKind::Binding(_, id, ident, ref sub) => {\n                 let var_ty = self.tables.node_type(pat.hir_id);\n                 if let ty::Error = var_ty.sty {\n                     // Avoid ICE\n@@ -1090,7 +1090,7 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ty::Const<'tcx>,\n+    Span, Field, Mutability, ast::Name, hir::HirId, usize, ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode, &'tcx AdtDef,\n     SubstsRef<'tcx>, &'tcx Kind<'tcx>, UserType<'tcx>,\n     UserTypeProjection<'tcx>, PatternTypeProjection<'tcx>"}, {"sha": "6d6a3f91472690c99198d10004e2ebec98b438d7", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -10,9 +10,9 @@ use rustc::ty::subst::InternalSubsts;\n pub fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n              mir: &Mir<'tcx>,\n              def_id: DefId) {\n-    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n-    if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(node_id)) {\n+    if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)) {\n         check_fn_for_unconditional_recursion(tcx, fn_like_node.kind(), mir, def_id);\n     }\n }"}, {"sha": "1e245faddf04c9814b1c20852e42f8d50852df70", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -976,8 +976,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 debug!(\"RootCollector: ItemKind::GlobalAsm({})\",\n                        def_id_to_string(self.tcx,\n                                         self.tcx.hir().local_def_id_from_hir_id(item.hir_id)));\n-                let node_id = self.tcx.hir().hir_to_node_id(item.hir_id);\n-                self.output.push(MonoItem::GlobalAsm(node_id));\n+                self.output.push(MonoItem::GlobalAsm(item.hir_id));\n             }\n             hir::ItemKind::Static(..) => {\n                 let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);"}, {"sha": "211f9ad1735c3bc131dbb13e1d296d2995fca9e6", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -58,8 +58,8 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n             MonoItem::Static(def_id) => {\n                 tcx.symbol_name(Instance::mono(tcx, def_id))\n             }\n-            MonoItem::GlobalAsm(node_id) => {\n-                let def_id = tcx.hir().local_def_id(node_id);\n+            MonoItem::GlobalAsm(hir_id) => {\n+                let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n                 ty::SymbolName {\n                     name: Symbol::intern(&format!(\"global_asm_{:?}\", def_id)).as_interned_str()\n                 }\n@@ -190,15 +190,15 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n         match *self.as_mono_item() {\n             MonoItem::Fn(Instance { def, .. }) => {\n-                tcx.hir().as_local_node_id(def.def_id())\n+                tcx.hir().as_local_hir_id(def.def_id())\n             }\n             MonoItem::Static(def_id) => {\n-                tcx.hir().as_local_node_id(def_id)\n+                tcx.hir().as_local_hir_id(def_id)\n             }\n-            MonoItem::GlobalAsm(node_id) => {\n-                Some(node_id)\n+            MonoItem::GlobalAsm(hir_id) => {\n+                Some(hir_id)\n             }\n-        }.map(|node_id| tcx.hir().span(node_id))\n+        }.map(|hir_id| tcx.hir().span_by_hir_id(hir_id))\n     }\n }\n "}, {"sha": "c0e2186d9f34c7be97baf1807e44098f5a55d872", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -96,10 +96,9 @@ use std::collections::hash_map::Entry;\n use std::cmp;\n use std::sync::Arc;\n \n-use syntax::ast::NodeId;\n use syntax::symbol::InternedString;\n use rustc::dep_graph::{WorkProductId, WorkProduct, DepNode, DepConstructor};\n-use rustc::hir::CodegenFnAttrFlags;\n+use rustc::hir::{CodegenFnAttrFlags, HirId};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::map::DefPathData;\n use rustc::mir::mono::{Linkage, Visibility, CodegenUnitNameBuilder};\n@@ -162,19 +161,19 @@ pub trait CodegenUnitExt<'tcx> {\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n         #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-        pub struct ItemSortKey(Option<NodeId>, ty::SymbolName);\n+        pub struct ItemSortKey(Option<HirId>, ty::SymbolName);\n \n         fn item_sort_key<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    item: MonoItem<'tcx>) -> ItemSortKey {\n             ItemSortKey(match item {\n                 MonoItem::Fn(ref instance) => {\n                     match instance.def {\n-                        // We only want to take NodeIds of user-defined\n+                        // We only want to take HirIds of user-defined\n                         // instances into account. The others don't matter for\n                         // the codegen tests and can even make item order\n                         // unstable.\n                         InstanceDef::Item(def_id) => {\n-                            tcx.hir().as_local_node_id(def_id)\n+                            tcx.hir().as_local_hir_id(def_id)\n                         }\n                         InstanceDef::VtableShim(..) |\n                         InstanceDef::Intrinsic(..) |\n@@ -188,10 +187,10 @@ pub trait CodegenUnitExt<'tcx> {\n                     }\n                 }\n                 MonoItem::Static(def_id) => {\n-                    tcx.hir().as_local_node_id(def_id)\n+                    tcx.hir().as_local_hir_id(def_id)\n                 }\n-                MonoItem::GlobalAsm(node_id) => {\n-                    Some(node_id)\n+                MonoItem::GlobalAsm(hir_id) => {\n+                    Some(hir_id)\n                 }\n             }, item.symbol_name(tcx))\n         }\n@@ -404,8 +403,8 @@ fn mono_item_visibility(\n                 Visibility::Hidden\n             };\n         }\n-        MonoItem::GlobalAsm(node_id) => {\n-            let def_id = tcx.hir().local_def_id(*node_id);\n+        MonoItem::GlobalAsm(hir_id) => {\n+            let def_id = tcx.hir().local_def_id_from_hir_id(*hir_id);\n             return if tcx.is_reachable_non_generic(def_id) {\n                 *can_be_internalized = false;\n                 default_visibility(tcx, def_id, false)\n@@ -789,7 +788,7 @@ fn characteristic_def_id_of_mono_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Some(def_id)\n         }\n         MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(node_id) => Some(tcx.hir().local_def_id(node_id)),\n+        MonoItem::GlobalAsm(hir_id) => Some(tcx.hir().local_def_id_from_hir_id(hir_id)),\n     }\n }\n "}, {"sha": "b494592c89f439929591ebcc95c4aa95e70feaaa", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -533,8 +533,8 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n \n     let param_env = tcx.param_env(def_id);\n \n-    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let (const_context, min_const_fn) = match tcx.hir().body_owner_kind(id) {\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let (const_context, min_const_fn) = match tcx.hir().body_owner_kind_by_hir_id(id) {\n         hir::BodyOwnerKind::Closure => (false, false),\n         hir::BodyOwnerKind::Fn => (tcx.is_const_fn(def_id), tcx.is_min_const_fn(def_id)),\n         hir::BodyOwnerKind::Const |"}, {"sha": "23d8138efccaf7d2962130f667e9dea4c111fa98", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -37,10 +37,10 @@ impl MirPass for ConstProp {\n         }\n \n         use rustc::hir::map::blocks::FnLikeNode;\n-        let node_id = tcx.hir().as_local_node_id(source.def_id())\n-                             .expect(\"Non-local call to local provider is_const_fn\");\n+        let hir_id = tcx.hir().as_local_hir_id(source.def_id())\n+                              .expect(\"Non-local call to local provider is_const_fn\");\n \n-        let is_fn_like = FnLikeNode::from_node(tcx.hir().get(node_id)).is_some();\n+        let is_fn_like = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)).is_some();\n         let is_assoc_const = match tcx.describe_def(source.def_id()) {\n             Some(Def::AssociatedConst(_)) => true,\n             _ => false,"}, {"sha": "32c027d90a0cebda7d95ca29cfe4c245fa3b5e87", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -11,11 +11,11 @@ use crate::util::elaborate_drops::{DropFlagState, Unwind, elaborate_drop};\n use crate::util::elaborate_drops::{DropElaborator, DropStyle, DropFlagMode};\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::layout::VariantIdx;\n+use rustc::hir;\n use rustc::mir::*;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::bit_set::BitSet;\n use std::fmt;\n-use syntax::ast;\n use syntax_pos::Span;\n \n pub struct ElaborateDrops;\n@@ -28,7 +28,7 @@ impl MirPass for ElaborateDrops {\n     {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, mir.span);\n \n-        let id = tcx.hir().as_local_node_id(src.def_id()).unwrap();\n+        let id = tcx.hir().as_local_hir_id(src.def_id()).unwrap();\n         let param_env = tcx.param_env(src.def_id()).with_reveal_all();\n         let move_data = match MoveData::gather_moves(mir, tcx) {\n             Ok(move_data) => move_data,\n@@ -80,7 +80,7 @@ impl MirPass for ElaborateDrops {\n fn find_dead_unwinds<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    id: ast::NodeId,\n+    id: hir::HirId,\n     env: &MoveDataParamEnv<'tcx, 'tcx>)\n     -> BitSet<BasicBlock>\n {"}, {"sha": "1f59802f8c6c09244e48e6a918864bbb512d9fb4", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -383,13 +383,13 @@ fn locals_live_across_suspend_points(\n     FxHashMap<BasicBlock, liveness::LiveVarSet>,\n ) {\n     let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n-    let node_id = tcx.hir().as_local_node_id(source.def_id()).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(source.def_id()).unwrap();\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n     let storage_live_analysis = MaybeStorageLive::new(mir);\n     let storage_live =\n-        do_dataflow(tcx, mir, node_id, &[], &dead_unwinds, storage_live_analysis,\n+        do_dataflow(tcx, mir, hir_id, &[], &dead_unwinds, storage_live_analysis,\n                     |bd, p| DebugFormatted::new(&bd.mir().local_decls[p]));\n \n     // Find the MIR locals which do not use StorageLive/StorageDead statements.\n@@ -403,7 +403,7 @@ fn locals_live_across_suspend_points(\n     let borrowed_locals = if !movable {\n         let analysis = HaveBeenBorrowedLocals::new(mir);\n         let result =\n-            do_dataflow(tcx, mir, node_id, &[], &dead_unwinds, analysis,\n+            do_dataflow(tcx, mir, hir_id, &[], &dead_unwinds, analysis,\n                         |bd, p| DebugFormatted::new(&bd.mir().local_decls[p]));\n         Some((analysis, result))\n     } else {"}, {"sha": "234483df13ada3eae12c2da93bcc16951893a155", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -72,8 +72,10 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         let param_env = self.tcx.param_env(self.source.def_id());\n \n         // Only do inlining into fn bodies.\n-        let id = self.tcx.hir().as_local_node_id(self.source.def_id()).unwrap();\n-        if self.tcx.hir().body_owner_kind(id).is_fn_or_closure() && self.source.promoted.is_none() {\n+        let id = self.tcx.hir().as_local_hir_id(self.source.def_id()).unwrap();\n+        if self.tcx.hir().body_owner_kind_by_hir_id(id).is_fn_or_closure()\n+            && self.source.promoted.is_none()\n+        {\n             for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated() {\n                 if let Some(callsite) = self.get_valid_function_call(bb,\n                                                                     bb_data,"}, {"sha": "0cd2cecf39c032af603fee6d998daf93983a0c17", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -214,8 +214,8 @@ fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n }\n \n fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n-    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind(node_id) {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind_by_hir_id(hir_id) {\n         // Ensure that we compute the `mir_const_qualif` for constants at\n         // this point, before we steal the mir-const result.\n         let _ = tcx.mir_const_qualif(def_id);"}, {"sha": "f078316b97ce85fc95df8402b482faff7e0d607d", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -3,6 +3,7 @@ use syntax::ast;\n use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt};\n+use rustc::hir;\n use rustc::mir::{self, Mir, Location};\n use rustc_data_structures::bit_set::BitSet;\n use crate::transform::{MirPass, MirSource};\n@@ -26,7 +27,7 @@ impl MirPass for SanityCheck {\n     fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>, mir: &mut Mir<'tcx>) {\n         let def_id = src.def_id();\n-        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         if !tcx.has_attr(def_id, \"rustc_mir\") {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.item_path_str(def_id));\n             return;\n@@ -85,7 +86,7 @@ impl MirPass for SanityCheck {\n /// errors are not intended to be used for unit tests.)\n pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 mir: &Mir<'tcx>,\n-                                                id: ast::NodeId,\n+                                                id: hir::HirId,\n                                                 _attributes: &[ast::Attribute],\n                                                 results: &DataflowResults<'tcx, O>)\n     where O: BitDenotation<'tcx, Idx=MovePathIndex> + HasMoveData<'tcx>"}, {"sha": "61b1a5a850d28b0124d5ebf0ace66107ed44050d", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -27,7 +27,7 @@ pub fn write_mir_fn_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n                                       w: &mut W) -> io::Result<()>\n     where W: Write\n {\n-    writeln!(w, \"digraph Mir_{} {{\", tcx.hir().as_local_node_id(def_id).unwrap())?;\n+    writeln!(w, \"digraph Mir_{} {{\", tcx.hir().as_local_hir_id(def_id).unwrap())?;\n \n     // Global graph properties\n     writeln!(w, r#\"    graph [fontname=\"monospace\"];\"#)?;"}, {"sha": "d08fb40966c4992a3f52808ce32aa1105c41449d", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -282,7 +282,7 @@ fn dump_matched_mir_node<'a, 'tcx>(\n ) {\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n-    let item_id = tcx.hir().as_local_node_id(source.def_id()).unwrap();\n+    let item_id = tcx.hir().as_local_hir_id(source.def_id()).unwrap();\n     let file_name = format!(\"rustc.node{}{}-liveness.mir\", item_id, pass_name);\n     file_path.push(&file_name);\n     let _ = fs::File::create(&file_path).and_then(|mut file| {"}, {"sha": "2272ac97cddaa843466039d21228ee52080c2ab7", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -8,7 +8,6 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Node, Destination};\n-use syntax::ast;\n use syntax::struct_span_err;\n use syntax_pos::Span;\n use errors::Applicability;\n@@ -105,25 +104,25 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 let loop_id = match label.target_id.into() {\n                     Ok(loop_id) => loop_id,\n-                    Err(hir::LoopIdError::OutsideLoopScope) => ast::DUMMY_NODE_ID,\n+                    Err(hir::LoopIdError::OutsideLoopScope) => hir::DUMMY_HIR_ID,\n                     Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n                         self.emit_unlabled_cf_in_while_condition(e.span, \"break\");\n-                        ast::DUMMY_NODE_ID\n+                        hir::DUMMY_HIR_ID\n                     },\n-                    Err(hir::LoopIdError::UnresolvedLabel) => ast::DUMMY_NODE_ID,\n+                    Err(hir::LoopIdError::UnresolvedLabel) => hir::DUMMY_HIR_ID,\n                 };\n \n-                if loop_id != ast::DUMMY_NODE_ID {\n-                    if let Node::Block(_) = self.hir_map.find(loop_id).unwrap() {\n+                if loop_id != hir::DUMMY_HIR_ID {\n+                    if let Node::Block(_) = self.hir_map.find_by_hir_id(loop_id).unwrap() {\n                         return\n                     }\n                 }\n \n                 if opt_expr.is_some() {\n-                    let loop_kind = if loop_id == ast::DUMMY_NODE_ID {\n+                    let loop_kind = if loop_id == hir::DUMMY_HIR_ID {\n                         None\n                     } else {\n-                        Some(match self.hir_map.expect_expr(loop_id).node {\n+                        Some(match self.hir_map.expect_expr_by_hir_id(loop_id).node {\n                             hir::ExprKind::While(..) => LoopKind::WhileLoop,\n                             hir::ExprKind::Loop(_, _, source) => LoopKind::Loop(source),\n                             ref r => span_bug!(e.span,\n@@ -162,7 +161,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 match destination.target_id {\n                     Ok(loop_id) => {\n-                        if let Node::Block(block) = self.hir_map.find(loop_id).unwrap() {\n+                        if let Node::Block(block) = self.hir_map.find_by_hir_id(loop_id).unwrap() {\n                             struct_span_err!(self.sess, e.span, E0696,\n                                             \"`continue` pointing to a labeled block\")\n                                 .span_label(e.span,"}, {"sha": "af01e38cb54317f0eb89800d9e18b0dd2e68f033", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -52,9 +52,9 @@ fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     assert!(def_id.is_local());\n \n-    let node_id = tcx.hir().as_local_node_id(def_id)\n+    let hir_id = tcx.hir().as_local_hir_id(def_id)\n         .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n-    let body_id = tcx.hir().body_owned_by(node_id);\n+    let body_id = tcx.hir().body_owned_by(hir_id);\n     tcx.rvalue_promotable_map(def_id).contains(&body_id.hir_id.local_id)\n }\n \n@@ -79,9 +79,9 @@ fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     // `def_id` should be a `Body` owner\n-    let node_id = tcx.hir().as_local_node_id(def_id)\n+    let hir_id = tcx.hir().as_local_hir_id(def_id)\n         .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n-    let body_id = tcx.hir().body_owned_by(node_id);\n+    let body_id = tcx.hir().body_owned_by(hir_id);\n     let _ = visitor.check_nested_body(body_id);\n \n     Lrc::new(visitor.result)\n@@ -455,10 +455,9 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Closure(_capture_clause, ref _box_fn_decl,\n                                body_id, _span, _option_generator_movability) => {\n             let nested_body_promotable = v.check_nested_body(body_id);\n-            let node_id = v.tcx.hir().hir_to_node_id(e.hir_id);\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n-            if v.tcx.with_freevars(node_id, |fv| !fv.is_empty()) {\n+            if v.tcx.with_freevars(e.hir_id, |fv| !fv.is_empty()) {\n                 NotPromotable\n             } else {\n                 nested_body_promotable"}, {"sha": "d07e89209e7f01c6aa6c106a3e984f7d99220119", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -1182,10 +1182,10 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n         // A path can only be private if:\n         // it's in this crate...\n-        if let Some(node_id) = self.tcx.hir().as_local_node_id(did) {\n+        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n             // .. and it corresponds to a private type in the AST (this returns\n             // `None` for type parameters).\n-            match self.tcx.hir().find(node_id) {\n+            match self.tcx.hir().find_by_hir_id(hir_id) {\n                 Some(Node::Item(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }"}, {"sha": "d80f3e5ce759cae9434335eb20e3f886e5d49867", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -647,7 +647,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Node::Binding(&hir::Pat {\n                 node: hir::PatKind::Binding(_, canonical_id, ..),\n                 ..\n-            }) => HirDef::Local(canonical_id),\n+            }) => HirDef::Local(self.tcx.hir().hir_to_node_id(canonical_id)),\n \n             Node::Ty(ty) => if let hir::Ty {\n                 node: hir::TyKind::Path(ref qpath),"}, {"sha": "c908c6993e19e883e8230a903382a6feda561858", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -213,8 +213,8 @@ crate fn environment<'a, 'tcx>(\n         // could bound lifetimes.\n         .map(Clause::ForAll);\n \n-    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let node = tcx.hir().get(node_id);\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let node = tcx.hir().get_by_hir_id(hir_id);\n \n     enum NodeKind {\n         TraitImpl,"}, {"sha": "89ec92a652160940916a66615dfd96c81843a247", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -1223,8 +1223,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let suitable_bounds = traits::transitive_bounds(tcx, bounds)\n             .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name));\n \n-        let param_node_id = tcx.hir().as_local_node_id(ty_param_def_id).unwrap();\n-        let param_name = tcx.hir().ty_param_name(param_node_id);\n+        let param_hir_id = tcx.hir().as_local_hir_id(ty_param_def_id).unwrap();\n+        let param_name = tcx.hir().ty_param_name(param_hir_id);\n         self.one_bound_for_assoc_type(suitable_bounds,\n                                       &param_name.as_str(),\n                                       assoc_name,"}, {"sha": "1a3ade7f8baf6b7d8672af00a834eabdd2fb0892", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.demand_eqtype_pat(pat.span, expected, rhs_ty, match_discrim_span);\n                 common_type\n             }\n-            PatKind::Binding(ba, _, var_id, _, ref sub) => {\n+            PatKind::Binding(ba, var_id, _, ref sub) => {\n                 let bm = if ba == hir::BindingAnnotation::Unannotated {\n                     def_bm\n                 } else {"}, {"sha": "6f3cd56c7bf5b204951e54a3f74d7da4a4a75198", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -712,9 +712,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         let b = self.shallow_resolve(b);\n \n-        let node_id_a = self.tcx.hir().as_local_node_id(def_id_a).unwrap();\n+        let hir_id_a = self.tcx.hir().as_local_hir_id(def_id_a).unwrap();\n         match b.sty {\n-            ty::FnPtr(_) if self.tcx.with_freevars(node_id_a, |v| v.is_empty()) => {\n+            ty::FnPtr(_) if self.tcx.with_freevars(hir_id_a, |v| v.is_empty()) => {\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to"}, {"sha": "1e5f5d244e9c4895db89c2279a2b560f051de9b0", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -83,8 +83,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // This node-id should be used for the `body_id` field on each\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n-    let impl_m_node_id = tcx.hir().as_local_node_id(impl_m.def_id).unwrap();\n-    let impl_m_hir_id = tcx.hir().node_to_hir_id(impl_m_node_id);\n+    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n \n     let cause = ObligationCause {\n         span: impl_m_span,\n@@ -416,8 +415,10 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                                                      trait_sig: ty::FnSig<'tcx>)\n                                                      -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n-    let impl_m_node_id = tcx.hir().as_local_node_id(impl_m.def_id).unwrap();\n-    let (impl_m_output, impl_m_iter) = match tcx.hir().expect_impl_item(impl_m_node_id).node {\n+    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n+    let (impl_m_output, impl_m_iter) = match tcx.hir()\n+                                                .expect_impl_item(impl_m_hir_id)\n+                                                .node {\n         ImplItemKind::Method(ref impl_m_sig, _) => {\n             (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n         }\n@@ -426,8 +427,10 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n \n     match *terr {\n         TypeError::Mutability => {\n-            if let Some(trait_m_node_id) = tcx.hir().as_local_node_id(trait_m.def_id) {\n-                let trait_m_iter = match tcx.hir().expect_trait_item(trait_m_node_id).node {\n+            if let Some(trait_m_hir_id) = tcx.hir().as_local_hir_id(trait_m.def_id) {\n+                let trait_m_iter = match tcx.hir()\n+                                            .expect_trait_item(trait_m_hir_id)\n+                                            .node {\n                     TraitItemKind::Method(ref trait_m_sig, _) => {\n                         trait_m_sig.decl.inputs.iter()\n                     }\n@@ -451,9 +454,9 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n             }\n         }\n         TypeError::Sorts(ExpectedFound { .. }) => {\n-            if let Some(trait_m_node_id) = tcx.hir().as_local_node_id(trait_m.def_id) {\n+            if let Some(trait_m_hir_id) = tcx.hir().as_local_hir_id(trait_m.def_id) {\n                 let (trait_m_output, trait_m_iter) =\n-                    match tcx.hir().expect_trait_item(trait_m_node_id).node {\n+                    match tcx.hir().expect_trait_item(trait_m_hir_id).node {\n                         TraitItemKind::Method(ref trait_m_sig, _) => {\n                             (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter())\n                         }\n@@ -596,8 +599,8 @@ fn compare_number_of_generics<'a, 'tcx>(\n         if impl_count != trait_count {\n             err_occurred = true;\n \n-            let impl_node_id = tcx.hir().as_local_node_id(impl_.def_id).unwrap();\n-            let impl_item = tcx.hir().expect_impl_item(impl_node_id);\n+            let impl_hir_id = tcx.hir().as_local_hir_id(impl_.def_id).unwrap();\n+            let impl_item = tcx.hir().expect_impl_item(impl_hir_id);\n             let span = if impl_item.generics.params.is_empty()\n                 || impl_item.generics.span.is_dummy() { // argument position impl Trait (#55374)\n                 impl_span\n@@ -661,8 +664,8 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n     let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n     if trait_number_args != impl_number_args {\n-        let trait_m_node_id = tcx.hir().as_local_node_id(trait_m.def_id);\n-        let trait_span = if let Some(trait_id) = trait_m_node_id {\n+        let trait_m_hir_id = tcx.hir().as_local_hir_id(trait_m.def_id);\n+        let trait_span = if let Some(trait_id) = trait_m_hir_id {\n             match tcx.hir().expect_trait_item(trait_id).node {\n                 TraitItemKind::Method(ref trait_m_sig, _) => {\n                     let pos = if trait_number_args > 0 {\n@@ -687,8 +690,8 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         } else {\n             trait_item_span\n         };\n-        let impl_m_node_id = tcx.hir().as_local_node_id(impl_m.def_id).unwrap();\n-        let impl_span = match tcx.hir().expect_impl_item(impl_m_node_id).node {\n+        let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n+        let impl_span = match tcx.hir().expect_impl_item(impl_m_hir_id).node {\n             ImplItemKind::Method(ref impl_m_sig, _) => {\n                 let pos = if impl_number_args > 0 {\n                     impl_number_args - 1\n@@ -927,8 +930,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Create a parameter environment that represents the implementation's\n         // method.\n-        let impl_c_node_id = tcx.hir().as_local_node_id(impl_c.def_id).unwrap();\n-        let impl_c_hir_id = tcx.hir().node_to_hir_id(impl_c_node_id);\n+        let impl_c_hir_id = tcx.hir().as_local_hir_id(impl_c.def_id).unwrap();\n \n         // Compute placeholder form of impl and trait const tys.\n         let impl_ty = tcx.type_of(impl_c.def_id);\n@@ -960,7 +962,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    trait_ty);\n \n             // Locate the Span containing just the type of the offending impl\n-            match tcx.hir().expect_impl_item(impl_c_node_id).node {\n+            match tcx.hir().expect_impl_item(impl_c_hir_id).node {\n                 ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n                 _ => bug!(\"{:?} is not a impl const\", impl_c),\n             }\n@@ -972,10 +974,10 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              trait\",\n                                             trait_c.ident);\n \n-            let trait_c_node_id = tcx.hir().as_local_node_id(trait_c.def_id);\n-            let trait_c_span = trait_c_node_id.map(|trait_c_node_id| {\n+            let trait_c_hir_id = tcx.hir().as_local_hir_id(trait_c.def_id);\n+            let trait_c_span = trait_c_hir_id.map(|trait_c_hir_id| {\n                 // Add a label to the Span containing just the type of the const\n-                match tcx.hir().expect_trait_item(trait_c_node_id).node {\n+                match tcx.hir().expect_trait_item(trait_c_hir_id).node {\n                     TraitItemKind::Const(ref ty, _) => ty.span,\n                     _ => bug!(\"{:?} is not a trait const\", trait_c),\n                 }"}, {"sha": "2882ed47f12cc787805472c300528a04555cd48b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -593,8 +593,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n                  -> InheritedBuilder<'a, 'gcx, 'tcx> {\n         let hir_id_root = if def_id.is_local() {\n-            let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-            let hir_id = tcx.hir().definitions().node_to_hir_id(node_id);\n+            let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n             DefId::local(hir_id.owner)\n         } else {\n             def_id\n@@ -619,8 +618,8 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> Self {\n         let tcx = infcx.tcx;\n-        let item_id = tcx.hir().as_local_node_id(def_id);\n-        let body_id = item_id.and_then(|id| tcx.hir().maybe_body_owned_by(id));\n+        let item_id = tcx.hir().as_local_hir_id(def_id);\n+        let body_id = item_id.and_then(|id| tcx.hir().maybe_body_owned_by_by_hir_id(id));\n         let implicit_region_bound = body_id.map(|body_id| {\n             let body = tcx.hir().body(body_id);\n             tcx.mk_region(ty::ReScope(region::Scope {\n@@ -1005,7 +1004,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n-        if let PatKind::Binding(_, _, _, ident, _) = p.node {\n+        if let PatKind::Binding(_, _, ident, _) = p.node {\n             let var_ty = self.assign(p.span, p.hir_id, None);\n \n             let node_id = self.fcx.tcx.hir().hir_to_node_id(p.hir_id);\n@@ -1920,9 +1919,9 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n                                  -> Lrc<ty::GenericPredicates<'tcx>>\n     {\n         let tcx = self.tcx;\n-        let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-        let item_id = tcx.hir().ty_param_owner(node_id);\n-        let item_def_id = tcx.hir().local_def_id(item_id);\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let item_id = tcx.hir().ty_param_owner(hir_id);\n+        let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n         let generics = tcx.generics_of(item_def_id);\n         let index = generics.param_def_id_to_index[&def_id];\n         Lrc::new(ty::GenericPredicates {\n@@ -4263,7 +4262,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::Break(destination, ref expr_opt) => {\n                 if let Ok(target_id) = destination.target_id {\n-                    let target_id = tcx.hir().node_to_hir_id(target_id);\n                     let (e_ty, cause);\n                     if let Some(ref e) = *expr_opt {\n                         // If this is a break with a value, we need to type-check"}, {"sha": "3e6e6576b63ba3c4dd1cded29c86bfb7dd28b4df", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -120,9 +120,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             None\n         };\n \n-        let closure_node_id = self.tcx.hir().hir_to_node_id(closure_hir_id);\n-\n-        self.tcx.with_freevars(closure_node_id, |freevars| {\n+        self.tcx.with_freevars(closure_hir_id, |freevars| {\n             let mut freevar_list: Vec<ty::UpvarId> = Vec::with_capacity(freevars.len());\n             for freevar in freevars {\n                 let upvar_id = ty::UpvarId {\n@@ -217,10 +215,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // inference algorithm will reject it).\n \n         // Equate the type variables for the upvars with the actual types.\n-        let final_upvar_tys = self.final_upvar_tys(closure_node_id);\n+        let final_upvar_tys = self.final_upvar_tys(closure_hir_id);\n         debug!(\n             \"analyze_closure: id={:?} substs={:?} final_upvar_tys={:?}\",\n-            closure_node_id, substs, final_upvar_tys\n+            closure_hir_id, substs, final_upvar_tys\n         );\n         for (upvar_ty, final_upvar_ty) in substs\n             .upvar_tys(closure_def_id, self.tcx)\n@@ -238,14 +236,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Returns a list of `ClosureUpvar`s for each upvar.\n-    fn final_upvar_tys(&self, closure_id: ast::NodeId) -> Vec<Ty<'tcx>> {\n+    fn final_upvar_tys(&self, closure_id: hir::HirId) -> Vec<Ty<'tcx>> {\n         // Presently an unboxed closure type cannot \"escape\" out of a\n         // function, so we will only encounter ones that originated in the\n         // local crate or were inlined into it along with some function.\n         // This may change if abstract return types of some sort are\n         // implemented.\n         let tcx = self.tcx;\n-        let closure_def_index = tcx.hir().local_def_id(closure_id);\n+        let closure_def_index = tcx.hir().local_def_id_from_hir_id(closure_id);\n \n         tcx.with_freevars(closure_id, |freevars| {\n             freevars"}, {"sha": "c7bab8d170904552cba8c313c3896d8dab595c63", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -151,8 +151,8 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n }\n \n pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let trait_item = tcx.hir().expect_trait_item(node_id);\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let trait_item = tcx.hir().expect_trait_item(hir_id);\n \n     let method_sig = match trait_item.node {\n         hir::TraitItemKind::Method(ref sig, _) => Some(sig),\n@@ -162,8 +162,8 @@ pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n }\n \n pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let impl_item = tcx.hir().expect_impl_item(node_id);\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let impl_item = tcx.hir().expect_impl_item(hir_id);\n \n     let method_sig = match impl_item.node {\n         hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n@@ -625,8 +625,8 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                 let generics = tcx.generics_of(def_id);\n                 // only check named existential types defined in this crate\n                 if generics.parent.is_none() && def_id.is_local() {\n-                    let opaque_node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-                    if may_define_existential_type(tcx, fn_def_id, opaque_node_id) {\n+                    let opaque_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    if may_define_existential_type(tcx, fn_def_id, opaque_hir_id) {\n                         trace!(\"check_existential_types may define. Generics: {:#?}\", generics);\n                         let mut seen: FxHashMap<_, Vec<_>> = FxHashMap::default();\n                         for (subst, param) in substs.iter().zip(&generics.params) {"}, {"sha": "cbb6d9b29f59f7f642588ffbe18ae3e0e18d7d22", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -94,8 +94,8 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n             // Note that if we carry through to the `extern_mod_stmt_cnum` query\n             // below it'll cause a panic because `def_id` is actually bogus at this\n             // point in time otherwise.\n-            if let Some(id) = tcx.hir().as_local_node_id(def_id) {\n-                if tcx.hir().find(id).is_none() {\n+            if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n+                if tcx.hir().find_by_hir_id(id).is_none() {\n                     return false;\n                 }\n             }"}, {"sha": "5d86bc5409532e0ecef0c9e96f2bcdc2db62f2ee", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -50,8 +50,8 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n         /* do nothing */\n     } else {\n         // Destructors only work on nominal types.\n-        if let Some(impl_node_id) = tcx.hir().as_local_node_id(impl_did) {\n-            if let Some(Node::Item(item)) = tcx.hir().find(impl_node_id) {\n+        if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_did) {\n+            if let Some(Node::Item(item)) = tcx.hir().find_by_hir_id(impl_hir_id) {\n                 let span = match item.node {\n                     ItemKind::Impl(.., ref ty, _) => ty.span,\n                     _ => item.span,"}, {"sha": "fb5b06470b957864d9839c03437590ddf8bb3684", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -255,9 +255,9 @@ fn type_param_predicates<'a, 'tcx>(\n     // written inline like `<T : Foo>` or in a where clause like\n     // `where T : Foo`.\n \n-    let param_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let param_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let param_owner = tcx.hir().ty_param_owner(param_id);\n-    let param_owner_def_id = tcx.hir().local_def_id(param_owner);\n+    let param_owner_def_id = tcx.hir().local_def_id_from_hir_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n     let index = generics.param_def_id_to_index[&def_id];\n     let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(param_id).as_interned_str());\n@@ -280,8 +280,8 @@ fn type_param_predicates<'a, 'tcx>(\n         },\n     );\n \n-    let item_node_id = tcx.hir().as_local_node_id(item_def_id).unwrap();\n-    let ast_generics = match tcx.hir().get(item_node_id) {\n+    let item_hir_id = tcx.hir().as_local_hir_id(item_def_id).unwrap();\n+    let ast_generics = match tcx.hir().get_by_hir_id(item_hir_id) {\n         Node::TraitItem(item) => &item.generics,\n \n         Node::ImplItem(item) => &item.generics,\n@@ -301,7 +301,7 @@ fn type_param_predicates<'a, 'tcx>(\n                 | ItemKind::Union(_, ref generics) => generics,\n                 ItemKind::Trait(_, _, ref generics, ..) => {\n                     // Implied `Self: Trait` and supertrait bounds.\n-                    if param_id == item_node_id {\n+                    if param_id == item_hir_id {\n                         let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n                         Lrc::make_mut(&mut result)\n                             .predicates\n@@ -322,10 +322,9 @@ fn type_param_predicates<'a, 'tcx>(\n     };\n \n     let icx = ItemCtxt::new(tcx, item_def_id);\n-    let param_hir_id = tcx.hir().node_to_hir_id(param_id);\n     Lrc::make_mut(&mut result)\n         .predicates\n-        .extend(icx.type_parameter_bounds_in_generics(ast_generics, param_hir_id, ty,\n+        .extend(icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty,\n             OnlySelfBounds(true)));\n     result\n }\n@@ -480,7 +479,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: hir::HirId) {\n }\n \n fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: hir::HirId) {\n-    let trait_item = tcx.hir().expect_trait_item_by_hir_id(trait_item_id);\n+    let trait_item = tcx.hir().expect_trait_item(trait_item_id);\n     let def_id = tcx.hir().local_def_id_from_hir_id(trait_item.hir_id);\n     tcx.generics_of(def_id);\n \n@@ -505,7 +504,7 @@ fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: hir::H\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n-    if let hir::ImplItemKind::Method(..) = tcx.hir().expect_impl_item_by_hir_id(impl_item_id).node {\n+    if let hir::ImplItemKind::Method(..) = tcx.hir().expect_impl_item(impl_item_id).node {\n         tcx.fn_sig(def_id);\n     }\n }\n@@ -619,8 +618,8 @@ fn convert_variant<'a, 'tcx>(\n fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n     use rustc::hir::*;\n \n-    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let item = match tcx.hir().get(node_id) {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let item = match tcx.hir().get_by_hir_id(hir_id) {\n         Node::Item(item) => item,\n         _ => bug!(),\n     };\n@@ -694,11 +693,11 @@ fn super_predicates_of<'a, 'tcx>(\n     trait_def_id: DefId,\n ) -> Lrc<ty::GenericPredicates<'tcx>> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n-    let trait_node_id = tcx.hir().as_local_node_id(trait_def_id).unwrap();\n+    let trait_hir_id = tcx.hir().as_local_hir_id(trait_def_id).unwrap();\n \n-    let item = match tcx.hir().get(trait_node_id) {\n+    let item = match tcx.hir().get_by_hir_id(trait_hir_id) {\n         Node::Item(item) => item,\n-        _ => bug!(\"trait_node_id {} is not an item\", trait_node_id),\n+        _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n     };\n \n     let (generics, bounds) = match item.node {\n@@ -887,14 +886,14 @@ fn has_late_bound_regions<'a, 'tcx>(\n fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Generics {\n     use rustc::hir::*;\n \n-    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n-    let node = tcx.hir().get(node_id);\n+    let node = tcx.hir().get_by_hir_id(hir_id);\n     let parent_def_id = match node {\n         Node::ImplItem(_) | Node::TraitItem(_) | Node::Variant(_)\n         | Node::StructCtor(_) | Node::Field(_) => {\n-            let parent_id = tcx.hir().get_parent(node_id);\n-            Some(tcx.hir().local_def_id(parent_id))\n+            let parent_id = tcx.hir().get_parent_item(hir_id);\n+            Some(tcx.hir().local_def_id_from_hir_id(parent_id))\n         }\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n@@ -994,7 +993,6 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n             }),\n     );\n \n-    let hir_id = tcx.hir().node_to_hir_id(node_id);\n     let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id);\n \n     // Now create the real type parameters.\n@@ -1096,7 +1094,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                 }),\n         );\n \n-        tcx.with_freevars(node_id, |fv| {\n+        tcx.with_freevars(hir_id, |fv| {\n             params.extend(fv.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n                 ty::GenericParamDef {\n                     index: type_start + i,\n@@ -1569,16 +1567,16 @@ fn find_existential_constraints<'a, 'tcx>(\n         tcx,\n         found: None,\n     };\n-    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let parent = tcx.hir().get_parent(node_id);\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let parent = tcx.hir().get_parent_item(hir_id);\n \n     trace!(\"parent_id: {:?}\", parent);\n \n-    if parent == ast::CRATE_NODE_ID {\n+    if parent == hir::CRATE_HIR_ID {\n         intravisit::walk_crate(&mut locator, tcx.hir().krate());\n     } else {\n-        trace!(\"parent: {:?}\", tcx.hir().get(parent));\n-        match tcx.hir().get(parent) {\n+        trace!(\"parent: {:?}\", tcx.hir().get_by_hir_id(parent));\n+        match tcx.hir().get_by_hir_id(parent) {\n             Node::Item(ref it) => intravisit::walk_item(&mut locator, it),\n             Node::ImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n             Node::TraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n@@ -1603,11 +1601,11 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n     use rustc::hir::*;\n     use rustc::hir::Node::*;\n \n-    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    match tcx.hir().get(node_id) {\n+    match tcx.hir().get_by_hir_id(hir_id) {\n         TraitItem(hir::TraitItem {\n             node: TraitItemKind::Method(sig, _),\n             ..\n@@ -1626,7 +1624,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n             node: ForeignItemKind::Fn(ref fn_decl, _, _),\n             ..\n         }) => {\n-            let abi = tcx.hir().get_foreign_abi(node_id);\n+            let abi = tcx.hir().get_foreign_abi_by_hir_id(hir_id);\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n@@ -1639,7 +1637,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n                 },\n             ..\n         }) => {\n-            let ty = tcx.type_of(tcx.hir().get_parent_did(node_id));\n+            let ty = tcx.type_of(tcx.hir().get_parent_did_by_hir_id(hir_id));\n             let inputs = fields\n                 .iter()\n                 .map(|f| tcx.type_of(tcx.hir().local_def_id_from_hir_id(f.hir_id)));\n@@ -1878,8 +1876,8 @@ fn explicit_predicates_of<'a, 'tcx>(\n         }\n     }\n \n-    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let node = tcx.hir().get(node_id);\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let node = tcx.hir().get_by_hir_id(hir_id);\n \n     let mut is_trait = None;\n     let mut is_default_impl_trait = None;"}, {"sha": "913990ee8789741939f1014167ecc4297b6f7f54", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -26,10 +26,10 @@ fn inferred_outlives_of<'a, 'tcx>(\n ) -> Lrc<Vec<ty::Predicate<'tcx>>> {\n     let id = tcx\n         .hir()\n-        .as_local_node_id(item_def_id)\n+        .as_local_hir_id(item_def_id)\n         .expect(\"expected local def-id\");\n \n-    match tcx.hir().get(id) {\n+    match tcx.hir().get_by_hir_id(id) {\n         Node::Item(item) => match item.node {\n             hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);"}, {"sha": "0b656ed44cc635b6aa5b5d53e74c5edcd4e941a9", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -3,7 +3,7 @@ use rustc::traits::auto_trait as auto;\n use rustc::ty::{self, TypeFoldable};\n use std::fmt::Debug;\n \n-use self::def_ctor::{get_def_from_def_id, get_def_from_node_id};\n+use self::def_ctor::{get_def_from_def_id, get_def_from_hir_id};\n \n use super::*;\n \n@@ -25,9 +25,9 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         })\n     }\n \n-    pub fn get_with_node_id(&self, id: ast::NodeId, name: String) -> Vec<Item> {\n-        get_def_from_node_id(&self.cx, id, name, &|def_ctor, name| {\n-            let did = self.cx.tcx.hir().local_def_id(id);\n+    pub fn get_with_hir_id(&self, id: hir::HirId, name: String) -> Vec<Item> {\n+        get_def_from_hir_id(&self.cx, id, name, &|def_ctor, name| {\n+            let did = self.cx.tcx.hir().local_def_id_from_hir_id(id);\n             self.get_auto_trait_impls(did, &def_ctor, Some(name))\n         })\n     }"}, {"sha": "86914f66c3d29691b06b7937d4ec03762ba7d282", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -9,7 +9,7 @@ use crate::core::DocAccessLevels;\n \n use super::*;\n \n-use self::def_ctor::{get_def_from_def_id, get_def_from_node_id};\n+use self::def_ctor::{get_def_from_def_id, get_def_from_hir_id};\n \n pub struct BlanketImplFinder<'a, 'tcx: 'a, 'rcx: 'a> {\n     pub cx: &'a core::DocContext<'a, 'tcx, 'rcx>,\n@@ -26,9 +26,9 @@ impl<'a, 'tcx, 'rcx> BlanketImplFinder <'a, 'tcx, 'rcx> {\n         })\n     }\n \n-    pub fn get_with_node_id(&self, id: ast::NodeId, name: String) -> Vec<Item> {\n-        get_def_from_node_id(&self.cx, id, name, &|def_ctor, name| {\n-            let did = self.cx.tcx.hir().local_def_id(id);\n+    pub fn get_with_hir_id(&self, id: hir::HirId, name: String) -> Vec<Item> {\n+        get_def_from_hir_id(&self.cx, id, name, &|def_ctor, name| {\n+            let did = self.cx.tcx.hir().local_def_id_from_hir_id(id);\n             self.get_blanket_impls(did, &def_ctor, Some(name))\n         })\n     }"}, {"sha": "17d53479a67aea9943c1aabb5700cb651a4e23df", "filename": "src/librustdoc/clean/def_ctor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -38,13 +38,13 @@ where F: Fn(& dyn Fn(DefId) -> Def) -> Vec<Item> {\n     }\n }\n \n-pub fn get_def_from_node_id<F>(cx: &DocContext<'_, '_, '_>,\n-                               id: ast::NodeId,\n-                               name: String,\n-                               callback: &F,\n+pub fn get_def_from_hir_id<F>(cx: &DocContext<'_, '_, '_>,\n+                              id: hir::HirId,\n+                              name: String,\n+                              callback: &F,\n ) -> Vec<Item>\n where F: Fn(& dyn Fn(DefId) -> Def, String) -> Vec<Item> {\n-    let item = &cx.tcx.hir().expect_item(id).node;\n+    let item = &cx.tcx.hir().expect_item_by_hir_id(id).node;\n \n     callback(&match *item {\n         hir::ItemKind::Struct(_, _) => Def::Struct,"}, {"sha": "abaf87f7aef0f3576472abf67981d2eebf2db7c4", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -422,8 +422,8 @@ fn build_module(\n }\n \n pub fn print_inlined_const(cx: &DocContext<'_, '_, '_>, did: DefId) -> String {\n-    if let Some(node_id) = cx.tcx.hir().as_local_node_id(did) {\n-        cx.tcx.hir().node_to_pretty_string(node_id)\n+    if let Some(node_id) = cx.tcx.hir().as_local_hir_id(did) {\n+        cx.tcx.hir().hir_to_pretty_string(node_id)\n     } else {\n         cx.tcx.rendered_const(did)\n     }"}, {"sha": "5a1b4d2f8ce7724b87b9e1abb0467fd0c67025e4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -1847,7 +1847,7 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n impl<'a, 'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext<'_, '_, '_>) -> FnDecl {\n         let (did, sig) = *self;\n-        let mut names = if cx.tcx.hir().as_local_node_id(did).is_some() {\n+        let mut names = if cx.tcx.hir().as_local_hir_id(did).is_some() {\n             vec![].into_iter()\n         } else {\n             cx.tcx.fn_arg_names(did).into_iter()\n@@ -3541,13 +3541,13 @@ pub struct Impl {\n     pub blanket_impl: Option<Type>,\n }\n \n-pub fn get_auto_traits_with_node_id(\n+pub fn get_auto_traits_with_hir_id(\n     cx: &DocContext<'_, '_, '_>,\n-    id: ast::NodeId,\n+    id: hir::HirId,\n     name: String\n ) -> Vec<Item> {\n     let finder = AutoTraitFinder::new(cx);\n-    finder.get_with_node_id(id, name)\n+    finder.get_with_hir_id(id, name)\n }\n \n pub fn get_auto_traits_with_def_id(\n@@ -3559,13 +3559,13 @@ pub fn get_auto_traits_with_def_id(\n     finder.get_with_def_id(id)\n }\n \n-pub fn get_blanket_impls_with_node_id(\n+pub fn get_blanket_impls_with_hir_id(\n     cx: &DocContext<'_, '_, '_>,\n-    id: ast::NodeId,\n+    id: hir::HirId,\n     name: String\n ) -> Vec<Item> {\n     let finder = BlanketImplFinder::new(cx);\n-    finder.get_with_node_id(id, name)\n+    finder.get_with_hir_id(id, name)\n }\n \n pub fn get_blanket_impls_with_def_id(\n@@ -3869,7 +3869,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n \n     match p.node {\n         PatKind::Wild => \"_\".to_string(),\n-        PatKind::Binding(_, _, _, ident, _) => ident.to_string(),\n+        PatKind::Binding(_, _, ident, _) => ident.to_string(),\n         PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n         PatKind::Struct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n@@ -3902,8 +3902,8 @@ fn name_from_pat(p: &hir::Pat) -> String {\n fn print_const(cx: &DocContext<'_, '_, '_>, n: ty::LazyConst<'_>) -> String {\n     match n {\n         ty::LazyConst::Unevaluated(def_id, _) => {\n-            if let Some(node_id) = cx.tcx.hir().as_local_node_id(def_id) {\n-                print_const_expr(cx, cx.tcx.hir().body_owned_by(node_id))\n+            if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n+                print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n             } else {\n                 inline::print_inlined_const(cx, def_id)\n             }\n@@ -4250,7 +4250,6 @@ where F: Fn(DefId) -> Def {\n         def: def_ctor(def_id),\n         segments: hir::HirVec::from_vec(apb.names.iter().map(|s| hir::PathSegment {\n             ident: ast::Ident::from_str(&s),\n-            id: None,\n             hir_id: None,\n             def: None,\n             args: None,"}, {"sha": "8fe116bd9c87364db7032d8b6a87be787c7928d6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -3,7 +3,7 @@ use rustc_driver::{driver, abort_on_err};\n use rustc::session::{self, config};\n use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CrateNum, LOCAL_CRATE};\n use rustc::hir::def::Def;\n-use rustc::hir::{self, HirVec};\n+use rustc::hir::{self, HirId, HirVec};\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt, AllArenas};\n@@ -17,7 +17,7 @@ use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n use rustc_target::spec::TargetTriple;\n \n-use syntax::ast::{self, Ident, NodeId};\n+use syntax::ast::{self, Ident};\n use syntax::source_map;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::json::JsonEmitter;\n@@ -159,14 +159,23 @@ impl<'a, 'tcx, 'rcx> DocContext<'a, 'tcx, 'rcx> {\n \n     /// Like the function of the same name on the HIR map, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n+    pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if self.all_fake_def_ids.borrow().contains(&def_id) {\n             None\n         } else {\n             self.tcx.hir().as_local_node_id(def_id)\n         }\n     }\n \n+    // FIXME(@ljedrz): remove the NodeId variant\n+    pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n+        if self.all_fake_def_ids.borrow().contains(&def_id) {\n+            None\n+        } else {\n+            self.tcx.hir().as_local_hir_id(def_id)\n+        }\n+    }\n+\n     pub fn get_real_ty<F>(&self,\n                           def_id: DefId,\n                           def_ctor: &F,\n@@ -182,7 +191,6 @@ impl<'a, 'tcx, 'rcx> DocContext<'a, 'tcx, 'rcx> {\n             real_name.unwrap_or(last.ident),\n             None,\n             None,\n-            None,\n             self.generics_to_path_params(generics.clone()),\n             false,\n         ));"}, {"sha": "c346714ab485a501a88a5fa887c4f3a237475b28", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -4,7 +4,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use syntax;\n-use syntax::ast::{self, Ident, NodeId};\n+use syntax::ast::{self, Ident};\n use syntax::feature_gate::UnstableFeatures;\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n@@ -49,7 +49,7 @@ enum PathKind {\n \n struct LinkCollector<'a, 'tcx: 'a, 'rcx: 'a> {\n     cx: &'a DocContext<'a, 'tcx, 'rcx>,\n-    mod_ids: Vec<NodeId>,\n+    mod_ids: Vec<ast::NodeId>,\n     is_nightly_build: bool,\n }\n \n@@ -69,7 +69,7 @@ impl<'a, 'tcx, 'rcx> LinkCollector<'a, 'tcx, 'rcx> {\n                path_str: &str,\n                is_val: bool,\n                current_item: &Option<String>,\n-               parent_id: Option<NodeId>)\n+               parent_id: Option<ast::NodeId>)\n         -> Result<(Def, Option<String>), ()>\n     {\n         let cx = self.cx;\n@@ -220,8 +220,8 @@ impl<'a, 'tcx, 'rcx> LinkCollector<'a, 'tcx, 'rcx> {\n \n impl<'a, 'tcx, 'rcx> DocFolder for LinkCollector<'a, 'tcx, 'rcx> {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n-        let item_node_id = if item.is_mod() {\n-            if let Some(id) = self.cx.tcx.hir().as_local_node_id(item.def_id) {\n+        let item_hir_id = if item.is_mod() {\n+            if let Some(id) = self.cx.tcx.hir().as_local_hir_id(item.def_id) {\n                 Some(id)\n             } else {\n                 debug!(\"attempting to fold on a non-local item: {:?}\", item);\n@@ -248,14 +248,14 @@ impl<'a, 'tcx, 'rcx> DocFolder for LinkCollector<'a, 'tcx, 'rcx> {\n         let current_item = match item.inner {\n             ModuleItem(..) => {\n                 if item.attrs.inner_docs {\n-                    if item_node_id.unwrap() != NodeId::from_u32(0) {\n+                    if item_hir_id.unwrap() != hir::CRATE_HIR_ID {\n                         item.name.clone()\n                     } else {\n                         None\n                     }\n                 } else {\n                     match parent_node.or(self.mod_ids.last().cloned()) {\n-                        Some(parent) if parent != NodeId::from_u32(0) => {\n+                        Some(parent) if parent != ast::CRATE_NODE_ID => {\n                             // FIXME: can we pull the parent module's name from elsewhere?\n                             Some(self.cx.tcx.hir().name(parent).to_string())\n                         }\n@@ -274,7 +274,7 @@ impl<'a, 'tcx, 'rcx> DocFolder for LinkCollector<'a, 'tcx, 'rcx> {\n         };\n \n         if item.is_mod() && item.attrs.inner_docs {\n-            self.mod_ids.push(item_node_id.unwrap());\n+            self.mod_ids.push(self.cx.tcx.hir().hir_to_node_id(item_hir_id.unwrap()));\n         }\n \n         let cx = self.cx;\n@@ -421,7 +421,7 @@ impl<'a, 'tcx, 'rcx> DocFolder for LinkCollector<'a, 'tcx, 'rcx> {\n         }\n \n         if item.is_mod() && !item.attrs.inner_docs {\n-            self.mod_ids.push(item_node_id.unwrap());\n+            self.mod_ids.push(self.cx.tcx.hir().hir_to_node_id(item_hir_id.unwrap()));\n         }\n \n         if item.is_mod() {"}, {"sha": "044e48f990e429c3e196ea4aa1b56f965c9f32cb", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -155,11 +155,11 @@ impl<'a, 'tcx, 'rcx> SyntheticImplCollector<'a, 'tcx, 'rcx> {\n impl<'a, 'tcx, 'rcx> DocFolder for SyntheticImplCollector<'a, 'tcx, 'rcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n-            if let (Some(node_id), Some(name)) =\n-                (self.cx.tcx.hir().as_local_node_id(i.def_id), i.name.clone())\n+            if let (Some(hir_id), Some(name)) =\n+                (self.cx.tcx.hir().as_local_hir_id(i.def_id), i.name.clone())\n             {\n-                self.impls.extend(get_auto_traits_with_node_id(self.cx, node_id, name.clone()));\n-                self.impls.extend(get_blanket_impls_with_node_id(self.cx, node_id, name));\n+                self.impls.extend(get_auto_traits_with_hir_id(self.cx, hir_id, name.clone()));\n+                self.impls.extend(get_blanket_impls_with_hir_id(self.cx, hir_id, name));\n             } else {\n                 self.impls.extend(get_auto_traits_with_def_id(self.cx, i.def_id));\n                 self.impls.extend(get_blanket_impls_with_def_id(self.cx, i.def_id));"}, {"sha": "48fc6f61952b3eacc8e6275bea9195fdd095a2a5", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -291,7 +291,7 @@ pub fn look_for_tests<'a, 'tcx: 'a, 'rcx: 'a>(\n     item: &Item,\n     check_missing_code: bool,\n ) {\n-    if cx.as_local_node_id(item.def_id).is_none() {\n+    if cx.as_local_hir_id(item.def_id).is_none() {\n         // If non-local, no need to check anything.\n         return;\n     }"}, {"sha": "d09ddce09c547d086c991523b302afc274599876", "filename": "src/test/mir-opt/inline-closure-borrows-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -20,7 +20,7 @@ fn foo<T: Copy>(_t: T, q: &i32) -> i32 {\n // ...\n // bb0: {\n //     ...\n-//     _3 = [closure@NodeId(53)];\n+//     _3 = [closure@HirId { owner: DefIndex(0:4), local_id: 27 }];\n //     ...\n //     _4 = &_3;\n //     ..."}, {"sha": "436a8c20e2b495aa5d1275ea387ddb9fcd4deaca", "filename": "src/test/mir-opt/inline-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -16,7 +16,7 @@ fn foo<T: Copy>(_t: T, q: i32) -> i32 {\n // ...\n // bb0: {\n //     ...\n-//     _3 = [closure@NodeId(39)];\n+//     _3 = [closure@HirId { owner: DefIndex(0:4), local_id: 11 }];\n //     ...\n //     _4 = &_3;\n //     ..."}, {"sha": "cdf635567378e2af654c628fd287c8ec76c3a058", "filename": "src/test/mir-opt/retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Ftest%2Fmir-opt%2Fretag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a65cbeea78c2c79b1030a0012cdea475104a44f/src%2Ftest%2Fmir-opt%2Fretag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.rs?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -98,7 +98,7 @@ fn main() {\n // }\n // END rustc.main.EraseRegions.after.mir\n // START rustc.main-{{closure}}.EraseRegions.after.mir\n-// fn main::{{closure}}(_1: &[closure@NodeId(124)], _2: &i32) -> &i32 {\n+// fn main::{{closure}}(_1: &[closure@HirId { owner: DefIndex(0:7), local_id: 70 }], _2: &i32) -> &i32 {\n //     ...\n //     bb0: {\n //         Retag([fn entry] _1);"}, {"sha": "5d78250c75db3b1923072cf1be3b03f7d0cef5e2", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=2a65cbeea78c2c79b1030a0012cdea475104a44f", "patch": "@@ -1 +1 @@\n-Subproject commit caccf8bd4c3d490d6a4cf329a3411bbf68753642\n+Subproject commit 5d78250c75db3b1923072cf1be3b03f7d0cef5e2"}]}