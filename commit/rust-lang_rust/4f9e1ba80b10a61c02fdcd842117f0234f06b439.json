{"sha": "4f9e1ba80b10a61c02fdcd842117f0234f06b439", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmOWUxYmE4MGIxMGE2MWMwMmZkY2Q4NDIxMTdmMDIzNGYwNmI0Mzk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-01-13T23:05:12Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-01-13T23:43:12Z"}, "message": "More doc porting.", "tree": {"sha": "c0e461c38265c0fee3d3e78e8776ead2ecae700a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0e461c38265c0fee3d3e78e8776ead2ecae700a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f9e1ba80b10a61c02fdcd842117f0234f06b439", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f9e1ba80b10a61c02fdcd842117f0234f06b439", "html_url": "https://github.com/rust-lang/rust/commit/4f9e1ba80b10a61c02fdcd842117f0234f06b439", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f9e1ba80b10a61c02fdcd842117f0234f06b439/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a34a7128a7eb73712d34bd3d39215ff5edb1026", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a34a7128a7eb73712d34bd3d39215ff5edb1026", "html_url": "https://github.com/rust-lang/rust/commit/4a34a7128a7eb73712d34bd3d39215ff5edb1026"}], "stats": {"total": 413, "additions": 377, "deletions": 36}, "files": [{"sha": "b498751e8806f86c3a3adda2558a25baacec2239", "filename": "doc/rust.md", "status": "modified", "additions": 373, "deletions": 36, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/4f9e1ba80b10a61c02fdcd842117f0234f06b439/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/4f9e1ba80b10a61c02fdcd842117f0234f06b439/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=4f9e1ba80b10a61c02fdcd842117f0234f06b439", "patch": "@@ -74,9 +74,9 @@ Where:\n      Unicode codepoint `U+00QQ`.\n   - `IDENTIFIER` is a nonempty string of ASCII letters and underscores.\n   - The `repeat` forms apply to the adjacent `element`, and are as follows:\n-    - `'?'` means zero or one repetition\n-    - `'*'` means zero or more repetitions\n-    - `'+'` means one or more repetitions\n+    - `?` means zero or one repetition\n+    - `*` means zero or more repetitions\n+    - `+` means one or more repetitions\n     - NUMBER trailing a repeat symbol gives a maximum repetition count\n     - NUMBER on its own gives an exact repetition count\n \n@@ -107,7 +107,7 @@ the [token](#tokens) rule, and are assumed to be the result of a\n lexical-analysis phase feeding the parser, driven by a DFA, operating over the\n disjunction of all such string table entries.\n \n-When such a string enclosed in double-quotes (`'\"'`) occurs inside the\n+When such a string enclosed in double-quotes (`\"`) occurs inside the\n grammar, it is an implicit reference to a single member of such a string table\n production. See [tokens](#tokens) for more information.\n \n@@ -150,10 +150,10 @@ Some productions are defined by exclusion of particular Unicode characters:\n \n   - `non_null` is any single Unicode character aside from `U+0000` (null)\n   - `non_eol` is `non_null` restricted to exclude `U+000A` (`'\\n'`)\n-  - `non_star` is `non_null` restricted to exclude `U+002A` (`'*'`)\n-  - `non_slash` is `non_null` restricted to exclude `U+002F` (`'/'`)\n-  - `non_single_quote` is `non_null` restricted to exclude `U+0027`  (`'\\''`)\n-  - `non_double_quote` is `non_null` restricted to exclude `U+0022` (`'\\\"'`)\n+  - `non_star` is `non_null` restricted to exclude `U+002A` (`*`)\n+  - `non_slash` is `non_null` restricted to exclude `U+002F` (`/`)\n+  - `non_single_quote` is `non_null` restricted to exclude `U+0027`  (`'`)\n+  - `non_double_quote` is `non_null` restricted to exclude `U+0022` (`\"`)\n \n ## Comments\n \n@@ -165,7 +165,7 @@ line_comment : \"//\" non_eol * ;\n ~~~~~~~~\n \n Comments in Rust code follow the general C++ style of line and block-comment\n-forms, with proper nesting of block-comment delimeters. Comments are\n+forms, with proper nesting of block-comment delimiters. Comments are\n interpreted as a form of whitespace.\n \n ## Whitespace\n@@ -284,29 +284,29 @@ nonzero_dec: '1' | '2' | '3' | '4'\n \n A _character literal_ is a single Unicode character enclosed within two\n `U+0027` (single-quote) characters, with the exception of `U+0027` itself,\n-which must be _escaped_ by a preceding U+005C character (`'\\'`).\n+which must be _escaped_ by a preceding U+005C character (`\\`).\n \n A _string literal_ is a sequence of any Unicode characters enclosed within\n two `U+0022` (double-quote) characters, with the exception of `U+0022`\n-itself, which must be _escaped_ by a preceding `U+005C` character (`'\\'`).\n+itself, which must be _escaped_ by a preceding `U+005C` character (`\\`).\n \n Some additional _escapes_ are available in either character or string\n-literals. An escape starts with a `U+005C` (`'\\'`) and continues with one of\n+literals. An escape starts with a `U+005C` (`\\`) and continues with one of\n the following forms:\n \n-  * An _8-bit codepoint escape_ escape starts with `U+0078` (`'x'`) and is\n+  * An _8-bit codepoint escape_ escape starts with `U+0078` (`x`) and is\n     followed by exactly two _hex digits_. It denotes the Unicode codepoint\n     equal to the provided hex value.\n-  * A _16-bit codepoint escape_ starts with `U+0075` (`'u'`) and is followed\n+  * A _16-bit codepoint escape_ starts with `U+0075` (`u`) and is followed\n     by exactly four _hex digits_. It denotes the Unicode codepoint equal to\n     the provided hex value.\n-  * A _32-bit codepoint escape_ starts with `U+0055` (`'U'`) and is followed\n+  * A _32-bit codepoint escape_ starts with `U+0055` (`U`) and is followed\n     by exactly eight _hex digits_. It denotes the Unicode codepoint equal to\n     the provided hex value.\n-  * A _whitespace escape_ is one of the characters `U+006E` (`'n'`), `U+0072`\n-    (`'r'`), or `U+0074` (`'t'`), denoting the unicode values `U+000A` (LF),\n+  * A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072`\n+    (`r`), or `U+0074` (`t`), denoting the unicode values `U+000A` (LF),\n     `U+000D` (CR) or `U+0009` (HT) respectively.\n-  * The _backslash escape_ is the character U+005C (`'\\'`) which must be\n+  * The _backslash escape_ is the character U+005C (`\\`) which must be\n     escaped in order to denote *itself*.\n \n #### Number literals\n@@ -341,9 +341,9 @@ An _integer literal_ has one of three forms:\n   * A _decimal literal_ starts with a *decimal digit* and continues with any\n     mixture of *decimal digits* and _underscores_.\n   * A _hex literal_ starts with the character sequence `U+0030` `U+0078`\n-    (`\"0x\"`) and continues as any mixture hex digits and underscores.\n+    (`0x`) and continues as any mixture hex digits and underscores.\n   * A _binary literal_ starts with the character sequence `U+0030` `U+0062`\n-    (`\"0b\"`) and continues as any mixture binary digits and underscores.\n+    (`0b`) and continues as any mixture binary digits and underscores.\n \n By default, an integer literal is of type `int`. An integer literal may be\n followed (immediately, without any spaces) by an _integer suffix_, which\n@@ -372,7 +372,7 @@ Examples of integer literals of various forms:\n A _floating-point literal_ has one of two forms:\n \n * Two _decimal literals_ separated by a period\n-  character `U+002E` (`'.'`), with an optional _exponent_ trailing after the\n+  character `U+002E` (`.`), with an optional _exponent_ trailing after the\n   second decimal literal.\n * A single _decimal literal_ followed by an _exponent_.\n \n@@ -425,7 +425,7 @@ type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n ~~~~~~~~\n \n A _path_ is a sequence of one or more path components _logically_ separated by\n-a namespace qualifier (`\"::\"`). If a path consists of only one component, it\n+a namespace qualifier (`::`). If a path consists of only one component, it\n may refer to either an [item](#items) or a (variable)[#variables) in a local\n control scope. If a path has multiple components, it refers to an item.\n \n@@ -444,9 +444,9 @@ x::y::z;\n Path components are usually [identifiers](#identifiers), but the trailing\n component of a path may be an angle-bracket enclosed list of [type\n arguments](type-arguments). In [expression](#expressions) context, the type\n-argument list is given after a final (`\"::\"`) namespace qualifier in order to\n+argument list is given after a final (`::`) namespace qualifier in order to\n disambiguate it from a relational expression involving the less-than symbol\n-(`'<'`). In [type expression](#type-expressions) context, the final namespace\n+(`<`). In [type expression](#type-expressions) context, the final namespace\n qualifier is omitted.\n \n Two examples of paths with type arguments:\n@@ -471,7 +471,11 @@ is directed towards a single crate in source form, and if successful\n produces a single crate in binary form, either an executable or a library.\n \n A _crate_ is a unit of compilation and linking, as well as versioning,\n-distribution and runtime loading.\n+distribution and runtime loading. A crate contains a _tree_ of nested\n+[module](#modules) scopes. The top-level of this tree is a module that is\n+anonymous -- from the point of view of paths within the module -- and any item\n+within a crate has a canonical [module path](#paths) denoting its location\n+within the crate's module tree.\n \n Crates are provided to the Rust compiler through two kinds of file:\n \n@@ -494,8 +498,9 @@ from the source file name, with the `.rs` extension removed.\n ## Crate files\n \n ~~~~~~~~ {.ebnf .gram}\n-crate : [ attribute * directive ] * ;\n-directive : view_directive | dir_directive | source_directive ;\n+crate : attribute [ ';' | attribute* directive ] \n+      | directive ;\n+directive : view_item | dir_directive | source_directive ;\n ~~~~~~~~\n \n A crate file contains a crate definition, for which the production above\n@@ -505,17 +510,37 @@ analogous to an *assembly* in the ECMA-335 CLI model, a *library* in the\n SML/NJ Compilation Manager, a *unit* in the Owens and Flatt module system,\n or a *configuration* in Mesa.] A crate file describes:\n \n-* Metadata about the crate, such as author, name, version, and copyright.\n-* The source file and directory modules that make up the crate.\n-* Any external crates or native modules that the crate imports to its top level.\n-* The organization of the crate's internal namespace.\n-* The set of names exported from the crate.\n+* [Attributes](#attributes) about the crate, such as author, name, version,\n+  and copyright. These are used for linking, versioning and distributing\n+  crates.\n+* The source-file and directory modules that make up the crate.\n+* Any `use`, `import` or `export` [view items](#view-items) that apply to the\n+  anonymous module at the top-level of the crate's module tree.\n \n-### View directives\n+An example of a crate file:\n \n-A `view_directive` contains a single `view_item` and arranges the top-level\n-namespace of the crate, the same way a `view_item` would in a module. See\n-[view items](#view-items).\n+~~~~~~~~\n+// Linkage attributes\n+#[ link(name = \"projx\"\n+        vers = \"2.5\",\n+        uuid = \"9cccc5d5-aceb-4af5-8285-811211826b82\") ];\n+\n+// Additional metadata attributes\n+#[ desc = \"Project X\",\n+   license = \"BSD\" ];\n+   author = \"Jane Doe\" ];\n+\n+// Import a module.\n+use std (ver = \"1.0\");\n+\n+// Define some modules.\n+#[path = \"foo.rs\"]\n+mod foo;\n+mod bar {\n+    #[path =  \"quux.rs\"]\n+    mod quux;\n+}\n+~~~~~~~~\n \n ### Dir directives\n \n@@ -541,8 +566,78 @@ a referencing crate file, or by the filename of the source file itself.\n \n # Items and attributes\n \n+\n+### Attributes\n+\n+~~~~~~~~{.ebnf .gram}\n+attribute : '#' '[' attr_list ']' ;\n+attr_list : attr [ ',' attr_list ]*\n+attr : ident [ '=' literal\n+             | '(' attr_list ')' ] ? ;\n+~~~~~~~~\n+\n+Static entities in Rust -- crates, modules and items -- may have _attributes_\n+applied to them. ^[Attributes in Rust are modeled on Attributes in ECMA-335,\n+C#] An attribute is a general, free-form piece of metadata that is interpreted\n+according to name, convention, and language and compiler version.  Attributes\n+may appear as any of:\n+\n+* A single identifier, the attribute name\n+* An identifier followed by the equals sign '=' and a literal, providing a key/value pair\n+* An identifier followed by a parenthesized list of sub-attribute arguments\n+\n+Attributes are applied to an entity by placing them within a hash-list\n+(`#[...]`) as either a prefix to the entity or as a semicolon-delimited\n+declaration within the entity body.\n+\n+An example of attributes:\n+\n+~~~~~~~~\n+// A function marked as a unit test\n+#[test]\n+fn test_foo() {\n+  ...\n+}\n+\n+// General metadata applied to the enclosing module or crate.\n+#[license = \"BSD\"];\n+\n+// A conditionally-compiled module\n+#[cfg(target_os=\"linux\")]\n+mod bar {\n+  ...\n+}\n+\n+// A documentation attribute\n+#[doc = \"Add two numbers together.\"\n+fn add(x: int, y: int) { x + y }\n+~~~~~~~~\n+\n+In future versions of Rust, user-provided extensions to the compiler will be\n+able to interpret attributes. When this facility is provided, a distinction\n+will be made between language-reserved and user-available attributes.\n+\n+At present, only the Rust compiler interprets attributes, so all attribute\n+names are effectively reserved. Some significant attributes include:\n+\n+* The `doc` attribute, for documenting code where it's written.\n+* The `cfg` attribute, for conditional-compilation by build-configuration.\n+* The `link` attribute, for describing linkage metadata for a crate.\n+* The `test` attribute, for marking functions as unit tests.\n+\n+Other attributes may be added or removed during development of the language.\n+\n+\n # Statements and expressions\n \n+## Call expressions\n+\n+~~~~~~~~ {.abnf .gram}\n+expr_list : [ expr [ ',' expr ]* ] ? ;\n+paren_expr_list : '(' expr_list ')' ;\n+call_expr : expr paren_expr_list ;\n+~~~~~~~~\n+\n ## Operators\n \n ### Unary operators\n@@ -563,8 +658,248 @@ a referencing crate file, or by the filename of the source file itself.\n <- <-> = += -= *= /= %= &= |= ^= <<= >>= >>>=\n ~~~~~~~~\n \n+\n+## Syntax extensions\n+\n+~~~~~~~~ {.abnf .gram}\n+syntax_ext_expr : '#' ident paren_expr_list ? brace_match ? ;\n+~~~~~~~~\n+\n+Rust provides a notation for _syntax extension_. The notation for invoking\n+a syntax extension is a marked syntactic form that can appear as an expression\n+in the body of a Rust program.\n+\n+After parsing, a syntax-extension invocation is expanded into a Rust\n+expression. The name of the extension determines the translation performed. In\n+future versions of Rust, user-provided syntax extensions aside from macros\n+will be provided via external crates.\n+\n+At present, only a set of built-in syntax extensions, as well as macros\n+introduced inline in source code using the `macro` extension, may be used. The\n+current built-in syntax extensions are:\n+\n+\n+* `fmt` expands into code to produce a formatted string, similar to \n+      `printf` from C.\n+* `env` expands into a string literal containing the value of that\n+      environment variable at compile-time.\n+* `concat_idents` expands into an identifier which is the \n+      concatenation of its arguments.\n+* `ident_to_str` expands into a string literal containing the name of\n+      its argument (which must be a literal).\n+* `log_syntax` causes the compiler to pretty-print its arguments.\n+\n+\n+Finally, `macro` is used to define a new macro. A macro can abstract over\n+second-class Rust concepts that are present in syntax. The arguments to\n+`macro` are pairs (two-element vectors). The pairs consist of an invocation\n+and the syntax to expand into. An example:\n+\n+~~~~~~~~\n+#macro([#apply[fn, [args, ...]], fn(args, ...)]);\n+~~~~~~~~\n+\n+In this case, the invocation `#apply[sum, 5, 8, 6]` expands to\n+`sum(5,8,6)`. If `...` follows an expression (which need not be as\n+simple as a single identifier) in the input syntax, the matcher will expect an\n+arbitrary number of occurrences of the thing preceding it, and bind syntax to\n+the identifiers it contains. If it follows an expression in the output syntax,\n+it will transcribe that expression repeatedly, according to the identifiers\n+(bound to syntax) that it contains.\n+\n+The behaviour of `...` is known as Macro By Example. It allows you to\n+write a macro with arbitrary repetition by specifying only one case of that\n+repetition, and following it by `...`, both where the repeated input is\n+matched, and where the repeated output must be transcribed. A more\n+sophisticated example:\n+\n+\n+~~~~~~~~\n+#macro([#zip_literals[[x, ...], [y, ...]), [[x, y], ...]]);\n+#macro([#unzip_literals[[x, y], ...], [[x, ...], [y, ...]]]);\n+~~~~~~~~\n+\n+In this case, `#zip_literals[[1,2,3], [1,2,3]]` expands to\n+`[[1,1],[2,2],[3,3]]`, and `#unzip_literals[[1,1], [2,2], [3,3]]`\n+expands to `[[1,2,3],[1,2,3]]`.\n+\n+Macro expansion takes place outside-in: that is,\n+`#unzip_literals[#zip_literals[[1,2,3],[1,2,3]]]` will fail because\n+`unzip_literals` expects a list, not a macro invocation, as an argument.\n+\n+The macro system currently has some limitations. It's not possible to\n+destructure anything other than vector literals (therefore, the arguments to\n+complicated macros will tend to be an ocean of square brackets). Macro\n+invocations and `...` can only appear in expression positions. Finally,\n+macro expansion is currently unhygienic. That is, name collisions between\n+macro-generated and user-written code can cause unintentional capture.\n+\n+Future versions of Rust will address these issues.\n+\n # Memory and concurrency model\n \n+## Memory model\n+\n+A Rust task's memory consists of a static set of *items*, a set of tasks\n+each with its own *stack*, and a *heap*. Immutable portions of the\n+heap may be shared between tasks, mutable portions may not.\n+\n+Allocations in the stack consist of *slots*, and allocations in the heap\n+consist of *boxes*.\n+\n+\n+### Memory allocation and lifetime\n+\n+The _items_ of a program are those functions, objects, modules and types\n+that have their value calculated at compile-time and stored uniquely in the\n+memory image of the rust process. Items are neither dynamically allocated nor\n+freed.\n+\n+A task's _stack_ consists of activation frames automatically allocated on\n+entry to each function as the task executes. A stack allocation is reclaimed\n+when control leaves the frame containing it.\n+\n+The _heap_ is a general term that describes two separate sets of boxes:\n+shared boxes -- which may be subject to garbage collection -- and unique\n+boxes.  The lifetime of an allocation in the heap depends on the lifetime of\n+the box values pointing to it. Since box values may themselves be passed in\n+and out of frames, or stored in the heap, heap allocations may outlive the\n+frame they are allocated within.\n+\n+\n+### Memory ownership\n+\n+A task owns all memory it can *safely* reach through local variables,\n+shared or unique boxes, and/or references. Sharing memory between tasks can\n+only be accomplished using *unsafe* constructs, such as raw pointer\n+operations or calling C code.\n+\n+When a task sends a value of *unique* kind over a channel, it loses\n+ownership of the value sent and can no longer refer to it. This is statically\n+guaranteed by the combined use of \"move semantics\" and unique kinds, within\n+the communication system.\n+\n+When a stack frame is exited, its local allocations are all released, and its\n+references to boxes (both shared and owned) are dropped.\n+\n+A shared box may (in the case of a recursive, mutable shared type) be cyclic;\n+in this case the release of memory inside the shared structure may be deferred\n+until task-local garbage collection can reclaim it. Code can ensure no such\n+delayed deallocation occurs by restricting itself to unique boxes and similar\n+unshared kinds of data.\n+\n+When a task finishes, its stack is necessarily empty and it therefore has no\n+references to any boxes; the remainder of its heap is immediately freed.\n+\n+\n+### Memory slots\n+\n+A task's stack contains slots.\n+\n+A _slot_ is a component of a stack frame. A slot is either *local* or\n+a *reference*.\n+\n+A _local_ slot (or *stack-local* allocation) holds a value directly,\n+allocated within the stack's memory. The value is a part of the stack frame.\n+\n+A _reference_ references a value outside the frame. It may refer to a\n+value allocated in another frame *or* a boxed value in the heap. The\n+reference-formation rules ensure that the referent will outlive the reference.\n+\n+Local slots are always implicitly mutable.\n+\n+Local slots are not initialized when allocated; the entire frame worth of\n+local slots are allocated at once, on frame-entry, in an uninitialized\n+state. Subsequent statements within a function may or may not initialize the\n+local slots. Local slots can be used only after they have been initialized;\n+this condition is guaranteed by the typestate system.\n+\n+References are created for function arguments. If the compiler can not prove\n+that the referred-to value will outlive the reference, it will try to set\n+aside a copy of that value to refer to. If this is not semantically safe (for\n+example, if the referred-to value contains mutable fields), it will reject the\n+program. If the compiler deems copying the value expensive, it will warn.\n+\n+A function can be declared to take an argument by mutable reference. This\n+allows the function to write to the slot that the reference refers to.\n+\n+An example function that accepts an value by mutable reference:\n+\n+~~~~~~~~\n+fn incr(&i: int) {\n+    i = i + 1;\n+}\n+~~~~~~~~\n+\n+\n+### Memory boxes\n+\n+A _box_ is a reference to a heap allocation holding another value. There\n+are two kinds of boxes: *shared boxes* and *unique boxes*.\n+\n+A _shared box_ type or value is constructed by the prefix *at* sigil `@`.\n+\n+A _unique box_ type or value is constructed by the prefix *tilde* sigil `~`.\n+\n+Multiple shared box values can point to the same heap allocation; copying a\n+shared box value makes a shallow copy of the pointer (optionally incrementing\n+a reference count, if the shared box is implemented through\n+reference-counting).\n+\n+Unique box values exist in 1:1 correspondence with their heap allocation;\n+copying a unique box value makes a deep copy of the heap allocation and\n+produces a pointer to the new allocation.\n+\n+An example of constructing one shared box type and value, and one unique box\n+type and value:\n+\n+~~~~~~~~\n+let x: @int = @10;\n+let x: ~int = ~10;\n+~~~~~~~~\n+\n+Some operations implicitly dereference boxes. Examples of such @dfn{implicit\n+dereference} operations are:\n+\n+* arithmetic operators (`x + y - z`)\n+* field selection (`x.y.z`)\n+\n+\n+An example of an implicit-dereference operation performed on box values:\n+\n+~~~~~~~~\n+let x: @int = @10;\n+let y: @int = @12;\n+assert (x + y == 22);\n+~~~~~~~~\n+\n+Other operations act on box values as single-word-sized address values. For\n+these operations, to access the value held in the box requires an explicit\n+dereference of the box value. Explicitly dereferencing a box is indicated with\n+the unary *star* operator `*`. Examples of such @dfn{explicit\n+dereference} operations are:\n+\n+* copying box values (`x = y`)\n+* passing box values to functions (`f(x,y)`)\n+\n+\n+An example of an explicit-dereference operation performed on box values:\n+\n+~~~~~~~~\n+fn takes_boxed(b: @int) {\n+}\n+\n+fn takes_unboxed(b: int) {\n+}\n+\n+fn main() {\n+    let x: @int = @10;\n+    takes_boxed(x);\n+    takes_unboxed(*x);\n+}\n+~~~~~~~~\n+\n+\n # Runtime services, linkage and debugging\n \n # Appendix: Rationales and design tradeoffs\n@@ -643,3 +978,5 @@ Additional specific influences can be seen from the following languages:\n * The lexical identifier rule of Python.\n * The block syntax of Ruby.\n \n+\n+LocalWords:  codepoint"}, {"sha": "63e89563464f30d824671fd6c2e7da6f79d00512", "filename": "src/etc/extract_grammar.py", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f9e1ba80b10a61c02fdcd842117f0234f06b439/src%2Fetc%2Fextract_grammar.py", "raw_url": "https://github.com/rust-lang/rust/raw/4f9e1ba80b10a61c02fdcd842117f0234f06b439/src%2Fetc%2Fextract_grammar.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fextract_grammar.py?ref=4f9e1ba80b10a61c02fdcd842117f0234f06b439", "patch": "@@ -86,6 +86,10 @@\n \n \"::\": \"coloncolon\",\n \n+\"->\": \"rightarrow\",\n+\"<-\": \"leftarrow\",\n+\"<->\": \"swaparrow\",\n+\n \"//\": \"linecomment\",\n \"/*\": \"openblockcomment\",\n \"*/\": \"closeblockcomment\""}]}