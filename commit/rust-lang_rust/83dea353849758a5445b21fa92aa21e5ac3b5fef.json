{"sha": "83dea353849758a5445b21fa92aa21e5ac3b5fef", "node_id": "C_kwDOAAsO6NoAKDgzZGVhMzUzODQ5NzU4YTU0NDViMjFmYTkyYWEyMWU1YWMzYjVmZWY", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-07-04T08:23:24Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-07-06T10:09:47Z"}, "message": "replace `guess_head_span` with `def_span`", "tree": {"sha": "1ab1a6f3445f8b22e441bf34532cca7473238b43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ab1a6f3445f8b22e441bf34532cca7473238b43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83dea353849758a5445b21fa92aa21e5ac3b5fef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83dea353849758a5445b21fa92aa21e5ac3b5fef", "html_url": "https://github.com/rust-lang/rust/commit/83dea353849758a5445b21fa92aa21e5ac3b5fef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83dea353849758a5445b21fa92aa21e5ac3b5fef/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b8cf49c51833ee5d27ae2e8e179337dbb9f14d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b8cf49c51833ee5d27ae2e8e179337dbb9f14d7", "html_url": "https://github.com/rust-lang/rust/commit/5b8cf49c51833ee5d27ae2e8e179337dbb9f14d7"}], "stats": {"total": 288, "additions": 111, "deletions": 177}, "files": [{"sha": "6fea6941085ce1daa457cdc9ed8e976338855b64", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -812,12 +812,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             return FnSelfUse {\n                 var_span: stmt.source_info.span,\n                 fn_call_span: *fn_span,\n-                fn_span: self\n-                    .infcx\n-                    .tcx\n-                    .sess\n-                    .source_map()\n-                    .guess_head_span(self.infcx.tcx.def_span(method_did)),\n+                fn_span: self.infcx.tcx.def_span(method_did),\n                 kind,\n             };\n         }"}, {"sha": "9574661282ba1b2bb5a9f57dd4ff351ab416559a", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -155,8 +155,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                     });\n \n                     if let Ok(Some(ImplSource::UserDefined(data))) = implsrc {\n-                        let span =\n-                            tcx.sess.source_map().guess_head_span(tcx.def_span(data.impl_def_id));\n+                        let span = tcx.def_span(data.impl_def_id);\n                         err.span_note(span, \"impl defined here, but it is not `const`\");\n                     }\n                 }\n@@ -205,7 +204,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n \n                 match self_ty.kind() {\n                     FnDef(def_id, ..) => {\n-                        let span = tcx.sess.source_map().guess_head_span(tcx.def_span(*def_id));\n+                        let span = tcx.def_span(*def_id);\n                         if ccx.tcx.is_const_fn_raw(*def_id) {\n                             span_bug!(span, \"calling const FnDef errored when it shouldn't\");\n                         }"}, {"sha": "05556f7d0f9564740dd498a3ff1bc014e2623e11", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -148,12 +148,10 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     region: ty::Region<'tcx>,\n ) -> (String, Span) {\n-    let sm = tcx.sess.source_map();\n-\n     let scope = region.free_region_binding_scope(tcx).expect_local();\n     match *region {\n         ty::ReEarlyBound(ref br) => {\n-            let mut sp = sm.guess_head_span(tcx.def_span(scope));\n+            let mut sp = tcx.def_span(scope);\n             if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n             {\n@@ -174,7 +172,7 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n             } else {\n                 match fr.bound_region {\n                     ty::BoundRegionKind::BrNamed(_, name) => {\n-                        let mut sp = sm.guess_head_span(tcx.def_span(scope));\n+                        let mut sp = tcx.def_span(scope);\n                         if let Some(param) =\n                             tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n                         {\n@@ -193,7 +191,7 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n                     ),\n                     _ => (\n                         format!(\"the lifetime `{}` as defined here\", region),\n-                        sm.guess_head_span(tcx.def_span(scope)),\n+                        tcx.def_span(scope),\n                     ),\n                 }\n             }"}, {"sha": "7e42458fda3d00f79fd23bf4e6b9e598e99aaf29", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -23,10 +23,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n \n-        if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n-            let span = self.tcx.sess.source_map().guess_head_span(trait_item_span);\n+        if trait_item_def_id.is_local() {\n             let item_name = self.tcx.item_name(impl_item_def_id.to_def_id());\n-            err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n+            err.span_label(\n+                self.tcx.def_span(trait_item_def_id),\n+                format!(\"definition of `{}` from trait\", item_name),\n+            );\n         }\n \n         err.span_label(sp, format!(\"impl has extra requirement {}\", requirement));"}, {"sha": "de25baf5b14b288ac2edac7868a773dee6262bba", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -551,7 +551,6 @@ impl MissingDoc {\n         &self,\n         cx: &LateContext<'_>,\n         def_id: LocalDefId,\n-        sp: Span,\n         article: &'static str,\n         desc: &'static str,\n     ) {\n@@ -610,13 +609,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        self.check_missing_docs_attrs(\n-            cx,\n-            CRATE_DEF_ID,\n-            cx.tcx.def_span(CRATE_DEF_ID),\n-            \"the\",\n-            \"crate\",\n-        );\n+        self.check_missing_docs_attrs(cx, CRATE_DEF_ID, \"the\", \"crate\");\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n@@ -646,13 +639,13 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n         let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, it.def_id, it.span, article, desc);\n+        self.check_missing_docs_attrs(cx, it.def_id, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, trait_item: &hir::TraitItem<'_>) {\n         let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, trait_item.def_id, trait_item.span, article, desc);\n+        self.check_missing_docs_attrs(cx, trait_item.def_id, article, desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n@@ -680,23 +673,23 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n         }\n \n         let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(cx, impl_item.def_id, impl_item.span, article, desc);\n+        self.check_missing_docs_attrs(cx, impl_item.def_id, article, desc);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'_>) {\n         let (article, desc) = cx.tcx.article_and_description(foreign_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(cx, foreign_item.def_id, foreign_item.span, article, desc);\n+        self.check_missing_docs_attrs(cx, foreign_item.def_id, article, desc);\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, sf: &hir::FieldDef<'_>) {\n         if !sf.is_positional() {\n             let def_id = cx.tcx.hir().local_def_id(sf.hir_id);\n-            self.check_missing_docs_attrs(cx, def_id, sf.span, \"a\", \"struct field\")\n+            self.check_missing_docs_attrs(cx, def_id, \"a\", \"struct field\")\n         }\n     }\n \n     fn check_variant(&mut self, cx: &LateContext<'_>, v: &hir::Variant<'_>) {\n-        self.check_missing_docs_attrs(cx, cx.tcx.hir().local_def_id(v.id), v.span, \"a\", \"variant\");\n+        self.check_missing_docs_attrs(cx, cx.tcx.hir().local_def_id(v.id), \"a\", \"variant\");\n     }\n }\n "}, {"sha": "49a518b101dd156415c9a559624c41d15b767d25", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -795,7 +795,7 @@ fn foo(&self) -> Self::T { String::new() }\n                         if item_def_id == proj_ty_item_def_id =>\n                     {\n                         Some((\n-                            self.sess.source_map().guess_head_span(self.def_span(item.def_id)),\n+                            self.def_span(item.def_id),\n                             format!(\"consider calling `{}`\", self.def_path_str(item.def_id)),\n                         ))\n                     }"}, {"sha": "8efefd476abc9b661a622533514e5f18b4663309", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -1112,18 +1112,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     })\n                     .collect::<Option<Vec<ArgKind>>>()?,\n             ),\n-            Node::Item(&hir::Item { span, kind: hir::ItemKind::Fn(ref sig, ..), .. })\n-            | Node::ImplItem(&hir::ImplItem {\n-                span,\n-                kind: hir::ImplItemKind::Fn(ref sig, _),\n-                ..\n-            })\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref sig, ..), .. })\n+            | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(ref sig, _), .. })\n             | Node::TraitItem(&hir::TraitItem {\n-                span,\n-                kind: hir::TraitItemKind::Fn(ref sig, _),\n-                ..\n+                kind: hir::TraitItemKind::Fn(ref sig, _), ..\n             }) => (\n-                sm.guess_head_span(span),\n+                sig.span,\n                 sig.decl\n                     .inputs\n                     .iter()\n@@ -1138,7 +1132,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ),\n             Node::Ctor(ref variant_data) => {\n                 let span = variant_data.ctor_hir_id().map_or(DUMMY_SP, |id| hir.span(id));\n-                let span = sm.guess_head_span(span);\n                 (span, vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n@@ -2185,7 +2178,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         let mut post = vec![];\n         for def_id in impls {\n             match self.tcx.span_of_impl(*def_id) {\n-                Ok(span) => spans.push(self.tcx.sess.source_map().guess_head_span(span)),\n+                Ok(span) => spans.push(span),\n                 Err(name) => {\n                     crates.push(name);\n                     if let Some(header) = to_pretty_impl_header(self.tcx, *def_id) {\n@@ -2532,8 +2525,7 @@ pub fn recursive_type_with_infinite_size_error<'tcx>(\n     spans: Vec<(Span, Option<hir::HirId>)>,\n ) {\n     assert!(type_def_id.is_local());\n-    let span = tcx.hir().span_if_local(type_def_id).unwrap();\n-    let span = tcx.sess.source_map().guess_head_span(span);\n+    let span = tcx.def_span(type_def_id);\n     let path = tcx.def_path_str(type_def_id);\n     let mut err =\n         struct_span_err!(tcx.sess, span, E0072, \"recursive type `{}` has infinite size\", path);"}, {"sha": "ff24ea63c0b72b07d9f739eeabde46039f377e12", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -341,10 +341,7 @@ fn report_negative_positive_conflict(\n     positive_impl_def_id: DefId,\n     sg: &mut specialization_graph::Graph,\n ) {\n-    let impl_span = tcx\n-        .sess\n-        .source_map()\n-        .guess_head_span(tcx.span_of_impl(local_impl_def_id.to_def_id()).unwrap());\n+    let impl_span = tcx.span_of_impl(local_impl_def_id.to_def_id()).unwrap();\n \n     let mut err = struct_span_err!(\n         tcx.sess,\n@@ -357,10 +354,7 @@ fn report_negative_positive_conflict(\n \n     match tcx.span_of_impl(negative_impl_def_id) {\n         Ok(span) => {\n-            err.span_label(\n-                tcx.sess.source_map().guess_head_span(span),\n-                \"negative implementation here\".to_string(),\n-            );\n+            err.span_label(span, \"negative implementation here\");\n         }\n         Err(cname) => {\n             err.note(&format!(\"negative implementation in crate `{}`\", cname));\n@@ -369,10 +363,7 @@ fn report_negative_positive_conflict(\n \n     match tcx.span_of_impl(positive_impl_def_id) {\n         Ok(span) => {\n-            err.span_label(\n-                tcx.sess.source_map().guess_head_span(span),\n-                \"positive implementation here\".to_string(),\n-            );\n+            err.span_label(span, \"positive implementation here\");\n         }\n         Err(cname) => {\n             err.note(&format!(\"positive implementation in crate `{}`\", cname));\n@@ -389,8 +380,7 @@ fn report_conflicting_impls(\n     used_to_be_allowed: Option<FutureCompatOverlapErrorKind>,\n     sg: &mut specialization_graph::Graph,\n ) {\n-    let impl_span =\n-        tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id.to_def_id()).unwrap());\n+    let impl_span = tcx.def_span(impl_def_id);\n \n     // Work to be done after we've built the DiagnosticBuilder. We have to define it\n     // now because the struct_lint methods don't return back the DiagnosticBuilder\n@@ -417,10 +407,7 @@ fn report_conflicting_impls(\n         let mut err = err.build(&msg);\n         match tcx.span_of_impl(overlap.with_impl) {\n             Ok(span) => {\n-                err.span_label(\n-                    tcx.sess.source_map().guess_head_span(span),\n-                    \"first implementation here\".to_string(),\n-                );\n+                err.span_label(span, \"first implementation here\".to_string());\n \n                 err.span_label(\n                     impl_span,"}, {"sha": "0a2b54eec47cd00c705972b2352230146d06994c", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -1958,9 +1958,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         );\n                     }\n \n-                    if let Some(sp) = tcx.hir().span_if_local(adt_def.did()) {\n-                        let sp = tcx.sess.source_map().guess_head_span(sp);\n-                        err.span_label(sp, format!(\"variant `{}` not found here\", assoc_ident));\n+                    if adt_def.did().is_local() {\n+                        err.span_label(\n+                            tcx.def_span(adt_def.did()),\n+                            format!(\"variant `{assoc_ident}` not found for this enum\"),\n+                        );\n                     }\n \n                     err.emit()\n@@ -2450,7 +2452,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                     let msg = format!(\"`Self` is of type `{ty}`\");\n                     if let (Ok(i_sp), Some(t_sp)) = (span_of_impl, span_of_ty) {\n-                        let i_sp = tcx.sess.source_map().guess_head_span(i_sp);\n                         let mut span: MultiSpan = vec![t_sp].into();\n                         span.push_span_label(\n                             i_sp,"}, {"sha": "e9709b64d930e15d0d488764f5ee98fd8de50fdb", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -288,11 +288,9 @@ fn check_panic_info_fn(\n         tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n     }\n \n-    let span = tcx.def_span(fn_id);\n     let inputs = fn_sig.inputs();\n     if inputs.len() != 1 {\n-        let span = tcx.sess.source_map().guess_head_span(span);\n-        tcx.sess.span_err(span, \"function should have one argument\");\n+        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n         return;\n     }\n \n@@ -345,9 +343,7 @@ fn check_alloc_error_fn(\n \n     let inputs = fn_sig.inputs();\n     if inputs.len() != 1 {\n-        let span = tcx.def_span(fn_id);\n-        let span = tcx.sess.source_map().guess_head_span(span);\n-        tcx.sess.span_err(span, \"function should have one argument\");\n+        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n         return;\n     }\n \n@@ -1034,7 +1030,6 @@ fn check_impl_items_against_trait<'tcx>(\n                 compare_impl_method(\n                     tcx,\n                     &ty_impl_item,\n-                    impl_item.span,\n                     &ty_trait_item,\n                     impl_trait_ref,\n                     opt_trait_span,\n@@ -1094,17 +1089,20 @@ fn check_impl_items_against_trait<'tcx>(\n         }\n \n         if !missing_items.is_empty() {\n-            let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n-            missing_items_err(tcx, impl_span, &missing_items, full_impl_span);\n+            missing_items_err(tcx, tcx.def_span(impl_id), &missing_items, full_impl_span);\n         }\n \n         if let Some(missing_items) = must_implement_one_of {\n-            let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n             let attr_span = tcx\n                 .get_attr(impl_trait_ref.def_id, sym::rustc_must_implement_one_of)\n                 .map(|attr| attr.span);\n \n-            missing_items_must_implement_one_of_err(tcx, impl_span, missing_items, attr_span);\n+            missing_items_must_implement_one_of_err(\n+                tcx,\n+                tcx.def_span(impl_id),\n+                missing_items,\n+                attr_span,\n+            );\n         }\n     }\n }"}, {"sha": "2bfb9343877a45fc4ee50736bea213c5eaf19d16", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -33,14 +33,13 @@ use super::{potentially_plural_count, FnCtxt, Inherited};\n pub(crate) fn compare_impl_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     trait_item_span: Option<Span>,\n ) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    let impl_m_span = tcx.sess.source_map().guess_head_span(impl_m_span);\n+    let impl_m_span = tcx.def_span(impl_m.def_id);\n \n     if let Err(_) = compare_self_type(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref) {\n         return;\n@@ -444,13 +443,9 @@ fn check_region_bounds_on_impl_item<'tcx>(\n             .as_local()\n             .and_then(|did| tcx.hir().get_generics(did))\n             .map_or(def_span, |g| g.span);\n-        let generics_span = tcx.hir().span_if_local(trait_m.def_id).map(|sp| {\n-            let def_sp = tcx.sess.source_map().guess_head_span(sp);\n-            trait_m\n-                .def_id\n-                .as_local()\n-                .and_then(|did| tcx.hir().get_generics(did))\n-                .map_or(def_sp, |g| g.span)\n+        let generics_span = trait_m.def_id.as_local().map(|did| {\n+            let def_sp = tcx.def_span(did);\n+            tcx.hir().get_generics(did).map_or(def_sp, |g| g.span)\n         });\n \n         let reported = tcx.sess.emit_err(LifetimesOrBoundsMismatchOnTrait {\n@@ -1044,8 +1039,7 @@ fn compare_generic_param_kinds<'tcx>(\n             err.span_label(trait_header_span, \"\");\n             err.span_label(param_trait_span, make_param_message(\"expected\", param_trait));\n \n-            let impl_header_span =\n-                tcx.sess.source_map().guess_head_span(tcx.def_span(tcx.parent(impl_item.def_id)));\n+            let impl_header_span = tcx.def_span(tcx.parent(impl_item.def_id));\n             err.span_label(impl_header_span, \"\");\n             err.span_label(param_impl_span, make_param_message(\"found\", param_impl));\n "}, {"sha": "edb0ec027a0facb45bfbd91a38ba826ca76f6340", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -184,9 +184,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else if let (ty::FnDef(def_id, ..), true) =\n             (&found.kind(), self.suggest_fn_call(err, expr, expected, found))\n         {\n-            if let Some(sp) = self.tcx.hir().span_if_local(*def_id) {\n-                let sp = self.sess().source_map().guess_head_span(sp);\n-                err.span_label(sp, &format!(\"{} defined here\", found));\n+            if def_id.is_local() {\n+                err.span_label(self.tcx.def_span(def_id), &format!(\"{} defined here\", found));\n             }\n         } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n             let is_struct_pat_shorthand_field ="}, {"sha": "4e1a105fc71cc0a308e91f07f3e84eac146e2532", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -121,11 +121,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }) else {\n                             continue;\n                         };\n-                        let note_span = self\n-                            .tcx\n-                            .hir()\n-                            .span_if_local(item.def_id)\n-                            .or_else(|| self.tcx.hir().span_if_local(impl_did));\n+\n+                        let note_span = if item.def_id.is_local() {\n+                            Some(self.tcx.def_span(item.def_id))\n+                        } else if impl_did.is_local() {\n+                            Some(self.tcx.def_span(impl_did))\n+                        } else {\n+                            None\n+                        };\n \n                         let impl_ty = self.tcx.at(span).type_of(impl_did);\n \n@@ -158,10 +161,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         };\n                         if let Some(note_span) = note_span {\n                             // We have a span pointing to the method. Show note with snippet.\n-                            err.span_note(\n-                                self.tcx.sess.source_map().guess_head_span(note_span),\n-                                &note_str,\n-                            );\n+                            err.span_note(note_span, &note_str);\n                         } else {\n                             err.note(&note_str);\n                         }\n@@ -197,11 +197,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     CandidateSource::Trait(trait_did) => {\n                         let Some(item) = self.associated_value(trait_did, item_name) else { continue };\n-                        let item_span = self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .guess_head_span(self.tcx.def_span(item.def_id));\n+                        let item_span = self.tcx.def_span(item.def_id);\n                         let idx = if sources.len() > 1 {\n                             let msg = &format!(\n                                 \"candidate #{} is defined in the trait `{}`\",\n@@ -471,9 +467,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         err.note(&format!(\"`count` is defined on `{iterator_trait}`, which `{actual}` does not implement\"));\n                     }\n                 } else if !unsatisfied_predicates.is_empty() {\n-                    let def_span = |def_id| {\n-                        self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id))\n-                    };\n                     let mut type_params = FxHashMap::default();\n \n                     // Pick out the list of unimplemented traits on the receiver.\n@@ -564,22 +557,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         );\n                         match &self_ty.kind() {\n                             // Point at the type that couldn't satisfy the bound.\n-                            ty::Adt(def, _) => bound_spans.push((def_span(def.did()), msg)),\n+                            ty::Adt(def, _) => {\n+                                bound_spans.push((self.tcx.def_span(def.did()), msg))\n+                            }\n                             // Point at the trait object that couldn't satisfy the bound.\n                             ty::Dynamic(preds, _) => {\n                                 for pred in preds.iter() {\n                                     match pred.skip_binder() {\n-                                        ty::ExistentialPredicate::Trait(tr) => {\n-                                            bound_spans.push((def_span(tr.def_id), msg.clone()))\n-                                        }\n+                                        ty::ExistentialPredicate::Trait(tr) => bound_spans\n+                                            .push((self.tcx.def_span(tr.def_id), msg.clone())),\n                                         ty::ExistentialPredicate::Projection(_)\n                                         | ty::ExistentialPredicate::AutoTrait(_) => {}\n                                     }\n                                 }\n                             }\n                             // Point at the closure that couldn't satisfy the bound.\n-                            ty::Closure(def_id, _) => bound_spans\n-                                .push((def_span(*def_id), format!(\"doesn't satisfy `{}`\", quiet))),\n+                            ty::Closure(def_id, _) => bound_spans.push((\n+                                tcx.def_span(*def_id),\n+                                format!(\"doesn't satisfy `{}`\", quiet),\n+                            )),\n                             _ => {}\n                         }\n                     };\n@@ -1469,21 +1465,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => None,\n             })\n             .collect::<FxHashSet<_>>();\n-        let sm = self.tcx.sess.source_map();\n         let mut spans: MultiSpan = def_ids\n             .iter()\n             .filter_map(|def_id| {\n                 let span = self.tcx.def_span(*def_id);\n-                if span.is_dummy() { None } else { Some(sm.guess_head_span(span)) }\n+                if span.is_dummy() { None } else { Some(span) }\n             })\n             .collect::<Vec<_>>()\n             .into();\n \n         for pred in &preds {\n             match pred.self_ty().kind() {\n-                ty::Adt(def, _) => {\n+                ty::Adt(def, _) if def.did().is_local() => {\n                     spans.push_span_label(\n-                        sm.guess_head_span(self.tcx.def_span(def.did())),\n+                        self.tcx.def_span(def.did()),\n                         format!(\"must implement `{}`\", pred.trait_ref.print_only_trait_path()),\n                     );\n                 }\n@@ -2090,9 +2085,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match &potential_candidates[..] {\n                 [] => {}\n                 [trait_info] if trait_info.def_id.is_local() => {\n-                    let span = self.tcx.hir().span_if_local(trait_info.def_id).unwrap();\n                     err.span_note(\n-                        self.tcx.sess.source_map().guess_head_span(span),\n+                        self.tcx.def_span(trait_info.def_id),\n                         &format!(\n                             \"`{}` defines an item `{}`, perhaps you need to {} it\",\n                             self.tcx.def_path_str(trait_info.def_id),"}, {"sha": "ae9ebe590914455b372b8326b43aaa4b3f414153", "filename": "compiler/rustc_typeck/src/coherence/mod.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -9,7 +9,6 @@ use rustc_errors::struct_span_err;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n-use rustc_span::Span;\n use rustc_trait_selection::traits;\n \n mod builtin;\n@@ -18,11 +17,6 @@ mod inherent_impls_overlap;\n mod orphan;\n mod unsafety;\n \n-/// Obtains the span of just the impl header of `impl_def_id`.\n-fn impl_header_span(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) -> Span {\n-    tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id.to_def_id()).unwrap())\n-}\n-\n fn check_impl(tcx: TyCtxt<'_>, impl_def_id: LocalDefId, trait_ref: ty::TraitRef<'_>) {\n     debug!(\n         \"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n@@ -47,56 +41,53 @@ fn enforce_trait_manually_implementable(\n ) {\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n+    let impl_header_span = tcx.def_span(impl_def_id);\n \n     // Disallow *all* explicit impls of `Pointee`, `DiscriminantKind`, `Sized` and `Unsize` for now.\n     if did == li.pointee_trait() {\n-        let span = impl_header_span(tcx, impl_def_id);\n         struct_span_err!(\n             tcx.sess,\n-            span,\n+            impl_header_span,\n             E0322,\n             \"explicit impls for the `Pointee` trait are not permitted\"\n         )\n-        .span_label(span, \"impl of `Pointee` not allowed\")\n+        .span_label(impl_header_span, \"impl of `Pointee` not allowed\")\n         .emit();\n         return;\n     }\n \n     if did == li.discriminant_kind_trait() {\n-        let span = impl_header_span(tcx, impl_def_id);\n         struct_span_err!(\n             tcx.sess,\n-            span,\n+            impl_header_span,\n             E0322,\n             \"explicit impls for the `DiscriminantKind` trait are not permitted\"\n         )\n-        .span_label(span, \"impl of `DiscriminantKind` not allowed\")\n+        .span_label(impl_header_span, \"impl of `DiscriminantKind` not allowed\")\n         .emit();\n         return;\n     }\n \n     if did == li.sized_trait() {\n-        let span = impl_header_span(tcx, impl_def_id);\n         struct_span_err!(\n             tcx.sess,\n-            span,\n+            impl_header_span,\n             E0322,\n             \"explicit impls for the `Sized` trait are not permitted\"\n         )\n-        .span_label(span, \"impl of `Sized` not allowed\")\n+        .span_label(impl_header_span, \"impl of `Sized` not allowed\")\n         .emit();\n         return;\n     }\n \n     if did == li.unsize_trait() {\n-        let span = impl_header_span(tcx, impl_def_id);\n         struct_span_err!(\n             tcx.sess,\n-            span,\n+            impl_header_span,\n             E0328,\n             \"explicit impls for the `Unsize` trait are not permitted\"\n         )\n-        .span_label(span, \"impl of `Unsize` not allowed\")\n+        .span_label(impl_header_span, \"impl of `Unsize` not allowed\")\n         .emit();\n         return;\n     }\n@@ -110,10 +101,9 @@ fn enforce_trait_manually_implementable(\n         tcx.trait_def(trait_def_id).specialization_kind\n     {\n         if !tcx.features().specialization && !tcx.features().min_specialization {\n-            let span = impl_header_span(tcx, impl_def_id);\n             tcx.sess\n                 .struct_span_err(\n-                    span,\n+                    impl_header_span,\n                     \"implementing `rustc_specialization_trait` traits is unstable\",\n                 )\n                 .help(\"add `#![feature(min_specialization)]` to the crate attributes to enable\")\n@@ -138,8 +128,13 @@ fn enforce_empty_impls_for_marker_traits(\n         return;\n     }\n \n-    let span = impl_header_span(tcx, impl_def_id);\n-    struct_span_err!(tcx.sess, span, E0715, \"impls for marker traits cannot contain items\").emit();\n+    struct_span_err!(\n+        tcx.sess,\n+        tcx.def_span(impl_def_id),\n+        E0715,\n+        \"impls for marker traits cannot contain items\"\n+    )\n+    .emit();\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -217,7 +212,7 @@ fn check_object_overlap<'tcx>(\n             } else {\n                 let mut supertrait_def_ids = traits::supertrait_def_ids(tcx, component_def_id);\n                 if supertrait_def_ids.any(|d| d == trait_def_id) {\n-                    let span = impl_header_span(tcx, impl_def_id);\n+                    let span = tcx.def_span(impl_def_id);\n                     struct_span_err!(\n                         tcx.sess,\n                         span,"}, {"sha": "697ef7bc022370bec4590c4172af3bd971d797d5", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -47,7 +47,7 @@ fn do_orphan_check_impl<'tcx>(\n     let hir::ItemKind::Impl(ref impl_) = item.kind else {\n         bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n     };\n-    let sp = tcx.sess.source_map().guess_head_span(item.span);\n+    let sp = tcx.def_span(def_id);\n     let tr = impl_.of_trait.as_ref().unwrap();\n \n     // Ensure no opaque types are present in this impl header. See issues #76202 and #86411 for examples,"}, {"sha": "08c194ec0b605f1a8e24933474f1300d49e573c0", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -223,15 +223,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         if !def_id.is_local() {\n             return None;\n         }\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-        match tcx.hir().find(hir_id) {\n-            Some(Node::Item(hir::Item { span: item_span, .. })) => {\n-                Some(tcx.sess.source_map().guess_head_span(*item_span))\n-            }\n-            _ => {\n-                span_bug!(tcx.def_span(def_id), \"main has a non-function type\");\n-            }\n-        }\n+        Some(tcx.def_span(def_id))\n     }\n \n     fn main_fn_return_type_span(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Span> {\n@@ -416,7 +408,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                         error = true;\n                     }\n                     if let hir::IsAsync::Async = sig.header.asyncness {\n-                        let span = tcx.sess.source_map().guess_head_span(it.span);\n+                        let span = tcx.def_span(it.def_id);\n                         struct_span_err!(\n                             tcx.sess,\n                             span,"}, {"sha": "5025b0b0ca82562f9f9f55b534722eb0590a44a0", "filename": "src/test/rustdoc-ui/deny-missing-docs-crate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.stderr?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -16,7 +16,7 @@ error: missing documentation for a struct\n   --> $DIR/deny-missing-docs-crate.rs:3:1\n    |\n LL | pub struct Foo;\n-   | ^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8de0edef076c62f939cb238fb116b6a0c21f58b0", "filename": "src/test/ui/issues/issue-34209.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Fissues%2Fissue-34209.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Fissues%2Fissue-34209.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34209.stderr?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -2,7 +2,7 @@ error[E0599]: no variant named `B` found for enum `S`\n   --> $DIR/issue-34209.rs:7:12\n    |\n LL | enum S {\n-   | ------ variant `B` not found here\n+   | ------ variant `B` not found for this enum\n ...\n LL |         S::B {} => {},\n    |            ^ help: there is a variant with a similar name: `A`"}, {"sha": "e83590a8f59749e6f4853938f242ffb78a8158e9", "filename": "src/test/ui/issues/issue-37884.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Fissues%2Fissue-37884.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Fissues%2Fissue-37884.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37884.stderr?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -1,13 +1,8 @@\n error[E0308]: method not compatible with trait\n   --> $DIR/issue-37884.rs:6:5\n    |\n-LL | /     fn next(&'a mut self) -> Option<Self::Item>\n-LL | |\n-LL | |\n-LL | |     {\n-LL | |         Some(&mut self.0)\n-LL | |     }\n-   | |_____^ lifetime mismatch\n+LL |     fn next(&'a mut self) -> Option<Self::Item>\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n    |\n    = note: expected fn pointer `fn(&mut RepeatMut<'a, T>) -> Option<_>`\n               found fn pointer `fn(&'a mut RepeatMut<'a, T>) -> Option<_>`"}, {"sha": "b4c877a2d74a45d32f9a7471596d981b5d0da2c8", "filename": "src/test/ui/issues/issue-77919.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Fissues%2Fissue-77919.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Fissues%2Fissue-77919.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-77919.stderr?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -24,7 +24,7 @@ LL |     const VAL: T;\n    |     ------------ `VAL` from trait\n ...\n LL | impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `VAL` in implementation\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `VAL` in implementation\n \n error: constant expression depends on a generic parameter\n   --> $DIR/issue-77919.rs:2:9"}, {"sha": "d68472d4b660254987d03a7cd535b0280af9e0e2", "filename": "src/test/ui/lint/lint-missing-doc.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.stderr?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -2,7 +2,7 @@ error: missing documentation for a type alias\n   --> $DIR/lint-missing-doc.rs:11:1\n    |\n LL | pub type PubTypedef = String;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/lint-missing-doc.rs:3:9\n@@ -56,13 +56,13 @@ error: missing documentation for an associated type\n   --> $DIR/lint-missing-doc.rs:64:5\n    |\n LL |     type AssociatedType;\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for an associated type\n   --> $DIR/lint-missing-doc.rs:65:5\n    |\n LL |     type AssociatedTypeDef = Self;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for an associated function\n   --> $DIR/lint-missing-doc.rs:81:5\n@@ -92,13 +92,13 @@ error: missing documentation for a constant\n   --> $DIR/lint-missing-doc.rs:151:1\n    |\n LL | pub const FOO4: u32 = 0;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a static\n   --> $DIR/lint-missing-doc.rs:161:1\n    |\n LL | pub static BAR4: u32 = 0;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n   --> $DIR/lint-missing-doc.rs:167:5\n@@ -122,19 +122,19 @@ error: missing documentation for a function\n   --> $DIR/lint-missing-doc.rs:189:5\n    |\n LL |     pub fn extern_fn_undocumented(f: f32) -> f32;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a static\n   --> $DIR/lint-missing-doc.rs:194:5\n    |\n LL |     pub static EXTERN_STATIC_UNDOCUMENTED: u8;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a foreign type\n   --> $DIR/lint-missing-doc.rs:199:5\n    |\n LL |     pub type ExternTyUndocumented;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 22 previous errors\n "}, {"sha": "0b4ccdd5a56d4939ce553c2bc25bd6f717558479", "filename": "src/test/ui/suggestions/parenthesized-deref-suggestion.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Fsuggestions%2Fparenthesized-deref-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Fsuggestions%2Fparenthesized-deref-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fparenthesized-deref-suggestion.rs?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "previous_filename": "src/test/ui/parenthesized-deref-suggestion.rs"}, {"sha": "cafddbe2624240dbd9276df2e181b4f7f55da156", "filename": "src/test/ui/suggestions/parenthesized-deref-suggestion.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Fsuggestions%2Fparenthesized-deref-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Fsuggestions%2Fparenthesized-deref-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fparenthesized-deref-suggestion.stderr?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "previous_filename": "src/test/ui/parenthesized-deref-suggestion.stderr"}, {"sha": "1a5833f6429ccbf0defe9bb8616c65686a714eac", "filename": "src/test/ui/suggestions/suggest-variants.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83dea353849758a5445b21fa92aa21e5ac3b5fef/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-variants.stderr?ref=83dea353849758a5445b21fa92aa21e5ac3b5fef", "patch": "@@ -2,7 +2,7 @@ error[E0599]: no variant named `Squareee` found for enum `Shape`\n   --> $DIR/suggest-variants.rs:12:41\n    |\n LL | enum Shape {\n-   | ---------- variant `Squareee` not found here\n+   | ---------- variant `Squareee` not found for this enum\n ...\n LL |     println!(\"My shape is {:?}\", Shape::Squareee { size: 5});\n    |                                         ^^^^^^^^ help: there is a variant with a similar name: `Square`\n@@ -11,7 +11,7 @@ error[E0599]: no variant named `Circl` found for enum `Shape`\n   --> $DIR/suggest-variants.rs:13:41\n    |\n LL | enum Shape {\n-   | ---------- variant `Circl` not found here\n+   | ---------- variant `Circl` not found for this enum\n ...\n LL |     println!(\"My shape is {:?}\", Shape::Circl { size: 5});\n    |                                         ^^^^^ help: there is a variant with a similar name: `Circle`\n@@ -20,7 +20,7 @@ error[E0599]: no variant named `Rombus` found for enum `Shape`\n   --> $DIR/suggest-variants.rs:14:41\n    |\n LL | enum Shape {\n-   | ---------- variant `Rombus` not found here\n+   | ---------- variant `Rombus` not found for this enum\n ...\n LL |     println!(\"My shape is {:?}\", Shape::Rombus{ size: 5});\n    |                                         ^^^^^^ variant not found in `Shape`"}]}