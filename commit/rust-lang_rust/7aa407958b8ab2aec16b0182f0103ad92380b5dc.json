{"sha": "7aa407958b8ab2aec16b0182f0103ad92380b5dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYTQwNzk1OGI4YWIyYWVjMTZiMDE4MmYwMTAzYWQ5MjM4MGI1ZGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-26T15:46:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-26T15:46:18Z"}, "message": "auto merge of #15998 : luqmana/rust/nmnnbd, r=thestinger\n\nLLVM recently added a new attribute, dereferenceable: http://reviews.llvm.org/D4449\r\n\r\n>This patch adds a dereferencable attribute. In some sense, this is a companion to the nonnull attribute, but specifies that the pointer is known to be dereferencable in the same sense as a pointer generated by alloca is known to be dereferencable.\r\n\r\nWith rust, everywhere that we previously marked `nonnull` we can actually mark as `dereferenceable` (which implies nonnull) since we know the size. That is, except for one case: when generating calls for TyVisitor. It seems like we haven't substituted the self type (so we have `ty_param`) and just treat it as an opaque pointer so I just left that bit as nonnull.\r\n\r\nWith this, LLVM can for example hoist a load out of a loop where it previously couldn't:\r\n\r\n```Rust\r\npub fn baz(c: &uint, n: uint) -> uint {\r\n    let mut res = 0;\r\n    for i in range(0, n) {\r\n        if i > 0 {\r\n            res += *c * i;\r\n        }\r\n    }\r\n    res\r\n}\r\n```\r\n\r\nBefore:\r\n```llvm\r\ndefine i64 @baz(i64* noalias nocapture nonnull readonly, i64) unnamed_addr #0 {\r\nentry-block:\r\n  br label %for_loopback.outer\r\n\r\nfor_loopback.outer:                               ; preds = %then-block-33-, %entry-block\r\n  %.ph = phi i64 [ %.lcssa, %then-block-33- ], [ 0, %entry-block ]\r\n  %res.0.ph = phi i64 [ %8, %then-block-33- ], [ 0, %entry-block ]\r\n  br label %for_loopback\r\n\r\nfor_exit:                                         ; preds = %for_loopback\r\n  %res.0.ph.lcssa = phi i64 [ %res.0.ph, %for_loopback ]\r\n  ret i64 %res.0.ph.lcssa\r\n\r\nfor_loopback:                                     ; preds = %for_loopback.outer, %for_body\r\n  %2 = phi i64 [ %4, %for_body ], [ %.ph, %for_loopback.outer ]\r\n  %3 = icmp ult i64 %2, %1\r\n  br i1 %3, label %for_body, label %for_exit\r\n\r\nfor_body:                                         ; preds = %for_loopback\r\n  %4 = add i64 %2, 1\r\n  %5 = icmp eq i64 %2, 0\r\n  br i1 %5, label %for_loopback, label %then-block-33-\r\n\r\nthen-block-33-:                                   ; preds = %for_body\r\n  %.lcssa = phi i64 [ %4, %for_body ]\r\n  %.lcssa15 = phi i64 [ %2, %for_body ]\r\n  %6 = load i64* %0, align 8                     ; <------- this load\r\n  %7 = mul i64 %6, %.lcssa15\r\n  %8 = add i64 %7, %res.0.ph\r\n  br label %for_loopback.outer\r\n}\r\n```\r\n\r\nAfter:\r\n```llvm\r\ndefine i64 @baz(i64* noalias nocapture readonly dereferenceable(8), i64) unnamed_addr #0 {\r\nentry-block:\r\n  %2 = load i64* %0, align 8                    ; <------- load once instead\r\n  br label %for_loopback.outer\r\n\r\nfor_loopback.outer:                               ; preds = %then-block-33-, %entry-block\r\n  %.ph = phi i64 [ %.lcssa, %then-block-33- ], [ 0, %entry-block ]\r\n  %res.0.ph = phi i64 [ %8, %then-block-33- ], [ 0, %entry-block ]\r\n  br label %for_loopback\r\n\r\nfor_exit:                                         ; preds = %for_loopback\r\n  %res.0.ph.lcssa = phi i64 [ %res.0.ph, %for_loopback ]\r\n  ret i64 %res.0.ph.lcssa\r\n\r\nfor_loopback:                                     ; preds = %for_loopback.outer, %for_body\r\n  %3 = phi i64 [ %5, %for_body ], [ %.ph, %for_loopback.outer ]\r\n  %4 = icmp ult i64 %3, %1\r\n  br i1 %4, label %for_body, label %for_exit\r\n\r\nfor_body:                                         ; preds = %for_loopback\r\n  %5 = add i64 %3, 1\r\n  %6 = icmp eq i64 %3, 0\r\n  br i1 %6, label %for_loopback, label %then-block-33-\r\n\r\nthen-block-33-:                                   ; preds = %for_body\r\n  %.lcssa = phi i64 [ %5, %for_body ]\r\n  %.lcssa15 = phi i64 [ %3, %for_body ]\r\n  %7 = mul i64 %2, %.lcssa15\r\n  %8 = add i64 %7, %res.0.ph\r\n  br label %for_loopback.outer\r\n}\r\n```", "tree": {"sha": "59dd1c3707de288a8b9584ca859a9bfdd3b7b9f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59dd1c3707de288a8b9584ca859a9bfdd3b7b9f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7aa407958b8ab2aec16b0182f0103ad92380b5dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7aa407958b8ab2aec16b0182f0103ad92380b5dc", "html_url": "https://github.com/rust-lang/rust/commit/7aa407958b8ab2aec16b0182f0103ad92380b5dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7aa407958b8ab2aec16b0182f0103ad92380b5dc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50c62b466723077ba725c1d7ea8093928613c311", "url": "https://api.github.com/repos/rust-lang/rust/commits/50c62b466723077ba725c1d7ea8093928613c311", "html_url": "https://github.com/rust-lang/rust/commit/50c62b466723077ba725c1d7ea8093928613c311"}, {"sha": "a78c0f1019a4a023de60ae1228ad47fafc96e423", "url": "https://api.github.com/repos/rust-lang/rust/commits/a78c0f1019a4a023de60ae1228ad47fafc96e423", "html_url": "https://github.com/rust-lang/rust/commit/a78c0f1019a4a023de60ae1228ad47fafc96e423"}], "stats": {"total": 318, "additions": 237, "deletions": 81}, "files": [{"sha": "5433923441a7b912b1c4a30d5cb09bf0a267afe0", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 77, "deletions": 45, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7aa407958b8ab2aec16b0182f0103ad92380b5dc", "patch": "@@ -281,11 +281,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n \n     let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, output);\n     let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n-    for &(idx, attr) in attrs.iter() {\n-        unsafe {\n-            llvm::LLVMAddFunctionAttribute(llfn, idx as c_uint, attr);\n-        }\n-    }\n+    attrs.apply_llfn(llfn);\n \n     llfn\n }\n@@ -962,7 +958,7 @@ pub fn invoke<'a>(\n                               llargs.as_slice(),\n                               normal_bcx.llbb,\n                               landing_pad,\n-                              attributes.as_slice());\n+                              Some(attributes));\n         return (llresult, normal_bcx);\n     } else {\n         debug!(\"calling {} at {}\", llfn, bcx.llbb);\n@@ -975,7 +971,7 @@ pub fn invoke<'a>(\n             None => debuginfo::clear_source_location(bcx.fcx)\n         };\n \n-        let llresult = Call(bcx, llfn, llargs.as_slice(), attributes.as_slice());\n+        let llresult = Call(bcx, llfn, llargs.as_slice(), Some(attributes));\n         return (llresult, bcx);\n     }\n }\n@@ -1081,7 +1077,7 @@ pub fn call_lifetime_start(cx: &Block, ptr: ValueRef) {\n     let llsize = C_u64(ccx, machine::llsize_of_alloc(ccx, val_ty(ptr).element_type()));\n     let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n     let lifetime_start = ccx.get_intrinsic(&\"llvm.lifetime.start\");\n-    Call(cx, lifetime_start, [llsize, ptr], []);\n+    Call(cx, lifetime_start, [llsize, ptr], None);\n }\n \n pub fn call_lifetime_end(cx: &Block, ptr: ValueRef) {\n@@ -1095,7 +1091,7 @@ pub fn call_lifetime_end(cx: &Block, ptr: ValueRef) {\n     let llsize = C_u64(ccx, machine::llsize_of_alloc(ccx, val_ty(ptr).element_type()));\n     let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n     let lifetime_end = ccx.get_intrinsic(&\"llvm.lifetime.end\");\n-    Call(cx, lifetime_end, [llsize, ptr], []);\n+    Call(cx, lifetime_end, [llsize, ptr], None);\n }\n \n pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n@@ -1111,7 +1107,7 @@ pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef,\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n-    Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], []);\n+    Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n pub fn memcpy_ty(bcx: &Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n@@ -1156,7 +1152,7 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     let size = machine::llsize_of(ccx, ty);\n     let align = C_i32(ccx, llalign_of_min(ccx, ty) as i32);\n     let volatile = C_bool(ccx, false);\n-    b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], []);\n+    b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], None);\n }\n \n pub fn alloc_ty(bcx: &Block, t: ty::t, name: &str) -> ValueRef {\n@@ -2040,7 +2036,7 @@ fn register_fn(ccx: &CrateContext,\n }\n \n pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n-                              -> Vec<(uint, u64)> {\n+                              -> llvm::AttrBuilder {\n     use middle::ty::{BrAnon, ReLateBound};\n \n     let (fn_sig, abi, has_env) = match ty::get(fn_ty).sty {\n@@ -2056,31 +2052,33 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         _ => fail!(\"expected closure or function.\")\n     };\n \n+    // Since index 0 is the return value of the llvm func, we start\n+    // at either 1 or 2 depending on whether there's an env slot or not\n+    let mut first_arg_offset = if has_env { 2 } else { 1 };\n+    let mut attrs = llvm::AttrBuilder::new();\n+    let ret_ty = fn_sig.output;\n+\n     // These have an odd calling convention, so we skip them for now.\n     //\n     // FIXME(pcwalton): We don't have to skip them; just untuple the result.\n     if abi == RustCall {\n-        return Vec::new()\n+        return attrs;\n     }\n \n-    // Since index 0 is the return value of the llvm func, we start\n-    // at either 1 or 2 depending on whether there's an env slot or not\n-    let mut first_arg_offset = if has_env { 2 } else { 1 };\n-    let mut attrs = Vec::new();\n-    let ret_ty = fn_sig.output;\n-\n     // A function pointer is called without the declaration\n     // available, so we have to apply any attributes with ABI\n     // implications directly to the call instruction. Right now,\n     // the only attribute we need to worry about is `sret`.\n     if type_of::return_uses_outptr(ccx, ret_ty) {\n-        attrs.push((1, llvm::StructRetAttribute as u64));\n+        let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, ret_ty));\n \n         // The outptr can be noalias and nocapture because it's entirely\n-        // invisible to the program. We can also mark it as nonnull\n-        attrs.push((1, llvm::NoAliasAttribute as u64));\n-        attrs.push((1, llvm::NoCaptureAttribute as u64));\n-        attrs.push((1, llvm::NonNullAttribute as u64));\n+        // invisible to the program. We also know it's nonnull as well\n+        // as how many bytes we can dereference\n+        attrs.arg(1, llvm::StructRetAttribute)\n+             .arg(1, llvm::NoAliasAttribute)\n+             .arg(1, llvm::NoCaptureAttribute)\n+             .arg(1, llvm::DereferenceableAttribute(llret_sz));\n \n         // Add one more since there's an outptr\n         first_arg_offset += 1;\n@@ -2094,27 +2092,28 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n                 ty::ty_str | ty::ty_vec(..) | ty::ty_trait(..) => true, _ => false\n             } => {}\n             ty::ty_uniq(_) => {\n-                attrs.push((llvm::ReturnIndex as uint, llvm::NoAliasAttribute as u64));\n+                attrs.ret(llvm::NoAliasAttribute);\n             }\n             _ => {}\n         }\n \n-        // We can also mark the return value as `nonnull` in certain cases\n+        // We can also mark the return value as `dereferenceable` in certain cases\n         match ty::get(ret_ty).sty {\n             // These are not really pointers but pairs, (pointer, len)\n             ty::ty_uniq(it) |\n             ty::ty_rptr(_, ty::mt { ty: it, .. }) if match ty::get(it).sty {\n                 ty::ty_str | ty::ty_vec(..) | ty::ty_trait(..) => true, _ => false\n             } => {}\n-            ty::ty_uniq(_) | ty::ty_rptr(_, _) => {\n-                attrs.push((llvm::ReturnIndex as uint, llvm::NonNullAttribute as u64));\n+            ty::ty_uniq(inner) | ty::ty_rptr(_, ty::mt { ty: inner, .. }) => {\n+                let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n+                attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n             }\n             _ => {}\n         }\n \n         match ty::get(ret_ty).sty {\n             ty::ty_bool => {\n-                attrs.push((llvm::ReturnIndex as uint, llvm::ZExtAttribute as u64));\n+                attrs.ret(llvm::ZExtAttribute);\n             }\n             _ => {}\n         }\n@@ -2124,44 +2123,77 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         match ty::get(t).sty {\n             // this needs to be first to prevent fat pointers from falling through\n             _ if !type_is_immediate(ccx, t) => {\n+                let llarg_sz = llsize_of_real(ccx, type_of::type_of(ccx, t));\n+\n                 // For non-immediate arguments the callee gets its own copy of\n                 // the value on the stack, so there are no aliases. It's also\n                 // program-invisible so can't possibly capture\n-                attrs.push((idx, llvm::NoAliasAttribute as u64));\n-                attrs.push((idx, llvm::NoCaptureAttribute as u64));\n-                attrs.push((idx, llvm::NonNullAttribute as u64));\n+                attrs.arg(idx, llvm::NoAliasAttribute)\n+                     .arg(idx, llvm::NoCaptureAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n             }\n+\n             ty::ty_bool => {\n-                attrs.push((idx, llvm::ZExtAttribute as u64));\n+                attrs.arg(idx, llvm::ZExtAttribute);\n             }\n+\n             // `~` pointer parameters never alias because ownership is transferred\n-            ty::ty_uniq(_) => {\n-                attrs.push((idx, llvm::NoAliasAttribute as u64));\n-                attrs.push((idx, llvm::NonNullAttribute as u64));\n+            ty::ty_uniq(inner) => {\n+                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n+\n+                attrs.arg(idx, llvm::NoAliasAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n+            }\n+\n+            // The visit glue deals only with opaque pointers so we don't\n+            // actually know the concrete type of Self thus we don't know how\n+            // many bytes to mark as dereferenceable so instead we just mark\n+            // it as nonnull which still holds true\n+            ty::ty_rptr(b, ty::mt { ty: it, mutbl }) if match ty::get(it).sty {\n+                ty::ty_param(_) => true, _ => false\n+            } && mutbl == ast::MutMutable => {\n+                attrs.arg(idx, llvm::NoAliasAttribute)\n+                     .arg(idx, llvm::NonNullAttribute);\n+\n+                match b {\n+                    ReLateBound(_, BrAnon(_)) => {\n+                        attrs.arg(idx, llvm::NoCaptureAttribute);\n+                    }\n+                    _ => {}\n+                }\n             }\n+\n             // `&mut` pointer parameters never alias other parameters, or mutable global data\n             // `&` pointer parameters never alias either (for LLVM's purposes) as long as the\n             // interior is safe\n             ty::ty_rptr(b, mt) if mt.mutbl == ast::MutMutable ||\n                                   !ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe() => {\n-                attrs.push((idx, llvm::NoAliasAttribute as u64));\n-                attrs.push((idx, llvm::NonNullAttribute as u64));\n+\n+                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n+                attrs.arg(idx, llvm::NoAliasAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n+\n                 match b {\n                     ReLateBound(_, BrAnon(_)) => {\n-                        attrs.push((idx, llvm::NoCaptureAttribute as u64));\n+                        attrs.arg(idx, llvm::NoCaptureAttribute);\n                     }\n                     _ => {}\n                 }\n             }\n+\n             // When a reference in an argument has no named lifetime, it's impossible for that\n             // reference to escape this function (returned or stored beyond the call by a closure).\n-            ty::ty_rptr(ReLateBound(_, BrAnon(_)), _) => {\n-                attrs.push((idx, llvm::NoCaptureAttribute as u64));\n-                attrs.push((idx, llvm::NonNullAttribute as u64));\n+            ty::ty_rptr(ReLateBound(_, BrAnon(_)), mt) => {\n+                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n+                attrs.arg(idx, llvm::NoCaptureAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n-            // & pointer parameters are never null\n-            ty::ty_rptr(_, _) => {\n-                attrs.push((idx, llvm::NonNullAttribute as u64));\n+\n+            // & pointer parameters are also never null and we know exactly how\n+            // many bytes we can dereference\n+            ty::ty_rptr(_, mt) => {\n+                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n+                attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n             _ => ()\n         }"}, {"sha": "d2ddf3ff696627c76e1ded2d0da9d31b8b55b6e0", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=7aa407958b8ab2aec16b0182f0103ad92380b5dc", "patch": "@@ -12,7 +12,7 @@\n #![allow(non_snake_case_functions)]\n \n use llvm;\n-use llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n+use llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect, AttrBuilder};\n use llvm::{Opcode, IntPredicate, RealPredicate};\n use llvm::{ValueRef, BasicBlockRef};\n use middle::trans::common::*;\n@@ -113,7 +113,7 @@ pub fn Invoke(cx: &Block,\n               args: &[ValueRef],\n               then: BasicBlockRef,\n               catch: BasicBlockRef,\n-              attributes: &[(uint, u64)])\n+              attributes: Option<AttrBuilder>)\n               -> ValueRef {\n     if cx.unreachable.get() {\n         return C_null(Type::i8(cx.ccx()));\n@@ -681,13 +681,13 @@ pub fn InlineAsmCall(cx: &Block, asm: *const c_char, cons: *const c_char,\n }\n \n pub fn Call(cx: &Block, fn_: ValueRef, args: &[ValueRef],\n-            attributes: &[(uint, u64)]) -> ValueRef {\n+            attributes: Option<AttrBuilder>) -> ValueRef {\n     if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n     B(cx).call(fn_, args, attributes)\n }\n \n pub fn CallWithConv(cx: &Block, fn_: ValueRef, args: &[ValueRef], conv: CallConv,\n-                    attributes: &[(uint, u64)]) -> ValueRef {\n+                    attributes: Option<AttrBuilder>) -> ValueRef {\n     if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n     B(cx).call_with_conv(fn_, args, conv, attributes)\n }"}, {"sha": "b3192a405be5938b2df85eb171227cf5ac54ed6a", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=7aa407958b8ab2aec16b0182f0103ad92380b5dc", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_code)] // FFI wrappers\n \n use llvm;\n-use llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n+use llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect, AttrBuilder};\n use llvm::{Opcode, IntPredicate, RealPredicate, False};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use middle::trans::base;\n@@ -155,7 +155,7 @@ impl<'a> Builder<'a> {\n                   args: &[ValueRef],\n                   then: BasicBlockRef,\n                   catch: BasicBlockRef,\n-                  attributes: &[(uint, u64)])\n+                  attributes: Option<AttrBuilder>)\n                   -> ValueRef {\n         self.count_insn(\"invoke\");\n \n@@ -174,8 +174,9 @@ impl<'a> Builder<'a> {\n                                           then,\n                                           catch,\n                                           noname());\n-            for &(idx, attr) in attributes.iter() {\n-                llvm::LLVMAddCallSiteAttribute(v, idx as c_uint, attr);\n+            match attributes {\n+                Some(a) => a.apply_callsite(v),\n+                None => {}\n             }\n             v\n         }\n@@ -777,7 +778,7 @@ impl<'a> Builder<'a> {\n                                              c, noname(), False, False)\n                 }\n             });\n-            self.call(asm, [], []);\n+            self.call(asm, [], None);\n         }\n     }\n \n@@ -802,12 +803,12 @@ impl<'a> Builder<'a> {\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n-            self.call(v, inputs, [])\n+            self.call(v, inputs, None)\n         }\n     }\n \n     pub fn call(&self, llfn: ValueRef, args: &[ValueRef],\n-                attributes: &[(uint, u64)]) -> ValueRef {\n+                attributes: Option<AttrBuilder>) -> ValueRef {\n         self.count_insn(\"call\");\n \n         debug!(\"Call {} with args ({})\",\n@@ -820,15 +821,16 @@ impl<'a> Builder<'a> {\n         unsafe {\n             let v = llvm::LLVMBuildCall(self.llbuilder, llfn, args.as_ptr(),\n                                         args.len() as c_uint, noname());\n-            for &(idx, attr) in attributes.iter() {\n-                llvm::LLVMAddCallSiteAttribute(v, idx as c_uint, attr);\n+            match attributes {\n+                Some(a) => a.apply_callsite(v),\n+                None => {}\n             }\n             v\n         }\n     }\n \n     pub fn call_with_conv(&self, llfn: ValueRef, args: &[ValueRef],\n-                          conv: CallConv, attributes: &[(uint, u64)]) -> ValueRef {\n+                          conv: CallConv, attributes: Option<AttrBuilder>) -> ValueRef {\n         self.count_insn(\"callwithconv\");\n         let v = self.call(llfn, args, attributes);\n         llvm::SetInstructionCallConv(v, conv);"}, {"sha": "a65d208d4d2872c674e0dd5f6622f33af3d08f98", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=7aa407958b8ab2aec16b0182f0103ad92380b5dc", "patch": "@@ -588,7 +588,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n     }\n     llargs.extend(args.iter().map(|arg| arg.val));\n \n-    let retval = Call(bcx, fn_ptr, llargs.as_slice(), []);\n+    let retval = Call(bcx, fn_ptr, llargs.as_slice(), None);\n     if type_is_zero_size(ccx, f.sig.output) || fcx.llretptr.get().is_some() {\n         RetVoid(bcx);\n     } else {"}, {"sha": "1dad6e3cb18439684d0ae3301b2e96a0194657a9", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=7aa407958b8ab2aec16b0182f0103ad92380b5dc", "patch": "@@ -553,7 +553,7 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n             let expected = Call(bcx,\n                                 expect,\n                                 [bounds_check, C_bool(ccx, false)],\n-                                []);\n+                                None);\n             bcx = with_cond(bcx, expected, |bcx| {\n                 controlflow::trans_fail_bounds_check(bcx,\n                                                      index_expr.span,"}, {"sha": "f305ae90d46af69f9ed01dfe2a4de098257eccd3", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=7aa407958b8ab2aec16b0182f0103ad92380b5dc", "patch": "@@ -382,21 +382,24 @@ pub fn trans_native_call<'a>(\n \n     // A function pointer is called without the declaration available, so we have to apply\n     // any attributes with ABI implications directly to the call instruction.\n-    let mut attrs = Vec::new();\n+    let mut attrs = llvm::AttrBuilder::new();\n \n     // Add attributes that are always applicable, independent of the concrete foreign ABI\n     if fn_type.ret_ty.is_indirect() {\n+        let llret_sz = machine::llsize_of_real(ccx, fn_type.ret_ty.ty);\n+\n         // The outptr can be noalias and nocapture because it's entirely\n-        // invisible to the program. We can also mark it as nonnull\n-        attrs.push((1, llvm::NoAliasAttribute as u64));\n-        attrs.push((1, llvm::NoCaptureAttribute as u64));\n-        attrs.push((1, llvm::NonNullAttribute as u64));\n+        // invisible to the program. We also know it's nonnull as well\n+        // as how many bytes we can dereference\n+        attrs.arg(1, llvm::NoAliasAttribute)\n+             .arg(1, llvm::NoCaptureAttribute)\n+             .arg(1, llvm::DereferenceableAttribute(llret_sz));\n     };\n \n     // Add attributes that depend on the concrete foreign ABI\n     let mut arg_idx = if fn_type.ret_ty.is_indirect() { 1 } else { 0 };\n     match fn_type.ret_ty.attr {\n-        Some(attr) => attrs.push((arg_idx, attr as u64)),\n+        Some(attr) => { attrs.arg(arg_idx, attr); },\n         _ => ()\n     }\n \n@@ -409,7 +412,7 @@ pub fn trans_native_call<'a>(\n         if arg_ty.pad.is_some() { arg_idx += 1; }\n \n         match arg_ty.attr {\n-            Some(attr) => attrs.push((arg_idx, attr as u64)),\n+            Some(attr) => { attrs.arg(arg_idx, attr); },\n             _ => {}\n         }\n \n@@ -420,7 +423,7 @@ pub fn trans_native_call<'a>(\n                                         llfn,\n                                         llargs_foreign.as_slice(),\n                                         cc,\n-                                        attrs.as_slice());\n+                                        Some(attrs));\n \n     // If the function we just called does not use an outpointer,\n     // store the result into the rust outpointer. Cast the outpointer\n@@ -762,7 +765,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         // Perform the call itself\n         debug!(\"calling llrustfn = {}, t = {}\", ccx.tn.val_to_string(llrustfn), t.repr(ccx.tcx()));\n         let attributes = base::get_fn_llvm_attributes(ccx, t);\n-        let llrust_ret_val = builder.call(llrustfn, llrust_args.as_slice(), attributes.as_slice());\n+        let llrust_ret_val = builder.call(llrustfn, llrust_args.as_slice(), Some(attributes));\n \n         // Get the return value where the foreign fn expects it.\n         let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {"}, {"sha": "5c978d505cb768e61c402fb5c5555536e45d159f", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=7aa407958b8ab2aec16b0182f0103ad92380b5dc", "patch": "@@ -129,7 +129,7 @@ pub fn drop_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n         } else {\n             v\n         };\n-        Call(bcx, glue, [ptr], []);\n+        Call(bcx, glue, [ptr], None);\n     }\n     bcx\n }\n@@ -185,7 +185,7 @@ pub fn call_visit_glue(bcx: &Block, v: ValueRef, tydesc: ValueRef) {\n     let llfn = Load(bcx, GEPi(bcx, tydesc, [0u, abi::tydesc_field_visit_glue]));\n     let llrawptr = PointerCast(bcx, v, Type::i8p(bcx.ccx()));\n \n-    Call(bcx, llfn, [llrawptr], []);\n+    Call(bcx, llfn, [llrawptr], None);\n }\n \n fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n@@ -303,7 +303,7 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                         Call(bcx,\n                              dtor,\n                              [PointerCast(bcx, lluniquevalue, Type::i8p(bcx.ccx()))],\n-                             []);\n+                             None);\n                         bcx\n                     })\n                 }\n@@ -342,7 +342,7 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 let dtor_ptr = GEPi(bcx, env, [0u, abi::box_field_tydesc]);\n                 let dtor = Load(bcx, dtor_ptr);\n                 let cdata = GEPi(bcx, env, [0u, abi::box_field_body]);\n-                Call(bcx, dtor, [PointerCast(bcx, cdata, Type::i8p(bcx.ccx()))], []);\n+                Call(bcx, dtor, [PointerCast(bcx, cdata, Type::i8p(bcx.ccx()))], None);\n \n                 // Free the environment itself\n                 // FIXME: #13994: pass align and size here"}, {"sha": "fb420a4035d94a25e582f912aa8c385239f592f1", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=7aa407958b8ab2aec16b0182f0103ad92380b5dc", "patch": "@@ -208,17 +208,17 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n \n     let llval = match (simple, name.get()) {\n         (Some(llfn), _) => {\n-            Call(bcx, llfn, llargs.as_slice(), [])\n+            Call(bcx, llfn, llargs.as_slice(), None)\n         }\n         (_, \"abort\") => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n-            let v = Call(bcx, llfn, [], []);\n+            let v = Call(bcx, llfn, [], None);\n             Unreachable(bcx);\n             v\n         }\n         (_, \"breakpoint\") => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n-            Call(bcx, llfn, [], [])\n+            Call(bcx, llfn, [], None)\n         }\n         (_, \"size_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n@@ -553,7 +553,7 @@ fn copy_intrinsic(bcx: &Block, allow_overlap: bool, volatile: bool,\n     let llfn = ccx.get_intrinsic(&name);\n \n     Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align,\n-                     C_bool(ccx, volatile)], [])\n+                     C_bool(ccx, volatile)], None)\n }\n \n fn memset_intrinsic(bcx: &Block, volatile: bool, tp_ty: ty::t,\n@@ -572,21 +572,21 @@ fn memset_intrinsic(bcx: &Block, volatile: bool, tp_ty: ty::t,\n     let llfn = ccx.get_intrinsic(&name);\n \n     Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align,\n-                     C_bool(ccx, volatile)], [])\n+                     C_bool(ccx, volatile)], None)\n }\n \n fn count_zeros_intrinsic(bcx: &Block, name: &'static str, val: ValueRef) -> ValueRef {\n     let y = C_bool(bcx.ccx(), false);\n     let llfn = bcx.ccx().get_intrinsic(&name);\n-    Call(bcx, llfn, [val, y], [])\n+    Call(bcx, llfn, [val, y], None)\n }\n \n fn with_overflow_intrinsic(bcx: &Block, name: &'static str, t: ty::t,\n                            a: ValueRef, b: ValueRef) -> ValueRef {\n     let llfn = bcx.ccx().get_intrinsic(&name);\n \n     // Convert `i1` to a `bool`, and write it to the out parameter\n-    let val = Call(bcx, llfn, [a, b], []);\n+    let val = Call(bcx, llfn, [a, b], None);\n     let result = ExtractValue(bcx, val, 0);\n     let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n     let ret = C_undef(type_of::type_of(bcx.ccx(), t));"}, {"sha": "1ac0aee85d4d9010d91ca47258ce745d2ae99ea1", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=7aa407958b8ab2aec16b0182f0103ad92380b5dc", "patch": "@@ -130,12 +130,101 @@ pub enum OtherAttribute {\n     NonNullAttribute = 1 << 44,\n }\n \n+pub enum SpecialAttribute {\n+    DereferenceableAttribute(u64)\n+}\n+\n #[repr(C)]\n pub enum AttributeSet {\n     ReturnIndex = 0,\n     FunctionIndex = !0\n }\n \n+trait AttrHelper {\n+    fn apply_llfn(&self, idx: c_uint, llfn: ValueRef);\n+    fn apply_callsite(&self, idx: c_uint, callsite: ValueRef);\n+}\n+\n+impl AttrHelper for Attribute {\n+    fn apply_llfn(&self, idx: c_uint, llfn: ValueRef) {\n+        unsafe {\n+            LLVMAddFunctionAttribute(llfn, idx, *self as uint64_t);\n+        }\n+    }\n+\n+    fn apply_callsite(&self, idx: c_uint, callsite: ValueRef) {\n+        unsafe {\n+            LLVMAddCallSiteAttribute(callsite, idx, *self as uint64_t);\n+        }\n+    }\n+}\n+\n+impl AttrHelper for OtherAttribute {\n+    fn apply_llfn(&self, idx: c_uint, llfn: ValueRef) {\n+        unsafe {\n+            LLVMAddFunctionAttribute(llfn, idx, *self as uint64_t);\n+        }\n+    }\n+\n+    fn apply_callsite(&self, idx: c_uint, callsite: ValueRef) {\n+        unsafe {\n+            LLVMAddCallSiteAttribute(callsite, idx, *self as uint64_t);\n+        }\n+    }\n+}\n+\n+impl AttrHelper for SpecialAttribute {\n+    fn apply_llfn(&self, idx: c_uint, llfn: ValueRef) {\n+        match *self {\n+            DereferenceableAttribute(bytes) => unsafe {\n+                LLVMAddDereferenceableAttr(llfn, idx, bytes as uint64_t);\n+            }\n+        }\n+    }\n+\n+    fn apply_callsite(&self, idx: c_uint, callsite: ValueRef) {\n+        match *self {\n+            DereferenceableAttribute(bytes) => unsafe {\n+                LLVMAddDereferenceableCallSiteAttr(callsite, idx, bytes as uint64_t);\n+            }\n+        }\n+    }\n+}\n+\n+pub struct AttrBuilder {\n+    attrs: Vec<(uint, Box<AttrHelper>)>\n+}\n+\n+impl AttrBuilder {\n+    pub fn new() -> AttrBuilder {\n+        AttrBuilder {\n+            attrs: Vec::new()\n+        }\n+    }\n+\n+    pub fn arg<'a, T: AttrHelper + 'static>(&'a mut self, idx: uint, a: T) -> &'a mut AttrBuilder {\n+        self.attrs.push((idx, box a as Box<AttrHelper>));\n+        self\n+    }\n+\n+    pub fn ret<'a, T: AttrHelper + 'static>(&'a mut self, a: T) -> &'a mut AttrBuilder {\n+        self.attrs.push((ReturnIndex as uint, box a as Box<AttrHelper>));\n+        self\n+    }\n+\n+    pub fn apply_llfn(&self, llfn: ValueRef) {\n+        for &(idx, ref attr) in self.attrs.iter() {\n+            attr.apply_llfn(idx as c_uint, llfn);\n+        }\n+    }\n+\n+    pub fn apply_callsite(&self, callsite: ValueRef) {\n+        for &(idx, ref attr) in self.attrs.iter() {\n+            attr.apply_callsite(idx as c_uint, callsite);\n+        }\n+    }\n+}\n+\n // enum for the LLVM IntPredicate type\n pub enum IntPredicate {\n     IntEQ = 32,\n@@ -740,6 +829,7 @@ extern {\n     pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n     pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n     pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n+    pub fn LLVMAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: uint64_t);\n     pub fn LLVMAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: uint64_t);\n     pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n     pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n@@ -811,6 +901,9 @@ extern {\n     pub fn LLVMAddCallSiteAttribute(Instr: ValueRef,\n                                     index: c_uint,\n                                     Val: uint64_t);\n+    pub fn LLVMAddDereferenceableCallSiteAttr(Instr: ValueRef,\n+                                              index: c_uint,\n+                                              bytes: uint64_t);\n \n     /* Operations on call instructions (only) */\n     pub fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;"}, {"sha": "8a3e06aabc69733e7e9547bcf504a24be0496133", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/7aa407958b8ab2aec16b0182f0103ad92380b5dc/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=7aa407958b8ab2aec16b0182f0103ad92380b5dc", "patch": "@@ -113,13 +113,39 @@ extern \"C\" void LLVMAddCallSiteAttribute(LLVMValueRef Instr, unsigned index, uin\n                                                          index, B)));\n }\n \n+\n+#if LLVM_VERSION_MINOR >= 5\n+extern \"C\" void LLVMAddDereferenceableCallSiteAttr(LLVMValueRef Instr, unsigned idx, uint64_t b) {\n+  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  AttrBuilder B;\n+  B.addDereferenceableAttr(b);\n+  Call.setAttributes(\n+    Call.getAttributes().addAttributes(Call->getContext(), idx,\n+                                       AttributeSet::get(Call->getContext(),\n+                                                         idx, B)));\n+}\n+#else\n+extern \"C\" void LLVMAddDereferenceableCallSiteAttr(LLVMValueRef, unsigned, uint64_t) {}\n+#endif\n+\n extern \"C\" void LLVMAddFunctionAttribute(LLVMValueRef Fn, unsigned index, uint64_t Val) {\n   Function *A = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addRawValue(Val);\n   A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n }\n \n+#if LLVM_VERSION_MINOR >= 5\n+extern \"C\" void LLVMAddDereferenceableAttr(LLVMValueRef Fn, unsigned index, uint64_t bytes) {\n+  Function *A = unwrap<Function>(Fn);\n+  AttrBuilder B;\n+  B.addDereferenceableAttr(bytes);\n+  A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n+}\n+#else\n+extern \"C\" void LLVMAddDereferenceableAttr(LLVMValueRef, unsigned, uint64_t) {}\n+#endif\n+\n extern \"C\" void LLVMAddFunctionAttrString(LLVMValueRef Fn, unsigned index, const char *Name) {\n   Function *F = unwrap<Function>(Fn);\n   AttrBuilder B;"}]}