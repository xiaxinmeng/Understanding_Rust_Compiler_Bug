{"sha": "421c5d11c1b4bb591bb429577c7b89cba59acefa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMWM1ZDExYzFiNGJiNTkxYmI0Mjk1NzdjN2I4OWNiYTU5YWNlZmE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-12-01T11:20:04Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-12-18T23:26:30Z"}, "message": "Remove scope placeholders, remove method `add_macro` of `ext::base::Resolver`.", "tree": {"sha": "355c3ca1ff8926f985ce2dbce5cb8b2e8df85b0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/355c3ca1ff8926f985ce2dbce5cb8b2e8df85b0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/421c5d11c1b4bb591bb429577c7b89cba59acefa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/421c5d11c1b4bb591bb429577c7b89cba59acefa", "html_url": "https://github.com/rust-lang/rust/commit/421c5d11c1b4bb591bb429577c7b89cba59acefa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/421c5d11c1b4bb591bb429577c7b89cba59acefa/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e80d1a8faf2da8df494828e2772e2d2043282fed", "url": "https://api.github.com/repos/rust-lang/rust/commits/e80d1a8faf2da8df494828e2772e2d2043282fed", "html_url": "https://github.com/rust-lang/rust/commit/e80d1a8faf2da8df494828e2772e2d2043282fed"}], "stats": {"total": 213, "additions": 91, "deletions": 122}, "files": [{"sha": "9f85580b93ef88a666b983192d8e195e990c24e7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=421c5d11c1b4bb591bb429577c7b89cba59acefa", "patch": "@@ -697,9 +697,13 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_item(&mut self, item: &'a Item) {\n         let macro_use = match item.node {\n-            ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => return, // Scope placeholder\n-            ItemKind::Mac(..) => {\n-                return self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+            ItemKind::Mac(ref mac) => {\n+                if mac.node.path.segments.is_empty() {\n+                    self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+                } else {\n+                    self.resolver.define_macro(item, &mut self.legacy_scope);\n+                }\n+                return\n             }\n             ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n             _ => false,"}, {"sha": "ce92a4446f92055208f84af7351d872e4716255e", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=421c5d11c1b4bb591bb429577c7b89cba59acefa", "patch": "@@ -23,8 +23,8 @@ use syntax::ast::{self, Name, Ident};\n use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n-use syntax::ext::base::{NormalTT, SyntaxExtension};\n-use syntax::ext::expand::Expansion;\n+use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n+use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, GateIssue};\n@@ -139,34 +139,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n-    fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef) {\n-        if def.ident.name == \"macro_rules\" {\n-            self.session.span_err(def.span, \"user-defined macros may not be named `macro_rules`\");\n-        }\n-\n-        let invocation = self.invocations[&scope];\n-        let binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n-            parent: Cell::new(invocation.legacy_scope.get()),\n-            name: def.ident.name,\n-            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n-            span: def.span,\n-        });\n-        invocation.legacy_scope.set(LegacyScope::Binding(binding));\n-        self.macro_names.insert(def.ident.name);\n-\n-        if attr::contains_name(&def.attrs, \"macro_export\") {\n-            def.id = self.next_node_id();\n-            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n-                collector.visit_macro_def(&def)\n-            });\n-            self.macro_exports.push(Export {\n-                name: def.ident.name,\n-                def: Def::Macro(self.definitions.local_def_id(def.id)),\n-            });\n-            self.exported_macros.push(def);\n-        }\n-    }\n-\n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n@@ -444,4 +416,47 @@ impl<'a> Resolver<'a> {\n             expansion.visit_with(def_collector)\n         });\n     }\n+\n+    pub fn define_macro(&mut self, item: &ast::Item, legacy_scope: &mut LegacyScope<'a>) {\n+        let tts = match item.node {\n+            ast::ItemKind::Mac(ref mac) => &mac.node.tts,\n+            _ => unreachable!(),\n+        };\n+\n+        if item.ident.name == \"macro_rules\" {\n+            self.session.span_err(item.span, \"user-defined macros may not be named `macro_rules`\");\n+        }\n+\n+        let mark = Mark::from_placeholder_id(item.id);\n+        let invocation = self.invocations[&mark];\n+        invocation.module.set(self.current_module);\n+\n+        let mut def = ast::MacroDef {\n+            ident: item.ident,\n+            attrs: item.attrs.clone(),\n+            id: ast::DUMMY_NODE_ID,\n+            span: item.span,\n+            body: mark_tts(tts, mark),\n+        };\n+\n+        *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n+            parent: Cell::new(*legacy_scope),\n+            name: def.ident.name,\n+            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n+            span: def.span,\n+        }));\n+        self.macro_names.insert(def.ident.name);\n+\n+        if attr::contains_name(&def.attrs, \"macro_export\") {\n+            def.id = self.next_node_id();\n+            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n+                collector.visit_macro_def(&def)\n+            });\n+            self.macro_exports.push(Export {\n+                name: def.ident.name,\n+                def: Def::Macro(self.definitions.local_def_id(def.id)),\n+            });\n+            self.exported_macros.push(def);\n+        }\n+    }\n }"}, {"sha": "f9364f39ab7685aea5c7267dc2053ef200a0e97c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=421c5d11c1b4bb591bb429577c7b89cba59acefa", "patch": "@@ -520,7 +520,6 @@ pub trait Resolver {\n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item>;\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n-    fn add_macro(&mut self, scope: Mark, def: ast::MacroDef);\n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n@@ -544,7 +543,6 @@ impl Resolver for DummyResolver {\n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> { item }\n \n     fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n-    fn add_macro(&mut self, _scope: Mark, _def: ast::MacroDef) {}\n     fn add_ext(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n     fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n "}, {"sha": "05501b5434a14f6ad6eb970733f3b154837dd615", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=421c5d11c1b4bb591bb429577c7b89cba59acefa", "patch": "@@ -392,14 +392,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n         let Mac_ { path, tts, .. } = mac.node;\n \n-        // Detect use of feature-gated or invalid attributes on macro invoations\n-        // since they will not be detected after macro expansion.\n-        for attr in attrs.iter() {\n-            feature_gate::check_attribute(&attr, &self.cx.parse_sess,\n-                                          &self.cx.parse_sess.codemap(),\n-                                          &self.cx.ecfg.features.unwrap());\n-        }\n-\n         let extname = path.segments.last().unwrap().identifier.name;\n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n         let marked_tts = mark_tts(&tts, mark);\n@@ -601,6 +593,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect_bang(\n         &mut self, mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span, kind: ExpansionKind,\n     ) -> Expansion {\n+        self.check_attributes(&attrs);\n         self.collect(kind, InvocationKind::Bang { attrs: attrs, mac: mac, ident: None, span: span })\n     }\n \n@@ -622,6 +615,16 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n+\n+    // Detect use of feature-gated or invalid attributes on macro invocations\n+    // since they will not be detected after macro expansion.\n+    fn check_attributes(&mut self, attrs: &[ast::Attribute]) {\n+        let codemap = &self.cx.parse_sess.codemap();\n+        let features = self.cx.ecfg.features.unwrap();\n+        for attr in attrs.iter() {\n+            feature_gate::check_attribute(&attr, &self.cx.parse_sess, codemap, features);\n+        }\n+    }\n }\n \n // These are pretty nasty. Ideally, we would keep the tokens around, linked from\n@@ -740,14 +743,18 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         match item.node {\n             ast::ItemKind::Mac(..) => {\n-                if match item.node {\n-                    ItemKind::Mac(ref mac) => mac.node.path.segments.is_empty(),\n-                    _ => unreachable!(),\n-                } {\n-                    return SmallVector::one(item);\n-                }\n+                self.check_attributes(&item.attrs);\n+                let is_macro_def = if let ItemKind::Mac(ref mac) = item.node {\n+                    mac.node.path.segments[0].identifier.name == \"macro_rules\"\n+                } else {\n+                    unreachable!()\n+                };\n \n-                item.and_then(|item| match item.node {\n+                item.and_then(|mut item| match item.node {\n+                    ItemKind::Mac(_) if is_macro_def => {\n+                        item.id = ast::NodeId::from_u32(Mark::fresh().as_u32());\n+                        SmallVector::one(P(item))\n+                    }\n                     ItemKind::Mac(mac) => {\n                         self.collect(ExpansionKind::Items, InvocationKind::Bang {\n                             mac: mac,"}, {"sha": "eb4b6144c8d28ad989d2044710ed2cda42b3f49f", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=421c5d11c1b4bb591bb429577c7b89cba59acefa", "patch": "@@ -12,9 +12,10 @@ use ast;\n use codemap::{DUMMY_SP, dummy_spanned};\n use ext::base::ExtCtxt;\n use ext::expand::{Expansion, ExpansionKind};\n+use ext::hygiene::Mark;\n use fold::*;\n use ptr::P;\n-use symbol::{Symbol, keywords};\n+use symbol::keywords;\n use util::move_map::MoveMap;\n use util::small_vector::SmallVector;\n \n@@ -68,10 +69,6 @@ pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     }\n }\n \n-pub fn macro_scope_placeholder() -> Expansion {\n-    placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n-}\n-\n pub struct PlaceholderExpander<'a, 'b: 'a> {\n     expansions: HashMap<ast::NodeId, Expansion>,\n     cx: &'a mut ExtCtxt<'b>,\n@@ -100,11 +97,12 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         match item.node {\n-            // Scope placeholder\n-            ast::ItemKind::Mac(_) if item.id == ast::DUMMY_NODE_ID => SmallVector::one(item),\n-            ast::ItemKind::Mac(_) => self.remove(item.id).make_items(),\n-            _ => noop_fold_item(item, self),\n+            ast::ItemKind::Mac(ref mac) if !mac.node.path.segments.is_empty() => {}\n+            ast::ItemKind::Mac(_) => return self.remove(item.id).make_items(),\n+            _ => {}\n         }\n+\n+        noop_fold_item(item, self)\n     }\n \n     fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n@@ -172,10 +170,10 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n             block.stmts = block.stmts.move_flat_map(|mut stmt| {\n                 remaining_stmts -= 1;\n \n-                // Scope placeholder\n+                // `macro_rules!` macro definition\n                 if let ast::StmtKind::Item(ref item) = stmt.node {\n-                    if let ast::ItemKind::Mac(..) = item.node {\n-                        macros.push(item.ident.ctxt.data().outer_mark);\n+                    if let ast::ItemKind::Mac(_) = item.node {\n+                        macros.push(Mark::from_placeholder_id(item.id));\n                         return None;\n                     }\n                 }\n@@ -208,33 +206,13 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n     fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n         let mut module = noop_fold_mod(module, self);\n         module.items = module.items.move_flat_map(|item| match item.node {\n-            ast::ItemKind::Mac(_) => None, // remove scope placeholders from modules\n+            ast::ItemKind::Mac(_) if !self.cx.ecfg.keep_macs => None, // remove macro definitions\n             _ => Some(item),\n         });\n         module\n     }\n-}\n \n-pub fn reconstructed_macro_rules(def: &ast::MacroDef) -> Expansion {\n-    Expansion::Items(SmallVector::one(P(ast::Item {\n-        ident: def.ident,\n-        attrs: def.attrs.clone(),\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ItemKind::Mac(ast::Mac {\n-            span: def.span,\n-            node: ast::Mac_ {\n-                path: ast::Path {\n-                    span: DUMMY_SP,\n-                    global: false,\n-                    segments: vec![ast::PathSegment {\n-                        identifier: ast::Ident::with_empty_ctxt(Symbol::intern(\"macro_rules\")),\n-                        parameters: ast::PathParameters::none(),\n-                    }],\n-                },\n-                tts: def.body.clone(),\n-            }\n-        }),\n-        vis: ast::Visibility::Inherited,\n-        span: def.span,\n-    })))\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        mac\n+    }\n }"}, {"sha": "3abd24b50ba9a83baf3473b12d1b5cde2d996eb4", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=421c5d11c1b4bb591bb429577c7b89cba59acefa", "patch": "@@ -10,10 +10,9 @@\n \n use {ast, attr};\n use syntax_pos::{Span, DUMMY_SP};\n-use ext::base::{DummyResult, ExtCtxt, MacEager, MacResult, SyntaxExtension};\n-use ext::base::{IdentMacroExpander, NormalTT, TTMacroExpander};\n+use ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n+use ext::base::{NormalTT, TTMacroExpander};\n use ext::expand::{Expansion, ExpansionKind};\n-use ext::placeholders;\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n@@ -151,35 +150,6 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n     cx.span_fatal(best_fail_spot.substitute_dummy(sp), &best_fail_msg);\n }\n \n-pub struct MacroRulesExpander;\n-impl IdentMacroExpander for MacroRulesExpander {\n-    fn expand(&self,\n-              cx: &mut ExtCtxt,\n-              span: Span,\n-              ident: ast::Ident,\n-              tts: Vec<tokenstream::TokenTree>,\n-              attrs: Vec<ast::Attribute>)\n-              -> Box<MacResult> {\n-        let def = ast::MacroDef {\n-            ident: ident,\n-            id: ast::DUMMY_NODE_ID,\n-            span: span,\n-            body: tts,\n-            attrs: attrs,\n-        };\n-\n-        // If keep_macs is true, expands to a MacEager::items instead.\n-        let result = if cx.ecfg.keep_macs {\n-            MacEager::items(placeholders::reconstructed_macro_rules(&def).make_items())\n-        } else {\n-            MacEager::items(placeholders::macro_scope_placeholder().make_items())\n-        };\n-\n-        cx.resolver.add_macro(cx.current_expansion.mark, def);\n-        result\n-    }\n-}\n-\n // Note that macro-by-example's input is also matched against a token tree:\n //                   $( $lhs:tt => $rhs:tt );+\n //"}, {"sha": "e31b29d5cc1b435270cc4cf9949b7825e0b639f7", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421c5d11c1b4bb591bb429577c7b89cba59acefa/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=421c5d11c1b4bb591bb429577c7b89cba59acefa", "patch": "@@ -50,8 +50,7 @@ pub mod deriving;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier, NamedSyntaxExtension};\n-use syntax::ext::tt::macro_rules::MacroRulesExpander;\n+use syntax::ext::base::{MacroExpanderFn, NormalTT, MultiModifier, NamedSyntaxExtension};\n use syntax::symbol::Symbol;\n \n pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n@@ -61,8 +60,6 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n         resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n \n-    register(Symbol::intern(\"macro_rules\"), IdentTT(Box::new(MacroRulesExpander), None, false));\n-\n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n             register(Symbol::intern(stringify!($name)),"}]}