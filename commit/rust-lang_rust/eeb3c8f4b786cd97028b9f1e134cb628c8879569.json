{"sha": "eeb3c8f4b786cd97028b9f1e134cb628c8879569", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYjNjOGY0Yjc4NmNkOTcwMjhiOWYxZTEzNGNiNjI4Yzg4Nzk1Njk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-01-06T18:06:34Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-08-22T18:23:32Z"}, "message": "Unify `with_task` functions.\n\nRemove with_eval_always_task.", "tree": {"sha": "88d3351576207a4557d8002b66d4514faa4425bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88d3351576207a4557d8002b66d4514faa4425bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeb3c8f4b786cd97028b9f1e134cb628c8879569", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb3c8f4b786cd97028b9f1e134cb628c8879569", "html_url": "https://github.com/rust-lang/rust/commit/eeb3c8f4b786cd97028b9f1e134cb628c8879569", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeb3c8f4b786cd97028b9f1e134cb628c8879569/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2c8707abbedee2587b5653a42e0860a101f0ddf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2c8707abbedee2587b5653a42e0860a101f0ddf", "html_url": "https://github.com/rust-lang/rust/commit/f2c8707abbedee2587b5653a42e0860a101f0ddf"}], "stats": {"total": 179, "additions": 76, "deletions": 103}, "files": [{"sha": "e589d16992f6c22a43dee49c24d421ae17f21c0d", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 69, "deletions": 86, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/eeb3c8f4b786cd97028b9f1e134cb628c8879569/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb3c8f4b786cd97028b9f1e134cb628c8879569/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=eeb3c8f4b786cd97028b9f1e134cb628c8879569", "patch": "@@ -215,24 +215,17 @@ impl<K: DepKind> DepGraph<K> {\n         cx: Ctxt,\n         arg: A,\n         task: fn(Ctxt, A) -> R,\n-        hash_result: impl FnOnce(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n+        hash_result: fn(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex) {\n-        self.with_task_impl(\n-            key,\n-            cx,\n-            arg,\n-            task,\n-            |_key| {\n-                Some(TaskDeps {\n-                    #[cfg(debug_assertions)]\n-                    node: Some(_key),\n-                    reads: SmallVec::new(),\n-                    read_set: Default::default(),\n-                    phantom_data: PhantomData,\n-                })\n-            },\n-            hash_result,\n-        )\n+        if self.is_fully_enabled() {\n+            self.with_task_impl(key, cx, arg, task, hash_result)\n+        } else {\n+            // Incremental compilation is turned off. We just execute the task\n+            // without tracking. We still provide a dep-node index that uniquely\n+            // identifies the task so that we have a cheap way of referring to\n+            // the query for self-profiling.\n+            (task(cx, arg), self.next_virtual_depnode_index())\n+        }\n     }\n \n     fn with_task_impl<Ctxt: HasDepContext<DepKind = K>, A: Debug, R>(\n@@ -241,71 +234,74 @@ impl<K: DepKind> DepGraph<K> {\n         cx: Ctxt,\n         arg: A,\n         task: fn(Ctxt, A) -> R,\n-        create_task: fn(DepNode<K>) -> Option<TaskDeps<K>>,\n-        hash_result: impl FnOnce(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n+        hash_result: fn(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex) {\n-        if let Some(ref data) = self.data {\n-            // If the following assertion triggers, it can have two reasons:\n-            // 1. Something is wrong with DepNode creation, either here or\n-            //    in `DepGraph::try_mark_green()`.\n-            // 2. Two distinct query keys get mapped to the same `DepNode`\n-            //    (see for example #48923).\n-            assert!(\n-                !self.dep_node_exists(&key),\n-                \"forcing query with already existing `DepNode`\\n\\\n+        // This function is only called when the graph is enabled.\n+        let data = self.data.as_ref().unwrap();\n+\n+        // If the following assertion triggers, it can have two reasons:\n+        // 1. Something is wrong with DepNode creation, either here or\n+        //    in `DepGraph::try_mark_green()`.\n+        // 2. Two distinct query keys get mapped to the same `DepNode`\n+        //    (see for example #48923).\n+        assert!(\n+            !self.dep_node_exists(&key),\n+            \"forcing query with already existing `DepNode`\\n\\\n                  - query-key: {:?}\\n\\\n                  - dep-node: {:?}\",\n-                arg,\n-                key\n-            );\n+            arg,\n+            key\n+        );\n \n-            let dcx = cx.dep_context();\n-            let task_deps = create_task(key).map(Lock::new);\n-            let result = K::with_deps(task_deps.as_ref(), || task(cx, arg));\n-            let edges = task_deps.map_or_else(|| smallvec![], |lock| lock.into_inner().reads);\n-\n-            let mut hcx = dcx.create_stable_hashing_context();\n-            let hashing_timer = dcx.profiler().incr_result_hashing();\n-            let current_fingerprint = hash_result(&mut hcx, &result);\n-\n-            let print_status = cfg!(debug_assertions) && dcx.sess().opts.debugging_opts.dep_tasks;\n-\n-            // Get timer for profiling `DepNode` interning\n-            let node_intern_timer = self\n-                .node_intern_event_id\n-                .map(|eid| dcx.profiler().generic_activity_with_event_id(eid));\n-            // Intern the new `DepNode`.\n-            let (dep_node_index, prev_and_color) = data.current.intern_node(\n-                dcx.profiler(),\n-                &data.previous,\n-                key,\n-                edges,\n-                current_fingerprint,\n-                print_status,\n-            );\n-            drop(node_intern_timer);\n+        let task_deps = if key.kind.is_eval_always() {\n+            None\n+        } else {\n+            Some(Lock::new(TaskDeps {\n+                #[cfg(debug_assertions)]\n+                node: Some(key),\n+                reads: SmallVec::new(),\n+                read_set: Default::default(),\n+                phantom_data: PhantomData,\n+            }))\n+        };\n+        let result = K::with_deps(task_deps.as_ref(), || task(cx, arg));\n+        let edges = task_deps.map_or_else(|| smallvec![], |lock| lock.into_inner().reads);\n+\n+        let dcx = cx.dep_context();\n+        let mut hcx = dcx.create_stable_hashing_context();\n+        let hashing_timer = dcx.profiler().incr_result_hashing();\n+        let current_fingerprint = hash_result(&mut hcx, &result);\n+\n+        let print_status = cfg!(debug_assertions) && dcx.sess().opts.debugging_opts.dep_tasks;\n+\n+        // Get timer for profiling `DepNode` interning\n+        let node_intern_timer =\n+            self.node_intern_event_id.map(|eid| dcx.profiler().generic_activity_with_event_id(eid));\n+        // Intern the new `DepNode`.\n+        let (dep_node_index, prev_and_color) = data.current.intern_node(\n+            dcx.profiler(),\n+            &data.previous,\n+            key,\n+            edges,\n+            current_fingerprint,\n+            print_status,\n+        );\n+        drop(node_intern_timer);\n \n-            hashing_timer.finish_with_query_invocation_id(dep_node_index.into());\n+        hashing_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n-            if let Some((prev_index, color)) = prev_and_color {\n-                debug_assert!(\n-                    data.colors.get(prev_index).is_none(),\n-                    \"DepGraph::with_task() - Duplicate DepNodeColor \\\n+        if let Some((prev_index, color)) = prev_and_color {\n+            debug_assert!(\n+                data.colors.get(prev_index).is_none(),\n+                \"DepGraph::with_task() - Duplicate DepNodeColor \\\n                             insertion for {:?}\",\n-                    key\n-                );\n-\n-                data.colors.insert(prev_index, color);\n-            }\n+                key\n+            );\n \n-            (result, dep_node_index)\n-        } else {\n-            // Incremental compilation is turned off. We just execute the task\n-            // without tracking. We still provide a dep-node index that uniquely\n-            // identifies the task so that we have a cheap way of referring to\n-            // the query for self-profiling.\n-            (task(cx, arg), self.next_virtual_depnode_index())\n+            data.colors.insert(prev_index, color);\n         }\n+\n+        (result, dep_node_index)\n     }\n \n     /// Executes something within an \"anonymous\" task, that is, a task the\n@@ -372,19 +368,6 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n-    /// Executes something within an \"eval-always\" task which is a task\n-    /// that runs whenever anything changes.\n-    pub fn with_eval_always_task<Ctxt: HasDepContext<DepKind = K>, A: Debug, R>(\n-        &self,\n-        key: DepNode<K>,\n-        cx: Ctxt,\n-        arg: A,\n-        task: fn(Ctxt, A) -> R,\n-        hash_result: impl FnOnce(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n-    ) -> (R, DepNodeIndex) {\n-        self.with_task_impl(key, cx, arg, task, |_| None, hash_result)\n-    }\n-\n     #[inline]\n     pub fn read_index(&self, dep_node_index: DepNodeIndex) {\n         if let Some(ref data) = self.data {"}, {"sha": "32cf724c6d70b71aa4e3605eb84616596c801541", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eeb3c8f4b786cd97028b9f1e134cb628c8879569/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb3c8f4b786cd97028b9f1e134cb628c8879569/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=eeb3c8f4b786cd97028b9f1e134cb628c8879569", "patch": "@@ -491,23 +491,13 @@ where\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node = dep_node_opt.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n \n-        if query.eval_always {\n-            tcx.dep_context().dep_graph().with_eval_always_task(\n-                dep_node,\n-                *tcx.dep_context(),\n-                key,\n-                compute,\n-                query.hash_result,\n-            )\n-        } else {\n-            tcx.dep_context().dep_graph().with_task(\n-                dep_node,\n-                *tcx.dep_context(),\n-                key,\n-                compute,\n-                query.hash_result,\n-            )\n-        }\n+        tcx.dep_context().dep_graph().with_task(\n+            dep_node,\n+            *tcx.dep_context(),\n+            key,\n+            compute,\n+            query.hash_result,\n+        )\n     });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());"}]}