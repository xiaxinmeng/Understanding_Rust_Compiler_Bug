{"sha": "ffb04ae32de66ca9d12646e5e559ec8ff318c8b1", "node_id": "C_kwDOAAsO6NoAKGZmYjA0YWUzMmRlNjZjYTlkMTI2NDZlNWU1NTllYzhmZjMxOGM4YjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-01T05:19:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-01T05:19:36Z"}, "message": "Auto merge of #14461 - HKalbasi:dev, r=Veykril\n\nUse async block in async fn type inference\n\nfix #14456\n\nAt some point we should probably go further and completely desugar async fn in hir lowering.", "tree": {"sha": "d277042850210b4b547f5845c28f7d7f7428cd39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d277042850210b4b547f5845c28f7d7f7428cd39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1", "html_url": "https://github.com/rust-lang/rust/commit/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "853fb44a24b8d3341f52747caa949013121b24b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/853fb44a24b8d3341f52747caa949013121b24b4", "html_url": "https://github.com/rust-lang/rust/commit/853fb44a24b8d3341f52747caa949013121b24b4"}, {"sha": "8a6ca86247c227ba27fb38470c1ca7ddc9ceb511", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a6ca86247c227ba27fb38470c1ca7ddc9ceb511", "html_url": "https://github.com/rust-lang/rust/commit/8a6ca86247c227ba27fb38470c1ca7ddc9ceb511"}], "stats": {"total": 125, "additions": 68, "deletions": 57}, "files": [{"sha": "431140a665d70d006345e1034618a5210533340f", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=ffb04ae32de66ca9d12646e5e559ec8ff318c8b1", "patch": "@@ -30,7 +30,6 @@ pub struct FunctionData {\n     pub name: Name,\n     pub params: Vec<(Option<Name>, Interned<TypeRef>)>,\n     pub ret_type: Interned<TypeRef>,\n-    pub async_ret_type: Option<Interned<TypeRef>>,\n     pub attrs: Attrs,\n     pub visibility: RawVisibility,\n     pub abi: Option<Interned<str>>,\n@@ -104,7 +103,6 @@ impl FunctionData {\n                 })\n                 .collect(),\n             ret_type: func.ret_type.clone(),\n-            async_ret_type: func.async_ret_type.clone(),\n             attrs: item_tree.attrs(db, krate, ModItem::from(loc.id.value).into()),\n             visibility,\n             abi: func.abi.clone(),"}, {"sha": "d5b973751dd1590cd8b229777bfcbb808d0dbf29", "filename": "crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=ffb04ae32de66ca9d12646e5e559ec8ff318c8b1", "patch": "@@ -608,7 +608,6 @@ pub struct Function {\n     pub abi: Option<Interned<str>>,\n     pub params: IdxRange<Param>,\n     pub ret_type: Interned<TypeRef>,\n-    pub async_ret_type: Option<Interned<TypeRef>>,\n     pub ast_id: FileAstId<ast::Fn>,\n     pub(crate) flags: FnFlags,\n }"}, {"sha": "5bbf8e52e8b6bccc84242eebff1693829ab39fca", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=ffb04ae32de66ca9d12646e5e559ec8ff318c8b1", "patch": "@@ -364,13 +364,12 @@ impl<'a> Ctx<'a> {\n             None => TypeRef::unit(),\n         };\n \n-        let (ret_type, async_ret_type) = if func.async_token().is_some() {\n-            let async_ret_type = ret_type.clone();\n+        let ret_type = if func.async_token().is_some() {\n             let future_impl = desugar_future_path(ret_type);\n             let ty_bound = Interned::new(TypeBound::Path(future_impl, TraitBoundModifier::None));\n-            (TypeRef::ImplTrait(vec![ty_bound]), Some(async_ret_type))\n+            TypeRef::ImplTrait(vec![ty_bound])\n         } else {\n-            (ret_type, None)\n+            ret_type\n         };\n \n         let abi = func.abi().map(lower_abi);\n@@ -404,7 +403,6 @@ impl<'a> Ctx<'a> {\n             abi,\n             params,\n             ret_type: Interned::new(ret_type),\n-            async_ret_type: async_ret_type.map(Interned::new),\n             ast_id,\n             flags,\n         };"}, {"sha": "edd5c3b1151d0ca8bc898495016c83502b2714c9", "filename": "crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=ffb04ae32de66ca9d12646e5e559ec8ff318c8b1", "patch": "@@ -233,7 +233,6 @@ impl<'a> Printer<'a> {\n                     abi,\n                     params,\n                     ret_type,\n-                    async_ret_type: _,\n                     ast_id: _,\n                     flags,\n                 } = &self.tree[it];"}, {"sha": "08ba80cdfffd966cda50ec442459bbd82f5ca7c9", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=ffb04ae32de66ca9d12646e5e559ec8ff318c8b1", "patch": "@@ -459,6 +459,7 @@ pub(crate) struct InferenceContext<'a> {\n     resume_yield_tys: Option<(Ty, Ty)>,\n     diverges: Diverges,\n     breakables: Vec<BreakableContext>,\n+    is_async_fn: bool,\n }\n \n #[derive(Clone, Debug)]\n@@ -526,6 +527,7 @@ impl<'a> InferenceContext<'a> {\n             resolver,\n             diverges: Diverges::Maybe,\n             breakables: Vec::new(),\n+            is_async_fn: false,\n         }\n     }\n \n@@ -636,12 +638,10 @@ impl<'a> InferenceContext<'a> {\n \n             self.infer_top_pat(*pat, &ty);\n         }\n-        let error_ty = &TypeRef::Error;\n-        let return_ty = if data.has_async_kw() {\n-            data.async_ret_type.as_deref().unwrap_or(error_ty)\n-        } else {\n-            &*data.ret_type\n-        };\n+        let return_ty = &*data.ret_type;\n+        if data.has_async_kw() {\n+            self.is_async_fn = true;\n+        }\n \n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver)\n             .with_impl_trait_mode(ImplTraitLoweringMode::Opaque);"}, {"sha": "23ef32db22774e209de355535919a376f519f730", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 45, "deletions": 42, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=ffb04ae32de66ca9d12646e5e559ec8ff318c8b1", "patch": "@@ -162,35 +162,7 @@ impl<'a> InferenceContext<'a> {\n                 .1\n             }\n             Expr::Async { id, statements, tail } => {\n-                let ret_ty = self.table.new_type_var();\n-                let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n-                let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n-                let prev_ret_coercion =\n-                    mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty.clone())));\n-\n-                let (_, inner_ty) =\n-                    self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n-                        this.infer_block(\n-                            tgt_expr,\n-                            *id,\n-                            statements,\n-                            *tail,\n-                            None,\n-                            &Expectation::has_type(ret_ty),\n-                        )\n-                    });\n-\n-                self.diverges = prev_diverges;\n-                self.return_ty = prev_ret_ty;\n-                self.return_coercion = prev_ret_coercion;\n-\n-                // Use the first type parameter as the output type of future.\n-                // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n-                let impl_trait_id =\n-                    crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, tgt_expr);\n-                let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n-                TyKind::OpaqueType(opaque_ty_id, Substitution::from1(Interner, inner_ty))\n-                    .intern(Interner)\n+                self.infer_async_block(tgt_expr, id, statements, tail)\n             }\n             &Expr::Loop { body, label } => {\n                 // FIXME: should be:\n@@ -260,18 +232,7 @@ impl<'a> InferenceContext<'a> {\n                     None => self.table.new_type_var(),\n                 };\n                 if let ClosureKind::Async = closure_kind {\n-                    // Use the first type parameter as the output type of future.\n-                    // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n-                    let impl_trait_id =\n-                        crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, *body);\n-                    let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n-                    sig_tys.push(\n-                        TyKind::OpaqueType(\n-                            opaque_ty_id,\n-                            Substitution::from1(Interner, ret_ty.clone()),\n-                        )\n-                        .intern(Interner),\n-                    );\n+                    sig_tys.push(self.lower_async_block_type_impl_trait(ret_ty.clone(), *body));\n                 } else {\n                     sig_tys.push(ret_ty.clone());\n                 }\n@@ -332,6 +293,7 @@ impl<'a> InferenceContext<'a> {\n \n                 // FIXME: lift these out into a struct\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                let prev_is_async_fn = mem::replace(&mut self.is_async_fn, false);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n                 let prev_ret_coercion =\n                     mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty)));\n@@ -345,6 +307,7 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n                 self.return_coercion = prev_ret_coercion;\n+                self.is_async_fn = prev_is_async_fn;\n                 self.resume_yield_tys = prev_resume_yield_tys;\n \n                 ty\n@@ -900,6 +863,42 @@ impl<'a> InferenceContext<'a> {\n         ty\n     }\n \n+    fn infer_async_block(\n+        &mut self,\n+        tgt_expr: ExprId,\n+        id: &Option<BlockId>,\n+        statements: &[Statement],\n+        tail: &Option<ExprId>,\n+    ) -> Ty {\n+        let ret_ty = self.table.new_type_var();\n+        let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+        let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n+        let prev_ret_coercion =\n+            mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty.clone())));\n+\n+        let (_, inner_ty) = self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n+            this.infer_block(tgt_expr, *id, statements, *tail, None, &Expectation::has_type(ret_ty))\n+        });\n+\n+        self.diverges = prev_diverges;\n+        self.return_ty = prev_ret_ty;\n+        self.return_coercion = prev_ret_coercion;\n+\n+        self.lower_async_block_type_impl_trait(inner_ty, tgt_expr)\n+    }\n+\n+    pub(crate) fn lower_async_block_type_impl_trait(\n+        &mut self,\n+        inner_ty: Ty,\n+        tgt_expr: ExprId,\n+    ) -> Ty {\n+        // Use the first type parameter as the output type of future.\n+        // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n+        let impl_trait_id = crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, tgt_expr);\n+        let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n+        TyKind::OpaqueType(opaque_ty_id, Substitution::from1(Interner, inner_ty)).intern(Interner)\n+    }\n+\n     fn infer_expr_array(\n         &mut self,\n         array: &Array,\n@@ -964,7 +963,11 @@ impl<'a> InferenceContext<'a> {\n             .as_mut()\n             .expect(\"infer_return called outside function body\")\n             .expected_ty();\n-        let return_expr_ty = self.infer_expr_inner(expr, &Expectation::HasType(ret_ty));\n+        let return_expr_ty = if self.is_async_fn {\n+            self.infer_async_block(expr, &None, &[], &Some(expr))\n+        } else {\n+            self.infer_expr_inner(expr, &Expectation::HasType(ret_ty))\n+        };\n         let mut coerce_many = self.return_coercion.take().unwrap();\n         coerce_many.coerce(self, Some(expr), &return_expr_ty);\n         self.return_coercion = Some(coerce_many);"}, {"sha": "8911dd318c41478e6467cbb2f2c7de671c22d581", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb04ae32de66ca9d12646e5e559ec8ff318c8b1/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=ffb04ae32de66ca9d12646e5e559ec8ff318c8b1", "patch": "@@ -1757,6 +1757,20 @@ const C: usize = 2 + 2;\n     );\n }\n \n+#[test]\n+fn regression_14456() {\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: future\n+async fn x() {}\n+fn f() {\n+    let fut = x();\n+    let t = [0u8; 2 + 2];\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn regression_14164() {\n     check_types("}]}