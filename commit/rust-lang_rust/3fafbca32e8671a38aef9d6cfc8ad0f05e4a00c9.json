{"sha": "3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9", "node_id": "C_kwDOAAsO6NoAKDNmYWZiY2EzMmU4NjcxYTM4YWVmOWQ2Y2ZjOGFkMGYwNWU0YTAwYzk", "commit": {"author": {"name": "Morgan Thomas", "email": "corp@m0rg.dev", "date": "2022-03-12T16:44:37Z"}, "committer": {"name": "Morgan Thomas", "email": "corp@m0rg.dev", "date": "2022-03-12T16:54:06Z"}, "message": "fix: \"Extract to function\" assist preserves `break` and `continue` labels\n\nAdds a label / lifetime parameter to `ide_assists::handlers::extract_function::FlowKind::{Break, Continue}`, adds support for emitting labels to `syntax::ast::make::{expr_break, expr_continue}`, and implements the required machinery to let `extract_function` make use of them.\n\nThis does modify the external API of the `syntax` crate, but the changes there are simple, not used outside `ide_assists`, and, well, we should probably support emitting `break` and `continue` labels through `syntax` anyways, they're part of the language spec.\n\nCloses #11413.", "tree": {"sha": "0dca2e2bc084cf0cba0ab6906885be4f3c312d60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dca2e2bc084cf0cba0ab6906885be4f3c312d60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9", "html_url": "https://github.com/rust-lang/rust/commit/3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9/comments", "author": {"login": "m0rg-dev", "id": 38578268, "node_id": "MDQ6VXNlcjM4NTc4MjY4", "avatar_url": "https://avatars.githubusercontent.com/u/38578268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m0rg-dev", "html_url": "https://github.com/m0rg-dev", "followers_url": "https://api.github.com/users/m0rg-dev/followers", "following_url": "https://api.github.com/users/m0rg-dev/following{/other_user}", "gists_url": "https://api.github.com/users/m0rg-dev/gists{/gist_id}", "starred_url": "https://api.github.com/users/m0rg-dev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m0rg-dev/subscriptions", "organizations_url": "https://api.github.com/users/m0rg-dev/orgs", "repos_url": "https://api.github.com/users/m0rg-dev/repos", "events_url": "https://api.github.com/users/m0rg-dev/events{/privacy}", "received_events_url": "https://api.github.com/users/m0rg-dev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m0rg-dev", "id": 38578268, "node_id": "MDQ6VXNlcjM4NTc4MjY4", "avatar_url": "https://avatars.githubusercontent.com/u/38578268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m0rg-dev", "html_url": "https://github.com/m0rg-dev", "followers_url": "https://api.github.com/users/m0rg-dev/followers", "following_url": "https://api.github.com/users/m0rg-dev/following{/other_user}", "gists_url": "https://api.github.com/users/m0rg-dev/gists{/gist_id}", "starred_url": "https://api.github.com/users/m0rg-dev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m0rg-dev/subscriptions", "organizations_url": "https://api.github.com/users/m0rg-dev/orgs", "repos_url": "https://api.github.com/users/m0rg-dev/repos", "events_url": "https://api.github.com/users/m0rg-dev/events{/privacy}", "received_events_url": "https://api.github.com/users/m0rg-dev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fcf979f8a09e6504bbe540cbff6d640b959935c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fcf979f8a09e6504bbe540cbff6d640b959935c", "html_url": "https://github.com/rust-lang/rust/commit/5fcf979f8a09e6504bbe540cbff6d640b959935c"}], "stats": {"total": 172, "additions": 146, "deletions": 26}, "files": [{"sha": "445567b7f90af277f5f0c430bd8a32b8f6b1512c", "filename": "crates/ide_assists/src/handlers/convert_to_guarded_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs?ref=3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9", "patch": "@@ -97,7 +97,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n     let parent_container = parent_block.syntax().parent()?;\n \n     let early_expression: ast::Expr = match parent_container.kind() {\n-        WHILE_EXPR | LOOP_EXPR => make::expr_continue(),\n+        WHILE_EXPR | LOOP_EXPR => make::expr_continue(None),\n         FN => make::expr_return(None),\n         _ => return None,\n     };"}, {"sha": "739097067d0ac36225beae9cfda1269bceed0699", "filename": "crates/ide_assists/src/handlers/convert_while_to_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_while_to_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_while_to_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_while_to_loop.rs?ref=3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn convert_while_to_loop(acc: &mut Assists, ctx: &AssistContext) -> O\n             let while_indent_level = IndentLevel::from_node(while_expr.syntax());\n \n             let break_block =\n-                make::block_expr(once(make::expr_stmt(make::expr_break(None)).into()), None)\n+                make::block_expr(once(make::expr_stmt(make::expr_break(None, None)).into()), None)\n                     .indent(while_indent_level);\n             let block_expr = if is_pattern_cond(while_cond.clone()) {\n                 let if_expr = make::expr_if(while_cond, while_body, Some(break_block.into()));"}, {"sha": "53cdeaaf925475c7cd4b8e3147bbe79b368282d4", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 128, "deletions": 18, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9", "patch": "@@ -287,10 +287,10 @@ enum FlowKind {\n     Try {\n         kind: TryKind,\n     },\n-    /// Break with value (`break $expr;`)\n-    Break(Option<ast::Expr>),\n-    /// Continue\n-    Continue,\n+    /// Break with label and value (`break 'label $expr;`)\n+    Break(Option<ast::Lifetime>, Option<ast::Expr>),\n+    /// Continue with label (`continue 'label;`)\n+    Continue(Option<ast::Lifetime>),\n }\n \n #[derive(Debug, Clone)]\n@@ -433,21 +433,21 @@ impl FlowKind {\n     fn make_result_handler(&self, expr: Option<ast::Expr>) -> ast::Expr {\n         match self {\n             FlowKind::Return(_) => make::expr_return(expr),\n-            FlowKind::Break(_) => make::expr_break(expr),\n+            FlowKind::Break(label, _) => make::expr_break(label.clone(), expr),\n             FlowKind::Try { .. } => {\n                 stdx::never!(\"cannot have result handler with try\");\n                 expr.unwrap_or_else(|| make::expr_return(None))\n             }\n-            FlowKind::Continue => {\n+            FlowKind::Continue(label) => {\n                 stdx::always!(expr.is_none(), \"continue with value is not possible\");\n-                make::expr_continue()\n+                make::expr_continue(label.clone())\n             }\n         }\n     }\n \n     fn expr_ty(&self, ctx: &AssistContext) -> Option<hir::Type> {\n         match self {\n-            FlowKind::Return(Some(expr)) | FlowKind::Break(Some(expr)) => {\n+            FlowKind::Return(Some(expr)) | FlowKind::Break(_, Some(expr)) => {\n                 ctx.sema.type_of_expr(expr).map(TypeInfo::adjusted)\n             }\n             FlowKind::Try { .. } => {\n@@ -839,8 +839,8 @@ impl FunctionBody {\n                 cov_mark::hit!(external_control_flow_break_and_continue);\n                 return None;\n             }\n-            (None, None, Some(b), None) => Some(FlowKind::Break(b.expr())),\n-            (None, None, None, Some(_)) => Some(FlowKind::Continue),\n+            (None, None, Some(b), None) => Some(FlowKind::Break(b.lifetime(), b.expr())),\n+            (None, None, None, Some(c)) => Some(FlowKind::Continue(c.lifetime())),\n             (None, None, None, None) => None,\n         };\n \n@@ -1185,20 +1185,20 @@ impl FlowHandler {\n                 let action = flow_kind.clone();\n                 if *ret_ty == FunType::Unit {\n                     match flow_kind {\n-                        FlowKind::Return(None) | FlowKind::Break(None) | FlowKind::Continue => {\n-                            FlowHandler::If { action }\n-                        }\n-                        FlowKind::Return(_) | FlowKind::Break(_) => {\n+                        FlowKind::Return(None)\n+                        | FlowKind::Break(_, None)\n+                        | FlowKind::Continue(_) => FlowHandler::If { action },\n+                        FlowKind::Return(_) | FlowKind::Break(_, _) => {\n                             FlowHandler::IfOption { action }\n                         }\n                         FlowKind::Try { kind } => FlowHandler::Try { kind: kind.clone() },\n                     }\n                 } else {\n                     match flow_kind {\n-                        FlowKind::Return(None) | FlowKind::Break(None) | FlowKind::Continue => {\n-                            FlowHandler::MatchOption { none: action }\n-                        }\n-                        FlowKind::Return(_) | FlowKind::Break(_) => {\n+                        FlowKind::Return(None)\n+                        | FlowKind::Break(_, None)\n+                        | FlowKind::Continue(_) => FlowHandler::MatchOption { none: action },\n+                        FlowKind::Return(_) | FlowKind::Break(_, _) => {\n                             FlowHandler::MatchResult { err: action }\n                         }\n                         FlowKind::Try { kind } => FlowHandler::Try { kind: kind.clone() },\n@@ -3404,6 +3404,76 @@ fn $0fun_name(n: i32) -> ControlFlow<()> {\n         );\n     }\n \n+    #[test]\n+    fn break_loop_nested_labeled() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+//- minicore: try\n+fn foo() {\n+    'bar: loop {\n+        loop {\n+            $0break 'bar;$0\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+use core::ops::ControlFlow;\n+\n+fn foo() {\n+    'bar: loop {\n+        loop {\n+            if let ControlFlow::Break(_) = fun_name() {\n+                break 'bar;\n+            }\n+        }\n+    }\n+}\n+\n+fn $0fun_name() -> ControlFlow<()> {\n+    return ControlFlow::Break(());\n+    ControlFlow::Continue(())\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn continue_loop_nested_labeled() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+//- minicore: try\n+fn foo() {\n+    'bar: loop {\n+        loop {\n+            $0continue 'bar;$0\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+use core::ops::ControlFlow;\n+\n+fn foo() {\n+    'bar: loop {\n+        loop {\n+            if let ControlFlow::Break(_) = fun_name() {\n+                continue 'bar;\n+            }\n+        }\n+    }\n+}\n+\n+fn $0fun_name() -> ControlFlow<()> {\n+    return ControlFlow::Break(());\n+    ControlFlow::Continue(())\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn return_from_nested_loop() {\n         check_assist(\n@@ -3608,6 +3678,46 @@ fn $0fun_name() -> Option<i32> {\n         );\n     }\n \n+    #[test]\n+    fn break_with_value_and_label() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() -> i32 {\n+    'bar: loop {\n+        let n = 1;\n+        $0let k = 1;\n+        if k == 42 {\n+            break 'bar 3;\n+        }\n+        let m = k + 1;$0\n+        let h = 1;\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> i32 {\n+    'bar: loop {\n+        let n = 1;\n+        if let Some(value) = fun_name() {\n+            break 'bar value;\n+        }\n+        let h = 1;\n+    }\n+}\n+\n+fn $0fun_name() -> Option<i32> {\n+    let k = 1;\n+    if k == 42 {\n+        return Some(4);\n+    }\n+    let m = k + 1;\n+    None\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn break_with_value_and_return() {\n         check_assist("}, {"sha": "d11d658a27313de53da71bd23d4270e579246e74", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=3fafbca32e8671a38aef9d6cfc8ad0f05e4a00c9", "patch": "@@ -368,18 +368,28 @@ pub fn expr_empty_block() -> ast::Expr {\n pub fn expr_path(path: ast::Path) -> ast::Expr {\n     expr_from_text(&path.to_string())\n }\n-pub fn expr_continue() -> ast::Expr {\n-    expr_from_text(\"continue\")\n+pub fn expr_continue(label: Option<ast::Lifetime>) -> ast::Expr {\n+    match label {\n+        Some(label) => expr_from_text(&format!(\"continue {}\", label)),\n+        None => expr_from_text(\"continue\"),\n+    }\n }\n // Consider `op: SyntaxKind` instead for nicer syntax at the call-site?\n pub fn expr_bin_op(lhs: ast::Expr, op: ast::BinaryOp, rhs: ast::Expr) -> ast::Expr {\n     expr_from_text(&format!(\"{} {} {}\", lhs, op, rhs))\n }\n-pub fn expr_break(expr: Option<ast::Expr>) -> ast::Expr {\n-    match expr {\n-        Some(expr) => expr_from_text(&format!(\"break {}\", expr)),\n-        None => expr_from_text(\"break\"),\n+pub fn expr_break(label: Option<ast::Lifetime>, expr: Option<ast::Expr>) -> ast::Expr {\n+    let mut s = String::from(\"break\");\n+\n+    if let Some(label) = label {\n+        format_to!(s, \" {}\", label);\n     }\n+\n+    if let Some(expr) = expr {\n+        format_to!(s, \" {}\", expr);\n+    }\n+\n+    expr_from_text(&s)\n }\n pub fn expr_return(expr: Option<ast::Expr>) -> ast::Expr {\n     match expr {"}]}