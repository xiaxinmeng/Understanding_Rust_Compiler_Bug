{"sha": "3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYzgzMDRmZDkyNzIwYzY4OGYzZDZhYzMwYjNhNzI4ZDE1ZjdhMzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-06T05:34:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-06T05:34:25Z"}, "message": "Auto merge of #37597 - alexcrichton:rollup, r=alexcrichton\n\nRollup of 24 pull requests\n\n- Successful merges: #37255, #37317, #37408, #37410, #37422, #37427, #37470, #37501, #37537, #37556, #37557, #37564, #37565, #37566, #37569, #37574, #37577, #37579, #37583, #37585, #37586, #37587, #37589, #37596\n- Failed merges: #37521, #37547", "tree": {"sha": "0ca0e95b5fee227e04f04bfaa4443bdd4a3ae3e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ca0e95b5fee227e04f04bfaa4443bdd4a3ae3e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "html_url": "https://github.com/rust-lang/rust/commit/3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cae6ab1c458ade22b4c228fcd4195917c96e2465", "url": "https://api.github.com/repos/rust-lang/rust/commits/cae6ab1c458ade22b4c228fcd4195917c96e2465", "html_url": "https://github.com/rust-lang/rust/commit/cae6ab1c458ade22b4c228fcd4195917c96e2465"}, {"sha": "bdacb63f5a93b7359e2d2b6d877f2841032d2ed2", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdacb63f5a93b7359e2d2b6d877f2841032d2ed2", "html_url": "https://github.com/rust-lang/rust/commit/bdacb63f5a93b7359e2d2b6d877f2841032d2ed2"}], "stats": {"total": 7332, "additions": 4360, "deletions": 2972}, "files": [{"sha": "7360651095bb581d01a575b071c7a91ba8db7585", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -127,7 +127,7 @@ ones from MSYS if you have it installed). You'll also need Visual Studio 2013 or\n newer with the C++ tools. Then all you need to do is to kick off rustbuild.\n \n ```\n-python .\\src\\bootstrap\\bootstrap.py\n+python x.py build\n ```\n \n Currently rustbuild only works with some known versions of Visual Studio. If you\n@@ -137,7 +137,7 @@ by manually calling the appropriate vcvars file before running the bootstrap.\n \n ```\n CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.bat\"\n-python .\\src\\bootstrap\\bootstrap.py\n+python x.py build\n ```\n \n ## Building Documentation"}, {"sha": "222ad3aa112af8e93b0ffd713f0aa5fd605adee6", "filename": "RELEASES.md", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1,3 +1,30 @@\n+Version 1.12.1 (2016-10-20)\n+===========================\n+\n+Regression Fixes\n+----------------\n+\n+* [ICE: 'rustc' panicked at 'assertion failed: concrete_substs.is_normalized_for_trans()' #36381][36381]\n+* [Confusion with double negation and booleans][36856]\n+* [rustc 1.12.0 fails with SIGSEGV in release mode (syn crate 0.8.0)][36875]\n+* [Rustc 1.12.0 Windows build of `ethcore` crate fails with LLVM error][36924]\n+* [1.12.0: High memory usage when linking in release mode with debug info][36926]\n+* [Corrupted memory after updated to 1.12][36936]\n+* [\"Let NullaryConstructor = something;\" causes internal compiler error: \"tried to overwrite interned AdtDef\"][37026]\n+* [Fix ICE: inject bitcast if types mismatch for invokes/calls/stores][37112]\n+* [debuginfo: Handle spread_arg case in MIR-trans in a more stable way.][37153]\n+\n+[36381]: https://github.com/rust-lang/rust/issues/36381\n+[36856]: https://github.com/rust-lang/rust/issues/36856\n+[36875]: https://github.com/rust-lang/rust/issues/36875\n+[36924]: https://github.com/rust-lang/rust/issues/36924\n+[36926]: https://github.com/rust-lang/rust/issues/36926\n+[36936]: https://github.com/rust-lang/rust/issues/36936\n+[37026]: https://github.com/rust-lang/rust/issues/37026\n+[37112]: https://github.com/rust-lang/rust/issues/37112\n+[37153]: https://github.com/rust-lang/rust/issues/37153\n+\n+\n Version 1.12.0 (2016-09-29)\n ===========================\n "}, {"sha": "85a3dd4b934848bc9fcf9764a5f7aaf685e5cf15", "filename": "configure", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/configure", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -868,13 +868,6 @@ then\n     fi\n fi\n \n-if [ -n \"$CFG_GDB\" ]\n-then\n-    # Store GDB's version\n-    CFG_GDB_VERSION=$($CFG_GDB --version 2>/dev/null | head -1)\n-    putvar CFG_GDB_VERSION\n-fi\n-\n if [ -n \"$CFG_LLDB\" ]\n then\n     # Store LLDB's version"}, {"sha": "2fa8ccf3621e0c1f59ec2d9cc549af603b82158a", "filename": "mk/main.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -372,7 +372,7 @@ CFG_INFO := $(info cfg: disabling unstable features (CFG_DISABLE_UNSTABLE_FEATUR\n # Turn on feature-staging\n export CFG_DISABLE_UNSTABLE_FEATURES\n # Subvert unstable feature lints to do the self-build\n-export RUSTC_BOOTSTRAP\n+export RUSTC_BOOTSTRAP=1\n endif\n ifdef CFG_MUSL_ROOT\n export CFG_MUSL_ROOT"}, {"sha": "f3d8f0387bbd6367bcacdd7576ede0b576b564bb", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -648,7 +648,7 @@ CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3) = \\\n         --host $(3) \\\n \t--docck-python $$(CFG_PYTHON) \\\n \t--lldb-python $$(CFG_LLDB_PYTHON) \\\n-        --gdb-version=\"$(CFG_GDB_VERSION)\" \\\n+        --gdb=\"$(CFG_GDB)\" \\\n         --lldb-version=\"$(CFG_LLDB_VERSION)\" \\\n         --llvm-version=\"$$(LLVM_VERSION_$(3))\" \\\n         --android-cross-path=$(CFG_ARM_LINUX_ANDROIDEABI_NDK) \\"}, {"sha": "c3a8923c6de5671bfc1439ca3e38a612d4eaeb77", "filename": "src/Cargo.lock", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -40,9 +40,9 @@ name = \"bootstrap\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.38 (git+https://github.com/alexcrichton/gcc-rs)\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -63,7 +63,7 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cmake\"\n-version = \"0.1.17\"\n+version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -131,11 +131,6 @@ dependencies = [\n name = \"fmt_macros\"\n version = \"0.0.0\"\n \n-[[package]]\n-name = \"gcc\"\n-version = \"0.3.38\"\n-source = \"git+https://github.com/alexcrichton/gcc-rs#be620ac6d3ddb498cd0c700d5312c6a4c3c19597\"\n-\n [[package]]\n name = \"gcc\"\n version = \"0.3.38\"\n@@ -189,7 +184,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"linkchecker\"\n version = \"0.1.0\"\n dependencies = [\n- \"url 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -725,7 +720,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"url\"\n-version = \"1.2.2\"\n+version = \"1.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"idna 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -743,10 +738,9 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [metadata]\n-\"checksum cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dfcf5bcece56ef953b8ea042509e9dcbdfe97820b7e20d86beb53df30ed94978\"\n+\"checksum cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e5bcf27e097a184c1df4437654ed98df3d7a516e8508a6ba45d8b092bbdf283\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum gcc 0.3.38 (git+https://github.com/alexcrichton/gcc-rs)\" = \"<none>\"\n \"checksum gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\" = \"553f11439bdefe755bf366b264820f1da70f3aaf3924e594b886beb9c831bcf5\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n \"checksum idna 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1053236e00ce4f668aeca4a769a09b3bf5a682d802abd6f3cb39374f6b162c11\"\n@@ -760,6 +754,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0590d72182e50e879c4da3b11c6488dae18fccb1ae0c7a3eda18e16795844796\"\n \"checksum unicode-bidi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c1f7ceb96afdfeedee42bade65a0d585a6a0106f681b6749c8ff4daa8df30b3f\"\n \"checksum unicode-normalization 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"26643a2f83bac55f1976fb716c10234485f9202dcd65cfbdf9da49867b271172\"\n-\"checksum url 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9ba5a45db1d2e0effb7a1c00cc73ffc63a973da8c7d1fcd5b46f24285ade6c54\"\n+\"checksum url 1.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48ccf7bd87a81b769cf84ad556e034541fb90e1cd6d4bc375c822ed9500cd9d7\"\n \"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n \"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "9d44ca033e45dfc936776189201c213aa739e398", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -27,7 +27,7 @@ num_cpus = \"0.2\"\n toml = \"0.1\"\n getopts = \"0.2\"\n rustc-serialize = \"0.3\"\n-gcc = { git = \"https://github.com/alexcrichton/gcc-rs\" }\n+gcc = \"0.3.36\"\n libc = \"0.2\"\n md5 = \"0.1\"\n "}, {"sha": "f73f41ffae29df50716f05e79b207ff759a88465", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 59, "deletions": 11, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -10,24 +10,72 @@ system.\n \n ## Using rustbuild\n \n-When configuring Rust via `./configure`, pass the following to enable building\n-via this build system:\n+The rustbuild build system has a primary entry point, a top level `x.py` script:\n \n ```\n-./configure --enable-rustbuild\n-make\n+python ./x.py build\n ```\n \n-Afterwards the `Makefile` which is generated will have a few commands like\n-`make check`, `make tidy`, etc. For finer-grained control, the\n-`bootstrap.py` entry point can be used:\n+Note that if you're on Unix you should be able to execute the script directly:\n \n ```\n-python src/bootstrap/bootstrap.py\n+./x.py build\n ```\n \n-This accepts a number of options like `--stage` and `--step` which can configure\n-what's actually being done.\n+The script accepts commands, flags, and filters to determine what to do:\n+\n+* `build` - a general purpose command for compiling code. Alone `build` will\n+  bootstrap the entire compiler, and otherwise arguments passed indicate what to\n+  build. For example:\n+\n+  ```\n+  # build the whole compiler\n+  ./x.py build\n+\n+  # build the stage1 compier\n+  ./x.py build --stage 1\n+\n+  # build stage0 libstd\n+  ./x.py build --stage 0 src/libstd\n+\n+  # build a particular crate in stage0\n+  ./x.py build --stage 0 src/libtest\n+  ```\n+\n+* `test` - a command for executing unit tests. Like the `build` command this\n+  will execute the entire test suite by default, and otherwise it can be used to\n+  select which test suite is run:\n+\n+  ```\n+  # run all unit tests\n+  ./x.py test\n+\n+  # execute the run-pass test suite\n+  ./x.py test src/test/run-pass\n+\n+  # execute only some tests in the run-pass test suite\n+  ./x.py test src/test/run-pass --filter my-filter\n+\n+  # execute tests in the standard library in stage0\n+  ./x.py test --stage 0 src/libstd\n+\n+  # execute all doc tests\n+  ./x.py test src/doc\n+  ```\n+\n+* `doc` - a command for building documentation. Like above can take arguments\n+  for what to document.\n+\n+If you're more used to `./configure` and `make`, however, then you can also\n+configure the build system to use rustbuild instead of the old makefiles:\n+\n+```\n+./configure --enable-rustbuild\n+make\n+```\n+\n+Afterwards the `Makefile` which is generated will have a few commands like\n+`make check`, `make tidy`, etc.\n \n ## Configuring rustbuild\n \n@@ -47,7 +95,7 @@ being invoked manually (via the python script).\n The rustbuild build system goes through a few phases to actually build the\n compiler. What actually happens when you invoke rustbuild is:\n \n-1. The entry point script, `src/bootstrap/bootstrap.py` is run. This script is\n+1. The entry point script, `x.py` is run. This script is\n    responsible for downloading the stage0 compiler/Cargo binaries, and it then\n    compiles the build system itself (this folder). Finally, it then invokes the\n    actual `bootstrap` binary build system."}, {"sha": "76bbb9d22e08217bbac1725f8f25bcb979472585", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -399,12 +399,10 @@ def main():\n \n     # Run the bootstrap\n     args = [os.path.join(rb.build_dir, \"bootstrap/debug/bootstrap\")]\n-    args.append('--src')\n-    args.append(rb.rust_root)\n-    args.append('--build')\n-    args.append(rb.build)\n     args.extend(sys.argv[1:])\n     env = os.environ.copy()\n+    env[\"BUILD\"] = rb.build\n+    env[\"SRC\"] = rb.rust_root\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     rb.run(args, env)\n "}, {"sha": "611630c5730f98dc29c96cafee0a0bf5f3abc001", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 27, "deletions": 68, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -13,44 +13,19 @@\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n \n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashSet;\n use std::env;\n use std::fs;\n use std::path::{PathBuf, Path};\n use std::process::Command;\n \n use build_helper::output;\n-use rustc_serialize::json;\n \n use {Build, Compiler, Mode};\n use util::{self, dylib_path, dylib_path_var};\n \n const ADB_TEST_DIR: &'static str = \"/data/tmp\";\n \n-#[derive(RustcDecodable)]\n-struct Output {\n-    packages: Vec<Package>,\n-    resolve: Resolve,\n-}\n-\n-#[derive(RustcDecodable)]\n-struct Package {\n-    id: String,\n-    name: String,\n-    source: Option<String>,\n-}\n-\n-#[derive(RustcDecodable)]\n-struct Resolve {\n-    nodes: Vec<ResolveNode>,\n-}\n-\n-#[derive(RustcDecodable)]\n-struct ResolveNode {\n-    id: String,\n-    dependencies: Vec<String>,\n-}\n-\n /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n ///\n /// This tool in `src/tools` will verify the validity of all our links in the\n@@ -168,8 +143,8 @@ pub fn compiletest(build: &Build,\n         cmd.arg(\"--lldb-python\").arg(python_default);\n     }\n \n-    if let Some(ref vers) = build.gdb_version {\n-        cmd.arg(\"--gdb-version\").arg(vers);\n+    if let Some(ref gdb) = build.config.gdb {\n+        cmd.arg(\"--gdb\").arg(gdb);\n     }\n     if let Some(ref vers) = build.lldb_version {\n         cmd.arg(\"--lldb-version\").arg(vers);\n@@ -181,7 +156,7 @@ pub fn compiletest(build: &Build,\n     let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n     cmd.arg(\"--llvm-version\").arg(llvm_version);\n \n-    cmd.args(&build.flags.args);\n+    cmd.args(&build.flags.cmd.test_args());\n \n     if build.config.verbose || build.flags.verbose {\n         cmd.arg(\"--verbose\");\n@@ -282,7 +257,7 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n     cmd.arg(\"--test\");\n     cmd.arg(markdown);\n \n-    let mut test_args = build.flags.args.join(\" \");\n+    let mut test_args = build.flags.cmd.test_args().join(\" \");\n     if build.config.quiet_tests {\n         test_args.push_str(\" --quiet\");\n     }\n@@ -302,7 +277,8 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n pub fn krate(build: &Build,\n              compiler: &Compiler,\n              target: &str,\n-             mode: Mode) {\n+             mode: Mode,\n+             krate: Option<&str>) {\n     let (name, path, features, root) = match mode {\n         Mode::Libstd => {\n             (\"libstd\", \"src/rustc/std_shim\", build.std_features(), \"std_shim\")\n@@ -318,24 +294,6 @@ pub fn krate(build: &Build,\n     println!(\"Testing {} stage{} ({} -> {})\", name, compiler.stage,\n              compiler.host, target);\n \n-    // Run `cargo metadata` to figure out what crates we're testing.\n-    //\n-    // Down below we're going to call `cargo test`, but to test the right set\n-    // of packages we're going to have to know what `-p` arguments to pass it\n-    // to know what crates to test. Here we run `cargo metadata` to learn about\n-    // the dependency graph and what `-p` arguments there are.\n-    let mut cargo = Command::new(&build.cargo);\n-    cargo.arg(\"metadata\")\n-         .arg(\"--manifest-path\").arg(build.src.join(path).join(\"Cargo.toml\"));\n-    let output = output(&mut cargo);\n-    let output: Output = json::decode(&output).unwrap();\n-    let id2pkg = output.packages.iter()\n-                        .map(|pkg| (&pkg.id, pkg))\n-                        .collect::<HashMap<_, _>>();\n-    let id2deps = output.resolve.nodes.iter()\n-                        .map(|node| (&node.id, &node.dependencies))\n-                        .collect::<HashMap<_, _>>();\n-\n     // Build up the base `cargo test` command.\n     //\n     // Pass in some standard flags then iterate over the graph we've discovered\n@@ -346,24 +304,25 @@ pub fn krate(build: &Build,\n          .arg(build.src.join(path).join(\"Cargo.toml\"))\n          .arg(\"--features\").arg(features);\n \n-    let mut visited = HashSet::new();\n-    let root_pkg = output.packages.iter().find(|p| p.name == root).unwrap();\n-    let mut next = vec![&root_pkg.id];\n-    while let Some(id) = next.pop() {\n-        // Skip any packages with sources listed, as these come from crates.io\n-        // and we shouldn't be testing them.\n-        if id2pkg[id].source.is_some() {\n-            continue\n-        }\n-        // Right now jemalloc is our only target-specific crate in the sense\n-        // that it's not present on all platforms. Custom skip it here for now,\n-        // but if we add more this probably wants to get more generalized.\n-        if !id.contains(\"jemalloc\") {\n-            cargo.arg(\"-p\").arg(&id2pkg[id].name);\n+    match krate {\n+        Some(krate) => {\n+            cargo.arg(\"-p\").arg(krate);\n         }\n-        for dep in id2deps[id] {\n-            if visited.insert(dep) {\n-                next.push(dep);\n+        None => {\n+            let mut visited = HashSet::new();\n+            let mut next = vec![root];\n+            while let Some(name) = next.pop() {\n+                // Right now jemalloc is our only target-specific crate in the sense\n+                // that it's not present on all platforms. Custom skip it here for now,\n+                // but if we add more this probably wants to get more generalized.\n+                if !name.contains(\"jemalloc\") {\n+                    cargo.arg(\"-p\").arg(name);\n+                }\n+                for dep in build.crates[name].deps.iter() {\n+                    if visited.insert(dep) {\n+                        next.push(dep);\n+                    }\n+                }\n             }\n         }\n     }\n@@ -389,7 +348,7 @@ pub fn krate(build: &Build,\n         build.run(cargo.arg(\"--no-run\"));\n         krate_emscripten(build, compiler, target, mode);\n     } else {\n-        cargo.args(&build.flags.args);\n+        cargo.args(&build.flags.cmd.test_args());\n         build.run(&mut cargo);\n     }\n }\n@@ -421,7 +380,7 @@ fn krate_android(build: &Build,\n                               target = target,\n                               test = test_file_name,\n                               log = log,\n-                              args = build.flags.args.join(\" \"));\n+                              args = build.flags.cmd.test_args().join(\" \"));\n \n         let output = output(Command::new(\"adb\").arg(\"shell\").arg(&program));\n         println!(\"{}\", output);"}, {"sha": "75bcbfee6ee0b3e119f037baa95f75d0b2e70fd6", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -16,6 +16,7 @@\n //! directory as we want that cached between builds.\n \n use std::fs;\n+use std::io::{self, ErrorKind};\n use std::path::Path;\n \n use Build;\n@@ -25,24 +26,58 @@ pub fn clean(build: &Build) {\n     rm_rf(build, &build.out.join(\"tmp\"));\n \n     for host in build.config.host.iter() {\n+        let entries = match build.out.join(host).read_dir() {\n+            Ok(iter) => iter,\n+            Err(_) => continue,\n+        };\n \n-        let out = build.out.join(host);\n+        for entry in entries {\n+            let entry = t!(entry);\n+            if entry.file_name().to_str() == Some(\"llvm\") {\n+                continue\n+            }\n+            let path = t!(entry.path().canonicalize());\n+            rm_rf(build, &path);\n+        }\n+    }\n+}\n \n-        rm_rf(build, &out.join(\"doc\"));\n+fn rm_rf(build: &Build, path: &Path) {\n+    if !path.exists() {\n+        return\n+    }\n \n-        for stage in 0..4 {\n-            rm_rf(build, &out.join(format!(\"stage{}\", stage)));\n-            rm_rf(build, &out.join(format!(\"stage{}-std\", stage)));\n-            rm_rf(build, &out.join(format!(\"stage{}-rustc\", stage)));\n-            rm_rf(build, &out.join(format!(\"stage{}-tools\", stage)));\n-            rm_rf(build, &out.join(format!(\"stage{}-test\", stage)));\n+    for file in t!(fs::read_dir(path)) {\n+        let file = t!(file).path();\n+\n+        if file.is_dir() {\n+            rm_rf(build, &file);\n+        } else {\n+            // On windows we can't remove a readonly file, and git will\n+            // often clone files as readonly. As a result, we have some\n+            // special logic to remove readonly files on windows.\n+            do_op(&file, \"remove file\", |p| fs::remove_file(p));\n         }\n     }\n+    do_op(path, \"remove dir\", |p| fs::remove_dir(p));\n }\n \n-fn rm_rf(build: &Build, path: &Path) {\n-    if path.exists() {\n-        build.verbose(&format!(\"removing `{}`\", path.display()));\n-        t!(fs::remove_dir_all(path));\n+fn do_op<F>(path: &Path, desc: &str, mut f: F)\n+    where F: FnMut(&Path) -> io::Result<()>\n+{\n+    match f(path) {\n+        Ok(()) => {}\n+        Err(ref e) if cfg!(windows) &&\n+                      e.kind() == ErrorKind::PermissionDenied => {\n+            let mut p = t!(path.metadata()).permissions();\n+            p.set_readonly(false);\n+            t!(fs::set_permissions(path, p));\n+            f(path).unwrap_or_else(|e| {\n+                panic!(\"failed to {} {}: {}\", desc, path.display(), e);\n+            })\n+        }\n+        Err(e) => {\n+            panic!(\"failed to {} {}: {}\", desc, path.display(), e);\n+        }\n     }\n }"}, {"sha": "5fc4f006729d3e6e397c25d0113ddc35af7b4593", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -64,8 +64,8 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     }\n \n     build.run(&mut cargo);\n-    update_mtime(&libstd_stamp(build, compiler, target));\n-    std_link(build, target, compiler, compiler.host);\n+    update_mtime(&libstd_stamp(build, &compiler, target));\n+    std_link(build, target, compiler.stage, compiler.host);\n }\n \n /// Link all libstd rlibs/dylibs into the sysroot location.\n@@ -74,11 +74,12 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n /// by `compiler` into `host`'s sysroot.\n pub fn std_link(build: &Build,\n                 target: &str,\n-                compiler: &Compiler,\n+                stage: u32,\n                 host: &str) {\n+    let compiler = Compiler::new(stage, &build.config.build);\n     let target_compiler = Compiler::new(compiler.stage, host);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n-    let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n+    let out_dir = build.cargo_out(&compiler, Mode::Libstd, target);\n \n     // If we're linking one compiler host's output into another, then we weren't\n     // called from the `std` method above. In that case we clean out what's\n@@ -146,7 +147,7 @@ pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n          .arg(build.src.join(\"src/rustc/test_shim/Cargo.toml\"));\n     build.run(&mut cargo);\n     update_mtime(&libtest_stamp(build, compiler, target));\n-    test_link(build, target, compiler, compiler.host);\n+    test_link(build, target, compiler.stage, compiler.host);\n }\n \n /// Link all libtest rlibs/dylibs into the sysroot location.\n@@ -155,11 +156,12 @@ pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n /// by `compiler` into `host`'s sysroot.\n pub fn test_link(build: &Build,\n                  target: &str,\n-                 compiler: &Compiler,\n+                 stage: u32,\n                  host: &str) {\n+    let compiler = Compiler::new(stage, &build.config.build);\n     let target_compiler = Compiler::new(compiler.stage, host);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n-    let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n+    let out_dir = build.cargo_out(&compiler, Mode::Libtest, target);\n     add_to_sysroot(&out_dir, &libdir);\n }\n \n@@ -218,7 +220,7 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     }\n     build.run(&mut cargo);\n \n-    rustc_link(build, target, compiler, compiler.host);\n+    rustc_link(build, target, compiler.stage, compiler.host);\n }\n \n /// Link all librustc rlibs/dylibs into the sysroot location.\n@@ -227,11 +229,12 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n /// by `compiler` into `host`'s sysroot.\n pub fn rustc_link(build: &Build,\n                   target: &str,\n-                  compiler: &Compiler,\n+                  stage: u32,\n                   host: &str) {\n+    let compiler = Compiler::new(stage, &build.config.build);\n     let target_compiler = Compiler::new(compiler.stage, host);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n-    let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n+    let out_dir = build.cargo_out(&compiler, Mode::Librustc, target);\n     add_to_sysroot(&out_dir, &libdir);\n }\n \n@@ -259,7 +262,10 @@ fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n /// must have been previously produced by the `stage - 1` build.config.build\n /// compiler.\n pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n-    assert!(stage > 0, \"the stage0 compiler isn't assembled, it's downloaded\");\n+    // nothing to do in stage0\n+    if stage == 0 {\n+        return\n+    }\n     // The compiler that we're assembling\n     let target_compiler = Compiler::new(stage, host);\n "}, {"sha": "bb05b75a3fc2cf8ff02c798b75ae5cb9ff1ff432", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -23,6 +23,7 @@ use std::process;\n use num_cpus;\n use rustc_serialize::Decodable;\n use toml::{Parser, Decoder, Value};\n+use util::push_exe_path;\n \n /// Global configuration for the entire build and/or bootstrap.\n ///\n@@ -86,6 +87,7 @@ pub struct Config {\n     pub mandir: Option<String>,\n     pub codegen_tests: bool,\n     pub nodejs: Option<PathBuf>,\n+    pub gdb: Option<PathBuf>,\n }\n \n /// Per-target configuration stored in the global configuration structure.\n@@ -123,6 +125,7 @@ struct Build {\n     compiler_docs: Option<bool>,\n     docs: Option<bool>,\n     submodules: Option<bool>,\n+    gdb: Option<String>,\n }\n \n /// TOML representation of how the LLVM build is configured.\n@@ -227,6 +230,7 @@ impl Config {\n         }\n         config.rustc = build.rustc.map(PathBuf::from);\n         config.cargo = build.cargo.map(PathBuf::from);\n+        config.gdb = build.gdb.map(PathBuf::from);\n         set(&mut config.compiler_docs, build.compiler_docs);\n         set(&mut config.docs, build.docs);\n         set(&mut config.submodules, build.submodules);\n@@ -356,44 +360,47 @@ impl Config {\n                                        .collect();\n                 }\n                 \"CFG_MUSL_ROOT\" if value.len() > 0 => {\n-                    self.musl_root = Some(PathBuf::from(value));\n+                    self.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_X86_64\" if value.len() > 0 => {\n                     let target = \"x86_64-unknown-linux-musl\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.musl_root = Some(PathBuf::from(value));\n+                    target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_I686\" if value.len() > 0 => {\n                     let target = \"i686-unknown-linux-musl\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.musl_root = Some(PathBuf::from(value));\n+                    target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_ARM\" if value.len() > 0 => {\n                     let target = \"arm-unknown-linux-musleabi\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.musl_root = Some(PathBuf::from(value));\n+                    target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_ARMHF\" if value.len() > 0 => {\n                     let target = \"arm-unknown-linux-musleabihf\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.musl_root = Some(PathBuf::from(value));\n+                    target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_ARMV7\" if value.len() > 0 => {\n                     let target = \"armv7-unknown-linux-musleabihf\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.musl_root = Some(PathBuf::from(value));\n+                    target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_DEFAULT_AR\" if value.len() > 0 => {\n                     self.rustc_default_ar = Some(value.to_string());\n                 }\n                 \"CFG_DEFAULT_LINKER\" if value.len() > 0 => {\n                     self.rustc_default_linker = Some(value.to_string());\n                 }\n+                \"CFG_GDB\" if value.len() > 0 => {\n+                    self.gdb = Some(parse_configure_path(value));\n+                }\n                 \"CFG_RELEASE_CHANNEL\" => {\n                     self.channel = value.to_string();\n                 }\n@@ -412,48 +419,73 @@ impl Config {\n                 \"CFG_LLVM_ROOT\" if value.len() > 0 => {\n                     let target = self.target_config.entry(self.build.clone())\n                                      .or_insert(Target::default());\n-                    let root = PathBuf::from(value);\n-                    target.llvm_config = Some(root.join(\"bin/llvm-config\"));\n+                    let root = parse_configure_path(value);\n+                    target.llvm_config = Some(push_exe_path(root, &[\"bin\", \"llvm-config\"]));\n                 }\n                 \"CFG_JEMALLOC_ROOT\" if value.len() > 0 => {\n                     let target = self.target_config.entry(self.build.clone())\n                                      .or_insert(Target::default());\n-                    target.jemalloc = Some(PathBuf::from(value));\n+                    target.jemalloc = Some(parse_configure_path(value));\n                 }\n                 \"CFG_ARM_LINUX_ANDROIDEABI_NDK\" if value.len() > 0 => {\n                     let target = \"arm-linux-androideabi\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.ndk = Some(PathBuf::from(value));\n+                    target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_ARMV7_LINUX_ANDROIDEABI_NDK\" if value.len() > 0 => {\n                     let target = \"armv7-linux-androideabi\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.ndk = Some(PathBuf::from(value));\n+                    target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_I686_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n                     let target = \"i686-linux-android\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.ndk = Some(PathBuf::from(value));\n+                    target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_AARCH64_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n                     let target = \"aarch64-linux-android\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.ndk = Some(PathBuf::from(value));\n+                    target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_LOCAL_RUST_ROOT\" if value.len() > 0 => {\n-                    self.rustc = Some(PathBuf::from(value).join(\"bin/rustc\"));\n-                    self.cargo = Some(PathBuf::from(value).join(\"bin/cargo\"));\n+                    let path = parse_configure_path(value);\n+                    self.rustc = Some(push_exe_path(path.clone(), &[\"bin\", \"rustc\"]));\n+                    self.cargo = Some(push_exe_path(path, &[\"bin\", \"cargo\"]));\n                 }\n                 _ => {}\n             }\n         }\n     }\n }\n \n+#[cfg(not(windows))]\n+fn parse_configure_path(path: &str) -> PathBuf {\n+    path.into()\n+}\n+\n+#[cfg(windows)]\n+fn parse_configure_path(path: &str) -> PathBuf {\n+    // on windows, configure produces unix style paths e.g. /c/some/path but we\n+    // only want real windows paths\n+\n+    use std::process::Command;\n+    use build_helper;\n+\n+    // '/' is invalid in windows paths, so we can detect unix paths by the presence of it\n+    if !path.contains('/') {\n+        return path.into();\n+    }\n+\n+    let win_path = build_helper::output(Command::new(\"cygpath\").arg(\"-w\").arg(path));\n+    let win_path = win_path.trim();\n+\n+    win_path.into()\n+}\n+\n fn set<T>(field: &mut T, val: Option<T>) {\n     if let Some(v) = val {\n         *field = v;"}, {"sha": "1289cdba59577a03ca852f24fc6095e083a42a2d", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -79,6 +79,9 @@\n # Indicate whether submodules are managed and updated automatically.\n #submodules = true\n \n+# The path to (or name of) the GDB executable to use\n+#gdb = \"gdb\"\n+\n # =============================================================================\n # Options for compiling Rust code itself\n # ============================================================================="}, {"sha": "30c7fefad87453bedfbfd4855aa50346c0e66a67", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -19,7 +19,6 @@\n \n use std::fs::{self, File};\n use std::io::prelude::*;\n-use std::path::Path;\n use std::process::Command;\n \n use {Build, Compiler, Mode};\n@@ -30,8 +29,9 @@ use util::{up_to_date, cp_r};\n ///\n /// This will not actually generate any documentation if the documentation has\n /// already been generated.\n-pub fn rustbook(build: &Build, stage: u32, target: &str, name: &str, out: &Path) {\n-    t!(fs::create_dir_all(out));\n+pub fn rustbook(build: &Build, stage: u32, target: &str, name: &str) {\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n \n     let out = out.join(name);\n     let compiler = Compiler::new(stage, &build.config.build);\n@@ -57,9 +57,10 @@ pub fn rustbook(build: &Build, stage: u32, target: &str, name: &str, out: &Path)\n /// `STAMP` alongw ith providing the various header/footer HTML we've cutomized.\n ///\n /// In the end, this is just a glorified wrapper around rustdoc!\n-pub fn standalone(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn standalone(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} standalone ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n \n     let compiler = Compiler::new(stage, &build.config.build);\n \n@@ -109,7 +110,7 @@ pub fn standalone(build: &Build, stage: u32, target: &str, out: &Path) {\n            .arg(\"--html-in-header\").arg(&favicon)\n            .arg(\"--markdown-playground-url\")\n            .arg(\"https://play.rust-lang.org/\")\n-           .arg(\"-o\").arg(out)\n+           .arg(\"-o\").arg(&out)\n            .arg(&path);\n \n         if filename == \"reference.md\" {\n@@ -131,9 +132,10 @@ pub fn standalone(build: &Build, stage: u32, target: &str, out: &Path) {\n ///\n /// This will generate all documentation for the standard library and its\n /// dependencies. This is largely just a wrapper around `cargo doc`.\n-pub fn std(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn std(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} std ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let out_dir = build.stage_out(&compiler, Mode::Libstd)\n                        .join(target).join(\"doc\");\n@@ -146,16 +148,17 @@ pub fn std(build: &Build, stage: u32, target: &str, out: &Path) {\n          .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"))\n          .arg(\"--features\").arg(build.std_features());\n     build.run(&mut cargo);\n-    cp_r(&out_dir, out)\n+    cp_r(&out_dir, &out)\n }\n \n /// Compile all libtest documentation.\n ///\n /// This will generate all documentation for libtest and its dependencies. This\n /// is largely just a wrapper around `cargo doc`.\n-pub fn test(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn test(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} test ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let out_dir = build.stage_out(&compiler, Mode::Libtest)\n                        .join(target).join(\"doc\");\n@@ -167,16 +170,17 @@ pub fn test(build: &Build, stage: u32, target: &str, out: &Path) {\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/test_shim/Cargo.toml\"));\n     build.run(&mut cargo);\n-    cp_r(&out_dir, out)\n+    cp_r(&out_dir, &out)\n }\n \n /// Generate all compiler documentation.\n ///\n /// This will generate all documentation for the compiler libraries and their\n /// dependencies. This is largely just a wrapper around `cargo doc`.\n-pub fn rustc(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn rustc(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} compiler ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let out_dir = build.stage_out(&compiler, Mode::Librustc)\n                        .join(target).join(\"doc\");\n@@ -189,14 +193,15 @@ pub fn rustc(build: &Build, stage: u32, target: &str, out: &Path) {\n          .arg(build.src.join(\"src/rustc/Cargo.toml\"))\n          .arg(\"--features\").arg(build.rustc_features());\n     build.run(&mut cargo);\n-    cp_r(&out_dir, out)\n+    cp_r(&out_dir, &out)\n }\n \n /// Generates the HTML rendered error-index by running the\n /// `error_index_generator` tool.\n-pub fn error_index(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn error_index(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} error index ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let mut index = build.tool_cmd(&compiler, \"error_index_generator\");\n     index.arg(\"html\");"}, {"sha": "d7516954f12d50fe20c0dfb4f1a8e9d2892f7dc1", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 202, "deletions": 37, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -13,60 +13,224 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n+use std::env;\n use std::fs;\n use std::path::PathBuf;\n use std::process;\n-use std::slice;\n \n-use getopts::Options;\n+use getopts::{Matches, Options};\n+\n+use Build;\n+use config::Config;\n+use metadata;\n+use step;\n \n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n     pub verbose: bool,\n     pub stage: Option<u32>,\n     pub build: String,\n-    pub host: Filter,\n-    pub target: Filter,\n-    pub step: Vec<String>,\n+    pub host: Vec<String>,\n+    pub target: Vec<String>,\n     pub config: Option<PathBuf>,\n     pub src: Option<PathBuf>,\n     pub jobs: Option<u32>,\n-    pub args: Vec<String>,\n-    pub clean: bool,\n+    pub cmd: Subcommand,\n }\n \n-pub struct Filter {\n-    values: Vec<String>,\n+pub enum Subcommand {\n+    Build {\n+        paths: Vec<PathBuf>,\n+    },\n+    Doc {\n+        paths: Vec<PathBuf>,\n+    },\n+    Test {\n+        paths: Vec<PathBuf>,\n+        test_args: Vec<String>,\n+    },\n+    Clean,\n+    Dist {\n+        install: bool,\n+    },\n }\n \n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n         let mut opts = Options::new();\n         opts.optflag(\"v\", \"verbose\", \"use verbose output\");\n         opts.optopt(\"\", \"config\", \"TOML configuration file for build\", \"FILE\");\n+        opts.optopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n         opts.optmulti(\"\", \"host\", \"host targets to build\", \"HOST\");\n-        opts.reqopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n-        opts.optmulti(\"\", \"target\", \"targets to build\", \"TARGET\");\n-        opts.optmulti(\"s\", \"step\", \"build step to execute\", \"STEP\");\n+        opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n         opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n-        opts.optopt(\"\", \"src\", \"path to repo root\", \"DIR\");\n+        opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n-        opts.optflag(\"\", \"clean\", \"clean output directory\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n \n-        let usage = |n| -> ! {\n-            let brief = format!(\"Usage: rust.py [options]\");\n-            print!(\"{}\", opts.usage(&brief));\n+        let usage = |n, opts: &Options| -> ! {\n+            let command = args.get(0).map(|s| &**s);\n+            let brief = format!(\"Usage: x.py {} [options] [<args>...]\",\n+                                command.unwrap_or(\"<command>\"));\n+\n+            println!(\"{}\", opts.usage(&brief));\n+            match command {\n+                Some(\"build\") => {\n+                    println!(\"\\\n+Arguments:\n+    This subcommand accepts a number of positional arguments of directories to\n+    the crates and/or artifacts to compile. For example:\n+\n+        ./x.py build src/libcore\n+        ./x.py build src/libproc_macro\n+        ./x.py build src/libstd --stage 1\n+\n+    If no arguments are passed then the complete artifacts for that stage are\n+    also compiled.\n+\n+        ./x.py build\n+        ./x.py build --stage 1\n+\n+    For a quick build with a usable compile, you can pass:\n+\n+        ./x.py build --stage 1 src/libtest\n+\");\n+                }\n+\n+                Some(\"test\") => {\n+                    println!(\"\\\n+Arguments:\n+    This subcommand accepts a number of positional arguments of directories to\n+    tests that should be compiled and run. For example:\n+\n+        ./x.py test src/test/run-pass\n+        ./x.py test src/test/run-pass/assert-*\n+        ./x.py test src/libstd --test-args hash_map\n+        ./x.py test src/libstd --stage 0\n+\n+    If no arguments are passed then the complete artifacts for that stage are\n+    compiled and tested.\n+\n+        ./x.py test\n+        ./x.py test --stage 1\n+\");\n+                }\n+\n+                Some(\"doc\") => {\n+                    println!(\"\\\n+Arguments:\n+    This subcommand accepts a number of positional arguments of directories of\n+    documentation to build. For example:\n+\n+        ./x.py doc src/doc/book\n+        ./x.py doc src/doc/nomicon\n+        ./x.py doc src/libstd\n+\n+    If no arguments are passed then everything is documented:\n+\n+        ./x.py doc\n+        ./x.py doc --stage 1\n+\");\n+                }\n+\n+                _ => {}\n+            }\n+\n+            if let Some(command) = command {\n+                if command == \"build\" ||\n+                   command == \"dist\" ||\n+                   command == \"doc\" ||\n+                   command == \"test\" ||\n+                   command == \"clean\"  {\n+                    println!(\"Available invocations:\");\n+                    if args.iter().any(|a| a == \"-v\") {\n+                        let flags = Flags::parse(&[\"build\".to_string()]);\n+                        let mut config = Config::default();\n+                        config.build = flags.build.clone();\n+                        let mut build = Build::new(flags, config);\n+                        metadata::build(&mut build);\n+                        step::build_rules(&build).print_help(command);\n+                    } else {\n+                        println!(\"    ... elided, run `./x.py {} -h -v` to see\",\n+                                 command);\n+                    }\n+\n+                    println!(\"\");\n+                }\n+            }\n+\n+println!(\"\\\n+Subcommands:\n+    build       Compile either the compiler or libraries\n+    test        Build and run some test suites\n+    doc         Build documentation\n+    clean       Clean out build directories\n+    dist        Build and/or install distribution artifacts\n+\n+To learn more about a subcommand, run `./x.py <command> -h`\n+\");\n+\n             process::exit(n);\n         };\n-\n-        let m = opts.parse(args).unwrap_or_else(|e| {\n-            println!(\"failed to parse options: {}\", e);\n-            usage(1);\n-        });\n-        if m.opt_present(\"h\") {\n-            usage(0);\n+        if args.len() == 0 {\n+            println!(\"a command must be passed\");\n+            usage(1, &opts);\n         }\n+        let parse = |opts: &Options| {\n+            let m = opts.parse(&args[1..]).unwrap_or_else(|e| {\n+                println!(\"failed to parse options: {}\", e);\n+                usage(1, opts);\n+            });\n+            if m.opt_present(\"h\") {\n+                usage(0, opts);\n+            }\n+            return m\n+        };\n+\n+        let cwd = t!(env::current_dir());\n+        let remaining_as_path = |m: &Matches| {\n+            m.free.iter().map(|p| cwd.join(p)).collect::<Vec<_>>()\n+        };\n+\n+        let m: Matches;\n+        let cmd = match &args[0][..] {\n+            \"build\" => {\n+                m = parse(&opts);\n+                Subcommand::Build { paths: remaining_as_path(&m) }\n+            }\n+            \"doc\" => {\n+                m = parse(&opts);\n+                Subcommand::Doc { paths: remaining_as_path(&m) }\n+            }\n+            \"test\" => {\n+                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n+                m = parse(&opts);\n+                Subcommand::Test {\n+                    paths: remaining_as_path(&m),\n+                    test_args: m.opt_strs(\"test-args\"),\n+                }\n+            }\n+            \"clean\" => {\n+                m = parse(&opts);\n+                if m.free.len() > 0 {\n+                    println!(\"clean takes no arguments\");\n+                    usage(1, &opts);\n+                }\n+                Subcommand::Clean\n+            }\n+            \"dist\" => {\n+                opts.optflag(\"\", \"install\", \"run installer as well\");\n+                m = parse(&opts);\n+                Subcommand::Dist {\n+                    install: m.opt_present(\"install\"),\n+                }\n+            }\n+            cmd => {\n+                println!(\"unknown command: {}\", cmd);\n+                usage(1, &opts);\n+            }\n+        };\n+\n \n         let cfg_file = m.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n             if fs::metadata(\"config.toml\").is_ok() {\n@@ -78,26 +242,27 @@ impl Flags {\n \n         Flags {\n             verbose: m.opt_present(\"v\"),\n-            clean: m.opt_present(\"clean\"),\n             stage: m.opt_str(\"stage\").map(|j| j.parse().unwrap()),\n-            build: m.opt_str(\"build\").unwrap(),\n-            host: Filter { values: m.opt_strs(\"host\") },\n-            target: Filter { values: m.opt_strs(\"target\") },\n-            step: m.opt_strs(\"step\"),\n+            build: m.opt_str(\"build\").unwrap_or_else(|| {\n+                env::var(\"BUILD\").unwrap()\n+            }),\n+            host: m.opt_strs(\"host\"),\n+            target: m.opt_strs(\"target\"),\n             config: cfg_file,\n             src: m.opt_str(\"src\").map(PathBuf::from),\n             jobs: m.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n-            args: m.free.clone(),\n+            cmd: cmd,\n         }\n     }\n }\n \n-impl Filter {\n-    pub fn contains(&self, name: &str) -> bool {\n-        self.values.len() == 0 || self.values.iter().any(|s| s == name)\n-    }\n-\n-    pub fn iter(&self) -> slice::Iter<String> {\n-        self.values.iter()\n+impl Subcommand {\n+    pub fn test_args(&self) -> Vec<&str> {\n+        match *self {\n+            Subcommand::Test { ref test_args, .. } => {\n+                test_args.iter().flat_map(|s| s.split_whitespace()).collect()\n+            }\n+            _ => Vec::new(),\n+        }\n     }\n }"}, {"sha": "3f8e3fe53128bfb4767e4b65b1424e1f09b451a7", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 27, "deletions": 248, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -57,6 +57,7 @@ mod channel;\n mod check;\n mod clean;\n mod compile;\n+mod metadata;\n mod config;\n mod dist;\n mod doc;\n@@ -76,7 +77,7 @@ mod job {\n }\n \n pub use config::Config;\n-pub use flags::Flags;\n+pub use flags::{Flags, Subcommand};\n \n /// A structure representing a Rust compiler.\n ///\n@@ -123,13 +124,23 @@ pub struct Build {\n     bootstrap_key_stage0: String,\n \n     // Probed tools at runtime\n-    gdb_version: Option<String>,\n     lldb_version: Option<String>,\n     lldb_python_dir: Option<String>,\n \n     // Runtime state filled in later on\n     cc: HashMap<String, (gcc::Tool, Option<PathBuf>)>,\n     cxx: HashMap<String, gcc::Tool>,\n+    crates: HashMap<String, Crate>,\n+}\n+\n+#[derive(Debug)]\n+struct Crate {\n+    name: String,\n+    deps: Vec<String>,\n+    path: PathBuf,\n+    doc_step: String,\n+    build_step: String,\n+    test_step: String,\n }\n \n /// The various \"modes\" of invoking Cargo.\n@@ -162,7 +173,9 @@ impl Build {\n     /// By default all build output will be placed in the current directory.\n     pub fn new(flags: Flags, config: Config) -> Build {\n         let cwd = t!(env::current_dir());\n-        let src = flags.src.clone().unwrap_or(cwd.clone());\n+        let src = flags.src.clone().or_else(|| {\n+            env::var_os(\"SRC\").map(|x| x.into())\n+        }).unwrap_or(cwd.clone());\n         let out = cwd.join(\"build\");\n \n         let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n@@ -196,21 +209,19 @@ impl Build {\n             package_vers: String::new(),\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n-            gdb_version: None,\n+            crates: HashMap::new(),\n             lldb_version: None,\n             lldb_python_dir: None,\n         }\n     }\n \n     /// Executes the entire build, as configured by the flags and configuration.\n     pub fn build(&mut self) {\n-        use step::Source::*;\n-\n         unsafe {\n             job::setup();\n         }\n \n-        if self.flags.clean {\n+        if let Subcommand::Clean = self.flags.cmd {\n             return clean::clean(self);\n         }\n \n@@ -232,247 +243,10 @@ impl Build {\n         }\n         self.verbose(\"updating submodules\");\n         self.update_submodules();\n+        self.verbose(\"learning about cargo\");\n+        metadata::build(self);\n \n-        // The main loop of the build system.\n-        //\n-        // The `step::all` function returns a topographically sorted list of all\n-        // steps that need to be executed as part of this build. Each step has a\n-        // corresponding entry in `step.rs` and indicates some unit of work that\n-        // needs to be done as part of the build.\n-        //\n-        // Almost all of these are simple one-liners that shell out to the\n-        // corresponding functionality in the extra modules, where more\n-        // documentation can be found.\n-        let steps = step::all(self);\n-\n-        self.verbose(\"bootstrap build plan:\");\n-        for step in &steps {\n-            self.verbose(&format!(\"{:?}\", step));\n-        }\n-\n-        for target in steps {\n-            let doc_out = self.out.join(&target.target).join(\"doc\");\n-            match target.src {\n-                Llvm { _dummy } => {\n-                    native::llvm(self, target.target);\n-                }\n-                TestHelpers { _dummy } => {\n-                    native::test_helpers(self, target.target);\n-                }\n-                Libstd { compiler } => {\n-                    compile::std(self, target.target, &compiler);\n-                }\n-                Libtest { compiler } => {\n-                    compile::test(self, target.target, &compiler);\n-                }\n-                Librustc { compiler } => {\n-                    compile::rustc(self, target.target, &compiler);\n-                }\n-                LibstdLink { compiler, host } => {\n-                    compile::std_link(self, target.target, &compiler, host);\n-                }\n-                LibtestLink { compiler, host } => {\n-                    compile::test_link(self, target.target, &compiler, host);\n-                }\n-                LibrustcLink { compiler, host } => {\n-                    compile::rustc_link(self, target.target, &compiler, host);\n-                }\n-                Rustc { stage: 0 } => {\n-                    // nothing to do...\n-                }\n-                Rustc { stage } => {\n-                    compile::assemble_rustc(self, stage, target.target);\n-                }\n-                ToolLinkchecker { stage } => {\n-                    compile::tool(self, stage, target.target, \"linkchecker\");\n-                }\n-                ToolRustbook { stage } => {\n-                    compile::tool(self, stage, target.target, \"rustbook\");\n-                }\n-                ToolErrorIndex { stage } => {\n-                    compile::tool(self, stage, target.target,\n-                                  \"error_index_generator\");\n-                }\n-                ToolCargoTest { stage } => {\n-                    compile::tool(self, stage, target.target, \"cargotest\");\n-                }\n-                ToolTidy { stage } => {\n-                    compile::tool(self, stage, target.target, \"tidy\");\n-                }\n-                ToolCompiletest { stage } => {\n-                    compile::tool(self, stage, target.target, \"compiletest\");\n-                }\n-                DocBook { stage } => {\n-                    doc::rustbook(self, stage, target.target, \"book\", &doc_out);\n-                }\n-                DocNomicon { stage } => {\n-                    doc::rustbook(self, stage, target.target, \"nomicon\",\n-                                  &doc_out);\n-                }\n-                DocStandalone { stage } => {\n-                    doc::standalone(self, stage, target.target, &doc_out);\n-                }\n-                DocStd { stage } => {\n-                    doc::std(self, stage, target.target, &doc_out);\n-                }\n-                DocTest { stage } => {\n-                    doc::test(self, stage, target.target, &doc_out);\n-                }\n-                DocRustc { stage } => {\n-                    doc::rustc(self, stage, target.target, &doc_out);\n-                }\n-                DocErrorIndex { stage } => {\n-                    doc::error_index(self, stage, target.target, &doc_out);\n-                }\n-\n-                CheckLinkcheck { stage } => {\n-                    check::linkcheck(self, stage, target.target);\n-                }\n-                CheckCargoTest { stage } => {\n-                    check::cargotest(self, stage, target.target);\n-                }\n-                CheckTidy { stage } => {\n-                    check::tidy(self, stage, target.target);\n-                }\n-                CheckRPass { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-pass\", \"run-pass\");\n-                }\n-                CheckRPassFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-pass\", \"run-pass-fulldeps\");\n-                }\n-                CheckCFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"compile-fail\", \"compile-fail\");\n-                }\n-                CheckCFailFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"compile-fail\", \"compile-fail-fulldeps\")\n-                }\n-                CheckPFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"parse-fail\", \"parse-fail\");\n-                }\n-                CheckRFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-fail\", \"run-fail\");\n-                }\n-                CheckRFailFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-fail\", \"run-fail-fulldeps\");\n-                }\n-                CheckPretty { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"pretty\");\n-                }\n-                CheckPrettyRPass { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-pass\");\n-                }\n-                CheckPrettyRPassFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-pass-fulldeps\");\n-                }\n-                CheckPrettyRFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-fail\");\n-                }\n-                CheckPrettyRFailFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-fail-fulldeps\");\n-                }\n-                CheckPrettyRPassValgrind { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-pass-valgrind\");\n-                }\n-                CheckMirOpt { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"mir-opt\", \"mir-opt\");\n-                }\n-                CheckCodegen { compiler } => {\n-                    if self.config.codegen_tests {\n-                        check::compiletest(self, &compiler, target.target,\n-                                           \"codegen\", \"codegen\");\n-                    }\n-                }\n-                CheckCodegenUnits { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"codegen-units\", \"codegen-units\");\n-                }\n-                CheckIncremental { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"incremental\", \"incremental\");\n-                }\n-                CheckUi { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"ui\", \"ui\");\n-                }\n-                CheckDebuginfo { compiler } => {\n-                    if target.target.contains(\"msvc\") {\n-                        // nothing to do\n-                    } else if target.target.contains(\"apple\") {\n-                        check::compiletest(self, &compiler, target.target,\n-                                           \"debuginfo-lldb\", \"debuginfo\");\n-                    } else {\n-                        check::compiletest(self, &compiler, target.target,\n-                                           \"debuginfo-gdb\", \"debuginfo\");\n-                    }\n-                }\n-                CheckRustdoc { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"rustdoc\", \"rustdoc\");\n-                }\n-                CheckRPassValgrind { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-pass-valgrind\", \"run-pass-valgrind\");\n-                }\n-                CheckDocs { compiler } => {\n-                    check::docs(self, &compiler);\n-                }\n-                CheckErrorIndex { compiler } => {\n-                    check::error_index(self, &compiler);\n-                }\n-                CheckRMake { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-make\", \"run-make\")\n-                }\n-                CheckCrateStd { compiler } => {\n-                    check::krate(self, &compiler, target.target, Mode::Libstd)\n-                }\n-                CheckCrateTest { compiler } => {\n-                    check::krate(self, &compiler, target.target, Mode::Libtest)\n-                }\n-                CheckCrateRustc { compiler } => {\n-                    check::krate(self, &compiler, target.target, Mode::Librustc)\n-                }\n-\n-                DistDocs { stage } => dist::docs(self, stage, target.target),\n-                DistMingw { _dummy } => dist::mingw(self, target.target),\n-                DistRustc { stage } => dist::rustc(self, stage, target.target),\n-                DistStd { compiler } => dist::std(self, &compiler, target.target),\n-                DistSrc { _dummy } => dist::rust_src(self),\n-\n-                Install { stage } => install::install(self, stage, target.target),\n-\n-                DebuggerScripts { stage } => {\n-                    let compiler = Compiler::new(stage, target.target);\n-                    dist::debugger_scripts(self,\n-                                           &self.sysroot(&compiler),\n-                                           target.target);\n-                }\n-\n-                AndroidCopyLibs { compiler } => {\n-                    check::android_copy_libs(self, &compiler, target.target);\n-                }\n-\n-                // pseudo-steps\n-                Dist { .. } |\n-                Doc { .. } |\n-                CheckTarget { .. } |\n-                Check { .. } => {}\n-            }\n-        }\n+        step::run(self);\n     }\n \n     /// Updates all git submodules that we have.\n@@ -812,6 +586,11 @@ impl Build {\n         self.out.join(target).join(\"llvm\")\n     }\n \n+    /// Output directory for all documentation for a target\n+    fn doc_out(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"doc\")\n+    }\n+\n     /// Returns true if no custom `llvm-config` is set for the specified target.\n     ///\n     /// If no custom `llvm-config` was specified then Rust's llvm will be used.\n@@ -873,7 +652,7 @@ impl Build {\n \n     /// Adds the compiler's bootstrap key to the environment of `cmd`.\n     fn add_bootstrap_key(&self, cmd: &mut Command) {\n-        cmd.env(\"RUSTC_BOOTSTRAP\", \"\");\n+        cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n         // FIXME: Transitionary measure to bootstrap using the old bootstrap logic.\n         // Remove this once the bootstrap compiler uses the new login in Issue #36548.\n         cmd.env(\"RUSTC_BOOTSTRAP_KEY\", \"62b3e239\");"}, {"sha": "bf5cc6a4ad838a057cc5fa3a04a4a0fe1cadb8f7", "filename": "src/bootstrap/metadata.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+use std::process::Command;\n+use std::path::PathBuf;\n+\n+use build_helper::output;\n+use rustc_serialize::json;\n+\n+use {Build, Crate};\n+\n+#[derive(RustcDecodable)]\n+struct Output {\n+    packages: Vec<Package>,\n+    resolve: Resolve,\n+}\n+\n+#[derive(RustcDecodable)]\n+struct Package {\n+    id: String,\n+    name: String,\n+    source: Option<String>,\n+    manifest_path: String,\n+}\n+\n+#[derive(RustcDecodable)]\n+struct Resolve {\n+    nodes: Vec<ResolveNode>,\n+}\n+\n+#[derive(RustcDecodable)]\n+struct ResolveNode {\n+    id: String,\n+    dependencies: Vec<String>,\n+}\n+\n+pub fn build(build: &mut Build) {\n+    build_krate(build, \"src/rustc/std_shim\");\n+    build_krate(build, \"src/rustc/test_shim\");\n+    build_krate(build, \"src/rustc\");\n+}\n+\n+fn build_krate(build: &mut Build, krate: &str) {\n+    // Run `cargo metadata` to figure out what crates we're testing.\n+    //\n+    // Down below we're going to call `cargo test`, but to test the right set\n+    // of packages we're going to have to know what `-p` arguments to pass it\n+    // to know what crates to test. Here we run `cargo metadata` to learn about\n+    // the dependency graph and what `-p` arguments there are.\n+    let mut cargo = Command::new(&build.cargo);\n+    cargo.arg(\"metadata\")\n+         .arg(\"--manifest-path\").arg(build.src.join(krate).join(\"Cargo.toml\"));\n+    let output = output(&mut cargo);\n+    let output: Output = json::decode(&output).unwrap();\n+    let mut id2name = HashMap::new();\n+    for package in output.packages {\n+        if package.source.is_none() {\n+            id2name.insert(package.id, package.name.clone());\n+            let mut path = PathBuf::from(package.manifest_path);\n+            path.pop();\n+            build.crates.insert(package.name.clone(), Crate {\n+                build_step: format!(\"build-crate-{}\", package.name),\n+                doc_step: format!(\"doc-crate-{}\", package.name),\n+                test_step: format!(\"test-crate-{}\", package.name),\n+                name: package.name,\n+                deps: Vec::new(),\n+                path: path,\n+            });\n+        }\n+    }\n+\n+    for node in output.resolve.nodes {\n+        let name = match id2name.get(&node.id) {\n+            Some(name) => name,\n+            None => continue,\n+        };\n+\n+        let krate = build.crates.get_mut(name).unwrap();\n+        for dep in node.dependencies.iter() {\n+            let dep = match id2name.get(dep) {\n+                Some(dep) => dep,\n+                None => continue,\n+            };\n+            krate.deps.push(dep.clone());\n+        }\n+    }\n+}"}, {"sha": "d4031077639c50d0be477ca4b062594c0e032829", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -17,47 +17,46 @@ else\n BOOTSTRAP_ARGS :=\n endif\n \n-BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py $(BOOTSTRAP_ARGS)\n+BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py\n \n all:\n-\t$(Q)$(BOOTSTRAP)\n+\t$(Q)$(BOOTSTRAP) build $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) doc $(BOOTSTRAP_ARGS)\n \n # Don\u2019t use $(Q) here, always show how to invoke the bootstrap script directly\n help:\n \t$(BOOTSTRAP) --help\n \n clean:\n-\t$(Q)$(BOOTSTRAP) --clean\n+\t$(Q)$(BOOTSTRAP) clean $(BOOTSTRAP_ARGS)\n \n rustc-stage1:\n-\t$(Q)$(BOOTSTRAP) --step libtest --stage 1\n+\t$(Q)$(BOOTSTRAP) build --stage 1 src/libtest $(BOOTSTRAP_ARGS)\n rustc-stage2:\n-\t$(Q)$(BOOTSTRAP) --step libtest --stage 2\n+\t$(Q)$(BOOTSTRAP) build --stage 2 src/libtest $(BOOTSTRAP_ARGS)\n \n docs: doc\n doc:\n-\t$(Q)$(BOOTSTRAP) --step doc\n-style:\n-\t$(Q)$(BOOTSTRAP) --step doc-style\n+\t$(Q)$(BOOTSTRAP) doc $(BOOTSTRAP_ARGS)\n nomicon:\n-\t$(Q)$(BOOTSTRAP) --step doc-nomicon\n+\t$(Q)$(BOOTSTRAP) doc src/doc/nomicon $(BOOTSTRAP_ARGS)\n book:\n-\t$(Q)$(BOOTSTRAP) --step doc-book\n+\t$(Q)$(BOOTSTRAP) doc src/doc/book $(BOOTSTRAP_ARGS)\n standalone-docs:\n-\t$(Q)$(BOOTSTRAP) --step doc-standalone\n+\t$(Q)$(BOOTSTRAP) doc src/doc $(BOOTSTRAP_ARGS)\n check:\n-\t$(Q)$(BOOTSTRAP) --step check\n+\t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-cargotest:\n-\t$(Q)$(BOOTSTRAP) --step check-cargotest\n+\t$(Q)$(BOOTSTRAP) test src/tools/cargotest $(BOOTSTRAP_ARGS)\n dist:\n-\t$(Q)$(BOOTSTRAP) --step dist\n+\t$(Q)$(BOOTSTRAP) dist $(BOOTSTRAP_ARGS)\n install:\n ifeq (root user, $(USER) $(patsubst %,user,$(SUDO_USER)))\n \t$(Q)echo \"'sudo make install' is not supported currently.\"\n else\n-\t$(Q)$(BOOTSTRAP) --step install\n+\t$(Q)$(BOOTSTRAP) dist --install $(BOOTSTRAP_ARGS)\n endif\n tidy:\n-\t$(Q)$(BOOTSTRAP) --step check-tidy --stage 0\n+\t$(Q)$(BOOTSTRAP) test src/tools/tidy $(BOOTSTRAP_ARGS)\n \n .PHONY: dist"}, {"sha": "cc1b7136d475f99f920ab3780f0d18fc8390c1d2", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -92,6 +92,12 @@ pub fn check(build: &mut Build) {\n         need_cmd(s.as_ref());\n     }\n \n+    if let Some(ref gdb) = build.config.gdb {\n+        need_cmd(gdb.as_ref());\n+    } else {\n+        build.config.gdb = have_cmd(\"gdb\".as_ref());\n+    }\n+\n     // We're gonna build some custom C code here and there, host triples\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n     for target in build.config.target.iter() {\n@@ -198,7 +204,6 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n                    .to_string()\n         })\n     };\n-    build.gdb_version = run(Command::new(\"gdb\").arg(\"--version\")).ok();\n     build.lldb_version = run(Command::new(\"lldb\").arg(\"--version\")).ok();\n     if build.lldb_version.is_some() {\n         build.lldb_python_dir = run(Command::new(\"lldb\").arg(\"-P\")).ok();"}, {"sha": "6f616434b10c345bd93041ccc4ded07da55adf8f", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 639, "deletions": 548, "changes": 1187, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -8,600 +8,691 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Major workhorse of rustbuild, definition and dependencies between stages of\n-//! the copmile.\n-//!\n-//! The primary purpose of this module is to define the various `Step`s of\n-//! execution of the build. Each `Step` has a corresponding `Source` indicating\n-//! what it's actually doing along with a number of dependencies which must be\n-//! executed first.\n-//!\n-//! This module will take the CLI as input and calculate the steps required for\n-//! the build requested, ensuring that all intermediate pieces are in place.\n-//! Essentially this module is a `make`-replacement, but not as good.\n-\n-use std::collections::HashSet;\n-\n-use {Build, Compiler};\n-\n-#[derive(Hash, Eq, PartialEq, Clone, Debug)]\n-pub struct Step<'a> {\n-    pub src: Source<'a>,\n-    pub target: &'a str,\n+use std::collections::{HashMap, HashSet};\n+use std::mem;\n+\n+use check;\n+use compile;\n+use dist;\n+use doc;\n+use flags::Subcommand;\n+use install;\n+use native;\n+use {Compiler, Build, Mode};\n+\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+struct Step<'a> {\n+    name: &'a str,\n+    stage: u32,\n+    host: &'a str,\n+    target: &'a str,\n }\n \n-/// Macro used to iterate over all targets that are recognized by the build\n-/// system.\n-///\n-/// Whenever a new step is added it will involve adding an entry here, updating\n-/// the dependencies section below, and then adding an implementation of the\n-/// step in `build/mod.rs`.\n-///\n-/// This macro takes another macro as an argument and then calls that macro with\n-/// all steps that the build system knows about.\n-macro_rules! targets {\n-    ($m:ident) => {\n-        $m! {\n-            // Step representing building the stageN compiler. This is just the\n-            // compiler executable itself, not any of the support libraries\n-            (rustc, Rustc { stage: u32 }),\n-\n-            // Steps for the two main cargo builds. These are parameterized over\n-            // the compiler which is producing the artifact.\n-            (libstd, Libstd { compiler: Compiler<'a> }),\n-            (libtest, Libtest { compiler: Compiler<'a> }),\n-            (librustc, Librustc { compiler: Compiler<'a> }),\n-\n-            // Links the target produced by the compiler provided into the\n-            // host's directory also provided.\n-            (libstd_link, LibstdLink {\n-                compiler: Compiler<'a>,\n-                host: &'a str\n-            }),\n-            (libtest_link, LibtestLink {\n-                compiler: Compiler<'a>,\n-                host: &'a str\n-            }),\n-            (librustc_link, LibrustcLink {\n-                compiler: Compiler<'a>,\n-                host: &'a str\n-            }),\n-\n-            // Various tools that we can build as part of the build.\n-            (tool_linkchecker, ToolLinkchecker { stage: u32 }),\n-            (tool_rustbook, ToolRustbook { stage: u32 }),\n-            (tool_error_index, ToolErrorIndex { stage: u32 }),\n-            (tool_cargotest, ToolCargoTest { stage: u32 }),\n-            (tool_tidy, ToolTidy { stage: u32 }),\n-            (tool_compiletest, ToolCompiletest { stage: u32 }),\n-\n-            // Steps for long-running native builds. Ideally these wouldn't\n-            // actually exist and would be part of build scripts, but for now\n-            // these are here.\n-            //\n-            // There aren't really any parameters to this, but empty structs\n-            // with braces are unstable so we just pick something that works.\n-            (llvm, Llvm { _dummy: () }),\n-            (test_helpers, TestHelpers { _dummy: () }),\n-            (debugger_scripts, DebuggerScripts { stage: u32 }),\n-\n-            // Steps for various pieces of documentation that we can generate,\n-            // the 'doc' step is just a pseudo target to depend on a bunch of\n-            // others.\n-            (doc, Doc { stage: u32 }),\n-            (doc_book, DocBook { stage: u32 }),\n-            (doc_nomicon, DocNomicon { stage: u32 }),\n-            (doc_standalone, DocStandalone { stage: u32 }),\n-            (doc_std, DocStd { stage: u32 }),\n-            (doc_test, DocTest { stage: u32 }),\n-            (doc_rustc, DocRustc { stage: u32 }),\n-            (doc_error_index, DocErrorIndex { stage: u32 }),\n-\n-            // Steps for running tests. The 'check' target is just a pseudo\n-            // target to depend on a bunch of others.\n-            (check, Check { stage: u32, compiler: Compiler<'a> }),\n-            (check_target, CheckTarget { stage: u32, compiler: Compiler<'a> }),\n-            (check_linkcheck, CheckLinkcheck { stage: u32 }),\n-            (check_cargotest, CheckCargoTest { stage: u32 }),\n-            (check_tidy, CheckTidy { stage: u32 }),\n-            (check_rpass, CheckRPass { compiler: Compiler<'a> }),\n-            (check_rpass_full, CheckRPassFull { compiler: Compiler<'a> }),\n-            (check_rpass_valgrind, CheckRPassValgrind { compiler: Compiler<'a> }),\n-            (check_rfail, CheckRFail { compiler: Compiler<'a> }),\n-            (check_rfail_full, CheckRFailFull { compiler: Compiler<'a> }),\n-            (check_cfail, CheckCFail { compiler: Compiler<'a> }),\n-            (check_cfail_full, CheckCFailFull { compiler: Compiler<'a> }),\n-            (check_pfail, CheckPFail { compiler: Compiler<'a> }),\n-            (check_pretty, CheckPretty { compiler: Compiler<'a> }),\n-            (check_pretty_rpass, CheckPrettyRPass { compiler: Compiler<'a> }),\n-            (check_pretty_rpass_full, CheckPrettyRPassFull { compiler: Compiler<'a> }),\n-            (check_pretty_rfail, CheckPrettyRFail { compiler: Compiler<'a> }),\n-            (check_pretty_rfail_full, CheckPrettyRFailFull { compiler: Compiler<'a> }),\n-            (check_pretty_rpass_valgrind, CheckPrettyRPassValgrind { compiler: Compiler<'a> }),\n-            (check_codegen, CheckCodegen { compiler: Compiler<'a> }),\n-            (check_codegen_units, CheckCodegenUnits { compiler: Compiler<'a> }),\n-            (check_incremental, CheckIncremental { compiler: Compiler<'a> }),\n-            (check_ui, CheckUi { compiler: Compiler<'a> }),\n-            (check_mir_opt, CheckMirOpt { compiler: Compiler<'a> }),\n-            (check_debuginfo, CheckDebuginfo { compiler: Compiler<'a> }),\n-            (check_rustdoc, CheckRustdoc { compiler: Compiler<'a> }),\n-            (check_docs, CheckDocs { compiler: Compiler<'a> }),\n-            (check_error_index, CheckErrorIndex { compiler: Compiler<'a> }),\n-            (check_rmake, CheckRMake { compiler: Compiler<'a> }),\n-            (check_crate_std, CheckCrateStd { compiler: Compiler<'a> }),\n-            (check_crate_test, CheckCrateTest { compiler: Compiler<'a> }),\n-            (check_crate_rustc, CheckCrateRustc { compiler: Compiler<'a> }),\n-\n-            // Distribution targets, creating tarballs\n-            (dist, Dist { stage: u32 }),\n-            (dist_docs, DistDocs { stage: u32 }),\n-            (dist_mingw, DistMingw { _dummy: () }),\n-            (dist_rustc, DistRustc { stage: u32 }),\n-            (dist_std, DistStd { compiler: Compiler<'a> }),\n-            (dist_src, DistSrc { _dummy: () }),\n-\n-            // install target\n-            (install, Install { stage: u32 }),\n-\n-            // Misc targets\n-            (android_copy_libs, AndroidCopyLibs { compiler: Compiler<'a> }),\n-        }\n+impl<'a> Step<'a> {\n+    fn name(&self, name: &'a str) -> Step<'a> {\n+        Step { name: name, ..*self }\n     }\n-}\n \n-// Define the `Source` enum by iterating over all the steps and peeling out just\n-// the types that we want to define.\n+    fn stage(&self, stage: u32) -> Step<'a> {\n+        Step { stage: stage, ..*self }\n+    }\n \n-macro_rules! item { ($a:item) => ($a) }\n+    fn host(&self, host: &'a str) -> Step<'a> {\n+        Step { host: host, ..*self }\n+    }\n \n-macro_rules! define_source {\n-    ($(($short:ident, $name:ident { $($args:tt)* }),)*) => {\n-        item! {\n-            #[derive(Hash, Eq, PartialEq, Clone, Debug)]\n-            pub enum Source<'a> {\n-                $($name { $($args)* }),*\n-            }\n-        }\n+    fn target(&self, target: &'a str) -> Step<'a> {\n+        Step { target: target, ..*self }\n     }\n-}\n \n-targets!(define_source);\n-\n-/// Calculate a list of all steps described by `build`.\n-///\n-/// This will inspect the flags passed in on the command line and use that to\n-/// build up a list of steps to execute. These steps will then be transformed\n-/// into a topologically sorted list which when executed left-to-right will\n-/// correctly sequence the entire build.\n-pub fn all(build: &Build) -> Vec<Step> {\n-    build.verbose(\"inferred build steps:\");\n-\n-    let mut ret = Vec::new();\n-    let mut all = HashSet::new();\n-    for target in top_level(build) {\n-        fill(build, &target, &mut ret, &mut all);\n-    }\n-    return ret;\n-\n-    fn fill<'a>(build: &'a Build,\n-                target: &Step<'a>,\n-                ret: &mut Vec<Step<'a>>,\n-                set: &mut HashSet<Step<'a>>) {\n-        if set.insert(target.clone()) {\n-            for dep in target.deps(build) {\n-                build.verbose(&format!(\"{:?}\\n  -> {:?}\", target, dep));\n-                fill(build, &dep, ret, set);\n-            }\n-            ret.push(target.clone());\n-        }\n+    fn compiler(&self) -> Compiler<'a> {\n+        Compiler::new(self.stage, self.host)\n     }\n }\n \n-/// Determines what top-level targets are requested as part of this build,\n-/// returning them as a list.\n-fn top_level(build: &Build) -> Vec<Step> {\n-    let mut targets = Vec::new();\n-    let stage = build.flags.stage.unwrap_or(2);\n+pub fn run(build: &Build) {\n+    let rules = build_rules(build);\n+    let steps = rules.plan();\n+    rules.run(&steps);\n+}\n \n-    let host = Step {\n-        src: Source::Llvm { _dummy: () },\n-        target: build.flags.host.iter().next()\n-                     .unwrap_or(&build.config.build),\n-    };\n-    let target = Step {\n-        src: Source::Llvm { _dummy: () },\n-        target: build.flags.target.iter().next().map(|x| &x[..])\n-                     .unwrap_or(host.target)\n+pub fn build_rules(build: &Build) -> Rules {\n+    let mut rules: Rules = Rules::new(build);\n+    // dummy rule to do nothing, useful when a dep maps to no deps\n+    rules.build(\"dummy\", \"path/to/nowhere\");\n+    fn dummy<'a>(s: &Step<'a>, build: &'a Build) -> Step<'a> {\n+        s.name(\"dummy\").stage(0)\n+         .target(&build.config.build)\n+         .host(&build.config.build)\n+    }\n+\n+    // Helper for loading an entire DAG of crates, rooted at `name`\n+    let krates = |name: &str| {\n+        let mut ret = Vec::new();\n+        let mut list = vec![name];\n+        let mut visited = HashSet::new();\n+        while let Some(krate) = list.pop() {\n+            let default = krate == name;\n+            let krate = &build.crates[krate];\n+            let path = krate.path.strip_prefix(&build.src).unwrap();\n+            ret.push((krate, path.to_str().unwrap(), default));\n+            for dep in krate.deps.iter() {\n+                if visited.insert(dep) && dep != \"build_helper\" {\n+                    list.push(dep);\n+                }\n+            }\n+        }\n+        return ret\n     };\n \n-    // First, try to find steps on the command line.\n-    add_steps(build, stage, &host, &target, &mut targets);\n+    rules.build(\"rustc\", \"path/to/nowhere\")\n+         .dep(move |s| {\n+             if s.stage == 0 {\n+                 dummy(s, build)\n+             } else {\n+                 s.name(\"librustc\")\n+                  .host(&build.config.build)\n+                  .stage(s.stage - 1)\n+             }\n+         })\n+         .run(move |s| compile::assemble_rustc(build, s.stage, s.target));\n+    rules.build(\"llvm\", \"src/llvm\")\n+         .host(true)\n+         .run(move |s| native::llvm(build, s.target));\n+\n+    // ========================================================================\n+    // Crate compilations\n+    //\n+    // Tools used during the build system but not shipped\n+    rules.build(\"libstd\", \"src/libstd\")\n+         .dep(|s| s.name(\"build-crate-std_shim\"));\n+    rules.build(\"libtest\", \"src/libtest\")\n+         .dep(|s| s.name(\"build-crate-test_shim\"));\n+    rules.build(\"librustc\", \"src/librustc\")\n+         .dep(|s| s.name(\"build-crate-rustc-main\"));\n+    for (krate, path, _default) in krates(\"std_shim\") {\n+        rules.build(&krate.build_step, path)\n+             .dep(move |s| s.name(\"rustc\").host(&build.config.build).target(s.host))\n+             .dep(move |s| {\n+                 if s.host == build.config.build {\n+                    dummy(s, build)\n+                 } else {\n+                    s.host(&build.config.build)\n+                 }\n+             })\n+             .run(move |s| {\n+                 if s.host == build.config.build {\n+                    compile::std(build, s.target, &s.compiler())\n+                 } else {\n+                    compile::std_link(build, s.target, s.stage, s.host)\n+                 }\n+             });\n+    }\n+    for (krate, path, default) in krates(\"test_shim\") {\n+        rules.build(&krate.build_step, path)\n+             .dep(|s| s.name(\"libstd\"))\n+             .dep(move |s| {\n+                 if s.host == build.config.build {\n+                    dummy(s, build)\n+                 } else {\n+                    s.host(&build.config.build)\n+                 }\n+             })\n+             .default(default)\n+             .run(move |s| {\n+                 if s.host == build.config.build {\n+                    compile::test(build, s.target, &s.compiler())\n+                 } else {\n+                    compile::test_link(build, s.target, s.stage, s.host)\n+                 }\n+             });\n+    }\n+    for (krate, path, default) in krates(\"rustc-main\") {\n+        rules.build(&krate.build_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .dep(move |s| s.name(\"llvm\").host(&build.config.build).stage(0))\n+             .dep(move |s| {\n+                 if s.host == build.config.build {\n+                    dummy(s, build)\n+                 } else {\n+                    s.host(&build.config.build)\n+                 }\n+             })\n+             .host(true)\n+             .default(default)\n+             .run(move |s| {\n+                 if s.host == build.config.build {\n+                    compile::rustc(build, s.target, &s.compiler())\n+                 } else {\n+                    compile::rustc_link(build, s.target, s.stage, s.host)\n+                 }\n+             });\n+    }\n \n-    // If none are specified, then build everything.\n-    if targets.len() == 0 {\n-        let t = Step {\n-            src: Source::Llvm { _dummy: () },\n-            target: &build.config.build,\n+    // ========================================================================\n+    // Test targets\n+    //\n+    // Various unit tests and tests suites we can run\n+    {\n+        let mut suite = |name, path, dir, mode| {\n+            rules.test(name, path)\n+                 .dep(|s| s.name(\"libtest\"))\n+                 .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n+                 .dep(|s| s.name(\"test-helpers\"))\n+                 .dep(move |s| {\n+                     if s.target.contains(\"android\") {\n+                         s.name(\"android-copy-libs\")\n+                     } else {\n+                         dummy(s, build)\n+                     }\n+                 })\n+                 .default(true)\n+                 .run(move |s| {\n+                     check::compiletest(build, &s.compiler(), s.target, dir, mode)\n+                 });\n         };\n-        if build.config.docs {\n-          targets.push(t.doc(stage));\n-        }\n-        for host in build.config.host.iter() {\n-            if !build.flags.host.contains(host) {\n-                continue\n-            }\n-            let host = t.target(host);\n-            if host.target == build.config.build {\n-                targets.push(host.librustc(host.compiler(stage)));\n-            } else {\n-                targets.push(host.librustc_link(t.compiler(stage), host.target));\n-            }\n-            for target in build.config.target.iter() {\n-                if !build.flags.target.contains(target) {\n-                    continue\n-                }\n \n-                if host.target == build.config.build {\n-                    targets.push(host.target(target)\n-                                     .libtest(host.compiler(stage)));\n-                } else {\n-                    targets.push(host.target(target)\n-                                     .libtest_link(t.compiler(stage), host.target));\n-                }\n-            }\n+        suite(\"check-rpass\", \"src/test/run-pass\", \"run-pass\", \"run-pass\");\n+        suite(\"check-cfail\", \"src/test/compile-fail\", \"compile-fail\", \"compile-fail\");\n+        suite(\"check-pfail\", \"src/test/parse-fail\", \"parse-fail\", \"parse-fail\");\n+        suite(\"check-rfail\", \"src/test/run-fail\", \"run-fail\", \"run-fail\");\n+        suite(\"check-rpass-valgrind\", \"src/test/run-pass-valgrind\",\n+              \"run-pass-valgrind\", \"run-pass-valgrind\");\n+        suite(\"check-mir-opt\", \"src/test/mir-opt\", \"mir-opt\", \"mir-opt\");\n+        if build.config.codegen_tests {\n+            suite(\"check-codegen\", \"src/test/codegen\", \"codegen\", \"codegen\");\n         }\n+        suite(\"check-codegen-units\", \"src/test/codegen-units\", \"codegen-units\",\n+              \"codegen-units\");\n+        suite(\"check-incremental\", \"src/test/incremental\", \"incremental\",\n+              \"incremental\");\n+        suite(\"check-ui\", \"src/test/ui\", \"ui\", \"ui\");\n+        suite(\"check-pretty\", \"src/test/pretty\", \"pretty\", \"pretty\");\n+        suite(\"check-pretty-rpass\", \"src/test/run-pass/pretty\", \"pretty\",\n+              \"run-pass\");\n+        suite(\"check-pretty-rfail\", \"src/test/run-pass/pretty\", \"pretty\",\n+              \"run-fail\");\n+        suite(\"check-pretty-valgrind\", \"src/test/run-pass-valgrind\", \"pretty\",\n+              \"run-pass-valgrind\");\n     }\n \n-    targets\n-}\n+    if build.config.build.contains(\"msvc\") {\n+        // nothing to do for debuginfo tests\n+    } else if build.config.build.contains(\"apple\") {\n+        rules.test(\"check-debuginfo\", \"src/test/debuginfo\")\n+             .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"tool-compiletest\").host(s.host))\n+             .dep(|s| s.name(\"test-helpers\"))\n+             .dep(|s| s.name(\"debugger-scripts\"))\n+             .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n+                                         \"debuginfo-lldb\", \"debuginfo\"));\n+    } else {\n+        rules.test(\"check-debuginfo\", \"src/test/debuginfo\")\n+             .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"tool-compiletest\").host(s.host))\n+             .dep(|s| s.name(\"test-helpers\"))\n+             .dep(|s| s.name(\"debugger-scripts\"))\n+             .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n+                                         \"debuginfo-gdb\", \"debuginfo\"));\n+    }\n \n-fn add_steps<'a>(build: &'a Build,\n-                 stage: u32,\n-                 host: &Step<'a>,\n-                 target: &Step<'a>,\n-                 targets: &mut Vec<Step<'a>>) {\n-    struct Context<'a> {\n-        stage: u32,\n-        compiler: Compiler<'a>,\n-        _dummy: (),\n-        host: &'a str,\n-    }\n-    for step in build.flags.step.iter() {\n-\n-        // The macro below insists on hygienic access to all local variables, so\n-        // we shove them all in a struct and subvert hygiene by accessing struct\n-        // fields instead,\n-        let cx = Context {\n-            stage: stage,\n-            compiler: host.target(&build.config.build).compiler(stage),\n-            _dummy: (),\n-            host: host.target,\n+    rules.test(\"debugger-scripts\", \"src/etc/lldb_batchmode.py\")\n+         .run(move |s| dist::debugger_scripts(build, &build.sysroot(&s.compiler()),\n+                                         s.target));\n+\n+    {\n+        let mut suite = |name, path, dir, mode| {\n+            rules.test(name, path)\n+                 .dep(|s| s.name(\"librustc\"))\n+                 .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n+                 .default(true)\n+                 .host(true)\n+                 .run(move |s| {\n+                     check::compiletest(build, &s.compiler(), s.target, dir, mode)\n+                 });\n         };\n-        macro_rules! add_step {\n-            ($(($short:ident, $name:ident { $($arg:ident: $t:ty),* }),)*) => ({$(\n-                let name = stringify!($short).replace(\"_\", \"-\");\n-                if &step[..] == &name[..] {\n-                    targets.push(target.$short($(cx.$arg),*));\n-                    continue\n-                }\n-                drop(name);\n-            )*})\n+\n+        suite(\"check-rpass-full\", \"src/test/run-pass-fulldeps\",\n+              \"run-pass\", \"run-pass-fulldeps\");\n+        suite(\"check-cfail-full\", \"src/test/compile-fail-fulldeps\",\n+              \"compile-fail\", \"compile-fail-fulldeps\");\n+        suite(\"check-rmake\", \"src/test/run-make\", \"run-make\", \"run-make\");\n+        suite(\"check-rustdoc\", \"src/test/rustdoc\", \"rustdoc\", \"rustdoc\");\n+        suite(\"check-pretty-rpass-full\", \"src/test/run-pass-fulldeps\",\n+              \"pretty\", \"run-pass-fulldeps\");\n+        suite(\"check-pretty-rfail-full\", \"src/test/run-fail-fulldeps\",\n+              \"pretty\", \"run-fail-fulldeps\");\n+    }\n+\n+    for (krate, path, _default) in krates(\"std_shim\") {\n+        rules.test(&krate.test_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                        Mode::Libstd, Some(&krate.name)));\n+    }\n+    rules.test(\"check-std-all\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .default(true)\n+         .run(move |s| check::krate(build, &s.compiler(), s.target, Mode::Libstd,\n+                               None));\n+    for (krate, path, _default) in krates(\"test_shim\") {\n+        rules.test(&krate.test_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                        Mode::Libtest, Some(&krate.name)));\n+    }\n+    rules.test(\"check-test-all\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .default(true)\n+         .run(move |s| check::krate(build, &s.compiler(), s.target, Mode::Libtest,\n+                               None));\n+    for (krate, path, _default) in krates(\"rustc-main\") {\n+        rules.test(&krate.test_step, path)\n+             .dep(|s| s.name(\"librustc\"))\n+             .host(true)\n+             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                        Mode::Librustc, Some(&krate.name)));\n+    }\n+    rules.test(\"check-rustc-all\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"librustc\"))\n+         .default(true)\n+         .host(true)\n+         .run(move |s| check::krate(build, &s.compiler(), s.target, Mode::Librustc,\n+                               None));\n+\n+    rules.test(\"check-linkchecker\", \"src/tools/linkchecker\")\n+         .dep(|s| s.name(\"tool-linkchecker\"))\n+         .dep(|s| s.name(\"default:doc\"))\n+         .default(true)\n+         .host(true)\n+         .run(move |s| check::linkcheck(build, s.stage, s.target));\n+    rules.test(\"check-cargotest\", \"src/tools/cargotest\")\n+         .dep(|s| s.name(\"tool-cargotest\"))\n+         .dep(|s| s.name(\"librustc\"))\n+         .host(true)\n+         .run(move |s| check::cargotest(build, s.stage, s.target));\n+    rules.test(\"check-tidy\", \"src/tools/tidy\")\n+         .dep(|s| s.name(\"tool-tidy\"))\n+         .default(true)\n+         .host(true)\n+         .run(move |s| check::tidy(build, s.stage, s.target));\n+    rules.test(\"check-error-index\", \"src/tools/error_index_generator\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"tool-error-index\").host(s.host))\n+         .default(true)\n+         .host(true)\n+         .run(move |s| check::error_index(build, &s.compiler()));\n+    rules.test(\"check-docs\", \"src/doc\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .default(true)\n+         .host(true)\n+         .run(move |s| check::docs(build, &s.compiler()));\n+\n+    rules.build(\"test-helpers\", \"src/rt/rust_test_helpers.c\")\n+         .run(move |s| native::test_helpers(build, s.target));\n+    rules.test(\"android-copy-libs\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .run(move |s| check::android_copy_libs(build, &s.compiler(), s.target));\n+\n+    // ========================================================================\n+    // Build tools\n+    //\n+    // Tools used during the build system but not shipped\n+    rules.build(\"tool-rustbook\", \"src/tools/rustbook\")\n+         .dep(|s| s.name(\"librustc\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"rustbook\"));\n+    rules.build(\"tool-error-index\", \"src/tools/error_index_generator\")\n+         .dep(|s| s.name(\"librustc\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"error_index_generator\"));\n+    rules.build(\"tool-tidy\", \"src/tools/tidy\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"tidy\"));\n+    rules.build(\"tool-linkchecker\", \"src/tools/linkchecker\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"linkchecker\"));\n+    rules.build(\"tool-cargotest\", \"src/tools/cargotest\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"cargotest\"));\n+    rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n+\n+    // ========================================================================\n+    // Documentation targets\n+    rules.doc(\"doc-book\", \"src/doc/book\")\n+         .dep(move |s| s.name(\"tool-rustbook\").target(&build.config.build))\n+         .default(build.config.docs)\n+         .run(move |s| doc::rustbook(build, s.stage, s.target, \"book\"));\n+    rules.doc(\"doc-nomicon\", \"src/doc/nomicon\")\n+         .dep(move |s| s.name(\"tool-rustbook\").target(&build.config.build))\n+         .default(build.config.docs)\n+         .run(move |s| doc::rustbook(build, s.stage, s.target, \"nomicon\"));\n+    rules.doc(\"doc-standalone\", \"src/doc\")\n+         .dep(move |s| s.name(\"rustc\").host(&build.config.build).target(&build.config.build))\n+         .default(build.config.docs)\n+         .run(move |s| doc::standalone(build, s.stage, s.target));\n+    rules.doc(\"doc-error-index\", \"src/tools/error_index_generator\")\n+         .dep(move |s| s.name(\"tool-error-index\").target(&build.config.build))\n+         .dep(move |s| s.name(\"librustc\"))\n+         .default(build.config.docs)\n+         .host(true)\n+         .run(move |s| doc::error_index(build, s.stage, s.target));\n+    for (krate, path, default) in krates(\"std_shim\") {\n+        rules.doc(&krate.doc_step, path)\n+             .dep(|s| s.name(\"libstd\"))\n+             .default(default && build.config.docs)\n+             .run(move |s| doc::std(build, s.stage, s.target));\n+    }\n+    for (krate, path, default) in krates(\"test_shim\") {\n+        rules.doc(&krate.doc_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .default(default && build.config.docs)\n+             .run(move |s| doc::test(build, s.stage, s.target));\n+    }\n+    for (krate, path, default) in krates(\"rustc-main\") {\n+        rules.doc(&krate.doc_step, path)\n+             .dep(|s| s.name(\"librustc\"))\n+             .host(true)\n+             .default(default && build.config.compiler_docs)\n+             .run(move |s| doc::rustc(build, s.stage, s.target));\n+    }\n+\n+    // ========================================================================\n+    // Distribution targets\n+    rules.dist(\"dist-rustc\", \"src/librustc\")\n+         .dep(move |s| s.name(\"rustc\").host(&build.config.build))\n+         .host(true)\n+         .default(true)\n+         .run(move |s| dist::rustc(build, s.stage, s.target));\n+    rules.dist(\"dist-std\", \"src/libstd\")\n+         .dep(move |s| {\n+             // We want to package up as many target libraries as possible\n+             // for the `rust-std` package, so if this is a host target we\n+             // depend on librustc and otherwise we just depend on libtest.\n+             if build.config.host.iter().any(|t| t == s.target) {\n+                 s.name(\"librustc\")\n+             } else {\n+                 s.name(\"libtest\")\n+             }\n+         })\n+         .default(true)\n+         .run(move |s| dist::std(build, &s.compiler(), s.target));\n+    rules.dist(\"dist-mingw\", \"path/to/nowhere\")\n+         .run(move |s| dist::mingw(build, s.target));\n+    rules.dist(\"dist-src\", \"src\")\n+         .default(true)\n+         .host(true)\n+         .run(move |_| dist::rust_src(build));\n+    rules.dist(\"dist-docs\", \"src/doc\")\n+         .dep(|s| s.name(\"default:doc\"))\n+         .run(move |s| dist::docs(build, s.stage, s.target));\n+    rules.dist(\"install\", \"src\")\n+         .dep(|s| s.name(\"default:dist\"))\n+         .run(move |s| install::install(build, s.stage, s.target));\n+\n+    rules.verify();\n+    return rules\n+}\n+\n+struct Rule<'a> {\n+    name: &'a str,\n+    path: &'a str,\n+    kind: Kind,\n+    deps: Vec<Box<Fn(&Step<'a>) -> Step<'a> + 'a>>,\n+    run: Box<Fn(&Step<'a>) + 'a>,\n+    default: bool,\n+    host: bool,\n+}\n+\n+#[derive(PartialEq)]\n+enum Kind {\n+    Build,\n+    Test,\n+    Dist,\n+    Doc,\n+}\n+\n+impl<'a> Rule<'a> {\n+    fn new(name: &'a str, path: &'a str, kind: Kind) -> Rule<'a> {\n+        Rule {\n+            name: name,\n+            deps: Vec::new(),\n+            run: Box::new(|_| ()),\n+            path: path,\n+            kind: kind,\n+            default: false,\n+            host: false,\n         }\n+    }\n+}\n+\n+struct RuleBuilder<'a: 'b, 'b> {\n+    rules: &'b mut Rules<'a>,\n+    rule: Rule<'a>,\n+}\n \n-        targets!(add_step);\n+impl<'a, 'b> RuleBuilder<'a, 'b> {\n+    fn dep<F>(&mut self, f: F) -> &mut Self\n+        where F: Fn(&Step<'a>) -> Step<'a> + 'a,\n+    {\n+        self.rule.deps.push(Box::new(f));\n+        self\n+    }\n+\n+    fn run<F>(&mut self, f: F) -> &mut Self\n+        where F: Fn(&Step<'a>) + 'a,\n+    {\n+        self.rule.run = Box::new(f);\n+        self\n+    }\n+\n+    fn default(&mut self, default: bool) -> &mut Self {\n+        self.rule.default = default;\n+        self\n+    }\n \n-        panic!(\"unknown step: {}\", step);\n+    fn host(&mut self, host: bool) -> &mut Self {\n+        self.rule.host = host;\n+        self\n     }\n }\n \n-macro_rules! constructors {\n-    ($(($short:ident, $name:ident { $($arg:ident: $t:ty),* }),)*) => {$(\n-        fn $short(&self, $($arg: $t),*) -> Step<'a> {\n-            Step {\n-                src: Source::$name { $($arg: $arg),* },\n-                target: self.target,\n-            }\n+impl<'a, 'b> Drop for RuleBuilder<'a, 'b> {\n+    fn drop(&mut self) {\n+        let rule = mem::replace(&mut self.rule, Rule::new(\"\", \"\", Kind::Build));\n+        let prev = self.rules.rules.insert(rule.name, rule);\n+        if let Some(prev) = prev {\n+            panic!(\"duplicate rule named: {}\", prev.name);\n         }\n-    )*}\n+    }\n }\n \n-impl<'a> Step<'a> {\n-    fn compiler(&self, stage: u32) -> Compiler<'a> {\n-        Compiler::new(stage, self.target)\n+pub struct Rules<'a> {\n+    build: &'a Build,\n+    sbuild: Step<'a>,\n+    rules: HashMap<&'a str, Rule<'a>>,\n+}\n+\n+impl<'a> Rules<'a> {\n+    fn new(build: &'a Build) -> Rules<'a> {\n+        Rules {\n+            build: build,\n+            sbuild: Step {\n+                stage: build.flags.stage.unwrap_or(2),\n+                target: &build.config.build,\n+                host: &build.config.build,\n+                name: \"\",\n+            },\n+            rules: HashMap::new(),\n+        }\n     }\n \n-    fn target(&self, target: &'a str) -> Step<'a> {\n-        Step { target: target, src: self.src.clone() }\n+    fn build<'b>(&'b mut self, name: &'a str, path: &'a str)\n+                 -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Build)\n     }\n \n-    // Define ergonomic constructors for each step defined above so they can be\n-    // easily constructed.\n-    targets!(constructors);\n+    fn test<'b>(&'b mut self, name: &'a str, path: &'a str)\n+                -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Test)\n+    }\n \n-    /// Mapping of all dependencies for rustbuild.\n-    ///\n-    /// This function receives a step, the build that we're building for, and\n-    /// then returns a list of all the dependencies of that step.\n-    pub fn deps(&self, build: &'a Build) -> Vec<Step<'a>> {\n-        match self.src {\n-            Source::Rustc { stage: 0 } => {\n-                Vec::new()\n-            }\n-            Source::Rustc { stage } => {\n-                let compiler = Compiler::new(stage - 1, &build.config.build);\n-                vec![self.librustc(compiler)]\n-            }\n-            Source::Librustc { compiler } => {\n-                vec![self.libtest(compiler), self.llvm(())]\n-            }\n-            Source::Libtest { compiler } => {\n-                vec![self.libstd(compiler)]\n-            }\n-            Source::Libstd { compiler } => {\n-                vec![self.rustc(compiler.stage).target(compiler.host)]\n-            }\n-            Source::LibrustcLink { compiler, host } => {\n-                vec![self.librustc(compiler),\n-                     self.libtest_link(compiler, host)]\n-            }\n-            Source::LibtestLink { compiler, host } => {\n-                vec![self.libtest(compiler), self.libstd_link(compiler, host)]\n-            }\n-            Source::LibstdLink { compiler, host } => {\n-                vec![self.libstd(compiler),\n-                     self.target(host).rustc(compiler.stage)]\n-            }\n-            Source::Llvm { _dummy } => Vec::new(),\n-            Source::TestHelpers { _dummy } => Vec::new(),\n-            Source::DebuggerScripts { stage: _ } => Vec::new(),\n-\n-            // Note that all doc targets depend on artifacts from the build\n-            // architecture, not the target (which is where we're generating\n-            // docs into).\n-            Source::DocStd { stage } => {\n-                let compiler = self.target(&build.config.build).compiler(stage);\n-                vec![self.libstd(compiler)]\n-            }\n-            Source::DocTest { stage } => {\n-                let compiler = self.target(&build.config.build).compiler(stage);\n-                vec![self.libtest(compiler)]\n-            }\n-            Source::DocBook { stage } |\n-            Source::DocNomicon { stage } => {\n-                vec![self.target(&build.config.build).tool_rustbook(stage)]\n-            }\n-            Source::DocErrorIndex { stage } => {\n-                vec![self.target(&build.config.build).tool_error_index(stage)]\n-            }\n-            Source::DocStandalone { stage } => {\n-                vec![self.target(&build.config.build).rustc(stage)]\n-            }\n-            Source::DocRustc { stage } => {\n-                vec![self.doc_test(stage)]\n-            }\n-            Source::Doc { stage } => {\n-                let mut deps = vec![\n-                    self.doc_book(stage), self.doc_nomicon(stage),\n-                    self.doc_standalone(stage), self.doc_std(stage),\n-                    self.doc_error_index(stage),\n-                ];\n-\n-                if build.config.compiler_docs {\n-                    deps.push(self.doc_rustc(stage));\n-                }\n+    fn doc<'b>(&'b mut self, name: &'a str, path: &'a str)\n+               -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Doc)\n+    }\n \n-                deps\n-            }\n-            Source::Check { stage, compiler } => {\n-                // Check is just a pseudo step which means check all targets,\n-                // so just depend on checking all targets.\n-                build.config.target.iter().map(|t| {\n-                    self.target(t).check_target(stage, compiler)\n-                }).collect()\n-            }\n-            Source::CheckTarget { stage, compiler } => {\n-                // CheckTarget here means run all possible test suites for this\n-                // target. Most of the time, however, we can't actually run\n-                // anything if we're not the build triple as we could be cross\n-                // compiling.\n-                //\n-                // As a result, the base set of targets here is quite stripped\n-                // down from the standard set of targets. These suites have\n-                // their own internal logic to run in cross-compiled situations\n-                // if they'll run at all. For example compiletest knows that\n-                // when testing Android targets we ship artifacts to the\n-                // emulator.\n-                //\n-                // When in doubt the rule of thumb for adding to this list is\n-                // \"should this test suite run on the android bot?\"\n-                let mut base = vec![\n-                    self.check_rpass(compiler),\n-                    self.check_rfail(compiler),\n-                    self.check_crate_std(compiler),\n-                    self.check_crate_test(compiler),\n-                    self.check_debuginfo(compiler),\n-                ];\n-\n-                // If we're testing the build triple, then we know we can\n-                // actually run binaries and such, so we run all possible tests\n-                // that we know about.\n-                if self.target == build.config.build {\n-                    base.extend(vec![\n-                        // docs-related\n-                        self.check_docs(compiler),\n-                        self.check_error_index(compiler),\n-                        self.check_rustdoc(compiler),\n-\n-                        // UI-related\n-                        self.check_cfail(compiler),\n-                        self.check_pfail(compiler),\n-                        self.check_ui(compiler),\n-\n-                        // codegen-related\n-                        self.check_incremental(compiler),\n-                        self.check_codegen(compiler),\n-                        self.check_codegen_units(compiler),\n-\n-                        // misc compiletest-test suites\n-                        self.check_rpass_full(compiler),\n-                        self.check_rfail_full(compiler),\n-                        self.check_cfail_full(compiler),\n-                        self.check_pretty_rpass_full(compiler),\n-                        self.check_pretty_rfail_full(compiler),\n-                        self.check_rpass_valgrind(compiler),\n-                        self.check_rmake(compiler),\n-                        self.check_mir_opt(compiler),\n-\n-                        // crates\n-                        self.check_crate_rustc(compiler),\n-\n-                        // pretty\n-                        self.check_pretty(compiler),\n-                        self.check_pretty_rpass(compiler),\n-                        self.check_pretty_rfail(compiler),\n-                        self.check_pretty_rpass_valgrind(compiler),\n-\n-                        // misc\n-                        self.check_linkcheck(stage),\n-                        self.check_tidy(stage),\n-\n-                        // can we make the distributables?\n-                        self.dist(stage),\n-                    ]);\n-                }\n-                base\n-            }\n-            Source::CheckLinkcheck { stage } => {\n-                vec![self.tool_linkchecker(stage), self.doc(stage)]\n-            }\n-            Source::CheckCargoTest { stage } => {\n-                vec![self.tool_cargotest(stage),\n-                     self.librustc(self.compiler(stage))]\n-            }\n-            Source::CheckTidy { stage } => {\n-                vec![self.tool_tidy(stage)]\n-            }\n-            Source::CheckMirOpt { compiler} |\n-            Source::CheckPrettyRPass { compiler } |\n-            Source::CheckPrettyRFail { compiler } |\n-            Source::CheckRFail { compiler } |\n-            Source::CheckPFail { compiler } |\n-            Source::CheckCodegen { compiler } |\n-            Source::CheckCodegenUnits { compiler } |\n-            Source::CheckIncremental { compiler } |\n-            Source::CheckUi { compiler } |\n-            Source::CheckPretty { compiler } |\n-            Source::CheckCFail { compiler } |\n-            Source::CheckRPassValgrind { compiler } |\n-            Source::CheckRPass { compiler } => {\n-                let mut base = vec![\n-                    self.libtest(compiler),\n-                    self.target(compiler.host).tool_compiletest(compiler.stage),\n-                    self.test_helpers(()),\n-                ];\n-                if self.target.contains(\"android\") {\n-                    base.push(self.android_copy_libs(compiler));\n-                }\n-                base\n-            }\n-            Source::CheckDebuginfo { compiler } => {\n-                vec![\n-                    self.libtest(compiler),\n-                    self.target(compiler.host).tool_compiletest(compiler.stage),\n-                    self.test_helpers(()),\n-                    self.debugger_scripts(compiler.stage),\n-                ]\n-            }\n-            Source::CheckRustdoc { compiler } |\n-            Source::CheckRPassFull { compiler } |\n-            Source::CheckRFailFull { compiler } |\n-            Source::CheckCFailFull { compiler } |\n-            Source::CheckPrettyRPassFull { compiler } |\n-            Source::CheckPrettyRFailFull { compiler } |\n-            Source::CheckPrettyRPassValgrind { compiler } |\n-            Source::CheckRMake { compiler } => {\n-                vec![self.librustc(compiler),\n-                     self.target(compiler.host).tool_compiletest(compiler.stage)]\n-            }\n-            Source::CheckDocs { compiler } => {\n-                vec![self.libtest(compiler)]\n-            }\n-            Source::CheckErrorIndex { compiler } => {\n-                vec![self.libstd(compiler),\n-                     self.target(compiler.host).tool_error_index(compiler.stage)]\n-            }\n-            Source::CheckCrateStd { compiler } => {\n-                vec![self.libtest(compiler)]\n-            }\n-            Source::CheckCrateTest { compiler } => {\n-                vec![self.libtest(compiler)]\n-            }\n-            Source::CheckCrateRustc { compiler } => {\n-                vec![self.libtest(compiler)]\n-            }\n+    fn dist<'b>(&'b mut self, name: &'a str, path: &'a str)\n+                -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Dist)\n+    }\n \n-            Source::ToolLinkchecker { stage } |\n-            Source::ToolTidy { stage } => {\n-                vec![self.libstd(self.compiler(stage))]\n-            }\n-            Source::ToolErrorIndex { stage } |\n-            Source::ToolRustbook { stage } => {\n-                vec![self.librustc(self.compiler(stage))]\n-            }\n-            Source::ToolCargoTest { stage } => {\n-                vec![self.libstd(self.compiler(stage))]\n-            }\n-            Source::ToolCompiletest { stage } => {\n-                vec![self.libtest(self.compiler(stage))]\n-            }\n+    fn rule<'b>(&'b mut self,\n+                name: &'a str,\n+                path: &'a str,\n+                kind: Kind) -> RuleBuilder<'a, 'b> {\n+        RuleBuilder {\n+            rules: self,\n+            rule: Rule::new(name, path, kind),\n+        }\n+    }\n+\n+    /// Verify the dependency graph defined by all our rules are correct, e.g.\n+    /// everything points to a valid something else.\n+    fn verify(&self) {\n+        for rule in self.rules.values() {\n+            for dep in rule.deps.iter() {\n+                let dep = dep(&self.sbuild.name(rule.name));\n+                if self.rules.contains_key(&dep.name) || dep.name.starts_with(\"default:\") {\n+                    continue }\n+                panic!(\"\\\n+\n+invalid rule dependency graph detected, was a rule added and maybe typo'd?\n+\n+    `{}` depends on `{}` which does not exist\n \n-            Source::DistDocs { stage } => vec![self.doc(stage)],\n-            Source::DistMingw { _dummy: _ } => Vec::new(),\n-            Source::DistRustc { stage } => {\n-                vec![self.rustc(stage)]\n+\", rule.name, dep.name);\n             }\n-            Source::DistStd { compiler } => {\n-                // We want to package up as many target libraries as possible\n-                // for the `rust-std` package, so if this is a host target we\n-                // depend on librustc and otherwise we just depend on libtest.\n-                if build.config.host.iter().any(|t| t == self.target) {\n-                    vec![self.librustc(compiler)]\n+        }\n+    }\n+\n+    pub fn print_help(&self, command: &str) {\n+        let kind = match command {\n+            \"build\" => Kind::Build,\n+            \"doc\" => Kind::Doc,\n+            \"test\" => Kind::Test,\n+            \"dist\" => Kind::Dist,\n+            _ => return,\n+        };\n+        let rules = self.rules.values().filter(|r| r.kind == kind);\n+        let rules = rules.filter(|r| !r.path.contains(\"nowhere\"));\n+        let mut rules = rules.collect::<Vec<_>>();\n+        rules.sort_by_key(|r| r.path);\n+\n+        println!(\"Available paths:\\n\");\n+        for rule in rules {\n+            print!(\"    ./x.py {} {}\", command, rule.path);\n+\n+            println!(\"\");\n+        }\n+    }\n+\n+    /// Construct the top-level build steps that we're going to be executing,\n+    /// given the subcommand that our build is performing.\n+    fn plan(&self) -> Vec<Step<'a>> {\n+        let (kind, paths) = match self.build.flags.cmd {\n+            Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n+            Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n+            Subcommand::Test { ref paths, test_args: _ } => (Kind::Test, &paths[..]),\n+            Subcommand::Dist { install } => {\n+                if install {\n+                    return vec![self.sbuild.name(\"install\")]\n                 } else {\n-                    vec![self.libtest(compiler)]\n-                }\n-            }\n-            Source::DistSrc { _dummy: _ } => Vec::new(),\n-\n-            Source::Dist { stage } => {\n-                let mut base = Vec::new();\n-\n-                for host in build.config.host.iter() {\n-                    let host = self.target(host);\n-                    base.push(host.dist_src(()));\n-                    base.push(host.dist_rustc(stage));\n-                    if host.target.contains(\"windows-gnu\") {\n-                        base.push(host.dist_mingw(()));\n-                    }\n-\n-                    let compiler = self.compiler(stage);\n-                    for target in build.config.target.iter() {\n-                        let target = self.target(target);\n-                        if build.config.docs {\n-                            base.push(target.dist_docs(stage));\n-                        }\n-                        base.push(target.dist_std(compiler));\n-                    }\n+                    (Kind::Dist, &[][..])\n                 }\n-                base\n             }\n+            Subcommand::Clean => panic!(),\n+        };\n \n-            Source::Install { stage } => {\n-                vec![self.dist(stage)]\n-            }\n+        self.rules.values().filter(|rule| rule.kind == kind).filter(|rule| {\n+            (paths.len() == 0 && rule.default) || paths.iter().any(|path| {\n+                path.ends_with(rule.path)\n+            })\n+        }).flat_map(|rule| {\n+            let hosts = if self.build.flags.host.len() > 0 {\n+                &self.build.flags.host\n+            } else {\n+                &self.build.config.host\n+            };\n+            let targets = if self.build.flags.target.len() > 0 {\n+                &self.build.flags.target\n+            } else {\n+                &self.build.config.target\n+            };\n+            let arr = if rule.host {hosts} else {targets};\n+\n+            hosts.iter().flat_map(move |host| {\n+                arr.iter().map(move |target| {\n+                    self.sbuild.name(rule.name).target(target).host(host)\n+                })\n+            })\n+        }).collect()\n+    }\n+\n+    /// Execute all top-level targets indicated by `steps`.\n+    ///\n+    /// This will take the list returned by `plan` and then execute each step\n+    /// along with all required dependencies as it goes up the chain.\n+    fn run(&self, steps: &[Step<'a>]) {\n+        self.build.verbose(\"bootstrap top targets:\");\n+        for step in steps.iter() {\n+            self.build.verbose(&format!(\"\\t{:?}\", step));\n+        }\n+\n+        // Using `steps` as the top-level targets, make a topological ordering\n+        // of what we need to do.\n+        let mut order = Vec::new();\n+        let mut added = HashSet::new();\n+        for step in steps.iter().cloned() {\n+            self.fill(step, &mut order, &mut added);\n+        }\n \n-            Source::AndroidCopyLibs { compiler } => {\n-                vec![self.libtest(compiler)]\n+        // Print out what we're doing for debugging\n+        self.build.verbose(\"bootstrap build plan:\");\n+        for step in order.iter() {\n+            self.build.verbose(&format!(\"\\t{:?}\", step));\n+        }\n+\n+        // And finally, iterate over everything and execute it.\n+        for step in order.iter() {\n+            self.build.verbose(&format!(\"executing step {:?}\", step));\n+            (self.rules[step.name].run)(step);\n+        }\n+    }\n+\n+    fn fill(&self,\n+            step: Step<'a>,\n+            order: &mut Vec<Step<'a>>,\n+            added: &mut HashSet<Step<'a>>) {\n+        if !added.insert(step.clone()) {\n+            return\n+        }\n+        for dep in self.rules[step.name].deps.iter() {\n+            let dep = dep(&step);\n+            if dep.name.starts_with(\"default:\") {\n+                let kind = match &dep.name[8..] {\n+                    \"doc\" => Kind::Doc,\n+                    \"dist\" => Kind::Dist,\n+                    kind => panic!(\"unknown kind: `{}`\", kind),\n+                };\n+                let rules = self.rules.values().filter(|r| r.default);\n+                for rule in rules.filter(|r| r.kind == kind) {\n+                    self.fill(dep.name(rule.name), order, added);\n+                }\n+            } else {\n+                self.fill(dep, order, added);\n             }\n         }\n+        order.push(step);\n     }\n }"}, {"sha": "e028c52236662bb23d60a143d6863f7badffb3ac", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -57,8 +57,7 @@ pub fn cp_r(src: &Path, dst: &Path) {\n         let name = path.file_name().unwrap();\n         let dst = dst.join(name);\n         if t!(f.file_type()).is_dir() {\n-            let _ = fs::remove_dir_all(&dst);\n-            t!(fs::create_dir(&dst));\n+            t!(fs::create_dir_all(&dst));\n             cp_r(&path, &dst);\n         } else {\n             let _ = fs::remove_file(&dst);\n@@ -172,3 +171,21 @@ pub fn dylib_path() -> Vec<PathBuf> {\n     env::split_paths(&env::var_os(dylib_path_var()).unwrap_or(OsString::new()))\n         .collect()\n }\n+\n+/// `push` all components to `buf`. On windows, append `.exe` to the last component.\n+pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n+    let (&file, components) = components.split_last().expect(\"at least one component required\");\n+    let mut file = file.to_owned();\n+\n+    if cfg!(windows) {\n+        file.push_str(\".exe\");\n+    }\n+\n+    for c in components {\n+        buf.push(c);\n+    }\n+\n+    buf.push(file);\n+\n+    buf\n+}"}, {"sha": "ecd2b1f6d689d5afbf5debe8afb3739337323852", "filename": "src/compiler-rt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler-rt?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1 +1 @@\n-Subproject commit f03ba5a4e8bf16dcf42dd742a4ce255c36321356\n+Subproject commit ecd2b1f6d689d5afbf5debe8afb3739337323852"}, {"sha": "fa9f66d43baa1ae7105c76516d1b8729663730f6", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -327,7 +327,7 @@ that takes a reference like so:\n fn call_with_ref<F>(some_closure:F) -> i32\n     where F: Fn(&i32) -> i32 {\n \n-    let mut value = 0;\n+    let value = 0;\n     some_closure(&value)\n }\n ```\n@@ -340,14 +340,15 @@ fn call_with_ref<'a, F>(some_closure:F) -> i32\n     where F: Fn(&'a i32) -> i32 {\n ```\n \n-However this presents a problem in our case. When you specify the explicit\n-lifetime on a function it binds that lifetime to the *entire* scope of the function\n-instead of just the invocation scope of our closure. This means that the borrow checker\n-will see a mutable reference in the same lifetime as our immutable reference and fail\n-to compile.\n+However, this presents a problem in our case. When a function has an explicit\n+lifetime parameter, that lifetime must be at least as long as the *entire*\n+call to that function.  The borrow checker will complain that `value` doesn't\n+live long enough, because it is only in scope after its declaration inside the\n+function body.\n \n-In order to say that we only need the lifetime to be valid for the invocation scope\n-of the closure we can use Higher-Ranked Trait Bounds with the `for<...>` syntax:\n+What we need is a closure that can borrow its argument only for its own\n+invocation scope, not for the outer function's scope.  In order to say that,\n+we can use Higher-Ranked Trait Bounds with the `for<...>` syntax:\n \n ```ignore\n fn call_with_ref<F>(some_closure:F) -> i32\n@@ -362,7 +363,7 @@ expect.\n fn call_with_ref<F>(some_closure:F) -> i32\n     where F: for<'a> Fn(&'a i32) -> i32 {\n \n-    let mut value = 0;\n+    let value = 0;\n     some_closure(&value)\n }\n ```"}, {"sha": "37618b7600a045d340869403f786709a0b0b235e", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -17,6 +17,7 @@ use core::hash::{Hash, Hasher};\n use core::ops::{Add, AddAssign, Deref};\n \n use fmt;\n+use string::String;\n \n use self::Cow::*;\n \n@@ -159,7 +160,10 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n         match *self {\n             Borrowed(borrowed) => {\n                 *self = Owned(borrowed.to_owned());\n-                self.to_mut()\n+                match *self {\n+                    Borrowed(..) => unreachable!(),\n+                    Owned(ref mut owned) => owned,\n+                }\n             }\n             Owned(ref mut owned) => owned,\n         }\n@@ -284,48 +288,60 @@ impl<'a, T: ?Sized + ToOwned> AsRef<T> for Cow<'a, T> {\n     }\n }\n \n-#[stable(feature = \"cow_add\", since = \"1.13.0\")]\n+#[stable(feature = \"cow_add\", since = \"1.14.0\")]\n impl<'a> Add<&'a str> for Cow<'a, str> {\n     type Output = Cow<'a, str>;\n \n-    fn add(self, rhs: &'a str) -> Self {\n-        if self == \"\" {\n-            Cow::Borrowed(rhs)\n-        } else if rhs == \"\" {\n-            self\n-        } else {\n-            Cow::Owned(self.into_owned() + rhs)\n-        }\n+    #[inline]\n+    fn add(mut self, rhs: &'a str) -> Self::Output {\n+        self += rhs;\n+        self\n     }\n }\n \n-#[stable(feature = \"cow_add\", since = \"1.13.0\")]\n+#[stable(feature = \"cow_add\", since = \"1.14.0\")]\n impl<'a> Add<Cow<'a, str>> for Cow<'a, str> {\n     type Output = Cow<'a, str>;\n \n-    fn add(self, rhs: Cow<'a, str>) -> Self {\n-        if self == \"\" {\n-            rhs\n-        } else if rhs == \"\" {\n-            self\n-        } else {\n-            Cow::Owned(self.into_owned() + rhs.borrow())\n-        }\n+    #[inline]\n+    fn add(mut self, rhs: Cow<'a, str>) -> Self::Output {\n+        self += rhs;\n+        self\n     }\n }\n \n-#[stable(feature = \"cow_add\", since = \"1.13.0\")]\n+#[stable(feature = \"cow_add\", since = \"1.14.0\")]\n impl<'a> AddAssign<&'a str> for Cow<'a, str> {\n     fn add_assign(&mut self, rhs: &'a str) {\n-        if rhs == \"\" { return; }\n-        self.to_mut().push_str(rhs);\n+        if self.is_empty() {\n+            *self = Cow::Borrowed(rhs)\n+        } else if rhs.is_empty() {\n+            return;\n+        } else {\n+            if let Cow::Borrowed(lhs) = *self {\n+                let mut s = String::with_capacity(lhs.len() + rhs.len());\n+                s.push_str(lhs);\n+                *self = Cow::Owned(s);\n+            }\n+            self.to_mut().push_str(rhs);\n+        }\n     }\n }\n \n-#[stable(feature = \"cow_add\", since = \"1.13.0\")]\n+#[stable(feature = \"cow_add\", since = \"1.14.0\")]\n impl<'a> AddAssign<Cow<'a, str>> for Cow<'a, str> {\n     fn add_assign(&mut self, rhs: Cow<'a, str>) {\n-        if rhs == \"\" { return; }\n-        self.to_mut().push_str(rhs.borrow());\n+        if self.is_empty() {\n+            *self = rhs\n+        } else if rhs.is_empty() {\n+            return;\n+        } else {\n+            if let Cow::Borrowed(lhs) = *self {\n+                let mut s = String::with_capacity(lhs.len() + rhs.len());\n+                s.push_str(lhs);\n+                *self = Cow::Owned(s);\n+            }\n+            self.to_mut().push_str(&rhs);\n+        }\n     }\n }"}, {"sha": "348eb6fb5ffa4806c5ff7b1fcfcefd9db5166735", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1904,10 +1904,10 @@ impl<'a> FromIterator<String> for Cow<'a, str> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Into<Vec<u8>> for String {\n-    fn into(self) -> Vec<u8> {\n-        self.into_bytes()\n+#[stable(feature = \"from_string_for_vec_u8\", since = \"1.14.0\")]\n+impl From<String> for Vec<u8> {\n+    fn from(string : String) -> Vec<u8> {\n+        string.into_bytes()\n     }\n }\n "}, {"sha": "b29245121daadeb52d6c206130090d43e9406008", "filename": "src/libcollectionstest/cow_str.rs", "status": "modified", "additions": 105, "deletions": 29, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibcollectionstest%2Fcow_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibcollectionstest%2Fcow_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fcow_str.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -12,54 +12,130 @@ use std::borrow::Cow;\n \n // check that Cow<'a, str> implements addition\n #[test]\n-fn check_cow_add() {\n-    borrowed1 = Cow::Borrowed(\"Hello, \");\n-    borrowed2 = Cow::Borrowed(\"World!\");\n-    borrow_empty = Cow::Borrowed(\"\");\n+fn check_cow_add_cow() {\n+    let borrowed1 = Cow::Borrowed(\"Hello, \");\n+    let borrowed2 = Cow::Borrowed(\"World!\");\n+    let borrow_empty = Cow::Borrowed(\"\");\n \n-    owned1 = Cow::Owned(\"Hi, \".into());\n-    owned2 = Cow::Owned(\"Rustaceans!\".into());\n-    owned_empty = Cow::Owned(\"\".into());\n+    let owned1: Cow<str> = Cow::Owned(String::from(\"Hi, \"));\n+    let owned2: Cow<str> = Cow::Owned(String::from(\"Rustaceans!\"));\n+    let owned_empty: Cow<str> = Cow::Owned(String::new());\n \n-    assert_eq!(\"Hello, World!\", borrowed1 + borrowed2);\n-    assert_eq!(\"Hello, Rustaceans!\", borrowed1 + owned2);\n+    assert_eq!(\"Hello, World!\", borrowed1.clone() + borrowed2.clone());\n+    assert_eq!(\"Hello, Rustaceans!\", borrowed1.clone() + owned2.clone());\n \n-    assert_eq!(\"Hello, World!\", owned1 + borrowed2);\n-    assert_eq!(\"Hello, Rustaceans!\", owned1 + owned2);\n+    assert_eq!(\"Hi, World!\", owned1.clone() + borrowed2.clone());\n+    assert_eq!(\"Hi, Rustaceans!\", owned1.clone() + owned2.clone());\n \n-    if let Cow::Owned(_) = borrowed1 + borrow_empty {\n+    if let Cow::Owned(_) = borrowed1.clone() + borrow_empty.clone() {\n         panic!(\"Adding empty strings to a borrow should note allocate\");\n     }\n-    if let Cow::Owned(_) = borrow_empty + borrowed1 {\n+    if let Cow::Owned(_) = borrow_empty.clone() + borrowed1.clone() {\n         panic!(\"Adding empty strings to a borrow should note allocate\");\n     }\n-    if let Cow::Owned(_) = borrowed1 + owned_empty {\n+    if let Cow::Owned(_) = borrowed1.clone() + owned_empty.clone() {\n         panic!(\"Adding empty strings to a borrow should note allocate\");\n     }\n-    if let Cow::Owned(_) = owned_empty + borrowed1 {\n+    if let Cow::Owned(_) = owned_empty.clone() + borrowed1.clone() {\n         panic!(\"Adding empty strings to a borrow should note allocate\");\n     }\n }\n \n-fn check_cow_add_assign() {\n-    borrowed1 = Cow::Borrowed(\"Hello, \");\n-    borrowed2 = Cow::Borrowed(\"World!\");\n-    borrow_empty = Cow::Borrowed(\"\");\n+#[test]\n+fn check_cow_add_str() {\n+    let borrowed = Cow::Borrowed(\"Hello, \");\n+    let borrow_empty = Cow::Borrowed(\"\");\n+\n+    let owned: Cow<str> = Cow::Owned(String::from(\"Hi, \"));\n+    let owned_empty: Cow<str> = Cow::Owned(String::new());\n \n-    owned1 = Cow::Owned(\"Hi, \".into());\n-    owned2 = Cow::Owned(\"Rustaceans!\".into());\n-    owned_empty = Cow::Owned(\"\".into());\n+    assert_eq!(\"Hello, World!\", borrowed.clone() + \"World!\");\n \n-    let borrowed1clone = borrowed1.clone();\n-    borrowed1clone += borrow_empty;\n-    assert_eq!((&borrowed1clone).as_ptr(), (&borrowed1).as_ptr());\n+    assert_eq!(\"Hi, World!\", owned.clone() + \"World!\");\n \n-    borrowed1clone += owned_empty;\n-    assert_eq!((&borrowed1clone).as_ptr(), (&borrowed1).as_ptr());\n+    if let Cow::Owned(_) = borrowed.clone() + \"\" {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    if let Cow::Owned(_) = borrow_empty.clone() + \"Hello, \" {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    if let Cow::Owned(_) = owned_empty.clone() + \"Hello, \" {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+}\n+\n+#[test]\n+fn check_cow_add_assign_cow() {\n+    let mut borrowed1 = Cow::Borrowed(\"Hello, \");\n+    let borrowed2 = Cow::Borrowed(\"World!\");\n+    let borrow_empty = Cow::Borrowed(\"\");\n+\n+    let mut owned1: Cow<str> = Cow::Owned(String::from(\"Hi, \"));\n+    let owned2: Cow<str> = Cow::Owned(String::from(\"Rustaceans!\"));\n+    let owned_empty: Cow<str> = Cow::Owned(String::new());\n+\n+    let mut s = borrowed1.clone();\n+    s += borrow_empty.clone();\n+    assert_eq!(\"Hello, \", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    let mut s = borrow_empty.clone();\n+    s += borrowed1.clone();\n+    assert_eq!(\"Hello, \", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    let mut s = borrowed1.clone();\n+    s += owned_empty.clone();\n+    assert_eq!(\"Hello, \", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    let mut s = owned_empty.clone();\n+    s += borrowed1.clone();\n+    assert_eq!(\"Hello, \", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n \n     owned1 += borrowed2;\n     borrowed1 += owned2;\n \n-    assert_eq!(\"Hello, World!\", owned1);\n+    assert_eq!(\"Hi, World!\", owned1);\n     assert_eq!(\"Hello, Rustaceans!\", borrowed1);\n }\n+\n+#[test]\n+fn check_cow_add_assign_str() {\n+    let mut borrowed = Cow::Borrowed(\"Hello, \");\n+    let borrow_empty = Cow::Borrowed(\"\");\n+\n+    let mut owned: Cow<str> = Cow::Owned(String::from(\"Hi, \"));\n+    let owned_empty: Cow<str> = Cow::Owned(String::new());\n+\n+    let mut s = borrowed.clone();\n+    s += \"\";\n+    assert_eq!(\"Hello, \", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    let mut s = borrow_empty.clone();\n+    s += \"World!\";\n+    assert_eq!(\"World!\", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    let mut s = owned_empty.clone();\n+    s += \"World!\";\n+    assert_eq!(\"World!\", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+\n+    owned += \"World!\";\n+    borrowed += \"World!\";\n+\n+    assert_eq!(\"Hi, World!\", owned);\n+    assert_eq!(\"Hello, World!\", borrowed);\n+}"}, {"sha": "14ec8d58bef61065ad669414be9eb19850670a8d", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -42,6 +42,7 @@ mod bench;\n \n mod binary_heap;\n mod btree;\n+mod cow_str;\n mod enum_set;\n mod fmt;\n mod linked_list;"}, {"sha": "5f5d07b6682372a3dd04ec92c552283ae1f27e76", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -24,7 +24,8 @@ use mem;\n ///\n /// See: https://131002.net/siphash/\n #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-#[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+#[rustc_deprecated(since = \"1.13.0\",\n+                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher13 {\n     hasher: Hasher<Sip13Rounds>,\n@@ -34,7 +35,8 @@ pub struct SipHasher13 {\n ///\n /// See: https://131002.net/siphash/\n #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-#[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+#[rustc_deprecated(since = \"1.13.0\",\n+                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher24 {\n     hasher: Hasher<Sip24Rounds>,\n@@ -53,7 +55,8 @@ pub struct SipHasher24 {\n /// it is not intended for cryptographic purposes. As such, all\n /// cryptographic uses of this implementation are _strongly discouraged_.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+#[rustc_deprecated(since = \"1.13.0\",\n+                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher(SipHasher24);\n \n@@ -140,15 +143,17 @@ impl SipHasher {\n     /// Creates a new `SipHasher` with the two initial keys set to 0.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+    #[rustc_deprecated(since = \"1.13.0\",\n+                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new() -> SipHasher {\n         SipHasher::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher` that is keyed off the provided keys.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+    #[rustc_deprecated(since = \"1.13.0\",\n+                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n         SipHasher(SipHasher24::new_with_keys(key0, key1))\n     }\n@@ -158,15 +163,17 @@ impl SipHasher13 {\n     /// Creates a new `SipHasher13` with the two initial keys set to 0.\n     #[inline]\n     #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+    #[rustc_deprecated(since = \"1.13.0\",\n+                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new() -> SipHasher13 {\n         SipHasher13::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher13` that is keyed off the provided keys.\n     #[inline]\n     #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+    #[rustc_deprecated(since = \"1.13.0\",\n+                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n         SipHasher13 {\n             hasher: Hasher::new_with_keys(key0, key1)\n@@ -178,15 +185,17 @@ impl SipHasher24 {\n     /// Creates a new `SipHasher24` with the two initial keys set to 0.\n     #[inline]\n     #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+    #[rustc_deprecated(since = \"1.13.0\",\n+                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new() -> SipHasher24 {\n         SipHasher24::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher24` that is keyed off the provided keys.\n     #[inline]\n     #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+    #[rustc_deprecated(since = \"1.13.0\",\n+                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher24 {\n         SipHasher24 {\n             hasher: Hasher::new_with_keys(key0, key1)"}, {"sha": "cd2e0cb11d35e0a2c3362cd217337648b94f6175", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1374,10 +1374,7 @@ impl<I: Iterator> Peekable<I> {\n         if self.peeked.is_none() {\n             self.peeked = self.iter.next();\n         }\n-        match self.peeked {\n-            Some(ref value) => Some(value),\n-            None => None,\n-        }\n+        self.peeked.as_ref()\n     }\n }\n "}, {"sha": "a2fc6e044e74c53753b3a2819a49cfad66a8c1ab", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -311,11 +311,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprIndex(ref l, ref r) |\n-            hir::ExprBinary(_, ref l, ref r) if self.tcx.is_method_call(expr.id) => {\n+            hir::ExprBinary(_, ref l, ref r) if self.tcx.tables().is_method_call(expr.id) => {\n                 self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n-            hir::ExprUnary(_, ref e) if self.tcx.is_method_call(expr.id) => {\n+            hir::ExprUnary(_, ref e) if self.tcx.tables().is_method_call(expr.id) => {\n                 self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }\n \n@@ -372,9 +372,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &hir::Expr,\n             args: I) -> CFGIndex {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n-        let fn_ty = match self.tcx.tables.borrow().method_map.get(&method_call) {\n+        let fn_ty = match self.tcx.tables().method_map.get(&method_call) {\n             Some(method) => method.ty,\n-            None => self.tcx.expr_ty_adjusted(func_or_rcvr)\n+            None => self.tcx.tables().expr_ty_adjusted(func_or_rcvr)\n         };\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);"}, {"sha": "e1fec898e41e46ec8fc166a58b72c64576a8c767", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1208,38 +1208,32 @@ impl<'a> LoweringContext<'a> {\n                 ExprKind::Break(opt_ident) => hir::ExprBreak(self.lower_opt_sp_ident(opt_ident)),\n                 ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| self.lower_expr(x))),\n-                ExprKind::InlineAsm(InlineAsm {\n-                        ref inputs,\n-                        ref outputs,\n-                        ref asm,\n-                        asm_str_style,\n-                        ref clobbers,\n-                        volatile,\n-                        alignstack,\n-                        dialect,\n-                        expn_id,\n-                    }) => hir::ExprInlineAsm(P(hir::InlineAsm {\n-                    inputs: inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n-                    outputs: outputs.iter()\n-                                    .map(|out| {\n-                                        hir::InlineAsmOutput {\n-                                            constraint: out.constraint.clone(),\n-                                            is_rw: out.is_rw,\n-                                            is_indirect: out.is_indirect,\n-                                        }\n-                                    })\n-                                    .collect(),\n-                    asm: asm.clone(),\n-                    asm_str_style: asm_str_style,\n-                    clobbers: clobbers.clone().into(),\n-                    volatile: volatile,\n-                    alignstack: alignstack,\n-                    dialect: dialect,\n-                    expn_id: expn_id,\n-                }), outputs.iter().map(|out| self.lower_expr(&out.expr)).collect(),\n-                   inputs.iter().map(|&(_, ref input)| self.lower_expr(input)).collect()),\n+                ExprKind::InlineAsm(ref asm) => {\n+                    let hir_asm = hir::InlineAsm {\n+                        inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n+                        outputs: asm.outputs.iter().map(|out| {\n+                            hir::InlineAsmOutput {\n+                                constraint: out.constraint.clone(),\n+                                is_rw: out.is_rw,\n+                                is_indirect: out.is_indirect,\n+                            }\n+                        }).collect(),\n+                        asm: asm.asm.clone(),\n+                        asm_str_style: asm.asm_str_style,\n+                        clobbers: asm.clobbers.clone().into(),\n+                        volatile: asm.volatile,\n+                        alignstack: asm.alignstack,\n+                        dialect: asm.dialect,\n+                        expn_id: asm.expn_id,\n+                    };\n+                    let outputs =\n+                        asm.outputs.iter().map(|out| self.lower_expr(&out.expr)).collect();\n+                    let inputs =\n+                        asm.inputs.iter().map(|&(_, ref input)| self.lower_expr(input)).collect();\n+                    hir::ExprInlineAsm(P(hir_asm), outputs, inputs)\n+                }\n                 ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n-                    hir::ExprStruct(self.lower_path(path),\n+                    hir::ExprStruct(P(self.lower_path(path)),\n                                     fields.iter().map(|x| self.lower_field(x)).collect(),\n                                     maybe_expr.as_ref().map(|x| self.lower_expr(x)))\n                 }\n@@ -1743,7 +1737,7 @@ impl<'a> LoweringContext<'a> {\n                    e: Option<P<hir::Expr>>,\n                    attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, false);\n-        let expr = self.expr(sp, hir::ExprStruct(path, fields, e), attrs);\n+        let expr = self.expr(sp, hir::ExprStruct(P(path), fields, e), attrs);\n         self.resolver.record_resolution(expr.id, def);\n         expr\n     }"}, {"sha": "5f57ceac353cc62e27d8438d60dd020f48278257", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -840,8 +840,8 @@ pub enum UnsafeSource {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Expr {\n     pub id: NodeId,\n-    pub node: Expr_,\n     pub span: Span,\n+    pub node: Expr_,\n     pub attrs: ThinVec<Attribute>,\n }\n \n@@ -946,7 +946,7 @@ pub enum Expr_ {\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    ExprStruct(Path, HirVec<Field>, Option<P<Expr>>),\n+    ExprStruct(P<Path>, HirVec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///"}, {"sha": "bbcd87d9cabfc2ff7a9e1bc91889f3bb5742196d", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1266,26 +1266,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.region_vars.new_bound(debruijn)\n     }\n \n-    /// Apply `adjustment` to the type of `expr`\n-    pub fn adjust_expr_ty(&self,\n-                          expr: &hir::Expr,\n-                          adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n-                          -> Ty<'tcx>\n-    {\n-        let raw_ty = self.expr_ty(expr);\n-        let raw_ty = self.shallow_resolve(raw_ty);\n-        let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n-        raw_ty.adjust(self.tcx,\n-                      expr.span,\n-                      expr.id,\n-                      adjustment,\n-                      |method_call| self.tables\n-                                        .borrow()\n-                                        .method_map\n-                                        .get(&method_call)\n-                                        .map(|method| resolve_ty(method.ty)))\n-    }\n-\n     /// True if errors have been reported since this infcx was\n     /// created.  This is sometimes used as a heuristic to skip\n     /// reporting errors that often occur as a result of earlier\n@@ -1622,7 +1602,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        let ty = self.adjust_expr_ty(expr, self.tables.borrow().adjustments.get(&expr.id));\n+        let ty = self.tables.borrow().expr_ty_adjusted(expr);\n         self.resolve_type_vars_or_error(&ty)\n     }\n \n@@ -1666,9 +1646,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .map(|method| method.def_id)\n     }\n \n-    pub fn adjustments(&self) -> Ref<NodeMap<adjustment::AutoAdjustment<'tcx>>> {\n+    pub fn adjustments(&self) -> Ref<NodeMap<adjustment::Adjustment<'tcx>>> {\n         fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n-                                        -> &'a NodeMap<adjustment::AutoAdjustment<'tcx>> {\n+                                        -> &'a NodeMap<adjustment::Adjustment<'tcx>> {\n             &tables.adjustments\n         }\n "}, {"sha": "4212b1fb05ee3a6eeffc5ff277ac84a964f0cf36", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         match def {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n             if self.tcx.trait_of_item(def.def_id()).is_some() => {\n-                if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n+                if let Some(substs) = self.tcx.tables().item_substs.get(&id) {\n                     if let ty::TyAdt(tyid, _) = substs.substs.type_at(0).sty {\n                         self.check_def_id(tyid.did);\n                     }\n@@ -123,12 +123,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n         let method_call = ty::MethodCall::expr(id);\n-        let method = self.tcx.tables.borrow().method_map[&method_call];\n+        let method = self.tcx.tables().method_map[&method_call];\n         self.check_def_id(method.def_id);\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n-        match self.tcx.expr_ty_adjusted(lhs).sty {\n+        match self.tcx.tables().expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().field_named(name).did);\n             }\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n-        match self.tcx.expr_ty_adjusted(lhs).sty {\n+        match self.tcx.tables().expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().fields[idx].did);\n             }\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n-        let variant = match self.tcx.node_id_to_type(lhs.id).sty {\n+        let variant = match self.tcx.tables().node_id_to_type(lhs.id).sty {\n             ty::TyAdt(adt, _) => {\n                 adt.variant_of_def(self.tcx.expect_def(lhs.id))\n             }\n@@ -433,7 +433,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.node_id_to_type(field.id);\n+        let field_type = self.tcx.tables().node_id_to_type(field.id);\n         let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n             _ => false"}, {"sha": "8ca3c75eaa4b1fbe3ad90774651e43d940cf113f", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -159,7 +159,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tcx.tables.borrow().method_map[&method_call].ty;\n+                let base_type = self.tcx.tables().method_map[&method_call].ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n@@ -168,15 +168,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprCall(ref base, _) => {\n-                let base_type = self.tcx.expr_ty_adjusted(base);\n+                let base_type = self.tcx.tables().expr_ty_adjusted(base);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             hir::ExprUnary(hir::UnDeref, ref base) => {\n-                let base_type = self.tcx.expr_ty_adjusted(base);\n+                let base_type = self.tcx.tables().expr_ty_adjusted(base);\n                 debug!(\"effect: unary case, base type is {:?}\",\n                         base_type);\n                 if let ty::TyRawPtr(_) = base_type.sty {\n@@ -200,7 +200,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprField(ref base_expr, field) => {\n-                if let ty::TyAdt(adt, ..) = self.tcx.expr_ty_adjusted(base_expr).sty {\n+                if let ty::TyAdt(adt, ..) = self.tcx.tables().expr_ty_adjusted(base_expr).sty {\n                     if adt.is_union() {\n                         self.require_unsafe(field.span, \"access to union field\");\n                     }\n@@ -214,7 +214,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &hir::Pat) {\n         if let PatKind::Struct(_, ref fields, _) = pat.node {\n-            if let ty::TyAdt(adt, ..) = self.tcx.pat_ty(pat).sty {\n+            if let ty::TyAdt(adt, ..) = self.tcx.tables().pat_ty(pat).sty {\n                 if adt.is_union() {\n                     for field in fields {\n                         self.require_unsafe(field.span, \"matching on union field\");"}, {"sha": "0543d1303a5f10fe9f1137d11c61cbec6e0769fb", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -720,20 +720,33 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n         let adj = infcx.adjustments().get(&expr.id).map(|x| x.clone());\n         if let Some(adjustment) = adj {\n-            match adjustment {\n-                adjustment::AdjustNeverToAny(..) |\n-                adjustment::AdjustReifyFnPointer |\n-                adjustment::AdjustUnsafeFnPointer |\n-                adjustment::AdjustMutToConstPointer => {\n+            match adjustment.kind {\n+                adjustment::Adjust::NeverToAny |\n+                adjustment::Adjust::ReifyFnPointer |\n+                adjustment::Adjust::UnsafeFnPointer |\n+                adjustment::Adjust::MutToConstPointer => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n                     debug!(\"walk_adjustment: trivial adjustment\");\n                     let cmt_unadjusted =\n                         return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                     self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 }\n-                adjustment::AdjustDerefRef(ref adj) => {\n-                    self.walk_autoderefref(expr, adj);\n+                adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n+                    debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n+\n+                    self.walk_autoderefs(expr, autoderefs);\n+\n+                    let cmt_derefd =\n+                        return_if_err!(self.mc.cat_expr_autoderefd(expr, autoderefs));\n+\n+                    let cmt_refd =\n+                        self.walk_autoref(expr, cmt_derefd, autoref);\n+\n+                    if unsize {\n+                        // Unsizing consumes the thin pointer and produces a fat one.\n+                        self.delegate_consume(expr.id, expr.span, cmt_refd);\n+                    }\n                 }\n             }\n         }\n@@ -770,28 +783,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn walk_autoderefref(&mut self,\n-                         expr: &hir::Expr,\n-                         adj: &adjustment::AutoDerefRef<'tcx>) {\n-        debug!(\"walk_autoderefref expr={:?} adj={:?}\",\n-               expr,\n-               adj);\n-\n-        self.walk_autoderefs(expr, adj.autoderefs);\n-\n-        let cmt_derefd =\n-            return_if_err!(self.mc.cat_expr_autoderefd(expr, adj.autoderefs));\n-\n-        let cmt_refd =\n-            self.walk_autoref(expr, cmt_derefd, adj.autoref);\n-\n-        if adj.unsize.is_some() {\n-            // Unsizing consumes the thin pointer and produces a fat one.\n-            self.delegate_consume(expr.id, expr.span, cmt_refd);\n-        }\n-    }\n-\n-\n     /// Walks the autoref `opt_autoref` applied to the autoderef'd\n     /// `expr`. `cmt_derefd` is the mem-categorized form of `expr`\n     /// after all relevant autoderefs have occurred. Because AutoRefs\n@@ -803,7 +794,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_autoref(&mut self,\n                     expr: &hir::Expr,\n                     cmt_base: mc::cmt<'tcx>,\n-                    opt_autoref: Option<adjustment::AutoRef<'tcx>>)\n+                    opt_autoref: Option<adjustment::AutoBorrow<'tcx>>)\n                     -> mc::cmt<'tcx>\n     {\n         debug!(\"walk_autoref(expr.id={} cmt_derefd={:?} opt_autoref={:?})\",\n@@ -822,7 +813,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         };\n \n         match *autoref {\n-            adjustment::AutoPtr(r, m) => {\n+            adjustment::AutoBorrow::Ref(r, m) => {\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n                                      cmt_base,\n@@ -831,7 +822,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                      AutoRef);\n             }\n \n-            adjustment::AutoUnsafe(m) => {\n+            adjustment::AutoBorrow::RawPtr(m) => {\n                 debug!(\"walk_autoref: expr.id={} cmt_base={:?}\",\n                        expr.id,\n                        cmt_base);"}, {"sha": "57503398cfe577acd6aa87f5e37af21cb734e5c9", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n         if let hir::ExprPath(..) = expr.node {\n             match self.infcx.tcx.expect_def(expr.id) {\n                 Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                    let typ = self.infcx.tcx.node_id_to_type(expr.id);\n+                    let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n                     match typ.sty {\n                         ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             let from = bare_fn_ty.sig.0.inputs[0];"}, {"sha": "46bea00cca3cbf8399319f2c5723ca75c3357d20", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1081,7 +1081,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAssignOp(_, ref l, ref r) => {\n             // an overloaded assign op is like a method call\n-            if self.ir.tcx.is_method_call(expr.id) {\n+            if self.ir.tcx.tables().is_method_call(expr.id) {\n                 let succ = self.propagate_through_expr(&l, succ);\n                 self.propagate_through_expr(&r, succ)\n             } else {\n@@ -1113,8 +1113,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprCall(ref f, ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n-                self.ir.tcx.expr_ty_adjusted(&f).fn_ret().0.is_never();\n+            let diverges = !self.ir.tcx.tables().is_method_call(expr.id) &&\n+                self.ir.tcx.tables().expr_ty_adjusted(&f).fn_ret().0.is_never();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1126,7 +1126,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprMethodCall(.., ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n-            let method_ty = self.ir.tcx.tables.borrow().method_map[&method_call].ty;\n+            let method_ty = self.ir.tcx.tables().method_map[&method_call].ty;\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let succ = if method_ty.fn_ret().0.is_never() {\n                 self.s.exit_ln\n@@ -1409,7 +1409,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n-        if !this.ir.tcx.is_method_call(expr.id) {\n+        if !this.ir.tcx.tables().is_method_call(expr.id) {\n             this.check_lvalue(&l);\n         }\n \n@@ -1459,7 +1459,7 @@ fn check_fn(_v: &Liveness,\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::Binder<Ty<'tcx>> {\n-        let fn_ty = self.ir.tcx.node_id_to_type(id);\n+        let fn_ty = self.ir.tcx.tables().node_id_to_type(id);\n         match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n@@ -1502,7 +1502,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     None if !body.stmts.is_empty() =>\n                         match body.stmts.last().unwrap().node {\n                             hir::StmtSemi(ref e, _) => {\n-                                self.ir.tcx.expr_ty(&e) == fn_ret\n+                                self.ir.tcx.tables().expr_ty(&e) == fn_ret\n                             },\n                             _ => false\n                         },"}, {"sha": "e3ed13e1e40173501cab2d79040731b8d07b67e0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -354,11 +354,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        let unadjusted_ty = self.expr_ty(expr)?;\n-        Ok(unadjusted_ty.adjust(\n-            self.tcx(), expr.span, expr.id,\n-            self.infcx.adjustments().get(&expr.id),\n-            |method_call| self.infcx.node_method_ty(method_call)))\n+        self.infcx.expr_ty_adjusted(expr)\n     }\n \n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n@@ -396,19 +392,21 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n \n             Some(adjustment) => {\n-                match *adjustment {\n-                    adjustment::AdjustDerefRef(\n-                        adjustment::AutoDerefRef {\n-                            autoref: None, unsize: None, autoderefs, ..}) => {\n+                match adjustment.kind {\n+                    adjustment::Adjust::DerefRef {\n+                        autoderefs,\n+                        autoref: None,\n+                        unsize: false\n+                    } => {\n                         // Equivalent to *expr or something similar.\n                         self.cat_expr_autoderefd(expr, autoderefs)\n                     }\n \n-                    adjustment::AdjustNeverToAny(..) |\n-                    adjustment::AdjustReifyFnPointer |\n-                    adjustment::AdjustUnsafeFnPointer |\n-                    adjustment::AdjustMutToConstPointer |\n-                    adjustment::AdjustDerefRef(_) => {\n+                    adjustment::Adjust::NeverToAny |\n+                    adjustment::Adjust::ReifyFnPointer |\n+                    adjustment::Adjust::UnsafeFnPointer |\n+                    adjustment::Adjust::MutToConstPointer |\n+                    adjustment::Adjust::DerefRef {..} => {\n                         debug!(\"cat_expr({:?}): {:?}\",\n                                adjustment,\n                                expr);"}, {"sha": "1a50d7aa0adc7f34107bf6f5d05ee20541c4f624", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                let def_id = self.tcx.tables().method_map[&method_call].def_id;\n \n                 // Mark the trait item (and, possibly, its default impl) as reachable\n                 // Or mark inherent impl item as reachable"}, {"sha": "fd17e378787a59008fd9415c5c93cf783f26e269", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -555,11 +555,11 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n         hir::ExprMethodCall(i, ..) => {\n             span = i.span;\n             let method_call = ty::MethodCall::expr(e.id);\n-            tcx.tables.borrow().method_map[&method_call].def_id\n+            tcx.tables().method_map[&method_call].def_id\n         }\n         hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n-            match tcx.expr_ty_adjusted(base_e).sty {\n+            match tcx.tables().expr_ty_adjusted(base_e).sty {\n                 ty::TyAdt(def, _) => {\n                     def.struct_variant().field_named(field.node).did\n                 }\n@@ -569,7 +569,7 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n         }\n         hir::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n-            match tcx.expr_ty_adjusted(base_e).sty {\n+            match tcx.tables().expr_ty_adjusted(base_e).sty {\n                 ty::TyAdt(def, _) => {\n                     def.struct_variant().fields[field.node].did\n                 }\n@@ -580,7 +580,7 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n             }\n         }\n         hir::ExprStruct(_, ref expr_fields, _) => {\n-            match tcx.expr_ty(e).sty {\n+            match tcx.tables().expr_ty(e).sty {\n                 ty::TyAdt(adt, ..) => match adt.adt_kind() {\n                     AdtKind::Struct | AdtKind::Union => {\n                         // check the stability of each field that appears\n@@ -637,7 +637,7 @@ pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n-    let v = match tcx.pat_ty_opt(pat).map(|ty| &ty.sty) {\n+    let v = match tcx.tables().pat_ty_opt(pat).map(|ty| &ty.sty) {\n         Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => adt.struct_variant(),\n         _ => return,\n     };"}, {"sha": "63eabd5212fd0d8ed0d8a9449944c754571f47a2", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -918,6 +918,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"the directory the MIR is dumped into\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n           \"print some performance-related statistics\"),\n+    hir_stats: bool = (false, parse_bool, [UNTRACKED],\n+          \"print some statistics about AST and HIR\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "333a5c74cb45cb309c73e62317493ffed343530c", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 107, "deletions": 182, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::AutoAdjustment::*;\n-pub use self::AutoRef::*;\n-\n-use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeAndMut};\n use ty::LvaluePreference::{NoPreference};\n \n use syntax::ast;\n@@ -20,116 +17,122 @@ use syntax_pos::Span;\n use hir;\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum AutoAdjustment<'tcx> {\n-    AdjustNeverToAny(Ty<'tcx>), // go from ! to any type\n-    AdjustReifyFnPointer,       // go from a fn-item type to a fn-pointer type\n-    AdjustUnsafeFnPointer,      // go from a safe fn pointer to an unsafe fn pointer\n-    AdjustMutToConstPointer,    // go from a mut raw pointer to a const raw pointer\n-    AdjustDerefRef(AutoDerefRef<'tcx>),\n+pub struct Adjustment<'tcx> {\n+    pub kind: Adjust<'tcx>,\n+    pub target: Ty<'tcx>\n }\n \n-/// Represents coercing a pointer to a different kind of pointer - where 'kind'\n-/// here means either or both of raw vs borrowed vs unique and fat vs thin.\n-///\n-/// We transform pointers by following the following steps in order:\n-/// 1. Deref the pointer `self.autoderefs` times (may be 0).\n-/// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n-///    `&` or `*` pointer.\n-/// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n-///    which will do things like convert thin pointers to fat\n-///    pointers, or convert structs containing thin pointers to\n-///    structs containing fat pointers, or convert between fat\n-///    pointers.  We don't store the details of how the transform is\n-///    done (in fact, we don't know that, because it might depend on\n-///    the precise type parameters). We just store the target\n-///    type. Trans figures out what has to be done at monomorphization\n-///    time based on the precise source/target type at hand.\n-///\n-/// To make that more concrete, here are some common scenarios:\n-///\n-/// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n-/// Here the pointer will be dereferenced N times (where a dereference can\n-/// happen to raw or borrowed pointers or any smart pointer which implements\n-/// Deref, including Box<_>). The number of dereferences is given by\n-/// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n-/// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n-/// None.\n-///\n-/// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n-/// with a thin pointer, deref a number of times, unsize the underlying data,\n-/// then autoref. The 'unsize' phase may change a fixed length array to a\n-/// dynamically sized one, a concrete object to a trait object, or statically\n-/// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n-/// represented by:\n-///\n-/// ```\n-/// AutoDerefRef {\n-///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n-///     autoref: Some(AutoPtr), // [i32] -> &[i32]\n-///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n-/// }\n-/// ```\n-///\n-/// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n-/// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n-/// The autoderef and -ref are the same as in the above example, but the type\n-/// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n-/// the underlying conversions from `[i32; 4]` to `[i32]`.\n-///\n-/// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n-/// that case, we have the pointer we need coming in, so there are no\n-/// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n-/// At some point, of course, `Box` should move out of the compiler, in which\n-/// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n-/// Box<[i32]> is represented by:\n-///\n-/// ```\n-/// AutoDerefRef {\n-///     autoderefs: 0,\n-///     autoref: None,\n-///     unsize: Some(Box<[i32]>),\n-/// }\n-/// ```\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub struct AutoDerefRef<'tcx> {\n-    /// Step 1. Apply a number of dereferences, producing an lvalue.\n-    pub autoderefs: usize,\n-\n-    /// Step 2. Optionally produce a pointer/reference from the value.\n-    pub autoref: Option<AutoRef<'tcx>>,\n-\n-    /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n-    /// `&[T]`. The stored type is the target pointer type. Note that\n-    /// the source could be a thin or fat pointer.\n-    pub unsize: Option<Ty<'tcx>>,\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum Adjust<'tcx> {\n+    /// Go from ! to any type.\n+    NeverToAny,\n+\n+    /// Go from a fn-item type to a fn-pointer type.\n+    ReifyFnPointer,\n+\n+    /// Go from a safe fn pointer to an unsafe fn pointer.\n+    UnsafeFnPointer,\n+\n+    /// Go from a mut raw pointer to a const raw pointer.\n+    MutToConstPointer,\n+\n+    /// Represents coercing a pointer to a different kind of pointer - where 'kind'\n+    /// here means either or both of raw vs borrowed vs unique and fat vs thin.\n+    ///\n+    /// We transform pointers by following the following steps in order:\n+    /// 1. Deref the pointer `self.autoderefs` times (may be 0).\n+    /// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n+    ///    `&` or `*` pointer.\n+    /// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n+    ///    which will do things like convert thin pointers to fat\n+    ///    pointers, or convert structs containing thin pointers to\n+    ///    structs containing fat pointers, or convert between fat\n+    ///    pointers.  We don't store the details of how the transform is\n+    ///    done (in fact, we don't know that, because it might depend on\n+    ///    the precise type parameters). We just store the target\n+    ///    type. Trans figures out what has to be done at monomorphization\n+    ///    time based on the precise source/target type at hand.\n+    ///\n+    /// To make that more concrete, here are some common scenarios:\n+    ///\n+    /// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n+    /// Here the pointer will be dereferenced N times (where a dereference can\n+    /// happen to raw or borrowed pointers or any smart pointer which implements\n+    /// Deref, including Box<_>). The number of dereferences is given by\n+    /// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n+    /// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n+    /// None.\n+    ///\n+    /// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n+    /// with a thin pointer, deref a number of times, unsize the underlying data,\n+    /// then autoref. The 'unsize' phase may change a fixed length array to a\n+    /// dynamically sized one, a concrete object to a trait object, or statically\n+    /// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n+    /// represented by:\n+    ///\n+    /// ```\n+    /// Adjust::DerefRef {\n+    ///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n+    ///     autoref: Some(AutoBorrow::Ref), // [i32] -> &[i32]\n+    ///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n+    /// }\n+    /// ```\n+    ///\n+    /// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n+    /// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n+    /// The autoderef and -ref are the same as in the above example, but the type\n+    /// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n+    /// the underlying conversions from `[i32; 4]` to `[i32]`.\n+    ///\n+    /// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n+    /// that case, we have the pointer we need coming in, so there are no\n+    /// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n+    /// At some point, of course, `Box` should move out of the compiler, in which\n+    /// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n+    /// Box<[i32]> is represented by:\n+    ///\n+    /// ```\n+    /// Adjust::DerefRef {\n+    ///     autoderefs: 0,\n+    ///     autoref: None,\n+    ///     unsize: Some(Box<[i32]>),\n+    /// }\n+    /// ```\n+    DerefRef {\n+        /// Step 1. Apply a number of dereferences, producing an lvalue.\n+        autoderefs: usize,\n+\n+        /// Step 2. Optionally produce a pointer/reference from the value.\n+        autoref: Option<AutoBorrow<'tcx>>,\n+\n+        /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n+        /// `&[T]`. Note that the source could be a thin or fat pointer.\n+        unsize: bool,\n+    }\n }\n \n-impl<'tcx> AutoAdjustment<'tcx> {\n+impl<'tcx> Adjustment<'tcx> {\n     pub fn is_identity(&self) -> bool {\n-        match *self {\n-            AdjustNeverToAny(ty) => ty.is_never(),\n-            AdjustReifyFnPointer |\n-            AdjustUnsafeFnPointer |\n-            AdjustMutToConstPointer => false,\n-            AdjustDerefRef(ref r) => r.is_identity(),\n+        match self.kind {\n+            Adjust::NeverToAny => self.target.is_never(),\n+\n+            Adjust::DerefRef { autoderefs: 0, autoref: None, unsize: false } => true,\n+\n+            Adjust::ReifyFnPointer |\n+            Adjust::UnsafeFnPointer |\n+            Adjust::MutToConstPointer |\n+            Adjust::DerefRef {..} => false,\n         }\n     }\n }\n-impl<'tcx> AutoDerefRef<'tcx> {\n-    pub fn is_identity(&self) -> bool {\n-        self.autoderefs == 0 && self.unsize.is_none() && self.autoref.is_none()\n-    }\n-}\n-\n \n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n-pub enum AutoRef<'tcx> {\n+pub enum AutoBorrow<'tcx> {\n     /// Convert from T to &T.\n-    AutoPtr(&'tcx ty::Region, hir::Mutability),\n+    Ref(&'tcx ty::Region, hir::Mutability),\n \n     /// Convert from T to *T.\n-    /// Value to thin pointer.\n-    AutoUnsafe(hir::Mutability),\n+    RawPtr(hir::Mutability),\n }\n \n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n@@ -139,84 +142,6 @@ pub enum CustomCoerceUnsized {\n }\n \n impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n-    /// See `expr_ty_adjusted`\n-    pub fn adjust<F>(&'tcx self,\n-                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     span: Span,\n-                     expr_id: ast::NodeId,\n-                     adjustment: Option<&AutoAdjustment<'tcx>>,\n-                     mut method_type: F)\n-                     -> Ty<'tcx> where\n-        F: FnMut(ty::MethodCall) -> Option<Ty<'tcx>>,\n-    {\n-        if let ty::TyError = self.sty {\n-            return self;\n-        }\n-\n-        return match adjustment {\n-            Some(adjustment) => {\n-                match *adjustment {\n-                    AdjustNeverToAny(ref ty) => ty,\n-\n-                    AdjustReifyFnPointer => {\n-                        match self.sty {\n-                            ty::TyFnDef(.., f) => tcx.mk_fn_ptr(f),\n-                            _ => {\n-                                bug!(\"AdjustReifyFnPointer adjustment on non-fn-item: {:?}\",\n-                                     self);\n-                            }\n-                        }\n-                    }\n-\n-                    AdjustUnsafeFnPointer => {\n-                        match self.sty {\n-                            ty::TyFnPtr(b) => tcx.safe_to_unsafe_fn_ty(b),\n-                            ref b => {\n-                                bug!(\"AdjustUnsafeFnPointer adjustment on non-fn-ptr: {:?}\",\n-                                     b);\n-                            }\n-                        }\n-                    }\n-\n-                    AdjustMutToConstPointer => {\n-                        match self.sty {\n-                            ty::TyRawPtr(mt) => tcx.mk_ptr(ty::TypeAndMut {\n-                                ty: mt.ty,\n-                                mutbl: hir::MutImmutable\n-                            }),\n-                            ref b => {\n-                                bug!(\"AdjustMutToConstPointer on non-raw-ptr: {:?}\",\n-                                     b);\n-                            }\n-                        }\n-                    }\n-\n-                    AdjustDerefRef(ref adj) => {\n-                        let mut adjusted_ty = self;\n-\n-                        if !adjusted_ty.references_error() {\n-                            for i in 0..adj.autoderefs {\n-                                adjusted_ty =\n-                                    adjusted_ty.adjust_for_autoderef(tcx,\n-                                                                     expr_id,\n-                                                                     span,\n-                                                                     i as u32,\n-                                                                     &mut method_type);\n-                            }\n-                        }\n-\n-                        if let Some(target) = adj.unsize {\n-                            target\n-                        } else {\n-                            adjusted_ty.adjust_for_autoref(tcx, adj.autoref)\n-                        }\n-                    }\n-                }\n-            }\n-            None => self\n-        };\n-    }\n-\n     pub fn adjust_for_autoderef<F>(&'tcx self,\n                                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                    expr_id: ast::NodeId,\n@@ -247,14 +172,14 @@ impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                              autoref: Option<AutoRef<'tcx>>)\n+                              autoref: Option<AutoBorrow<'tcx>>)\n                               -> Ty<'tcx> {\n         match autoref {\n             None => self,\n-            Some(AutoPtr(r, m)) => {\n+            Some(AutoBorrow::Ref(r, m)) => {\n                 tcx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n             }\n-            Some(AutoUnsafe(m)) => {\n+            Some(AutoBorrow::RawPtr(m)) => {\n                 tcx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n             }\n         }"}, {"sha": "7e5e10435d51683d520fc299a801a67b082eeb58", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 72, "deletions": 10, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -41,7 +41,7 @@ use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n use arena::TypedArena;\n use std::borrow::Borrow;\n-use std::cell::{Cell, RefCell, Ref};\n+use std::cell::{Cell, RefCell};\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n@@ -212,7 +212,7 @@ pub struct Tables<'tcx> {\n     /// other items.\n     pub item_substs: NodeMap<ty::ItemSubsts<'tcx>>,\n \n-    pub adjustments: NodeMap<ty::adjustment::AutoAdjustment<'tcx>>,\n+    pub adjustments: NodeMap<ty::adjustment::Adjustment<'tcx>>,\n \n     pub method_map: ty::MethodMap<'tcx>,\n \n@@ -255,6 +255,76 @@ impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n             fru_field_types: NodeMap()\n         }\n     }\n+\n+    pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n+        match self.node_id_to_type_opt(id) {\n+            Some(ty) => ty,\n+            None => {\n+                bug!(\"node_id_to_type: no type for node `{}`\",\n+                     tls::with(|tcx| tcx.map.node_to_string(id)))\n+            }\n+        }\n+    }\n+\n+    pub fn node_id_to_type_opt(&self, id: NodeId) -> Option<Ty<'tcx>> {\n+        self.node_types.get(&id).cloned()\n+    }\n+\n+    pub fn node_id_item_substs(&self, id: NodeId) -> Option<&'tcx Substs<'tcx>> {\n+        self.item_substs.get(&id).map(|ts| ts.substs)\n+    }\n+\n+    // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n+    // doesn't provide type parameter substitutions.\n+    pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n+        self.node_id_to_type(pat.id)\n+    }\n+\n+    pub fn pat_ty_opt(&self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n+        self.node_id_to_type_opt(pat.id)\n+    }\n+\n+    // Returns the type of an expression as a monotype.\n+    //\n+    // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n+    // some cases, we insert `Adjustment` annotations such as auto-deref or\n+    // auto-ref.  The type returned by this function does not consider such\n+    // adjustments.  See `expr_ty_adjusted()` instead.\n+    //\n+    // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n+    // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n+    // instead of \"fn(ty) -> T with T = isize\".\n+    pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+        self.node_id_to_type(expr.id)\n+    }\n+\n+    pub fn expr_ty_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+        self.node_id_to_type_opt(expr.id)\n+    }\n+\n+    /// Returns the type of `expr`, considering any `Adjustment`\n+    /// entry recorded for that expression.\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+        self.adjustments.get(&expr.id)\n+            .map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n+    }\n+\n+    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+        self.adjustments.get(&expr.id)\n+            .map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n+    }\n+\n+    pub fn is_method_call(&self, expr_id: NodeId) -> bool {\n+        self.method_map.contains_key(&ty::MethodCall::expr(expr_id))\n+    }\n+\n+    pub fn is_overloaded_autoderef(&self, expr_id: NodeId, autoderefs: u32) -> bool {\n+        self.method_map.contains_key(&ty::MethodCall::autoderef(expr_id, autoderefs))\n+    }\n+\n+    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n+        Some(self.upvar_capture_map.get(&upvar_id).unwrap().clone())\n+    }\n }\n \n impl<'tcx> CommonTypes<'tcx> {\n@@ -599,14 +669,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n \n-    pub fn node_types(self) -> Ref<'a, NodeMap<Ty<'tcx>>> {\n-        fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) -> &'a NodeMap<Ty<'tcx>> {\n-            &tables.node_types\n-        }\n-\n-        Ref::map(self.tables.borrow(), projection)\n-    }\n-\n     pub fn node_type_insert(self, id: NodeId, ty: Ty<'gcx>) {\n         self.tables.borrow_mut().node_types.insert(id, ty);\n     }"}, {"sha": "b79ebdb14f552ba0977135013ba10f6782a9b0b3", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -176,8 +176,8 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         r.super_fold_with(self)\n     }\n \n-    fn fold_autoref(&mut self, ar: &adjustment::AutoRef<'tcx>)\n-                    -> adjustment::AutoRef<'tcx> {\n+    fn fold_autoref(&mut self, ar: &adjustment::AutoBorrow<'tcx>)\n+                    -> adjustment::AutoBorrow<'tcx> {\n         ar.super_fold_with(self)\n     }\n }"}, {"sha": "2c15f08e89822667ad9fd9cdab7cce33fb9ca20d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 87, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -2120,80 +2120,8 @@ impl BorrowKind {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn node_id_to_type(self, id: NodeId) -> Ty<'gcx> {\n-        match self.node_id_to_type_opt(id) {\n-           Some(ty) => ty,\n-           None => bug!(\"node_id_to_type: no type for node `{}`\",\n-                        self.map.node_to_string(id))\n-        }\n-    }\n-\n-    pub fn node_id_to_type_opt(self, id: NodeId) -> Option<Ty<'gcx>> {\n-        self.tables.borrow().node_types.get(&id).cloned()\n-    }\n-\n-    pub fn node_id_item_substs(self, id: NodeId) -> ItemSubsts<'gcx> {\n-        match self.tables.borrow().item_substs.get(&id) {\n-            None => ItemSubsts {\n-                substs: self.global_tcx().intern_substs(&[])\n-            },\n-            Some(ts) => ts.clone(),\n-        }\n-    }\n-\n-    // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n-    // doesn't provide type parameter substitutions.\n-    pub fn pat_ty(self, pat: &hir::Pat) -> Ty<'gcx> {\n-        self.node_id_to_type(pat.id)\n-    }\n-    pub fn pat_ty_opt(self, pat: &hir::Pat) -> Option<Ty<'gcx>> {\n-        self.node_id_to_type_opt(pat.id)\n-    }\n-\n-    // Returns the type of an expression as a monotype.\n-    //\n-    // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n-    // some cases, we insert `AutoAdjustment` annotations such as auto-deref or\n-    // auto-ref.  The type returned by this function does not consider such\n-    // adjustments.  See `expr_ty_adjusted()` instead.\n-    //\n-    // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n-    // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n-    // instead of \"fn(ty) -> T with T = isize\".\n-    pub fn expr_ty(self, expr: &hir::Expr) -> Ty<'gcx> {\n-        self.node_id_to_type(expr.id)\n-    }\n-\n-    pub fn expr_ty_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n-        self.node_id_to_type_opt(expr.id)\n-    }\n-\n-    /// Returns the type of `expr`, considering any `AutoAdjustment`\n-    /// entry recorded for that expression.\n-    ///\n-    /// It would almost certainly be better to store the adjusted ty in with\n-    /// the `AutoAdjustment`, but I opted not to do this because it would\n-    /// require serializing and deserializing the type and, although that's not\n-    /// hard to do, I just hate that code so much I didn't want to touch it\n-    /// unless it was to fix it properly, which seemed a distraction from the\n-    /// thread at hand! -nmatsakis\n-    pub fn expr_ty_adjusted(self, expr: &hir::Expr) -> Ty<'gcx> {\n-        self.expr_ty(expr)\n-            .adjust(self.global_tcx(), expr.span, expr.id,\n-                    self.tables.borrow().adjustments.get(&expr.id),\n-                    |method_call| {\n-            self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n-        })\n-    }\n-\n-    pub fn expr_ty_adjusted_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n-        self.expr_ty_opt(expr).map(|t| t.adjust(self.global_tcx(),\n-                                                expr.span,\n-                                                expr.id,\n-                                                self.tables.borrow().adjustments.get(&expr.id),\n-                                                |method_call| {\n-            self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n-        }))\n+    pub fn tables(self) -> Ref<'a, Tables<'gcx>> {\n+        self.tables.borrow()\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n@@ -2908,19 +2836,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_region(ty::ReScope(self.region_maps.node_extent(id)))\n     }\n \n-    pub fn is_method_call(self, expr_id: NodeId) -> bool {\n-        self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n-    }\n-\n-    pub fn is_overloaded_autoderef(self, expr_id: NodeId, autoderefs: u32) -> bool {\n-        self.tables.borrow().method_map.contains_key(&MethodCall::autoderef(expr_id,\n-                                                                            autoderefs))\n-    }\n-\n-    pub fn upvar_capture(self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n-        Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n-    }\n-\n     pub fn visit_all_items_in_krate<V,F>(self,\n                                          dep_node_fn: F,\n                                          visitor: &mut V)"}, {"sha": "9ca911837b517855e3dcbce3e0aa5c69b22a4bfd", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -218,15 +218,15 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ItemSubsts<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoRef<'a> {\n-    type Lifted = ty::adjustment::AutoRef<'tcx>;\n+impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n+    type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            ty::adjustment::AutoPtr(r, m) => {\n-                tcx.lift(&r).map(|r| ty::adjustment::AutoPtr(r, m))\n+            ty::adjustment::AutoBorrow::Ref(r, m) => {\n+                tcx.lift(&r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n             }\n-            ty::adjustment::AutoUnsafe(m) => {\n-                Some(ty::adjustment::AutoUnsafe(m))\n+            ty::adjustment::AutoBorrow::RawPtr(m) => {\n+                Some(ty::adjustment::AutoBorrow::RawPtr(m))\n             }\n         }\n     }\n@@ -676,13 +676,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ty::adjustment::AutoPtr(ref r, m) => {\n-                ty::adjustment::AutoPtr(r.fold_with(folder), m)\n+            ty::adjustment::AutoBorrow::Ref(ref r, m) => {\n+                ty::adjustment::AutoBorrow::Ref(r.fold_with(folder), m)\n             }\n-            ty::adjustment::AutoUnsafe(m) => ty::adjustment::AutoUnsafe(m)\n+            ty::adjustment::AutoBorrow::RawPtr(m) => ty::adjustment::AutoBorrow::RawPtr(m)\n         }\n     }\n \n@@ -692,8 +692,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            ty::adjustment::AutoPtr(r, _m) => r.visit_with(visitor),\n-            ty::adjustment::AutoUnsafe(_m) => false,\n+            ty::adjustment::AutoBorrow::Ref(r, _m) => r.visit_with(visitor),\n+            ty::adjustment::AutoBorrow::RawPtr(_m) => false,\n         }\n     }\n }"}, {"sha": "7cd5fd78df528981329792c6f9585bf522e6d81a", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -75,6 +75,26 @@ pub fn duration_to_secs_str(dur: Duration) -> String {\n     format!(\"{:.3}\", secs)\n }\n \n+pub fn to_readable_str(mut val: usize) -> String {\n+    let mut groups = vec![];\n+    loop {\n+        let group = val % 1000;\n+\n+        val /= 1000;\n+\n+        if val == 0 {\n+            groups.push(format!(\"{}\", group));\n+            break\n+        } else {\n+            groups.push(format!(\"{:03}\", group));\n+        }\n+    }\n+\n+    groups.reverse();\n+\n+    groups.join(\"_\")\n+}\n+\n pub fn record_time<T, F>(accu: &Cell<Duration>, f: F) -> T where\n     F: FnOnce() -> T,\n {\n@@ -264,3 +284,17 @@ pub fn path2cstr(p: &Path) -> CString {\n pub fn path2cstr(p: &Path) -> CString {\n     CString::new(p.to_str().unwrap()).unwrap()\n }\n+\n+\n+#[test]\n+fn test_to_readable_str() {\n+    assert_eq!(\"0\", to_readable_str(0));\n+    assert_eq!(\"1\", to_readable_str(1));\n+    assert_eq!(\"99\", to_readable_str(99));\n+    assert_eq!(\"999\", to_readable_str(999));\n+    assert_eq!(\"1_000\", to_readable_str(1_000));\n+    assert_eq!(\"1_001\", to_readable_str(1_001));\n+    assert_eq!(\"999_999\", to_readable_str(999_999));\n+    assert_eq!(\"1_000_000\", to_readable_str(1_000_000));\n+    assert_eq!(\"1_234_567\", to_readable_str(1_234_567));\n+}"}, {"sha": "31304fb7b4993eeb4e8c24a21cc0687c10d7d7a6", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -447,32 +447,9 @@ impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::adjustment::AutoAdjustment<'tcx> {\n+impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::adjustment::AdjustNeverToAny(ref target) => {\n-                write!(f, \"AdjustNeverToAny({:?})\", target)\n-            }\n-            ty::adjustment::AdjustReifyFnPointer => {\n-                write!(f, \"AdjustReifyFnPointer\")\n-            }\n-            ty::adjustment::AdjustUnsafeFnPointer => {\n-                write!(f, \"AdjustUnsafeFnPointer\")\n-            }\n-            ty::adjustment::AdjustMutToConstPointer => {\n-                write!(f, \"AdjustMutToConstPointer\")\n-            }\n-            ty::adjustment::AdjustDerefRef(ref data) => {\n-                write!(f, \"{:?}\", data)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::adjustment::AutoDerefRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"AutoDerefRef({}, unsize={:?}, {:?})\",\n-               self.autoderefs, self.unsize, self.autoref)\n+        write!(f, \"{:?} -> {}\", self.kind, self.target)\n     }\n }\n "}, {"sha": "51574868f9bfb5b72a2f8483f4356bef9539311b", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -37,7 +37,7 @@ pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              decl_id: ast::NodeId,\n                              _decl_span: Span,\n                              var_id: ast::NodeId) {\n-    let ty = bccx.tcx.node_id_to_type(var_id);\n+    let ty = bccx.tcx.tables().node_id_to_type(var_id);\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), ty));\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }"}, {"sha": "615aca90db8bfd86497836f4c94938f8243407f9", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n-            let pat_ty = self.tcx.node_id_to_type(scrut.id);\n+            let pat_ty = self.tcx.tables().node_id_to_type(scrut.id);\n             if inlined_arms.is_empty() {\n                 if !pat_ty.is_uninhabited(self.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n-            let pat_ty = cx.tcx.pat_ty(p);\n+            let pat_ty = cx.tcx.tables().pat_ty(p);\n             if let ty::TyAdt(edef, _) = pat_ty.sty {\n                 if edef.is_enum() {\n                     if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n@@ -486,7 +486,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     for pat in pats {\n         pat.walk(|p| {\n             if let PatKind::Binding(hir::BindByValue(..), _, ref sub) = p.node {\n-                let pat_ty = cx.tcx.node_id_to_type(p.id);\n+                let pat_ty = cx.tcx.tables().node_id_to_type(p.id);\n                 if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n                     check_move(p, sub.as_ref().map(|p| &**p));\n                 }"}, {"sha": "57a5400ecadf8071c48a566b6a099baffb22926d", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -27,7 +27,7 @@ use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::Substs;\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::NodeMap;\n+use rustc::util::nodemap::DefIdMap;\n use rustc::lint;\n \n use graphviz::IntoCow;\n@@ -246,7 +246,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    pat_id: ast::NodeId,\n                                    span: Span)\n                                    -> Result<P<hir::Pat>, DefId> {\n-    let pat_ty = tcx.expr_ty(expr);\n+    let pat_ty = tcx.tables().expr_ty(expr);\n     debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n     match pat_ty.sty {\n         ty::TyFloat(_) => {\n@@ -314,7 +314,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           },\n                       }))\n                       .collect::<Result<_, _>>()?;\n-            PatKind::Struct(path.clone(), field_pats, false)\n+            PatKind::Struct((**path).clone(), field_pats, false)\n         }\n \n         hir::ExprArray(ref exprs) => {\n@@ -329,7 +329,8 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 Def::StructCtor(_, CtorKind::Const) |\n                 Def::VariantCtor(_, CtorKind::Const) => PatKind::Path(None, path.clone()),\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                    let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n+                    let substs = Some(tcx.tables().node_id_item_substs(expr.id)\n+                        .unwrap_or_else(|| tcx.intern_substs(&[])));\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n                     return const_expr_to_pat(tcx, expr, pat_id, span);\n                 },\n@@ -413,7 +414,7 @@ pub fn eval_const_expr_checked<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     eval_const_expr_partial(tcx, e, ExprTypeChecked, None)\n }\n \n-pub type FnArgMap<'a> = Option<&'a NodeMap<ConstVal>>;\n+pub type FnArgMap<'a> = Option<&'a DefIdMap<ConstVal>>;\n \n #[derive(Clone, Debug)]\n pub struct ConstEvalErr {\n@@ -606,7 +607,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let ety = match ty_hint {\n         ExprTypeChecked => {\n             // After type-checking, expr_ty is guaranteed to succeed.\n-            Some(tcx.expr_ty(e))\n+            Some(tcx.tables().expr_ty(e))\n         }\n         UncheckedExprHint(ty) => {\n             // Use the type hint; it's not guaranteed to be right, but it's\n@@ -617,7 +618,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // This expression might not be type-checked, and we have no hint.\n             // Try to query the context for a type anyway; we might get lucky\n             // (for example, if the expression was imported from another crate).\n-            tcx.expr_ty_opt(e)\n+            tcx.tables().expr_ty_opt(e)\n         }\n     };\n     let result = match e.node {\n@@ -759,7 +760,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let base_hint = if let ExprTypeChecked = ty_hint {\n             ExprTypeChecked\n         } else {\n-            match tcx.expr_ty_opt(&base) {\n+            match tcx.tables().expr_ty_opt(&base) {\n                 Some(t) => UncheckedExprHint(t),\n                 None => ty_hint\n             }\n@@ -798,7 +799,8 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                   let substs = if let ExprTypeChecked = ty_hint {\n-                      Some(tcx.node_id_item_substs(e.id).substs)\n+                      Some(tcx.tables().node_id_item_substs(e.id)\n+                        .unwrap_or_else(|| tcx.intern_substs(&[])))\n                   } else {\n                       None\n                   };\n@@ -835,9 +837,8 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   ConstVal::Struct(e.id)\n               }\n               Def::Local(def_id) => {\n-                  let id = tcx.map.as_local_node_id(def_id).unwrap();\n-                  debug!(\"Def::Local({:?}): {:?}\", id, fn_args);\n-                  if let Some(val) = fn_args.and_then(|args| args.get(&id)) {\n+                  debug!(\"Def::Local({:?}): {:?}\", def_id, fn_args);\n+                  if let Some(val) = fn_args.and_then(|args| args.get(&def_id)) {\n                       val.clone()\n                   } else {\n                       signal!(e, NonConstPath);\n@@ -863,7 +864,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n           let result = result.as_ref().expect(\"const fn has no result expression\");\n           assert_eq!(decl.inputs.len(), args.len());\n \n-          let mut call_args = NodeMap();\n+          let mut call_args = DefIdMap();\n           for (arg, arg_expr) in decl.inputs.iter().zip(args.iter()) {\n               let arg_hint = ty_hint.erase_hint();\n               let arg_val = eval_const_expr_partial(\n@@ -873,7 +874,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   fn_args\n               )?;\n               debug!(\"const call arg: {:?}\", arg);\n-              let old = call_args.insert(arg.pat.id, arg_val);\n+              let old = call_args.insert(tcx.expect_def(arg.pat.id).def_id(), arg_val);\n               assert!(old.is_none());\n           }\n           debug!(\"const call({:?})\", call_args);"}, {"sha": "10b2a7625cacfefa1140ec965188e48d1cb7d516", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        let mut ty = self.tcx.node_id_to_type(pat.id);\n+        let mut ty = self.tcx.tables().node_id_to_type(pat.id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n@@ -167,8 +167,9 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 match self.tcx.expect_def(pat.id) {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                         let tcx = self.tcx.global_tcx();\n-                        let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n-                        match eval::lookup_const_by_id(tcx, def_id, substs) {\n+                        let substs = tcx.tables().node_id_item_substs(pat.id)\n+                            .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                        match eval::lookup_const_by_id(tcx, def_id, Some(substs)) {\n                             Some((const_expr, _const_ty)) => {\n                                 match eval::const_expr_to_pat(\n                                     tcx, const_expr, pat.id, pat.span)\n@@ -197,7 +198,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = self.tcx.node_id_to_type(pat.id);\n+                let ty = self.tcx.tables().node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n@@ -222,7 +223,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n-                match self.tcx.node_id_to_type(pat.id).sty {\n+                match self.tcx.tables().node_id_to_type(pat.id).sty {\n                     ty::TyTuple(ref tys) => {\n                         let subpatterns =\n                             subpatterns.iter()\n@@ -243,7 +244,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             PatKind::Binding(bm, ref ident, ref sub) => {\n                 let def_id = self.tcx.expect_def(pat.id).def_id();\n                 let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n-                let var_ty = self.tcx.node_id_to_type(pat.id);\n+                let var_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n@@ -280,7 +281,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n-                let pat_ty = self.tcx.node_id_to_type(pat.id);\n+                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n@@ -299,7 +300,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Struct(_, ref fields, _) => {\n-                let pat_ty = self.tcx.node_id_to_type(pat.id);\n+                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {"}, {"sha": "d83918495676c99c8fc6d13ccf1bf60c64a2f4f7", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -37,7 +37,8 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{ast_validation, no_asm, loops, consts, rvalues, static_recursion};\n+use rustc_passes::{ast_validation, no_asm, loops, consts, rvalues,\n+                   static_recursion, hir_stats};\n use rustc_const_eval::check_match;\n use super::Compilation;\n \n@@ -513,6 +514,10 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session, input: &Input) -> PResult<'a,\n         syntax::show_span::run(sess.diagnostic(), s, &krate);\n     }\n \n+    if sess.opts.debugging_opts.hir_stats {\n+        hir_stats::print_ast_stats(&krate, \"PRE EXPANSION AST STATS\");\n+    }\n+\n     Ok(krate)\n }\n \n@@ -718,6 +723,10 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }\n \n+    if sess.opts.debugging_opts.hir_stats {\n+        hir_stats::print_ast_stats(&krate, \"POST EXPANSION AST STATS\");\n+    }\n+\n     if sess.opts.debugging_opts.ast_json {\n         println!(\"{}\", json::as_json(&krate));\n     }\n@@ -758,7 +767,13 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n \n     // Lower ast -> hir.\n     let hir_forest = time(sess.time_passes(), \"lowering ast -> hir\", || {\n-        hir_map::Forest::new(lower_crate(sess, &krate, &mut resolver), &sess.dep_graph)\n+        let hir_crate = lower_crate(sess, &krate, &mut resolver);\n+\n+        if sess.opts.debugging_opts.hir_stats {\n+            hir_stats::print_hir_stats(&hir_crate);\n+        }\n+\n+        hir_map::Forest::new(hir_crate, &sess.dep_graph)\n     });\n \n     // Discard hygiene data, which isn't required past lowering to HIR."}, {"sha": "b4ab9da92e9d0af08a6495b4d7aca42b647dff9b", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -501,7 +501,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n                 pp::space(&mut s.s)?;\n                 pp::word(&mut s.s, \"as\")?;\n                 pp::space(&mut s.s)?;\n-                pp::word(&mut s.s, &self.tcx.expr_ty(expr).to_string())?;\n+                pp::word(&mut s.s, &self.tcx.tables().expr_ty(expr).to_string())?;\n                 s.pclose()\n             }\n             _ => Ok(()),"}, {"sha": "c92e4d8f5aba563c35cbb876c7c449f5e59b38c6", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -11,4 +11,4 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = { path = \"../liblog\" }\n serialize = { path = \"../libserialize\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "28dc71fd59bae021941cf78f5a7e27287ef5b9c9", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -34,7 +34,6 @@ use middle::stability;\n use rustc::cfg;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::adjustment;\n use rustc::traits::{self, Reveal};\n use rustc::hir::map as hir_map;\n use util::nodemap::NodeSet;\n@@ -118,7 +117,9 @@ impl LateLintPass for BoxPointers {\n             hir::ItemTy(..) |\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => self.check_heap_type(cx, it.span, cx.tcx.node_id_to_type(it.id)),\n+            hir::ItemUnion(..) => {\n+                self.check_heap_type(cx, it.span, cx.tcx.tables().node_id_to_type(it.id))\n+            }\n             _ => (),\n         }\n \n@@ -129,15 +130,15 @@ impl LateLintPass for BoxPointers {\n                 for struct_field in struct_def.fields() {\n                     self.check_heap_type(cx,\n                                          struct_field.span,\n-                                         cx.tcx.node_id_to_type(struct_field.id));\n+                                         cx.tcx.tables().node_id_to_type(struct_field.id));\n                 }\n             }\n             _ => (),\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        let ty = cx.tcx.node_id_to_type(e.id);\n+        let ty = cx.tcx.tables().node_id_to_type(e.id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -585,7 +586,7 @@ impl LateLintPass for MissingDebugImplementations {\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n                 if let Some(n) = cx.tcx.map.as_local_node_id(d) {\n-                    if let Some(ty_def) = cx.tcx.node_id_to_type(n).ty_to_def_id() {\n+                    if let Some(ty_def) = cx.tcx.tables().node_id_to_type(n).ty_to_def_id() {\n                         if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n                             impls.insert(node_id);\n                         }\n@@ -939,24 +940,23 @@ impl LateLintPass for UnconditionalRecursion {\n                                                 method: &ty::Method,\n                                                 id: ast::NodeId)\n                                                 -> bool {\n+            use rustc::ty::adjustment::*;\n+\n             // Check for method calls and overloaded operators.\n-            let opt_m = tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)).cloned();\n+            let opt_m = tcx.tables().method_map.get(&ty::MethodCall::expr(id)).cloned();\n             if let Some(m) = opt_m {\n                 if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                     return true;\n                 }\n             }\n \n             // Check for overloaded autoderef method calls.\n-            let opt_adj = tcx.tables.borrow().adjustments.get(&id).cloned();\n-            if let Some(adjustment::AdjustDerefRef(adj)) = opt_adj {\n-                for i in 0..adj.autoderefs {\n+            let opt_adj = tcx.tables().adjustments.get(&id).cloned();\n+            if let Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) = opt_adj {\n+                for i in 0..autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n-                    if let Some(m) = tcx.tables\n-                        .borrow()\n-                        .method_map\n-                        .get(&method_call)\n-                        .cloned() {\n+                    if let Some(m) = tcx.tables().method_map.get(&method_call)\n+                                                            .cloned() {\n                         if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                             return true;\n                         }\n@@ -971,12 +971,10 @@ impl LateLintPass for UnconditionalRecursion {\n                     // it doesn't necessarily have a definition.\n                     match tcx.expect_def_or_none(callee.id) {\n                         Some(Def::Method(def_id)) => {\n-                            let item_substs = tcx.node_id_item_substs(callee.id);\n-                            method_call_refers_to_method(tcx,\n-                                                         method,\n-                                                         def_id,\n-                                                         &item_substs.substs,\n-                                                         id)\n+                            let substs = tcx.tables().node_id_item_substs(callee.id)\n+                                .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                            method_call_refers_to_method(\n+                                tcx, method, def_id, substs, id)\n                         }\n                         _ => false,\n                     }\n@@ -1213,7 +1211,7 @@ impl LateLintPass for MutableTransmutes {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let typ = cx.tcx.node_id_to_type(expr.id);\n+                let typ = cx.tcx.tables().node_id_to_type(expr.id);\n                 match typ.sty {\n                     ty::TyFnDef(.., ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n                         let from = bare_fn.sig.0.inputs[0];\n@@ -1284,7 +1282,7 @@ impl LateLintPass for UnionsWithDropFields {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n             for field in vdata.fields() {\n-                let field_ty = ctx.tcx.node_id_to_type(field.id);\n+                let field_ty = ctx.tcx.tables().node_id_to_type(field.id);\n                 if ctx.tcx.type_needs_drop_given_env(field_ty, param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,"}, {"sha": "b04759955a956b8d3a43153d9b98b4b89a7da7a5", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -113,14 +113,14 @@ impl LateLintPass for TypeLimits {\n                             forbid_unsigned_negation(cx, e.span);\n                         }\n                         ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n-                            if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n+                            if let ty::TyUint(_) = cx.tcx.tables().node_id_to_type(e.id).sty {\n                                 forbid_unsigned_negation(cx, e.span);\n                             }\n                         }\n                         _ => (),\n                     }\n                 } else {\n-                    let t = cx.tcx.node_id_to_type(expr.id);\n+                    let t = cx.tcx.tables().node_id_to_type(expr.id);\n                     if let ty::TyUint(_) = t.sty {\n                         forbid_unsigned_negation(cx, e.span);\n                     }\n@@ -138,7 +138,7 @@ impl LateLintPass for TypeLimits {\n                 }\n \n                 if binop.node.is_shift() {\n-                    let opt_ty_bits = match cx.tcx.node_id_to_type(l.id).sty {\n+                    let opt_ty_bits = match cx.tcx.tables().node_id_to_type(l.id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None,\n@@ -171,7 +171,7 @@ impl LateLintPass for TypeLimits {\n                 }\n             }\n             hir::ExprLit(ref lit) => {\n-                match cx.tcx.node_id_to_type(e.id).sty {\n+                match cx.tcx.tables().node_id_to_type(e.id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n@@ -324,7 +324,7 @@ impl LateLintPass for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match tcx.node_id_to_type(expr.id).sty {\n+            match tcx.tables().node_id_to_type(expr.id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n@@ -740,7 +740,7 @@ impl LateLintPass for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-                let t = cx.tcx.node_id_to_type(it.id);\n+                let t = cx.tcx.tables().node_id_to_type(it.id);\n                 let layout = cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n                     ty.layout(&infcx)"}, {"sha": "15430a5c9f99d96ca583ae3c2767bb8d51dfd374", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -140,7 +140,7 @@ impl LateLintPass for UnusedResults {\n             return;\n         }\n \n-        let t = cx.tcx.expr_ty(&expr);\n+        let t = cx.tcx.tables().expr_ty(&expr);\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n             ty::TyNever => return,\n@@ -441,16 +441,15 @@ impl LateLintPass for UnusedAllocation {\n             _ => return,\n         }\n \n-        if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n-            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef { ref autoref, .. }) =\n-                *adjustment {\n+        if let Some(adjustment) = cx.tcx.tables().adjustments.get(&e.id) {\n+            if let adjustment::Adjust::DerefRef { autoref, .. } = adjustment.kind {\n                 match autoref {\n-                    &Some(adjustment::AutoPtr(_, hir::MutImmutable)) => {\n+                    Some(adjustment::AutoBorrow::Ref(_, hir::MutImmutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION,\n                                      e.span,\n                                      \"unnecessary allocation, use & instead\");\n                     }\n-                    &Some(adjustment::AutoPtr(_, hir::MutMutable)) => {\n+                    Some(adjustment::AutoBorrow::Ref(_, hir::MutMutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION,\n                                      e.span,\n                                      \"unnecessary allocation, use &mut instead\");"}, {"sha": "e009955b92ee4a67cc7f13f05bf4f3e93189ddcf", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -38,7 +38,7 @@ enum TableEntry<'tcx> {\n     Def(Def),\n     NodeType(Ty<'tcx>),\n     ItemSubsts(ty::ItemSubsts<'tcx>),\n-    Adjustment(ty::adjustment::AutoAdjustment<'tcx>),\n+    Adjustment(ty::adjustment::Adjustment<'tcx>),\n     ConstQualif(ConstQualif),\n }\n \n@@ -94,9 +94,9 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx>\n         };\n \n         encode(tcx.expect_def_or_none(id).map(TableEntry::Def));\n-        encode(tcx.node_types().get(&id).cloned().map(TableEntry::NodeType));\n-        encode(tcx.tables.borrow().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n-        encode(tcx.tables.borrow().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n+        encode(tcx.tables().node_types.get(&id).cloned().map(TableEntry::NodeType));\n+        encode(tcx.tables().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n+        encode(tcx.tables().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n         encode(tcx.const_qualif_map.borrow().get(&id).cloned().map(TableEntry::ConstQualif));\n     }\n }"}, {"sha": "fdb117ef81b13e731b638ad70e795466cdcdb0f6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.tables.borrow().closure_tys[&def_id]),\n+            ty: self.lazy(&tcx.tables().closure_tys[&def_id]),\n         };\n \n         Entry {"}, {"sha": "b37dd8dd0a90716d11c584cde4bff6e33c7f4db2", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -191,7 +191,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     assert_eq!(block, builder.return_block());\n \n     let mut spread_arg = None;\n-    match tcx.node_id_to_type(fn_id).sty {\n+    match tcx.tables().node_id_to_type(fn_id).sty {\n         ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n             // RustCall pseudo-ABI untuples the last argument.\n             spread_arg = Some(Local::new(arguments.len()));\n@@ -203,7 +203,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n             let var_id = tcx.map.as_local_node_id(fv.def.def_id()).unwrap();\n-            let by_ref = tcx.upvar_capture(ty::UpvarId {\n+            let by_ref = tcx.tables().upvar_capture(ty::UpvarId {\n                 var_id: var_id,\n                 closure_expr_id: fn_id\n             }).map_or(false, |capture| match capture {\n@@ -233,7 +233,7 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        ast_expr: &'tcx hir::Expr)\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n     let tcx = hir.tcx();\n-    let ty = tcx.expr_ty_adjusted(ast_expr);\n+    let ty = tcx.tables().expr_ty_adjusted(ast_expr);\n     let span = tcx.map.span(item_id);\n     let mut builder = Builder::new(hir, span, 0, ty);\n "}, {"sha": "cb69de2cb3cace0923c907f0218e471cc3010649", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -77,7 +77,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n-    let block_ty = cx.tcx.node_id_to_type(block.id);\n+    let block_ty = cx.tcx.tables().node_id_to_type(block.id);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(block.id);\n     let expr = Expr {\n         ty: block_ty,"}, {"sha": "ba0d3b49a6c1ae28315fd51bd8085db29f982470", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 57, "deletions": 60, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -35,62 +35,61 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let mut expr = make_mirror_unadjusted(cx, self);\n+        let adj = cx.tcx.tables().adjustments.get(&self.id).cloned();\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n-               expr, cx.tcx.tables.borrow().adjustments.get(&self.id));\n+               expr, adj);\n \n         // Now apply adjustments, if any.\n-        match cx.tcx.tables.borrow().adjustments.get(&self.id) {\n+        match adj.map(|adj| (adj.kind, adj.target)) {\n             None => {}\n-            Some(&ty::adjustment::AdjustReifyFnPointer) => {\n-                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+            Some((ty::adjustment::Adjust::ReifyFnPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::ReifyFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustUnsafeFnPointer) => {\n-                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+            Some((ty::adjustment::Adjust::UnsafeFnPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustNeverToAny(adjusted_ty)) => {\n+            Some((ty::adjustment::Adjust::NeverToAny, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::NeverToAny { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustMutToConstPointer) => {\n-                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+            Some((ty::adjustment::Adjust::MutToConstPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::Cast { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustDerefRef(ref adj)) => {\n-                for i in 0..adj.autoderefs {\n+            Some((ty::adjustment::Adjust::DerefRef { autoderefs, autoref, unsize },\n+                  adjusted_ty)) => {\n+                for i in 0..autoderefs {\n                     let i = i as u32;\n                     let adjusted_ty =\n                         expr.ty.adjust_for_autoderef(\n                             cx.tcx,\n                             self.id,\n                             self.span,\n                             i,\n-                            |mc| cx.tcx.tables.borrow().method_map.get(&mc).map(|m| m.ty));\n+                            |mc| cx.tcx.tables().method_map.get(&mc).map(|m| m.ty));\n                     debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\", i, adjusted_ty);\n                     let method_key = ty::MethodCall::autoderef(self.id, i);\n                     let meth_ty =\n-                        cx.tcx.tables.borrow().method_map.get(&method_key).map(|m| m.ty);\n+                        cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n                     let kind = if let Some(meth_ty) = meth_ty {\n                         debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n \n@@ -128,10 +127,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     };\n                 }\n \n-                if let Some(autoref) = adj.autoref {\n+                if let Some(autoref) = autoref {\n                     let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n                     match autoref {\n-                        ty::adjustment::AutoPtr(r, m) => {\n+                        ty::adjustment::AutoBorrow::Ref(r, m) => {\n                             expr = Expr {\n                                 temp_lifetime: temp_lifetime,\n                                 ty: adjusted_ty,\n@@ -143,7 +142,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 },\n                             };\n                         }\n-                        ty::adjustment::AutoUnsafe(m) => {\n+                        ty::adjustment::AutoBorrow::RawPtr(m) => {\n                             // Convert this to a suitable `&foo` and\n                             // then an unsafe coercion. Limit the region to be just this\n                             // expression.\n@@ -169,10 +168,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     }\n                 }\n \n-                if let Some(target) = adj.unsize {\n+                if unsize {\n                     expr = Expr {\n                         temp_lifetime: temp_lifetime,\n-                        ty: target,\n+                        ty: adjusted_ty,\n                         span: self.span,\n                         kind: ExprKind::Unsize { source: expr.to_ref() },\n                     };\n@@ -212,7 +211,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n-    let expr_ty = cx.tcx.expr_ty(expr);\n+    let expr_ty = cx.tcx.tables().expr_ty(expr);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     let kind = match expr.node {\n@@ -231,7 +230,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprCall(ref fun, ref args) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 // The callee is something implementing Fn, FnMut, or FnOnce.\n                 // Find the actual method implementation being called and\n                 // build the appropriate UFCS call expression with the\n@@ -282,7 +281,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     })\n                 } else { None };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tcx.node_id_item_substs(fun.id).substs;\n+                    let substs = cx.tcx.tables().node_id_item_substs(fun.id)\n+                        .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n                     let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n                         name: Field::new(idx),\n                         expr: e.to_ref()\n@@ -296,7 +296,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                 } else {\n                     ExprKind::Call {\n-                        ty: cx.tcx.node_id_to_type(fun.id),\n+                        ty: cx.tcx.tables().node_id_to_type(fun.id),\n                         fun: fun.to_ref(),\n                         args: args.to_ref(),\n                     }\n@@ -328,7 +328,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n@@ -350,7 +350,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n@@ -406,7 +406,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprIndex(ref lhs, ref index) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n                                   PassArgs::ByValue, lhs.to_ref(), vec![index])\n             } else {\n@@ -418,7 +418,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n                                   PassArgs::ByValue, arg.to_ref(), vec![])\n             } else {\n@@ -427,7 +427,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n                                     PassArgs::ByValue, arg.to_ref(), vec![])\n             } else {\n@@ -439,7 +439,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n                                     PassArgs::ByValue, arg.to_ref(), vec![])\n             } else {\n@@ -470,10 +470,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             base: base.as_ref().map(|base| {\n                                 FruInfo {\n                                     base: base.to_ref(),\n-                                    field_types: cx.tcx.tables\n-                                        .borrow()\n-                                        .fru_field_types[&expr.id]\n-                                        .clone()\n+                                    field_types:\n+                                        cx.tcx.tables().fru_field_types[&expr.id].clone()\n                                 }\n                             })\n                         }\n@@ -512,7 +510,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprClosure(..) => {\n-            let closure_ty = cx.tcx.expr_ty(expr);\n+            let closure_ty = cx.tcx.tables().expr_ty(expr);\n             let (def_id, substs) = match closure_ty.sty {\n                 ty::TyClosure(def_id, substs) => (def_id, substs),\n                 _ => {\n@@ -551,7 +549,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprRepeat(ref v, ref c) => ExprKind::Repeat {\n             value: v.to_ref(),\n             count: TypedConstVal {\n-                ty: cx.tcx.expr_ty(c),\n+                ty: cx.tcx.tables().expr_ty(c),\n                 span: c.span,\n                 value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n                     ConstVal::Integral(ConstInt::Usize(u)) => u,\n@@ -579,7 +577,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::Loop { condition: None,\n                              body: block::to_expr_ref(cx, body) },\n         hir::ExprField(ref source, name) => {\n-            let index = match cx.tcx.expr_ty_adjusted(source).sty {\n+            let index = match cx.tcx.tables().expr_ty_adjusted(source).sty {\n                 ty::TyAdt(adt_def, _) =>\n                     adt_def.variants[0].index_of_field_named(name.node),\n                 ref ty =>\n@@ -631,8 +629,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n                                  method_call: ty::MethodCall)\n                                  -> Expr<'tcx> {\n-    let tables = cx.tcx.tables.borrow();\n-    let callee = &tables.method_map[&method_call];\n+    let callee = cx.tcx.tables().method_map[&method_call];\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n     Expr {\n         temp_lifetime: temp_lifetime,\n@@ -666,8 +663,8 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tcx.node_id_item_substs(expr.id).substs;\n-    // Otherwise there may be def_map borrow conflicts\n+    let substs = cx.tcx.tables().node_id_item_substs(expr.id)\n+        .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n     let def = cx.tcx.expect_def(expr.id);\n     let def_id = match def {\n         // A regular function, constructor function or a constant.\n@@ -677,18 +674,20 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Const(def_id) | Def::AssociatedConst(def_id) => def_id,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n-        Def::VariantCtor(def_id, CtorKind::Const) => match cx.tcx.node_id_to_type(expr.id).sty {\n-            // A unit struct/variant which is used as a value.\n-            // We return a completely different ExprKind here to account for this special case.\n-            ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n-                adt_def: adt_def,\n-                variant_index: adt_def.variant_index_with_id(def_id),\n-                substs: substs,\n-                fields: vec![],\n-                base: None,\n-            },\n-            ref sty => bug!(\"unexpected sty: {:?}\", sty)\n-        },\n+        Def::VariantCtor(def_id, CtorKind::Const) => {\n+            match cx.tcx.tables().node_id_to_type(expr.id).sty {\n+                // A unit struct/variant which is used as a value.\n+                // We return a completely different ExprKind here to account for this special case.\n+                ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n+                    adt_def: adt_def,\n+                    variant_index: adt_def.variant_index_with_id(def_id),\n+                    substs: substs,\n+                    fields: vec![],\n+                    base: None,\n+                },\n+                ref sty => bug!(\"unexpected sty: {:?}\", sty)\n+            }\n+        }\n \n         Def::Static(node_id, _) => return ExprKind::StaticRef {\n             id: node_id,\n@@ -720,7 +719,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Upvar(def_id, index, closure_expr_id) => {\n             let id_var = cx.tcx.map.as_local_node_id(def_id).unwrap();\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\", id_var, index, closure_expr_id);\n-            let var_ty = cx.tcx.node_id_to_type(id_var);\n+            let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n \n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n                 Some(map::NodeExpr(expr)) => {\n@@ -737,7 +736,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n \n             // FIXME free regions in closures are not right\n-            let closure_ty = cx.tcx.node_id_to_type(closure_expr_id);\n+            let closure_ty = cx.tcx.tables().node_id_to_type(closure_expr_id);\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n@@ -809,7 +808,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 var_id: id_var,\n                 closure_expr_id: closure_expr_id,\n             };\n-            let upvar_capture = match cx.tcx.upvar_capture(upvar_id) {\n+            let upvar_capture = match cx.tcx.tables().upvar_capture(upvar_id) {\n                 Some(c) => c,\n                 None => {\n                     span_bug!(\n@@ -893,7 +892,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             argrefs.extend(\n                 args.iter()\n                     .map(|arg| {\n-                        let arg_ty = cx.tcx.expr_ty_adjusted(arg);\n+                        let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n                         let adjusted_ty =\n                             cx.tcx.mk_ref(region,\n                                        ty::TypeAndMut { ty: arg_ty,\n@@ -931,9 +930,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n \n     // to find the type &T of the content returned by the method;\n-    let tables = cx.tcx.tables.borrow();\n-    let callee = &tables.method_map[&method_call];\n-    let ref_ty = callee.ty.fn_ret();\n+    let ref_ty = cx.tcx.tables().method_map[&method_call].ty.fn_ret();\n     let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap();\n     // callees always have all late-bound regions fully instantiated,\n \n@@ -962,9 +959,9 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         var_id: id_var,\n         closure_expr_id: closure_expr.id,\n     };\n-    let upvar_capture = cx.tcx.upvar_capture(upvar_id).unwrap();\n+    let upvar_capture = cx.tcx.tables().upvar_capture(upvar_id).unwrap();\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(closure_expr.id);\n-    let var_ty = cx.tcx.node_id_to_type(id_var);\n+    let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,\n         ty: var_ty,"}, {"sha": "0ffc59fe6bf45da6140208019e0e8419845ba63b", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n                 id: ast::NodeId) {\n         // fetch the fully liberated fn signature (that is, all bound\n         // types/lifetimes replaced)\n-        let fn_sig = match self.tcx.tables.borrow().liberated_fn_sigs.get(&id) {\n+        let fn_sig = match self.tcx.tables().liberated_fn_sigs.get(&id) {\n             Some(f) => f.clone(),\n             None => {\n                 span_bug!(span, \"no liberated fn sig for {:?}\", id);\n@@ -248,7 +248,7 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: ast::NodeId)\n                              -> Ty<'tcx> {\n-    let closure_ty = tcx.node_id_to_type(closure_expr_id);\n+    let closure_ty = tcx.tables().node_id_to_type(closure_expr_id);\n \n     // We're just hard-coding the idea that the signature will be\n     // &self or &mut self and hence will have a bound region with"}, {"sha": "f23539e88f78d175f3b9dfc36e4dd70a019dbdae", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -319,7 +319,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         let mut outer = self.qualif;\n         self.qualif = ConstQualif::empty();\n \n-        let node_ty = self.tcx.node_id_to_type(ex.id);\n+        let node_ty = self.tcx.tables().node_id_to_type(ex.id);\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n@@ -449,14 +449,14 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n     match e.node {\n         hir::ExprUnary(..) |\n         hir::ExprBinary(..) |\n-        hir::ExprIndex(..) if v.tcx.tables.borrow().method_map.contains_key(&method_call) => {\n+        hir::ExprIndex(..) if v.tcx.tables().method_map.contains_key(&method_call) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n         }\n         hir::ExprBox(_) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n         }\n         hir::ExprUnary(op, ref inner) => {\n-            match v.tcx.node_id_to_type(inner.id).sty {\n+            match v.tcx.tables().node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n@@ -466,7 +466,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprBinary(op, ref lhs, _) => {\n-            match v.tcx.node_id_to_type(lhs.id).sty {\n+            match v.tcx.tables().node_id_to_type(lhs.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n                             op.node == hir::BiLe || op.node == hir::BiLt ||\n@@ -503,7 +503,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                     }\n                 }\n                 Def::Const(did) | Def::AssociatedConst(did) => {\n-                    let substs = Some(v.tcx.node_id_item_substs(e.id).substs);\n+                    let substs = Some(v.tcx.tables().node_id_item_substs(e.id)\n+                        .unwrap_or_else(|| v.tcx.intern_substs(&[])));\n                     if let Some((expr, _)) = lookup_const_by_id(v.tcx, did, substs) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n@@ -555,7 +556,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let method = v.tcx.tables.borrow().method_map[&method_call];\n+            let method = v.tcx.tables().method_map[&method_call];\n             let is_const = match v.tcx.impl_or_trait_item(method.def_id).container() {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(e, method.def_id, node_ty),\n                 ty::TraitContainer(_) => false\n@@ -565,7 +566,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprStruct(..) => {\n-            if let ty::TyAdt(adt, ..) = v.tcx.expr_ty(e).sty {\n+            if let ty::TyAdt(adt, ..) = v.tcx.tables().expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items.unsafe_cell_type() {\n                     v.add_qualif(ConstQualif::MUTABLE_MEM);\n@@ -624,16 +625,18 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n \n /// Check the adjustments of an expression\n fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n-    match v.tcx.tables.borrow().adjustments.get(&e.id) {\n+    use rustc::ty::adjustment::*;\n+\n+    match v.tcx.tables().adjustments.get(&e.id).map(|adj| adj.kind) {\n         None |\n-        Some(&ty::adjustment::AdjustNeverToAny(..)) |\n-        Some(&ty::adjustment::AdjustReifyFnPointer) |\n-        Some(&ty::adjustment::AdjustUnsafeFnPointer) |\n-        Some(&ty::adjustment::AdjustMutToConstPointer) => {}\n+        Some(Adjust::NeverToAny) |\n+        Some(Adjust::ReifyFnPointer) |\n+        Some(Adjust::UnsafeFnPointer) |\n+        Some(Adjust::MutToConstPointer) => {}\n \n-        Some(&ty::adjustment::AdjustDerefRef(ty::adjustment::AutoDerefRef { autoderefs, .. })) => {\n+        Some(Adjust::DerefRef { autoderefs, .. }) => {\n             if (0..autoderefs as u32)\n-                .any(|autoderef| v.tcx.is_overloaded_autoderef(e.id, autoderef)) {\n+                .any(|autoderef| v.tcx.tables().is_overloaded_autoderef(e.id, autoderef)) {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n             }\n         }"}, {"sha": "18586715894f5042ab09819f02228f0ddcb9a229", "filename": "src/librustc_passes/hir_stats.rs", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -0,0 +1,374 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The visitors in this module collect sizes and counts of the most important\n+// pieces of AST and HIR. The resulting numbers are good approximations but not\n+// completely accurate (some things might be counted twice, others missed).\n+\n+use rustc::hir;\n+use rustc::hir::intravisit as hir_visit;\n+use rustc::util::common::to_readable_str;\n+use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n+use syntax::ast::{self, NodeId, AttrId};\n+use syntax::visit as ast_visit;\n+use syntax_pos::Span;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+enum Id {\n+    Node(NodeId),\n+    Attr(AttrId),\n+    None,\n+}\n+\n+struct NodeData {\n+    count: usize,\n+    size: usize,\n+}\n+\n+struct StatCollector<'k> {\n+    krate: Option<&'k hir::Crate>,\n+    data: FnvHashMap<&'static str, NodeData>,\n+    seen: FnvHashSet<Id>,\n+}\n+\n+pub fn print_hir_stats(krate: &hir::Crate) {\n+    let mut collector = StatCollector {\n+        krate: Some(krate),\n+        data: FnvHashMap(),\n+        seen: FnvHashSet(),\n+    };\n+    hir_visit::walk_crate(&mut collector, krate);\n+    collector.print(\"HIR STATS\");\n+}\n+\n+pub fn print_ast_stats(krate: &ast::Crate, title: &str) {\n+    let mut collector = StatCollector {\n+        krate: None,\n+        data: FnvHashMap(),\n+        seen: FnvHashSet(),\n+    };\n+    ast_visit::walk_crate(&mut collector, krate);\n+    collector.print(title);\n+}\n+\n+impl<'k> StatCollector<'k> {\n+\n+    fn record<T>(&mut self, label: &'static str, id: Id, node: &T) {\n+        if id != Id::None {\n+            if !self.seen.insert(id) {\n+                return\n+            }\n+        }\n+\n+        let entry = self.data.entry(label).or_insert(NodeData {\n+            count: 0,\n+            size: 0,\n+        });\n+\n+        entry.count += 1;\n+        entry.size = ::std::mem::size_of_val(node);\n+    }\n+\n+    fn print(&self, title: &str) {\n+        let mut stats: Vec<_> = self.data.iter().collect();\n+\n+        stats.sort_by_key(|&(_, ref d)| d.count * d.size);\n+\n+        let mut total_size = 0;\n+\n+        println!(\"\\n{}\\n\", title);\n+\n+        println!(\"{:<18}{:>18}{:>14}{:>14}\",\n+            \"Name\", \"Accumulated Size\", \"Count\", \"Item Size\");\n+        println!(\"----------------------------------------------------------------\");\n+\n+        for (label, data) in stats {\n+            println!(\"{:<18}{:>18}{:>14}{:>14}\",\n+                label,\n+                to_readable_str(data.count * data.size),\n+                to_readable_str(data.count),\n+                to_readable_str(data.size));\n+\n+            total_size += data.count * data.size;\n+        }\n+        println!(\"----------------------------------------------------------------\");\n+        println!(\"{:<18}{:>18}\\n\",\n+                \"Total\",\n+                to_readable_str(total_size));\n+    }\n+}\n+\n+impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n+\n+    fn visit_nested_item(&mut self, id: hir::ItemId) {\n+        let nested_item = self.krate.unwrap().item(id.id);\n+        self.visit_item(nested_item)\n+    }\n+\n+    fn visit_item(&mut self, i: &'v hir::Item) {\n+        self.record(\"Item\", Id::Node(i.id), i);\n+        hir_visit::walk_item(self, i)\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+\n+    fn visit_mod(&mut self, m: &'v hir::Mod, _s: Span, n: NodeId) {\n+        self.record(\"Mod\", Id::None, m);\n+        hir_visit::walk_mod(self, m, n)\n+    }\n+    fn visit_foreign_item(&mut self, i: &'v hir::ForeignItem) {\n+        self.record(\"ForeignItem\", Id::Node(i.id), i);\n+        hir_visit::walk_foreign_item(self, i)\n+    }\n+    fn visit_local(&mut self, l: &'v hir::Local) {\n+        self.record(\"Local\", Id::Node(l.id), l);\n+        hir_visit::walk_local(self, l)\n+    }\n+    fn visit_block(&mut self, b: &'v hir::Block) {\n+        self.record(\"Block\", Id::Node(b.id), b);\n+        hir_visit::walk_block(self, b)\n+    }\n+    fn visit_stmt(&mut self, s: &'v hir::Stmt) {\n+        self.record(\"Stmt\", Id::Node(s.node.id()), s);\n+        hir_visit::walk_stmt(self, s)\n+    }\n+    fn visit_arm(&mut self, a: &'v hir::Arm) {\n+        self.record(\"Arm\", Id::None, a);\n+        hir_visit::walk_arm(self, a)\n+    }\n+    fn visit_pat(&mut self, p: &'v hir::Pat) {\n+        self.record(\"Pat\", Id::Node(p.id), p);\n+        hir_visit::walk_pat(self, p)\n+    }\n+    fn visit_decl(&mut self, d: &'v hir::Decl) {\n+        self.record(\"Decl\", Id::None, d);\n+        hir_visit::walk_decl(self, d)\n+    }\n+    fn visit_expr(&mut self, ex: &'v hir::Expr) {\n+        self.record(\"Expr\", Id::Node(ex.id), ex);\n+        hir_visit::walk_expr(self, ex)\n+    }\n+\n+    fn visit_ty(&mut self, t: &'v hir::Ty) {\n+        self.record(\"Ty\", Id::Node(t.id), t);\n+        hir_visit::walk_ty(self, t)\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fk: hir_visit::FnKind<'v>,\n+                fd: &'v hir::FnDecl,\n+                b: &'v hir::Block,\n+                s: Span,\n+                id: NodeId) {\n+        self.record(\"FnDecl\", Id::None, fd);\n+        hir_visit::walk_fn(self, fk, fd, b, s, id)\n+    }\n+\n+    fn visit_where_predicate(&mut self, predicate: &'v hir::WherePredicate) {\n+        self.record(\"WherePredicate\", Id::None, predicate);\n+        hir_visit::walk_where_predicate(self, predicate)\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'v hir::TraitItem) {\n+        self.record(\"TraitItem\", Id::Node(ti.id), ti);\n+        hir_visit::walk_trait_item(self, ti)\n+    }\n+    fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n+        self.record(\"ImplItem\", Id::Node(ii.id), ii);\n+        hir_visit::walk_impl_item(self, ii)\n+    }\n+\n+    fn visit_ty_param_bound(&mut self, bounds: &'v hir::TyParamBound) {\n+        self.record(\"TyParamBound\", Id::None, bounds);\n+        hir_visit::walk_ty_param_bound(self, bounds)\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'v hir::StructField) {\n+        self.record(\"StructField\", Id::Node(s.id), s);\n+        hir_visit::walk_struct_field(self, s)\n+    }\n+\n+    fn visit_variant(&mut self,\n+                     v: &'v hir::Variant,\n+                     g: &'v hir::Generics,\n+                     item_id: NodeId) {\n+        self.record(\"Variant\", Id::None, v);\n+        hir_visit::walk_variant(self, v, g, item_id)\n+    }\n+    fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n+        self.record(\"Lifetime\", Id::Node(lifetime.id), lifetime);\n+        hir_visit::walk_lifetime(self, lifetime)\n+    }\n+    fn visit_lifetime_def(&mut self, lifetime: &'v hir::LifetimeDef) {\n+        self.record(\"LifetimeDef\", Id::None, lifetime);\n+        hir_visit::walk_lifetime_def(self, lifetime)\n+    }\n+    fn visit_path(&mut self, path: &'v hir::Path, _id: NodeId) {\n+        self.record(\"Path\", Id::None, path);\n+        hir_visit::walk_path(self, path)\n+    }\n+    fn visit_path_list_item(&mut self,\n+                            prefix: &'v hir::Path,\n+                            item: &'v hir::PathListItem) {\n+        self.record(\"PathListItem\", Id::Node(item.node.id), item);\n+        hir_visit::walk_path_list_item(self, prefix, item)\n+    }\n+    fn visit_path_segment(&mut self,\n+                          path_span: Span,\n+                          path_segment: &'v hir::PathSegment) {\n+        self.record(\"PathSegment\", Id::None, path_segment);\n+        hir_visit::walk_path_segment(self, path_span, path_segment)\n+    }\n+\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'v hir::TypeBinding) {\n+        self.record(\"TypeBinding\", Id::Node(type_binding.id), type_binding);\n+        hir_visit::walk_assoc_type_binding(self, type_binding)\n+    }\n+    fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n+        self.record(\"Attribute\", Id::Attr(attr.node.id), attr);\n+    }\n+    fn visit_macro_def(&mut self, macro_def: &'v hir::MacroDef) {\n+        self.record(\"MacroDef\", Id::Node(macro_def.id), macro_def);\n+        hir_visit::walk_macro_def(self, macro_def)\n+    }\n+}\n+\n+impl<'v> ast_visit::Visitor for StatCollector<'v> {\n+\n+    fn visit_mod(&mut self, m: &ast::Mod, _s: Span, _n: NodeId) {\n+        self.record(\"Mod\", Id::None, m);\n+        ast_visit::walk_mod(self, m)\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n+        self.record(\"ForeignItem\", Id::None, i);\n+        ast_visit::walk_foreign_item(self, i)\n+    }\n+\n+    fn visit_item(&mut self, i: &ast::Item) {\n+        self.record(\"Item\", Id::None, i);\n+        ast_visit::walk_item(self, i)\n+    }\n+\n+    fn visit_local(&mut self, l: &ast::Local) {\n+        self.record(\"Local\", Id::None, l);\n+        ast_visit::walk_local(self, l)\n+    }\n+\n+    fn visit_block(&mut self, b: &ast::Block) {\n+        self.record(\"Block\", Id::None, b);\n+        ast_visit::walk_block(self, b)\n+    }\n+\n+    fn visit_stmt(&mut self, s: &ast::Stmt) {\n+        self.record(\"Stmt\", Id::None, s);\n+        ast_visit::walk_stmt(self, s)\n+    }\n+\n+    fn visit_arm(&mut self, a: &ast::Arm) {\n+        self.record(\"Arm\", Id::None, a);\n+        ast_visit::walk_arm(self, a)\n+    }\n+\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n+        self.record(\"Pat\", Id::None, p);\n+        ast_visit::walk_pat(self, p)\n+    }\n+\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n+        self.record(\"Expr\", Id::None, ex);\n+        ast_visit::walk_expr(self, ex)\n+    }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n+        self.record(\"Ty\", Id::None, t);\n+        ast_visit::walk_ty(self, t)\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fk: ast_visit::FnKind,\n+                fd: &ast::FnDecl,\n+                b: &ast::Block,\n+                s: Span,\n+                _: NodeId) {\n+        self.record(\"FnDecl\", Id::None, fd);\n+        ast_visit::walk_fn(self, fk, fd, b, s)\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        self.record(\"TraitItem\", Id::None, ti);\n+        ast_visit::walk_trait_item(self, ti)\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        self.record(\"ImplItem\", Id::None, ii);\n+        ast_visit::walk_impl_item(self, ii)\n+    }\n+\n+    fn visit_ty_param_bound(&mut self, bounds: &ast::TyParamBound) {\n+        self.record(\"TyParamBound\", Id::None, bounds);\n+        ast_visit::walk_ty_param_bound(self, bounds)\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &ast::StructField) {\n+        self.record(\"StructField\", Id::None, s);\n+        ast_visit::walk_struct_field(self, s)\n+    }\n+\n+    fn visit_variant(&mut self,\n+                     v: &ast::Variant,\n+                     g: &ast::Generics,\n+                     item_id: NodeId) {\n+        self.record(\"Variant\", Id::None, v);\n+        ast_visit::walk_variant(self, v, g, item_id)\n+    }\n+\n+    fn visit_lifetime(&mut self, lifetime: &ast::Lifetime) {\n+        self.record(\"Lifetime\", Id::None, lifetime);\n+        ast_visit::walk_lifetime(self, lifetime)\n+    }\n+\n+    fn visit_lifetime_def(&mut self, lifetime: &ast::LifetimeDef) {\n+        self.record(\"LifetimeDef\", Id::None, lifetime);\n+        ast_visit::walk_lifetime_def(self, lifetime)\n+    }\n+\n+    fn visit_mac(&mut self, mac: &ast::Mac) {\n+        self.record(\"Mac\", Id::None, mac);\n+    }\n+\n+    fn visit_path_list_item(&mut self,\n+                            prefix: &ast::Path,\n+                            item: &ast::PathListItem) {\n+        self.record(\"PathListItem\", Id::None, item);\n+        ast_visit::walk_path_list_item(self, prefix, item)\n+    }\n+\n+    fn visit_path_segment(&mut self,\n+                          path_span: Span,\n+                          path_segment: &ast::PathSegment) {\n+        self.record(\"PathSegment\", Id::None, path_segment);\n+        ast_visit::walk_path_segment(self, path_span, path_segment)\n+    }\n+\n+    fn visit_assoc_type_binding(&mut self, type_binding: &ast::TypeBinding) {\n+        self.record(\"TypeBinding\", Id::None, type_binding);\n+        ast_visit::walk_assoc_type_binding(self, type_binding)\n+    }\n+\n+    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+        self.record(\"Attribute\", Id::None, attr);\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &ast::MacroDef) {\n+        self.record(\"MacroDef\", Id::None, macro_def);\n+        ast_visit::walk_macro_def(self, macro_def)\n+    }\n+}"}, {"sha": "94816594878ccada8d6dc816454e15b355665b50", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -45,6 +45,7 @@ pub mod diagnostics;\n \n pub mod ast_validation;\n pub mod consts;\n+pub mod hir_stats;\n pub mod loops;\n pub mod no_asm;\n pub mod rvalues;"}, {"sha": "8fdfecd4a586519f3fac992ea2e9445adf324206", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -430,11 +430,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let method = self.tcx.tables.borrow().method_map[&method_call];\n+                let method = self.tcx.tables().method_map[&method_call];\n                 self.check_method(expr.span, method.def_id);\n             }\n             hir::ExprStruct(_, ref expr_fields, _) => {\n-                let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(expr.id));\n                 // RFC 736: ensure all unmentioned fields are visible.\n                 // Rather than computing the set of unmentioned fields\n@@ -495,14 +495,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n         match pattern.node {\n             PatKind::Struct(_, ref fields, _) => {\n-                let adt = self.tcx.pat_ty(pattern).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().pat_ty(pattern).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(pattern.id));\n                 for field in fields {\n                     self.check_field(field.span, adt, variant.field_named(field.node.name));\n                 }\n             }\n             PatKind::TupleStruct(_, ref fields, ddpos) => {\n-                match self.tcx.pat_ty(pattern).sty {\n+                match self.tcx.tables().pat_ty(pattern).sty {\n                     // enum fields have no privacy at this time\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let expected_len = def.struct_variant().fields.len();"}, {"sha": "db4788c3ceadb70964703f37c071161b23f13e17", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -356,7 +356,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n             for &(id, ref p, ..) in &collector.collected_paths {\n-                let typ = self.tcx.node_types().get(&id).unwrap().to_string();\n+                let typ = self.tcx.tables().node_types.get(&id).unwrap().to_string();\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 let sub_span = span_utils.span_for_last_ident(p.span);\n@@ -988,7 +988,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         match p.node {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n-                let adt = self.tcx.node_id_to_type(p.id).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().node_id_to_type(p.id).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(p.id));\n \n                 for &Spanned { node: ref field, span } in fields {\n@@ -1023,8 +1023,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n             };\n-            let types = self.tcx.node_types();\n-            let typ = match types.get(&id) {\n+            let typ = match self.tcx.tables().node_types.get(&id) {\n                 Some(typ) => {\n                     let typ = typ.to_string();\n                     if !value.is_empty() {\n@@ -1355,7 +1354,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n             }\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.map.expect_expr(ex.id);\n-                let adt = self.tcx.expr_ty(&hir_expr).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().expr_ty(&hir_expr).ty_adt_def().unwrap();\n                 let def = self.tcx.expect_def(hir_expr.id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n@@ -1381,7 +1380,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                         return;\n                     }\n                 };\n-                let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n+                let ty = &self.tcx.tables().expr_ty_adjusted(&hir_node).sty;\n                 match *ty {\n                     ty::TyAdt(def, _) => {\n                         let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n@@ -1468,7 +1467,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n-                    let typ = self.tcx.node_types()\n+                    let typ = self.tcx.tables().node_types\n                                   .get(&id).map(|t| t.to_string()).unwrap_or(String::new());\n                     value.push_str(\": \");\n                     value.push_str(&typ);"}, {"sha": "7e008f741624b117187e54a756b1ed73dbcc8133", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -286,7 +286,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                           scope: NodeId) -> Option<VariableData> {\n         if let Some(ident) = field.ident {\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n-            let typ = self.tcx.node_types().get(&field.id).unwrap().to_string();\n+            let typ = self.tcx.tables().node_types.get(&field.id).unwrap().to_string();\n             let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n             filter!(self.span_utils, sub_span, field.span, None);\n             Some(VariableData {\n@@ -418,7 +418,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         let hir_node = self.tcx.map.expect_expr(expr.id);\n-        let ty = self.tcx.expr_ty_adjusted_opt(&hir_node);\n+        let ty = self.tcx.tables().expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().sty == ty::TyError {\n             return None;\n         }\n@@ -432,7 +432,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         return None;\n                     }\n                 };\n-                match self.tcx.expr_ty_adjusted(&hir_node).sty {\n+                match self.tcx.tables().expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let f = def.struct_variant().field_named(ident.node.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n@@ -451,7 +451,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::Struct(ref path, ..) => {\n-                match self.tcx.expr_ty_adjusted(&hir_node).sty {\n+                match self.tcx.tables().expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);\n@@ -472,7 +472,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ExprKind::MethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let method_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                let method_id = self.tcx.tables().method_map[&method_call].def_id;\n                 let (def_id, decl_id) = match self.tcx.impl_or_trait_item(method_id).container() {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),"}, {"sha": "ad8e0c1ee59f6dac0ce2f2edb7b72245733f0654", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -636,7 +636,7 @@ fn link_natively(sess: &Session,\n     {\n         let mut linker = trans.linker_info.to_linker(&mut cmd, &sess);\n         link_args(&mut *linker, sess, crate_type, tmpdir,\n-                  objects, out_filename, outputs);\n+                  objects, out_filename, outputs, trans);\n     }\n     cmd.args(&sess.target.target.options.late_link_args);\n     for obj in &sess.target.target.options.post_link_objects {\n@@ -711,7 +711,8 @@ fn link_args(cmd: &mut Linker,\n              tmpdir: &Path,\n              objects: &[PathBuf],\n              out_filename: &Path,\n-             outputs: &OutputFilenames) {\n+             outputs: &OutputFilenames,\n+             trans: &CrateTranslation) {\n \n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n@@ -726,6 +727,13 @@ fn link_args(cmd: &mut Linker,\n     }\n     cmd.output_filename(out_filename);\n \n+    if crate_type == config::CrateTypeExecutable &&\n+       sess.target.target.options.is_like_windows {\n+        if let Some(ref s) = trans.windows_subsystem {\n+            cmd.subsystem(s);\n+        }\n+    }\n+\n     // If we're building a dynamic library then some platforms need to make sure\n     // that all symbols are exported correctly from the dynamic library.\n     if crate_type != config::CrateTypeExecutable {"}, {"sha": "860903d259fe5394128256821f237a13199f31af", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -92,6 +92,7 @@ pub trait Linker {\n     fn whole_archives(&mut self);\n     fn no_whole_archives(&mut self);\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n+    fn subsystem(&mut self, subsystem: &str);\n }\n \n pub struct GnuLinker<'a> {\n@@ -294,6 +295,10 @@ impl<'a> Linker for GnuLinker<'a> {\n \n         self.cmd.arg(arg);\n     }\n+\n+    fn subsystem(&mut self, subsystem: &str) {\n+        self.cmd.arg(&format!(\"-Wl,--subsystem,{}\", subsystem));\n+    }\n }\n \n pub struct MsvcLinker<'a> {\n@@ -441,6 +446,30 @@ impl<'a> Linker for MsvcLinker<'a> {\n         arg.push(path);\n         self.cmd.arg(&arg);\n     }\n+\n+    fn subsystem(&mut self, subsystem: &str) {\n+        // Note that previous passes of the compiler validated this subsystem,\n+        // so we just blindly pass it to the linker.\n+        self.cmd.arg(&format!(\"/SUBSYSTEM:{}\", subsystem));\n+\n+        // Windows has two subsystems we're interested in right now, the console\n+        // and windows subsystems. These both implicitly have different entry\n+        // points (starting symbols). The console entry point starts with\n+        // `mainCRTStartup` and the windows entry point starts with\n+        // `WinMainCRTStartup`. These entry points, defined in system libraries,\n+        // will then later probe for either `main` or `WinMain`, respectively to\n+        // start the application.\n+        //\n+        // In Rust we just always generate a `main` function so we want control\n+        // to always start there, so we force the entry point on the windows\n+        // subsystem to be `mainCRTStartup` to get everything booted up\n+        // correctly.\n+        //\n+        // For more information see RFC #1665\n+        if subsystem == \"windows\" {\n+            self.cmd.arg(\"/ENTRY:mainCRTStartup\");\n+        }\n+    }\n }\n \n fn exported_symbols(scx: &SharedCrateContext,"}, {"sha": "bd15035b8a94ed26e5dc9b37d56d082e2c864634", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1196,6 +1196,9 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n         }\n         let llfn = declare::declare_cfn(ccx, \"main\", llfty);\n \n+        // `main` should respect same config for frame pointer elimination as rest of code\n+        attributes::set_frame_pointer_elimination(ccx, llfn);\n+\n         let llbb = unsafe {\n             llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, \"top\\0\".as_ptr() as *const _)\n         };\n@@ -1611,7 +1614,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             metadata: metadata,\n             reachable: vec![],\n             no_builtins: no_builtins,\n-            linker_info: linker_info\n+            linker_info: linker_info,\n+            windows_subsystem: None,\n         };\n     }\n \n@@ -1747,14 +1751,26 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let linker_info = LinkerInfo::new(&shared_ccx, &reachable_symbols);\n \n+    let subsystem = attr::first_attr_value_str_by_name(&krate.attrs,\n+                                                       \"windows_subsystem\");\n+    let windows_subsystem = subsystem.map(|subsystem| {\n+        if subsystem != \"windows\" && subsystem != \"console\" {\n+            tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n+                                     `windows` and `console` are allowed\",\n+                                    subsystem));\n+        }\n+        subsystem.to_string()\n+    });\n+\n     CrateTranslation {\n         modules: modules,\n         metadata_module: metadata_module,\n         link: link_meta,\n         metadata: metadata,\n         reachable: reachable_symbols,\n         no_builtins: no_builtins,\n-        linker_info: linker_info\n+        linker_info: linker_info,\n+        windows_subsystem: windows_subsystem,\n     }\n }\n "}, {"sha": "ffb13a833a582543e615fe7dba8e971f289e3590", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> Callee<'tcx> {\n     pub fn method_call<'blk>(bcx: Block<'blk, 'tcx>,\n                              method_call: ty::MethodCall)\n                              -> Callee<'tcx> {\n-        let method = bcx.tcx().tables.borrow().method_map[&method_call];\n+        let method = bcx.tcx().tables().method_map[&method_call];\n         Callee::method(bcx, method)\n     }\n "}, {"sha": "a439d415ede151f16e2f7e1418498e89b4f5a69f", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1082,10 +1082,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n                 if !generics.is_parameterized() {\n-                    let ty = {\n-                        let tables = self.scx.tcx().tables.borrow();\n-                        tables.node_types[&item.id]\n-                    };\n+                    let ty = self.scx.tcx().tables().node_types[&item.id];\n \n                     if self.mode == TransItemCollectionMode::Eager {\n                         debug!(\"RootCollector: ADT drop-glue for {}\","}, {"sha": "4bb34850e0870c0cce998ceb9a57acb54ac81dbf", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1765,7 +1765,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = tcx.erase_regions(&tcx.node_id_to_type(node_id));\n+    let variable_type = tcx.erase_regions(&tcx.tables().node_id_to_type(node_id));\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");"}, {"sha": "37304f28e03f64e2b25e2073f9177fa90a82de17", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -169,6 +169,7 @@ pub struct CrateTranslation {\n     pub metadata: Vec<u8>,\n     pub reachable: Vec<String>,\n     pub no_builtins: bool,\n+    pub windows_subsystem: Option<String>,\n     pub linker_info: back::linker::LinkerInfo\n }\n "}, {"sha": "c93f1c6c8e6102523bdb7a9fea545239b91112cd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1549,7 +1549,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n                 tcx.prohibit_type_params(base_segments);\n                 let impl_id = tcx.map.as_local_node_id(def_id).unwrap();\n-                let ty = tcx.node_id_to_type(impl_id);\n+                let ty = tcx.tables().node_id_to_type(impl_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n                 } else {"}, {"sha": "3cf64fa439d7d0afe868f3ab2554079661dac4c1", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match self.structurally_resolved_type(callee_expr.span, adjusted_ty).sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                self.write_autoderef_adjustment(callee_expr.id, autoderefs);\n+                self.write_autoderef_adjustment(callee_expr.id, autoderefs, adjusted_ty);\n                 return Some(CallStep::Builtin);\n             }\n "}, {"sha": "16493412d690b41e042afbb1e2c9b99b2fc8fe06", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -65,10 +65,7 @@ use check::FnCtxt;\n use rustc::hir;\n use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n use rustc::traits::{self, ObligationCause};\n-use rustc::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n-use rustc::ty::adjustment::{AutoPtr, AutoUnsafe, AdjustReifyFnPointer};\n-use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n-use rustc::ty::adjustment::AdjustNeverToAny;\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::{self, LvaluePreference, TypeAndMut, Ty};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n@@ -93,7 +90,7 @@ impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n     }\n }\n \n-type CoerceResult<'tcx> = RelateResult<'tcx, (Ty<'tcx>, AutoAdjustment<'tcx>)>;\n+type CoerceResult<'tcx> = RelateResult<'tcx, (Ty<'tcx>, Adjust<'tcx>)>;\n \n fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n                        to_mutbl: hir::Mutability)\n@@ -144,12 +141,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n     /// Synthesize an identity adjustment.\n     fn identity(&self, ty: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        Ok((ty,\n-            AdjustDerefRef(AutoDerefRef {\n-                autoderefs: 0,\n-                autoref: None,\n-                unsize: None,\n-            })))\n+        Ok((ty, Adjust::DerefRef {\n+            autoderefs: 0,\n+            autoref: None,\n+            unsize: false,\n+        }))\n     }\n \n     fn coerce<'a, E, I>(&self, exprs: &E, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx>\n@@ -166,7 +162,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n \n         if a.is_never() {\n-            return Ok((b, AdjustNeverToAny(b)));\n+            return Ok((b, Adjust::NeverToAny));\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -396,17 +392,16 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyRef(r_borrow, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n-        let autoref = Some(AutoPtr(r_borrow, mt_b.mutbl));\n+        let autoref = Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl));\n         debug!(\"coerce_borrowed_pointer: succeeded ty={:?} autoderefs={:?} autoref={:?}\",\n                ty,\n                autoderefs,\n                autoref);\n-        Ok((ty,\n-            AdjustDerefRef(AutoDerefRef {\n-                autoderefs: autoderefs,\n-                autoref: autoref,\n-                unsize: None,\n-            })))\n+        Ok((ty, Adjust::DerefRef {\n+            autoderefs: autoderefs,\n+            autoref: autoref,\n+            unsize: false,\n+        }))\n     }\n \n \n@@ -437,11 +432,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n                 let coercion = Coercion(self.origin.span());\n                 let r_borrow = self.next_region_var(coercion);\n-                (mt_a.ty, Some(AutoPtr(r_borrow, mt_b.mutbl)))\n+                (mt_a.ty, Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl)))\n             }\n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n-                (mt_a.ty, Some(AutoUnsafe(mt_b.mutbl)))\n+                (mt_a.ty, Some(AutoBorrow::RawPtr(mt_b.mutbl)))\n             }\n             _ => (source, None),\n         };\n@@ -497,13 +492,13 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         *self.unsizing_obligations.borrow_mut() = leftover_predicates;\n \n-        let adjustment = AutoDerefRef {\n+        let adjustment = Adjust::DerefRef {\n             autoderefs: if reborrow.is_some() { 1 } else { 0 },\n             autoref: reborrow,\n-            unsize: Some(target),\n+            unsize: true,\n         };\n         debug!(\"Success, coerced with {:?}\", adjustment);\n-        Ok((target, AdjustDerefRef(adjustment)))\n+        Ok((target, adjustment))\n     }\n \n     fn coerce_from_safe_fn(&self,\n@@ -516,7 +511,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n                     return self.unify_and_identity(unsafe_a, b)\n-                        .map(|(ty, _)| (ty, AdjustUnsafeFnPointer));\n+                        .map(|(ty, _)| (ty, Adjust::UnsafeFnPointer));\n                 }\n                 _ => {}\n             }\n@@ -555,7 +550,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n                 self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b)\n-                    .map(|(ty, _)| (ty, AdjustReifyFnPointer))\n+                    .map(|(ty, _)| (ty, Adjust::ReifyFnPointer))\n             }\n             _ => self.unify_and_identity(a, b),\n         }\n@@ -585,17 +580,17 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n \n         // Although references and unsafe ptrs have the same\n-        // representation, we still register an AutoDerefRef so that\n+        // representation, we still register an Adjust::DerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n         Ok((ty,\n             if is_ref {\n-                AdjustDerefRef(AutoDerefRef {\n+                Adjust::DerefRef {\n                     autoderefs: 1,\n-                    autoref: Some(AutoUnsafe(mutbl_b)),\n-                    unsize: None,\n-                })\n+                    autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n+                    unsize: false,\n+                }\n             } else if mt_a.mutbl != mutbl_b {\n-                AdjustMutToConstPointer\n+                Adjust::MutToConstPointer\n             } else {\n                 noop\n             }))\n@@ -606,24 +601,25 @@ fn apply<'a, 'b, 'gcx, 'tcx, E, I>(coerce: &mut Coerce<'a, 'gcx, 'tcx>,\n                                    exprs: &E,\n                                    a: Ty<'tcx>,\n                                    b: Ty<'tcx>)\n-                                   -> CoerceResult<'tcx>\n+                                   -> RelateResult<'tcx, Adjustment<'tcx>>\n     where E: Fn() -> I,\n           I: IntoIterator<Item = &'b hir::Expr>\n {\n \n-    let (ty, adjustment) = indent(|| coerce.coerce(exprs, a, b))?;\n+    let (ty, adjust) = indent(|| coerce.coerce(exprs, a, b))?;\n \n     let fcx = coerce.fcx;\n-    if let AdjustDerefRef(auto) = adjustment {\n-        if auto.unsize.is_some() {\n-            let mut obligations = coerce.unsizing_obligations.borrow_mut();\n-            for obligation in obligations.drain(..) {\n-                fcx.register_predicate(obligation);\n-            }\n+    if let Adjust::DerefRef { unsize: true, .. } = adjust {\n+        let mut obligations = coerce.unsizing_obligations.borrow_mut();\n+        for obligation in obligations.drain(..) {\n+            fcx.register_predicate(obligation);\n         }\n     }\n \n-    Ok((ty, adjustment))\n+    Ok(Adjustment {\n+        kind: adjust,\n+        target: ty\n+    })\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -641,17 +637,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut coerce = Coerce::new(self, TypeOrigin::ExprAssignable(expr.span));\n         self.commit_if_ok(|_| {\n-            let (ty, adjustment) = apply(&mut coerce, &|| Some(expr), source, target)?;\n+            let adjustment = apply(&mut coerce, &|| Some(expr), source, target)?;\n             if !adjustment.is_identity() {\n                 debug!(\"Success, coerced with {:?}\", adjustment);\n                 match self.tables.borrow().adjustments.get(&expr.id) {\n                     None |\n-                    Some(&AdjustNeverToAny(..)) => (),\n+                    Some(&Adjustment { kind: Adjust::NeverToAny, .. }) => (),\n                     _ => bug!(\"expr already has an adjustment on it!\"),\n                 };\n                 self.write_adjustment(expr.id, adjustment);\n             }\n-            Ok(ty)\n+            Ok(adjustment.target)\n         })\n     }\n \n@@ -705,12 +701,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 // Reify both sides and return the reified fn pointer type.\n+                let fn_ptr = self.tcx.mk_fn_ptr(fty);\n                 for expr in exprs().into_iter().chain(Some(new)) {\n                     // No adjustments can produce a fn item, so this should never trip.\n                     assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n-                    self.write_adjustment(expr.id, AdjustReifyFnPointer);\n+                    self.write_adjustment(expr.id, Adjustment {\n+                        kind: Adjust::ReifyFnPointer,\n+                        target: fn_ptr\n+                    });\n                 }\n-                return Ok(self.tcx.mk_fn_ptr(fty));\n+                return Ok(fn_ptr);\n             }\n             _ => {}\n         }\n@@ -724,11 +724,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if !self.tables.borrow().adjustments.contains_key(&new.id) {\n             let result = self.commit_if_ok(|_| apply(&mut coerce, &|| Some(new), new_ty, prev_ty));\n             match result {\n-                Ok((ty, adjustment)) => {\n+                Ok(adjustment) => {\n                     if !adjustment.is_identity() {\n                         self.write_adjustment(new.id, adjustment);\n                     }\n-                    return Ok(ty);\n+                    return Ok(adjustment.target);\n                 }\n                 Err(e) => first_error = Some(e),\n             }\n@@ -738,10 +738,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // This requires ensuring there are no coercions applied to *any* of the\n         // previous expressions, other than noop reborrows (ignoring lifetimes).\n         for expr in exprs() {\n-            let noop = match self.tables.borrow().adjustments.get(&expr.id) {\n-                Some(&AdjustDerefRef(AutoDerefRef { autoderefs: 1,\n-                                                    autoref: Some(AutoPtr(_, mutbl_adj)),\n-                                                    unsize: None })) => {\n+            let noop = match self.tables.borrow().adjustments.get(&expr.id).map(|adj| adj.kind) {\n+                Some(Adjust::DerefRef {\n+                    autoderefs: 1,\n+                    autoref: Some(AutoBorrow::Ref(_, mutbl_adj)),\n+                    unsize: false\n+                }) => {\n                     match self.node_ty(expr.id).sty {\n                         ty::TyRef(_, mt_orig) => {\n                             // Reborrow that we can safely ignore.\n@@ -750,7 +752,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         _ => false,\n                     }\n                 }\n-                Some(&AdjustNeverToAny(_)) => true,\n+                Some(Adjust::NeverToAny) => true,\n                 Some(_) => false,\n                 None => true,\n             };\n@@ -783,18 +785,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     })\n                 }\n             }\n-            Ok((ty, adjustment)) => {\n+            Ok(adjustment) => {\n                 if !adjustment.is_identity() {\n+                    let mut tables = self.tables.borrow_mut();\n                     for expr in exprs() {\n-                        let previous = self.tables.borrow().adjustments.get(&expr.id).cloned();\n-                        if let Some(AdjustNeverToAny(_)) = previous {\n-                            self.write_adjustment(expr.id, AdjustNeverToAny(ty));\n-                        } else {\n-                            self.write_adjustment(expr.id, adjustment);\n+                        if let Some(&mut Adjustment {\n+                            kind: Adjust::NeverToAny,\n+                            ref mut target\n+                        }) = tables.adjustments.get_mut(&expr.id) {\n+                            *target = adjustment.target;\n+                            continue;\n                         }\n+                        tables.adjustments.insert(expr.id, adjustment);\n                     }\n                 }\n-                Ok(ty)\n+                Ok(adjustment.target)\n             }\n         }\n     }"}, {"sha": "f88bb355d1270a63ddeaa536a2ec5ca64e2c962d", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 70, "deletions": 66, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -15,7 +15,7 @@ use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n-use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use syntax_pos::Span;\n@@ -140,20 +140,19 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                       unadjusted_self_ty: Ty<'tcx>,\n                       pick: &probe::Pick<'tcx>)\n                       -> Ty<'tcx> {\n-        let (autoref, unsize) = if let Some(mutbl) = pick.autoref {\n+        let autoref = if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n-            let autoref = AutoPtr(region, mutbl);\n-            (Some(autoref),\n-             pick.unsize.map(|target| target.adjust_for_autoref(self.tcx, Some(autoref))))\n+            Some(AutoBorrow::Ref(region, mutbl))\n         } else {\n             // No unsizing should be performed without autoref (at\n             // least during method dispach). This is because we\n             // currently only unsize `[T;N]` to `[T]`, and naturally\n             // that must occur being a reference.\n             assert!(pick.unsize.is_none());\n-            (None, None)\n+            None\n         };\n \n+\n         // Commit the autoderefs by calling `autoderef` again, but this\n         // time writing the results into the various tables.\n         let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n@@ -163,19 +162,20 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         autoderef.unambiguous_final_ty();\n         autoderef.finalize(LvaluePreference::NoPreference, Some(self.self_expr));\n \n+        let target = pick.unsize.unwrap_or(autoderefd_ty);\n+        let target = target.adjust_for_autoref(self.tcx, autoref);\n+\n         // Write out the final adjustment.\n-        self.write_adjustment(self.self_expr.id,\n-                              AdjustDerefRef(AutoDerefRef {\n-                                  autoderefs: pick.autoderefs,\n-                                  autoref: autoref,\n-                                  unsize: unsize,\n-                              }));\n-\n-        if let Some(target) = unsize {\n-            target\n-        } else {\n-            autoderefd_ty.adjust_for_autoref(self.tcx, autoref)\n-        }\n+        self.write_adjustment(self.self_expr.id, Adjustment {\n+            kind: Adjust::DerefRef {\n+                autoderefs: pick.autoderefs,\n+                autoref: autoref,\n+                unsize: pick.unsize.is_some(),\n+            },\n+            target: target\n+        });\n+\n+        target\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -463,29 +463,23 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Fix up autoderefs and derefs.\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n+            debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?}\", i, expr);\n+\n             // Count autoderefs.\n-            let autoderef_count = match self.tables\n-                .borrow()\n-                .adjustments\n-                .get(&expr.id) {\n-                Some(&AdjustDerefRef(ref adj)) => adj.autoderefs,\n-                Some(_) | None => 0,\n-            };\n-\n-            debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?} \\\n-                                                      autoderef_count={}\",\n-                   i,\n-                   expr,\n-                   autoderef_count);\n-\n-            if autoderef_count > 0 {\n-                let mut autoderef = self.autoderef(expr.span, self.node_ty(expr.id));\n-                autoderef.nth(autoderef_count).unwrap_or_else(|| {\n-                    span_bug!(expr.span,\n-                              \"expr was deref-able {} times but now isn't?\",\n-                              autoderef_count);\n-                });\n-                autoderef.finalize(PreferMutLvalue, Some(expr));\n+            let adjustment = self.tables.borrow().adjustments.get(&expr.id).cloned();\n+            match adjustment {\n+                Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) => {\n+                    if autoderefs > 0 {\n+                        let mut autoderef = self.autoderef(expr.span, self.node_ty(expr.id));\n+                        autoderef.nth(autoderefs).unwrap_or_else(|| {\n+                            span_bug!(expr.span,\n+                                      \"expr was deref-able {} times but now isn't?\",\n+                                      autoderefs);\n+                        });\n+                        autoderef.finalize(PreferMutLvalue, Some(expr));\n+                    }\n+                }\n+                Some(_) | None => {}\n             }\n \n             // Don't retry the first one or we might infinite loop!\n@@ -503,45 +497,55 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     // ought to recode this routine so it doesn't\n                     // (ab)use the normal type checking paths.\n                     let adj = self.tables.borrow().adjustments.get(&base_expr.id).cloned();\n-                    let (autoderefs, unsize) = match adj {\n-                        Some(AdjustDerefRef(adr)) => {\n-                            match adr.autoref {\n+                    let (autoderefs, unsize, adjusted_base_ty) = match adj {\n+                        Some(Adjustment {\n+                            kind: Adjust::DerefRef { autoderefs, autoref, unsize },\n+                            target\n+                        }) => {\n+                            match autoref {\n                                 None => {\n-                                    assert!(adr.unsize.is_none());\n-                                    (adr.autoderefs, None)\n-                                }\n-                                Some(AutoPtr(..)) => {\n-                                    (adr.autoderefs,\n-                                     adr.unsize.map(|target| {\n-                                         target.builtin_deref(false, NoPreference)\n-                                             .expect(\"fixup: AutoPtr is not &T\")\n-                                             .ty\n-                                     }))\n+                                    assert!(!unsize);\n                                 }\n+                                Some(AutoBorrow::Ref(..)) => {}\n                                 Some(_) => {\n                                     span_bug!(base_expr.span,\n                                               \"unexpected adjustment autoref {:?}\",\n-                                              adr);\n+                                              adj);\n                                 }\n                             }\n+\n+                            (autoderefs, unsize, if unsize {\n+                                target.builtin_deref(false, NoPreference)\n+                                      .expect(\"fixup: AutoBorrow::Ref is not &T\")\n+                                      .ty\n+                            } else {\n+                                let ty = self.node_ty(base_expr.id);\n+                                let mut ty = self.shallow_resolve(ty);\n+                                let mut method_type = |method_call: ty::MethodCall| {\n+                                    self.tables.borrow().method_map.get(&method_call).map(|m| {\n+                                        self.resolve_type_vars_if_possible(&m.ty)\n+                                    })\n+                                };\n+\n+                                if !ty.references_error() {\n+                                    for i in 0..autoderefs {\n+                                        ty = ty.adjust_for_autoderef(self.tcx,\n+                                                                     base_expr.id,\n+                                                                     base_expr.span,\n+                                                                     i as u32,\n+                                                                     &mut method_type);\n+                                    }\n+                                }\n+\n+                                ty\n+                            })\n                         }\n-                        None => (0, None),\n+                        None => (0, false, self.node_ty(base_expr.id)),\n                         Some(_) => {\n                             span_bug!(base_expr.span, \"unexpected adjustment type\");\n                         }\n                     };\n \n-                    let (adjusted_base_ty, unsize) = if let Some(target) = unsize {\n-                        (target, true)\n-                    } else {\n-                        (self.adjust_expr_ty(base_expr,\n-                                             Some(&AdjustDerefRef(AutoDerefRef {\n-                                                 autoderefs: autoderefs,\n-                                                 autoref: None,\n-                                                 unsize: None,\n-                                             }))),\n-                         false)\n-                    };\n                     let index_expr_ty = self.node_ty(index_expr.id);\n \n                     let result = self.try_index_step(ty::MethodCall::expr(expr.id),"}, {"sha": "2df562f9ade46032613c5c6ea92799d74e2e79e9", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -16,7 +16,7 @@ use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::infer;\n \n use syntax::ast;\n@@ -294,28 +294,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        unsize,\n                        method_ty.explicit_self);\n \n-                match method_ty.explicit_self {\n+                let autoref = match method_ty.explicit_self {\n                     ty::ExplicitSelfCategory::ByValue => {\n                         // Trait method is fn(self), no transformation needed.\n                         assert!(!unsize);\n-                        self.write_autoderef_adjustment(self_expr.id, autoderefs);\n+                        None\n                     }\n \n                     ty::ExplicitSelfCategory::ByReference(..) => {\n                         // Trait method is fn(&self) or fn(&mut self), need an\n                         // autoref. Pull the region etc out of the type of first argument.\n                         match transformed_self_ty.sty {\n                             ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ }) => {\n-                                self.write_adjustment(self_expr.id,\n-                                                      AdjustDerefRef(AutoDerefRef {\n-                                                          autoderefs: autoderefs,\n-                                                          autoref: Some(AutoPtr(region, mutbl)),\n-                                                          unsize: if unsize {\n-                                                              Some(transformed_self_ty)\n-                                                          } else {\n-                                                              None\n-                                                          },\n-                                                      }));\n+                                Some(AutoBorrow::Ref(region, mutbl))\n                             }\n \n                             _ => {\n@@ -331,7 +322,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   \"unexpected explicit self type in operator method: {:?}\",\n                                   method_ty.explicit_self);\n                     }\n-                }\n+                };\n+\n+                self.write_adjustment(self_expr.id, Adjustment {\n+                    kind: Adjust::DerefRef {\n+                        autoderefs: autoderefs,\n+                        autoref: autoref,\n+                        unsize: unsize\n+                    },\n+                    target: transformed_self_ty\n+                });\n             }\n         }\n "}, {"sha": "d8314bd6c2aedc29cdc7b050ea18ad8bc4a65309", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -777,7 +777,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         check_union(ccx, it.id, it.span);\n       }\n       hir::ItemTy(_, ref generics) => {\n-        let pty_ty = ccx.tcx.node_id_to_type(it.id);\n+        let pty_ty = ccx.tcx.tables().node_id_to_type(it.id);\n         check_bounds_are_used(ccx, generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n@@ -1205,7 +1205,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  sp: Span,\n                                  item_id: ast::NodeId)\n                                  -> bool {\n-    let rty = tcx.node_id_to_type(item_id);\n+    let rty = tcx.tables().node_id_to_type(item_id);\n \n     // Check that it is possible to represent this type. This call identifies\n     // (1) types that contain themselves and (2) types that contain a different\n@@ -1224,7 +1224,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, id: ast::NodeId) {\n-    let t = tcx.node_id_to_type(id);\n+    let t = tcx.tables().node_id_to_type(id);\n     match t.sty {\n         ty::TyAdt(def, substs) if def.is_struct() => {\n             let fields = &def.struct_variant().fields;\n@@ -1581,20 +1581,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn write_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n-                                      derefs: usize) {\n-        self.write_adjustment(\n-            node_id,\n-            adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n+                                      derefs: usize,\n+                                      adjusted_ty: Ty<'tcx>) {\n+        self.write_adjustment(node_id, adjustment::Adjustment {\n+            kind: adjustment::Adjust::DerefRef {\n                 autoderefs: derefs,\n                 autoref: None,\n-                unsize: None\n-            })\n-        );\n+                unsize: false\n+            },\n+            target: adjusted_ty\n+        });\n     }\n \n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n-                            adj: adjustment::AutoAdjustment<'tcx>) {\n+                            adj: adjustment::Adjustment<'tcx>) {\n         debug!(\"write_adjustment(node_id={}, adj={:?})\", node_id, adj);\n \n         if adj.is_identity() {\n@@ -1760,21 +1761,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    /// Apply `adjustment` to the type of `expr`\n-    pub fn adjust_expr_ty(&self,\n-                          expr: &hir::Expr,\n-                          adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n-                          -> Ty<'tcx>\n-    {\n-        let raw_ty = self.node_ty(expr.id);\n-        let raw_ty = self.shallow_resolve(raw_ty);\n-        let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n-        raw_ty.adjust(self.tcx, expr.span, expr.id, adjustment, |method_call| {\n-            self.tables.borrow().method_map.get(&method_call)\n-                                        .map(|method| resolve_ty(method.ty))\n-        })\n-    }\n-\n     pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n         match self.tables.borrow().node_types.get(&id) {\n             Some(&t) => t,\n@@ -2311,7 +2297,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 debug!(\"try_index_step: success, using built-in indexing\");\n                 // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n                 assert!(!unsize);\n-                self.write_autoderef_adjustment(base_expr.id, autoderefs);\n+                self.write_autoderef_adjustment(base_expr.id, autoderefs, adjusted_ty);\n                 return Some((tcx.types.usize, ty));\n             }\n             _ => {}\n@@ -2867,9 +2853,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // In case we did perform an adjustment, we have to update\n                 // the type of the block, because old trans still uses it.\n-                let adj = self.tables.borrow().adjustments.get(&then.id).cloned();\n-                if res.is_ok() && adj.is_some() {\n-                    self.write_ty(then_blk.id, self.adjust_expr_ty(then, adj.as_ref()));\n+                if res.is_ok() {\n+                    let adj = self.tables.borrow().adjustments.get(&then.id).cloned();\n+                    if let Some(adj) = adj {\n+                        self.write_ty(then_blk.id, adj.target);\n+                    }\n                 }\n \n                 res\n@@ -2930,7 +2918,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n                             autoderef.finalize(lvalue_pref, Some(base));\n-                            self.write_autoderef_adjustment(base.id, autoderefs);\n+                            self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n                             return field_ty;\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n@@ -3048,7 +3036,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if let Some(field_ty) = field {\n                 autoderef.finalize(lvalue_pref, Some(base));\n-                self.write_autoderef_adjustment(base.id, autoderefs);\n+                self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n                 return field_ty;\n             }\n         }\n@@ -3252,6 +3240,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             Def::Struct(..) | Def::Union(..) | Def::TyAlias(..) |\n             Def::AssociatedTy(..) | Def::SelfTy(..) => {\n+                match def {\n+                    Def::AssociatedTy(..) | Def::SelfTy(..)\n+                            if !self.tcx.sess.features.borrow().more_struct_aliases => {\n+                        emit_feature_err(&self.tcx.sess.parse_sess,\n+                                         \"more_struct_aliases\", path.span, GateIssue::Language,\n+                                         \"`Self` and associated types in struct \\\n+                                          expressions and patterns are unstable\");\n+                    }\n+                    _ => {}\n+                }\n                 match ty.sty {\n                     ty::TyAdt(adt, substs) if !adt.is_enum() => {\n                         Some((adt.struct_variant(), adt.did, substs))\n@@ -3358,8 +3356,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if ty.is_never() {\n             if let Some(hir::map::NodeExpr(_)) = self.tcx.map.find(expr.id) {\n                 let adj_ty = self.next_diverging_ty_var();\n-                let adj = adjustment::AdjustNeverToAny(adj_ty);\n-                self.write_adjustment(expr.id, adj);\n+                self.write_adjustment(expr.id, adjustment::Adjustment {\n+                    kind: adjustment::Adjust::NeverToAny,\n+                    target: adj_ty\n+                });\n                 return adj_ty;\n             }\n         }"}, {"sha": "6f6538254c46bae735d2f9884ef27083b94d85ae", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -259,23 +259,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.resolve_type(t)\n     }\n \n-    fn resolve_method_type(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n-        let method_ty = self.tables.borrow().method_map\n-                            .get(&method_call).map(|method| method.ty);\n-        method_ty.map(|method_ty| self.resolve_type(method_ty))\n-    }\n-\n     /// Try to resolve the type for the given node.\n     pub fn resolve_expr_type_adjusted(&mut self, expr: &hir::Expr) -> Ty<'tcx> {\n-        let ty_unadjusted = self.resolve_node_type(expr.id);\n-        if ty_unadjusted.references_error() {\n-            ty_unadjusted\n-        } else {\n-            ty_unadjusted.adjust(\n-                self.tcx, expr.span, expr.id,\n-                self.tables.borrow().adjustments.get(&expr.id),\n-                |method_call| self.resolve_method_type(method_call))\n-        }\n+        let ty = self.tables.borrow().expr_ty_adjusted(expr);\n+        self.resolve_type(ty)\n     }\n \n     fn visit_fn_body(&mut self,\n@@ -553,10 +540,8 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n         let adjustment = self.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n         if let Some(adjustment) = adjustment {\n             debug!(\"adjustment={:?}\", adjustment);\n-            match adjustment {\n-                adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n-                    autoderefs, ref autoref, ..\n-                }) => {\n+            match adjustment.kind {\n+                adjustment::Adjust::DerefRef { autoderefs, ref autoref, .. } => {\n                     let expr_ty = self.resolve_node_type(expr.id);\n                     self.constrain_autoderefs(expr, autoderefs, expr_ty);\n                     if let Some(ref autoref) = *autoref {\n@@ -946,7 +931,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     let origin = infer::ParameterOrigin::OverloadedDeref;\n                     self.substs_wf_in_scope(origin, method.substs, deref_expr.span, r_deref_expr);\n \n-                    // Treat overloaded autoderefs as if an AutoRef adjustment\n+                    // Treat overloaded autoderefs as if an AutoBorrow adjustment\n                     // was applied on the base type, as that is always the case.\n                     let fn_sig = method.ty.fn_sig();\n                     let fn_sig = // late-bound regions should have been instantiated\n@@ -1060,15 +1045,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         id: ast::NodeId,\n         minimum_lifetime: &'tcx ty::Region)\n     {\n-        let tcx = self.tcx;\n-\n         // Try to resolve the type.  If we encounter an error, then typeck\n         // is going to fail anyway, so just stop here and let typeck\n         // report errors later on in the writeback phase.\n         let ty0 = self.resolve_node_type(id);\n-        let ty = ty0.adjust(tcx, origin.span(), id,\n-                            self.tables.borrow().adjustments.get(&id),\n-                            |method_call| self.resolve_method_type(method_call));\n+        let ty = self.tables.borrow().adjustments.get(&id).map_or(ty0, |adj| adj.target);\n+        let ty = self.resolve_type(ty);\n         debug!(\"constrain_regions_in_type_of_node(\\\n                 ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n                 ty,  ty0,\n@@ -1165,20 +1147,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn link_autoref(&self,\n                     expr: &hir::Expr,\n                     autoderefs: usize,\n-                    autoref: &adjustment::AutoRef<'tcx>)\n+                    autoref: &adjustment::AutoBorrow<'tcx>)\n     {\n         debug!(\"link_autoref(autoref={:?})\", autoref);\n         let mc = mc::MemCategorizationContext::new(self);\n         let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n         debug!(\"expr_cmt={:?}\", expr_cmt);\n \n         match *autoref {\n-            adjustment::AutoPtr(r, m) => {\n+            adjustment::AutoBorrow::Ref(r, m) => {\n                 self.link_region(expr.span, r,\n                                  ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n \n-            adjustment::AutoUnsafe(m) => {\n+            adjustment::AutoBorrow::RawPtr(m) => {\n                 let r = self.tcx.node_scope_region(expr.id);\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }"}, {"sha": "be1f2e35679d71e7ab191c5130a8fff33b87678a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -416,7 +416,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     }\n                 }\n                 None => {\n-                    let self_ty = fcx.tcx.node_id_to_type(item.id);\n+                    let self_ty = fcx.tcx.tables().node_id_to_type(item.id);\n                     let self_ty = fcx.instantiate_type_scheme(item.span, free_substs, &self_ty);\n                     fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n                 }\n@@ -519,7 +519,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let ty = self.tcx().node_id_to_type(item.id);\n+        let ty = self.tcx().tables().node_id_to_type(item.id);\n         if self.tcx().has_error_field(ty) {\n             return;\n         }\n@@ -649,7 +649,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let fields =\n             struct_def.fields().iter()\n             .map(|field| {\n-                let field_ty = self.tcx.node_id_to_type(field.id);\n+                let field_ty = self.tcx.tables().node_id_to_type(field.id);\n                 let field_ty = self.instantiate_type_scheme(field.span,\n                                                             &self.parameter_environment\n                                                                  .free_substs,"}, {"sha": "5ef3e8699602b5437d93a813b7a04ce2addc8586", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -229,7 +229,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         debug!(\"Type for pattern binding {} (id {}) resolved to {:?}\",\n                pat_to_string(p),\n                p.id,\n-               self.tcx().node_id_to_type(p.id));\n+               self.tcx().tables().node_id_to_type(p.id));\n \n         intravisit::walk_pat(self, p);\n     }\n@@ -381,36 +381,40 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             }\n \n             Some(adjustment) => {\n-                let resolved_adjustment = match adjustment {\n-                    adjustment::AdjustNeverToAny(ty) => {\n-                        adjustment::AdjustNeverToAny(self.resolve(&ty, reason))\n+                let resolved_adjustment = match adjustment.kind {\n+                    adjustment::Adjust::NeverToAny => {\n+                        adjustment::Adjust::NeverToAny\n                     }\n \n-                    adjustment::AdjustReifyFnPointer => {\n-                        adjustment::AdjustReifyFnPointer\n+                    adjustment::Adjust::ReifyFnPointer => {\n+                        adjustment::Adjust::ReifyFnPointer\n                     }\n \n-                    adjustment::AdjustMutToConstPointer => {\n-                        adjustment::AdjustMutToConstPointer\n+                    adjustment::Adjust::MutToConstPointer => {\n+                        adjustment::Adjust::MutToConstPointer\n                     }\n \n-                    adjustment::AdjustUnsafeFnPointer => {\n-                        adjustment::AdjustUnsafeFnPointer\n+                    adjustment::Adjust::UnsafeFnPointer => {\n+                        adjustment::Adjust::UnsafeFnPointer\n                     }\n \n-                    adjustment::AdjustDerefRef(adj) => {\n-                        for autoderef in 0..adj.autoderefs {\n+                    adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n+                        for autoderef in 0..autoderefs {\n                             let method_call = MethodCall::autoderef(id, autoderef as u32);\n                             self.visit_method_map_entry(reason, method_call);\n                         }\n \n-                        adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n-                            autoderefs: adj.autoderefs,\n-                            autoref: self.resolve(&adj.autoref, reason),\n-                            unsize: self.resolve(&adj.unsize, reason),\n-                        })\n+                        adjustment::Adjust::DerefRef {\n+                            autoderefs: autoderefs,\n+                            autoref: self.resolve(&autoref, reason),\n+                            unsize: unsize,\n+                        }\n                     }\n                 };\n+                let resolved_adjustment = adjustment::Adjustment {\n+                    kind: resolved_adjustment,\n+                    target: self.resolve(&adjustment.target, reason)\n+                };\n                 debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n                 self.tcx().tables.borrow_mut().adjustments.insert(\n                     id, resolved_adjustment);"}, {"sha": "0e0f5cb1a7e156517fbb97a3954f70e606ec3879", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1724,16 +1724,15 @@ fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n     match unbound {\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n-            let trait_def_id = tcx.expect_def(tpb.ref_id).def_id();\n-            match kind_id {\n-                Ok(kind_id) if trait_def_id != kind_id => {\n+            if let Ok(kind_id) = kind_id {\n+                let trait_def = tcx.expect_def(tpb.ref_id);\n+                if trait_def != Def::Trait(kind_id) {\n                     tcx.sess.span_warn(span,\n                                        \"default bound relaxed for a type parameter, but \\\n                                        this does nothing because the given bound is not \\\n                                        a default. Only `?Sized` is supported\");\n                     tcx.try_add_builtin_trait(kind_id, bounds);\n                 }\n-                _ => {}\n             }\n         }\n         _ if kind_id.is_ok() => {"}, {"sha": "671274a4057c0190fa2a2e6c3c0124bb6fa3c72f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -211,7 +211,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_id: ast::NodeId,\n                     main_span: Span) {\n     let tcx = ccx.tcx;\n-    let main_t = tcx.node_id_to_type(main_id);\n+    let main_t = tcx.tables().node_id_to_type(main_id);\n     match main_t.sty {\n         ty::TyFnDef(..) => {\n             match tcx.map.find(main_id) {\n@@ -263,7 +263,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                      start_id: ast::NodeId,\n                      start_span: Span) {\n     let tcx = ccx.tcx;\n-    let start_t = tcx.node_id_to_type(start_id);\n+    let start_t = tcx.tables().node_id_to_type(start_id);\n     match start_t.sty {\n         ty::TyFnDef(..) => {\n             match tcx.map.find(start_id) {"}, {"sha": "795c89c0007472d09acd1a52a1e946efac5eb373", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -126,23 +126,28 @@ pub enum ErrorKind {\n     InvalidInput,\n     /// Data not valid for the operation were encountered.\n     ///\n-    /// Unlike `InvalidInput`, this typically means that the operation\n+    /// Unlike [`InvalidInput`], this typically means that the operation\n     /// parameters were valid, however the error was caused by malformed\n     /// input data.\n     ///\n     /// For example, a function that reads a file into a string will error with\n     /// `InvalidData` if the file's contents are not valid UTF-8.\n+    ///\n+    /// [`InvalidInput`]: #variant.InvalidInput\n     #[stable(feature = \"io_invalid_data\", since = \"1.2.0\")]\n     InvalidData,\n     /// The I/O operation's timeout expired, causing it to be canceled.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     TimedOut,\n     /// An error returned when an operation could not be completed because a\n-    /// call to `write` returned `Ok(0)`.\n+    /// call to [`write()`] returned [`Ok(0)`].\n     ///\n     /// This typically means that an operation could only succeed if it wrote a\n     /// particular number of bytes but only a smaller number of bytes could be\n     /// written.\n+    ///\n+    /// [`write()`]: ../../std/io/trait.Write.html#tymethod.write\n+    /// [`Ok(0)`]: ../../std/io/type.Result.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     WriteZero,\n     /// This operation was interrupted."}, {"sha": "bb6883236e8024b9aa3753f8ab1e2a7732db43a9", "filename": "src/libstd/path.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1173,6 +1173,13 @@ impl From<OsString> for PathBuf {\n     }\n }\n \n+#[stable(feature = \"from_path_buf_for_os_string\", since = \"1.14.0\")]\n+impl From<PathBuf> for OsString {\n+    fn from(path_buf : PathBuf) -> OsString {\n+        path_buf.inner\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<String> for PathBuf {\n     fn from(s: String) -> PathBuf {\n@@ -1283,13 +1290,6 @@ impl AsRef<OsStr> for PathBuf {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Into<OsString> for PathBuf {\n-    fn into(self) -> OsString {\n-        self.inner\n-    }\n-}\n-\n /// A slice of a path (akin to [`str`]).\n ///\n /// This type supports a number of operations for inspecting a path, including"}, {"sha": "9b1cf6ffd0e2200a4b395e45ffc3c5948e2ffe07", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -350,11 +350,19 @@ mod imp {\n \n     #[link(name = \"magenta\")]\n     extern {\n-        fn mx_cprng_draw(buffer: *mut u8, len: usize) -> isize;\n+        fn mx_cprng_draw(buffer: *mut u8, len: usize, actual: *mut usize) -> i32;\n     }\n \n-    fn getrandom(buf: &mut [u8]) -> isize {\n-        unsafe { mx_cprng_draw(buf.as_mut_ptr(), buf.len()) }\n+    fn getrandom(buf: &mut [u8]) -> Result<usize, i32> {\n+        unsafe {\n+            let mut actual = 0;\n+            let status = mx_cprng_draw(buf.as_mut_ptr(), buf.len(), &mut actual);\n+            if status == 0 {\n+                Ok(actual)\n+            } else {\n+                Err(status)\n+            }\n+        }\n     }\n \n     pub struct OsRng {\n@@ -381,12 +389,16 @@ mod imp {\n             let mut buf = v;\n             while !buf.is_empty() {\n                 let ret = getrandom(buf);\n-                if ret < 0 {\n-                    panic!(\"kernel mx_cprng_draw call failed! (returned {}, buf.len() {})\",\n-                        ret, buf.len());\n+                match ret {\n+                    Err(err) => {\n+                        panic!(\"kernel mx_cprng_draw call failed! (returned {}, buf.len() {})\",\n+                            err, buf.len())\n+                    }\n+                    Ok(actual) => {\n+                        let move_buf = buf;\n+                        buf = &mut move_buf[(actual as usize)..];\n+                    }\n                 }\n-                let move_buf = buf;\n-                buf = &mut move_buf[(ret as usize)..];\n             }\n         }\n     }"}, {"sha": "f7581924eb19fadb7770d73ef468420098ad767e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -1050,7 +1050,7 @@ pub enum ExprKind {\n     Ret(Option<P<Expr>>),\n \n     /// Output of the `asm!()` macro\n-    InlineAsm(InlineAsm),\n+    InlineAsm(P<InlineAsm>),\n \n     /// A macro invocation; pre-expansion\n     Mac(Mac),"}, {"sha": "1f47a91fcc13e8372dcd621a7a7bac50cc65ca35", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -615,7 +615,9 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree])\n         -> parser::Parser<'a> {\n-        parse::tts_to_parser(self.parse_sess, tts.to_vec())\n+        let mut parser = parse::tts_to_parser(self.parse_sess, tts.to_vec());\n+        parser.allow_interpolated_tts = false; // FIXME(jseyfried) `quote!` can't handle these yet\n+        parser\n     }\n     pub fn codemap(&self) -> &'a CodeMap { self.parse_sess.codemap() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }"}, {"sha": "969cfa292ce8068315fea22fd6d587851647264f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -80,67 +80,71 @@ pub mod rt {\n \n     impl ToTokens for ast::Path {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP,\n-                                  token::Interpolated(token::NtPath(Box::new(self.clone()))))]\n+            let nt = token::NtPath(self.clone());\n+            vec![TokenTree::Token(DUMMY_SP, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for ast::Ty {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(self.span, token::Interpolated(token::NtTy(P(self.clone()))))]\n+            let nt = token::NtTy(P(self.clone()));\n+            vec![TokenTree::Token(self.span, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for ast::Block {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(self.span, token::Interpolated(token::NtBlock(P(self.clone()))))]\n+            let nt = token::NtBlock(P(self.clone()));\n+            vec![TokenTree::Token(self.span, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for ast::Generics {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP, token::Interpolated(token::NtGenerics(self.clone())))]\n+            let nt = token::NtGenerics(self.clone());\n+            vec![TokenTree::Token(DUMMY_SP, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for ast::WhereClause {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP,\n-                                  token::Interpolated(token::NtWhereClause(self.clone())))]\n+            let nt = token::NtWhereClause(self.clone());\n+            vec![TokenTree::Token(DUMMY_SP, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for P<ast::Item> {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(self.span, token::Interpolated(token::NtItem(self.clone())))]\n+            let nt = token::NtItem(self.clone());\n+            vec![TokenTree::Token(self.span, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for ast::ImplItem {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(self.span,\n-                                  token::Interpolated(token::NtImplItem(P(self.clone()))))]\n+            let nt = token::NtImplItem(self.clone());\n+            vec![TokenTree::Token(self.span, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for P<ast::ImplItem> {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(self.span, token::Interpolated(token::NtImplItem(self.clone())))]\n+            let nt = token::NtImplItem((**self).clone());\n+            vec![TokenTree::Token(self.span, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for ast::TraitItem {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(self.span,\n-                                  token::Interpolated(token::NtTraitItem(P(self.clone()))))]\n+            let nt = token::NtTraitItem(self.clone());\n+            vec![TokenTree::Token(self.span, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for ast::Stmt {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let mut tts = vec![\n-                TokenTree::Token(self.span, token::Interpolated(token::NtStmt(P(self.clone()))))\n-            ];\n+            let nt = token::NtStmt(self.clone());\n+            let mut tts = vec![TokenTree::Token(self.span, token::Interpolated(Rc::new(nt)))];\n \n             // Some statements require a trailing semicolon.\n             if classify::stmt_ends_with_semi(&self.node) {\n@@ -153,31 +157,36 @@ pub mod rt {\n \n     impl ToTokens for P<ast::Expr> {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(self.span, token::Interpolated(token::NtExpr(self.clone())))]\n+            let nt = token::NtExpr(self.clone());\n+            vec![TokenTree::Token(self.span, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for P<ast::Pat> {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(self.span, token::Interpolated(token::NtPat(self.clone())))]\n+            let nt = token::NtPat(self.clone());\n+            vec![TokenTree::Token(self.span, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for ast::Arm {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP, token::Interpolated(token::NtArm(self.clone())))]\n+            let nt = token::NtArm(self.clone());\n+            vec![TokenTree::Token(DUMMY_SP, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for ast::Arg {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP, token::Interpolated(token::NtArg(self.clone())))]\n+            let nt = token::NtArg(self.clone());\n+            vec![TokenTree::Token(DUMMY_SP, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n     impl ToTokens for P<ast::Block> {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP, token::Interpolated(token::NtBlock(self.clone())))]\n+            let nt = token::NtBlock(self.clone());\n+            vec![TokenTree::Token(DUMMY_SP, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n \n@@ -204,7 +213,8 @@ pub mod rt {\n \n     impl ToTokens for P<ast::MetaItem> {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP, token::Interpolated(token::NtMeta(self.clone())))]\n+            let nt = token::NtMeta(self.clone());\n+            vec![TokenTree::Token(DUMMY_SP, token::Interpolated(Rc::new(nt)))]\n         }\n     }\n "}, {"sha": "1066646aa8e8a82a2c7830b6631502634e5d2401", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -89,7 +89,6 @@ use parse::token::{DocComment, MatchNt, SubstNt};\n use parse::token::{Token, Nonterminal};\n use parse::token;\n use print::pprust;\n-use ptr::P;\n use tokenstream::{self, TokenTree};\n use util::small_vector::SmallVector;\n \n@@ -198,7 +197,7 @@ pub fn initial_matcher_pos(ms: Vec<TokenTree>, sep: Option<Token>, lo: BytePos)\n \n pub enum NamedMatch {\n     MatchedSeq(Vec<Rc<NamedMatch>>, syntax_pos::Span),\n-    MatchedNonterminal(Nonterminal)\n+    MatchedNonterminal(Rc<Nonterminal>)\n }\n \n pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n@@ -279,17 +278,16 @@ pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n     }\n }\n \n-pub fn parse(sess: &ParseSess, mut rdr: TtReader, ms: &[TokenTree]) -> NamedParseResult {\n-    let mut cur_eis = SmallVector::one(initial_matcher_pos(ms.to_owned(),\n-                                                           None,\n-                                                           rdr.peek().sp.lo));\n+pub fn parse(sess: &ParseSess, rdr: TtReader, ms: &[TokenTree]) -> NamedParseResult {\n+    let mut parser = Parser::new_with_doc_flag(sess, Box::new(rdr), true);\n+    let mut cur_eis = SmallVector::one(initial_matcher_pos(ms.to_owned(), None, parser.span.lo));\n \n     loop {\n         let mut bb_eis = Vec::new(); // black-box parsed by parser.rs\n         let mut next_eis = Vec::new(); // or proceed normally\n         let mut eof_eis = Vec::new();\n \n-        let TokenAndSpan { tok, sp } = rdr.peek();\n+        let (sp, tok) = (parser.span, parser.token.clone());\n \n         /* we append new items to this while we go */\n         loop {\n@@ -474,23 +472,19 @@ pub fn parse(sess: &ParseSess, mut rdr: TtReader, ms: &[TokenTree]) -> NamedPars\n                 while !next_eis.is_empty() {\n                     cur_eis.push(next_eis.pop().unwrap());\n                 }\n-                rdr.next_token();\n+                parser.bump();\n             } else /* bb_eis.len() == 1 */ {\n-                rdr.next_tok = {\n-                    let mut rust_parser = Parser::new(sess, Box::new(&mut rdr));\n-                    let mut ei = bb_eis.pop().unwrap();\n-                    if let TokenTree::Token(span, MatchNt(_, ident)) = ei.top_elts.get_tt(ei.idx) {\n-                        let match_cur = ei.match_cur;\n-                        (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n-                            parse_nt(&mut rust_parser, span, &ident.name.as_str()))));\n-                        ei.idx += 1;\n-                        ei.match_cur += 1;\n-                    } else {\n-                        unreachable!()\n-                    }\n-                    cur_eis.push(ei);\n-                    Some(TokenAndSpan { tok: rust_parser.token, sp: rust_parser.span })\n-                };\n+                let mut ei = bb_eis.pop().unwrap();\n+                if let TokenTree::Token(span, MatchNt(_, ident)) = ei.top_elts.get_tt(ei.idx) {\n+                    let match_cur = ei.match_cur;\n+                    (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n+                        Rc::new(parse_nt(&mut parser, span, &ident.name.as_str())))));\n+                    ei.idx += 1;\n+                    ei.match_cur += 1;\n+                } else {\n+                    unreachable!()\n+                }\n+                cur_eis.push(ei);\n             }\n         }\n \n@@ -502,10 +496,19 @@ pub fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n     match name {\n         \"tt\" => {\n             p.quote_depth += 1; //but in theory, non-quoted tts might be useful\n-            let res: ::parse::PResult<'a, _> = p.parse_token_tree();\n-            let res = token::NtTT(P(panictry!(res)));\n+            let mut tt = panictry!(p.parse_token_tree());\n             p.quote_depth -= 1;\n-            return res;\n+            loop {\n+                let nt = match tt {\n+                    TokenTree::Token(_, token::Interpolated(ref nt)) => nt.clone(),\n+                    _ => break,\n+                };\n+                match *nt {\n+                    token::NtTT(ref sub_tt) => tt = sub_tt.clone(),\n+                    _ => break,\n+                }\n+            }\n+            return token::NtTT(tt);\n         }\n         _ => {}\n     }\n@@ -521,7 +524,7 @@ pub fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         },\n         \"block\" => token::NtBlock(panictry!(p.parse_block())),\n         \"stmt\" => match panictry!(p.parse_stmt()) {\n-            Some(s) => token::NtStmt(P(s)),\n+            Some(s) => token::NtStmt(s),\n             None => {\n                 p.fatal(\"expected a statement\").emit();\n                 panic!(FatalError);\n@@ -534,7 +537,7 @@ pub fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         \"ident\" => match p.token {\n             token::Ident(sn) => {\n                 p.bump();\n-                token::NtIdent(Box::new(Spanned::<Ident>{node: sn, span: p.span}))\n+                token::NtIdent(Spanned::<Ident>{node: sn, span: p.span})\n             }\n             _ => {\n                 let token_str = pprust::token_to_string(&p.token);\n@@ -544,7 +547,7 @@ pub fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n             }\n         },\n         \"path\" => {\n-            token::NtPath(Box::new(panictry!(p.parse_path(PathStyle::Type))))\n+            token::NtPath(panictry!(p.parse_path(PathStyle::Type)))\n         },\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n         // this is not supposed to happen, since it has been checked"}, {"sha": "552d4de961740f4c59b749b30ba9fde36719d75e", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -236,22 +236,28 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n     // Extract the arguments:\n     let lhses = match **argument_map.get(&lhs_nm).unwrap() {\n         MatchedSeq(ref s, _) => {\n-            s.iter().map(|m| match **m {\n-                MatchedNonterminal(NtTT(ref tt)) => {\n-                    valid &= check_lhs_nt_follows(sess, tt);\n-                    (**tt).clone()\n+            s.iter().map(|m| {\n+                if let MatchedNonterminal(ref nt) = **m {\n+                    if let NtTT(ref tt) = **nt {\n+                        valid &= check_lhs_nt_follows(sess, tt);\n+                        return (*tt).clone();\n+                    }\n                 }\n-                _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n+                sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n             }).collect::<Vec<TokenTree>>()\n         }\n         _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n     };\n \n     let rhses = match **argument_map.get(&rhs_nm).unwrap() {\n         MatchedSeq(ref s, _) => {\n-            s.iter().map(|m| match **m {\n-                MatchedNonterminal(NtTT(ref tt)) => (**tt).clone(),\n-                _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured rhs\")\n+            s.iter().map(|m| {\n+                if let MatchedNonterminal(ref nt) = **m {\n+                    if let NtTT(ref tt) = **nt {\n+                        return (*tt).clone();\n+                    }\n+                }\n+                sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n             }).collect()\n         }\n         _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured rhs\")"}, {"sha": "37e329e5d3b29fb581e7d3b77838da3acda067d5", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 11, "deletions": 54, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -12,9 +12,7 @@ use self::LockstepIterSize::*;\n use ast::Ident;\n use errors::{Handler, DiagnosticBuilder};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n-use parse::token::{DocComment, MatchNt, SubstNt};\n-use parse::token::{Token, Interpolated, NtIdent, NtTT};\n-use parse::token;\n+use parse::token::{self, MatchNt, SubstNt, Token, NtIdent};\n use parse::lexer::TokenAndSpan;\n use syntax_pos::{Span, DUMMY_SP};\n use tokenstream::{self, TokenTree};\n@@ -46,9 +44,7 @@ pub struct TtReader<'a> {\n     /* cached: */\n     pub cur_tok: Token,\n     pub cur_span: Span,\n-    pub next_tok: Option<TokenAndSpan>,\n     /// Transform doc comments. Only useful in macro invocations\n-    pub desugar_doc_comments: bool,\n     pub fatal_errs: Vec<DiagnosticBuilder<'a>>,\n }\n \n@@ -59,20 +55,6 @@ pub fn new_tt_reader(sp_diag: &Handler,\n                      interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n                      src: Vec<tokenstream::TokenTree>)\n                      -> TtReader {\n-    new_tt_reader_with_doc_flag(sp_diag, interp, src, false)\n-}\n-\n-/// The extra `desugar_doc_comments` flag enables reading doc comments\n-/// like any other attribute which consists of `meta` and surrounding #[ ] tokens.\n-///\n-/// This can do Macro-By-Example transcription. On the other hand, if\n-/// `src` contains no `TokenTree::Sequence`s, `MatchNt`s or `SubstNt`s, `interp` can\n-/// (and should) be None.\n-pub fn new_tt_reader_with_doc_flag(sp_diag: &Handler,\n-                                   interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n-                                   src: Vec<tokenstream::TokenTree>,\n-                                   desugar_doc_comments: bool)\n-                                   -> TtReader {\n     let mut r = TtReader {\n         sp_diag: sp_diag,\n         stack: SmallVector::one(TtFrame {\n@@ -91,11 +73,9 @@ pub fn new_tt_reader_with_doc_flag(sp_diag: &Handler,\n         },\n         repeat_idx: Vec::new(),\n         repeat_len: Vec::new(),\n-        desugar_doc_comments: desugar_doc_comments,\n         /* dummy values, never read: */\n         cur_tok: token::Eof,\n         cur_span: DUMMY_SP,\n-        next_tok: None,\n         fatal_errs: Vec::new(),\n     };\n     tt_next_token(&mut r); /* get cur_tok and cur_span set up */\n@@ -174,9 +154,6 @@ fn lockstep_iter_size(t: &TokenTree, r: &TtReader) -> LockstepIterSize {\n /// Return the next token from the TtReader.\n /// EFFECT: advances the reader's token field\n pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n-    if let Some(tok) = r.next_tok.take() {\n-        return tok;\n-    }\n     // FIXME(pcwalton): Bad copy?\n     let ret_val = TokenAndSpan {\n         tok: r.cur_tok.clone(),\n@@ -269,47 +246,35 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n             }\n             // FIXME #2887: think about span stuff here\n             TokenTree::Token(sp, SubstNt(ident)) => {\n+                r.stack.last_mut().unwrap().idx += 1;\n                 match lookup_cur_matched(r, ident) {\n                     None => {\n-                        r.stack.last_mut().unwrap().idx += 1;\n                         r.cur_span = sp;\n                         r.cur_tok = SubstNt(ident);\n                         return ret_val;\n                         // this can't be 0 length, just like TokenTree::Delimited\n                     }\n-                    Some(cur_matched) => {\n-                        match *cur_matched {\n+                    Some(cur_matched) => if let MatchedNonterminal(ref nt) = *cur_matched {\n+                        match **nt {\n                             // sidestep the interpolation tricks for ident because\n                             // (a) idents can be in lots of places, so it'd be a pain\n                             // (b) we actually can, since it's a token.\n-                            MatchedNonterminal(NtIdent(ref sn)) => {\n-                                r.stack.last_mut().unwrap().idx += 1;\n+                            NtIdent(ref sn) => {\n                                 r.cur_span = sn.span;\n                                 r.cur_tok = token::Ident(sn.node);\n                                 return ret_val;\n                             }\n-                            MatchedNonterminal(NtTT(ref tt)) => {\n-                                r.stack.push(TtFrame {\n-                                    forest: TokenTree::Token(sp, Interpolated(NtTT(tt.clone()))),\n-                                    idx: 0,\n-                                    dotdotdoted: false,\n-                                    sep: None,\n-                                });\n-                            }\n-                            MatchedNonterminal(ref other_whole_nt) => {\n-                                r.stack.last_mut().unwrap().idx += 1;\n+                            _ => {\n                                 // FIXME(pcwalton): Bad copy.\n                                 r.cur_span = sp;\n-                                r.cur_tok = Interpolated((*other_whole_nt).clone());\n+                                r.cur_tok = token::Interpolated(nt.clone());\n                                 return ret_val;\n                             }\n-                            MatchedSeq(..) => {\n-                                panic!(r.sp_diag.span_fatal(\n-                                    sp, /* blame the macro writer */\n-                                    &format!(\"variable '{}' is still repeating at this depth\",\n-                                            ident)));\n-                            }\n                         }\n+                    } else {\n+                        panic!(r.sp_diag.span_fatal(\n+                            sp, /* blame the macro writer */\n+                            &format!(\"variable '{}' is still repeating at this depth\", ident)));\n                     }\n                 }\n             }\n@@ -324,14 +289,6 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 });\n                 // if this could be 0-length, we'd need to potentially recur here\n             }\n-            TokenTree::Token(sp, DocComment(name)) if r.desugar_doc_comments => {\n-                r.stack.push(TtFrame {\n-                   forest: TokenTree::Token(sp, DocComment(name)),\n-                   idx: 0,\n-                   dotdotdoted: false,\n-                   sep: None\n-                });\n-            }\n             TokenTree::Token(sp, tok) => {\n                 r.cur_span = sp;\n                 r.cur_tok = tok;"}, {"sha": "ba16208715109e5dcc44a1e3159d1d1db991a5df", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -309,6 +309,12 @@ declare_features! (\n \n     // Allows field shorthands (`x` meaning `x: x`) in struct literal expressions.\n     (active, field_init_shorthand, \"1.14.0\", Some(37340)),\n+\n+    // The #![windows_subsystem] attribute\n+    (active, windows_subsystem, \"1.14.0\", Some(37499)),\n+\n+    // Allows using `Self` and associated types in struct expressions and patterns.\n+    (active, more_struct_aliases, \"1.14.0\", Some(37544)),\n );\n \n declare_features! (\n@@ -713,6 +719,12 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                               \"defining reflective traits is still evolving\",\n                                               cfg_fn!(reflect))),\n \n+    (\"windows_subsystem\", Whitelisted, Gated(Stability::Unstable,\n+                                             \"windows_subsystem\",\n+                                             \"the windows subsystem attribute \\\n+                                              is currently unstable\",\n+                                             cfg_fn!(windows_subsystem))),\n+\n     // Crate level attributes\n     (\"crate_name\", CrateLevel, Ungated),\n     (\"crate_type\", CrateLevel, Ungated),"}, {"sha": "1deeaf422316c29391b7dd63f8d0b6ebd9d8f817", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 34, "deletions": 43, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -576,7 +576,13 @@ pub fn noop_fold_token<T: Folder>(t: token::Token, fld: &mut T) -> token::Token\n     match t {\n         token::Ident(id) => token::Ident(fld.fold_ident(id)),\n         token::Lifetime(id) => token::Lifetime(fld.fold_ident(id)),\n-        token::Interpolated(nt) => token::Interpolated(fld.fold_interpolated(nt)),\n+        token::Interpolated(nt) => {\n+            let nt = match Rc::try_unwrap(nt) {\n+                Ok(nt) => nt,\n+                Err(nt) => (*nt).clone(),\n+            };\n+            token::Interpolated(Rc::new(fld.fold_interpolated(nt)))\n+        }\n         token::SubstNt(ident) => token::SubstNt(fld.fold_ident(ident)),\n         token::MatchNt(name, kind) => token::MatchNt(fld.fold_ident(name), fld.fold_ident(kind)),\n         _ => t\n@@ -614,26 +620,25 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n                           .expect_one(\"expected fold to produce exactly one item\")),\n         token::NtBlock(block) => token::NtBlock(fld.fold_block(block)),\n         token::NtStmt(stmt) =>\n-            token::NtStmt(stmt.map(|stmt| fld.fold_stmt(stmt)\n+            token::NtStmt(fld.fold_stmt(stmt)\n                           // this is probably okay, because the only folds likely\n                           // to peek inside interpolated nodes will be renamings/markings,\n                           // which map single items to single items\n-                          .expect_one(\"expected fold to produce exactly one statement\"))),\n+                          .expect_one(\"expected fold to produce exactly one statement\")),\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n-        token::NtIdent(id) =>\n-            token::NtIdent(Box::new(Spanned::<Ident>{node: fld.fold_ident(id.node), ..*id})),\n+        token::NtIdent(id) => token::NtIdent(Spanned::<Ident>{node: fld.fold_ident(id.node), ..id}),\n         token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n-        token::NtPath(path) => token::NtPath(Box::new(fld.fold_path(*path))),\n-        token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&tt))),\n+        token::NtPath(path) => token::NtPath(fld.fold_path(path)),\n+        token::NtTT(tt) => token::NtTT(fld.fold_tt(&tt)),\n         token::NtArm(arm) => token::NtArm(fld.fold_arm(arm)),\n-        token::NtImplItem(arm) =>\n-            token::NtImplItem(arm.map(|arm| fld.fold_impl_item(arm)\n-                              .expect_one(\"expected fold to produce exactly one item\"))),\n-        token::NtTraitItem(arm) =>\n-            token::NtTraitItem(arm.map(|arm| fld.fold_trait_item(arm)\n-                               .expect_one(\"expected fold to produce exactly one item\"))),\n+        token::NtImplItem(item) =>\n+            token::NtImplItem(fld.fold_impl_item(item)\n+                              .expect_one(\"expected fold to produce exactly one item\")),\n+        token::NtTraitItem(item) =>\n+            token::NtTraitItem(fld.fold_trait_item(item)\n+                               .expect_one(\"expected fold to produce exactly one item\")),\n         token::NtGenerics(generics) => token::NtGenerics(fld.fold_generics(generics)),\n         token::NtWhereClause(where_clause) =>\n             token::NtWhereClause(fld.fold_where_clause(where_clause)),\n@@ -1244,36 +1249,22 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                        folder.fold_ident(label.node)))\n             ),\n             ExprKind::Ret(e) => ExprKind::Ret(e.map(|x| folder.fold_expr(x))),\n-            ExprKind::InlineAsm(InlineAsm {\n-                inputs,\n-                outputs,\n-                asm,\n-                asm_str_style,\n-                clobbers,\n-                volatile,\n-                alignstack,\n-                dialect,\n-                expn_id,\n-            }) => ExprKind::InlineAsm(InlineAsm {\n-                inputs: inputs.move_map(|(c, input)| {\n-                    (c, folder.fold_expr(input))\n-                }),\n-                outputs: outputs.move_map(|out| {\n-                    InlineAsmOutput {\n-                        constraint: out.constraint,\n-                        expr: folder.fold_expr(out.expr),\n-                        is_rw: out.is_rw,\n-                        is_indirect: out.is_indirect,\n-                    }\n-                }),\n-                asm: asm,\n-                asm_str_style: asm_str_style,\n-                clobbers: clobbers,\n-                volatile: volatile,\n-                alignstack: alignstack,\n-                dialect: dialect,\n-                expn_id: expn_id,\n-            }),\n+            ExprKind::InlineAsm(asm) => ExprKind::InlineAsm(asm.map(|asm| {\n+                InlineAsm {\n+                    inputs: asm.inputs.move_map(|(c, input)| {\n+                        (c, folder.fold_expr(input))\n+                    }),\n+                    outputs: asm.outputs.move_map(|out| {\n+                        InlineAsmOutput {\n+                            constraint: out.constraint,\n+                            expr: folder.fold_expr(out.expr),\n+                            is_rw: out.is_rw,\n+                            is_indirect: out.is_indirect,\n+                        }\n+                    }),\n+                    ..asm\n+                }\n+            })),\n             ExprKind::Mac(mac) => ExprKind::Mac(folder.fold_mac(mac)),\n             ExprKind::Struct(path, fields, maybe_expr) => {\n                 ExprKind::Struct(folder.fold_path(path),"}, {"sha": "983c882eafca31298542d0a2a53ee7d44eca1dd8", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -215,7 +215,10 @@ impl<'a> Parser<'a> {\n     /// meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n     pub fn parse_meta_item(&mut self) -> PResult<'a, P<ast::MetaItem>> {\n         let nt_meta = match self.token {\n-            token::Interpolated(token::NtMeta(ref e)) => Some(e.clone()),\n+            token::Interpolated(ref nt) => match **nt {\n+                token::NtMeta(ref e) => Some(e.clone()),\n+                _ => None,\n+            },\n             _ => None,\n         };\n "}, {"sha": "cf48c445c80ebf24f2be8bb15467ecba278aab70", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -22,7 +22,7 @@ use std::char;\n use std::mem::replace;\n use std::rc::Rc;\n \n-pub use ext::tt::transcribe::{TtReader, new_tt_reader, new_tt_reader_with_doc_flag};\n+pub use ext::tt::transcribe::{TtReader, new_tt_reader};\n \n pub mod comments;\n mod unicode_chars;\n@@ -171,31 +171,10 @@ impl<'a> Reader for TtReader<'a> {\n         self.fatal_errs.clear();\n     }\n     fn peek(&self) -> TokenAndSpan {\n-        self.next_tok.clone().unwrap_or(TokenAndSpan {\n+        TokenAndSpan {\n             tok: self.cur_tok.clone(),\n             sp: self.cur_span,\n-        })\n-    }\n-}\n-\n-impl<'a, 'b> Reader for &'b mut TtReader<'a> {\n-    fn is_eof(&self) -> bool {\n-        (**self).is_eof()\n-    }\n-    fn try_next_token(&mut self) -> Result<TokenAndSpan, ()> {\n-        (**self).try_next_token()\n-    }\n-    fn fatal(&self, m: &str) -> FatalError {\n-        (**self).fatal(m)\n-    }\n-    fn err(&self, m: &str) {\n-        (**self).err(m)\n-    }\n-    fn emit_fatal_errors(&mut self) {\n-        (**self).emit_fatal_errors()\n-    }\n-    fn peek(&self) -> TokenAndSpan {\n-        (**self).peek()\n+        }\n     }\n }\n "}, {"sha": "b670a7384739bd30373abff886253c8888520f7b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 134, "deletions": 181, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -107,125 +107,41 @@ pub enum SemiColonMode {\n /// be. The important thing is to make sure that lookahead doesn't balk at\n /// `token::Interpolated` tokens.\n macro_rules! maybe_whole_expr {\n-    ($p:expr) => (\n-        {\n-            let found = match $p.token {\n-                token::Interpolated(token::NtExpr(ref e)) => {\n-                    Some((*e).clone())\n+    ($p:expr) => {\n+        if let token::Interpolated(nt) = $p.token.clone() {\n+            match *nt {\n+                token::NtExpr(ref e) => {\n+                    $p.bump();\n+                    return Ok((*e).clone());\n                 }\n-                token::Interpolated(token::NtPath(_)) => {\n-                    // FIXME: The following avoids an issue with lexical borrowck scopes,\n-                    // but the clone is unfortunate.\n-                    let pt = match $p.token {\n-                        token::Interpolated(token::NtPath(ref pt)) => (**pt).clone(),\n-                        _ => unreachable!()\n-                    };\n+                token::NtPath(ref path) => {\n+                    $p.bump();\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Path(None, pt), ThinVec::new()))\n+                    let kind = ExprKind::Path(None, (*path).clone());\n+                    return Ok($p.mk_expr(span.lo, span.hi, kind, ThinVec::new()));\n                 }\n-                token::Interpolated(token::NtBlock(_)) => {\n-                    // FIXME: The following avoids an issue with lexical borrowck scopes,\n-                    // but the clone is unfortunate.\n-                    let b = match $p.token {\n-                        token::Interpolated(token::NtBlock(ref b)) => (*b).clone(),\n-                        _ => unreachable!()\n-                    };\n+                token::NtBlock(ref block) => {\n+                    $p.bump();\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Block(b), ThinVec::new()))\n+                    let kind = ExprKind::Block((*block).clone());\n+                    return Ok($p.mk_expr(span.lo, span.hi, kind, ThinVec::new()));\n                 }\n-                _ => None\n+                _ => {},\n             };\n-            match found {\n-                Some(e) => {\n-                    $p.bump();\n-                    return Ok(e);\n-                }\n-                None => ()\n-            }\n         }\n-    )\n+    }\n }\n \n /// As maybe_whole_expr, but for things other than expressions\n macro_rules! maybe_whole {\n-    ($p:expr, $constructor:ident) => (\n-        {\n-            let found = match ($p).token {\n-                token::Interpolated(token::$constructor(_)) => {\n-                    Some(($p).bump_and_get())\n-                }\n-                _ => None\n-            };\n-            if let Some(token::Interpolated(token::$constructor(x))) = found {\n-                return Ok(x.clone());\n+    ($p:expr, $constructor:ident, |$x:ident| $e:expr) => {\n+        if let token::Interpolated(nt) = $p.token.clone() {\n+            if let token::$constructor($x) = (*nt).clone() {\n+                $p.bump();\n+                return Ok($e);\n             }\n         }\n-    );\n-    (no_clone $p:expr, $constructor:ident) => (\n-        {\n-            let found = match ($p).token {\n-                token::Interpolated(token::$constructor(_)) => {\n-                    Some(($p).bump_and_get())\n-                }\n-                _ => None\n-            };\n-            if let Some(token::Interpolated(token::$constructor(x))) = found {\n-                return Ok(x);\n-            }\n-        }\n-    );\n-    (no_clone_from_p $p:expr, $constructor:ident) => (\n-        {\n-            let found = match ($p).token {\n-                token::Interpolated(token::$constructor(_)) => {\n-                    Some(($p).bump_and_get())\n-                }\n-                _ => None\n-            };\n-            if let Some(token::Interpolated(token::$constructor(x))) = found {\n-                return Ok(x.unwrap());\n-            }\n-        }\n-    );\n-    (deref $p:expr, $constructor:ident) => (\n-        {\n-            let found = match ($p).token {\n-                token::Interpolated(token::$constructor(_)) => {\n-                    Some(($p).bump_and_get())\n-                }\n-                _ => None\n-            };\n-            if let Some(token::Interpolated(token::$constructor(x))) = found {\n-                return Ok((*x).clone());\n-            }\n-        }\n-    );\n-    (Some deref $p:expr, $constructor:ident) => (\n-        {\n-            let found = match ($p).token {\n-                token::Interpolated(token::$constructor(_)) => {\n-                    Some(($p).bump_and_get())\n-                }\n-                _ => None\n-            };\n-            if let Some(token::Interpolated(token::$constructor(x))) = found {\n-                return Ok(Some((*x).clone()));\n-            }\n-        }\n-    );\n-    (pair_empty $p:expr, $constructor:ident) => (\n-        {\n-            let found = match ($p).token {\n-                token::Interpolated(token::$constructor(_)) => {\n-                    Some(($p).bump_and_get())\n-                }\n-                _ => None\n-            };\n-            if let Some(token::Interpolated(token::$constructor(x))) = found {\n-                return Ok((Vec::new(), x));\n-            }\n-        }\n-    )\n+    };\n }\n \n fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n@@ -294,6 +210,9 @@ pub struct Parser<'a> {\n     /// into modules, and sub-parsers have new values for this name.\n     pub root_module_name: Option<String>,\n     pub expected_tokens: Vec<TokenType>,\n+    pub tts: Vec<(TokenTree, usize)>,\n+    pub desugar_doc_comments: bool,\n+    pub allow_interpolated_tts: bool,\n }\n \n #[derive(PartialEq, Eq, Clone)]\n@@ -357,33 +276,82 @@ impl From<P<Expr>> for LhsExpr {\n }\n \n impl<'a> Parser<'a> {\n-    pub fn new(sess: &'a ParseSess, mut rdr: Box<Reader+'a>) -> Self {\n-        let tok0 = rdr.real_token();\n-        let span = tok0.sp;\n-        let mut directory = match span {\n-            syntax_pos::DUMMY_SP => PathBuf::new(),\n-            _ => PathBuf::from(sess.codemap().span_to_filename(span)),\n-        };\n-        directory.pop();\n+    pub fn new(sess: &'a ParseSess, rdr: Box<Reader+'a>) -> Self {\n+        Parser::new_with_doc_flag(sess, rdr, false)\n+    }\n \n-        Parser {\n+    pub fn new_with_doc_flag(sess: &'a ParseSess, rdr: Box<Reader+'a>, desugar_doc_comments: bool)\n+                             -> Self {\n+        let mut parser = Parser {\n             reader: rdr,\n             sess: sess,\n-            token: tok0.tok,\n-            span: span,\n-            prev_span: span,\n+            token: token::Underscore,\n+            span: syntax_pos::DUMMY_SP,\n+            prev_span: syntax_pos::DUMMY_SP,\n             prev_token_kind: PrevTokenKind::Other,\n             lookahead_buffer: Default::default(),\n             tokens_consumed: 0,\n             restrictions: Restrictions::empty(),\n             quote_depth: 0,\n             parsing_token_tree: false,\n             obsolete_set: HashSet::new(),\n-            directory: directory,\n+            directory: PathBuf::new(),\n             open_braces: Vec::new(),\n             owns_directory: true,\n             root_module_name: None,\n             expected_tokens: Vec::new(),\n+            tts: Vec::new(),\n+            desugar_doc_comments: desugar_doc_comments,\n+            allow_interpolated_tts: true,\n+        };\n+\n+        let tok = parser.next_tok();\n+        parser.token = tok.tok;\n+        parser.span = tok.sp;\n+        if parser.span != syntax_pos::DUMMY_SP {\n+            parser.directory = PathBuf::from(sess.codemap().span_to_filename(parser.span));\n+            parser.directory.pop();\n+        }\n+        parser\n+    }\n+\n+    fn next_tok(&mut self) -> TokenAndSpan {\n+        'outer: loop {\n+            let mut tok = if let Some((tts, i)) = self.tts.pop() {\n+                let tt = tts.get_tt(i);\n+                if i + 1 < tts.len() {\n+                    self.tts.push((tts, i + 1));\n+                }\n+                if let TokenTree::Token(sp, tok) = tt {\n+                    TokenAndSpan { tok: tok, sp: sp }\n+                } else {\n+                    self.tts.push((tt, 0));\n+                    continue\n+                }\n+            } else {\n+                self.reader.real_token()\n+            };\n+\n+            loop {\n+                let nt = match tok.tok {\n+                    token::Interpolated(ref nt) => nt.clone(),\n+                    token::DocComment(name) if self.desugar_doc_comments => {\n+                        self.tts.push((TokenTree::Token(tok.sp, token::DocComment(name)), 0));\n+                        continue 'outer\n+                    }\n+                    _ => return tok,\n+                };\n+                match *nt {\n+                    token::NtTT(TokenTree::Token(sp, ref t)) => {\n+                        tok = TokenAndSpan { tok: t.clone(), sp: sp };\n+                    }\n+                    token::NtTT(ref tt) => {\n+                        self.tts.push((tt.clone(), 0));\n+                        continue 'outer\n+                    }\n+                    _ => return tok,\n+                }\n+            }\n         }\n     }\n \n@@ -516,9 +484,6 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 Ok(i)\n             }\n-            token::Interpolated(token::NtIdent(..)) => {\n-                self.bug(\"ident interpolation not converted to real token\");\n-            }\n             _ => {\n                 Err(if self.prev_token_kind == PrevTokenKind::DocComment {\n                     self.span_fatal_help(self.prev_span,\n@@ -935,7 +900,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let next = if self.lookahead_buffer.start == self.lookahead_buffer.end {\n-            self.reader.real_token()\n+            self.next_tok()\n         } else {\n             // Avoid token copies with `replace`.\n             let old_start = self.lookahead_buffer.start;\n@@ -980,7 +945,7 @@ impl<'a> Parser<'a> {\n             f(&self.token)\n         } else if dist < LOOKAHEAD_BUFFER_CAPACITY {\n             while self.lookahead_buffer.len() < dist {\n-                self.lookahead_buffer.buffer[self.lookahead_buffer.end] = self.reader.real_token();\n+                self.lookahead_buffer.buffer[self.lookahead_buffer.end] = self.next_tok();\n                 self.lookahead_buffer.end =\n                     (self.lookahead_buffer.end + 1) % LOOKAHEAD_BUFFER_CAPACITY;\n             }\n@@ -1162,7 +1127,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse the items in a trait declaration\n     pub fn parse_trait_item(&mut self) -> PResult<'a, TraitItem> {\n-        maybe_whole!(no_clone_from_p self, NtTraitItem);\n+        maybe_whole!(self, NtTraitItem, |x| x);\n         let mut attrs = self.parse_outer_attributes()?;\n         let lo = self.span.lo;\n \n@@ -1331,7 +1296,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a type.\n     pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n-        maybe_whole!(no_clone self, NtTy);\n+        maybe_whole!(self, NtTy, |x| x);\n \n         let lo = self.span.lo;\n \n@@ -1476,7 +1441,7 @@ impl<'a> Parser<'a> {\n     /// This version of parse arg doesn't necessarily require\n     /// identifier names.\n     pub fn parse_arg_general(&mut self, require_name: bool) -> PResult<'a, Arg> {\n-        maybe_whole!(no_clone self, NtArg);\n+        maybe_whole!(self, NtArg, |x| x);\n \n         let pat = if require_name || self.is_named_argument() {\n             debug!(\"parse_arg_general parse_pat (require_name:{})\",\n@@ -1542,12 +1507,13 @@ impl<'a> Parser<'a> {\n     /// Matches token_lit = LIT_INTEGER | ...\n     pub fn parse_lit_token(&mut self) -> PResult<'a, LitKind> {\n         let out = match self.token {\n-            token::Interpolated(token::NtExpr(ref v)) => {\n-                match v.node {\n+            token::Interpolated(ref nt) => match **nt {\n+                token::NtExpr(ref v) => match v.node {\n                     ExprKind::Lit(ref lit) => { lit.node.clone() }\n                     _ => { return self.unexpected_last(&self.token); }\n-                }\n-            }\n+                },\n+                _ => { return self.unexpected_last(&self.token); }\n+            },\n             token::Literal(lit, suf) => {\n                 let (suffix_illegal, out) = match lit {\n                     token::Byte(i) => (true, LitKind::Byte(parse::byte_lit(&i.as_str()).0)),\n@@ -1703,14 +1669,7 @@ impl<'a> Parser<'a> {\n     /// bounds are permitted and whether `::` must precede type parameter\n     /// groups.\n     pub fn parse_path(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n-        // Check for a whole path...\n-        let found = match self.token {\n-            token::Interpolated(token::NtPath(_)) => Some(self.bump_and_get()),\n-            _ => None,\n-        };\n-        if let Some(token::Interpolated(token::NtPath(path))) = found {\n-            return Ok(*path);\n-        }\n+        maybe_whole!(self, NtPath, |x| x);\n \n         let lo = self.span.lo;\n         let is_global = self.eat(&token::ModSep);\n@@ -2746,8 +2705,6 @@ impl<'a> Parser<'a> {\n         // and token::SubstNt's; it's too early to know yet\n         // whether something will be a nonterminal or a seq\n         // yet.\n-        maybe_whole!(deref self, NtTT);\n-\n         match self.token {\n             token::Eof => {\n                 let mut err: DiagnosticBuilder<'a> =\n@@ -2760,6 +2717,17 @@ impl<'a> Parser<'a> {\n                 Err(err)\n             },\n             token::OpenDelim(delim) => {\n+                if self.tts.last().map(|&(_, i)| i == 1).unwrap_or(false) {\n+                    let tt = self.tts.pop().unwrap().0;\n+                    self.bump();\n+                    return Ok(if self.allow_interpolated_tts {\n+                        // avoid needlessly reparsing token trees in recursive macro expansions\n+                        TokenTree::Token(tt.span(), token::Interpolated(Rc::new(token::NtTT(tt))))\n+                    } else {\n+                        tt\n+                    });\n+                }\n+\n                 let parsing_token_tree = ::std::mem::replace(&mut self.parsing_token_tree, true);\n                 // The span for beginning of the delimited section\n                 let pre_span = self.span;\n@@ -2833,29 +2801,20 @@ impl<'a> Parser<'a> {\n                     close_span: close_span,\n                 })))\n             },\n+            token::CloseDelim(_) => {\n+                // An unexpected closing delimiter (i.e., there is no\n+                // matching opening delimiter).\n+                let token_str = self.this_token_to_string();\n+                let err = self.diagnostic().struct_span_err(self.span,\n+                    &format!(\"unexpected close delimiter: `{}`\", token_str));\n+                Err(err)\n+            },\n+            /* we ought to allow different depths of unquotation */\n+            token::Dollar | token::SubstNt(..) if self.quote_depth > 0 => {\n+                self.parse_unquoted()\n+            }\n             _ => {\n-                // invariants: the current token is not a left-delimiter,\n-                // not an EOF, and not the desired right-delimiter (if\n-                // it were, parse_seq_to_before_end would have prevented\n-                // reaching this point).\n-                maybe_whole!(deref self, NtTT);\n-                match self.token {\n-                    token::CloseDelim(_) => {\n-                        // An unexpected closing delimiter (i.e., there is no\n-                        // matching opening delimiter).\n-                        let token_str = self.this_token_to_string();\n-                        let err = self.diagnostic().struct_span_err(self.span,\n-                            &format!(\"unexpected close delimiter: `{}`\", token_str));\n-                        Err(err)\n-                    },\n-                    /* we ought to allow different depths of unquotation */\n-                    token::Dollar | token::SubstNt(..) if self.quote_depth > 0 => {\n-                        self.parse_unquoted()\n-                    }\n-                    _ => {\n-                        Ok(TokenTree::Token(self.span, self.bump_and_get()))\n-                    }\n-                }\n+                Ok(TokenTree::Token(self.span, self.bump_and_get()))\n             }\n         }\n     }\n@@ -3336,7 +3295,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_arm(&mut self) -> PResult<'a, Arm> {\n-        maybe_whole!(no_clone self, NtArm);\n+        maybe_whole!(self, NtArm, |x| x);\n \n         let attrs = self.parse_outer_attributes()?;\n         let pats = self.parse_pats()?;\n@@ -3592,7 +3551,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a pattern.\n     pub fn parse_pat(&mut self) -> PResult<'a, P<Pat>> {\n-        maybe_whole!(self, NtPat);\n+        maybe_whole!(self, NtPat, |x| x);\n \n         let lo = self.span.lo;\n         let pat;\n@@ -3897,7 +3856,7 @@ impl<'a> Parser<'a> {\n     fn parse_stmt_without_recovery(&mut self,\n                                    macro_legacy_warnings: bool)\n                                    -> PResult<'a, Option<Stmt>> {\n-        maybe_whole!(Some deref self, NtStmt);\n+        maybe_whole!(self, NtStmt, |x| Some(x));\n \n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.span.lo;\n@@ -4086,7 +4045,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a block. No inner attrs are allowed.\n     pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n-        maybe_whole!(no_clone self, NtBlock);\n+        maybe_whole!(self, NtBlock, |x| x);\n \n         let lo = self.span.lo;\n \n@@ -4124,7 +4083,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a block. Inner attrs are allowed.\n     fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n-        maybe_whole!(pair_empty self, NtBlock);\n+        maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n \n         let lo = self.span.lo;\n         self.expect(&token::OpenDelim(token::Brace))?;\n@@ -4299,7 +4258,7 @@ impl<'a> Parser<'a> {\n     ///                  | ( < lifetimes , typaramseq ( , )? > )\n     /// where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n     pub fn parse_generics(&mut self) -> PResult<'a, ast::Generics> {\n-        maybe_whole!(self, NtGenerics);\n+        maybe_whole!(self, NtGenerics, |x| x);\n         let span_lo = self.span.lo;\n \n         if self.eat(&token::Lt) {\n@@ -4440,7 +4399,7 @@ impl<'a> Parser<'a> {\n     /// where T : Trait<U, V> + 'b, 'a : 'b\n     /// ```\n     pub fn parse_where_clause(&mut self) -> PResult<'a, ast::WhereClause> {\n-        maybe_whole!(self, NtWhereClause);\n+        maybe_whole!(self, NtWhereClause, |x| x);\n \n         let mut where_clause = WhereClause {\n             id: ast::DUMMY_NODE_ID,\n@@ -4848,7 +4807,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an impl item.\n     pub fn parse_impl_item(&mut self) -> PResult<'a, ImplItem> {\n-        maybe_whole!(no_clone_from_p self, NtImplItem);\n+        maybe_whole!(self, NtImplItem, |x| x);\n \n         let mut attrs = self.parse_outer_attributes()?;\n         let lo = self.span.lo;\n@@ -5716,19 +5675,13 @@ impl<'a> Parser<'a> {\n     /// extern crate.\n     fn parse_item_(&mut self, attrs: Vec<Attribute>,\n                    macros_allowed: bool, attributes_allowed: bool) -> PResult<'a, Option<P<Item>>> {\n-        let nt_item = match self.token {\n-            token::Interpolated(token::NtItem(ref item)) => {\n-                Some((**item).clone())\n-            }\n-            _ => None\n-        };\n-        if let Some(mut item) = nt_item {\n-            self.bump();\n+        maybe_whole!(self, NtItem, |item| {\n+            let mut item = item.unwrap();\n             let mut attrs = attrs;\n             mem::swap(&mut item.attrs, &mut attrs);\n             item.attrs.extend(attrs);\n-            return Ok(Some(P(item)));\n-        }\n+            Some(P(item))\n+        });\n \n         let lo = self.span.lo;\n "}, {"sha": "0198ee073d23982c3534787ab2c950fa2a44076e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -123,7 +123,7 @@ pub enum Token {\n     Lifetime(ast::Ident),\n \n     /* For interpolation */\n-    Interpolated(Nonterminal),\n+    Interpolated(Rc<Nonterminal>),\n     // Can be expanded into several tokens.\n     /// Doc comment\n     DocComment(ast::Name),\n@@ -172,12 +172,15 @@ impl Token {\n             DotDot | DotDotDot          => true, // range notation\n             Lt | BinOp(Shl)             => true, // associated path\n             ModSep                      => true,\n-            Interpolated(NtExpr(..))    => true,\n-            Interpolated(NtIdent(..))   => true,\n-            Interpolated(NtBlock(..))   => true,\n-            Interpolated(NtPath(..))    => true,\n             Pound                       => true, // for expression attributes\n-            _                           => false,\n+            Interpolated(ref nt) => match **nt {\n+                NtExpr(..) => true,\n+                NtIdent(..) => true,\n+                NtBlock(..) => true,\n+                NtPath(..) => true,\n+                _ => false,\n+            },\n+            _ => false,\n         }\n     }\n \n@@ -215,10 +218,12 @@ impl Token {\n \n     /// Returns `true` if the token is an interpolated path.\n     pub fn is_path(&self) -> bool {\n-        match *self {\n-            Interpolated(NtPath(..))    => true,\n-            _                           => false,\n+        if let Interpolated(ref nt) = *self {\n+            if let NtPath(..) = **nt {\n+                return true;\n+            }\n         }\n+        false\n     }\n \n     /// Returns `true` if the token is a lifetime.\n@@ -290,19 +295,19 @@ impl Token {\n pub enum Nonterminal {\n     NtItem(P<ast::Item>),\n     NtBlock(P<ast::Block>),\n-    NtStmt(P<ast::Stmt>),\n+    NtStmt(ast::Stmt),\n     NtPat(P<ast::Pat>),\n     NtExpr(P<ast::Expr>),\n     NtTy(P<ast::Ty>),\n-    NtIdent(Box<ast::SpannedIdent>),\n+    NtIdent(ast::SpannedIdent),\n     /// Stuff inside brackets for attributes\n     NtMeta(P<ast::MetaItem>),\n-    NtPath(Box<ast::Path>),\n-    NtTT(P<tokenstream::TokenTree>), // needs P'ed to break a circularity\n+    NtPath(ast::Path),\n+    NtTT(tokenstream::TokenTree),\n     // These are not exposed to macros, but are used by quasiquote.\n     NtArm(ast::Arm),\n-    NtImplItem(P<ast::ImplItem>),\n-    NtTraitItem(P<ast::TraitItem>),\n+    NtImplItem(ast::ImplItem),\n+    NtTraitItem(ast::TraitItem),\n     NtGenerics(ast::Generics),\n     NtWhereClause(ast::WhereClause),\n     NtArg(ast::Arg),"}, {"sha": "7352792a8a25253ec950d07722089a53c2b4232b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -285,7 +285,7 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Comment              => \"/* */\".to_string(),\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s),\n \n-        token::Interpolated(ref nt) => match *nt {\n+        token::Interpolated(ref nt) => match **nt {\n             token::NtExpr(ref e)        => expr_to_string(&e),\n             token::NtMeta(ref e)        => meta_item_to_string(&e),\n             token::NtTy(ref e)          => ty_to_string(&e),"}, {"sha": "9ef6c07e489dce7de227d349cbeef5b313358422", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -134,8 +134,10 @@ impl TokenTree {\n                     AttrStyle::Inner => 3,\n                 }\n             }\n+            TokenTree::Token(_, token::Interpolated(ref nt)) => {\n+                if let Nonterminal::NtTT(..) = **nt { 1 } else { 0 }\n+            },\n             TokenTree::Token(_, token::MatchNt(..)) => 3,\n-            TokenTree::Token(_, token::Interpolated(Nonterminal::NtTT(..))) => 1,\n             TokenTree::Delimited(_, ref delimed) => delimed.tts.len() + 2,\n             TokenTree::Sequence(_, ref seq) => seq.tts.len(),\n             TokenTree::Token(..) => 0,\n@@ -193,9 +195,6 @@ impl TokenTree {\n                          TokenTree::Token(sp, token::Ident(kind))];\n                 v[index].clone()\n             }\n-            (&TokenTree::Token(_, token::Interpolated(Nonterminal::NtTT(ref tt))), _) => {\n-                tt.clone().unwrap()\n-            }\n             (&TokenTree::Sequence(_, ref seq), _) => seq.tts[index].clone(),\n             _ => panic!(\"Cannot expand a token tree\"),\n         }\n@@ -215,11 +214,9 @@ impl TokenTree {\n                  mtch: &[TokenTree],\n                  tts: &[TokenTree])\n                  -> macro_parser::NamedParseResult {\n+        let diag = &cx.parse_sess().span_diagnostic;\n         // `None` is because we're not interpolating\n-        let arg_rdr = lexer::new_tt_reader_with_doc_flag(&cx.parse_sess().span_diagnostic,\n-                                                         None,\n-                                                         tts.iter().cloned().collect(),\n-                                                         true);\n+        let arg_rdr = lexer::new_tt_reader(diag, None, tts.iter().cloned().collect());\n         macro_parser::parse(cx.parse_sess(), arg_rdr, mtch)\n     }\n "}, {"sha": "e4d0cb74046037a9407e421640445adaaacb8d16", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -250,7 +250,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n \n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprKind::InlineAsm(ast::InlineAsm {\n+        node: ast::ExprKind::InlineAsm(P(ast::InlineAsm {\n             asm: token::intern_and_get_ident(&asm),\n             asm_str_style: asm_str_style.unwrap(),\n             outputs: outputs,\n@@ -260,7 +260,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n             alignstack: alignstack,\n             dialect: dialect,\n             expn_id: expn_id,\n-        }),\n+        })),\n         span: sp,\n         attrs: ast::ThinVec::new(),\n     }))"}, {"sha": "a8accd63dcf0a1252e223abb675f34153d5f3ca3", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -105,6 +105,17 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n         match item.node {\n             ast::ItemKind::Fn(..) => {}\n             _ => {\n+                // Check for invalid use of proc_macro_derive\n+                let attr = item.attrs.iter()\n+                    .filter(|a| a.check_name(\"proc_macro_derive\"))\n+                    .next();\n+                if let Some(attr) = attr {\n+                    self.handler.span_err(attr.span(),\n+                                          \"the `#[proc_macro_derive]` \\\n+                                          attribute may only be used \\\n+                                          on bare functions\");\n+                    return;\n+                }\n                 self.check_not_pub_in_root(&item.vis, item.span);\n                 return visit::walk_item(self, item)\n             }"}, {"sha": "405994b36e25ef025dc930d9f9791963a7b153cd", "filename": "src/test/compile-fail-fulldeps/proc-macro/illegal-proc-macro-derive-use.rs", "status": "renamed", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fillegal-proc-macro-derive-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fillegal-proc-macro-derive-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fillegal-proc-macro-derive-use.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,4 +18,10 @@ pub fn foo(a: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     a\n }\n \n+// Issue #37590\n+#[proc_macro_derive(Foo)]\n+//~^ ERROR: the `#[proc_macro_derive]` attribute may only be used on bare functions\n+pub struct Foo {\n+}\n+\n fn main() {}", "previous_filename": "src/test/compile-fail-fulldeps/proc-macro/require-rustc-macro-crate-type.rs"}, {"sha": "eb676601e89ce2b77abc9b139808b53e3a58595b", "filename": "src/test/compile-fail/issue-37534.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fissue-37534.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fissue-37534.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-37534.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<T: ?Hash> { }\n+//~^ ERROR trait `Hash` is not in scope [E0405]\n+//~^^ ERROR parameter `T` is never used [E0392]\n+//~^^^ WARN default bound relaxed for a type parameter, but this does nothing\n+\n+fn main() { }"}, {"sha": "ecaf269fcb1ae64f0d53bfcf5e95ac7ee247a9e7", "filename": "src/test/compile-fail/struct-path-associated-type.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fstruct-path-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fstruct-path-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-associated-type.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(more_struct_aliases)]\n+\n struct S;\n \n trait Tr {"}, {"sha": "a2050182a7e303f80ef4dbad84cbf4cea1a12581", "filename": "src/test/compile-fail/struct-path-self-feature-gate.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-feature-gate.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+trait Tr {\n+    type A;\n+}\n+\n+fn f<T: Tr<A = S>>() {\n+    let _ = T::A {};\n+    //~^ ERROR `Self` and associated types in struct expressions and patterns are unstable\n+}\n+\n+impl S {\n+    fn f() {\n+        let _ = Self {};\n+        //~^ ERROR `Self` and associated types in struct expressions and patterns are unstable\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "8352bd6751f50dcfd3854a4a5c21f41927e6aa6a", "filename": "src/test/compile-fail/struct-path-self-type-mismatch.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-type-mismatch.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(more_struct_aliases)]\n+\n struct Foo<A> { inner: A }\n \n trait Bar { fn bar(); }"}, {"sha": "aeac199227b75f1f44a64b3bebf5249c9490cc35", "filename": "src/test/compile-fail/struct-path-self.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fstruct-path-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fstruct-path-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-self.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(more_struct_aliases)]\n+\n struct S;\n \n trait Tr {"}, {"sha": "4b563e78e55c85643164db1af15d7fc9729976b4", "filename": "src/test/compile-fail/windows-subsystem-gated.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fwindows-subsystem-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fwindows-subsystem-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwindows-subsystem-gated.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![windows_subsystem = \"console\"]\n+//~^ ERROR: the windows subsystem attribute is currently unstable\n+\n+fn main() {}"}, {"sha": "e0003440719e62b2d3f1860e4c566299f26ad693", "filename": "src/test/compile-fail/windows-subsystem-invalid.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fwindows-subsystem-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fcompile-fail%2Fwindows-subsystem-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwindows-subsystem-invalid.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: invalid windows subsystem `wrong`, only `windows` and `console` are allowed\n+\n+#![feature(windows_subsystem)]\n+#![windows_subsystem = \"wrong\"]\n+\n+fn main() {}"}, {"sha": "ccd94022711cd7362408154793d7b80f6cff185b", "filename": "src/test/debuginfo/associated-types.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -16,7 +16,8 @@\n // gdb-command:run\n \n // gdb-command:print arg\n-// gdb-check:$1 = {b = -1, b1 = 0}\n+// gdbg-check:$1 = {b = -1, b1 = 0}\n+// gdbr-check:$1 = associated_types::Struct<i32> {b: -1, b1: 0}\n // gdb-command:continue\n \n // gdb-command:print inferred\n@@ -30,7 +31,8 @@\n // gdb-command:continue\n \n // gdb-command:print arg\n-// gdb-check:$5 = {__0 = 4, __1 = 5}\n+// gdbg-check:$5 = {__0 = 4, __1 = 5}\n+// gdbr-check:$5 = (4, 5)\n // gdb-command:continue\n \n // gdb-command:print a"}, {"sha": "fe687dabe9acbbc104252fa6c6a608cce20a94ad", "filename": "src/test/debuginfo/basic-types-globals-metadata.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals-metadata.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -12,33 +12,47 @@\n \n // compile-flags:-g\n // gdb-command:run\n-// gdb-command:whatis 'basic_types_globals_metadata::B'\n+// gdbg-command:whatis 'basic_types_globals_metadata::B'\n+// gdbr-command:whatis basic_types_globals_metadata::B\n // gdb-check:type = bool\n-// gdb-command:whatis 'basic_types_globals_metadata::I'\n+// gdbg-command:whatis 'basic_types_globals_metadata::I'\n+// gdbr-command:whatis basic_types_globals_metadata::I\n // gdb-check:type = isize\n-// gdb-command:whatis 'basic_types_globals_metadata::C'\n+// gdbg-command:whatis 'basic_types_globals_metadata::C'\n+// gdbr-command:whatis basic_types_globals_metadata::C\n // gdb-check:type = char\n-// gdb-command:whatis 'basic_types_globals_metadata::I8'\n+// gdbg-command:whatis 'basic_types_globals_metadata::I8'\n+// gdbr-command:whatis basic_types_globals_metadata::I8\n // gdb-check:type = i8\n-// gdb-command:whatis 'basic_types_globals_metadata::I16'\n+// gdbg-command:whatis 'basic_types_globals_metadata::I16'\n+// gdbr-command:whatis basic_types_globals_metadata::I16\n // gdb-check:type = i16\n-// gdb-command:whatis 'basic_types_globals_metadata::I32'\n+// gdbg-command:whatis 'basic_types_globals_metadata::I32'\n+// gdbr-command:whatis basic_types_globals_metadata::I32\n // gdb-check:type = i32\n-// gdb-command:whatis 'basic_types_globals_metadata::I64'\n+// gdbg-command:whatis 'basic_types_globals_metadata::I64'\n+// gdbr-command:whatis basic_types_globals_metadata::I64\n // gdb-check:type = i64\n-// gdb-command:whatis 'basic_types_globals_metadata::U'\n+// gdbg-command:whatis 'basic_types_globals_metadata::U'\n+// gdbr-command:whatis basic_types_globals_metadata::U\n // gdb-check:type = usize\n-// gdb-command:whatis 'basic_types_globals_metadata::U8'\n+// gdbg-command:whatis 'basic_types_globals_metadata::U8'\n+// gdbr-command:whatis basic_types_globals_metadata::U8\n // gdb-check:type = u8\n-// gdb-command:whatis 'basic_types_globals_metadata::U16'\n+// gdbg-command:whatis 'basic_types_globals_metadata::U16'\n+// gdbr-command:whatis basic_types_globals_metadata::U16\n // gdb-check:type = u16\n-// gdb-command:whatis 'basic_types_globals_metadata::U32'\n+// gdbg-command:whatis 'basic_types_globals_metadata::U32'\n+// gdbr-command:whatis basic_types_globals_metadata::U32\n // gdb-check:type = u32\n-// gdb-command:whatis 'basic_types_globals_metadata::U64'\n+// gdbg-command:whatis 'basic_types_globals_metadata::U64'\n+// gdbr-command:whatis basic_types_globals_metadata::U64\n // gdb-check:type = u64\n-// gdb-command:whatis 'basic_types_globals_metadata::F32'\n+// gdbg-command:whatis 'basic_types_globals_metadata::F32'\n+// gdbr-command:whatis basic_types_globals_metadata::F32\n // gdb-check:type = f32\n-// gdb-command:whatis 'basic_types_globals_metadata::F64'\n+// gdbg-command:whatis 'basic_types_globals_metadata::F64'\n+// gdbr-command:whatis basic_types_globals_metadata::F64\n // gdb-check:type = f64\n // gdb-command:continue\n "}, {"sha": "20bc403fbbcdc8a45eb2a1daf688e0e60e2f85bb", "filename": "src/test/debuginfo/basic-types-globals.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-globals.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,33 +18,48 @@\n \n // compile-flags:-g\n // gdb-command:run\n-// gdb-command:print 'basic_types_globals::B'\n+// gdbg-command:print 'basic_types_globals::B'\n+// gdbr-command:print B\n // gdb-check:$1 = false\n-// gdb-command:print 'basic_types_globals::I'\n+// gdbg-command:print 'basic_types_globals::I'\n+// gdbr-command:print I\n // gdb-check:$2 = -1\n-// gdb-command:print 'basic_types_globals::C'\n-// gdb-check:$3 = 97\n-// gdb-command:print/d 'basic_types_globals::I8'\n+// gdbg-command:print 'basic_types_globals::C'\n+// gdbr-command:print C\n+// gdbg-check:$3 = 97\n+// gdbr-check:$3 = 97 'a'\n+// gdbg-command:print/d 'basic_types_globals::I8'\n+// gdbr-command:print I8\n // gdb-check:$4 = 68\n-// gdb-command:print 'basic_types_globals::I16'\n+// gdbg-command:print 'basic_types_globals::I16'\n+// gdbr-command:print I16\n // gdb-check:$5 = -16\n-// gdb-command:print 'basic_types_globals::I32'\n+// gdbg-command:print 'basic_types_globals::I32'\n+// gdbr-command:print I32\n // gdb-check:$6 = -32\n-// gdb-command:print 'basic_types_globals::I64'\n+// gdbg-command:print 'basic_types_globals::I64'\n+// gdbr-command:print I64\n // gdb-check:$7 = -64\n-// gdb-command:print 'basic_types_globals::U'\n+// gdbg-command:print 'basic_types_globals::U'\n+// gdbr-command:print U\n // gdb-check:$8 = 1\n-// gdb-command:print/d 'basic_types_globals::U8'\n+// gdbg-command:print/d 'basic_types_globals::U8'\n+// gdbr-command:print U8\n // gdb-check:$9 = 100\n-// gdb-command:print 'basic_types_globals::U16'\n+// gdbg-command:print 'basic_types_globals::U16'\n+// gdbr-command:print U16\n // gdb-check:$10 = 16\n-// gdb-command:print 'basic_types_globals::U32'\n+// gdbg-command:print 'basic_types_globals::U32'\n+// gdbr-command:print U32\n // gdb-check:$11 = 32\n-// gdb-command:print 'basic_types_globals::U64'\n+// gdbg-command:print 'basic_types_globals::U64'\n+// gdbr-command:print U64\n // gdb-check:$12 = 64\n-// gdb-command:print 'basic_types_globals::F32'\n+// gdbg-command:print 'basic_types_globals::F32'\n+// gdbr-command:print F32\n // gdb-check:$13 = 2.5\n-// gdb-command:print 'basic_types_globals::F64'\n+// gdbg-command:print 'basic_types_globals::F64'\n+// gdbr-command:print F64\n // gdb-check:$14 = 3.5\n // gdb-command:continue\n "}, {"sha": "8aec1a059bdc65c82c84b3c712fb71b55e2ac593", "filename": "src/test/debuginfo/basic-types-metadata.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fbasic-types-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fbasic-types-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-metadata.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -45,20 +45,29 @@\n // gdb-command:whatis fnptr\n // gdb-check:type = [...] (*)([...])\n // gdb-command:info functions _yyy\n-// gdb-check:[...]![...]_yyy([...]);\n+// gdbg-check:[...]![...]_yyy([...]);\n+// gdbr-check:static fn basic_types_metadata::_yyy() -> !;\n // gdb-command:ptype closure_0\n-// gdb-check: type = struct closure {\n-// gdb-check:     <no data fields>\n-// gdb-check: }\n+// gdbr-check: type = struct closure\n+// gdbg-check: type = struct closure {\n+// gdbg-check:     <no data fields>\n+// gdbg-check: }\n // gdb-command:ptype closure_1\n-// gdb-check: type = struct closure {\n-// gdb-check:     bool *__0;\n-// gdb-check: }\n+// gdbg-check: type = struct closure {\n+// gdbg-check:     bool *__0;\n+// gdbg-check: }\n+// gdbr-check: type = struct closure (\n+// gdbr-check:     bool *,\n+// gdbr-check: )\n // gdb-command:ptype closure_2\n-// gdb-check: type = struct closure {\n-// gdb-check:     bool *__0;\n-// gdb-check:     isize *__1;\n-// gdb-check: }\n+// gdbg-check: type = struct closure {\n+// gdbg-check:     bool *__0;\n+// gdbg-check:     isize *__1;\n+// gdbg-check: }\n+// gdbr-check: type = struct closure (\n+// gdbr-check:     bool *,\n+// gdbr-check:     isize *,\n+// gdbr-check: )\n \n //\n // gdb-command:continue"}, {"sha": "62325aa53ab9f258e5146ba754f3ce63d19bd566", "filename": "src/test/debuginfo/basic-types-mut-globals.rs", "status": "modified", "additions": 60, "deletions": 30, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fbasic-types-mut-globals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fbasic-types-mut-globals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types-mut-globals.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -21,64 +21,94 @@\n // gdb-command:run\n \n // Check initializers\n-// gdb-command:print 'basic_types_mut_globals::B'\n+// gdbg-command:print 'basic_types_mut_globals::B'\n+// gdbr-command:print B\n // gdb-check:$1 = false\n-// gdb-command:print 'basic_types_mut_globals::I'\n+// gdbg-command:print 'basic_types_mut_globals::I'\n+// gdbr-command:print I\n // gdb-check:$2 = -1\n-// gdb-command:print 'basic_types_mut_globals::C'\n-// gdb-check:$3 = 97\n-// gdb-command:print/d 'basic_types_mut_globals::I8'\n+// gdbg-command:print/d 'basic_types_mut_globals::C'\n+// gdbr-command:print C\n+// gdbg-check:$3 = 97\n+// gdbr-check:$3 = 97 'a'\n+// gdbg-command:print/d 'basic_types_mut_globals::I8'\n+// gdbr-command:print I8\n // gdb-check:$4 = 68\n-// gdb-command:print 'basic_types_mut_globals::I16'\n+// gdbg-command:print 'basic_types_mut_globals::I16'\n+// gdbr-command:print I16\n // gdb-check:$5 = -16\n-// gdb-command:print 'basic_types_mut_globals::I32'\n+// gdbg-command:print 'basic_types_mut_globals::I32'\n+// gdbr-command:print I32\n // gdb-check:$6 = -32\n-// gdb-command:print 'basic_types_mut_globals::I64'\n+// gdbg-command:print 'basic_types_mut_globals::I64'\n+// gdbr-command:print I64\n // gdb-check:$7 = -64\n-// gdb-command:print 'basic_types_mut_globals::U'\n+// gdbg-command:print 'basic_types_mut_globals::U'\n+// gdbr-command:print U\n // gdb-check:$8 = 1\n-// gdb-command:print/d 'basic_types_mut_globals::U8'\n+// gdbg-command:print/d 'basic_types_mut_globals::U8'\n+// gdbr-command:print U8\n // gdb-check:$9 = 100\n-// gdb-command:print 'basic_types_mut_globals::U16'\n+// gdbg-command:print 'basic_types_mut_globals::U16'\n+// gdbr-command:print U16\n // gdb-check:$10 = 16\n-// gdb-command:print 'basic_types_mut_globals::U32'\n+// gdbg-command:print 'basic_types_mut_globals::U32'\n+// gdbr-command:print U32\n // gdb-check:$11 = 32\n-// gdb-command:print 'basic_types_mut_globals::U64'\n+// gdbg-command:print 'basic_types_mut_globals::U64'\n+// gdbr-command:print U64\n // gdb-check:$12 = 64\n-// gdb-command:print 'basic_types_mut_globals::F32'\n+// gdbg-command:print 'basic_types_mut_globals::F32'\n+// gdbr-command:print F32\n // gdb-check:$13 = 2.5\n-// gdb-command:print 'basic_types_mut_globals::F64'\n+// gdbg-command:print 'basic_types_mut_globals::F64'\n+// gdbr-command:print F64\n // gdb-check:$14 = 3.5\n // gdb-command:continue\n \n // Check new values\n-// gdb-command:print 'basic_types_mut_globals'::B\n+// gdbg-command:print 'basic_types_mut_globals'::B\n+// gdbr-command:print B\n // gdb-check:$15 = true\n-// gdb-command:print 'basic_types_mut_globals'::I\n+// gdbg-command:print 'basic_types_mut_globals'::I\n+// gdbr-command:print I\n // gdb-check:$16 = 2\n-// gdb-command:print 'basic_types_mut_globals'::C\n-// gdb-check:$17 = 102\n-// gdb-command:print/d 'basic_types_mut_globals'::I8\n+// gdbg-command:print/d 'basic_types_mut_globals'::C\n+// gdbr-command:print C\n+// gdbg-check:$17 = 102\n+// gdbr-check:$17 = 102 'f'\n+// gdbg-command:print/d 'basic_types_mut_globals'::I8\n+// gdbr-command:print/d I8\n // gdb-check:$18 = 78\n-// gdb-command:print 'basic_types_mut_globals'::I16\n+// gdbg-command:print 'basic_types_mut_globals'::I16\n+// gdbr-command:print I16\n // gdb-check:$19 = -26\n-// gdb-command:print 'basic_types_mut_globals'::I32\n+// gdbg-command:print 'basic_types_mut_globals'::I32\n+// gdbr-command:print I32\n // gdb-check:$20 = -12\n-// gdb-command:print 'basic_types_mut_globals'::I64\n+// gdbg-command:print 'basic_types_mut_globals'::I64\n+// gdbr-command:print I64\n // gdb-check:$21 = -54\n-// gdb-command:print 'basic_types_mut_globals'::U\n+// gdbg-command:print 'basic_types_mut_globals'::U\n+// gdbr-command:print U\n // gdb-check:$22 = 5\n-// gdb-command:print/d 'basic_types_mut_globals'::U8\n+// gdbg-command:print/d 'basic_types_mut_globals'::U8\n+// gdbr-command:print/d U8\n // gdb-check:$23 = 20\n-// gdb-command:print 'basic_types_mut_globals'::U16\n+// gdbg-command:print 'basic_types_mut_globals'::U16\n+// gdbr-command:print U16\n // gdb-check:$24 = 32\n-// gdb-command:print 'basic_types_mut_globals'::U32\n+// gdbg-command:print 'basic_types_mut_globals'::U32\n+// gdbr-command:print U32\n // gdb-check:$25 = 16\n-// gdb-command:print 'basic_types_mut_globals'::U64\n+// gdbg-command:print 'basic_types_mut_globals'::U64\n+// gdbr-command:print U64\n // gdb-check:$26 = 128\n-// gdb-command:print 'basic_types_mut_globals'::F32\n+// gdbg-command:print 'basic_types_mut_globals'::F32\n+// gdbr-command:print F32\n // gdb-check:$27 = 5.75\n-// gdb-command:print 'basic_types_mut_globals'::F64\n+// gdbg-command:print 'basic_types_mut_globals'::F64\n+// gdbr-command:print F64\n // gdb-check:$28 = 9.25\n \n #![allow(unused_variables)]"}, {"sha": "01ce5bd31626e33ed0d3a5b047318144b30d7155", "filename": "src/test/debuginfo/basic-types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fbasic-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fbasic-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbasic-types.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -26,7 +26,8 @@\n // gdb-command:print i\n // gdb-check:$2 = -1\n // gdb-command:print c\n-// gdb-check:$3 = 97\n+// gdbg-check:$3 = 97\n+// gdbr-check:$3 = 97 'a'\n // gdb-command:print/d i8\n // gdb-check:$4 = 68\n // gdb-command:print i16"}, {"sha": "f6c0ff09efe93f7fa3ac509327d9ca71bb979424", "filename": "src/test/debuginfo/borrowed-basic.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fborrowed-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fborrowed-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-basic.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -25,10 +25,12 @@\n // gdb-check:$2 = -1\n \n // gdb-command:print *char_ref\n-// gdb-check:$3 = 97\n+// gdbg-check:$3 = 97\n+// gdbr-check:$3 = 97 'a'\n \n // gdb-command:print *i8_ref\n-// gdb-check:$4 = 68 'D'\n+// gdbg-check:$4 = 68 'D'\n+// gdbr-check:$4 = 68\n \n // gdb-command:print *i16_ref\n // gdb-check:$5 = -16\n@@ -43,7 +45,8 @@\n // gdb-check:$8 = 1\n \n // gdb-command:print *u8_ref\n-// gdb-check:$9 = 100 'd'\n+// gdbg-check:$9 = 100 'd'\n+// gdbr-check:$9 = 100\n \n // gdb-command:print *u16_ref\n // gdb-check:$10 = 16"}, {"sha": "d6f379634be5bceddfa9b652316bb0871b6afea8", "filename": "src/test/debuginfo/borrowed-c-style-enum.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fborrowed-c-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fborrowed-c-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-c-style-enum.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -17,13 +17,16 @@\n // gdb-command:run\n \n // gdb-command:print *the_a_ref\n-// gdb-check:$1 = TheA\n+// gdbg-check:$1 = TheA\n+// gdbr-check:$1 = borrowed_c_style_enum::ABC::TheA\n \n // gdb-command:print *the_b_ref\n-// gdb-check:$2 = TheB\n+// gdbg-check:$2 = TheB\n+// gdbr-check:$2 = borrowed_c_style_enum::ABC::TheB\n \n // gdb-command:print *the_c_ref\n-// gdb-check:$3 = TheC\n+// gdbg-check:$3 = TheC\n+// gdbr-check:$3 = borrowed_c_style_enum::ABC::TheC\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "ddc29c64302706be1306157c7f13e7bbe8b2faa9", "filename": "src/test/debuginfo/borrowed-enum.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,13 +18,16 @@\n // gdb-command:run\n \n // gdb-command:print *the_a_ref\n-// gdb-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, __0 = 0, __1 = 2088533116, __2 = 2088533116}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, __0 = 0, __1 = 2088533116, __2 = 2088533116}}\n+// gdbr-check:$1 = borrowed_enum::ABC::TheA{x: 0, y: 8970181431921507452}\n \n // gdb-command:print *the_b_ref\n-// gdb-check:$2 = {{RUST$ENUM$DISR = TheB, x = 0, y = 1229782938247303441}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, x = 0, y = 1229782938247303441}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n+// gdbr-check:$2 = borrowed_enum::ABC::TheB(0, 286331153, 286331153)\n \n // gdb-command:print *univariant_ref\n-// gdb-check:$3 = {{__0 = 4820353753753434}}\n+// gdbg-check:$3 = {{__0 = 4820353753753434}}\n+// gdbr-check:$3 = borrowed_enum::Univariant::TheOnlyCase(4820353753753434)\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "01428e515e27f25b15dfc333980167356c33015a", "filename": "src/test/debuginfo/borrowed-struct.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fborrowed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fborrowed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -16,7 +16,8 @@\n // gdb-command:run\n \n // gdb-command:print *stack_val_ref\n-// gdb-check:$1 = {x = 10, y = 23.5}\n+// gdbg-check:$1 = {x = 10, y = 23.5}\n+// gdbr-check:$1 = borrowed_struct::SomeStruct {x: 10, y: 23.5}\n \n // gdb-command:print *stack_val_interior_ref_1\n // gdb-check:$2 = 10\n@@ -25,10 +26,12 @@\n // gdb-check:$3 = 23.5\n \n // gdb-command:print *ref_to_unnamed\n-// gdb-check:$4 = {x = 11, y = 24.5}\n+// gdbg-check:$4 = {x = 11, y = 24.5}\n+// gdbr-check:$4 = borrowed_struct::SomeStruct {x: 11, y: 24.5}\n \n // gdb-command:print *unique_val_ref\n-// gdb-check:$5 = {x = 13, y = 26.5}\n+// gdbg-check:$5 = {x = 13, y = 26.5}\n+// gdbr-check:$5 = borrowed_struct::SomeStruct {x: 13, y: 26.5}\n \n // gdb-command:print *unique_val_interior_ref_1\n // gdb-check:$6 = 13"}, {"sha": "17db88ee37f53fcecbeaad6a81a415e8274e2caf", "filename": "src/test/debuginfo/borrowed-tuple.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fborrowed-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fborrowed-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-tuple.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -17,13 +17,16 @@\n // gdb-command:run\n \n // gdb-command:print *stack_val_ref\n-// gdb-check:$1 = {__0 = -14, __1 = -19}\n+// gdbg-check:$1 = {__0 = -14, __1 = -19}\n+// gdbr-check:$1 = (-14, -19)\n \n // gdb-command:print *ref_to_unnamed\n-// gdb-check:$2 = {__0 = -15, __1 = -20}\n+// gdbg-check:$2 = {__0 = -15, __1 = -20}\n+// gdbr-check:$2 = (-15, -20)\n \n // gdb-command:print *unique_val_ref\n-// gdb-check:$3 = {__0 = -17, __1 = -22}\n+// gdbg-check:$3 = {__0 = -17, __1 = -22}\n+// gdbr-check:$3 = (-17, -22)\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "9e95498b0c30e7cbbd6903efb3a121e9e1bb9e27", "filename": "src/test/debuginfo/borrowed-unique-basic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fborrowed-unique-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fborrowed-unique-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-unique-basic.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -26,7 +26,8 @@\n // gdb-check:$2 = -1\n \n // gdb-command:print *char_ref\n-// gdb-check:$3 = 97\n+// gdbg-check:$3 = 97\n+// gdbr-check:$3 = 97 'a'\n \n // gdb-command:print/d *i8_ref\n // gdb-check:$4 = 68"}, {"sha": "98c09fe09de8f3f2937ef30b644e15bbae403352", "filename": "src/test/debuginfo/box.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fbox.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -19,7 +19,8 @@\n // gdb-command:print *a\n // gdb-check:$1 = 1\n // gdb-command:print *b\n-// gdb-check:$2 = {__0 = 2, __1 = 3.5}\n+// gdbg-check:$2 = {__0 = 2, __1 = 3.5}\n+// gdbr-check:$2 = (2, 3.5)\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "ac091b4a533db49b8b3fabe694e74eba386ad5d0", "filename": "src/test/debuginfo/boxed-struct.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fboxed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fboxed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fboxed-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -17,10 +17,12 @@\n // gdb-command:run\n \n // gdb-command:print *unique\n-// gdb-check:$1 = {x = 99, y = 999, z = 9999, w = 99999}\n+// gdbg-check:$1 = {x = 99, y = 999, z = 9999, w = 99999}\n+// gdbr-check:$1 = boxed_struct::StructWithSomePadding {x: 99, y: 999, z: 9999, w: 99999}\n \n // gdb-command:print *unique_dtor\n-// gdb-check:$2 = {x = 77, y = 777, z = 7777, w = 77777}\n+// gdbg-check:$2 = {x = 77, y = 777, z = 7777, w = 77777}\n+// gdbr-check:$2 = boxed_struct::StructWithDestructor {x: 77, y: 777, z: 7777, w: 77777}\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "6d821dbc155d0fc18a73a5fbab20656a1deea604", "filename": "src/test/debuginfo/by-value-non-immediate-argument.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fby-value-non-immediate-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fby-value-non-immediate-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fby-value-non-immediate-argument.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,27 +18,32 @@\n // gdb-command:run\n \n // gdb-command:print s\n-// gdb-check:$1 = {a = 1, b = 2.5}\n+// gdbg-check:$1 = {a = 1, b = 2.5}\n+// gdbr-check:$1 = by_value_non_immediate_argument::Struct {a: 1, b: 2.5}\n // gdb-command:continue\n \n // gdb-command:print x\n-// gdb-check:$2 = {a = 3, b = 4.5}\n+// gdbg-check:$2 = {a = 3, b = 4.5}\n+// gdbr-check:$2 = by_value_non_immediate_argument::Struct {a: 3, b: 4.5}\n // gdb-command:print y\n // gdb-check:$3 = 5\n // gdb-command:print z\n // gdb-check:$4 = 6.5\n // gdb-command:continue\n \n // gdb-command:print a\n-// gdb-check:$5 = {__0 = 7, __1 = 8, __2 = 9.5, __3 = 10.5}\n+// gdbg-check:$5 = {__0 = 7, __1 = 8, __2 = 9.5, __3 = 10.5}\n+// gdbr-check:$5 = (7, 8, 9.5, 10.5)\n // gdb-command:continue\n \n // gdb-command:print a\n-// gdb-check:$6 = {__0 = 11.5, __1 = 12.5, __2 = 13, __3 = 14}\n+// gdbg-check:$6 = {__0 = 11.5, __1 = 12.5, __2 = 13, __3 = 14}\n+// gdbr-check:$6 = by_value_non_immediate_argument::Newtype (11.5, 12.5, 13, 14)\n // gdb-command:continue\n \n // gdb-command:print x\n-// gdb-check:$7 = {{RUST$ENUM$DISR = Case1, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 2088533116, __2 = 2088533116}}\n+// gdbg-check:$7 = {{RUST$ENUM$DISR = Case1, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 2088533116, __2 = 2088533116}}\n+// gdbr-check:$7 = by_value_non_immediate_argument::Enum::Case1{x: 0, y: 8970181431921507452}\n // gdb-command:continue\n \n "}, {"sha": "c14f8c7b354fcaaf75dbfef7792ee6c78c238480", "filename": "src/test/debuginfo/by-value-self-argument-in-trait-impl.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fby-value-self-argument-in-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fby-value-self-argument-in-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fby-value-self-argument-in-trait-impl.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -21,11 +21,13 @@\n // gdb-command:continue\n \n // gdb-command:print self\n-// gdb-check:$2 = {x = 2222, y = 3333}\n+// gdbg-check:$2 = {x = 2222, y = 3333}\n+// gdbr-check:$2 = by_value_self_argument_in_trait_impl::Struct {x: 2222, y: 3333}\n // gdb-command:continue\n \n // gdb-command:print self\n-// gdb-check:$3 = {__0 = 4444.5, __1 = 5555, __2 = 6666, __3 = 7777.5}\n+// gdbg-check:$3 = {__0 = 4444.5, __1 = 5555, __2 = 6666, __3 = 7777.5}\n+// gdbr-check:$3 = (4444.5, 5555, 6666, 7777.5)\n // gdb-command:continue\n \n "}, {"sha": "004e15d1cc6c15a0745afa92bc96d3d910f6a8dd", "filename": "src/test/debuginfo/c-style-enum-in-composite.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,26 +18,32 @@\n // gdb-command:run\n \n // gdb-command:print tuple_interior_padding\n-// gdb-check:$1 = {__0 = 0, __1 = OneHundred}\n+// gdbg-check:$1 = {__0 = 0, __1 = OneHundred}\n+// gdbr-check:$1 = (0, c_style_enum_in_composite::AnEnum::OneHundred)\n \n // gdb-command:print tuple_padding_at_end\n-// gdb-check:$2 = {__0 = {__0 = 1, __1 = OneThousand}, __1 = 2}\n+// gdbg-check:$2 = {__0 = {__0 = 1, __1 = OneThousand}, __1 = 2}\n+// gdbr-check:$2 = ((1, c_style_enum_in_composite::AnEnum::OneThousand), 2)\n \n // gdb-command:print tuple_different_enums\n-// gdb-check:$3 = {__0 = OneThousand, __1 = MountainView, __2 = OneMillion, __3 = Vienna}\n+// gdbg-check:$3 = {__0 = OneThousand, __1 = MountainView, __2 = OneMillion, __3 = Vienna}\n+// gdbr-check:$3 = (c_style_enum_in_composite::AnEnum::OneThousand, c_style_enum_in_composite::AnotherEnum::MountainView, c_style_enum_in_composite::AnEnum::OneMillion, c_style_enum_in_composite::AnotherEnum::Vienna)\n \n // gdb-command:print padded_struct\n-// gdb-check:$4 = {a = 3, b = OneMillion, c = 4, d = Toronto, e = 5}\n+// gdbg-check:$4 = {a = 3, b = OneMillion, c = 4, d = Toronto, e = 5}\n+// gdbr-check:$4 = c_style_enum_in_composite::PaddedStruct {a: 3, b: c_style_enum_in_composite::AnEnum::OneMillion, c: 4, d: c_style_enum_in_composite::AnotherEnum::Toronto, e: 5}\n \n // gdb-command:print packed_struct\n-// gdb-check:$5 = {a = 6, b = OneHundred, c = 7, d = Vienna, e = 8}\n+// gdbg-check:$5 = {a = 6, b = OneHundred, c = 7, d = Vienna, e = 8}\n+// gdbr-check:$5 = c_style_enum_in_composite::PackedStruct {a: 6, b: c_style_enum_in_composite::AnEnum::OneHundred, c: 7, d: c_style_enum_in_composite::AnotherEnum::Vienna, e: 8}\n \n // gdb-command:print non_padded_struct\n-// gdb-check:$6 = {a = OneMillion, b = MountainView, c = OneThousand, d = Toronto}\n+// gdbg-check:$6 = {a = OneMillion, b = MountainView, c = OneThousand, d = Toronto}\n+// gdbr-check:$6 = c_style_enum_in_composite::NonPaddedStruct {a: c_style_enum_in_composite::AnEnum::OneMillion, b: c_style_enum_in_composite::AnotherEnum::MountainView, c: c_style_enum_in_composite::AnEnum::OneThousand, d: c_style_enum_in_composite::AnotherEnum::Toronto}\n \n // gdb-command:print struct_with_drop\n-// gdb-check:$7 = {__0 = {a = OneHundred, b = Vienna}, __1 = 9}\n-\n+// gdbg-check:$7 = {__0 = {a = OneHundred, b = Vienna}, __1 = 9}\n+// gdbr-check:$7 = (c_style_enum_in_composite::StructWithDrop {a: c_style_enum_in_composite::AnEnum::OneHundred, b: c_style_enum_in_composite::AnotherEnum::Vienna}, 9)\n \n // === LLDB TESTS ==================================================================================\n "}, {"sha": "2452c18f54347d6d639ae8cd06890016aaf79033", "filename": "src/test/debuginfo/c-style-enum.rs", "status": "modified", "additions": 48, "deletions": 26, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -16,60 +16,82 @@\n // === GDB TESTS ===================================================================================\n \n // gdb-command:print 'c_style_enum::SINGLE_VARIANT'\n-// gdb-check:$1 = TheOnlyVariant\n+// gdbg-check:$1 = TheOnlyVariant\n+// gdbr-check:$1 = c_style_enum::SingleVariant::TheOnlyVariant\n \n // gdb-command:print 'c_style_enum::AUTO_ONE'\n-// gdb-check:$2 = One\n+// gdbg-check:$2 = One\n+// gdbr-check:$2 = c_style_enum::AutoDiscriminant::One\n \n // gdb-command:print 'c_style_enum::AUTO_TWO'\n-// gdb-check:$3 = One\n+// gdbg-check:$3 = One\n+// gdbr-check:$3 = c_style_enum::AutoDiscriminant::One\n \n // gdb-command:print 'c_style_enum::AUTO_THREE'\n-// gdb-check:$4 = One\n+// gdbg-check:$4 = One\n+// gdbr-check:$4 = c_style_enum::AutoDiscriminant::One\n \n // gdb-command:print 'c_style_enum::MANUAL_ONE'\n-// gdb-check:$5 = OneHundred\n+// gdbg-check:$5 = OneHundred\n+// gdbr-check:$5 = c_style_enum::ManualDiscriminant::OneHundred\n \n // gdb-command:print 'c_style_enum::MANUAL_TWO'\n-// gdb-check:$6 = OneHundred\n+// gdbg-check:$6 = OneHundred\n+// gdbr-check:$6 = c_style_enum::ManualDiscriminant::OneHundred\n \n // gdb-command:print 'c_style_enum::MANUAL_THREE'\n-// gdb-check:$7 = OneHundred\n+// gdbg-check:$7 = OneHundred\n+// gdbr-check:$7 = c_style_enum::ManualDiscriminant::OneHundred\n \n // gdb-command:run\n \n // gdb-command:print auto_one\n-// gdb-check:$8 = One\n+// gdbg-check:$8 = One\n+// gdbr-check:$8 = c_style_enum::AutoDiscriminant::One\n \n // gdb-command:print auto_two\n-// gdb-check:$9 = Two\n+// gdbg-check:$9 = Two\n+// gdbr-check:$9 = c_style_enum::AutoDiscriminant::Two\n \n // gdb-command:print auto_three\n-// gdb-check:$10 = Three\n+// gdbg-check:$10 = Three\n+// gdbr-check:$10 = c_style_enum::AutoDiscriminant::Three\n \n // gdb-command:print manual_one_hundred\n-// gdb-check:$11 = OneHundred\n+// gdbg-check:$11 = OneHundred\n+// gdbr-check:$11 = c_style_enum::ManualDiscriminant::OneHundred\n \n // gdb-command:print manual_one_thousand\n-// gdb-check:$12 = OneThousand\n+// gdbg-check:$12 = OneThousand\n+// gdbr-check:$12 = c_style_enum::ManualDiscriminant::OneThousand\n \n // gdb-command:print manual_one_million\n-// gdb-check:$13 = OneMillion\n+// gdbg-check:$13 = OneMillion\n+// gdbr-check:$13 = c_style_enum::ManualDiscriminant::OneMillion\n \n // gdb-command:print single_variant\n-// gdb-check:$14 = TheOnlyVariant\n-\n-// gdb-command:print 'c_style_enum::AUTO_TWO'\n-// gdb-check:$15 = Two\n-\n-// gdb-command:print 'c_style_enum::AUTO_THREE'\n-// gdb-check:$16 = Three\n-\n-// gdb-command:print 'c_style_enum::MANUAL_TWO'\n-// gdb-check:$17 = OneThousand\n-\n-// gdb-command:print 'c_style_enum::MANUAL_THREE'\n-// gdb-check:$18 = OneMillion\n+// gdbg-check:$14 = TheOnlyVariant\n+// gdbr-check:$14 = c_style_enum::SingleVariant::TheOnlyVariant\n+\n+// gdbg-command:print 'c_style_enum::AUTO_TWO'\n+// gdbr-command:print AUTO_TWO\n+// gdbg-check:$15 = Two\n+// gdbr-check:$15 = c_style_enum::AutoDiscriminant::Two\n+\n+// gdbg-command:print 'c_style_enum::AUTO_THREE'\n+// gdbr-command:print AUTO_THREE\n+// gdbg-check:$16 = Three\n+// gdbr-check:$16 = c_style_enum::AutoDiscriminant::Three\n+\n+// gdbg-command:print 'c_style_enum::MANUAL_TWO'\n+// gdbr-command:print MANUAL_TWO\n+// gdbg-check:$17 = OneThousand\n+// gdbr-check:$17 = c_style_enum::ManualDiscriminant::OneThousand\n+\n+// gdbg-command:print 'c_style_enum::MANUAL_THREE'\n+// gdbr-command:print MANUAL_THREE\n+// gdbg-check:$18 = OneMillion\n+// gdbr-check:$18 = c_style_enum::ManualDiscriminant::OneMillion\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "28728df92805103c5c708df6c38f2f5fab1ff166", "filename": "src/test/debuginfo/cross-crate-spans.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fcross-crate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fcross-crate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fcross-crate-spans.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -25,15 +25,17 @@ extern crate cross_crate_spans;\n // gdb-command:run\n \n // gdb-command:print result\n-// gdb-check:$1 = {__0 = 17, __1 = 17}\n+// gdbg-check:$1 = {__0 = 17, __1 = 17}\n+// gdbr-check:$1 = (17, 17)\n // gdb-command:print a_variable\n // gdb-check:$2 = 123456789\n // gdb-command:print another_variable\n // gdb-check:$3 = 123456789.5\n // gdb-command:continue\n \n // gdb-command:print result\n-// gdb-check:$4 = {__0 = 1212, __1 = 1212}\n+// gdbg-check:$4 = {__0 = 1212, __1 = 1212}\n+// gdbr-check:$4 = (1212, 1212)\n // gdb-command:print a_variable\n // gdb-check:$5 = 123456789\n // gdb-command:print another_variable"}, {"sha": "efa9ee59b22b2233588d078348b2c34f07b852e5", "filename": "src/test/debuginfo/destructured-fn-argument.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fdestructured-fn-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fdestructured-fn-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-fn-argument.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -33,13 +33,15 @@\n // gdb-command:print a\n // gdb-check:$6 = 5\n // gdb-command:print b\n-// gdb-check:$7 = {__0 = 6, __1 = 7}\n+// gdbg-check:$7 = {__0 = 6, __1 = 7}\n+// gdbr-check:$7 = (6, 7)\n // gdb-command:continue\n \n // gdb-command:print h\n // gdb-check:$8 = 8\n // gdb-command:print i\n-// gdb-check:$9 = {a = 9, b = 10}\n+// gdbg-check:$9 = {a = 9, b = 10}\n+// gdbr-check:$9 = destructured_fn_argument::Struct {a: 9, b: 10}\n // gdb-command:print j\n // gdb-check:$10 = 11\n // gdb-command:continue\n@@ -65,7 +67,8 @@\n // gdb-command:print q\n // gdb-check:$17 = 20\n // gdb-command:print r\n-// gdb-check:$18 = {a = 21, b = 22}\n+// gdbg-check:$18 = {a = 21, b = 22}\n+// gdbr-check:$18 = destructured_fn_argument::Struct {a: 21, b: 22}\n // gdb-command:continue\n \n // gdb-command:print s\n@@ -95,29 +98,34 @@\n // gdb-command:continue\n \n // gdb-command:print aa\n-// gdb-check:$30 = {__0 = 34, __1 = 35}\n+// gdbg-check:$30 = {__0 = 34, __1 = 35}\n+// gdbr-check:$30 = (34, 35)\n // gdb-command:continue\n \n // gdb-command:print bb\n-// gdb-check:$31 = {__0 = 36, __1 = 37}\n+// gdbg-check:$31 = {__0 = 36, __1 = 37}\n+// gdbr-check:$31 = (36, 37)\n // gdb-command:continue\n \n // gdb-command:print cc\n // gdb-check:$32 = 38\n // gdb-command:continue\n \n // gdb-command:print dd\n-// gdb-check:$33 = {__0 = 40, __1 = 41, __2 = 42}\n+// gdbg-check:$33 = {__0 = 40, __1 = 41, __2 = 42}\n+// gdbr-check:$33 = (40, 41, 42)\n // gdb-command:continue\n \n // gdb-command:print *ee\n-// gdb-check:$34 = {__0 = 43, __1 = 44, __2 = 45}\n+// gdbg-check:$34 = {__0 = 43, __1 = 44, __2 = 45}\n+// gdbr-check:$34 = (43, 44, 45)\n // gdb-command:continue\n \n // gdb-command:print *ff\n // gdb-check:$35 = 46\n // gdb-command:print gg\n-// gdb-check:$36 = {__0 = 47, __1 = 48}\n+// gdbg-check:$36 = {__0 = 47, __1 = 48}\n+// gdbr-check:$36 = (47, 48)\n // gdb-command:continue\n \n // gdb-command:print *hh"}, {"sha": "e973c22fd4a8502b785310a15e6792422ed48f74", "filename": "src/test/debuginfo/destructured-for-loop-variable.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -73,11 +73,13 @@\n // gdb-command:continue\n \n // gdb-command:print simple_struct_ident\n-// gdb-check:$23 = {x = 3537, y = 35437.5, z = true}\n+// gdbg-check:$23 = {x = 3537, y = 35437.5, z = true}\n+// gdbr-check:$23 = destructured_for_loop_variable::Struct {x: 3537, y: 35437.5, z: true}\n // gdb-command:continue\n \n // gdb-command:print simple_tuple_ident\n-// gdb-check:$24 = {__0 = 34903493, __1 = 232323}\n+// gdbg-check:$24 = {__0 = 34903493, __1 = 232323}\n+// gdbr-check:$24 = (34903493, 232323)\n // gdb-command:continue\n \n // === LLDB TESTS =================================================================================="}, {"sha": "1f18b77ab8f6fbf6b797096506b4d89b4d9991f5", "filename": "src/test/debuginfo/destructured-local.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-local.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -31,12 +31,14 @@\n // gdb-command:print f\n // gdb-check:$6 = 5\n // gdb-command:print g\n-// gdb-check:$7 = {__0 = 6, __1 = 7}\n+// gdbg-check:$7 = {__0 = 6, __1 = 7}\n+// gdbr-check:$7 = (6, 7)\n \n // gdb-command:print h\n // gdb-check:$8 = 8\n // gdb-command:print i\n-// gdb-check:$9 = {a = 9, b = 10}\n+// gdbg-check:$9 = {a = 9, b = 10}\n+// gdbr-check:$9 = destructured_local::Struct {a: 9, b: 10}\n // gdb-command:print j\n // gdb-check:$10 = 11\n \n@@ -58,7 +60,8 @@\n // gdb-command:print q\n // gdb-check:$17 = 20\n // gdb-command:print r\n-// gdb-check:$18 = {a = 21, b = 22}\n+// gdbg-check:$18 = {a = 21, b = 22}\n+// gdbr-check:$18 = destructured_local::Struct {a: 21, b: 22}\n \n // gdb-command:print s\n // gdb-check:$19 = 24\n@@ -85,25 +88,30 @@\n // gdb-check:$29 = 33\n \n // gdb-command:print aa\n-// gdb-check:$30 = {__0 = 34, __1 = 35}\n+// gdbg-check:$30 = {__0 = 34, __1 = 35}\n+// gdbr-check:$30 = (34, 35)\n \n // gdb-command:print bb\n-// gdb-check:$31 = {__0 = 36, __1 = 37}\n+// gdbg-check:$31 = {__0 = 36, __1 = 37}\n+// gdbr-check:$31 = (36, 37)\n \n // gdb-command:print cc\n // gdb-check:$32 = 38\n \n // gdb-command:print dd\n-// gdb-check:$33 = {__0 = 40, __1 = 41, __2 = 42}\n+// gdbg-check:$33 = {__0 = 40, __1 = 41, __2 = 42}\n+// gdbr-check:$33 = (40, 41, 42)\n \n // gdb-command:print *ee\n-// gdb-check:$34 = {__0 = 43, __1 = 44, __2 = 45}\n+// gdbg-check:$34 = {__0 = 43, __1 = 44, __2 = 45}\n+// gdbr-check:$34 = (43, 44, 45)\n \n // gdb-command:print *ff\n // gdb-check:$35 = 46\n \n // gdb-command:print gg\n-// gdb-check:$36 = {__0 = 47, __1 = 48}\n+// gdbg-check:$36 = {__0 = 47, __1 = 48}\n+// gdbr-check:$36 = (47, 48)\n \n // gdb-command:print *hh\n // gdb-check:$37 = 50"}, {"sha": "2e151577590b3647ded4c70aee82c8940b414c99", "filename": "src/test/debuginfo/evec-in-struct.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fevec-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fevec-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fevec-in-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -17,18 +17,23 @@\n // gdb-command:run\n \n // gdb-command:print no_padding1\n-// gdb-check:$1 = {x = {0, 1, 2}, y = -3, z = {4.5, 5.5}}\n+// gdbg-check:$1 = {x = {0, 1, 2}, y = -3, z = {4.5, 5.5}}\n+// gdbr-check:$1 = evec_in_struct::NoPadding1 {x: [0, 1, 2], y: -3, z: [4.5, 5.5]}\n // gdb-command:print no_padding2\n-// gdb-check:$2 = {x = {6, 7, 8}, y = {{9, 10}, {11, 12}}}\n+// gdbg-check:$2 = {x = {6, 7, 8}, y = {{9, 10}, {11, 12}}}\n+// gdbr-check:$2 = evec_in_struct::NoPadding2 {x: [6, 7, 8], y: [[9, 10], [11, 12]]}\n \n // gdb-command:print struct_internal_padding\n-// gdb-check:$3 = {x = {13, 14}, y = {15, 16}}\n+// gdbg-check:$3 = {x = {13, 14}, y = {15, 16}}\n+// gdbr-check:$3 = evec_in_struct::StructInternalPadding {x: [13, 14], y: [15, 16]}\n \n // gdb-command:print single_vec\n-// gdb-check:$4 = {x = {17, 18, 19, 20, 21}}\n+// gdbg-check:$4 = {x = {17, 18, 19, 20, 21}}\n+// gdbr-check:$4 = evec_in_struct::SingleVec {x: [17, 18, 19, 20, 21]}\n \n // gdb-command:print struct_padded_at_end\n-// gdb-check:$5 = {x = {22, 23}, y = {24, 25}}\n+// gdbg-check:$5 = {x = {22, 23}, y = {24, 25}}\n+// gdbr-check:$5 = evec_in_struct::StructPaddedAtEnd {x: [22, 23], y: [24, 25]}\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "01901b2c42b8e74c693470b5fc1e526541897fad", "filename": "src/test/debuginfo/extern-c-fn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fextern-c-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fextern-c-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fextern-c-fn.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -16,7 +16,8 @@\n // gdb-command:run\n \n // gdb-command:print s\n-// gdb-check:$1 = [...]\"abcd\"\n+// gdbg-check:$1 = [...]\"abcd\"\n+// gdbr-check:$1 = [...]\"abcd\\000\"\n // gdb-command:print len\n // gdb-check:$2 = 20\n // gdb-command:print local0"}, {"sha": "21fdc4e5e88a65067549df2e7a808be3f4dec7bb", "filename": "src/test/debuginfo/function-arg-initialization.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n // min-lldb-version: 310\n \n // This test case checks if function arguments already have the correct value\n@@ -34,9 +36,11 @@\n \n // NON IMMEDIATE ARGS\n // gdb-command:print a\n-// gdb-check:$4 = {a = 3, b = 4, c = 5, d = 6, e = 7, f = 8, g = 9, h = 10}\n+// gdbg-check:$4 = {a = 3, b = 4, c = 5, d = 6, e = 7, f = 8, g = 9, h = 10}\n+// gdbt-check:$4 = function_arg_initialization::BigStruct {a: 3, b: 4, c: 5, d: 6, e: 7, f: 8, g: 9, h: 10}\n // gdb-command:print b\n-// gdb-check:$5 = {a = 11, b = 12, c = 13, d = 14, e = 15, f = 16, g = 17, h = 18}\n+// gdbg-check:$5 = {a = 11, b = 12, c = 13, d = 14, e = 15, f = 16, g = 17, h = 18}\n+// gdbt-check:$5 = function_arg_initialization::BigStruct {a: 11, b: 12, c: 13, d: 14, e: 15, f: 16, g: 17, h: 18}\n // gdb-command:continue\n \n // BINDING"}, {"sha": "158a1f17fc03d6312e9d851b87a69df630a67c33", "filename": "src/test/debuginfo/gdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -26,13 +26,16 @@\n // gdb-check:$2 = EmptyStruct\n \n // gdb-command: print c_style_enum1\n-// gdb-check:$3 = CStyleEnumVar1\n+// gdbg-check:$3 = CStyleEnumVar1\n+// gdbr-check:$3 = gdb_pretty_struct_and_enums_pre_gdb_7_7::CStyleEnum::CStyleEnumVar1\n \n // gdb-command: print c_style_enum2\n-// gdb-check:$4 = CStyleEnumVar2\n+// gdbg-check:$4 = CStyleEnumVar2\n+// gdbr-check:$4 = gdb_pretty_struct_and_enums_pre_gdb_7_7::CStyleEnum::CStyleEnumVar2\n \n // gdb-command: print c_style_enum3\n-// gdb-check:$5 = CStyleEnumVar3\n+// gdbg-check:$5 = CStyleEnumVar3\n+// gdbr-check:$5 = gdb_pretty_struct_and_enums_pre_gdb_7_7::CStyleEnum::CStyleEnumVar3\n \n #![allow(dead_code, unused_variables)]\n "}, {"sha": "1fc05b3752f04126b23fef8707aa46317b546150", "filename": "src/test/debuginfo/generic-enum-with-different-disr-sizes.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,22 +18,37 @@\n // gdb-command:run\n \n // gdb-command:print eight_bytes1\n-// gdb-check:$1 = {{RUST$ENUM$DISR = Variant1, __0 = 100}, {RUST$ENUM$DISR = Variant1, __0 = 100}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Variant1, __0 = 100}, {RUST$ENUM$DISR = Variant1, __0 = 100}}\n+// gdbr-check:$1 = generic_enum_with_different_disr_sizes::Enum::Variant1(100)\n+\n // gdb-command:print four_bytes1\n-// gdb-check:$2 = {{RUST$ENUM$DISR = Variant1, __0 = 101}, {RUST$ENUM$DISR = Variant1, __0 = 101}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Variant1, __0 = 101}, {RUST$ENUM$DISR = Variant1, __0 = 101}}\n+// gdbr-check:$2 = generic_enum_with_different_disr_sizes::Enum::Variant1(101)\n+\n // gdb-command:print two_bytes1\n-// gdb-check:$3 = {{RUST$ENUM$DISR = Variant1, __0 = 102}, {RUST$ENUM$DISR = Variant1, __0 = 102}}\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Variant1, __0 = 102}, {RUST$ENUM$DISR = Variant1, __0 = 102}}\n+// gdbr-check:$3 = generic_enum_with_different_disr_sizes::Enum::Variant1(102)\n+\n // gdb-command:print one_byte1\n-// gdb-check:$4 = {{RUST$ENUM$DISR = Variant1, __0 = 65 'A'}, {RUST$ENUM$DISR = Variant1, __0 = 65 'A'}}\n+// gdbg-check:$4 = {{RUST$ENUM$DISR = Variant1, __0 = 65 'A'}, {RUST$ENUM$DISR = Variant1, __0 = 65 'A'}}\n+// gdbr-check:$4 = generic_enum_with_different_disr_sizes::Enum::Variant1(65)\n+\n \n // gdb-command:print eight_bytes2\n-// gdb-check:$5 = {{RUST$ENUM$DISR = Variant2, __0 = 100}, {RUST$ENUM$DISR = Variant2, __0 = 100}}\n+// gdbg-check:$5 = {{RUST$ENUM$DISR = Variant2, __0 = 100}, {RUST$ENUM$DISR = Variant2, __0 = 100}}\n+// gdbr-check:$5 = generic_enum_with_different_disr_sizes::Enum::Variant2(100)\n+\n // gdb-command:print four_bytes2\n-// gdb-check:$6 = {{RUST$ENUM$DISR = Variant2, __0 = 101}, {RUST$ENUM$DISR = Variant2, __0 = 101}}\n+// gdbg-check:$6 = {{RUST$ENUM$DISR = Variant2, __0 = 101}, {RUST$ENUM$DISR = Variant2, __0 = 101}}\n+// gdbr-check:$6 = generic_enum_with_different_disr_sizes::Enum::Variant2(101)\n+\n // gdb-command:print two_bytes2\n-// gdb-check:$7 = {{RUST$ENUM$DISR = Variant2, __0 = 102}, {RUST$ENUM$DISR = Variant2, __0 = 102}}\n+// gdbg-check:$7 = {{RUST$ENUM$DISR = Variant2, __0 = 102}, {RUST$ENUM$DISR = Variant2, __0 = 102}}\n+// gdbr-check:$7 = generic_enum_with_different_disr_sizes::Enum::Variant2(102)\n+\n // gdb-command:print one_byte2\n-// gdb-check:$8 = {{RUST$ENUM$DISR = Variant2, __0 = 65 'A'}, {RUST$ENUM$DISR = Variant2, __0 = 65 'A'}}\n+// gdbg-check:$8 = {{RUST$ENUM$DISR = Variant2, __0 = 65 'A'}, {RUST$ENUM$DISR = Variant2, __0 = 65 'A'}}\n+// gdbr-check:$8 = generic_enum_with_different_disr_sizes::Enum::Variant2(65)\n \n // gdb-command:continue\n "}, {"sha": "f1bfc08915edd86258f6e1a0af53dcf2215fffed", "filename": "src/test/debuginfo/generic-function.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgeneric-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgeneric-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-function.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n // min-lldb-version: 310\n \n // compile-flags:-g\n@@ -21,23 +23,27 @@\n // gdb-command:print *t1\n // gdb-check:$2 = 2.5\n // gdb-command:print ret\n-// gdb-check:$3 = {__0 = {__0 = 1, __1 = 2.5}, __1 = {__0 = 2.5, __1 = 1}}\n+// gdbg-check:$3 = {__0 = {__0 = 1, __1 = 2.5}, __1 = {__0 = 2.5, __1 = 1}}\n+// gdbr-check:$3 = ((1, 2.5), (2.5, 1))\n // gdb-command:continue\n \n // gdb-command:print *t0\n // gdb-check:$4 = 3.5\n // gdb-command:print *t1\n // gdb-check:$5 = 4\n // gdb-command:print ret\n-// gdb-check:$6 = {__0 = {__0 = 3.5, __1 = 4}, __1 = {__0 = 4, __1 = 3.5}}\n+// gdbg-check:$6 = {__0 = {__0 = 3.5, __1 = 4}, __1 = {__0 = 4, __1 = 3.5}}\n+// gdbr-check:$6 = ((3.5, 4), (4, 3.5))\n // gdb-command:continue\n \n // gdb-command:print *t0\n // gdb-check:$7 = 5\n // gdb-command:print *t1\n-// gdb-check:$8 = {a = 6, b = 7.5}\n+// gdbg-check:$8 = {a = 6, b = 7.5}\n+// gdbr-check:$8 = generic_function::Struct {a: 6, b: 7.5}\n // gdb-command:print ret\n-// gdb-check:$9 = {__0 = {__0 = 5, __1 = {a = 6, b = 7.5}}, __1 = {__0 = {a = 6, b = 7.5}, __1 = 5}}\n+// gdbg-check:$9 = {__0 = {__0 = 5, __1 = {a = 6, b = 7.5}}, __1 = {__0 = {a = 6, b = 7.5}, __1 = 5}}\n+// gdbr-check:$9 = ((5, generic_function::Struct {a: 6, b: 7.5}), (generic_function::Struct {a: 6, b: 7.5}, 5))\n // gdb-command:continue\n \n "}, {"sha": "4f3f6dfc821eef4d589405ed70559aaca94c3a3e", "filename": "src/test/debuginfo/generic-method-on-generic-struct.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,7 +18,8 @@\n \n // STACK BY REF\n // gdb-command:print *self\n-// gdb-check:$1 = {x = {__0 = 8888, __1 = -8888}}\n+// gdbg-check:$1 = {x = {__0 = 8888, __1 = -8888}}\n+// gdbr-check:$1 = generic_method_on_generic_struct::Struct<(u32, i32)> {x: (8888, -8888)}\n // gdb-command:print arg1\n // gdb-check:$2 = -1\n // gdb-command:print arg2\n@@ -27,7 +28,8 @@\n \n // STACK BY VAL\n // gdb-command:print self\n-// gdb-check:$4 = {x = {__0 = 8888, __1 = -8888}}\n+// gdbg-check:$4 = {x = {__0 = 8888, __1 = -8888}}\n+// gdbr-check:$4 = generic_method_on_generic_struct::Struct<(u32, i32)> {x: (8888, -8888)}\n // gdb-command:print arg1\n // gdb-check:$5 = -3\n // gdb-command:print arg2\n@@ -36,7 +38,8 @@\n \n // OWNED BY REF\n // gdb-command:print *self\n-// gdb-check:$7 = {x = 1234.5}\n+// gdbg-check:$7 = {x = 1234.5}\n+// gdbr-check:$7 = generic_method_on_generic_struct::Struct<f64> {x: 1234.5}\n // gdb-command:print arg1\n // gdb-check:$8 = -5\n // gdb-command:print arg2\n@@ -45,7 +48,8 @@\n \n // OWNED BY VAL\n // gdb-command:print self\n-// gdb-check:$10 = {x = 1234.5}\n+// gdbg-check:$10 = {x = 1234.5}\n+// gdbr-check:$10 = generic_method_on_generic_struct::Struct<f64> {x: 1234.5}\n // gdb-command:print arg1\n // gdb-check:$11 = -7\n // gdb-command:print arg2\n@@ -54,7 +58,8 @@\n \n // OWNED MOVED\n // gdb-command:print *self\n-// gdb-check:$13 = {x = 1234.5}\n+// gdbg-check:$13 = {x = 1234.5}\n+// gdbr-check:$13 = generic_method_on_generic_struct::Struct<f64> {x: 1234.5}\n // gdb-command:print arg1\n // gdb-check:$14 = -9\n // gdb-command:print arg2"}, {"sha": "dba9422721a9665674836c339b39f176473bb505", "filename": "src/test/debuginfo/generic-struct-style-enum.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -17,16 +17,20 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdb-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, a = 0, b = 2088533116, c = 2088533116}, {RUST$ENUM$DISR = Case1, a = 0, b = 8970181431921507452}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, a = 0, b = 2088533116, c = 2088533116}, {RUST$ENUM$DISR = Case1, a = 0, b = 8970181431921507452}}\n+// gdbr-check:$1 = generic_struct_style_enum::Regular::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n \n // gdb-command:print case2\n-// gdb-check:$2 = {{RUST$ENUM$DISR = Case2, a = 0, b = 4369, c = 4369, d = 4369, e = 4369}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, a = 0, b = 1229782938247303441}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, a = 0, b = 4369, c = 4369, d = 4369, e = 4369}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, a = 0, b = 1229782938247303441}}\n+// gdbr-check:$2 = generic_struct_style_enum::Regular::Case2{a: 0, b: 286331153, c: 286331153}\n \n // gdb-command:print case3\n-// gdb-check:$3 = {{RUST$ENUM$DISR = Case3, a = 0, b = 22873, c = 22873, d = 22873, e = 22873}, {RUST$ENUM$DISR = Case3, a = 0, b = 1499027801, c = 1499027801}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, a = 0, b = 22873, c = 22873, d = 22873, e = 22873}, {RUST$ENUM$DISR = Case3, a = 0, b = 1499027801, c = 1499027801}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n+// gdbr-check:$3 = generic_struct_style_enum::Regular::Case3{a: 0, b: 6438275382588823897}\n \n // gdb-command:print univariant\n-// gdb-check:$4 = {{a = -1}}\n+// gdbg-check:$4 = {{a = -1}}\n+// gdbr-check:$4 = generic_struct_style_enum::Univariant<i32>::TheOnlyCase{a: -1}\n \n \n #![feature(omit_gdb_pretty_printer_section)]"}, {"sha": "35f00ce78717b59901fc5f8cd3cc26725e710c59", "filename": "src/test/debuginfo/generic-struct.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgeneric-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgeneric-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,13 +18,17 @@\n // gdb-command:run\n \n // gdb-command:print int_int\n-// gdb-check:$1 = {key = 0, value = 1}\n+// gdbg-check:$1 = {key = 0, value = 1}\n+// gdbr-check:$1 = generic_struct::AGenericStruct<i32, i32> {key: 0, value: 1}\n // gdb-command:print int_float\n-// gdb-check:$2 = {key = 2, value = 3.5}\n+// gdbg-check:$2 = {key = 2, value = 3.5}\n+// gdbr-check:$2 = generic_struct::AGenericStruct<i32, f64> {key: 2, value: 3.5}\n // gdb-command:print float_int\n-// gdb-check:$3 = {key = 4.5, value = 5}\n+// gdbg-check:$3 = {key = 4.5, value = 5}\n+// gdbr-check:$3 = generic_struct::AGenericStruct<f64, i32> {key: 4.5, value: 5}\n // gdb-command:print float_int_float\n-// gdb-check:$4 = {key = 6.5, value = {key = 7, value = 8.5}}\n+// gdbg-check:$4 = {key = 6.5, value = {key = 7, value = 8.5}}\n+// gdbr-check:$4 = generic_struct::AGenericStruct<f64, generic_struct::AGenericStruct<i32, f64>> {key: 6.5, value: generic_struct::AGenericStruct<i32, f64> {key: 7, value: 8.5}}\n \n // === LLDB TESTS ==================================================================================\n "}, {"sha": "01d2ff4e334397ae7e3727a42b86c3343cbfb07b", "filename": "src/test/debuginfo/generic-tuple-style-enum.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -19,16 +19,20 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdb-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 2088533116, __2 = 2088533116}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 8970181431921507452}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 2088533116, __2 = 2088533116}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 8970181431921507452}}\n+// gdbr-check:$1 = generic_tuple_style_enum::Regular::Case1(0, 31868, 31868, 31868, 31868)\n \n // gdb-command:print case2\n-// gdb-check:$2 = {{RUST$ENUM$DISR = Case2, __0 = 0, __1 = 4369, __2 = 4369, __3 = 4369, __4 = 4369}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 1229782938247303441}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, __0 = 0, __1 = 4369, __2 = 4369, __3 = 4369, __4 = 4369}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 1229782938247303441}}\n+// gdbr-check:$2 = generic_tuple_style_enum::Regular::Case2(0, 286331153, 286331153)\n \n // gdb-command:print case3\n-// gdb-check:$3 = {{RUST$ENUM$DISR = Case3, __0 = 0, __1 = 22873, __2 = 22873, __3 = 22873, __4 = 22873}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 1499027801, __2 = 1499027801}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, __0 = 0, __1 = 22873, __2 = 22873, __3 = 22873, __4 = 22873}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 1499027801, __2 = 1499027801}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n+// gdbr-check:$3 = generic_tuple_style_enum::Regular::Case3(0, 6438275382588823897)\n \n // gdb-command:print univariant\n-// gdb-check:$4 = {{__0 = -1}}\n+// gdbg-check:$4 = {{__0 = -1}}\n+// gdbr-check:$4 = generic_tuple_style_enum::Univariant<i64>::TheOnlyCase(-1)\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "8e8a194e37841d5fd58a4fbc92236ccf1eded99f", "filename": "src/test/debuginfo/lexical-scopes-in-block-expression.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -16,7 +16,8 @@\n \n // gdb-command:run\n \n-// gdb-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbg-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbr-command:print lexical_scopes_in_block_expression::MUT_INT\n // gdb-check:$1 = 0\n \n // STRUCT EXPRESSION\n@@ -28,7 +29,8 @@\n \n // gdb-command:print val\n // gdb-check:$4 = 11\n-// gdb-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbg-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbr-command:print lexical_scopes_in_block_expression::MUT_INT\n // gdb-check:$5 = 1\n // gdb-command:print ten\n // gdb-check:$6 = 10\n@@ -49,7 +51,8 @@\n \n // gdb-command:print val\n // gdb-check:$11 = 12\n-// gdb-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbg-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbr-command:print lexical_scopes_in_block_expression::MUT_INT\n // gdb-check:$12 = 2\n // gdb-command:print ten\n // gdb-check:$13 = 10\n@@ -70,7 +73,8 @@\n \n // gdb-command:print val\n // gdb-check:$18 = 13\n-// gdb-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbg-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbr-command:print lexical_scopes_in_block_expression::MUT_INT\n // gdb-check:$19 = 3\n // gdb-command:print ten\n // gdb-check:$20 = 10\n@@ -91,7 +95,8 @@\n \n // gdb-command:print val\n // gdb-check:$25 = 14\n-// gdb-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbg-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbr-command:print lexical_scopes_in_block_expression::MUT_INT\n // gdb-check:$26 = 4\n // gdb-command:print ten\n // gdb-check:$27 = 10\n@@ -112,7 +117,8 @@\n \n // gdb-command:print val\n // gdb-check:$32 = 15\n-// gdb-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbg-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbr-command:print lexical_scopes_in_block_expression::MUT_INT\n // gdb-check:$33 = 5\n // gdb-command:print ten\n // gdb-check:$34 = 10\n@@ -133,7 +139,8 @@\n \n // gdb-command:print val\n // gdb-check:$39 = 16\n-// gdb-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbg-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbr-command:print lexical_scopes_in_block_expression::MUT_INT\n // gdb-check:$40 = 6\n // gdb-command:print ten\n // gdb-check:$41 = 10\n@@ -155,7 +162,8 @@\n \n // gdb-command:print val\n // gdb-check:$46 = 17\n-// gdb-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbg-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbr-command:print lexical_scopes_in_block_expression::MUT_INT\n // gdb-check:$47 = 7\n // gdb-command:print ten\n // gdb-check:$48 = 10\n@@ -176,7 +184,8 @@\n \n // gdb-command:print val\n // gdb-check:$53 = 18\n-// gdb-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbg-command:print 'lexical_scopes_in_block_expression::MUT_INT'\n+// gdbr-command:print lexical_scopes_in_block_expression::MUT_INT\n // gdb-check:$54 = 8\n // gdb-command:print ten\n // gdb-check:$55 = 10"}, {"sha": "7dbc0d3c5130ddd4c0b00e58e68de21675c91ab0", "filename": "src/test/debuginfo/method-on-enum.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -19,7 +19,8 @@\n \n // STACK BY REF\n // gdb-command:print *self\n-// gdb-check:$1 = {{RUST$ENUM$DISR = Variant2, [...]}, {RUST$ENUM$DISR = Variant2, __0 = 117901063}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Variant2, [...]}, {RUST$ENUM$DISR = Variant2, __0 = 117901063}}\n+// gdbr-check:$1 = method_on_enum::Enum::Variant2(117901063)\n // gdb-command:print arg1\n // gdb-check:$2 = -1\n // gdb-command:print arg2\n@@ -28,7 +29,8 @@\n \n // STACK BY VAL\n // gdb-command:print self\n-// gdb-check:$4 = {{RUST$ENUM$DISR = Variant2, [...]}, {RUST$ENUM$DISR = Variant2, __0 = 117901063}}\n+// gdbg-check:$4 = {{RUST$ENUM$DISR = Variant2, [...]}, {RUST$ENUM$DISR = Variant2, __0 = 117901063}}\n+// gdbr-check:$4 = method_on_enum::Enum::Variant2(117901063)\n // gdb-command:print arg1\n // gdb-check:$5 = -3\n // gdb-command:print arg2\n@@ -37,7 +39,8 @@\n \n // OWNED BY REF\n // gdb-command:print *self\n-// gdb-check:$7 = {{RUST$ENUM$DISR = Variant1, x = 1799, y = 1799}, {RUST$ENUM$DISR = Variant1, [...]}}\n+// gdbg-check:$7 = {{RUST$ENUM$DISR = Variant1, x = 1799, y = 1799}, {RUST$ENUM$DISR = Variant1, [...]}}\n+// gdbr-check:$7 = method_on_enum::Enum::Variant1{x: 1799, y: 1799}\n // gdb-command:print arg1\n // gdb-check:$8 = -5\n // gdb-command:print arg2\n@@ -46,7 +49,8 @@\n \n // OWNED BY VAL\n // gdb-command:print self\n-// gdb-check:$10 = {{RUST$ENUM$DISR = Variant1, x = 1799, y = 1799}, {RUST$ENUM$DISR = Variant1, [...]}}\n+// gdbg-check:$10 = {{RUST$ENUM$DISR = Variant1, x = 1799, y = 1799}, {RUST$ENUM$DISR = Variant1, [...]}}\n+// gdbr-check:$10 = method_on_enum::Enum::Variant1{x: 1799, y: 1799}\n // gdb-command:print arg1\n // gdb-check:$11 = -7\n // gdb-command:print arg2\n@@ -55,7 +59,8 @@\n \n // OWNED MOVED\n // gdb-command:print *self\n-// gdb-check:$13 = {{RUST$ENUM$DISR = Variant1, x = 1799, y = 1799}, {RUST$ENUM$DISR = Variant1, [...]}}\n+// gdbg-check:$13 = {{RUST$ENUM$DISR = Variant1, x = 1799, y = 1799}, {RUST$ENUM$DISR = Variant1, [...]}}\n+// gdbr-check:$13 = method_on_enum::Enum::Variant1{x: 1799, y: 1799}\n // gdb-command:print arg1\n // gdb-check:$14 = -9\n // gdb-command:print arg2"}, {"sha": "20d419b4ac088357c00520dc58cbc8fe0079cd17", "filename": "src/test/debuginfo/method-on-generic-struct.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fmethod-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fmethod-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-generic-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,7 +18,8 @@\n \n // STACK BY REF\n // gdb-command:print *self\n-// gdb-check:$1 = {x = {__0 = 8888, __1 = -8888}}\n+// gdbg-check:$1 = {x = {__0 = 8888, __1 = -8888}}\n+// gdbr-check:$1 = method_on_generic_struct::Struct<(u32, i32)> {x: (8888, -8888)}\n // gdb-command:print arg1\n // gdb-check:$2 = -1\n // gdb-command:print arg2\n@@ -27,7 +28,8 @@\n \n // STACK BY VAL\n // gdb-command:print self\n-// gdb-check:$4 = {x = {__0 = 8888, __1 = -8888}}\n+// gdbg-check:$4 = {x = {__0 = 8888, __1 = -8888}}\n+// gdbr-check:$4 = method_on_generic_struct::Struct<(u32, i32)> {x: (8888, -8888)}\n // gdb-command:print arg1\n // gdb-check:$5 = -3\n // gdb-command:print arg2\n@@ -36,7 +38,8 @@\n \n // OWNED BY REF\n // gdb-command:print *self\n-// gdb-check:$7 = {x = 1234.5}\n+// gdbg-check:$7 = {x = 1234.5}\n+// gdbr-check:$7 = method_on_generic_struct::Struct<f64> {x: 1234.5}\n // gdb-command:print arg1\n // gdb-check:$8 = -5\n // gdb-command:print arg2\n@@ -45,7 +48,8 @@\n \n // OWNED BY VAL\n // gdb-command:print self\n-// gdb-check:$10 = {x = 1234.5}\n+// gdbg-check:$10 = {x = 1234.5}\n+// gdbr-check:$10 = method_on_generic_struct::Struct<f64> {x: 1234.5}\n // gdb-command:print arg1\n // gdb-check:$11 = -7\n // gdb-command:print arg2\n@@ -54,7 +58,8 @@\n \n // OWNED MOVED\n // gdb-command:print *self\n-// gdb-check:$13 = {x = 1234.5}\n+// gdbg-check:$13 = {x = 1234.5}\n+// gdbr-check:$13 = method_on_generic_struct::Struct<f64> {x: 1234.5}\n // gdb-command:print arg1\n // gdb-check:$14 = -9\n // gdb-command:print arg2"}, {"sha": "c7546fe2221ff60365d8e6e1b7ca460f791bb73e", "filename": "src/test/debuginfo/method-on-struct.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fmethod-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fmethod-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,7 +18,8 @@\n \n // STACK BY REF\n // gdb-command:print *self\n-// gdb-check:$1 = {x = 100}\n+// gdbg-check:$1 = {x = 100}\n+// gdbr-check:$1 = method_on_struct::Struct {x: 100}\n // gdb-command:print arg1\n // gdb-check:$2 = -1\n // gdb-command:print arg2\n@@ -27,7 +28,8 @@\n \n // STACK BY VAL\n // gdb-command:print self\n-// gdb-check:$4 = {x = 100}\n+// gdbg-check:$4 = {x = 100}\n+// gdbr-check:$4 = method_on_struct::Struct {x: 100}\n // gdb-command:print arg1\n // gdb-check:$5 = -3\n // gdb-command:print arg2\n@@ -36,7 +38,8 @@\n \n // OWNED BY REF\n // gdb-command:print *self\n-// gdb-check:$7 = {x = 200}\n+// gdbg-check:$7 = {x = 200}\n+// gdbr-check:$7 = method_on_struct::Struct {x: 200}\n // gdb-command:print arg1\n // gdb-check:$8 = -5\n // gdb-command:print arg2\n@@ -45,7 +48,8 @@\n \n // OWNED BY VAL\n // gdb-command:print self\n-// gdb-check:$10 = {x = 200}\n+// gdbg-check:$10 = {x = 200}\n+// gdbr-check:$10 = method_on_struct::Struct {x: 200}\n // gdb-command:print arg1\n // gdb-check:$11 = -7\n // gdb-command:print arg2\n@@ -54,7 +58,8 @@\n \n // OWNED MOVED\n // gdb-command:print *self\n-// gdb-check:$13 = {x = 200}\n+// gdbg-check:$13 = {x = 200}\n+// gdbr-check:$13 = method_on_struct::Struct {x: 200}\n // gdb-command:print arg1\n // gdb-check:$14 = -9\n // gdb-command:print arg2"}, {"sha": "1dc37bb06ac40eadc8b9668febd69ec21ced572e", "filename": "src/test/debuginfo/method-on-trait.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fmethod-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fmethod-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-trait.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,7 +18,8 @@\n \n // STACK BY REF\n // gdb-command:print *self\n-// gdb-check:$1 = {x = 100}\n+// gdbg-check:$1 = {x = 100}\n+// gdbr-check:$1 = method_on_trait::Struct {x: 100}\n // gdb-command:print arg1\n // gdb-check:$2 = -1\n // gdb-command:print arg2\n@@ -27,7 +28,8 @@\n \n // STACK BY VAL\n // gdb-command:print self\n-// gdb-check:$4 = {x = 100}\n+// gdbg-check:$4 = {x = 100}\n+// gdbr-check:$4 = method_on_trait::Struct {x: 100}\n // gdb-command:print arg1\n // gdb-check:$5 = -3\n // gdb-command:print arg2\n@@ -36,7 +38,8 @@\n \n // OWNED BY REF\n // gdb-command:print *self\n-// gdb-check:$7 = {x = 200}\n+// gdbg-check:$7 = {x = 200}\n+// gdbr-check:$7 = method_on_trait::Struct {x: 200}\n // gdb-command:print arg1\n // gdb-check:$8 = -5\n // gdb-command:print arg2\n@@ -45,7 +48,8 @@\n \n // OWNED BY VAL\n // gdb-command:print self\n-// gdb-check:$10 = {x = 200}\n+// gdbg-check:$10 = {x = 200}\n+// gdbr-check:$10 = method_on_trait::Struct {x: 200}\n // gdb-command:print arg1\n // gdb-check:$11 = -7\n // gdb-command:print arg2\n@@ -54,7 +58,8 @@\n \n // OWNED MOVED\n // gdb-command:print *self\n-// gdb-check:$13 = {x = 200}\n+// gdbg-check:$13 = {x = 200}\n+// gdbr-check:$13 = method_on_trait::Struct {x: 200}\n // gdb-command:print arg1\n // gdb-check:$14 = -9\n // gdb-command:print arg2"}, {"sha": "dac762ae0c35bde7d36881afac4369a9bf2452dd", "filename": "src/test/debuginfo/method-on-tuple-struct.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,7 +18,8 @@\n \n // STACK BY REF\n // gdb-command:print *self\n-// gdb-check:$1 = {__0 = 100, __1 = -100.5}\n+// gdbg-check:$1 = {__0 = 100, __1 = -100.5}\n+// gdbr-check:$1 = method_on_tuple_struct::TupleStruct (100, -100.5)\n // gdb-command:print arg1\n // gdb-check:$2 = -1\n // gdb-command:print arg2\n@@ -27,7 +28,8 @@\n \n // STACK BY VAL\n // gdb-command:print self\n-// gdb-check:$4 = {__0 = 100, __1 = -100.5}\n+// gdbg-check:$4 = {__0 = 100, __1 = -100.5}\n+// gdbr-check:$4 = method_on_tuple_struct::TupleStruct (100, -100.5)\n // gdb-command:print arg1\n // gdb-check:$5 = -3\n // gdb-command:print arg2\n@@ -36,7 +38,8 @@\n \n // OWNED BY REF\n // gdb-command:print *self\n-// gdb-check:$7 = {__0 = 200, __1 = -200.5}\n+// gdbg-check:$7 = {__0 = 200, __1 = -200.5}\n+// gdbr-check:$7 = method_on_tuple_struct::TupleStruct (200, -200.5)\n // gdb-command:print arg1\n // gdb-check:$8 = -5\n // gdb-command:print arg2\n@@ -45,7 +48,8 @@\n \n // OWNED BY VAL\n // gdb-command:print self\n-// gdb-check:$10 = {__0 = 200, __1 = -200.5}\n+// gdbg-check:$10 = {__0 = 200, __1 = -200.5}\n+// gdbr-check:$10 = method_on_tuple_struct::TupleStruct (200, -200.5)\n // gdb-command:print arg1\n // gdb-check:$11 = -7\n // gdb-command:print arg2\n@@ -54,7 +58,8 @@\n \n // OWNED MOVED\n // gdb-command:print *self\n-// gdb-check:$13 = {__0 = 200, __1 = -200.5}\n+// gdbg-check:$13 = {__0 = 200, __1 = -200.5}\n+// gdbr-check:$13 = method_on_tuple_struct::TupleStruct (200, -200.5)\n // gdb-command:print arg1\n // gdb-check:$14 = -9\n // gdb-command:print arg2"}, {"sha": "94377421c0b0c9927a039b26970371581d959315", "filename": "src/test/debuginfo/nil-enum.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -16,10 +16,12 @@\n // gdb-command:run\n \n // gdb-command:print first\n-// gdb-check:$1 = {<No data fields>}\n+// gdbg-check:$1 = {<No data fields>}\n+// gdbr-check:$1 = <error reading variable>\n \n // gdb-command:print second\n-// gdb-check:$2 = {<No data fields>}\n+// gdbg-check:$2 = {<No data fields>}\n+// gdbr-check:$2 = <error reading variable>\n \n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]\n@@ -28,8 +30,9 @@\n enum ANilEnum {}\n enum AnotherNilEnum {}\n \n-// This test relies on gdb printing the string \"{<No data fields>}\" for empty\n+// This test relies on gdbg printing the string \"{<No data fields>}\" for empty\n // structs (which may change some time)\n+// The error from gdbr is expected since nil enums are not supposed to exist.\n fn main() {\n     unsafe {\n         let first: ANilEnum = ::std::mem::zeroed();"}, {"sha": "39e6a4e4facf9a9a03833964b7deccfe6d354ee4", "filename": "src/test/debuginfo/option-like-enum.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,28 +18,36 @@\n // gdb-command:run\n \n // gdb-command:print some\n-// gdb-check:$1 = {RUST$ENCODED$ENUM$0$None = {__0 = 0x12345678}}\n+// gdbg-check:$1 = {RUST$ENCODED$ENUM$0$None = {__0 = 0x12345678}}\n+// gdbr-check:$1 = core::option::Option<&u32>::Some(0x12345678)\n \n // gdb-command:print none\n-// gdb-check:$2 = {RUST$ENCODED$ENUM$0$None = {__0 = 0x0}}\n+// gdbg-check:$2 = {RUST$ENCODED$ENUM$0$None = {__0 = 0x0}}\n+// gdbr-check:$2 = core::option::Option<&u32>::None\n \n // gdb-command:print full\n-// gdb-check:$3 = {RUST$ENCODED$ENUM$1$Empty = {__0 = 454545, __1 = 0x87654321, __2 = 9988}}\n+// gdbg-check:$3 = {RUST$ENCODED$ENUM$1$Empty = {__0 = 454545, __1 = 0x87654321, __2 = 9988}}\n+// gdbr-check:$3 = option_like_enum::MoreFields::Full(454545, 0x87654321, 9988)\n \n-// gdb-command:print empty_gdb->discr\n+// gdbg-command:print empty_gdb->discr\n+// gdbr-command:print empty_gdb.discr\n // gdb-check:$4 = (isize *) 0x0\n \n // gdb-command:print droid\n-// gdb-check:$5 = {RUST$ENCODED$ENUM$2$Void = {id = 675675, range = 10000001, internals = 0x43218765}}\n+// gdbg-check:$5 = {RUST$ENCODED$ENUM$2$Void = {id = 675675, range = 10000001, internals = 0x43218765}}\n+// gdbr-check:$5 = option_like_enum::NamedFields::Droid{id: 675675, range: 10000001, internals: 0x43218765}\n \n-// gdb-command:print void_droid_gdb->internals\n+// gdbg-command:print void_droid_gdb->internals\n+// gdbr-command:print void_droid_gdb.internals\n // gdb-check:$6 = (isize *) 0x0\n \n // gdb-command:print nested_non_zero_yep\n-// gdb-check:$7 = {RUST$ENCODED$ENUM$1$2$Nope = {__0 = 10.5, __1 = {a = 10, b = 20, c = [...]}}}\n+// gdbg-check:$7 = {RUST$ENCODED$ENUM$1$2$Nope = {__0 = 10.5, __1 = {a = 10, b = 20, c = [...]}}}\n+// gdbr-check:$7 = option_like_enum::NestedNonZero::Yep(10.5, option_like_enum::NestedNonZeroField {a: 10, b: 20, c: 0x[...] \"x[...]\"})\n \n // gdb-command:print nested_non_zero_nope\n-// gdb-check:$8 = {RUST$ENCODED$ENUM$1$2$Nope = {__0 = [...], __1 = {a = [...], b = [...], c = 0x0}}}\n+// gdbg-check:$8 = {RUST$ENCODED$ENUM$1$2$Nope = {__0 = [...], __1 = {a = [...], b = [...], c = 0x0}}}\n+// gdbr-check:$8 = option_like_enum::NestedNonZero::Nope\n \n // gdb-command:continue\n "}, {"sha": "50bd857d460763c766cc7f87eda744e7ab153a9a", "filename": "src/test/debuginfo/packed-struct-with-destructor.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,29 +18,37 @@\n // gdb-command:run\n \n // gdb-command:print packed\n-// gdb-check:$1 = {x = 123, y = 234, z = 345}\n+// gdbg-check:$1 = {x = 123, y = 234, z = 345}\n+// gdbr-check:$1 = packed_struct_with_destructor::Packed {x: 123, y: 234, z: 345}\n \n // gdb-command:print packedInPacked\n-// gdb-check:$2 = {a = 1111, b = {x = 2222, y = 3333, z = 4444}, c = 5555, d = {x = 6666, y = 7777, z = 8888}}\n+// gdbg-check:$2 = {a = 1111, b = {x = 2222, y = 3333, z = 4444}, c = 5555, d = {x = 6666, y = 7777, z = 8888}}\n+// gdbr-check:$2 = packed_struct_with_destructor::PackedInPacked {a: 1111, b: packed_struct_with_destructor::Packed {x: 2222, y: 3333, z: 4444}, c: 5555, d: packed_struct_with_destructor::Packed {x: 6666, y: 7777, z: 8888}}\n \n // gdb-command:print packedInUnpacked\n-// gdb-check:$3 = {a = -1111, b = {x = -2222, y = -3333, z = -4444}, c = -5555, d = {x = -6666, y = -7777, z = -8888}}\n+// gdbg-check:$3 = {a = -1111, b = {x = -2222, y = -3333, z = -4444}, c = -5555, d = {x = -6666, y = -7777, z = -8888}}\n+// gdbr-check:$3 = packed_struct_with_destructor::PackedInUnpacked {a: -1111, b: packed_struct_with_destructor::Packed {x: -2222, y: -3333, z: -4444}, c: -5555, d: packed_struct_with_destructor::Packed {x: -6666, y: -7777, z: -8888}}\n \n // gdb-command:print unpackedInPacked\n-// gdb-check:$4 = {a = 987, b = {x = 876, y = 765, z = 654}, c = {x = 543, y = 432, z = 321}, d = 210}\n+// gdbg-check:$4 = {a = 987, b = {x = 876, y = 765, z = 654}, c = {x = 543, y = 432, z = 321}, d = 210}\n+// gdbr-check:$4 = packed_struct_with_destructor::UnpackedInPacked {a: 987, b: packed_struct_with_destructor::Unpacked {x: 876, y: 765, z: 654}, c: packed_struct_with_destructor::Unpacked {x: 543, y: 432, z: 321}, d: 210}\n \n \n // gdb-command:print packedInPackedWithDrop\n-// gdb-check:$5 = {a = 11, b = {x = 22, y = 33, z = 44}, c = 55, d = {x = 66, y = 77, z = 88}}\n+// gdbg-check:$5 = {a = 11, b = {x = 22, y = 33, z = 44}, c = 55, d = {x = 66, y = 77, z = 88}}\n+// gdbr-check:$5 = packed_struct_with_destructor::PackedInPackedWithDrop {a: 11, b: packed_struct_with_destructor::Packed {x: 22, y: 33, z: 44}, c: 55, d: packed_struct_with_destructor::Packed {x: 66, y: 77, z: 88}}\n \n // gdb-command:print packedInUnpackedWithDrop\n-// gdb-check:$6 = {a = -11, b = {x = -22, y = -33, z = -44}, c = -55, d = {x = -66, y = -77, z = -88}}\n+// gdbg-check:$6 = {a = -11, b = {x = -22, y = -33, z = -44}, c = -55, d = {x = -66, y = -77, z = -88}}\n+// gdbr-check:$6 = packed_struct_with_destructor::PackedInUnpackedWithDrop {a: -11, b: packed_struct_with_destructor::Packed {x: -22, y: -33, z: -44}, c: -55, d: packed_struct_with_destructor::Packed {x: -66, y: -77, z: -88}}\n \n // gdb-command:print unpackedInPackedWithDrop\n-// gdb-check:$7 = {a = 98, b = {x = 87, y = 76, z = 65}, c = {x = 54, y = 43, z = 32}, d = 21}\n+// gdbg-check:$7 = {a = 98, b = {x = 87, y = 76, z = 65}, c = {x = 54, y = 43, z = 32}, d = 21}\n+// gdbr-check:$7 = packed_struct_with_destructor::UnpackedInPackedWithDrop {a: 98, b: packed_struct_with_destructor::Unpacked {x: 87, y: 76, z: 65}, c: packed_struct_with_destructor::Unpacked {x: 54, y: 43, z: 32}, d: 21}\n \n // gdb-command:print deeplyNested\n-// gdb-check:$8 = {a = {a = 1, b = {x = 2, y = 3, z = 4}, c = 5, d = {x = 6, y = 7, z = 8}}, b = {a = 9, b = {x = 10, y = 11, z = 12}, c = {x = 13, y = 14, z = 15}, d = 16}, c = {a = 17, b = {x = 18, y = 19, z = 20}, c = 21, d = {x = 22, y = 23, z = 24}}, d = {a = 25, b = {x = 26, y = 27, z = 28}, c = 29, d = {x = 30, y = 31, z = 32}}, e = {a = 33, b = {x = 34, y = 35, z = 36}, c = {x = 37, y = 38, z = 39}, d = 40}, f = {a = 41, b = {x = 42, y = 43, z = 44}, c = 45, d = {x = 46, y = 47, z = 48}}}\n+// gdbg-check:$8 = {a = {a = 1, b = {x = 2, y = 3, z = 4}, c = 5, d = {x = 6, y = 7, z = 8}}, b = {a = 9, b = {x = 10, y = 11, z = 12}, c = {x = 13, y = 14, z = 15}, d = 16}, c = {a = 17, b = {x = 18, y = 19, z = 20}, c = 21, d = {x = 22, y = 23, z = 24}}, d = {a = 25, b = {x = 26, y = 27, z = 28}, c = 29, d = {x = 30, y = 31, z = 32}}, e = {a = 33, b = {x = 34, y = 35, z = 36}, c = {x = 37, y = 38, z = 39}, d = 40}, f = {a = 41, b = {x = 42, y = 43, z = 44}, c = 45, d = {x = 46, y = 47, z = 48}}}\n+// gdbr-check:$8 = packed_struct_with_destructor::DeeplyNested {a: packed_struct_with_destructor::PackedInPacked {a: 1, b: packed_struct_with_destructor::Packed {x: 2, y: 3, z: 4}, c: 5, d: packed_struct_with_destructor::Packed {x: 6, y: 7, z: 8}}, b: packed_struct_with_destructor::UnpackedInPackedWithDrop {a: 9, b: packed_struct_with_destructor::Unpacked {x: 10, y: 11, z: 12}, c: packed_struct_with_destructor::Unpacked {x: 13, y: 14, z: 15}, d: 16}, c: packed_struct_with_destructor::PackedInUnpacked {a: 17, b: packed_struct_with_destructor::Packed {x: 18, y: 19, z: 20}, c: 21, d: packed_struct_with_destructor::Packed {x: 22, y: 23, z: 24}}, d: packed_struct_with_destructor::PackedInUnpackedWithDrop {a: 25, b: packed_struct_with_destructor::Packed {x: 26, y: 27, z: 28}, c: 29, d: packed_struct_with_destructor::Packed {x: 30, y: 31, z: 32}}, e: packed_struct_with_destructor::UnpackedInPacked {a: 33, b: packed_struct_with_destructor::Unpacked {x: 34, y: 35, z: 36}, c: packed_struct_with_destructor::Unpacked {x: 37, y: 38, z: 39}, d: 40}, f: packed_struct_with_destructor::PackedInPackedWithDrop {a: 41, b: packed_struct_with_destructor::Packed {x: 42, y: 43, z: 44}, c: 45, d: packed_struct_with_destructor::Packed {x: 46, y: 47, z: 48}}}\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "b84161c36a557e78e1bcdce044bfe56feed1ff69", "filename": "src/test/debuginfo/packed-struct.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,16 +18,20 @@\n // gdb-command:run\n \n // gdb-command:print packed\n-// gdb-check:$1 = {x = 123, y = 234, z = 345}\n+// gdbg-check:$1 = {x = 123, y = 234, z = 345}\n+// gdbr-check:$1 = packed_struct::Packed {x: 123, y: 234, z: 345}\n \n // gdb-command:print packedInPacked\n-// gdb-check:$2 = {a = 1111, b = {x = 2222, y = 3333, z = 4444}, c = 5555, d = {x = 6666, y = 7777, z = 8888}}\n+// gdbg-check:$2 = {a = 1111, b = {x = 2222, y = 3333, z = 4444}, c = 5555, d = {x = 6666, y = 7777, z = 8888}}\n+// gdbr-check:$2 = packed_struct::PackedInPacked {a: 1111, b: packed_struct::Packed {x: 2222, y: 3333, z: 4444}, c: 5555, d: packed_struct::Packed {x: 6666, y: 7777, z: 8888}}\n \n // gdb-command:print packedInUnpacked\n-// gdb-check:$3 = {a = -1111, b = {x = -2222, y = -3333, z = -4444}, c = -5555, d = {x = -6666, y = -7777, z = -8888}}\n+// gdbg-check:$3 = {a = -1111, b = {x = -2222, y = -3333, z = -4444}, c = -5555, d = {x = -6666, y = -7777, z = -8888}}\n+// gdbr-check:$3 = packed_struct::PackedInUnpacked {a: -1111, b: packed_struct::Packed {x: -2222, y: -3333, z: -4444}, c: -5555, d: packed_struct::Packed {x: -6666, y: -7777, z: -8888}}\n \n // gdb-command:print unpackedInPacked\n-// gdb-check:$4 = {a = 987, b = {x = 876, y = 765, z = 654, w = 543}, c = {x = 432, y = 321, z = 210, w = 109}, d = -98}\n+// gdbg-check:$4 = {a = 987, b = {x = 876, y = 765, z = 654, w = 543}, c = {x = 432, y = 321, z = 210, w = 109}, d = -98}\n+// gdbr-check:$4 = packed_struct::UnpackedInPacked {a: 987, b: packed_struct::Unpacked {x: 876, y: 765, z: 654, w: 543}, c: packed_struct::Unpacked {x: 432, y: 321, z: 210, w: 109}, d: -98}\n \n // gdb-command:print sizeof(packed)\n // gdb-check:$5 = 14"}, {"sha": "153f0c8271fc4f6783d344d7ba2f08958217f513", "filename": "src/test/debuginfo/pretty-std.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -35,7 +35,8 @@\n // gdb-check:$5 = Some = {8}\n \n // gdb-command: print none\n-// gdb-check:$6 = None\n+// gdbg-check:$6 = None\n+// gdbr-check:$6 = core::option::Option::None\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "80147b14174daf01c5fb2c542e24c42a049a2655", "filename": "src/test/debuginfo/recursive-struct.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -12,57 +12,72 @@\n // ignore-lldb\n \n // compile-flags:-g\n+\n // gdb-command:run\n \n // gdb-command:print stack_unique.value\n // gdb-check:$1 = 0\n-// gdb-command:print stack_unique.next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbg-command:print stack_unique.next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbr-command:print stack_unique.next.val.value\n // gdb-check:$2 = 1\n \n-// gdb-command:print unique_unique->value\n+// gdbg-command:print unique_unique->value\n+// gdbr-command:print unique_unique.value\n // gdb-check:$3 = 2\n-// gdb-command:print unique_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbg-command:print unique_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbr-command:print unique_unique.next.val.value\n // gdb-check:$4 = 3\n \n // gdb-command:print vec_unique[0].value\n // gdb-check:$5 = 6.5\n-// gdb-command:print vec_unique[0].next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbg-command:print vec_unique[0].next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbr-command:print vec_unique[0].next.val.value\n // gdb-check:$6 = 7.5\n \n-// gdb-command:print borrowed_unique->value\n+// gdbg-command:print borrowed_unique->value\n+// gdbr-command:print borrowed_unique.value\n // gdb-check:$7 = 8.5\n-// gdb-command:print borrowed_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbg-command:print borrowed_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n+// gdbr-command:print borrowed_unique.next.val.value\n // gdb-check:$8 = 9.5\n \n // LONG CYCLE\n // gdb-command:print long_cycle1.value\n // gdb-check:$9 = 20\n-// gdb-command:print long_cycle1.next->value\n+// gdbg-command:print long_cycle1.next->value\n+// gdbr-command:print long_cycle1.next.value\n // gdb-check:$10 = 21\n-// gdb-command:print long_cycle1.next->next->value\n+// gdbg-command:print long_cycle1.next->next->value\n+// gdbr-command:print long_cycle1.next.next.value\n // gdb-check:$11 = 22\n-// gdb-command:print long_cycle1.next->next->next->value\n+// gdbg-command:print long_cycle1.next->next->next->value\n+// gdbr-command:print long_cycle1.next.next.next.value\n // gdb-check:$12 = 23\n \n // gdb-command:print long_cycle2.value\n // gdb-check:$13 = 24\n-// gdb-command:print long_cycle2.next->value\n+// gdbg-command:print long_cycle2.next->value\n+// gdbr-command:print long_cycle2.next.value\n // gdb-check:$14 = 25\n-// gdb-command:print long_cycle2.next->next->value\n+// gdbg-command:print long_cycle2.next->next->value\n+// gdbr-command:print long_cycle2.next.next.value\n // gdb-check:$15 = 26\n \n // gdb-command:print long_cycle3.value\n // gdb-check:$16 = 27\n-// gdb-command:print long_cycle3.next->value\n+// gdbg-command:print long_cycle3.next->value\n+// gdbr-command:print long_cycle3.next.value\n // gdb-check:$17 = 28\n \n // gdb-command:print long_cycle4.value\n // gdb-check:$18 = 29.5\n \n-// gdb-command:print (*****long_cycle_w_anonymous_types).value\n+// gdbg-command:print (*****long_cycle_w_anonymous_types).value\n+// gdbr-command:print long_cycle_w_anonymous_types.value\n // gdb-check:$19 = 30\n \n-// gdb-command:print (*****((*****long_cycle_w_anonymous_types).next.RUST$ENCODED$ENUM$0$Empty.val)).value\n+// gdbg-command:print (*****((*****long_cycle_w_anonymous_types).next.RUST$ENCODED$ENUM$0$Empty.val)).value\n+// gdbr-command:print long_cycle_w_anonymous_types.next.val.value\n // gdb-check:$20 = 31\n \n // gdb-command:continue"}, {"sha": "796d122cd66baed906c47425376a11cc60e29514", "filename": "src/test/debuginfo/self-in-default-method.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,7 +18,8 @@\n \n // STACK BY REF\n // gdb-command:print *self\n-// gdb-check:$1 = {x = 100}\n+// gdbg-check:$1 = {x = 100}\n+// gdbr-check:$1 = self_in_default_method::Struct {x: 100}\n // gdb-command:print arg1\n // gdb-check:$2 = -1\n // gdb-command:print arg2\n@@ -27,7 +28,8 @@\n \n // STACK BY VAL\n // gdb-command:print self\n-// gdb-check:$4 = {x = 100}\n+// gdbg-check:$4 = {x = 100}\n+// gdbr-check:$4 = self_in_default_method::Struct {x: 100}\n // gdb-command:print arg1\n // gdb-check:$5 = -3\n // gdb-command:print arg2\n@@ -36,7 +38,8 @@\n \n // OWNED BY REF\n // gdb-command:print *self\n-// gdb-check:$7 = {x = 200}\n+// gdbg-check:$7 = {x = 200}\n+// gdbr-check:$7 = self_in_default_method::Struct {x: 200}\n // gdb-command:print arg1\n // gdb-check:$8 = -5\n // gdb-command:print arg2\n@@ -45,7 +48,8 @@\n \n // OWNED BY VAL\n // gdb-command:print self\n-// gdb-check:$10 = {x = 200}\n+// gdbg-check:$10 = {x = 200}\n+// gdbr-check:$10 = self_in_default_method::Struct {x: 200}\n // gdb-command:print arg1\n // gdb-check:$11 = -7\n // gdb-command:print arg2\n@@ -54,7 +58,8 @@\n \n // OWNED MOVED\n // gdb-command:print *self\n-// gdb-check:$13 = {x = 200}\n+// gdbg-check:$13 = {x = 200}\n+// gdbr-check:$13 = self_in_default_method::Struct {x: 200}\n // gdb-command:print arg1\n // gdb-check:$14 = -9\n // gdb-command:print arg2"}, {"sha": "b07d7ca5fb7b7c34de917910bda563c3fbf849eb", "filename": "src/test/debuginfo/self-in-generic-default-method.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,7 +18,8 @@\n \n // STACK BY REF\n // gdb-command:print *self\n-// gdb-check:$1 = {x = 987}\n+// gdbg-check:$1 = {x = 987}\n+// gdbr-check:$1 = self_in_generic_default_method::Struct {x: 987}\n // gdb-command:print arg1\n // gdb-check:$2 = -1\n // gdb-command:print arg2\n@@ -27,7 +28,8 @@\n \n // STACK BY VAL\n // gdb-command:print self\n-// gdb-check:$4 = {x = 987}\n+// gdbg-check:$4 = {x = 987}\n+// gdbr-check:$4 = self_in_generic_default_method::Struct {x: 987}\n // gdb-command:print arg1\n // gdb-check:$5 = -3\n // gdb-command:print arg2\n@@ -36,7 +38,8 @@\n \n // OWNED BY REF\n // gdb-command:print *self\n-// gdb-check:$7 = {x = 879}\n+// gdbg-check:$7 = {x = 879}\n+// gdbr-check:$7 = self_in_generic_default_method::Struct {x: 879}\n // gdb-command:print arg1\n // gdb-check:$8 = -5\n // gdb-command:print arg2\n@@ -45,7 +48,8 @@\n \n // OWNED BY VAL\n // gdb-command:print self\n-// gdb-check:$10 = {x = 879}\n+// gdbg-check:$10 = {x = 879}\n+// gdbr-check:$10 = self_in_generic_default_method::Struct {x: 879}\n // gdb-command:print arg1\n // gdb-check:$11 = -7\n // gdb-command:print arg2\n@@ -54,7 +58,8 @@\n \n // OWNED MOVED\n // gdb-command:print *self\n-// gdb-check:$13 = {x = 879}\n+// gdbg-check:$13 = {x = 879}\n+// gdbr-check:$13 = self_in_generic_default_method::Struct {x: 879}\n // gdb-command:print arg1\n // gdb-check:$14 = -9\n // gdb-command:print arg2"}, {"sha": "75e68f7efedef62733559aaa84417700c36e4e01", "filename": "src/test/debuginfo/simd.rs", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimd.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -20,28 +20,46 @@\n // compile-flags:-g\n // gdb-command:run\n \n-// gdb-command:print/d vi8x16\n-// gdb-check:$1 = {__0 = 0, __1 = 1, __2 = 2, __3 = 3, __4 = 4, __5 = 5, __6 = 6, __7 = 7, __8 = 8, __9 = 9, __10 = 10, __11 = 11, __12 = 12, __13 = 13, __14 = 14, __15 = 15}\n-// gdb-command:print/d vi16x8\n-// gdb-check:$2 = {__0 = 16, __1 = 17, __2 = 18, __3 = 19, __4 = 20, __5 = 21, __6 = 22, __7 = 23}\n-// gdb-command:print/d vi32x4\n-// gdb-check:$3 = {__0 = 24, __1 = 25, __2 = 26, __3 = 27}\n-// gdb-command:print/d vi64x2\n-// gdb-check:$4 = {__0 = 28, __1 = 29}\n-\n-// gdb-command:print/d vu8x16\n-// gdb-check:$5 = {__0 = 30, __1 = 31, __2 = 32, __3 = 33, __4 = 34, __5 = 35, __6 = 36, __7 = 37, __8 = 38, __9 = 39, __10 = 40, __11 = 41, __12 = 42, __13 = 43, __14 = 44, __15 = 45}\n-// gdb-command:print/d vu16x8\n-// gdb-check:$6 = {__0 = 46, __1 = 47, __2 = 48, __3 = 49, __4 = 50, __5 = 51, __6 = 52, __7 = 53}\n-// gdb-command:print/d vu32x4\n-// gdb-check:$7 = {__0 = 54, __1 = 55, __2 = 56, __3 = 57}\n-// gdb-command:print/d vu64x2\n-// gdb-check:$8 = {__0 = 58, __1 = 59}\n+// gdbg-command:print/d vi8x16\n+// gdbr-command:print vi8x16\n+// gdbg-check:$1 = {__0 = 0, __1 = 1, __2 = 2, __3 = 3, __4 = 4, __5 = 5, __6 = 6, __7 = 7, __8 = 8, __9 = 9, __10 = 10, __11 = 11, __12 = 12, __13 = 13, __14 = 14, __15 = 15}\n+// gdbr-check:$1 = simd::i8x16 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)\n+// gdbg-command:print/d vi16x8\n+// gdbr-command:print vi16x8\n+// gdbg-check:$2 = {__0 = 16, __1 = 17, __2 = 18, __3 = 19, __4 = 20, __5 = 21, __6 = 22, __7 = 23}\n+// gdbr-check:$2 = simd::i16x8 (16, 17, 18, 19, 20, 21, 22, 23)\n+// gdbg-command:print/d vi32x4\n+// gdbr-command:print vi32x4\n+// gdbg-check:$3 = {__0 = 24, __1 = 25, __2 = 26, __3 = 27}\n+// gdbr-check:$3 = simd::i32x4 (24, 25, 26, 27)\n+// gdbg-command:print/d vi64x2\n+// gdbr-command:print vi64x2\n+// gdbg-check:$4 = {__0 = 28, __1 = 29}\n+// gdbr-check:$4 = simd::i64x2 (28, 29)\n+\n+// gdbg-command:print/d vu8x16\n+// gdbr-command:print vu8x16\n+// gdbg-check:$5 = {__0 = 30, __1 = 31, __2 = 32, __3 = 33, __4 = 34, __5 = 35, __6 = 36, __7 = 37, __8 = 38, __9 = 39, __10 = 40, __11 = 41, __12 = 42, __13 = 43, __14 = 44, __15 = 45}\n+// gdbr-check:$5 = simd::u8x16 (30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45)\n+// gdbg-command:print/d vu16x8\n+// gdbr-command:print vu16x8\n+// gdbg-check:$6 = {__0 = 46, __1 = 47, __2 = 48, __3 = 49, __4 = 50, __5 = 51, __6 = 52, __7 = 53}\n+// gdbr-check:$6 = simd::u16x8 (46, 47, 48, 49, 50, 51, 52, 53)\n+// gdbg-command:print/d vu32x4\n+// gdbr-command:print vu32x4\n+// gdbg-check:$7 = {__0 = 54, __1 = 55, __2 = 56, __3 = 57}\n+// gdbr-check:$7 = simd::u32x4 (54, 55, 56, 57)\n+// gdbg-command:print/d vu64x2\n+// gdbr-command:print vu64x2\n+// gdbg-check:$8 = {__0 = 58, __1 = 59}\n+// gdbr-check:$8 = simd::u64x2 (58, 59)\n \n // gdb-command:print vf32x4\n-// gdb-check:$9 = {__0 = 60.5, __1 = 61.5, __2 = 62.5, __3 = 63.5}\n+// gdbg-check:$9 = {__0 = 60.5, __1 = 61.5, __2 = 62.5, __3 = 63.5}\n+// gdbr-check:$9 = simd::f32x4 (60.5, 61.5, 62.5, 63.5)\n // gdb-command:print vf64x2\n-// gdb-check:$10 = {__0 = 64.5, __1 = 65.5}\n+// gdbg-check:$10 = {__0 = 64.5, __1 = 65.5}\n+// gdbr-check:$10 = simd::f64x2 (64.5, 65.5)\n \n // gdb-command:continue\n "}, {"sha": "4956313ad2214d2c0eb3c18232d2fac878906848", "filename": "src/test/debuginfo/simple-struct.rs", "status": "modified", "additions": 74, "deletions": 41, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fsimple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fsimple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimple-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -14,61 +14,94 @@\n \n // === GDB TESTS ===================================================================================\n \n-// gdb-command:print 'simple_struct::NO_PADDING_16'\n-// gdb-check:$1 = {x = 1000, y = -1001}\n-\n-// gdb-command:print 'simple_struct::NO_PADDING_32'\n-// gdb-check:$2 = {x = 1, y = 2, z = 3}\n-\n-// gdb-command:print 'simple_struct::NO_PADDING_64'\n-// gdb-check:$3 = {x = 4, y = 5, z = 6}\n-\n-// gdb-command:print 'simple_struct::NO_PADDING_163264'\n-// gdb-check:$4 = {a = 7, b = 8, c = 9, d = 10}\n-\n-// gdb-command:print 'simple_struct::INTERNAL_PADDING'\n-// gdb-check:$5 = {x = 11, y = 12}\n-\n-// gdb-command:print 'simple_struct::PADDING_AT_END'\n-// gdb-check:$6 = {x = 13, y = 14}\n+// there's no frame yet for gdb to reliably detect the language, set it explicitly\n+// gdbr-command:set language rust\n+\n+// gdbg-command:print 'simple_struct::NO_PADDING_16'\n+// gdbr-command:print simple_struct::NO_PADDING_16\n+// gdbg-check:$1 = {x = 1000, y = -1001}\n+// gdbr-check:$1 = simple_struct::NoPadding16 {x: 1000, y: -1001}\n+\n+// gdbg-command:print 'simple_struct::NO_PADDING_32'\n+// gdbr-command:print simple_struct::NO_PADDING_32\n+// gdbg-check:$2 = {x = 1, y = 2, z = 3}\n+// gdbr-check:$2 = simple_struct::NoPadding32 {x: 1, y: 2, z: 3}\n+\n+// gdbg-command:print 'simple_struct::NO_PADDING_64'\n+// gdbr-command:print simple_struct::NO_PADDING_64\n+// gdbg-check:$3 = {x = 4, y = 5, z = 6}\n+// gdbr-check:$3 = simple_struct::NoPadding64 {x: 4, y: 5, z: 6}\n+\n+// gdbg-command:print 'simple_struct::NO_PADDING_163264'\n+// gdbr-command:print simple_struct::NO_PADDING_163264\n+// gdbg-check:$4 = {a = 7, b = 8, c = 9, d = 10}\n+// gdbr-check:$4 = simple_struct::NoPadding163264 {a: 7, b: 8, c: 9, d: 10}\n+\n+// gdbg-command:print 'simple_struct::INTERNAL_PADDING'\n+// gdbr-command:print simple_struct::INTERNAL_PADDING\n+// gdbg-check:$5 = {x = 11, y = 12}\n+// gdbr-check:$5 = simple_struct::InternalPadding {x: 11, y: 12}\n+\n+// gdbg-command:print 'simple_struct::PADDING_AT_END'\n+// gdbr-command:print simple_struct::PADDING_AT_END\n+// gdbg-check:$6 = {x = 13, y = 14}\n+// gdbr-check:$6 = simple_struct::PaddingAtEnd {x: 13, y: 14}\n \n // gdb-command:run\n \n // gdb-command:print no_padding16\n-// gdb-check:$7 = {x = 10000, y = -10001}\n+// gdbg-check:$7 = {x = 10000, y = -10001}\n+// gdbr-check:$7 = simple_struct::NoPadding16 {x: 10000, y: -10001}\n \n // gdb-command:print no_padding32\n-// gdb-check:$8 = {x = -10002, y = -10003.5, z = 10004}\n+// gdbg-check:$8 = {x = -10002, y = -10003.5, z = 10004}\n+// gdbr-check:$8 = simple_struct::NoPadding32 {x: -10002, y: -10003.5, z: 10004}\n \n // gdb-command:print no_padding64\n-// gdb-check:$9 = {x = -10005.5, y = 10006, z = 10007}\n+// gdbg-check:$9 = {x = -10005.5, y = 10006, z = 10007}\n+// gdbr-check:$9 = simple_struct::NoPadding64 {x: -10005.5, y: 10006, z: 10007}\n \n // gdb-command:print no_padding163264\n-// gdb-check:$10 = {a = -10008, b = 10009, c = 10010, d = 10011}\n+// gdbg-check:$10 = {a = -10008, b = 10009, c = 10010, d = 10011}\n+// gdbr-check:$10 = simple_struct::NoPadding163264 {a: -10008, b: 10009, c: 10010, d: 10011}\n \n // gdb-command:print internal_padding\n-// gdb-check:$11 = {x = 10012, y = -10013}\n+// gdbg-check:$11 = {x = 10012, y = -10013}\n+// gdbr-check:$11 = simple_struct::InternalPadding {x: 10012, y: -10013}\n \n // gdb-command:print padding_at_end\n-// gdb-check:$12 = {x = -10014, y = 10015}\n-\n-// gdb-command:print 'simple_struct::NO_PADDING_16'\n-// gdb-check:$13 = {x = 100, y = -101}\n-\n-// gdb-command:print 'simple_struct::NO_PADDING_32'\n-// gdb-check:$14 = {x = -15, y = -16, z = 17}\n-\n-// gdb-command:print 'simple_struct::NO_PADDING_64'\n-// gdb-check:$15 = {x = -18, y = 19, z = 20}\n-\n-// gdb-command:print 'simple_struct::NO_PADDING_163264'\n-// gdb-check:$16 = {a = -21, b = 22, c = 23, d = 24}\n-\n-// gdb-command:print 'simple_struct::INTERNAL_PADDING'\n-// gdb-check:$17 = {x = 25, y = -26}\n-\n-// gdb-command:print 'simple_struct::PADDING_AT_END'\n-// gdb-check:$18 = {x = -27, y = 28}\n+// gdbg-check:$12 = {x = -10014, y = 10015}\n+// gdbr-check:$12 = simple_struct::PaddingAtEnd {x: -10014, y: 10015}\n+\n+// gdbg-command:print 'simple_struct::NO_PADDING_16'\n+// gdbr-command:print simple_struct::NO_PADDING_16\n+// gdbg-check:$13 = {x = 100, y = -101}\n+// gdbr-check:$13 = simple_struct::NoPadding16 {x: 100, y: -101}\n+\n+// gdbg-command:print 'simple_struct::NO_PADDING_32'\n+// gdbr-command:print simple_struct::NO_PADDING_32\n+// gdbg-check:$14 = {x = -15, y = -16, z = 17}\n+// gdbr-check:$14 = simple_struct::NoPadding32 {x: -15, y: -16, z: 17}\n+\n+// gdbg-command:print 'simple_struct::NO_PADDING_64'\n+// gdbr-command:print simple_struct::NO_PADDING_64\n+// gdbg-check:$15 = {x = -18, y = 19, z = 20}\n+// gdbr-check:$15 = simple_struct::NoPadding64 {x: -18, y: 19, z: 20}\n+\n+// gdbg-command:print 'simple_struct::NO_PADDING_163264'\n+// gdbr-command:print simple_struct::NO_PADDING_163264\n+// gdbg-check:$16 = {a = -21, b = 22, c = 23, d = 24}\n+// gdbr-check:$16 = simple_struct::NoPadding163264 {a: -21, b: 22, c: 23, d: 24}\n+\n+// gdbg-command:print 'simple_struct::INTERNAL_PADDING'\n+// gdbr-command:print simple_struct::INTERNAL_PADDING\n+// gdbg-check:$17 = {x = 25, y = -26}\n+// gdbr-check:$17 = simple_struct::InternalPadding {x: 25, y: -26}\n+\n+// gdbg-command:print 'simple_struct::PADDING_AT_END'\n+// gdbr-command:print simple_struct::PADDING_AT_END\n+// gdbg-check:$18 = {x = -27, y = 28}\n+// gdbr-check:$18 = simple_struct::PaddingAtEnd {x: -27, y: 28}\n \n // gdb-command:continue\n "}, {"sha": "354a2c26cb36db21932bf0761eaace5cc161a478", "filename": "src/test/debuginfo/simple-tuple.rs", "status": "modified", "additions": 80, "deletions": 41, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fsimple-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fsimple-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimple-tuple.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -14,58 +14,97 @@\n \n // === GDB TESTS ===================================================================================\n \n-// gdb-command:print/d 'simple_tuple::NO_PADDING_8'\n-// gdb-check:$1 = {__0 = -50, __1 = 50}\n-// gdb-command:print 'simple_tuple::NO_PADDING_16'\n-// gdb-check:$2 = {__0 = -1, __1 = 2, __2 = 3}\n-// gdb-command:print 'simple_tuple::NO_PADDING_32'\n-// gdb-check:$3 = {__0 = 4, __1 = 5, __2 = 6}\n-// gdb-command:print 'simple_tuple::NO_PADDING_64'\n-// gdb-check:$4 = {__0 = 7, __1 = 8, __2 = 9}\n-\n-// gdb-command:print 'simple_tuple::INTERNAL_PADDING_1'\n-// gdb-check:$5 = {__0 = 10, __1 = 11}\n-// gdb-command:print 'simple_tuple::INTERNAL_PADDING_2'\n-// gdb-check:$6 = {__0 = 12, __1 = 13, __2 = 14, __3 = 15}\n-\n-// gdb-command:print 'simple_tuple::PADDING_AT_END'\n-// gdb-check:$7 = {__0 = 16, __1 = 17}\n+// there's no frame yet for gdb to reliably detect the language, set it explicitly\n+// gdbr-command:set language rust\n+\n+// gdbg-command:print/d 'simple_tuple::NO_PADDING_8'\n+// gdbr-command:print simple_tuple::NO_PADDING_8\n+// gdbg-check:$1 = {__0 = -50, __1 = 50}\n+// gdbr-check:$1 = (-50, 50)\n+// gdbg-command:print 'simple_tuple::NO_PADDING_16'\n+// gdbr-command:print simple_tuple::NO_PADDING_16\n+// gdbg-check:$2 = {__0 = -1, __1 = 2, __2 = 3}\n+// gdbr-check:$2 = (-1, 2, 3)\n+// gdbg-command:print 'simple_tuple::NO_PADDING_32'\n+// gdbr-command:print simple_tuple::NO_PADDING_32\n+// gdbg-check:$3 = {__0 = 4, __1 = 5, __2 = 6}\n+// gdbr-check:$3 = (4, 5, 6)\n+// gdbg-command:print 'simple_tuple::NO_PADDING_64'\n+// gdbr-command:print simple_tuple::NO_PADDING_64\n+// gdbg-check:$4 = {__0 = 7, __1 = 8, __2 = 9}\n+// gdbr-check:$4 = (7, 8, 9)\n+\n+// gdbg-command:print 'simple_tuple::INTERNAL_PADDING_1'\n+// gdbr-command:print simple_tuple::INTERNAL_PADDING_1\n+// gdbg-check:$5 = {__0 = 10, __1 = 11}\n+// gdbr-check:$5 = (10, 11)\n+// gdbg-command:print 'simple_tuple::INTERNAL_PADDING_2'\n+// gdbr-command:print simple_tuple::INTERNAL_PADDING_2\n+// gdbg-check:$6 = {__0 = 12, __1 = 13, __2 = 14, __3 = 15}\n+// gdbr-check:$6 = (12, 13, 14, 15)\n+\n+// gdbg-command:print 'simple_tuple::PADDING_AT_END'\n+// gdbr-command:print simple_tuple::PADDING_AT_END\n+// gdbg-check:$7 = {__0 = 16, __1 = 17}\n+// gdbr-check:$7 = (16, 17)\n \n // gdb-command:run\n \n-// gdb-command:print/d noPadding8\n-// gdb-check:$8 = {__0 = -100, __1 = 100}\n+// gdbg-command:print/d noPadding8\n+// gdbr-command:print noPadding8\n+// gdbg-check:$8 = {__0 = -100, __1 = 100}\n+// gdbr-check:$8 = (-100, 100)\n // gdb-command:print noPadding16\n-// gdb-check:$9 = {__0 = 0, __1 = 1, __2 = 2}\n+// gdbg-check:$9 = {__0 = 0, __1 = 1, __2 = 2}\n+// gdbr-check:$9 = (0, 1, 2)\n // gdb-command:print noPadding32\n-// gdb-check:$10 = {__0 = 3, __1 = 4.5, __2 = 5}\n+// gdbg-check:$10 = {__0 = 3, __1 = 4.5, __2 = 5}\n+// gdbr-check:$10 = (3, 4.5, 5)\n // gdb-command:print noPadding64\n-// gdb-check:$11 = {__0 = 6, __1 = 7.5, __2 = 8}\n+// gdbg-check:$11 = {__0 = 6, __1 = 7.5, __2 = 8}\n+// gdbr-check:$11 = (6, 7.5, 8)\n \n // gdb-command:print internalPadding1\n-// gdb-check:$12 = {__0 = 9, __1 = 10}\n+// gdbg-check:$12 = {__0 = 9, __1 = 10}\n+// gdbr-check:$12 = (9, 10)\n // gdb-command:print internalPadding2\n-// gdb-check:$13 = {__0 = 11, __1 = 12, __2 = 13, __3 = 14}\n+// gdbg-check:$13 = {__0 = 11, __1 = 12, __2 = 13, __3 = 14}\n+// gdbr-check:$13 = (11, 12, 13, 14)\n \n // gdb-command:print paddingAtEnd\n-// gdb-check:$14 = {__0 = 15, __1 = 16}\n-\n-// gdb-command:print/d 'simple_tuple::NO_PADDING_8'\n-// gdb-check:$15 = {__0 = -127, __1 = 127}\n-// gdb-command:print 'simple_tuple::NO_PADDING_16'\n-// gdb-check:$16 = {__0 = -10, __1 = 10, __2 = 9}\n-// gdb-command:print 'simple_tuple::NO_PADDING_32'\n-// gdb-check:$17 = {__0 = 14, __1 = 15, __2 = 16}\n-// gdb-command:print 'simple_tuple::NO_PADDING_64'\n-// gdb-check:$18 = {__0 = 17, __1 = 18, __2 = 19}\n-\n-// gdb-command:print 'simple_tuple::INTERNAL_PADDING_1'\n-// gdb-check:$19 = {__0 = 110, __1 = 111}\n-// gdb-command:print 'simple_tuple::INTERNAL_PADDING_2'\n-// gdb-check:$20 = {__0 = 112, __1 = 113, __2 = 114, __3 = 115}\n-\n-// gdb-command:print 'simple_tuple::PADDING_AT_END'\n-// gdb-check:$21 = {__0 = 116, __1 = 117}\n+// gdbg-check:$14 = {__0 = 15, __1 = 16}\n+// gdbr-check:$14 = (15, 16)\n+\n+// gdbg-command:print/d 'simple_tuple::NO_PADDING_8'\n+// gdbr-command:print simple_tuple::NO_PADDING_8\n+// gdbg-check:$15 = {__0 = -127, __1 = 127}\n+// gdbr-check:$15 = (-127, 127)\n+// gdbg-command:print 'simple_tuple::NO_PADDING_16'\n+// gdbr-command:print simple_tuple::NO_PADDING_16\n+// gdbg-check:$16 = {__0 = -10, __1 = 10, __2 = 9}\n+// gdbr-check:$16 = (-10, 10, 9)\n+// gdbg-command:print 'simple_tuple::NO_PADDING_32'\n+// gdbr-command:print simple_tuple::NO_PADDING_32\n+// gdbg-check:$17 = {__0 = 14, __1 = 15, __2 = 16}\n+// gdbr-check:$17 = (14, 15, 16)\n+// gdbg-command:print 'simple_tuple::NO_PADDING_64'\n+// gdbr-command:print simple_tuple::NO_PADDING_64\n+// gdbg-check:$18 = {__0 = 17, __1 = 18, __2 = 19}\n+// gdbr-check:$18 = (17, 18, 19)\n+\n+// gdbg-command:print 'simple_tuple::INTERNAL_PADDING_1'\n+// gdbr-command:print simple_tuple::INTERNAL_PADDING_1\n+// gdbg-check:$19 = {__0 = 110, __1 = 111}\n+// gdbr-check:$19 = (110, 111)\n+// gdbg-command:print 'simple_tuple::INTERNAL_PADDING_2'\n+// gdbr-command:print simple_tuple::INTERNAL_PADDING_2\n+// gdbg-check:$20 = {__0 = 112, __1 = 113, __2 = 114, __3 = 115}\n+// gdbr-check:$20 = (112, 113, 114, 115)\n+\n+// gdbg-command:print 'simple_tuple::PADDING_AT_END'\n+// gdbr-command:print simple_tuple::PADDING_AT_END\n+// gdbg-check:$21 = {__0 = 116, __1 = 117}\n+// gdbr-check:$21 = (116, 117)\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "d0aceaa4f3f9c2f0de7e925852055b411d96158b", "filename": "src/test/debuginfo/struct-in-enum.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -19,13 +19,16 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdb-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = {x = 2088533116, y = 2088533116, z = 31868}}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 8970181431921507452, __2 = 31868}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = {x = 2088533116, y = 2088533116, z = 31868}}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 8970181431921507452, __2 = 31868}}\n+// gdbr-check:$1 = struct_in_enum::Regular::Case1(0, struct_in_enum::Struct {x: 2088533116, y: 2088533116, z: 31868})\n \n // gdb-command:print case2\n-// gdb-check:$2 = {{RUST$ENUM$DISR = Case2, __0 = 0, __1 = {x = 286331153, y = 286331153, z = 4369}}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 1229782938247303441, __2 = 4369}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, __0 = 0, __1 = {x = 286331153, y = 286331153, z = 4369}}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 1229782938247303441, __2 = 4369}}\n+// gdbr-check:$2 = struct_in_enum::Regular::Case2(0, 1229782938247303441, 4369)\n \n // gdb-command:print univariant\n-// gdb-check:$3 = {{__0 = {x = 123, y = 456, z = 789}}}\n+// gdbg-check:$3 = {{__0 = {x = 123, y = 456, z = 789}}}\n+// gdbr-check:$3 = struct_in_enum::Univariant::TheOnlyCase(struct_in_enum::Struct {x: 123, y: 456, z: 789})\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "46524cf1d029a98b1180f6831ec6be2dc904382c", "filename": "src/test/debuginfo/struct-in-struct.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fstruct-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fstruct-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-in-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,13 +18,16 @@\n // gdb-command:run\n \n // gdb-command:print three_simple_structs\n-// gdb-check:$1 = {x = {x = 1}, y = {x = 2}, z = {x = 3}}\n+// gdbg-check:$1 = {x = {x = 1}, y = {x = 2}, z = {x = 3}}\n+// gdbr-check:$1 = struct_in_struct::ThreeSimpleStructs {x: struct_in_struct::Simple {x: 1}, y: struct_in_struct::Simple {x: 2}, z: struct_in_struct::Simple {x: 3}}\n \n // gdb-command:print internal_padding_parent\n-// gdb-check:$2 = {x = {x = 4, y = 5}, y = {x = 6, y = 7}, z = {x = 8, y = 9}}\n+// gdbg-check:$2 = {x = {x = 4, y = 5}, y = {x = 6, y = 7}, z = {x = 8, y = 9}}\n+// gdbr-check:$2 = struct_in_struct::InternalPaddingParent {x: struct_in_struct::InternalPadding {x: 4, y: 5}, y: struct_in_struct::InternalPadding {x: 6, y: 7}, z: struct_in_struct::InternalPadding {x: 8, y: 9}}\n \n // gdb-command:print padding_at_end_parent\n-// gdb-check:$3 = {x = {x = 10, y = 11}, y = {x = 12, y = 13}, z = {x = 14, y = 15}}\n+// gdbg-check:$3 = {x = {x = 10, y = 11}, y = {x = 12, y = 13}, z = {x = 14, y = 15}}\n+// gdbr-check:$3 = struct_in_struct::PaddingAtEndParent {x: struct_in_struct::PaddingAtEnd {x: 10, y: 11}, y: struct_in_struct::PaddingAtEnd {x: 12, y: 13}, z: struct_in_struct::PaddingAtEnd {x: 14, y: 15}}\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "8abc139eb1172bd61e1d545b216a8e6817883040", "filename": "src/test/debuginfo/struct-style-enum.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -19,16 +19,20 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdb-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, a = 0, b = 2088533116, c = 2088533116}, {RUST$ENUM$DISR = Case1, a = 0, b = 8970181431921507452}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, a = 0, b = 2088533116, c = 2088533116}, {RUST$ENUM$DISR = Case1, a = 0, b = 8970181431921507452}}\n+// gdbr-check:$1 = struct_style_enum::Regular::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n \n // gdb-command:print case2\n-// gdb-check:$2 = {{RUST$ENUM$DISR = Case2, a = 0, b = 4369, c = 4369, d = 4369, e = 4369}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, a = 0, b = 1229782938247303441}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, a = 0, b = 4369, c = 4369, d = 4369, e = 4369}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, a = 0, b = 1229782938247303441}}\n+// gdbr-check:$2 = struct_style_enum::Regular::Case2{a: 0, b: 286331153, c: 286331153}\n \n // gdb-command:print case3\n-// gdb-check:$3 = {{RUST$ENUM$DISR = Case3, a = 0, b = 22873, c = 22873, d = 22873, e = 22873}, {RUST$ENUM$DISR = Case3, a = 0, b = 1499027801, c = 1499027801}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, a = 0, b = 22873, c = 22873, d = 22873, e = 22873}, {RUST$ENUM$DISR = Case3, a = 0, b = 1499027801, c = 1499027801}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n+// gdbr-check:$3 = struct_style_enum::Regular::Case3{a: 0, b: 6438275382588823897}\n \n // gdb-command:print univariant\n-// gdb-check:$4 = {{a = -1}}\n+// gdbg-check:$4 = {{a = -1}}\n+// gdbr-check:$4 = struct_style_enum::Univariant::TheOnlyCase{a: -1}\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "af70b4a63fd279f8d82c072de6d083f03ce14cde", "filename": "src/test/debuginfo/struct-with-destructor.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fstruct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fstruct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-with-destructor.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n // min-lldb-version: 310\n \n // compile-flags:-g\n@@ -16,16 +18,20 @@\n \n // gdb-command:run\n // gdb-command:print simple\n-// gdb-check:$1 = {x = 10, y = 20}\n+// gdbg-check:$1 = {x = 10, y = 20}\n+// gdbr-check:$1 = struct_with_destructor::WithDestructor {x: 10, y: 20}\n \n // gdb-command:print noDestructor\n-// gdb-check:$2 = {a = {x = 10, y = 20}, guard = -1}\n+// gdbg-check:$2 = {a = {x = 10, y = 20}, guard = -1}\n+// gdbr-check:$2 = struct_with_destructor::NoDestructorGuarded {a: struct_with_destructor::NoDestructor {x: 10, y: 20}, guard: -1}\n \n // gdb-command:print withDestructor\n-// gdb-check:$3 = {a = {x = 10, y = 20}, guard = -1}\n+// gdbg-check:$3 = {a = {x = 10, y = 20}, guard = -1}\n+// gdbr-check:$3 = struct_with_destructor::WithDestructorGuarded {a: struct_with_destructor::WithDestructor {x: 10, y: 20}, guard: -1}\n \n // gdb-command:print nested\n-// gdb-check:$4 = {a = {a = {x = 7890, y = 9870}}}\n+// gdbg-check:$4 = {a = {a = {x = 7890, y = 9870}}}\n+// gdbr-check:$4 = struct_with_destructor::NestedOuter {a: struct_with_destructor::NestedInner {a: struct_with_destructor::WithDestructor {x: 7890, y: 9870}}}\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "dae1f5da542f524e8544ca51977227c62624e11c", "filename": "src/test/debuginfo/tuple-in-struct.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Ftuple-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Ftuple-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-in-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -17,29 +17,39 @@\n // gdb-command:run\n \n // gdb-command:print no_padding1\n-// gdb-check:$1 = {x = {__0 = 0, __1 = 1}, y = 2, z = {__0 = 3, __1 = 4, __2 = 5}}\n+// gdbg-check:$1 = {x = {__0 = 0, __1 = 1}, y = 2, z = {__0 = 3, __1 = 4, __2 = 5}}\n+// gdbr-check:$1 = tuple_in_struct::NoPadding1 {x: (0, 1), y: 2, z: (3, 4, 5)}\n // gdb-command:print no_padding2\n-// gdb-check:$2 = {x = {__0 = 6, __1 = 7}, y = {__0 = {__0 = 8, __1 = 9}, __1 = 10}}\n+// gdbg-check:$2 = {x = {__0 = 6, __1 = 7}, y = {__0 = {__0 = 8, __1 = 9}, __1 = 10}}\n+// gdbr-check:$2 = tuple_in_struct::NoPadding2 {x: (6, 7), y: ((8, 9), 10)}\n \n // gdb-command:print tuple_internal_padding\n-// gdb-check:$3 = {x = {__0 = 11, __1 = 12}, y = {__0 = 13, __1 = 14}}\n+// gdbg-check:$3 = {x = {__0 = 11, __1 = 12}, y = {__0 = 13, __1 = 14}}\n+// gdbr-check:$3 = tuple_in_struct::TupleInternalPadding {x: (11, 12), y: (13, 14)}\n // gdb-command:print struct_internal_padding\n-// gdb-check:$4 = {x = {__0 = 15, __1 = 16}, y = {__0 = 17, __1 = 18}}\n+// gdbg-check:$4 = {x = {__0 = 15, __1 = 16}, y = {__0 = 17, __1 = 18}}\n+// gdbr-check:$4 = tuple_in_struct::StructInternalPadding {x: (15, 16), y: (17, 18)}\n // gdb-command:print both_internally_padded\n-// gdb-check:$5 = {x = {__0 = 19, __1 = 20, __2 = 21}, y = {__0 = 22, __1 = 23}}\n+// gdbg-check:$5 = {x = {__0 = 19, __1 = 20, __2 = 21}, y = {__0 = 22, __1 = 23}}\n+// gdbr-check:$5 = tuple_in_struct::BothInternallyPadded {x: (19, 20, 21), y: (22, 23)}\n \n // gdb-command:print single_tuple\n-// gdb-check:$6 = {x = {__0 = 24, __1 = 25, __2 = 26}}\n+// gdbg-check:$6 = {x = {__0 = 24, __1 = 25, __2 = 26}}\n+// gdbr-check:$6 = tuple_in_struct::SingleTuple {x: (24, 25, 26)}\n \n // gdb-command:print tuple_padded_at_end\n-// gdb-check:$7 = {x = {__0 = 27, __1 = 28}, y = {__0 = 29, __1 = 30}}\n+// gdbg-check:$7 = {x = {__0 = 27, __1 = 28}, y = {__0 = 29, __1 = 30}}\n+// gdbr-check:$7 = tuple_in_struct::TuplePaddedAtEnd {x: (27, 28), y: (29, 30)}\n // gdb-command:print struct_padded_at_end\n-// gdb-check:$8 = {x = {__0 = 31, __1 = 32}, y = {__0 = 33, __1 = 34}}\n+// gdbg-check:$8 = {x = {__0 = 31, __1 = 32}, y = {__0 = 33, __1 = 34}}\n+// gdbr-check:$8 = tuple_in_struct::StructPaddedAtEnd {x: (31, 32), y: (33, 34)}\n // gdb-command:print both_padded_at_end\n-// gdb-check:$9 = {x = {__0 = 35, __1 = 36, __2 = 37}, y = {__0 = 38, __1 = 39}}\n+// gdbg-check:$9 = {x = {__0 = 35, __1 = 36, __2 = 37}, y = {__0 = 38, __1 = 39}}\n+// gdbr-check:$9 = tuple_in_struct::BothPaddedAtEnd {x: (35, 36, 37), y: (38, 39)}\n \n // gdb-command:print mixed_padding\n-// gdb-check:$10 = {x = {__0 = {__0 = 40, __1 = 41, __2 = 42}, __1 = {__0 = 43, __1 = 44}}, y = {__0 = 45, __1 = 46, __2 = 47, __3 = 48}}\n+// gdbg-check:$10 = {x = {__0 = {__0 = 40, __1 = 41, __2 = 42}, __1 = {__0 = 43, __1 = 44}}, y = {__0 = 45, __1 = 46, __2 = 47, __3 = 48}}\n+// gdbr-check:$10 = tuple_in_struct::MixedPadding {x: ((40, 41, 42), (43, 44)), y: (45, 46, 47, 48)}\n \n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]"}, {"sha": "4ebc740b9c0f7a55c625666275a8cd4fae3a3cbb", "filename": "src/test/debuginfo/tuple-in-tuple.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Ftuple-in-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Ftuple-in-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-in-tuple.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -17,21 +17,28 @@\n // gdb-command:run\n \n // gdb-command:print no_padding1\n-// gdb-check:$1 = {__0 = {__0 = 0, __1 = 1}, __1 = 2, __2 = 3}\n+// gdbg-check:$1 = {__0 = {__0 = 0, __1 = 1}, __1 = 2, __2 = 3}\n+// gdbr-check:$1 = ((0, 1), 2, 3)\n // gdb-command:print no_padding2\n-// gdb-check:$2 = {__0 = 4, __1 = {__0 = 5, __1 = 6}, __2 = 7}\n+// gdbg-check:$2 = {__0 = 4, __1 = {__0 = 5, __1 = 6}, __2 = 7}\n+// gdbr-check:$2 = (4, (5, 6), 7)\n // gdb-command:print no_padding3\n-// gdb-check:$3 = {__0 = 8, __1 = 9, __2 = {__0 = 10, __1 = 11}}\n+// gdbg-check:$3 = {__0 = 8, __1 = 9, __2 = {__0 = 10, __1 = 11}}\n+// gdbr-check:$3 = (8, 9, (10, 11))\n \n // gdb-command:print internal_padding1\n-// gdb-check:$4 = {__0 = 12, __1 = {__0 = 13, __1 = 14}}\n+// gdbg-check:$4 = {__0 = 12, __1 = {__0 = 13, __1 = 14}}\n+// gdbr-check:$4 = (12, (13, 14))\n // gdb-command:print internal_padding2\n-// gdb-check:$5 = {__0 = 15, __1 = {__0 = 16, __1 = 17}}\n+// gdbg-check:$5 = {__0 = 15, __1 = {__0 = 16, __1 = 17}}\n+// gdbr-check:$5 = (15, (16, 17))\n \n // gdb-command:print padding_at_end1\n-// gdb-check:$6 = {__0 = 18, __1 = {__0 = 19, __1 = 20}}\n+// gdbg-check:$6 = {__0 = 18, __1 = {__0 = 19, __1 = 20}}\n+// gdbr-check:$6 = (18, (19, 20))\n // gdb-command:print padding_at_end2\n-// gdb-check:$7 = {__0 = {__0 = 21, __1 = 22}, __1 = 23}\n+// gdbg-check:$7 = {__0 = {__0 = 21, __1 = 22}, __1 = 23}\n+// gdbr-check:$7 = ((21, 22), 23)\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "aa644d8419b54f72a3aac5334cb1ac83eb639ffd", "filename": "src/test/debuginfo/tuple-struct.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Ftuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Ftuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-struct.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -17,22 +17,28 @@\n // gdb-command:run\n \n // gdb-command:print no_padding16\n-// gdb-check:$1 = {__0 = 10000, __1 = -10001}\n+// gdbg-check:$1 = {__0 = 10000, __1 = -10001}\n+// gdbr-check:$1 = tuple_struct::NoPadding16 (10000, -10001)\n \n // gdb-command:print no_padding32\n-// gdb-check:$2 = {__0 = -10002, __1 = -10003.5, __2 = 10004}\n+// gdbg-check:$2 = {__0 = -10002, __1 = -10003.5, __2 = 10004}\n+// gdbr-check:$2 = tuple_struct::NoPadding32 (-10002, -10003.5, 10004)\n \n // gdb-command:print no_padding64\n-// gdb-check:$3 = {__0 = -10005.5, __1 = 10006, __2 = 10007}\n+// gdbg-check:$3 = {__0 = -10005.5, __1 = 10006, __2 = 10007}\n+// gdbr-check:$3 = tuple_struct::NoPadding64 (-10005.5, 10006, 10007)\n \n // gdb-command:print no_padding163264\n-// gdb-check:$4 = {__0 = -10008, __1 = 10009, __2 = 10010, __3 = 10011}\n+// gdbg-check:$4 = {__0 = -10008, __1 = 10009, __2 = 10010, __3 = 10011}\n+// gdbr-check:$4 = tuple_struct::NoPadding163264 (-10008, 10009, 10010, 10011)\n \n // gdb-command:print internal_padding\n-// gdb-check:$5 = {__0 = 10012, __1 = -10013}\n+// gdbg-check:$5 = {__0 = 10012, __1 = -10013}\n+// gdbr-check:$5 = tuple_struct::InternalPadding (10012, -10013)\n \n // gdb-command:print padding_at_end\n-// gdb-check:$6 = {__0 = -10014, __1 = 10015}\n+// gdbg-check:$6 = {__0 = -10014, __1 = 10015}\n+// gdbr-check:$6 = tuple_struct::PaddingAtEnd (-10014, 10015)\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "d05edec3e737dfbd2d21ef357656d4bbad4c1f91", "filename": "src/test/debuginfo/tuple-style-enum.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -19,16 +19,20 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdb-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 2088533116, __2 = 2088533116}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 8970181431921507452}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 2088533116, __2 = 2088533116}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 8970181431921507452}}\n+// gdbr-check:$1 = tuple_style_enum::Regular::Case1(0, 31868, 31868, 31868, 31868)\n \n // gdb-command:print case2\n-// gdb-check:$2 = {{RUST$ENUM$DISR = Case2, __0 = 0, __1 = 4369, __2 = 4369, __3 = 4369, __4 = 4369}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 1229782938247303441}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, __0 = 0, __1 = 4369, __2 = 4369, __3 = 4369, __4 = 4369}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 1229782938247303441}}\n+// gdbr-check:$2 = tuple_style_enum::Regular::Case2(0, 286331153, 286331153)\n \n // gdb-command:print case3\n-// gdb-check:$3 = {{RUST$ENUM$DISR = Case3, __0 = 0, __1 = 22873, __2 = 22873, __3 = 22873, __4 = 22873}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 1499027801, __2 = 1499027801}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, __0 = 0, __1 = 22873, __2 = 22873, __3 = 22873, __4 = 22873}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 1499027801, __2 = 1499027801}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n+// gdbr-check:$3 = tuple_style_enum::Regular::Case3(0, 6438275382588823897)\n \n // gdb-command:print univariant\n-// gdb-check:$4 = {{__0 = -1}}\n+// gdbg-check:$4 = {{__0 = -1}}\n+// gdbr-check:$4 = tuple_style_enum::Univariant::TheOnlyCase(-1)\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "438a78743bb1ec6ee0168006a8223f5694a0ead6", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 92, "deletions": 46, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -20,160 +20,206 @@\n \n // STRUCTS\n // gdb-command:whatis simple_struct\n-// gdb-check:type = struct Struct1\n+// gdbg-check:type = struct Struct1\n+// gdbr-check:type = type_names::Struct1\n \n // gdb-command:whatis generic_struct1\n-// gdb-check:type = struct GenericStruct<type_names::mod1::Struct2, type_names::mod1::mod2::Struct3>\n+// gdbg-check:type = struct GenericStruct<type_names::mod1::Struct2, type_names::mod1::mod2::Struct3>\n+// gdbr-check:type = type_names::GenericStruct<type_names::mod1::Struct2, type_names::mod1::mod2::Struct3>\n \n // gdb-command:whatis generic_struct2\n-// gdb-check:type = struct GenericStruct<type_names::Struct1, extern \"fastcall\" fn(isize) -> usize>\n+// gdbg-check:type = struct GenericStruct<type_names::Struct1, extern \"fastcall\" fn(isize) -> usize>\n+// gdbr-check:type = type_names::GenericStruct<type_names::Struct1, extern \"fastcall\" fn(isize) -> usize>\n \n // gdb-command:whatis mod_struct\n-// gdb-check:type = struct Struct2\n+// gdbg-check:type = struct Struct2\n+// gdbr-check:type = type_names::mod1::Struct2\n \n \n // ENUMS\n // gdb-command:whatis simple_enum_1\n-// gdb-check:type = union Enum1\n+// gdbg-check:type = union Enum1\n+// gdbr-check:type = type_names::Enum1\n \n // gdb-command:whatis simple_enum_2\n-// gdb-check:type = union Enum1\n+// gdbg-check:type = union Enum1\n+// gdbr-check:type = type_names::Enum1\n \n // gdb-command:whatis simple_enum_3\n-// gdb-check:type = union Enum2\n+// gdbg-check:type = union Enum2\n+// gdbr-check:type = type_names::mod1::Enum2\n \n // gdb-command:whatis generic_enum_1\n-// gdb-check:type = union Enum3<type_names::mod1::Struct2>\n+// gdbg-check:type = union Enum3<type_names::mod1::Struct2>\n+// gdbr-check:type = type_names::mod1::mod2::Enum3<type_names::mod1::Struct2>\n \n // gdb-command:whatis generic_enum_2\n-// gdb-check:type = union Enum3<type_names::Struct1>\n+// gdbg-check:type = union Enum3<type_names::Struct1>\n+// gdbr-check:type = type_names::mod1::mod2::Enum3<type_names::Struct1>\n \n \n // TUPLES\n // gdb-command:whatis tuple1\n-// gdb-check:type = struct (u32, type_names::Struct1, type_names::mod1::mod2::Enum3<type_names::mod1::Struct2>)\n+// gdbg-check:type = struct (u32, type_names::Struct1, type_names::mod1::mod2::Enum3<type_names::mod1::Struct2>)\n+// gdbr-check:type = (u32, type_names::Struct1, type_names::mod1::mod2::Enum3<type_names::mod1::Struct2>)\n \n // gdb-command:whatis tuple2\n-// gdb-check:type = struct ((type_names::Struct1, type_names::mod1::mod2::Struct3), type_names::mod1::Enum2, char)\n+// gdbg-check:type = struct ((type_names::Struct1, type_names::mod1::mod2::Struct3), type_names::mod1::Enum2, char)\n+// gdbr-check:type = ((type_names::Struct1, type_names::mod1::mod2::Struct3), type_names::mod1::Enum2, char)\n \n \n // BOX\n // gdb-command:whatis box1\n-// gdb-check:type = struct (Box<f32>, i32)\n+// gdbg-check:type = struct (Box<f32>, i32)\n+// gdbr-check:type = (Box<f32>, i32)\n \n // gdb-command:whatis box2\n-// gdb-check:type = struct (Box<type_names::mod1::mod2::Enum3<f32>>, i32)\n+// gdbg-check:type = struct (Box<type_names::mod1::mod2::Enum3<f32>>, i32)\n+// gdbr-check:type = (Box<type_names::mod1::mod2::Enum3<f32>>, i32)\n \n \n // REFERENCES\n // gdb-command:whatis ref1\n-// gdb-check:type = struct (&type_names::Struct1, i32)\n+// gdbg-check:type = struct (&type_names::Struct1, i32)\n+// gdbr-check:type = (&type_names::Struct1, i32)\n \n // gdb-command:whatis ref2\n-// gdb-check:type = struct (&type_names::GenericStruct<char, type_names::Struct1>, i32)\n+// gdbg-check:type = struct (&type_names::GenericStruct<char, type_names::Struct1>, i32)\n+// gdbr-check:type = (&type_names::GenericStruct<char, type_names::Struct1>, i32)\n \n // gdb-command:whatis mut_ref1\n-// gdb-check:type = struct (&mut type_names::Struct1, i32)\n+// gdbg-check:type = struct (&mut type_names::Struct1, i32)\n+// gdbr-check:type = (&mut type_names::Struct1, i32)\n \n // gdb-command:whatis mut_ref2\n-// gdb-check:type = struct (&mut type_names::GenericStruct<type_names::mod1::Enum2, f64>, i32)\n+// gdbg-check:type = struct (&mut type_names::GenericStruct<type_names::mod1::Enum2, f64>, i32)\n+// gdbr-check:type = (&mut type_names::GenericStruct<type_names::mod1::Enum2, f64>, i32)\n \n \n // RAW POINTERS\n // gdb-command:whatis mut_ptr1\n-// gdb-check:type = struct (*mut type_names::Struct1, isize)\n+// gdbg-check:type = struct (*mut type_names::Struct1, isize)\n+// gdbr-check:type = (*mut type_names::Struct1, isize)\n \n // gdb-command:whatis mut_ptr2\n-// gdb-check:type = struct (*mut isize, isize)\n+// gdbg-check:type = struct (*mut isize, isize)\n+// gdbr-check:type = (*mut isize, isize)\n \n // gdb-command:whatis mut_ptr3\n-// gdb-check:type = struct (*mut type_names::mod1::mod2::Enum3<type_names::Struct1>, isize)\n+// gdbg-check:type = struct (*mut type_names::mod1::mod2::Enum3<type_names::Struct1>, isize)\n+// gdbr-check:type = (*mut type_names::mod1::mod2::Enum3<type_names::Struct1>, isize)\n \n // gdb-command:whatis const_ptr1\n-// gdb-check:type = struct (*const type_names::Struct1, isize)\n+// gdbg-check:type = struct (*const type_names::Struct1, isize)\n+// gdbr-check:type = (*const type_names::Struct1, isize)\n \n // gdb-command:whatis const_ptr2\n-// gdb-check:type = struct (*const isize, isize)\n+// gdbg-check:type = struct (*const isize, isize)\n+// gdbr-check:type = (*const isize, isize)\n \n // gdb-command:whatis const_ptr3\n-// gdb-check:type = struct (*const type_names::mod1::mod2::Enum3<type_names::Struct1>, isize)\n+// gdbg-check:type = struct (*const type_names::mod1::mod2::Enum3<type_names::Struct1>, isize)\n+// gdbr-check:type = (*const type_names::mod1::mod2::Enum3<type_names::Struct1>, isize)\n \n \n // VECTORS\n // gdb-command:whatis fixed_size_vec1\n-// gdb-check:type = struct ([type_names::Struct1; 3], i16)\n+// gdbg-check:type = struct ([type_names::Struct1; 3], i16)\n+// gdbr-check:type = ([type_names::Struct1; 3], i16)\n \n // gdb-command:whatis fixed_size_vec2\n-// gdb-check:type = struct ([usize; 3], i16)\n+// gdbg-check:type = struct ([usize; 3], i16)\n+// gdbr-check:type = ([usize; 3], i16)\n \n // gdb-command:whatis slice1\n-// gdb-check:type = struct &[usize]\n+// gdbg-check:type = struct &[usize]\n+// gdbr-check:type = &[usize]\n \n // gdb-command:whatis slice2\n-// gdb-check:type = struct &[type_names::mod1::Enum2]\n+// gdbg-check:type = struct &[type_names::mod1::Enum2]\n+// gdbr-check:type = &[type_names::mod1::Enum2]\n \n \n // TRAITS\n // gdb-command:whatis box_trait\n-// gdb-check:type = struct Box<Trait1>\n+// gdbg-check:type = struct Box<Trait1>\n+// gdbr-check:type = type_names::Box<Trait1>\n \n // gdb-command:whatis ref_trait\n-// gdb-check:type = struct &Trait1\n+// gdbg-check:type = struct &Trait1\n+// gdbr-check:type = type_names::&Trait1\n \n // gdb-command:whatis mut_ref_trait\n-// gdb-check:type = struct &mut Trait1\n+// gdbg-check:type = struct &mut Trait1\n+// gdbr-check:type = type_names::&mut Trait1\n \n // gdb-command:whatis generic_box_trait\n-// gdb-check:type = struct Box<Trait2<i32, type_names::mod1::Struct2>>\n+// gdbg-check:type = struct Box<Trait2<i32, type_names::mod1::Struct2>>\n+// gdbr-check:type = type_names::Box<Trait2<i32, type_names::mod1::Struct2>>\n \n // gdb-command:whatis generic_ref_trait\n-// gdb-check:type = struct &Trait2<type_names::Struct1, type_names::Struct1>\n+// gdbg-check:type = struct &Trait2<type_names::Struct1, type_names::Struct1>\n+// gdbr-check:type = type_names::&Trait2<type_names::Struct1, type_names::Struct1>\n \n // gdb-command:whatis generic_mut_ref_trait\n-// gdb-check:type = struct &mut Trait2<type_names::mod1::mod2::Struct3, type_names::GenericStruct<usize, isize>>\n+// gdbg-check:type = struct &mut Trait2<type_names::mod1::mod2::Struct3, type_names::GenericStruct<usize, isize>>\n+// gdbr-check:type = type_names::&mut Trait2<type_names::mod1::mod2::Struct3, type_names::GenericStruct<usize, isize>>\n \n \n // BARE FUNCTIONS\n // gdb-command:whatis rust_fn\n-// gdb-check:type = struct (fn(core::option::Option<isize>, core::option::Option<&type_names::mod1::Struct2>), usize)\n+// gdbg-check:type = struct (fn(core::option::Option<isize>, core::option::Option<&type_names::mod1::Struct2>), usize)\n+// gdbr-check:type = (fn(core::option::Option<isize>, core::option::Option<&type_names::mod1::Struct2>), usize)\n \n // gdb-command:whatis extern_c_fn\n-// gdb-check:type = struct (extern \"C\" fn(isize), usize)\n+// gdbg-check:type = struct (extern \"C\" fn(isize), usize)\n+// gdbr-check:type = (extern \"C\" fn(isize), usize)\n \n // gdb-command:whatis unsafe_fn\n-// gdb-check:type = struct (unsafe fn(core::result::Result<char, f64>), usize)\n+// gdbg-check:type = struct (unsafe fn(core::result::Result<char, f64>), usize)\n+// gdbr-check:type = (unsafe fn(core::result::Result<char, f64>), usize)\n \n // gdb-command:whatis extern_stdcall_fn\n-// gdb-check:type = struct (extern \"stdcall\" fn(), usize)\n+// gdbg-check:type = struct (extern \"stdcall\" fn(), usize)\n+// gdbr-check:type = (extern \"stdcall\" fn(), usize)\n \n // gdb-command:whatis rust_fn_with_return_value\n-// gdb-check:type = struct (fn(f64) -> usize, usize)\n+// gdbg-check:type = struct (fn(f64) -> usize, usize)\n+// gdbr-check:type = (fn(f64) -> usize, usize)\n \n // gdb-command:whatis extern_c_fn_with_return_value\n-// gdb-check:type = struct (extern \"C\" fn() -> type_names::Struct1, usize)\n+// gdbg-check:type = struct (extern \"C\" fn() -> type_names::Struct1, usize)\n+// gdbr-check:type = (extern \"C\" fn() -> type_names::Struct1, usize)\n \n // gdb-command:whatis unsafe_fn_with_return_value\n-// gdb-check:type = struct (unsafe fn(type_names::GenericStruct<u16, u8>) -> type_names::mod1::Struct2, usize)\n+// gdbg-check:type = struct (unsafe fn(type_names::GenericStruct<u16, u8>) -> type_names::mod1::Struct2, usize)\n+// gdbr-check:type = (unsafe fn(type_names::GenericStruct<u16, u8>) -> type_names::mod1::Struct2, usize)\n \n // gdb-command:whatis extern_stdcall_fn_with_return_value\n-// gdb-check:type = struct (extern \"stdcall\" fn(Box<isize>) -> usize, usize)\n+// gdbg-check:type = struct (extern \"stdcall\" fn(Box<isize>) -> usize, usize)\n+// gdbr-check:type = (extern \"stdcall\" fn(Box<isize>) -> usize, usize)\n \n // gdb-command:whatis generic_function_int\n-// gdb-check:type = struct (fn(isize) -> isize, usize)\n+// gdbg-check:type = struct (fn(isize) -> isize, usize)\n+// gdbr-check:type = (fn(isize) -> isize, usize)\n \n // gdb-command:whatis generic_function_struct3\n-// gdb-check:type = struct (fn(type_names::mod1::mod2::Struct3) -> type_names::mod1::mod2::Struct3, usize)\n+// gdbg-check:type = struct (fn(type_names::mod1::mod2::Struct3) -> type_names::mod1::mod2::Struct3, usize)\n+// gdbr-check:type = (fn(type_names::mod1::mod2::Struct3) -> type_names::mod1::mod2::Struct3, usize)\n \n // gdb-command:whatis variadic_function\n-// gdb-check:type = struct (unsafe extern \"C\" fn(*const u8, ...) -> isize, usize)\n+// gdbg-check:type = struct (unsafe extern \"C\" fn(*const u8, ...) -> isize, usize)\n+// gdbr-check:type = (unsafe extern \"C\" fn(*const u8, ...) -> isize, usize)\n \n \n // CLOSURES\n // gdb-command:whatis closure1\n-// gdb-check:type = struct (closure, usize)\n+// gdbg-check:type = struct (closure, usize)\n+// gdbr-check:type = (closure, usize)\n \n // gdb-command:whatis closure2\n-// gdb-check:type = struct (closure, usize)\n+// gdbg-check:type = struct (closure, usize)\n+// gdbr-check:type = (closure, usize)\n \n #![feature(box_syntax)]\n #![allow(unused_variables)]"}, {"sha": "26e73a08ea137ce9c905776182d98fc04517afdd", "filename": "src/test/debuginfo/union-smoke.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Funion-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Funion-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funion-smoke.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -16,9 +16,11 @@\n \n // gdb-command:run\n // gdb-command:print u\n-// gdb-check:$1 = {a = {__0 = 2 '\\002', __1 = 2 '\\002'}, b = 514}\n+// gdbg-check:$1 = {a = {__0 = 2 '\\002', __1 = 2 '\\002'}, b = 514}\n+// gdbr-check:$1 = union_smoke::U {a: (2, 2), b: 514}\n // gdb-command:print union_smoke::SU\n-// gdb-check:$2 = {a = {__0 = 1 '\\001', __1 = 1 '\\001'}, b = 257}\n+// gdbg-check:$2 = {a = {__0 = 1 '\\001', __1 = 1 '\\001'}, b = 257}\n+// gdbr-check:$2 = union_smoke::U {a: (1, 1), b: 257}\n \n // === LLDB TESTS ==================================================================================\n "}, {"sha": "e882544b802bda7e24ce793a48a7a65a89126dc8", "filename": "src/test/debuginfo/unique-enum.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funique-enum.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,13 +18,16 @@\n // gdb-command:run\n \n // gdb-command:print *the_a\n-// gdb-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, __0 = 0, __1 = 2088533116, __2 = 2088533116}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, __0 = 0, __1 = 2088533116, __2 = 2088533116}}\n+// gdbr-check:$1 = unique_enum::ABC::TheA{x: 0, y: 8970181431921507452}\n \n // gdb-command:print *the_b\n-// gdb-check:$2 = {{RUST$ENUM$DISR = TheB, x = 0, y = 1229782938247303441}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, x = 0, y = 1229782938247303441}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n+// gdbr-check:$2 = unique_enum::ABC::TheB(0, 286331153, 286331153)\n \n // gdb-command:print *univariant\n-// gdb-check:$3 = {{__0 = 123234}}\n+// gdbg-check:$3 = {{__0 = 123234}}\n+// gdbr-check:$3 = unique_enum::Univariant::TheOnlyCase(123234)\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "b9a1d73b6d8696de85d1c44237e1678be2e89562", "filename": "src/test/debuginfo/var-captured-in-nested-closure.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -21,9 +21,11 @@\n // gdb-command:print constant\n // gdb-check:$2 = 2\n // gdb-command:print a_struct\n-// gdb-check:$3 = {a = -3, b = 4.5, c = 5}\n+// gdbg-check:$3 = {a = -3, b = 4.5, c = 5}\n+// gdbr-check:$3 = var_captured_in_nested_closure::Struct {a: -3, b: 4.5, c: 5}\n // gdb-command:print *struct_ref\n-// gdb-check:$4 = {a = -3, b = 4.5, c = 5}\n+// gdbg-check:$4 = {a = -3, b = 4.5, c = 5}\n+// gdbr-check:$4 = var_captured_in_nested_closure::Struct {a: -3, b: 4.5, c: 5}\n // gdb-command:print *owned\n // gdb-check:$5 = 6\n // gdb-command:print closure_local\n@@ -35,9 +37,11 @@\n // gdb-command:print constant\n // gdb-check:$8 = 2\n // gdb-command:print a_struct\n-// gdb-check:$9 = {a = -3, b = 4.5, c = 5}\n+// gdbg-check:$9 = {a = -3, b = 4.5, c = 5}\n+// gdbr-check:$9 = var_captured_in_nested_closure::Struct {a: -3, b: 4.5, c: 5}\n // gdb-command:print *struct_ref\n-// gdb-check:$10 = {a = -3, b = 4.5, c = 5}\n+// gdbg-check:$10 = {a = -3, b = 4.5, c = 5}\n+// gdbr-check:$10 = var_captured_in_nested_closure::Struct {a: -3, b: 4.5, c: 5}\n // gdb-command:print *owned\n // gdb-check:$11 = 6\n // gdb-command:print closure_local"}, {"sha": "120bbdd7ba9022a70b1964e388804a88306cc434", "filename": "src/test/debuginfo/var-captured-in-sendable-closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -19,7 +19,8 @@\n // gdb-command:print constant\n // gdb-check:$1 = 1\n // gdb-command:print a_struct\n-// gdb-check:$2 = {a = -2, b = 3.5, c = 4}\n+// gdbg-check:$2 = {a = -2, b = 3.5, c = 4}\n+// gdbr-check:$2 = var_captured_in_sendable_closure::Struct {a: -2, b: 3.5, c: 4}\n // gdb-command:print *owned\n // gdb-check:$3 = 5\n // gdb-command:continue"}, {"sha": "c795a095b9769a095d1ffb7a95a7cc185e24cbda", "filename": "src/test/debuginfo/var-captured-in-stack-closure.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -21,9 +21,11 @@\n // gdb-command:print constant\n // gdb-check:$2 = 2\n // gdb-command:print a_struct\n-// gdb-check:$3 = {a = -3, b = 4.5, c = 5}\n+// gdbg-check:$3 = {a = -3, b = 4.5, c = 5}\n+// gdbr-check:$3 = var_captured_in_stack_closure::Struct {a: -3, b: 4.5, c: 5}\n // gdb-command:print *struct_ref\n-// gdb-check:$4 = {a = -3, b = 4.5, c = 5}\n+// gdbg-check:$4 = {a = -3, b = 4.5, c = 5}\n+// gdbr-check:$4 = var_captured_in_stack_closure::Struct {a: -3, b: 4.5, c: 5}\n // gdb-command:print *owned\n // gdb-check:$5 = 6\n \n@@ -34,9 +36,11 @@\n // gdb-command:print constant\n // gdb-check:$7 = 2\n // gdb-command:print a_struct\n-// gdb-check:$8 = {a = -3, b = 4.5, c = 5}\n+// gdbg-check:$8 = {a = -3, b = 4.5, c = 5}\n+// gdbr-check:$8 = var_captured_in_stack_closure::Struct {a: -3, b: 4.5, c: 5}\n // gdb-command:print *struct_ref\n-// gdb-check:$9 = {a = -3, b = 4.5, c = 5}\n+// gdbg-check:$9 = {a = -3, b = 4.5, c = 5}\n+// gdbr-check:$9 = var_captured_in_stack_closure::Struct {a: -3, b: 4.5, c: 5}\n // gdb-command:print *owned\n // gdb-check:$10 = 6\n "}, {"sha": "5553f8427e90fe97d5e2b78575a14c274614997a", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -21,42 +21,57 @@\n \n // gdb-command:print singleton.length\n // gdb-check:$2 = 1\n-// gdb-command:print *((int64_t[1]*)(singleton.data_ptr))\n-// gdb-check:$3 = {1}\n+// gdbg-command:print *((int64_t[1]*)(singleton.data_ptr))\n+// gdbr-command:print *(singleton.data_ptr as &[i64; 1])\n+// gdbg-check:$3 = {1}\n+// gdbr-check:$3 = [1]\n \n // gdb-command:print multiple.length\n // gdb-check:$4 = 4\n-// gdb-command:print *((int64_t[4]*)(multiple.data_ptr))\n-// gdb-check:$5 = {2, 3, 4, 5}\n+// gdbg-command:print *((int64_t[4]*)(multiple.data_ptr))\n+// gdbr-command:print *(multiple.data_ptr as &[i64; 4])\n+// gdbg-check:$5 = {2, 3, 4, 5}\n+// gdbr-check:$5 = [2, 3, 4, 5]\n \n // gdb-command:print slice_of_slice.length\n // gdb-check:$6 = 2\n-// gdb-command:print *((int64_t[2]*)(slice_of_slice.data_ptr))\n-// gdb-check:$7 = {3, 4}\n+// gdbg-command:print *((int64_t[2]*)(slice_of_slice.data_ptr))\n+// gdbr-command:print *(slice_of_slice.data_ptr as &[i64; 2])\n+// gdbg-check:$7 = {3, 4}\n+// gdbr-check:$7 = [3, 4]\n \n // gdb-command:print padded_tuple.length\n // gdb-check:$8 = 2\n // gdb-command:print padded_tuple.data_ptr[0]\n-// gdb-check:$9 = {__0 = 6, __1 = 7}\n+// gdbg-check:$9 = {__0 = 6, __1 = 7}\n+// gdbr-check:$9 = (6, 7)\n // gdb-command:print padded_tuple.data_ptr[1]\n-// gdb-check:$10 = {__0 = 8, __1 = 9}\n+// gdbg-check:$10 = {__0 = 8, __1 = 9}\n+// gdbr-check:$10 = (8, 9)\n \n // gdb-command:print padded_struct.length\n // gdb-check:$11 = 2\n // gdb-command:print padded_struct.data_ptr[0]\n-// gdb-check:$12 = {x = 10, y = 11, z = 12}\n+// gdbg-check:$12 = {x = 10, y = 11, z = 12}\n+// gdbr-check:$12 = vec_slices::AStruct {x: 10, y: 11, z: 12}\n // gdb-command:print padded_struct.data_ptr[1]\n-// gdb-check:$13 = {x = 13, y = 14, z = 15}\n+// gdbg-check:$13 = {x = 13, y = 14, z = 15}\n+// gdbr-check:$13 = vec_slices::AStruct {x: 13, y: 14, z: 15}\n \n-// gdb-command:print 'vec_slices::MUT_VECT_SLICE'.length\n+// gdbg-command:print 'vec_slices::MUT_VECT_SLICE'.length\n+// gdbr-command:print MUT_VECT_SLICE.length\n // gdb-check:$14 = 2\n-// gdb-command:print *((int64_t[2]*)('vec_slices::MUT_VECT_SLICE'.data_ptr))\n-// gdb-check:$15 = {64, 65}\n+// gdbg-command:print *((int64_t[2]*)('vec_slices::MUT_VECT_SLICE'.data_ptr))\n+// gdbr-command:print *(MUT_VECT_SLICE.data_ptr as &[i64; 2])\n+// gdbg-check:$15 = {64, 65}\n+// gdbr-check:$15 = [64, 65]\n \n //gdb-command:print mut_slice.length\n //gdb-check:$16 = 5\n-//gdb-command:print *((int64_t[5]*)(mut_slice.data_ptr))\n-//gdb-check:$17 = {1, 2, 3, 4, 5}\n+//gdbg-command:print *((int64_t[5]*)(mut_slice.data_ptr))\n+//gdbr-command:print *(mut_slice.data_ptr as &[i64; 5])\n+//gdbg-check:$17 = {1, 2, 3, 4, 5}\n+//gdbr-check:$17 = [1, 2, 3, 4, 5]\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "fbb33b94d95770e8e79533513af65d45f018ce14", "filename": "src/test/debuginfo/vec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Fdebuginfo%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -16,9 +16,11 @@\n \n // gdb-command:run\n // gdb-command:print a\n-// gdb-check:$1 = {1, 2, 3}\n+// gdbg-check:$1 = {1, 2, 3}\n+// gdbr-check:$1 = [1, 2, 3]\n // gdb-command:print vec::VECT\n-// gdb-check:$2 = {4, 5, 6}\n+// gdbg-check:$2 = {4, 5, 6}\n+// gdbr-check:$2 = [4, 5, 6]\n \n \n // === LLDB TESTS =================================================================================="}, {"sha": "34fb5db32f95afd1334b55b670f45aabfb557132", "filename": "src/test/run-make/windows-subsystem/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-make%2Fwindows-subsystem%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-make%2Fwindows-subsystem%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwindows-subsystem%2FMakefile?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) windows.rs\n+\t$(RUSTC) console.rs"}, {"sha": "3aedb0ecab722f6a8ef6a82e6bbc909cd6066068", "filename": "src/test/run-make/windows-subsystem/console.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-make%2Fwindows-subsystem%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-make%2Fwindows-subsystem%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwindows-subsystem%2Fconsole.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(windows_subsystem)]\n+#![windows_subsystem = \"console\"]\n+\n+fn main() {}\n+"}, {"sha": "5d875a5a1bf1f5ee7e371297f3f82067707c6352", "filename": "src/test/run-make/windows-subsystem/windows.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-make%2Fwindows-subsystem%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-make%2Fwindows-subsystem%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwindows-subsystem%2Fwindows.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(windows_subsystem)]\n+#![windows_subsystem = \"windows\"]\n+\n+fn main() {}"}, {"sha": "6ac0d5ad1a3bc89e9f145548c16511f60afbebbb", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,10 +18,10 @@ extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::parse::token::{self, str_to_ident, NtExpr, NtPat};\n+use syntax::parse::token::{str_to_ident, NtExpr, NtPat};\n use syntax::ast::{Pat};\n use syntax::tokenstream::{TokenTree};\n-use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n+use syntax::ext::base::{ExtCtxt, MacResult, MacEager};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use syntax::ext::tt::macro_parser::{Success, Failure, Error};\n@@ -30,35 +30,12 @@ use syntax::ptr::P;\n use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n-fn expand_mbe_matches(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n+fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n         -> Box<MacResult + 'static> {\n \n     let mbe_matcher = quote_matcher!(cx, $matched:expr, $($pat:pat)|+);\n-\n-    let mac_expr = match TokenTree::parse(cx, &mbe_matcher[..], args) {\n-        Success(map) => {\n-            match (&*map[&str_to_ident(\"matched\")], &*map[&str_to_ident(\"pat\")]) {\n-                (&MatchedNonterminal(NtExpr(ref matched_expr)),\n-                 &MatchedSeq(ref pats, seq_sp)) => {\n-                    let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt|\n-                        if let &MatchedNonterminal(NtPat(ref pat)) = &**pat_nt {\n-                            pat.clone()\n-                        } else {\n-                            unreachable!()\n-                        }\n-                    ).collect();\n-                    let arm = cx.arm(seq_sp, pats, cx.expr_bool(seq_sp, true));\n-\n-                    quote_expr!(cx,\n-                        match $matched_expr {\n-                            $arm\n-                            _ => false\n-                        }\n-                    )\n-                }\n-                _ => unreachable!()\n-            }\n-        }\n+    let map = match TokenTree::parse(cx, &mbe_matcher, args) {\n+        Success(map) => map,\n         Failure(_, tok) => {\n             panic!(\"expected Success, but got Failure: {}\", parse_failure_msg(tok));\n         }\n@@ -67,6 +44,34 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         }\n     };\n \n+    let matched_nt = match *map[&str_to_ident(\"matched\")] {\n+        MatchedNonterminal(ref nt) => nt.clone(),\n+        _ => unreachable!(),\n+    };\n+\n+    let mac_expr = match (&*matched_nt, &*map[&str_to_ident(\"pat\")]) {\n+        (&NtExpr(ref matched_expr), &MatchedSeq(ref pats, seq_sp)) => {\n+            let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt| {\n+                match **pat_nt {\n+                    MatchedNonterminal(ref nt) => match **nt {\n+                        NtPat(ref pat) => pat.clone(),\n+                        _ => unreachable!(),\n+                    },\n+                    _ => unreachable!(),\n+                }\n+            }).collect();\n+            let arm = cx.arm(seq_sp, pats, cx.expr_bool(seq_sp, true));\n+\n+            quote_expr!(cx,\n+                match $matched_expr {\n+                    $arm\n+                    _ => false\n+                }\n+            )\n+        }\n+        _ => unreachable!()\n+    };\n+\n     MacEager::expr(mac_expr)\n }\n "}, {"sha": "832ee1d7c1b456be5e7a6744518041a400b4bc67", "filename": "src/test/run-pass/auxiliary/issue-36954.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-36954.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-36954.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-36954.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+#![crate_type = \"lib\"]\n+\n+const fn foo(i: i32) -> i32 {\n+    i\n+}\n+\n+pub const FOO: i32 = foo(1);"}, {"sha": "f8330ba99b7ae80fd0695c403a62884fdea94f80", "filename": "src/test/run-pass/issue-36954.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-pass%2Fissue-36954.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-pass%2Fissue-36954.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-36954.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-36954.rs\n+\n+extern crate issue_36954 as lib;\n+\n+fn main() {\n+    let _ = lib::FOO;\n+}"}, {"sha": "292761dfd005f35d9c2697d59a6a2390d99e8db9", "filename": "src/test/run-pass/struct-path-associated-type.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-pass%2Fstruct-path-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-pass%2Fstruct-path-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-path-associated-type.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(more_struct_aliases)]\n+\n struct S<T, U = u16> {\n     a: T,\n     b: U,"}, {"sha": "b569ab62c1bfa5469844846cb3acc54813c6b3e0", "filename": "src/test/run-pass/struct-path-self.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-pass%2Fstruct-path-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftest%2Frun-pass%2Fstruct-path-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-path-self.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(more_struct_aliases)]\n+\n use std::ops::Add;\n \n struct S<T, U = u16> {"}, {"sha": "34f3837d8bbb0605a44460fd07fc01c456e7f90b", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -146,8 +146,14 @@ pub struct Config {\n     // Host triple for the compiler being invoked\n     pub host: String,\n \n-    // Version of GDB\n-    pub gdb_version: Option<String>,\n+    // Path to / name of the GDB executable\n+    pub gdb: Option<String>,\n+\n+    // Version of GDB, encoded as ((major * 1000) + minor) * 1000 + patch\n+    pub gdb_version: Option<u32>,\n+\n+    // Whether GDB has native rust support\n+    pub gdb_native_rust: bool,\n \n     // Version of LLDB\n     pub lldb_version: Option<String>,"}, {"sha": "e57c9949b1c57b84439fbf371a213ef5e7e6f174", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -18,6 +18,8 @@ use common::Config;\n use common;\n use util;\n \n+use extract_gdb_version;\n+\n /// Properties which must be known very early, before actually running\n /// the test.\n pub struct EarlyProps {\n@@ -75,15 +77,15 @@ impl EarlyProps {\n                 return true;\n             }\n \n-            if let Some(ref actual_version) = config.gdb_version {\n+            if let Some(actual_version) = config.gdb_version {\n                 if line.contains(\"min-gdb-version\") {\n                     let min_version = line.trim()\n                         .split(' ')\n                         .last()\n                         .expect(\"Malformed GDB version directive\");\n                     // Ignore if actual version is smaller the minimum required\n                     // version\n-                    gdb_version_to_int(actual_version) < gdb_version_to_int(min_version)\n+                    actual_version < extract_gdb_version(min_version).unwrap()\n                 } else {\n                     false\n                 }\n@@ -464,23 +466,6 @@ pub fn parse_name_value_directive(line: &str, directive: &str) -> Option<String>\n     }\n }\n \n-pub fn gdb_version_to_int(version_string: &str) -> isize {\n-    let error_string = format!(\"Encountered GDB version string with unexpected format: {}\",\n-                               version_string);\n-    let error_string = error_string;\n-\n-    let components: Vec<&str> = version_string.trim().split('.').collect();\n-\n-    if components.len() != 2 {\n-        panic!(\"{}\", error_string);\n-    }\n-\n-    let major: isize = components[0].parse().ok().expect(&error_string);\n-    let minor: isize = components[1].parse().ok().expect(&error_string);\n-\n-    return major * 1000 + minor;\n-}\n-\n pub fn lldb_version_to_int(version_string: &str) -> isize {\n     let error_string = format!(\"Encountered LLDB version string with unexpected format: {}\",\n                                version_string);"}, {"sha": "806363679d174cd6c4ee2b1c7d77d34211d569df", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 137, "deletions": 38, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -12,6 +12,7 @@\n \n #![feature(box_syntax)]\n #![feature(rustc_private)]\n+#![feature(static_in_const)]\n #![feature(test)]\n #![feature(libc)]\n \n@@ -35,6 +36,7 @@ use std::ffi::OsString;\n use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n+use std::process::Command;\n use getopts::{optopt, optflag, reqopt};\n use common::Config;\n use common::{Pretty, DebugInfoGdb, DebugInfoLldb, Mode};\n@@ -98,7 +100,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           optopt(\"\", \"logfile\", \"file to log test execution to\", \"FILE\"),\n           optopt(\"\", \"target\", \"the target to build for\", \"TARGET\"),\n           optopt(\"\", \"host\", \"the host to build for\", \"HOST\"),\n-          optopt(\"\", \"gdb-version\", \"the version of GDB used\", \"VERSION STRING\"),\n+          optopt(\"\", \"gdb\", \"path to GDB to use for GDB debuginfo tests\", \"PATH\"),\n           optopt(\"\", \"lldb-version\", \"the version of LLDB used\", \"VERSION STRING\"),\n           optopt(\"\", \"llvm-version\", \"the version of LLVM used\", \"VERSION STRING\"),\n           optopt(\"\", \"android-cross-path\", \"Android NDK standalone path\", \"PATH\"),\n@@ -149,6 +151,8 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         }\n     }\n \n+    let (gdb, gdb_version, gdb_native_rust) = analyze_gdb(matches.opt_str(\"gdb\"));\n+\n     Config {\n         compile_lib_path: make_absolute(opt_path(matches, \"compile-lib-path\")),\n         run_lib_path: make_absolute(opt_path(matches, \"run-lib-path\")),\n@@ -171,7 +175,9 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         target_rustcflags: matches.opt_str(\"target-rustcflags\"),\n         target: opt_str2(matches.opt_str(\"target\")),\n         host: opt_str2(matches.opt_str(\"host\")),\n-        gdb_version: extract_gdb_version(matches.opt_str(\"gdb-version\")),\n+        gdb: gdb,\n+        gdb_version: gdb_version,\n+        gdb_native_rust: gdb_native_rust,\n         lldb_version: extract_lldb_version(matches.opt_str(\"lldb-version\")),\n         llvm_version: matches.opt_str(\"llvm-version\"),\n         android_cross_path: opt_path(matches, \"android-cross-path\"),\n@@ -470,44 +476,96 @@ pub fn make_test_closure(config: &Config, testpaths: &TestPaths) -> test::TestFn\n     }))\n }\n \n-fn extract_gdb_version(full_version_line: Option<String>) -> Option<String> {\n-    match full_version_line {\n-        Some(ref full_version_line)\n-          if !full_version_line.trim().is_empty() => {\n-            let full_version_line = full_version_line.trim();\n+/// Returns (Path to GDB, GDB Version, GDB has Rust Support)\n+fn analyze_gdb(gdb: Option<String>) -> (Option<String>, Option<u32>, bool) {\n+    #[cfg(not(windows))]\n+    const GDB_FALLBACK: &str = \"gdb\";\n+    #[cfg(windows)]\n+    const GDB_FALLBACK: &str = \"gdb.exe\";\n \n-            // used to be a regex \"(^|[^0-9])([0-9]\\.[0-9]+)\"\n-            for (pos, c) in full_version_line.char_indices() {\n-                if !c.is_digit(10) {\n-                    continue\n-                }\n-                if pos + 2 >= full_version_line.len() {\n-                    continue\n-                }\n-                if full_version_line[pos + 1..].chars().next().unwrap() != '.' {\n-                    continue\n-                }\n-                if !full_version_line[pos + 2..].chars().next().unwrap().is_digit(10) {\n-                    continue\n-                }\n-                if pos > 0 && full_version_line[..pos].chars().next_back()\n-                                                      .unwrap().is_digit(10) {\n-                    continue\n-                }\n-                let mut end = pos + 3;\n-                while end < full_version_line.len() &&\n-                      full_version_line[end..].chars().next()\n-                                              .unwrap().is_digit(10) {\n-                    end += 1;\n-                }\n-                return Some(full_version_line[pos..end].to_owned());\n-            }\n-            println!(\"Could not extract GDB version from line '{}'\",\n-                     full_version_line);\n-            None\n-        },\n-        _ => None\n+    const MIN_GDB_WITH_RUST: u32 = 7011010;\n+\n+    let gdb = match gdb {\n+        None => GDB_FALLBACK,\n+        Some(ref s) if s.is_empty() => GDB_FALLBACK, // may be empty if configure found no gdb\n+        Some(ref s) => s,\n+    };\n+\n+    let version_line = Command::new(gdb).arg(\"--version\").output().map(|output| {\n+        String::from_utf8_lossy(&output.stdout).lines().next().unwrap().to_string()\n+    }).ok();\n+\n+    let version = match version_line {\n+        Some(line) => extract_gdb_version(&line),\n+        None => return (None, None, false),\n+    };\n+\n+    let gdb_native_rust = version.map_or(false, |v| v >= MIN_GDB_WITH_RUST);\n+\n+    return (Some(gdb.to_owned()), version, gdb_native_rust);\n+}\n+\n+fn extract_gdb_version(full_version_line: &str) -> Option<u32> {\n+    let full_version_line = full_version_line.trim();\n+\n+    // GDB versions look like this: \"major.minor.patch?.yyyymmdd?\", with both\n+    // of the ? sections being optional\n+\n+    // We will parse up to 3 digits for minor and patch, ignoring the date\n+    // We limit major to 1 digit, otherwise, on openSUSE, we parse the openSUSE version\n+\n+    // don't start parsing in the middle of a number\n+    let mut prev_was_digit = false;\n+    for (pos, c) in full_version_line.char_indices() {\n+        if prev_was_digit || !c.is_digit(10) {\n+            prev_was_digit = c.is_digit(10);\n+            continue\n+        }\n+\n+        prev_was_digit = true;\n+\n+        let line = &full_version_line[pos..];\n+\n+        let next_split = match line.find(|c: char| !c.is_digit(10)) {\n+            Some(idx) => idx,\n+            None => continue, // no minor version\n+        };\n+\n+        if line.as_bytes()[next_split] != b'.' {\n+            continue; // no minor version\n+        }\n+\n+        let major = &line[..next_split];\n+        let line = &line[next_split + 1..];\n+\n+        let (minor, patch) = match line.find(|c: char| !c.is_digit(10)) {\n+            Some(idx) => if line.as_bytes()[idx] == b'.' {\n+                let patch = &line[idx + 1..];\n+\n+                let patch_len = patch.find(|c: char| !c.is_digit(10)).unwrap_or(patch.len());\n+                let patch = &patch[..patch_len];\n+                let patch = if patch_len > 3 || patch_len == 0 { None } else { Some(patch) };\n+\n+                (&line[..idx], patch)\n+            } else {\n+                (&line[..idx], None)\n+            },\n+            None => (line, None),\n+        };\n+\n+        if major.len() != 1 || minor.is_empty() {\n+            continue;\n+        }\n+\n+        let major: u32 = major.parse().unwrap();\n+        let minor: u32 = minor.parse().unwrap();\n+        let patch: u32 = patch.unwrap_or(\"0\").parse().unwrap();\n+\n+        return Some(((major * 1000) + minor) * 1000 + patch);\n     }\n+\n+    println!(\"Could not extract GDB version from line '{}'\", full_version_line);\n+    None\n }\n \n fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n@@ -553,3 +611,44 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n fn is_blacklisted_lldb_version(version: &str) -> bool {\n     version == \"350\"\n }\n+\n+#[test]\n+fn test_extract_gdb_version() {\n+    macro_rules! test { ($($expectation:tt: $input:tt,)*) => {{$(\n+        assert_eq!(extract_gdb_version($input), Some($expectation));\n+    )*}}}\n+\n+    test! {\n+        7000001: \"GNU gdb (GDB) CentOS (7.0.1-45.el5.centos)\",\n+\n+        7002000: \"GNU gdb (GDB) Red Hat Enterprise Linux (7.2-90.el6)\",\n+\n+        7004000: \"GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04\",\n+        7004001: \"GNU gdb (GDB) 7.4.1-debian\",\n+\n+        7006001: \"GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-80.el7\",\n+\n+        7007001: \"GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1\",\n+        7007001: \"GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1\",\n+        7007001: \"GNU gdb (GDB) Fedora 7.7.1-21.fc20\",\n+\n+        7008000: \"GNU gdb (GDB; openSUSE 13.2) 7.8\",\n+        7009001: \"GNU gdb (GDB) Fedora 7.9.1-20.fc22\",\n+        7010001: \"GNU gdb (GDB) Fedora 7.10.1-31.fc23\",\n+\n+        7011000: \"GNU gdb (Ubuntu 7.11-0ubuntu1) 7.11\",\n+        7011001: \"GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\",\n+        7011001: \"GNU gdb (Debian 7.11.1-2) 7.11.1\",\n+        7011001: \"GNU gdb (GDB) Fedora 7.11.1-86.fc24\",\n+        7011001: \"GNU gdb (GDB; openSUSE Leap 42.1) 7.11.1\",\n+        7011001: \"GNU gdb (GDB; openSUSE Tumbleweed) 7.11.1\",\n+\n+        7011090: \"7.11.90\",\n+        7011090: \"GNU gdb (Ubuntu 7.11.90.20161005-0ubuntu1) 7.11.90.20161005-git\",\n+\n+        7012000: \"7.12\",\n+        7012000: \"GNU gdb (GDB) 7.12\",\n+        7012000: \"GNU gdb (GDB) 7.12.20161027-git\",\n+        7012050: \"GNU gdb (GDB) 7.12.50.20161027-git\",\n+    }\n+}"}, {"sha": "8cb2e3b1c2de336ab70a60bcd50be95993f97e4a", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 50, "deletions": 33, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -32,6 +32,8 @@ use std::path::{Path, PathBuf};\n use std::process::{Command, Output, ExitStatus};\n use std::str;\n \n+use extract_gdb_version;\n+\n pub fn run(config: Config, testpaths: &TestPaths) {\n     match &*config.target {\n \n@@ -41,7 +43,12 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n             }\n         }\n \n-        _=> { }\n+        _ => {\n+            // android has it's own gdb handling\n+            if config.mode == DebugInfoGdb && config.gdb.is_none() {\n+                panic!(\"gdb not available but debuginfo gdb debuginfo test requested\");\n+            }\n+        }\n     }\n \n     if config.verbose {\n@@ -430,11 +437,23 @@ actual:\\n\\\n     }\n \n     fn run_debuginfo_gdb_test_no_opt(&self) {\n+        let prefixes = if self.config.gdb_native_rust {\n+            // GDB with Rust\n+            static PREFIXES: &'static [&'static str] = &[\"gdb\", \"gdbr\"];\n+            println!(\"NOTE: compiletest thinks it is using GDB with native rust support\");\n+            PREFIXES\n+        } else {\n+            // Generic GDB\n+            static PREFIXES: &'static [&'static str] = &[\"gdb\", \"gdbg\"];\n+            println!(\"NOTE: compiletest thinks it is using GDB without native rust support\");\n+            PREFIXES\n+        };\n+\n         let DebuggerCommands {\n             commands,\n             check_lines,\n             breakpoint_lines\n-        } = self.parse_debugger_commands(\"gdb\");\n+        } = self.parse_debugger_commands(prefixes);\n         let mut cmds = commands.join(\"\\n\");\n \n         // compile test file (it should have 'compile-flags:-g' in the header)\n@@ -586,19 +605,18 @@ actual:\\n\\\n                 script_str.push_str(\"show version\\n\");\n \n                 match self.config.gdb_version {\n-                    Some(ref version) => {\n+                    Some(version) => {\n                         println!(\"NOTE: compiletest thinks it is using GDB version {}\",\n                                  version);\n \n-                        if header::gdb_version_to_int(version) >\n-                            header::gdb_version_to_int(\"7.4\") {\n-                                // Add the directory containing the pretty printers to\n-                                // GDB's script auto loading safe path\n-                                script_str.push_str(\n-                                    &format!(\"add-auto-load-safe-path {}\\n\",\n-                                             rust_pp_module_abs_path.replace(r\"\\\", r\"\\\\\"))\n-                                );\n-                            }\n+                        if version > extract_gdb_version(\"7.4\").unwrap() {\n+                            // Add the directory containing the pretty printers to\n+                            // GDB's script auto loading safe path\n+                            script_str.push_str(\n+                                &format!(\"add-auto-load-safe-path {}\\n\",\n+                                         rust_pp_module_abs_path.replace(r\"\\\", r\"\\\\\"))\n+                            );\n+                        }\n                     }\n                     _ => {\n                         println!(\"NOTE: compiletest does not know which version of \\\n@@ -633,11 +651,6 @@ actual:\\n\\\n                 debug!(\"script_str = {}\", script_str);\n                 self.dump_output_file(&script_str, \"debugger.script\");\n \n-                // run debugger script with gdb\n-                fn debugger() -> &'static str {\n-                    if cfg!(windows) {\"gdb.exe\"} else {\"gdb\"}\n-                }\n-\n                 let debugger_script = self.make_out_name(\"debugger.script\");\n \n                 // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -648,7 +661,7 @@ actual:\\n\\\n                          format!(\"-command={}\", debugger_script.to_str().unwrap())];\n \n                 let proc_args = ProcArgs {\n-                    prog: debugger().to_owned(),\n+                    prog: self.config.gdb.as_ref().unwrap().to_owned(),\n                     args: debugger_opts,\n                 };\n \n@@ -731,7 +744,7 @@ actual:\\n\\\n             check_lines,\n             breakpoint_lines,\n             ..\n-        } = self.parse_debugger_commands(\"lldb\");\n+        } = self.parse_debugger_commands(&[\"lldb\"]);\n \n         // Write debugger script:\n         // We don't want to hang when calling `quit` while the process is still running\n@@ -826,9 +839,11 @@ actual:\\n\\\n         }\n     }\n \n-    fn parse_debugger_commands(&self, debugger_prefix: &str) -> DebuggerCommands {\n-        let command_directive = format!(\"{}-command\", debugger_prefix);\n-        let check_directive = format!(\"{}-check\", debugger_prefix);\n+    fn parse_debugger_commands(&self, debugger_prefixes: &[&str]) -> DebuggerCommands {\n+        let directives = debugger_prefixes.iter().map(|prefix| (\n+            format!(\"{}-command\", prefix),\n+            format!(\"{}-check\", prefix),\n+        )).collect::<Vec<_>>();\n \n         let mut breakpoint_lines = vec![];\n         let mut commands = vec![];\n@@ -842,17 +857,19 @@ actual:\\n\\\n                         breakpoint_lines.push(counter);\n                     }\n \n-                    header::parse_name_value_directive(\n-                        &line,\n-                        &command_directive).map(|cmd| {\n-                            commands.push(cmd)\n-                        });\n-\n-                    header::parse_name_value_directive(\n-                        &line,\n-                        &check_directive).map(|cmd| {\n-                            check_lines.push(cmd)\n-                        });\n+                    for &(ref command_directive, ref check_directive) in &directives {\n+                        header::parse_name_value_directive(\n+                            &line,\n+                            &command_directive).map(|cmd| {\n+                                commands.push(cmd)\n+                            });\n+\n+                        header::parse_name_value_directive(\n+                            &line,\n+                            &check_directive).map(|cmd| {\n+                                check_lines.push(cmd)\n+                            });\n+                    }\n                 }\n                 Err(e) => {\n                     self.fatal(&format!(\"Error while parsing debugger commands: {}\", e))"}, {"sha": "54148b0d2b29de511ff955d3d2a5e46d04f5326e", "filename": "x.py", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/x.py", "raw_url": "https://github.com/rust-lang/rust/raw/3fc8304fd92720c688f3d6ac30b3a728d15f7a33/x.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/x.py?ref=3fc8304fd92720c688f3d6ac30b3a728d15f7a33", "patch": "@@ -0,0 +1,19 @@\n+#!/usr/bin/env python\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import sys\n+import os\n+dir = os.path.dirname(__file__)\n+sys.path.append(os.path.abspath(os.path.join(dir, \"src\", \"bootstrap\")))\n+\n+import bootstrap\n+\n+bootstrap.main()"}]}