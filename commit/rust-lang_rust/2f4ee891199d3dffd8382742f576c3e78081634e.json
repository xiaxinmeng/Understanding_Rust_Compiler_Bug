{"sha": "2f4ee891199d3dffd8382742f576c3e78081634e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNGVlODkxMTk5ZDNkZmZkODM4Mjc0MmY1NzZjM2U3ODA4MTYzNGU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-28T19:22:33Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-28T20:47:45Z"}, "message": "Demode extfmt\n\nNeeds a snapshot before this can be completed, because I changed\nthe mode for conv_poly.", "tree": {"sha": "d23a11352a1adf5eb20741111eb6a3ca22a01510", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d23a11352a1adf5eb20741111eb6a3ca22a01510"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f4ee891199d3dffd8382742f576c3e78081634e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f4ee891199d3dffd8382742f576c3e78081634e", "html_url": "https://github.com/rust-lang/rust/commit/2f4ee891199d3dffd8382742f576c3e78081634e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f4ee891199d3dffd8382742f576c3e78081634e/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21519bc7e0a32e388e8b12be5d36d4440129f417", "url": "https://api.github.com/repos/rust-lang/rust/commits/21519bc7e0a32e388e8b12be5d36d4440129f417", "html_url": "https://github.com/rust-lang/rust/commit/21519bc7e0a32e388e8b12be5d36d4440129f417"}], "stats": {"total": 222, "additions": 117, "deletions": 105}, "files": [{"sha": "714c85c75c36baac8955f39e1e53508c067e56c5", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=2f4ee891199d3dffd8382742f576c3e78081634e", "patch": "@@ -21,7 +21,7 @@ pub unsafe fn reinterpret_cast<T, U>(src: &T) -> U {\n  * reinterpret_cast on managed pointer types.\n  */\n #[inline(always)]\n-pub unsafe fn forget<T>(-thing: T) { rusti::forget(move thing); }\n+pub unsafe fn forget<T>(+thing: T) { rusti::forget(move thing); }\n \n /**\n  * Force-increment the reference count on a shared box. If used\n@@ -40,7 +40,7 @@ pub unsafe fn bump_box_refcount<T>(+t: @T) { forget(move t); }\n  *     assert transmute(\"L\") == ~[76u8, 0u8];\n  */\n #[inline(always)]\n-pub unsafe fn transmute<L, G>(-thing: L) -> G {\n+pub unsafe fn transmute<L, G>(+thing: L) -> G {\n     let newthing: G = reinterpret_cast(&thing);\n     forget(move thing);\n     move newthing"}, {"sha": "ff5fd11ccc2720d9410cfc78edb2f23151f1e3c4", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=2f4ee891199d3dffd8382742f576c3e78081634e", "patch": "@@ -81,14 +81,14 @@ mod ct {\n \n     // A fragment of the output sequence\n     enum Piece { PieceString(~str), PieceConv(Conv), }\n-    type ErrorFn = fn@(~str) -> ! ;\n+    type ErrorFn = fn@(&str) -> ! ;\n \n-    fn parse_fmt_string(s: ~str, error: ErrorFn) -> ~[Piece] {\n+    fn parse_fmt_string(s: &str, error: ErrorFn) -> ~[Piece] {\n         let mut pieces: ~[Piece] = ~[];\n         let lim = str::len(s);\n         let mut buf = ~\"\";\n-        fn flush_buf(+buf: ~str, &pieces: ~[Piece]) -> ~str {\n-            if str::len(buf) > 0 {\n+        fn flush_buf(+buf: ~str, pieces: &mut ~[Piece]) -> ~str {\n+            if buf.len() > 0 {\n                 let piece = PieceString(move buf);\n                 pieces.push(move piece);\n             }\n@@ -108,17 +108,17 @@ mod ct {\n                     buf += curr2;\n                     i += 1;\n                 } else {\n-                    buf = flush_buf(move buf, pieces);\n+                    buf = flush_buf(move buf, &mut pieces);\n                     let rs = parse_conversion(s, i, lim, error);\n                     pieces.push(copy rs.piece);\n                     i = rs.next;\n                 }\n             } else { buf += curr; i += size; }\n         }\n-        flush_buf(move buf, pieces);\n+        flush_buf(move buf, &mut pieces);\n         move pieces\n     }\n-    fn peek_num(s: ~str, i: uint, lim: uint) ->\n+    fn peek_num(s: &str, i: uint, lim: uint) ->\n        Option<{num: uint, next: uint}> {\n         let mut j = i;\n         let mut accum = 0u;\n@@ -140,7 +140,7 @@ mod ct {\n             None\n         }\n     }\n-    fn parse_conversion(s: ~str, i: uint, lim: uint, error: ErrorFn) ->\n+    fn parse_conversion(s: &str, i: uint, lim: uint, error: ErrorFn) ->\n        {piece: Piece, next: uint} {\n         let parm = parse_parameter(s, i, lim);\n         let flags = parse_flags(s, parm.next, lim);\n@@ -155,7 +155,7 @@ mod ct {\n                              ty: ty.ty}),\n              next: ty.next};\n     }\n-    fn parse_parameter(s: ~str, i: uint, lim: uint) ->\n+    fn parse_parameter(s: &str, i: uint, lim: uint) ->\n        {param: Option<int>, next: uint} {\n         if i >= lim { return {param: None, next: i}; }\n         let num = peek_num(s, i, lim);\n@@ -170,34 +170,35 @@ mod ct {\n               }\n             };\n     }\n-    fn parse_flags(s: ~str, i: uint, lim: uint) ->\n+    fn parse_flags(s: &str, i: uint, lim: uint) ->\n        {flags: ~[Flag], next: uint} {\n         let noflags: ~[Flag] = ~[];\n         if i >= lim { return {flags: move noflags, next: i}; }\n \n-        fn more_(f: Flag, s: ~str, i: uint, lim: uint) ->\n+        fn more(f: Flag, s: &str, i: uint, lim: uint) ->\n            {flags: ~[Flag], next: uint} {\n             let next = parse_flags(s, i + 1u, lim);\n             let rest = copy next.flags;\n             let j = next.next;\n             let curr: ~[Flag] = ~[f];\n             return {flags: vec::append(move curr, rest), next: j};\n         }\n-        let more = |x, copy s| more_(x, copy s, i, lim);\n+        // Unfortunate, but because s is borrowed, can't use a closure\n+     //   fn more(f: Flag, s: &str) { more_(f, s, i, lim); }\n         let f = s[i];\n         return if f == '-' as u8 {\n-                more(FlagLeftJustify)\n+                more(FlagLeftJustify, s, i, lim)\n             } else if f == '0' as u8 {\n-                more(FlagLeftZeroPad)\n+                more(FlagLeftZeroPad, s, i, lim)\n             } else if f == ' ' as u8 {\n-                more(FlagSpaceForSign)\n+                more(FlagSpaceForSign, s, i, lim)\n             } else if f == '+' as u8 {\n-                more(FlagSignAlways)\n+                more(FlagSignAlways, s, i, lim)\n             } else if f == '#' as u8 {\n-                more(FlagAlternate)\n+                more(FlagAlternate, s, i, lim)\n             } else { {flags: move noflags, next: i} };\n     }\n-    fn parse_count(s: ~str, i: uint, lim: uint)\n+    fn parse_count(s: &str, i: uint, lim: uint)\n         -> {count: Count, next: uint} {\n         return if i >= lim {\n                 {count: CountImplied, next: i}\n@@ -219,7 +220,7 @@ mod ct {\n                 }\n             };\n     }\n-    fn parse_precision(s: ~str, i: uint, lim: uint) ->\n+    fn parse_precision(s: &str, i: uint, lim: uint) ->\n        {count: Count, next: uint} {\n         return if i >= lim {\n                 {count: CountImplied, next: i}\n@@ -235,7 +236,7 @@ mod ct {\n                 }\n             } else { {count: CountImplied, next: i} };\n     }\n-    fn parse_type(s: ~str, i: uint, lim: uint, error: ErrorFn) ->\n+    fn parse_type(s: &str, i: uint, lim: uint, error: ErrorFn) ->\n        {ty: Ty, next: uint} {\n         if i >= lim { error(~\"missing type in conversion\"); }\n         let tstr = str::slice(s, i, i+1u);\n@@ -269,10 +270,7 @@ mod ct {\n     }\n }\n \n-// Functions used by the fmt extension at runtime. For now there are a lot of\n-// decisions made a runtime. If it proves worthwhile then some of these\n-// conditions can be evaluated at compile-time. For now though it's cleaner to\n-// implement it 0this way, I think.\n+// OLD CODE -- eventually remove\n mod rt {\n     #[legacy_exports];\n     const flag_none : u32 = 0u32;\n@@ -328,7 +326,7 @@ mod rt {\n         let mut unpadded = match cv.precision {\n           CountImplied => s.to_unique(),\n           CountIs(max) => if max as uint < str::char_len(s) {\n-            str::substr(s, 0u, max as uint)\n+            str::substr(s, 0, max as uint)\n           } else {\n             s.to_unique()\n           }\n@@ -338,7 +336,7 @@ mod rt {\n     pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n-              CountImplied => (float::to_str, 6u)\n+              CountImplied => (float::to_str, 6)\n         };\n         let mut s = unsafe { to_str(f, digits) };\n         if 0.0 <= f {\n@@ -404,16 +402,17 @@ mod rt {\n         pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n     }\n \n-    fn pad(cv: Conv, &s: ~str, mode: PadMode) -> ~str {\n+    fn pad(cv: Conv, +s: ~str, mode: PadMode) -> ~str {\n+        let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {\n-          CountImplied => return copy s,\n+          CountImplied => return s,\n           CountIs(width) => {\n               // FIXME: width should probably be uint (see Issue #1996)\n               width as uint\n           }\n         };\n         let strlen = str::char_len(s);\n-        if uwidth <= strlen { return copy s; }\n+        if uwidth <= strlen { return s; }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {\n@@ -444,7 +443,7 @@ mod rt {\n         // zeros. It may make sense to convert zero padding to a precision\n         // instead.\n \n-        if signed && zero_padding && str::len(s) > 0u {\n+        if signed && zero_padding && s.len() > 0 {\n             let head = str::shift_char(&mut s);\n             if head == '+' || head == '-' || head == ' ' {\n                 let headstr = str::from_chars(vec::from_elem(1u, head));\n@@ -461,7 +460,12 @@ mod rt {\n     }\n }\n \n-// XXX remove after snapshots\n+// NEW CODE\n+\n+// Functions used by the fmt extension at runtime. For now there are a lot of\n+// decisions made a runtime. If it proves worthwhile then some of these\n+// conditions can be evaluated at compile-time. For now though it's cleaner to\n+// implement it 0this way, I think.\n mod rt2 {\n     #[legacy_exports];\n     const flag_none : u32 = 0u32;\n@@ -477,7 +481,7 @@ mod rt2 {\n     type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n \n     pure fn conv_int(cv: Conv, i: int) -> ~str {\n-        let radix = 10u;\n+        let radix = 10;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n         if 0 <= i {\n@@ -511,7 +515,7 @@ mod rt2 {\n         let mut s = str::from_char(c);\n         return unsafe { pad(cv, s, PadNozero) };\n     }\n-    pure fn conv_str(cv: Conv, s: &str) -> ~str {\n+    pure fn conv_str(cv: Conv, +s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n@@ -539,8 +543,8 @@ mod rt2 {\n         }\n         return unsafe { pad(cv, s, PadFloat) };\n     }\n-    pure fn conv_poly<T>(cv: Conv, v: T) -> ~str {\n-        let s = sys::log_str(&v);\n+    pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n+        let s = sys::log_str(v);\n         return conv_str(cv, s);\n     }\n \n@@ -593,16 +597,17 @@ mod rt2 {\n         pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n     }\n \n-    fn pad(cv: Conv, &s: ~str, mode: PadMode) -> ~str {\n+    fn pad(cv: Conv, +s: ~str, mode: PadMode) -> ~str {\n+        let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {\n-          CountImplied => return copy s,\n+          CountImplied => return s,\n           CountIs(width) => {\n               // FIXME: width should probably be uint (see Issue #1996)\n               width as uint\n           }\n         };\n         let strlen = str::char_len(s);\n-        if uwidth <= strlen { return copy s; }\n+        if uwidth <= strlen { return s; }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {\n@@ -633,7 +638,7 @@ mod rt2 {\n         // zeros. It may make sense to convert zero padding to a precision\n         // instead.\n \n-        if signed && zero_padding && str::len(s) > 0u {\n+        if signed && zero_padding && s.len() > 0 {\n             let head = str::shift_char(&mut s);\n             if head == '+' || head == '-' || head == ' ' {\n                 let headstr = str::from_chars(vec::from_elem(1u, head));"}, {"sha": "85d921e88331736fb69f51d1f5b3e21098b4aa33", "filename": "src/libcore/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=2f4ee891199d3dffd8382742f576c3e78081634e", "patch": "@@ -328,7 +328,7 @@ pub fn program_output(prog: &str, args: &[~str]) ->\n     return {status: status, out: move outs, err: move errs};\n }\n \n-fn writeclose(fd: c_int, s: &str) {\n+fn writeclose(fd: c_int, +s: ~str) {\n     use io::WriterUtil;\n \n     error!(\"writeclose %d, %s\", fd as int, s);"}, {"sha": "321eb3158a933f65b8b4824e56e5e657df8fa85a", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=2f4ee891199d3dffd8382742f576c3e78081634e", "patch": "@@ -156,14 +156,14 @@ mod v4 {\n     fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {\n         let parts = vec::map(str::split_char(ip, '.'), |s| {\n             match uint::from_str(*s) {\n-              Some(n) if n <= 255u => n,\n-              _ => 256u\n+              Some(n) if n <= 255 => n,\n+              _ => 256\n             }\n         });\n-        if vec::len(parts) != 4u {\n+        if parts.len() != 4 {\n                 result::Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n                 }\n-        else if vec::contains(parts, &256u) {\n+        else if parts.contains(&256) {\n                 result::Err(fmt!(\"invalid octal in addr '%s'\", ip))\n                 }\n         else {"}, {"sha": "7f208a3a710c8f886070dea8c9a5f3798c382a15", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=2f4ee891199d3dffd8382742f576c3e78081634e", "patch": "@@ -10,30 +10,30 @@ export ice_msg;\n export expect;\n \n type emitter = fn@(cmsp: Option<(codemap::codemap, span)>,\n-                   msg: ~str, lvl: level);\n+                   msg: &str, lvl: level);\n \n \n trait span_handler {\n-    fn span_fatal(sp: span, msg: ~str) -> !;\n-    fn span_err(sp: span, msg: ~str);\n-    fn span_warn(sp: span, msg: ~str);\n-    fn span_note(sp: span, msg: ~str);\n-    fn span_bug(sp: span, msg: ~str) -> !;\n-    fn span_unimpl(sp: span, msg: ~str) -> !;\n+    fn span_fatal(sp: span, msg: &str) -> !;\n+    fn span_err(sp: span, msg: &str);\n+    fn span_warn(sp: span, msg: &str);\n+    fn span_note(sp: span, msg: &str);\n+    fn span_bug(sp: span, msg: &str) -> !;\n+    fn span_unimpl(sp: span, msg: &str) -> !;\n     fn handler() -> handler;\n }\n \n trait handler {\n-    fn fatal(msg: ~str) -> !;\n-    fn err(msg: ~str);\n+    fn fatal(msg: &str) -> !;\n+    fn err(msg: &str);\n     fn bump_err_count();\n     fn has_errors() -> bool;\n     fn abort_if_errors();\n-    fn warn(msg: ~str);\n-    fn note(msg: ~str);\n-    fn bug(msg: ~str) -> !;\n-    fn unimpl(msg: ~str) -> !;\n-    fn emit(cmsp: Option<(codemap::codemap, span)>, msg: ~str, lvl: level);\n+    fn warn(msg: &str);\n+    fn note(msg: &str);\n+    fn bug(msg: &str) -> !;\n+    fn unimpl(msg: &str) -> !;\n+    fn emit(cmsp: Option<(codemap::codemap, span)>, msg: &str, lvl: level);\n }\n \n type handler_t = @{\n@@ -47,24 +47,24 @@ type codemap_t = @{\n };\n \n impl codemap_t: span_handler {\n-    fn span_fatal(sp: span, msg: ~str) -> ! {\n+    fn span_fatal(sp: span, msg: &str) -> ! {\n         self.handler.emit(Some((self.cm, sp)), msg, fatal);\n         fail;\n     }\n-    fn span_err(sp: span, msg: ~str) {\n+    fn span_err(sp: span, msg: &str) {\n         self.handler.emit(Some((self.cm, sp)), msg, error);\n         self.handler.bump_err_count();\n     }\n-    fn span_warn(sp: span, msg: ~str) {\n+    fn span_warn(sp: span, msg: &str) {\n         self.handler.emit(Some((self.cm, sp)), msg, warning);\n     }\n-    fn span_note(sp: span, msg: ~str) {\n+    fn span_note(sp: span, msg: &str) {\n         self.handler.emit(Some((self.cm, sp)), msg, note);\n     }\n-    fn span_bug(sp: span, msg: ~str) -> ! {\n+    fn span_bug(sp: span, msg: &str) -> ! {\n         self.span_fatal(sp, ice_msg(msg));\n     }\n-    fn span_unimpl(sp: span, msg: ~str) -> ! {\n+    fn span_unimpl(sp: span, msg: &str) -> ! {\n         self.span_bug(sp, ~\"unimplemented \" + msg);\n     }\n     fn handler() -> handler {\n@@ -73,11 +73,11 @@ impl codemap_t: span_handler {\n }\n \n impl handler_t: handler {\n-    fn fatal(msg: ~str) -> ! {\n+    fn fatal(msg: &str) -> ! {\n         self.emit(None, msg, fatal);\n         fail;\n     }\n-    fn err(msg: ~str) {\n+    fn err(msg: &str) {\n         self.emit(None, msg, error);\n         self.bump_err_count();\n     }\n@@ -97,22 +97,22 @@ impl handler_t: handler {\n         }\n         self.fatal(s);\n     }\n-    fn warn(msg: ~str) {\n+    fn warn(msg: &str) {\n         self.emit(None, msg, warning);\n     }\n-    fn note(msg: ~str) {\n+    fn note(msg: &str) {\n         self.emit(None, msg, note);\n     }\n-    fn bug(msg: ~str) -> ! {\n+    fn bug(msg: &str) -> ! {\n         self.fatal(ice_msg(msg));\n     }\n-    fn unimpl(msg: ~str) -> ! { self.bug(~\"unimplemented \" + msg); }\n-    fn emit(cmsp: Option<(codemap::codemap, span)>, msg: ~str, lvl: level) {\n+    fn unimpl(msg: &str) -> ! { self.bug(~\"unimplemented \" + msg); }\n+    fn emit(cmsp: Option<(codemap::codemap, span)>, msg: &str, lvl: level) {\n         self.emit(cmsp, msg, lvl);\n     }\n }\n \n-fn ice_msg(msg: ~str) -> ~str {\n+fn ice_msg(msg: &str) -> ~str {\n     fmt!(\"internal compiler error: %s\", msg)\n }\n \n@@ -126,17 +126,19 @@ fn mk_handler(emitter: Option<emitter>) -> handler {\n       Some(e) => e,\n       None => {\n         let f = fn@(cmsp: Option<(codemap::codemap, span)>,\n-            msg: ~str, t: level) {\n+            msg: &str, t: level) {\n             emit(cmsp, msg, t);\n         };\n         f\n       }\n     };\n \n-    @{\n-        mut err_count: 0u,\n+    let x: handler_t = @{\n+        mut err_count: 0,\n         emit: emit\n-    } as handler\n+    };\n+\n+    x as handler\n }\n \n enum level {\n@@ -171,7 +173,7 @@ fn diagnosticcolor(lvl: level) -> u8 {\n     }\n }\n \n-fn print_diagnostic(topic: ~str, lvl: level, msg: ~str) {\n+fn print_diagnostic(topic: ~str, lvl: level, msg: &str) {\n     let use_color = term::color_supported() &&\n         io::stderr().get_type() == io::Screen;\n     if str::is_not_empty(topic) {\n@@ -188,7 +190,7 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: ~str) {\n }\n \n fn emit(cmsp: Option<(codemap::codemap, span)>,\n-        msg: ~str, lvl: level) {\n+        msg: &str, lvl: level) {\n     match cmsp {\n       Some((cm, sp)) => {\n         let sp = codemap::adjust_span(cm,sp);"}, {"sha": "6c71fd8fcbc9467b6caaf86129726cf8a6e81fb8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=2f4ee891199d3dffd8382742f576c3e78081634e", "patch": "@@ -133,12 +133,12 @@ trait ext_ctxt {\n     fn mod_path() -> ~[ast::ident];\n     fn bt_push(ei: codemap::expn_info_);\n     fn bt_pop();\n-    fn span_fatal(sp: span, msg: ~str) -> !;\n-    fn span_err(sp: span, msg: ~str);\n-    fn span_warn(sp: span, msg: ~str);\n-    fn span_unimpl(sp: span, msg: ~str) -> !;\n-    fn span_bug(sp: span, msg: ~str) -> !;\n-    fn bug(msg: ~str) -> !;\n+    fn span_fatal(sp: span, msg: &str) -> !;\n+    fn span_err(sp: span, msg: &str);\n+    fn span_warn(sp: span, msg: &str);\n+    fn span_unimpl(sp: span, msg: &str) -> !;\n+    fn span_bug(sp: span, msg: &str) -> !;\n+    fn bug(msg: &str) -> !;\n     fn next_id() -> ast::node_id;\n     pure fn trace_macros() -> bool;\n     fn set_trace_macros(x: bool);\n@@ -182,27 +182,27 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n               _ => self.bug(~\"tried to pop without a push\")\n             }\n         }\n-        fn span_fatal(sp: span, msg: ~str) -> ! {\n+        fn span_fatal(sp: span, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n         }\n-        fn span_err(sp: span, msg: ~str) {\n+        fn span_err(sp: span, msg: &str) {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_err(sp, msg);\n         }\n-        fn span_warn(sp: span, msg: ~str) {\n+        fn span_warn(sp: span, msg: &str) {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_warn(sp, msg);\n         }\n-        fn span_unimpl(sp: span, msg: ~str) -> ! {\n+        fn span_unimpl(sp: span, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_unimpl(sp, msg);\n         }\n-        fn span_bug(sp: span, msg: ~str) -> ! {\n+        fn span_bug(sp: span, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_bug(sp, msg);\n         }\n-        fn bug(msg: ~str) -> ! {\n+        fn bug(msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.handler().bug(msg);\n         }"}, {"sha": "a43b0cb69f4b68626ffbba2c7dd48b22239ddc96", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=2f4ee891199d3dffd8382742f576c3e78081634e", "patch": "@@ -50,6 +50,10 @@ fn mk_access(cx: ext_ctxt, sp: span, p: ~[ast::ident], m: ast::ident)\n     let pathexpr = mk_path(cx, sp, p);\n     return mk_access_(cx, sp, pathexpr, m);\n }\n+fn mk_addr_of(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+    return mk_expr(cx, sp, ast::expr_addr_of(ast::m_imm, e));\n+}\n+\n fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n             args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, false))"}, {"sha": "8b94620f9b60e86b4daa2669dc35570b006e8aae", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=2f4ee891199d3dffd8382742f576c3e78081634e", "patch": "@@ -20,10 +20,10 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     let fmtspan = args[0].span;\n     debug!(\"Format string:\");\n     log(debug, fmt);\n-    fn parse_fmt_err_(cx: ext_ctxt, sp: span, msg: ~str) -> ! {\n+    fn parse_fmt_err_(cx: ext_ctxt, sp: span, msg: &str) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n-    let parse_fmt_err = fn@(s: ~str) -> ! {\n+    let parse_fmt_err = fn@(s: &str) -> ! {\n         parse_fmt_err_(cx, fmtspan, s)\n     };\n     let pieces = parse_fmt_string(fmt, parse_fmt_err);\n@@ -39,7 +39,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n    -> @ast::expr {\n     fn make_path_vec(_cx: ext_ctxt, ident: @~str) -> ~[ast::ident] {\n         let intr = _cx.parse_sess().interner;\n-        return ~[intr.intern(@~\"extfmt\"), intr.intern(@~\"rt\"),\n+        return ~[intr.intern(@~\"extfmt\"), intr.intern(@~\"rt2\"),\n                  intr.intern(ident)];\n     }\n     fn make_rt_path_expr(cx: ext_ctxt, sp: span, nm: @~str) -> @ast::expr {\n@@ -187,7 +187,8 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n           TyFloat => {\n             return make_conv_call(cx, arg.span, ~\"float\", cnv, arg);\n           }\n-          TyPoly => return make_conv_call(cx, arg.span, ~\"poly\", cnv, arg)\n+          TyPoly => return make_conv_call(cx, arg.span, ~\"poly\", cnv,\n+                                          mk_addr_of(cx, sp, arg))\n         }\n     }\n     fn log_conv(c: Conv) {"}, {"sha": "7db9261d133020fbd4c77f0336b89526ed83460c", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=2f4ee891199d3dffd8382742f576c3e78081634e", "patch": "@@ -236,7 +236,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n         // The 'diagnostics emitter'. Every error, warning, etc. should\n         // go through this function.\n         let demitter = fn@(cmsp: Option<(codemap::codemap, codemap::span)>,\n-                           msg: ~str, lvl: diagnostic::level) {\n+                           msg: &str, lvl: diagnostic::level) {\n             if lvl == diagnostic::fatal {\n                 comm::send(ch, fatal);\n             }"}, {"sha": "ab6b348c04a2d39fd16c5791c7763a34e3d87467", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f4ee891199d3dffd8382742f576c3e78081634e/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=2f4ee891199d3dffd8382742f576c3e78081634e", "patch": "@@ -145,25 +145,25 @@ fn build_error_handlers(\n     };\n \n     impl DiagnosticHandler: diagnostic::handler {\n-        fn fatal(msg: ~str) -> ! { self.inner.fatal(msg) }\n-        fn err(msg: ~str) { self.inner.err(msg) }\n+        fn fatal(msg: &str) -> ! { self.inner.fatal(msg) }\n+        fn err(msg: &str) { self.inner.err(msg) }\n         fn bump_err_count() {\n             self.inner.bump_err_count();\n         }\n         fn has_errors() -> bool { self.inner.has_errors() }\n         fn abort_if_errors() { self.inner.abort_if_errors() }\n-        fn warn(msg: ~str) { self.inner.warn(msg) }\n-        fn note(msg: ~str) { self.inner.note(msg) }\n-        fn bug(msg: ~str) -> ! { self.inner.bug(msg) }\n-        fn unimpl(msg: ~str) -> ! { self.inner.unimpl(msg) }\n+        fn warn(msg: &str) { self.inner.warn(msg) }\n+        fn note(msg: &str) { self.inner.note(msg) }\n+        fn bug(msg: &str) -> ! { self.inner.bug(msg) }\n+        fn unimpl(msg: &str) -> ! { self.inner.unimpl(msg) }\n         fn emit(cmsp: Option<(codemap::codemap, codemap::span)>,\n-                msg: ~str, lvl: diagnostic::level) {\n+                msg: &str, lvl: diagnostic::level) {\n             self.inner.emit(cmsp, msg, lvl)\n         }\n     }\n \n     let emitter = fn@(cmsp: Option<(codemap::codemap, codemap::span)>,\n-                       msg: ~str, lvl: diagnostic::level) {\n+                       msg: &str, lvl: diagnostic::level) {\n         diagnostic::emit(cmsp, msg, lvl);\n     };\n     let inner_handler = diagnostic::mk_handler(Some(emitter));"}]}