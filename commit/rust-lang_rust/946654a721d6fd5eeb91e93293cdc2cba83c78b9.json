{"sha": "946654a721d6fd5eeb91e93293cdc2cba83c78b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NjY1NGE3MjFkNmZkNWVlYjkxZTkzMjkzY2RjMmNiYTgzYzc4Yjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-16T15:25:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-16T15:25:59Z"}, "message": "auto merge of #17197 : nikomatsakis/rust/issue-5527-trait-reform-revisited, r=pcwalton\n\nThis patch does not make many functional changes, but does a lot of restructuring towards the goals of #5527. This is the biggest patch, basically, that should enable most of the other patches in a relatively straightforward way.\r\n\r\nMajor changes:\r\n\r\n- Do not track impls through trans, instead recompute as needed.\r\n- Isolate trait matching code into its own module, carefully structure to distinguish various phases (selection vs confirmation vs fulfillment)\r\n- Consider where clauses in their more general form\r\n- Integrate checking of builtin bounds into the  trait matching process, rather than doing it separately in kind.rs (important for opt-in builtin bounds)\r\n\r\nWhat is not included:\r\n\r\n- Where clauses are still not generalized. This should be a straightforward follow-up patch.\r\n- Caching. I did not include much caching. I have plans for various kinds of caching we can do. Should be straightforward. Preliminary perf measurements suggested that this branch keeps compilation times roughly what they are.\r\n- Method resolution. The initial algorithm I proposed for #5527 does not work as well as I hoped. I have a revised plan which is much more similar to what we do today.\r\n- Deref vs deref-mut. The initial fix I had worked great for autoderef, but not for explicit deref. \r\n- Permitting blanket impls to overlap with specific impls. Initial plan to consider all nested obligations before considering an impl to match caused many compilation errors. We have a revised plan but it is not implemented here, should be a relatively straightforward extension.", "tree": {"sha": "284ceef62c9e2c207acb9c497cadfa53f59994b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/284ceef62c9e2c207acb9c497cadfa53f59994b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/946654a721d6fd5eeb91e93293cdc2cba83c78b9", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/946654a721d6fd5eeb91e93293cdc2cba83c78b9", "html_url": "https://github.com/rust-lang/rust/commit/946654a721d6fd5eeb91e93293cdc2cba83c78b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/946654a721d6fd5eeb91e93293cdc2cba83c78b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdd46f8592a0ca7eb69110bff0569094951ccc67", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdd46f8592a0ca7eb69110bff0569094951ccc67", "html_url": "https://github.com/rust-lang/rust/commit/cdd46f8592a0ca7eb69110bff0569094951ccc67"}, {"sha": "eafeb335a0731b4bfcd8be6203d0d29a3668cd76", "url": "https://api.github.com/repos/rust-lang/rust/commits/eafeb335a0731b4bfcd8be6203d0d29a3668cd76", "html_url": "https://github.com/rust-lang/rust/commit/eafeb335a0731b4bfcd8be6203d0d29a3668cd76"}], "stats": {"total": 8718, "additions": 5676, "deletions": 3042}, "files": [{"sha": "0011a7245e56d0908cbda4b9479f432004ab1624", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -59,7 +59,7 @@ CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n DEPS_core :=\n-DEPS_rlibc :=\n+DEPS_rlibc := core\n DEPS_unicode := core\n DEPS_alloc := core libc native:jemalloc\n DEPS_debug := std"}, {"sha": "8c67634d57aec590dd314fbff95d7497192230d4", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -461,11 +461,12 @@ fn start(_argc: int, _argv: *const *const u8) -> int {\n     0\n }\n \n-// These functions are invoked by the compiler, but not\n+// These functions and traits are used by the compiler, but not\n // for a bare-bones hello world. These are normally\n // provided by libstd.\n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"sized\"] trait Sized { }\n # // fn main() {} tricked you, rustdoc!\n ```\n \n@@ -488,13 +489,14 @@ pub extern fn main(argc: int, argv: *const *const u8) -> int {\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"sized\"] trait Sized { }\n # // fn main() {} tricked you, rustdoc!\n ```\n \n \n The compiler currently makes a few assumptions about symbols which are available\n in the executable to call. Normally these functions are provided by the standard\n-library, but without it you must define your own.\n+xlibrary, but without it you must define your own.\n \n The first of these two functions, `stack_exhausted`, is invoked whenever stack\n overflow is detected.  This function has a number of restrictions about how it\n@@ -508,6 +510,12 @@ mechanisms of the compiler. This is often mapped to GCC's personality function\n information), but crates which do not trigger failure can be assured that this\n function is never called.\n \n+The final item in the example is a trait called `Sized`. This a trait\n+that represents data of a known static size: it is integral to the\n+Rust type system, and so the compiler expects the standard library to\n+provide it. Since you are not using the standard library, you have to\n+provide it yourself.\n+\n ## Using libcore\n \n > **Note**: the core library's structure is unstable, and it is recommended to\n@@ -686,6 +694,7 @@ fn main(argc: int, argv: *const *const u8) -> int {\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"sized\"] trait Sized {}\n ```\n \n Note the use of `abort`: the `exchange_malloc` lang item is assumed to"}, {"sha": "2905b30deeb9a06b1fa01ddfaa89597992f7c8eb", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -238,7 +238,6 @@ mod imp {\n #[cfg(not(jemalloc), unix)]\n mod imp {\n     use core::cmp;\n-    use core::mem;\n     use core::ptr;\n     use libc;\n     use libc_heap;"}, {"sha": "c24a7e9ca77d1f56a459f85cd5b85e4804c24c4f", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -35,12 +35,13 @@\n // LLVM to optimize these function calls to themselves!\n #![no_builtins]\n \n+#[phase(plugin, link)] extern crate core;\n+\n #[cfg(test)] extern crate native;\n #[cfg(test)] extern crate test;\n #[cfg(test)] extern crate debug;\n \n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n-#[cfg(test)] #[phase(plugin, link)] extern crate core;\n \n // Require the offset intrinsics for LLVM to properly optimize the\n // implementations below. If pointer arithmetic is done through integers the"}, {"sha": "af3d19c4d2d4004b3ccbaac7fdd0c2dc76963644", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -108,6 +108,7 @@ pub mod middle {\n     pub mod save;\n     pub mod stability;\n     pub mod subst;\n+    pub mod traits;\n     pub mod trans;\n     pub mod ty;\n     pub mod ty_fold;"}, {"sha": "eed41edac9d6c2dda244b4c8c52c2fcd941b84cd", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -1470,17 +1470,17 @@ impl LintPass for Stability {\n                                 def_id\n                             }\n                             typeck::MethodParam(typeck::MethodParam {\n-                                trait_id: trait_id,\n+                                trait_ref: ref trait_ref,\n                                 method_num: index,\n                                 ..\n-                            })\n-                            | typeck::MethodObject(typeck::MethodObject {\n-                                trait_id: trait_id,\n+                            }) |\n+                            typeck::MethodObject(typeck::MethodObject {\n+                                trait_ref: ref trait_ref,\n                                 method_num: index,\n                                 ..\n                             }) => {\n                                 match ty::trait_item(cx.tcx,\n-                                                     trait_id,\n+                                                     trait_ref.def_id,\n                                                      index) {\n                                     ty::MethodTraitItem(method) => {\n                                         method.def_id"}, {"sha": "3ec91bf9840527668c442f0eb67ca881dcfabac4", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -140,9 +140,10 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_unboxed_closures = 0x54,\n     tag_table_upvar_borrow_map = 0x55,\n     tag_table_capture_modes = 0x56,\n+    tag_table_object_cast_map = 0x57,\n }\n static first_astencode_tag: uint = tag_ast as uint;\n-static last_astencode_tag: uint = tag_table_capture_modes as uint;\n+static last_astencode_tag: uint = tag_table_object_cast_map as uint;\n impl astencode_tag {\n     pub fn from_uint(value : uint) -> Option<astencode_tag> {\n         let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;"}, {"sha": "3ab50b0efd17c77b980e719756e885be79bb3f3b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -20,9 +20,7 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n use middle::ty::{lookup_item_type};\n-use middle::astencode;\n use middle::ty;\n-use middle::typeck;\n use middle::stability;\n use middle;\n use util::nodemap::{NodeMap, NodeSet};\n@@ -125,14 +123,6 @@ fn encode_trait_ref(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_impl_vtables(rbml_w: &mut Encoder,\n-                       ecx: &EncodeContext,\n-                       vtables: &typeck::vtable_res) {\n-    rbml_w.start_tag(tag_item_impl_vtables);\n-    astencode::encode_vtable_res(ecx, rbml_w, vtables);\n-    rbml_w.end_tag();\n-}\n-\n // Item info table encoding\n fn encode_family(rbml_w: &mut Encoder, c: char) {\n     rbml_w.start_tag(tag_items_data_item_family);\n@@ -191,6 +181,18 @@ pub fn write_type(ecx: &EncodeContext,\n     tyencode::enc_ty(rbml_w.writer, ty_str_ctxt, typ);\n }\n \n+pub fn write_trait_ref(ecx: &EncodeContext,\n+                       rbml_w: &mut Encoder,\n+                       trait_ref: &ty::TraitRef) {\n+    let ty_str_ctxt = &tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_string,\n+        tcx: ecx.tcx,\n+        abbrevs: &ecx.type_abbrevs\n+    };\n+    tyencode::enc_trait_ref(rbml_w.writer, ty_str_ctxt, trait_ref);\n+}\n+\n pub fn write_region(ecx: &EncodeContext,\n                     rbml_w: &mut Encoder,\n                     r: ty::Region) {\n@@ -399,7 +401,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n     let impl_items = ecx.tcx.impl_items.borrow();\n     match ecx.tcx.inherent_impls.borrow().find(&exp.def_id) {\n         Some(implementations) => {\n-            for base_impl_did in implementations.borrow().iter() {\n+            for base_impl_did in implementations.iter() {\n                 for &method_did in impl_items.get(base_impl_did).iter() {\n                     let impl_item = ty::impl_or_trait_item(\n                         ecx.tcx,\n@@ -946,7 +948,7 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n     match ecx.tcx.inherent_impls.borrow().find(&def_id) {\n         None => {}\n         Some(implementations) => {\n-            for &impl_def_id in implementations.borrow().iter() {\n+            for &impl_def_id in implementations.iter() {\n                 rbml_w.start_tag(tag_items_data_item_inherent_impl);\n                 encode_def_id(rbml_w, impl_def_id);\n                 rbml_w.end_tag();\n@@ -1203,8 +1205,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let trait_ref = ty::node_id_to_trait_ref(\n                 tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n-            let impl_vtables = ty::lookup_impl_vtables(tcx, def_id);\n-            encode_impl_vtables(rbml_w, ecx, &impl_vtables);\n         }\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);"}, {"sha": "21d0292d2fe3a2508af08aa69041096cfbe1aa7a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 180, "deletions": 60, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -43,6 +43,7 @@ use libc;\n use std::io::Seek;\n use std::mem;\n use std::gc::GC;\n+use std::rc::Rc;\n \n use rbml::io::SeekableMemWriter;\n use rbml::{reader, writer};\n@@ -589,7 +590,7 @@ fn encode_method_callee(ecx: &e::EncodeContext,\n             adjustment.encode(rbml_w)\n         });\n         rbml_w.emit_struct_field(\"origin\", 1u, |rbml_w| {\n-            method.origin.encode(rbml_w)\n+            Ok(rbml_w.emit_method_origin(ecx, &method.origin))\n         });\n         rbml_w.emit_struct_field(\"ty\", 2u, |rbml_w| {\n             Ok(rbml_w.emit_ty(ecx, method.ty))\n@@ -610,9 +611,7 @@ impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n             }).unwrap();\n             Ok((adjustment, MethodCallee {\n                 origin: this.read_struct_field(\"origin\", 1, |this| {\n-                    let method_origin: MethodOrigin =\n-                        Decodable::decode(this).unwrap();\n-                    Ok(method_origin.tr(dcx))\n+                    Ok(this.read_method_origin(dcx))\n                 }).unwrap(),\n                 ty: this.read_struct_field(\"ty\", 2, |this| {\n                     Ok(this.read_ty(dcx))\n@@ -635,15 +634,16 @@ impl tr for MethodOrigin {\n             typeck::MethodParam(ref mp) => {\n                 typeck::MethodParam(\n                     typeck::MethodParam {\n-                        trait_id: mp.trait_id.tr(dcx),\n-                        .. *mp\n+                        // def-id is already translated when we read it out\n+                        trait_ref: mp.trait_ref.clone(),\n+                        method_num: mp.method_num,\n                     }\n                 )\n             }\n             typeck::MethodObject(ref mo) => {\n                 typeck::MethodObject(\n                     typeck::MethodObject {\n-                        trait_id: mo.trait_id.tr(dcx),\n+                        trait_ref: mo.trait_ref.clone(),\n                         .. *mo\n                     }\n                 )\n@@ -655,22 +655,6 @@ impl tr for MethodOrigin {\n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n-fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n-                              rbml_w: &mut Encoder,\n-                              adjustment: typeck::ExprAdjustment,\n-                              dr: &typeck::vtable_res) {\n-    use serialize::Encoder;\n-\n-    rbml_w.emit_struct(\"VtableWithKey\", 2, |rbml_w| {\n-        rbml_w.emit_struct_field(\"adjustment\", 0u, |rbml_w| {\n-            adjustment.encode(rbml_w)\n-        });\n-        rbml_w.emit_struct_field(\"vtable_res\", 1u, |rbml_w| {\n-            Ok(encode_vtable_res(ecx, rbml_w, dr))\n-        })\n-    }).unwrap()\n-}\n-\n pub fn encode_vtable_res(ecx: &e::EncodeContext,\n                          rbml_w: &mut Encoder,\n                          dr: &typeck::vtable_res) {\n@@ -913,11 +897,15 @@ trait rbml_writer_helpers {\n     fn emit_closure_type(&mut self,\n                          ecx: &e::EncodeContext,\n                          closure_type: &ty::ClosureTy);\n+    fn emit_method_origin(&mut self,\n+                          ecx: &e::EncodeContext,\n+                          method_origin: &typeck::MethodOrigin);\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t);\n     fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]);\n     fn emit_type_param_def(&mut self,\n                            ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef);\n+    fn emit_trait_ref(&mut self, ecx: &e::EncodeContext, ty: &ty::TraitRef);\n     fn emit_polytype(&mut self,\n                      ecx: &e::EncodeContext,\n                      pty: ty::Polytype);\n@@ -939,6 +927,63 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n+    fn emit_method_origin(&mut self,\n+                          ecx: &e::EncodeContext,\n+                          method_origin: &typeck::MethodOrigin)\n+    {\n+        use serialize::Encoder;\n+\n+        self.emit_enum(\"MethodOrigin\", |this| {\n+            match *method_origin {\n+                typeck::MethodStatic(def_id) => {\n+                    this.emit_enum_variant(\"MethodStatic\", 0, 1, |this| {\n+                        Ok(this.emit_def_id(def_id))\n+                    })\n+                }\n+\n+                typeck::MethodStaticUnboxedClosure(def_id) => {\n+                    this.emit_enum_variant(\"MethodStaticUnboxedClosure\", 1, 1, |this| {\n+                        Ok(this.emit_def_id(def_id))\n+                    })\n+                }\n+\n+                typeck::MethodParam(ref p) => {\n+                    this.emit_enum_variant(\"MethodParam\", 2, 1, |this| {\n+                        this.emit_struct(\"MethodParam\", 2, |this| {\n+                            try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n+                                Ok(this.emit_trait_ref(ecx, &*p.trait_ref))\n+                            }));\n+                            try!(this.emit_struct_field(\"method_num\", 0, |this| {\n+                                this.emit_uint(p.method_num)\n+                            }));\n+                            Ok(())\n+                        })\n+                    })\n+                }\n+\n+                typeck::MethodObject(ref o) => {\n+                    this.emit_enum_variant(\"MethodObject\", 3, 1, |this| {\n+                        this.emit_struct(\"MethodObject\", 2, |this| {\n+                            try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n+                                Ok(this.emit_trait_ref(ecx, &*o.trait_ref))\n+                            }));\n+                            try!(this.emit_struct_field(\"object_trait_id\", 0, |this| {\n+                                Ok(this.emit_def_id(o.object_trait_id))\n+                            }));\n+                            try!(this.emit_struct_field(\"method_num\", 0, |this| {\n+                                this.emit_uint(o.method_num)\n+                            }));\n+                            try!(this.emit_struct_field(\"real_index\", 0, |this| {\n+                                this.emit_uint(o.real_index)\n+                            }));\n+                            Ok(())\n+                        })\n+                    })\n+                }\n+            }\n+        });\n+    }\n+\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n@@ -947,6 +992,12 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         self.emit_from_vec(tys, |this, ty| Ok(this.emit_ty(ecx, *ty)));\n     }\n \n+    fn emit_trait_ref(&mut self,\n+                      ecx: &e::EncodeContext,\n+                      trait_ref: &ty::TraitRef) {\n+        self.emit_opaque(|this| Ok(e::write_trait_ref(ecx, this, trait_ref)));\n+    }\n+\n     fn emit_type_param_def(&mut self,\n                            ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef) {\n@@ -1103,12 +1154,16 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n                         this.emit_enum_variant_arg(1, |this| idx.encode(this))\n                     })\n                 }\n-                ty::UnsizeVtable(ref b, def_id, ref substs) => {\n-                    this.emit_enum_variant(\"UnsizeVtable\", 2, 3, |this| {\n+                ty::UnsizeVtable(ty::TyTrait { def_id: def_id,\n+                                               bounds: ref b,\n+                                               substs: ref substs },\n+                                 self_ty) => {\n+                    this.emit_enum_variant(\"UnsizeVtable\", 2, 4, |this| {\n                         this.emit_enum_variant_arg(\n                             0, |this| Ok(this.emit_existential_bounds(ecx, b)));\n                         this.emit_enum_variant_arg(1, |this| def_id.encode(this));\n-                        this.emit_enum_variant_arg(2, |this| Ok(this.emit_substs(ecx, substs)))\n+                        this.emit_enum_variant_arg(2, |this| Ok(this.emit_ty(ecx, self_ty)));\n+                        this.emit_enum_variant_arg(3, |this| Ok(this.emit_substs(ecx, substs)))\n                     })\n                 }\n             }\n@@ -1282,11 +1337,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-        rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n+    for &trait_ref in tcx.object_cast_map.borrow().find(&id).iter() {\n+        rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n+                rbml_w.emit_trait_ref(ecx, &**trait_ref);\n             })\n         })\n     }\n@@ -1303,15 +1358,6 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                         })\n                     })\n                 }\n-\n-                for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-                    rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n-                        rbml_w.id(id);\n-                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                            encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n-                        })\n-                    })\n-                }\n             }\n             ty::AutoDerefRef(ref adj) => {\n                 assert!(!ty::adjust_is_object(adjustment));\n@@ -1326,16 +1372,6 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                             })\n                         })\n                     }\n-\n-                    for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-                        rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n-                            rbml_w.id(id);\n-                            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                                encode_vtable_res_with_key(ecx, rbml_w,\n-                                                           method_call.adjustment, dr);\n-                            })\n-                        })\n-                    }\n                 }\n             }\n             _ => {\n@@ -1378,8 +1414,10 @@ impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n }\n \n trait rbml_decoder_decoder_helpers {\n+    fn read_method_origin(&mut self, dcx: &DecodeContext) -> typeck::MethodOrigin;\n     fn read_ty(&mut self, dcx: &DecodeContext) -> ty::t;\n     fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<ty::t>;\n+    fn read_trait_ref(&mut self, dcx: &DecodeContext) -> Rc<ty::TraitRef>;\n     fn read_type_param_def(&mut self, dcx: &DecodeContext)\n                            -> ty::TypeParameterDef;\n     fn read_polytype(&mut self, dcx: &DecodeContext)\n@@ -1447,6 +1485,77 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n+    fn read_method_origin(&mut self, dcx: &DecodeContext)\n+                          -> typeck::MethodOrigin\n+    {\n+        self.read_enum(\"MethodOrigin\", |this| {\n+            let variants = [\"MethodStatic\", \"MethodStaticUnboxedClosure\",\n+                            \"MethodParam\", \"MethodObject\"];\n+            this.read_enum_variant(variants, |this, i| {\n+                Ok(match i {\n+                    0 => {\n+                        let def_id = this.read_def_id(dcx);\n+                        typeck::MethodStatic(def_id)\n+                    }\n+\n+                    1 => {\n+                        let def_id = this.read_def_id(dcx);\n+                        typeck::MethodStaticUnboxedClosure(def_id)\n+                    }\n+\n+                    2 => {\n+                        this.read_struct(\"MethodParam\", 2, |this| {\n+                            Ok(typeck::MethodParam(\n+                                typeck::MethodParam {\n+                                    trait_ref: {\n+                                        this.read_struct_field(\"trait_ref\", 0, |this| {\n+                                            Ok(this.read_trait_ref(dcx))\n+                                        }).unwrap()\n+                                    },\n+                                    method_num: {\n+                                        this.read_struct_field(\"method_num\", 1, |this| {\n+                                            this.read_uint()\n+                                        }).unwrap()\n+                                    }\n+                                }))\n+                        }).unwrap()\n+                    }\n+\n+                    3 => {\n+                        this.read_struct(\"MethodObject\", 2, |this| {\n+                            Ok(typeck::MethodObject(\n+                                typeck::MethodObject {\n+                                    trait_ref: {\n+                                        this.read_struct_field(\"trait_ref\", 0, |this| {\n+                                            Ok(this.read_trait_ref(dcx))\n+                                        }).unwrap()\n+                                    },\n+                                    object_trait_id: {\n+                                        this.read_struct_field(\"object_trait_id\", 1, |this| {\n+                                            Ok(this.read_def_id(dcx))\n+                                        }).unwrap()\n+                                    },\n+                                    method_num: {\n+                                        this.read_struct_field(\"method_num\", 2, |this| {\n+                                            this.read_uint()\n+                                        }).unwrap()\n+                                    },\n+                                    real_index: {\n+                                        this.read_struct_field(\"real_index\", 3, |this| {\n+                                            this.read_uint()\n+                                        }).unwrap()\n+                                    },\n+                                }))\n+                        }).unwrap()\n+                    }\n+\n+                    _ => fail!(\"..\")\n+                })\n+            })\n+        }).unwrap()\n+    }\n+\n+\n     fn read_ty(&mut self, dcx: &DecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n@@ -1479,6 +1588,18 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().move_iter().collect()\n     }\n \n+    fn read_trait_ref(&mut self, dcx: &DecodeContext) -> Rc<ty::TraitRef> {\n+        Rc::new(self.read_opaque(|this, doc| {\n+            let ty = tydecode::parse_trait_ref_data(\n+                doc.data,\n+                dcx.cdata.cnum,\n+                doc.start,\n+                dcx.tcx,\n+                |s, a| this.convert_def_id(dcx, s, a));\n+            Ok(ty)\n+        }).unwrap())\n+    }\n+\n     fn read_type_param_def(&mut self, dcx: &DecodeContext)\n                            -> ty::TypeParameterDef {\n         self.read_opaque(|this, doc| {\n@@ -1667,10 +1788,14 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                                 0, |this| Ok(this.read_existential_bounds(dcx))).unwrap();\n                         let def_id: ast::DefId =\n                             this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n-                        let substs = this.read_enum_variant_arg(2,\n+                        let self_ty =\n+                            this.read_enum_variant_arg(2, |this| Ok(this.read_ty(dcx))).unwrap();\n+                        let substs = this.read_enum_variant_arg(3,\n                             |this| Ok(this.read_substs(dcx))).unwrap();\n-\n-                        ty::UnsizeVtable(b, def_id.tr(dcx), substs)\n+                        let ty_trait = ty::TyTrait { def_id: def_id.tr(dcx),\n+                                                     bounds: b,\n+                                                     substs: substs };\n+                        ty::UnsizeVtable(ty_trait, self_ty)\n                     }\n                     _ => fail!(\"bad enum variant for ty::UnsizeKind\")\n                 })\n@@ -1828,15 +1953,10 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         };\n                         dcx.tcx.method_map.borrow_mut().insert(method_call, method);\n                     }\n-                    c::tag_table_vtable_map => {\n-                        let (adjustment, vtable_res) =\n-                            val_dsr.read_vtable_res_with_key(dcx.tcx,\n-                                                             dcx.cdata);\n-                        let vtable_key = MethodCall {\n-                            expr_id: id,\n-                            adjustment: adjustment\n-                        };\n-                        dcx.tcx.vtable_map.borrow_mut().insert(vtable_key, vtable_res);\n+                    c::tag_table_object_cast_map => {\n+                        let trait_ref = val_dsr.read_trait_ref(dcx);\n+                        dcx.tcx.object_cast_map.borrow_mut()\n+                                               .insert(id, trait_ref);\n                     }\n                     c::tag_table_adjustments => {\n                         let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);"}, {"sha": "f13c6bc3336fc429c62a277489a54c7968100933", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -102,17 +102,17 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     }\n                     typeck::MethodStaticUnboxedClosure(_) => {}\n                     typeck::MethodParam(typeck::MethodParam {\n-                        trait_id: trait_id,\n+                        trait_ref: ref trait_ref,\n                         method_num: index,\n                         ..\n-                    })\n-                    | typeck::MethodObject(typeck::MethodObject {\n-                        trait_id: trait_id,\n+                    }) |\n+                    typeck::MethodObject(typeck::MethodObject {\n+                        trait_ref: ref trait_ref,\n                         method_num: index,\n                         ..\n                     }) => {\n                         let trait_item = ty::trait_item(self.tcx,\n-                                                        trait_id,\n+                                                        trait_ref.def_id,\n                                                         index);\n                         match trait_item {\n                             ty::MethodTraitItem(method) => {\n@@ -470,7 +470,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         match self.tcx.inherent_impls.borrow().find(&local_def(id)) {\n             None => (),\n             Some(impl_list) => {\n-                for impl_did in impl_list.borrow().iter() {\n+                for impl_did in impl_list.iter() {\n                     for item_did in impl_items.get(impl_did).iter() {\n                         if self.live_symbols.contains(&item_did.def_id()\n                                                                .node) {"}, {"sha": "d6c11caefe84b2c14b96c39e0c3b43b131a3d589", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -174,11 +174,9 @@ impl OverloadedCallType {\n             MethodStaticUnboxedClosure(def_id) => {\n                 OverloadedCallType::from_unboxed_closure(tcx, def_id)\n             }\n-            MethodParam(ref method_param) => {\n-                OverloadedCallType::from_trait_id(tcx, method_param.trait_id)\n-            }\n-            MethodObject(ref method_object) => {\n-                OverloadedCallType::from_trait_id(tcx, method_object.trait_id)\n+            MethodParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n+            MethodObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n+                OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n             }\n         }\n     }"}, {"sha": "aeb0c155a3f4851ea100ff3904c671b4d6945892", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 46, "deletions": 437, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -10,50 +10,30 @@\n \n use middle::freevars::freevar_entry;\n use middle::freevars;\n+use middle::mem_categorization::Typer;\n use middle::subst;\n-use middle::ty::ParameterEnvironment;\n use middle::ty;\n use middle::ty_fold::TypeFoldable;\n use middle::ty_fold;\n-use middle::typeck::check::vtable;\n-use middle::typeck::{MethodCall, NoAdjustment};\n-use middle::typeck;\n-use util::ppaux::{Repr, ty_to_string};\n+use util::ppaux::{ty_to_string};\n use util::ppaux::UserString;\n \n-use std::collections::HashSet;\n use syntax::ast::*;\n-use syntax::ast_util;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::print::pprust::{expr_to_string, ident_to_string};\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-// Kind analysis pass.\n-//\n-// There are several kinds defined by various operations. The most restrictive\n-// kind is noncopyable. The noncopyable kind can be extended with any number\n-// of the following attributes.\n-//\n-//  Send: Things that can be sent on channels or included in spawned closures. It\n-//  includes scalar types as well as classes and unique types containing only\n-//  sendable types.\n-//  'static: Things that do not contain references.\n-//\n-// This pass ensures that type parameters are only instantiated with types\n-// whose kinds are equal or less general than the way the type parameter was\n-// annotated (with the `Send` bound).\n-//\n-// It also verifies that noncopyable kinds are not copied. Sendability is not\n-// applied, since none of our language primitives send. Instead, the sending\n-// primitives in the stdlib are explicitly annotated to only take sendable\n-// types.\n+// Kind analysis pass. This pass does some ad-hoc checks that are more\n+// convenient to do after type checking is complete and all checks are\n+// known. These are generally related to the builtin bounds `Copy` and\n+// `Sized`. Note that many of the builtin bound properties that used\n+// to be checked here are actually checked by trait checking these\n+// days.\n \n-pub struct Context<'a, 'tcx: 'a> {\n+pub struct Context<'a,'tcx:'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    struct_and_enum_bounds_checked: HashSet<ty::t>,\n-    parameter_environments: Vec<ParameterEnvironment>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n@@ -77,17 +57,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn visit_pat(&mut self, p: &Pat) {\n         check_pat(self, p);\n     }\n-\n-    fn visit_local(&mut self, l: &Local) {\n-        check_local(self, l);\n-    }\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n     let mut ctx = Context {\n         tcx: tcx,\n-        struct_and_enum_bounds_checked: HashSet::new(),\n-        parameter_environments: Vec::new(),\n     };\n     visit::walk_crate(&mut ctx, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n@@ -135,27 +109,11 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n                               .find(&trait_ref.ref_id)\n                               .expect(\"trait ref not in def map!\");\n     let trait_def_id = ast_trait_def.def_id();\n-    let trait_def = cx.tcx.trait_defs.borrow()\n-                          .find_copy(&trait_def_id)\n-                          .expect(\"trait def not in trait-defs map!\");\n-\n-    // If this trait has builtin-kind supertraits, meet them.\n-    let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n-    debug!(\"checking impl with self type {}\", ty::get(self_ty).sty);\n-    check_builtin_bounds(\n-        cx, self_ty, trait_def.bounds.builtin_bounds,\n-        |missing| {\n-            span_err!(cx.tcx.sess, self_type.span, E0142,\n-                      \"the type `{}', which does not fulfill `{}`, \\\n-                       cannot implement this trait\",\n-                      ty_to_string(cx.tcx, self_ty), missing.user_string(cx.tcx));\n-            span_note!(cx.tcx.sess, self_type.span,\n-                       \"types implementing this trait must fulfill `{}`\",\n-                       trait_def.bounds.user_string(cx.tcx));\n-        });\n \n     // If this is a destructor, check kinds.\n-    if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) {\n+    if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) &&\n+        !attr::contains_name(it.attrs.as_slice(), \"unsafe_destructor\")\n+    {\n         match self_type.node {\n             TyPath(_, ref bounds, path_node_id) => {\n                 assert!(bounds.is_none());\n@@ -172,133 +130,50 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n }\n \n fn check_item(cx: &mut Context, item: &Item) {\n-    if !attr::contains_name(item.attrs.as_slice(), \"unsafe_destructor\") {\n-        match item.node {\n-            ItemImpl(_, ref trait_ref, ref self_type, _) => {\n-                let parameter_environment =\n-                    ParameterEnvironment::for_item(cx.tcx, item.id);\n-                cx.parameter_environments.push(parameter_environment);\n-\n-                // Check bounds on the `self` type.\n-                check_bounds_on_structs_or_enums_in_type_if_possible(\n-                    cx,\n-                    item.span,\n-                    ty::node_id_to_type(cx.tcx, item.id));\n-\n-                match trait_ref {\n-                    &Some(ref trait_ref) => {\n-                        check_impl_of_trait(cx, item, trait_ref, &**self_type);\n-\n-                        // Check bounds on the trait ref.\n-                        match ty::impl_trait_ref(cx.tcx,\n-                                                 ast_util::local_def(item.id)) {\n-                            None => {}\n-                            Some(trait_ref) => {\n-                                check_bounds_on_structs_or_enums_in_trait_ref(\n-                                    cx,\n-                                    item.span,\n-                                    &*trait_ref);\n-\n-                                let trait_def = ty::lookup_trait_def(cx.tcx, trait_ref.def_id);\n-                                for (ty, type_param_def) in trait_ref.substs.types\n-                                                                  .iter()\n-                                                                  .zip(trait_def.generics\n-                                                                                .types\n-                                                                                .iter()) {\n-                                    check_typaram_bounds(cx, item.span, *ty, type_param_def);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    &None => {}\n-                }\n-\n-                drop(cx.parameter_environments.pop());\n-            }\n-            ItemEnum(..) => {\n-                let parameter_environment =\n-                    ParameterEnvironment::for_item(cx.tcx, item.id);\n-                cx.parameter_environments.push(parameter_environment);\n-\n-                let def_id = ast_util::local_def(item.id);\n-                for variant in ty::enum_variants(cx.tcx, def_id).iter() {\n-                    for arg in variant.args.iter() {\n-                        check_bounds_on_structs_or_enums_in_type_if_possible(\n-                            cx,\n-                            item.span,\n-                            *arg)\n-                    }\n-                }\n-\n-                drop(cx.parameter_environments.pop());\n-            }\n-            ItemStruct(..) => {\n-                let parameter_environment =\n-                    ParameterEnvironment::for_item(cx.tcx, item.id);\n-                cx.parameter_environments.push(parameter_environment);\n-\n-                let def_id = ast_util::local_def(item.id);\n-                for field in ty::lookup_struct_fields(cx.tcx, def_id).iter() {\n-                    check_bounds_on_structs_or_enums_in_type_if_possible(\n-                        cx,\n-                        item.span,\n-                        ty::node_id_to_type(cx.tcx, field.id.node))\n-                }\n-\n-                drop(cx.parameter_environments.pop());\n-\n-            }\n-            ItemStatic(..) => {\n-                let parameter_environment =\n-                    ParameterEnvironment::for_item(cx.tcx, item.id);\n-                cx.parameter_environments.push(parameter_environment);\n-\n-                check_bounds_on_structs_or_enums_in_type_if_possible(\n-                    cx,\n-                    item.span,\n-                    ty::node_id_to_type(cx.tcx, item.id));\n-\n-                drop(cx.parameter_environments.pop());\n-            }\n-            _ => {}\n+    match item.node {\n+        ItemImpl(_, Some(ref trait_ref), ref self_type, _) => {\n+            check_impl_of_trait(cx, item, trait_ref, &**self_type);\n         }\n+        _ => {}\n     }\n \n     visit::walk_item(cx, item)\n }\n \n-fn check_local(cx: &mut Context, local: &Local) {\n-    check_bounds_on_structs_or_enums_in_type_if_possible(\n-        cx,\n-        local.span,\n-        ty::node_id_to_type(cx.tcx, local.id));\n-\n-    visit::walk_local(cx, local)\n-}\n-\n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the NodeId for some expression that creates the\n // closure.\n fn with_appropriate_checker(cx: &Context,\n                             id: NodeId,\n+                            fn_span: Span,\n                             b: |checker: |&Context, &freevar_entry||) {\n-    fn check_for_uniq(cx: &Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n+    fn check_for_uniq(cx: &Context,\n+                      fn_span: Span,\n+                      fv: &freevar_entry,\n+                      bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n         let id = fv.def.def_id().node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n \n-        check_freevar_bounds(cx, fv.span, var_t, bounds, None);\n+        check_freevar_bounds(cx, fn_span, fv.span, var_t, bounds, None);\n     }\n \n-    fn check_for_block(cx: &Context, fv: &freevar_entry,\n-                       bounds: ty::BuiltinBounds, region: ty::Region) {\n+    fn check_for_block(cx: &Context,\n+                       fn_span: Span,\n+                       fn_id: NodeId,\n+                       fv: &freevar_entry,\n+                       bounds: ty::BuiltinBounds) {\n         let id = fv.def.def_id().node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n-        // FIXME(#3569): Figure out whether the implicit borrow is actually\n-        // mutable. Currently we assume all upvars are referenced mutably.\n-        let implicit_borrowed_type = ty::mk_mut_rptr(cx.tcx, region, var_t);\n-        check_freevar_bounds(cx, fv.span, implicit_borrowed_type,\n+        let upvar_id = ty::UpvarId { var_id: id, closure_expr_id: fn_id };\n+        let upvar_borrow = cx.tcx.upvar_borrow(upvar_id);\n+        let implicit_borrowed_type =\n+            ty::mk_rptr(cx.tcx,\n+                        upvar_borrow.region,\n+                        ty::mt { mutbl: upvar_borrow.kind.to_mutbl_lossy(),\n+                                 ty: var_t });\n+        check_freevar_bounds(cx, fn_span, fv.span, implicit_borrowed_type,\n                              bounds, Some(var_t));\n     }\n \n@@ -315,12 +190,16 @@ fn with_appropriate_checker(cx: &Context,\n             bounds: bounds,\n             ..\n         }) => {\n-            b(|cx, fv| check_for_uniq(cx, fv, bounds.builtin_bounds))\n+            b(|cx, fv| check_for_uniq(cx, fn_span, fv,\n+                                      bounds.builtin_bounds))\n         }\n \n         ty::ty_closure(box ty::ClosureTy {\n-            store: ty::RegionTraitStore(region, _), bounds, ..\n-        }) => b(|cx, fv| check_for_block(cx, fv, bounds.builtin_bounds, region)),\n+            store: ty::RegionTraitStore(..), bounds, ..\n+        }) => {\n+            b(|cx, fv| check_for_block(cx, fn_span, id, fv,\n+                                       bounds.builtin_bounds))\n+        }\n \n         ty::ty_bare_fn(_) => {\n             b(check_for_bare)\n@@ -346,8 +225,8 @@ fn check_fn(\n     sp: Span,\n     fn_id: NodeId) {\n \n-    // Check kinds on free variables:\n-    with_appropriate_checker(cx, fn_id, |chk| {\n+    // <Check kinds on free variables:\n+    with_appropriate_checker(cx, fn_id, sp, |chk| {\n         freevars::with_freevars(cx.tcx, fn_id, |freevars| {\n             for fv in freevars.iter() {\n                 chk(cx, fv);\n@@ -357,52 +236,18 @@ fn check_fn(\n \n     match fk {\n         visit::FkFnBlock(..) => {\n-            let ty = ty::node_id_to_type(cx.tcx, fn_id);\n-            check_bounds_on_structs_or_enums_in_type_if_possible(cx, sp, ty);\n-\n             visit::walk_fn(cx, fk, decl, body, sp)\n         }\n         visit::FkItemFn(..) | visit::FkMethod(..) => {\n-            let parameter_environment = ParameterEnvironment::for_item(cx.tcx,\n-                                                                       fn_id);\n-            cx.parameter_environments.push(parameter_environment);\n-\n-            let ty = ty::node_id_to_type(cx.tcx, fn_id);\n-            check_bounds_on_structs_or_enums_in_type_if_possible(cx, sp, ty);\n-\n             visit::walk_fn(cx, fk, decl, body, sp);\n-            drop(cx.parameter_environments.pop());\n         }\n     }\n }\n \n pub fn check_expr(cx: &mut Context, e: &Expr) {\n     debug!(\"kind::check_expr({})\", expr_to_string(e));\n \n-    // Handle any kind bounds on type parameters\n-    check_bounds_on_type_parameters(cx, e);\n-\n-    // Check bounds on structures or enumerations in the type of the\n-    // expression.\n-    let expression_type = ty::expr_ty(cx.tcx, e);\n-    check_bounds_on_structs_or_enums_in_type_if_possible(cx,\n-                                                         e.span,\n-                                                         expression_type);\n-\n     match e.node {\n-        ExprCast(ref source, _) => {\n-            let source_ty = ty::expr_ty(cx.tcx, &**source);\n-            let target_ty = ty::expr_ty(cx.tcx, e);\n-            let method_call = MethodCall {\n-                expr_id: e.id,\n-                adjustment: NoAdjustment,\n-            };\n-            check_trait_cast(cx,\n-                             source_ty,\n-                             target_ty,\n-                             source.span,\n-                             method_call);\n-        }\n         ExprRepeat(ref element, ref count_expr) => {\n             let count = ty::eval_repeat_count(cx.tcx, &**count_expr);\n             if count > 1 {\n@@ -427,174 +272,8 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n         _ => {}\n     }\n \n-    // Search for auto-adjustments to find trait coercions.\n-    match cx.tcx.adjustments.borrow().find(&e.id) {\n-        Some(adjustment) => {\n-            match adjustment {\n-                adj if ty::adjust_is_object(adj) => {\n-                    let source_ty = ty::expr_ty(cx.tcx, e);\n-                    let target_ty = ty::expr_ty_adjusted(cx.tcx, e);\n-                    let method_call = MethodCall {\n-                        expr_id: e.id,\n-                        adjustment: typeck::AutoObject,\n-                    };\n-                    check_trait_cast(cx,\n-                                     source_ty,\n-                                     target_ty,\n-                                     e.span,\n-                                     method_call);\n-                }\n-                _ => {}\n-            }\n-        }\n-        None => {}\n-    }\n-\n     visit::walk_expr(cx, e);\n }\n-\n-fn check_bounds_on_type_parameters(cx: &mut Context, e: &Expr) {\n-    let method_map = cx.tcx.method_map.borrow();\n-    let method_call = typeck::MethodCall::expr(e.id);\n-    let method = method_map.find(&method_call);\n-\n-    // Find the values that were provided (if any)\n-    let item_substs = cx.tcx.item_substs.borrow();\n-    let (types, is_object_call) = match method {\n-        Some(method) => {\n-            let is_object_call = match method.origin {\n-                typeck::MethodObject(..) => true,\n-                typeck::MethodStatic(..) |\n-                typeck::MethodStaticUnboxedClosure(..) |\n-                typeck::MethodParam(..) => false\n-            };\n-            (&method.substs.types, is_object_call)\n-        }\n-        None => {\n-            match item_substs.find(&e.id) {\n-                None => { return; }\n-                Some(s) => { (&s.substs.types, false) }\n-            }\n-        }\n-    };\n-\n-    // Find the relevant type parameter definitions\n-    let def_map = cx.tcx.def_map.borrow();\n-    let type_param_defs = match e.node {\n-        ExprPath(_) => {\n-            let did = def_map.get_copy(&e.id).def_id();\n-            ty::lookup_item_type(cx.tcx, did).generics.types.clone()\n-        }\n-        _ => {\n-            // Type substitutions should only occur on paths and\n-            // method calls, so this needs to be a method call.\n-\n-            // Even though the callee_id may have been the id with\n-            // node_type_substs, e.id is correct here.\n-            match method {\n-                Some(method) => {\n-                    ty::method_call_type_param_defs(cx.tcx, method.origin)\n-                }\n-                None => {\n-                    cx.tcx.sess.span_bug(e.span,\n-                                         \"non path/method call expr has type substs??\");\n-                }\n-            }\n-        }\n-    };\n-\n-    // Check that the value provided for each definition meets the\n-    // kind requirements\n-    for type_param_def in type_param_defs.iter() {\n-        let ty = *types.get(type_param_def.space, type_param_def.index);\n-\n-        // If this is a call to an object method (`foo.bar()` where\n-        // `foo` has a type like `Trait`), then the self type is\n-        // unknown (after all, this is a virtual call). In that case,\n-        // we will have put a ty_err in the substitutions, and we can\n-        // just skip over validating the bounds (because the bounds\n-        // would have been enforced when the object instance was\n-        // created).\n-        if is_object_call && type_param_def.space == subst::SelfSpace {\n-            assert_eq!(type_param_def.index, 0);\n-            assert!(ty::type_is_error(ty));\n-            continue;\n-        }\n-\n-        debug!(\"type_param_def space={} index={} ty={}\",\n-               type_param_def.space, type_param_def.index, ty.repr(cx.tcx));\n-        check_typaram_bounds(cx, e.span, ty, type_param_def)\n-    }\n-\n-    // Check the vtable.\n-    let vtable_map = cx.tcx.vtable_map.borrow();\n-    let vtable_res = match vtable_map.find(&method_call) {\n-        None => return,\n-        Some(vtable_res) => vtable_res,\n-    };\n-    check_type_parameter_bounds_in_vtable_result(cx, e.span, vtable_res);\n-}\n-\n-fn check_type_parameter_bounds_in_vtable_result(\n-        cx: &mut Context,\n-        span: Span,\n-        vtable_res: &typeck::vtable_res) {\n-    for origins in vtable_res.iter() {\n-        for origin in origins.iter() {\n-            let (type_param_defs, substs) = match *origin {\n-                typeck::vtable_static(def_id, ref tys, _) => {\n-                    let type_param_defs =\n-                        ty::lookup_item_type(cx.tcx, def_id).generics\n-                                                            .types\n-                                                            .clone();\n-                    (type_param_defs, (*tys).clone())\n-                }\n-                _ => {\n-                    // Nothing to do here.\n-                    continue\n-                }\n-            };\n-            for type_param_def in type_param_defs.iter() {\n-                let typ = substs.types.get(type_param_def.space,\n-                                           type_param_def.index);\n-                check_typaram_bounds(cx, span, *typ, type_param_def)\n-            }\n-        }\n-    }\n-}\n-\n-fn check_trait_cast(cx: &mut Context,\n-                    source_ty: ty::t,\n-                    target_ty: ty::t,\n-                    span: Span,\n-                    method_call: MethodCall) {\n-    match ty::get(target_ty).sty {\n-        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ ty, .. }) => {\n-            match ty::get(ty).sty {\n-                ty::ty_trait(box ty::TyTrait { bounds, .. }) => {\n-                     match cx.tcx.vtable_map.borrow().find(&method_call) {\n-                        None => {\n-                            cx.tcx.sess.span_bug(span,\n-                                                 \"trait cast not in vtable \\\n-                                                  map?!\")\n-                        }\n-                        Some(vtable_res) => {\n-                            check_type_parameter_bounds_in_vtable_result(\n-                                cx,\n-                                span,\n-                                vtable_res)\n-                        }\n-                    };\n-                    check_trait_cast_bounds(cx, span, source_ty,\n-                                            bounds.builtin_bounds);\n-                }\n-                _ => {}\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n fn check_ty(cx: &mut Context, aty: &Ty) {\n     match aty.node {\n         TyPath(_, _, id) => {\n@@ -651,77 +330,7 @@ pub fn check_typaram_bounds(cx: &Context,\n     });\n }\n \n-fn check_bounds_on_structs_or_enums_in_type_if_possible(cx: &mut Context,\n-                                                        span: Span,\n-                                                        ty: ty::t) {\n-    // If we aren't in a function, structure, or enumeration context, we don't\n-    // have enough information to ensure that bounds on structures or\n-    // enumerations are satisfied. So we don't perform the check.\n-    if cx.parameter_environments.len() == 0 {\n-        return\n-    }\n-\n-    // If we've already checked for this type, don't do it again. This\n-    // massively speeds up kind checking.\n-    if cx.struct_and_enum_bounds_checked.contains(&ty) {\n-        return\n-    }\n-    cx.struct_and_enum_bounds_checked.insert(ty);\n-\n-    ty::walk_ty(ty, |ty| {\n-        match ty::get(ty).sty {\n-            ty::ty_struct(type_id, ref substs) |\n-            ty::ty_enum(type_id, ref substs) => {\n-                let polytype = ty::lookup_item_type(cx.tcx, type_id);\n-\n-                // Check builtin bounds.\n-                for (ty, type_param_def) in substs.types\n-                                                  .iter()\n-                                                  .zip(polytype.generics\n-                                                               .types\n-                                                               .iter()) {\n-                    check_typaram_bounds(cx, span, *ty, type_param_def);\n-                }\n-\n-                // Check trait bounds.\n-                let parameter_environment =\n-                    cx.parameter_environments.get(cx.parameter_environments\n-                                                    .len() - 1);\n-                debug!(\n-                    \"check_bounds_on_structs_or_enums_in_type_if_possible(): \\\n-                     checking {}\",\n-                    ty.repr(cx.tcx));\n-                vtable::check_param_bounds(cx.tcx,\n-                                           span,\n-                                           parameter_environment,\n-                                           &polytype.generics.types,\n-                                           substs,\n-                                           |missing| {\n-                    cx.tcx\n-                      .sess\n-                      .span_err(span,\n-                                format!(\"instantiating a type parameter with \\\n-                                         an incompatible type `{}`, which \\\n-                                         does not fulfill `{}`\",\n-                                        ty_to_string(cx.tcx, ty),\n-                                        missing.user_string(\n-                                            cx.tcx)).as_slice());\n-                })\n-            }\n-            _ => {}\n-        }\n-    });\n-}\n-\n-fn check_bounds_on_structs_or_enums_in_trait_ref(cx: &mut Context,\n-                                                 span: Span,\n-                                                 trait_ref: &ty::TraitRef) {\n-    for ty in trait_ref.substs.types.iter() {\n-        check_bounds_on_structs_or_enums_in_type_if_possible(cx, span, *ty)\n-    }\n-}\n-\n-pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n+pub fn check_freevar_bounds(cx: &Context, fn_span: Span, sp: Span, ty: ty::t,\n                             bounds: ty::BuiltinBounds, referenced_ty: Option<ty::t>)\n {\n     check_builtin_bounds(cx, ty, bounds, |missing| {\n@@ -741,7 +350,7 @@ pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n                     ty_to_string(cx.tcx, ty), missing.user_string(cx.tcx));\n             }\n         }\n-        span_note!(cx.tcx.sess, sp,\n+        span_note!(cx.tcx.sess, fn_span,\n             \"this closure's environment must satisfy `{}`\",\n             bounds.user_string(cx.tcx));\n     });"}, {"sha": "1875c53f0740c99bcf152f361a6aa220d065767d", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -85,6 +85,17 @@ impl LanguageItems {\n         }\n     }\n \n+    pub fn from_builtin_kind(&self, bound: ty::BuiltinBound)\n+                             -> Result<ast::DefId, String>\n+    {\n+        match bound {\n+            ty::BoundSend => self.require(SendTraitLangItem),\n+            ty::BoundSized => self.require(SizedTraitLangItem),\n+            ty::BoundCopy => self.require(CopyTraitLangItem),\n+            ty::BoundSync => self.require(SyncTraitLangItem),\n+        }\n+    }\n+\n     pub fn to_builtin_kind(&self, id: ast::DefId) -> Option<ty::BuiltinBound> {\n         if Some(id) == self.send_trait() {\n             Some(ty::BoundSend)"}, {"sha": "56c785d3c2592845c1a07bd550f10a71a5b62378", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -782,19 +782,19 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Checks that a method is in scope.\n-    fn check_method(&mut self, span: Span, origin: MethodOrigin,\n+    fn check_method(&mut self, span: Span, origin: &MethodOrigin,\n                     ident: ast::Ident) {\n-        match origin {\n+        match *origin {\n             MethodStatic(method_id) => {\n                 self.check_static_method(span, method_id, ident)\n             }\n             MethodStaticUnboxedClosure(_) => {}\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            MethodParam(MethodParam { trait_id: trait_id, .. }) |\n-            MethodObject(MethodObject { trait_id: trait_id, .. }) => {\n-                self.report_error(self.ensure_public(span, trait_id, None,\n-                                                     \"source trait\"));\n+            MethodParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n+            MethodObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n+                self.report_error(self.ensure_public(span, trait_ref.def_id,\n+                                                     None, \"source trait\"));\n             }\n         }\n     }\n@@ -835,7 +835,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     }\n                     Some(method) => {\n                         debug!(\"(privacy checking) checking impl method\");\n-                        self.check_method(expr.span, method.origin, ident.node);\n+                        self.check_method(expr.span, &method.origin, ident.node);\n                     }\n                 }\n             }"}, {"sha": "5859e5ceeeeb1af4e6c0a66ca3a8c06f55fdd855", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -908,21 +908,21 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 };\n                 (Some(def_id), decl_id)\n             }\n-            typeck::MethodParam(mp) => {\n+            typeck::MethodParam(ref mp) => {\n                 // method invoked on a type parameter\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n-                                                mp.trait_id,\n+                                                mp.trait_ref.def_id,\n                                                 mp.method_num);\n                 match trait_item {\n                     ty::MethodTraitItem(method) => {\n                         (None, Some(method.def_id))\n                     }\n                 }\n             },\n-            typeck::MethodObject(mo) => {\n+            typeck::MethodObject(ref mo) => {\n                 // method invoked on a trait instance\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n-                                                mo.trait_id,\n+                                                mo.trait_ref.def_id,\n                                                 mo.method_num);\n                 match trait_item {\n                     ty::MethodTraitItem(method) => {"}, {"sha": "d7e6fd18ed5633a5d602de61f3a20e9e9c33d019", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -164,6 +164,11 @@ impl Substs {\n         s\n     }\n \n+    pub fn erase_regions(self) -> Substs {\n+        let Substs { types: types, regions: _ } = self;\n+        Substs { types: types, regions: ErasedRegions }\n+    }\n+\n     pub fn regions<'a>(&'a self) -> &'a VecPerParamSpace<ty::Region> {\n         /*!\n          * Since ErasedRegions are only to be used in trans, most of\n@@ -333,6 +338,16 @@ impl<T> VecPerParamSpace<T> {\n         }\n     }\n \n+    fn new_internal(content: Vec<T>, type_limit: uint, self_limit: uint)\n+                    -> VecPerParamSpace<T>\n+    {\n+        VecPerParamSpace {\n+            type_limit: type_limit,\n+            self_limit: self_limit,\n+            content: content,\n+        }\n+    }\n+\n     pub fn sort(t: Vec<T>, space: |&T| -> ParamSpace) -> VecPerParamSpace<T> {\n         let mut result = VecPerParamSpace::empty();\n         for t in t.move_iter() {\n@@ -448,13 +463,17 @@ impl<T> VecPerParamSpace<T> {\n     }\n \n     pub fn map<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {\n-        // FIXME (#15418): this could avoid allocating the intermediate\n-        // Vec's, but note that the values of type_limit and self_limit\n-        // also need to be kept in sync during construction.\n-        VecPerParamSpace::new(\n-            self.get_slice(TypeSpace).iter().map(|p| pred(p)).collect(),\n-            self.get_slice(SelfSpace).iter().map(|p| pred(p)).collect(),\n-            self.get_slice(FnSpace).iter().map(|p| pred(p)).collect())\n+        let result = self.iter().map(pred).collect();\n+        VecPerParamSpace::new_internal(result,\n+                                       self.type_limit,\n+                                       self.self_limit)\n+    }\n+\n+    pub fn map_move<U>(self, pred: |T| -> U) -> VecPerParamSpace<U> {\n+        let (t, s, f) = self.split();\n+        VecPerParamSpace::new(t.move_iter().map(|p| pred(p)).collect(),\n+                              s.move_iter().map(|p| pred(p)).collect(),\n+                              f.move_iter().map(|p| pred(p)).collect())\n     }\n \n     pub fn map_rev<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {"}, {"sha": "415eed380fc545f778a931379e4f531f4a8bdf7d", "filename": "src/librustc/middle/traits/coherence.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,168 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*! See `doc.rs` for high-level documentation */\n+\n+use super::DUMMY_CAUSE;\n+use super::{EvaluatedToMatch, EvaluatedToAmbiguity, EvaluatedToUnmatch};\n+use super::{evaluate_impl};\n+use super::util;\n+\n+use middle::subst;\n+use middle::subst::Subst;\n+use middle::ty;\n+use middle::typeck::infer::InferCtxt;\n+use syntax::ast;\n+use syntax::codemap::DUMMY_SP;\n+use util::nodemap::DefIdMap;\n+use util::ppaux::Repr;\n+\n+pub fn impl_can_satisfy(infcx: &InferCtxt,\n+                        impl1_def_id: ast::DefId,\n+                        impl2_def_id: ast::DefId)\n+                        -> bool\n+{\n+    // `impl1` provides an implementation of `Foo<X,Y> for Z`.\n+    let impl1_substs =\n+        util::fresh_substs_for_impl(infcx, DUMMY_SP, impl1_def_id);\n+    let impl1_self_ty =\n+        ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()\n+            .self_ty()\n+            .subst(infcx.tcx, &impl1_substs);\n+\n+    // Determine whether `impl2` can provide an implementation for those\n+    // same types.\n+    let param_env = ty::empty_parameter_environment();\n+    let unboxed_closures = DefIdMap::new();\n+    match evaluate_impl(infcx, &param_env, &unboxed_closures, DUMMY_CAUSE,\n+                        impl2_def_id, impl1_self_ty) {\n+        EvaluatedToMatch | EvaluatedToAmbiguity => true,\n+        EvaluatedToUnmatch => false,\n+    }\n+}\n+\n+pub fn impl_is_local(tcx: &ty::ctxt,\n+                     impl_def_id: ast::DefId)\n+                     -> bool\n+{\n+    debug!(\"impl_is_local({})\", impl_def_id.repr(tcx));\n+\n+    // We only except this routine to be invoked on implementations\n+    // of a trait, not inherent implementations.\n+    let trait_ref = ty::impl_trait_ref(tcx, impl_def_id).unwrap();\n+    debug!(\"trait_ref={}\", trait_ref.repr(tcx));\n+\n+    // If the trait is local to the crate, ok.\n+    if trait_ref.def_id.krate == ast::LOCAL_CRATE {\n+        debug!(\"trait {} is local to current crate\",\n+               trait_ref.def_id.repr(tcx));\n+        return true;\n+    }\n+\n+    // Otherwise, self type must be local to the crate.\n+    let self_ty = ty::lookup_item_type(tcx, impl_def_id).ty;\n+    return ty_is_local(tcx, self_ty);\n+}\n+\n+pub fn ty_is_local(tcx: &ty::ctxt,\n+                   ty: ty::t)\n+                   -> bool\n+{\n+    debug!(\"ty_is_local({})\", ty.repr(tcx));\n+\n+    match ty::get(ty).sty {\n+        ty::ty_nil |\n+        ty::ty_bot |\n+        ty::ty_bool |\n+        ty::ty_char |\n+        ty::ty_int(..) |\n+        ty::ty_uint(..) |\n+        ty::ty_float(..) |\n+        ty::ty_str(..) => {\n+            false\n+        }\n+\n+        ty::ty_unboxed_closure(..) => {\n+            // This routine is invoked on types specified by users as\n+            // part of an impl and hence an unboxed closure type\n+            // cannot appear.\n+            tcx.sess.bug(\"ty_is_local applied to unboxed closure type\")\n+        }\n+\n+        ty::ty_bare_fn(..) |\n+        ty::ty_closure(..) => {\n+            false\n+        }\n+\n+        ty::ty_uniq(t) => {\n+            let krate = tcx.lang_items.owned_box().map(|d| d.krate);\n+            krate == Some(ast::LOCAL_CRATE) || ty_is_local(tcx, t)\n+        }\n+\n+        ty::ty_box(t) => {\n+            let krate = tcx.lang_items.gc().map(|d| d.krate);\n+            krate == Some(ast::LOCAL_CRATE) || ty_is_local(tcx, t)\n+        }\n+\n+        ty::ty_vec(t, _) |\n+        ty::ty_ptr(ty::mt { ty: t, .. }) |\n+        ty::ty_rptr(_, ty::mt { ty: t, .. }) => {\n+            ty_is_local(tcx, t)\n+        }\n+\n+        ty::ty_tup(ref ts) => {\n+            ts.iter().any(|&t| ty_is_local(tcx, t))\n+        }\n+\n+        ty::ty_enum(def_id, ref substs) |\n+        ty::ty_struct(def_id, ref substs) => {\n+            def_id.krate == ast::LOCAL_CRATE || {\n+                let variances = ty::item_variances(tcx, def_id);\n+                subst::ParamSpace::all().iter().any(|&space| {\n+                    substs.types.get_slice(space).iter().enumerate().any(\n+                        |(i, &t)| {\n+                            match *variances.types.get(space, i) {\n+                                ty::Bivariant => {\n+                                    // If Foo<T> is bivariant with respect to\n+                                    // T, then it doesn't matter whether T is\n+                                    // local or not, because `Foo<U>` for any\n+                                    // U will be a subtype of T.\n+                                    false\n+                                }\n+                                ty::Contravariant |\n+                                ty::Covariant |\n+                                ty::Invariant => {\n+                                    ty_is_local(tcx, t)\n+                                }\n+                            }\n+                        })\n+                })\n+            }\n+        }\n+\n+        ty::ty_trait(ref tt) => {\n+            tt.def_id.krate == ast::LOCAL_CRATE\n+        }\n+\n+        // Type parameters may be bound to types that are not local to\n+        // the crate.\n+        ty::ty_param(..) => {\n+            false\n+        }\n+\n+        ty::ty_infer(..) |\n+        ty::ty_open(..) |\n+        ty::ty_err => {\n+            tcx.sess.bug(\n+                format!(\"ty_is_local invoked on unexpected type: {}\",\n+                        ty.repr(tcx)).as_slice())\n+        }\n+    }\n+}"}, {"sha": "98db2263874537262e9b73a9c0de5a6539acee7e", "filename": "src/librustc/middle/traits/doc.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,268 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+# TRAIT RESOLUTION\n+\n+This document describes the general process and points out some non-obvious\n+things.\n+\n+## Major concepts\n+\n+Trait resolution is the process of pairing up an impl with each\n+reference to a trait. So, for example, if there is a generic function like:\n+\n+    fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { ... }\n+\n+and then a call to that function:\n+\n+    let v: Vec<int> = clone_slice([1, 2, 3].as_slice())\n+\n+it is the job of trait resolution to figure out (in which case)\n+whether there exists an impl of `int : Clone`\n+\n+Note that in some cases, like generic functions, we may not be able to\n+find a specific impl, but we can figure out that the caller must\n+provide an impl. To see what I mean, consider the body of `clone_slice`:\n+\n+    fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {\n+        let mut v = Vec::new();\n+        for e in x.iter() {\n+            v.push((*e).clone()); // (*)\n+        }\n+    }\n+\n+The line marked `(*)` is only legal if `T` (the type of `*e`)\n+implements the `Clone` trait. Naturally, since we don't know what `T`\n+is, we can't find the specific impl; but based on the bound `T:Clone`,\n+we can say that there exists an impl which the caller must provide.\n+\n+We use the term *obligation* to refer to a trait reference in need of\n+an impl.\n+\n+## Overview\n+\n+Trait resolution consists of three major parts:\n+\n+- SELECTION: Deciding how to resolve a specific obligation. For\n+  example, selection might decide that a specific obligation can be\n+  resolved by employing an impl which matches the self type, or by\n+  using a parameter bound. In the case of an impl, Selecting one\n+  obligation can create *nested obligations* because of where clauses\n+  on the impl itself.\n+\n+- FULFILLMENT: The fulfillment code is what tracks that obligations\n+  are completely fulfilled. Basically it is a worklist of obligations\n+  to be selected: once selection is successful, the obligation is\n+  removed from the worklist and any nested obligations are enqueued.\n+\n+- COHERENCE: The coherence checks are intended to ensure that there\n+  are never overlapping impls, where two impls could be used with\n+  equal precedence.\n+\n+## Selection\n+\n+Selection is the process of deciding whether an obligation can be\n+resolved and, if so, how it is to be resolved (via impl, where clause, etc).\n+The main interface is the `select()` function, which takes an obligation\n+and returns a `SelectionResult`. There are three possible outcomes:\n+\n+- `Ok(Some(selection))` -- yes, the obligation can be resolved, and\n+  `selection` indicates how. If the impl was resolved via an impl,\n+  then `selection` may also indicate nested obligations that are required\n+  by the impl.\n+\n+- `Ok(None)` -- we are not yet sure whether the obligation can be\n+  resolved or not. This happens most commonly when the obligation\n+  contains unbound type variables.\n+\n+- `Err(err)` -- the obligation definitely cannot be resolved due to a\n+  type error, or because there are no impls that could possibly apply,\n+  etc.\n+\n+The basic algorithm for selection is broken into two big phases:\n+candidate assembly and confirmation.\n+\n+### Candidate assembly\n+\n+Searches for impls/where-clauses/etc that might\n+possibly be used to satisfy the obligation. Each of those is called\n+a candidate. To avoid ambiguity, we want to find exactly one\n+candidate that is definitively applicable. In some cases, we may not\n+know whether an impl/where-clause applies or not -- this occurs when\n+the obligation contains unbound inference variables.\n+\n+One important point is that candidate assembly considers *only the\n+input types* of the obligation when deciding whether an impl applies\n+or not. Consider the following example:\n+\n+    trait Convert<T> { // T is output, Self is input\n+        fn convert(&self) -> T;\n+    }\n+\n+    impl Convert<uint> for int { ... }\n+\n+Now assume we have an obligation `int : Convert<char>`. During\n+candidate assembly, the impl above would be considered a definitively\n+applicable candidate, because it has the same self type (`int`). The\n+fact that the output type parameter `T` is `uint` on the impl and\n+`char` in the obligation is not considered.\n+\n+#### Skolemization\n+\n+We (at least currently) wish to guarantee \"crate concatenability\" --\n+which basically means that you could take two crates, concatenate\n+them textually, and the combined crate would continue to compile. The\n+only real way that this relates to trait matching is with\n+inference. We have to be careful not to influence unbound type\n+variables during the selection process, basically.\n+\n+Here is an example:\n+\n+    trait Foo { fn method() { ... }}\n+    impl Foo for int { ... }\n+\n+    fn something() {\n+        let mut x = None; // `x` has type `Option<?>`\n+        loop {\n+            match x {\n+                Some(ref y) => { // `y` has type ?\n+                    y.method();  // (*)\n+                    ...\n+        }}}\n+    }\n+\n+The question is, can we resolve the call to `y.method()`? We don't yet\n+know what type `y` has. However, there is only one impl in scope, and\n+it is for `int`, so perhaps we could deduce that `y` *must* have type\n+`int` (and hence the type of `x` is `Option<int>`)? This is actually\n+sound reasoning: `int` is the only type in scope that could possibly\n+make this program type check. However, this deduction is a bit\n+\"unstable\", though, because if we concatenated with another crate that\n+defined a newtype and implemented `Foo` for this newtype, then the\n+inference would fail, because there would be two potential impls, not\n+one.\n+\n+It is unclear how important this property is. It might be nice to drop it.\n+But for the time being we maintain it.\n+\n+The way we do this is by *skolemizing* the obligation self type during\n+the selection process -- skolemizing means, basically, replacing all\n+unbound type variables with a new \"skolemized\" type. Each skolemized\n+type is basically considered \"as if\" it were some fresh type that is\n+distinct from all other types. The skolemization process also replaces\n+lifetimes with `'static`, see the section on lifetimes below for an\n+explanation.\n+\n+In the example above, this means that when matching `y.method()` we\n+would convert the type of `y` from a type variable `?` to a skolemized\n+type `X`. Then, since `X` cannot unify with `int`, the match would\n+fail.  Special code exists to check that the match failed because a\n+skolemized type could not be unified with another kind of type -- this is\n+not considered a definitive failure, but rather an ambiguous result,\n+since if the type variable were later to be unified with int, then this\n+obligation could be resolved then.\n+\n+*Note:* Currently, method matching does not use the trait resolution\n+code, so if you in fact type in the example above, it may\n+compile. Hopefully this will be fixed in later patches.\n+\n+#### Matching\n+\n+The subroutines that decide whether a particular impl/where-clause/etc\n+applies to a particular obligation. At the moment, this amounts to\n+unifying the self types, but in the future we may also recursively\n+consider some of the nested obligations, in the case of an impl.\n+\n+#### Lifetimes and selection\n+\n+Because of how that lifetime inference works, it is not possible to\n+give back immediate feedback as to whether a unification or subtype\n+relationship between lifetimes holds or not. Therefore, lifetime\n+matching is *not* considered during selection. This is achieved by\n+having the skolemization process just replace *ALL* lifetimes with\n+`'static`. Later, during confirmation, the non-skolemized self-type\n+will be unified with the type from the impl (or whatever). This may\n+yield lifetime constraints that will later be found to be in error (in\n+contrast, the non-lifetime-constraints have already been checked\n+during selection and can never cause an error, though naturally they\n+may lead to other errors downstream).\n+\n+#### Where clauses\n+\n+Besides an impl, the other major way to resolve an obligation is via a\n+where clause. The selection process is always given a *parameter\n+environment* which contains a list of where clauses, which are\n+basically obligations that can assume are satisfiable. We will iterate\n+over that list and check whether our current obligation can be found\n+in that list, and if so it is considered satisfied. More precisely, we\n+want to check whether there is a where-clause obligation that is for\n+the same trait (or some subtrait) and for which the self types match,\n+using the definition of *matching* given above.\n+\n+Consider this simple example:\n+\n+     trait A1 { ... }\n+     trait A2 : A1 { ... }\n+\n+     trait B { ... }\n+\n+     fn foo<X:A2+B> { ... }\n+\n+Clearly we can use methods offered by `A1`, `A2`, or `B` within the\n+body of `foo`. In each case, that will incur an obligation like `X :\n+A1` or `X : A2`. The parameter environment will contain two\n+where-clauses, `X : A2` and `X : B`. For each obligation, then, we\n+search this list of where-clauses.  To resolve an obligation `X:A1`,\n+we would note that `X:A2` implies that `X:A1`.\n+\n+### Confirmation\n+\n+Confirmation unifies the output type parameters of the trait with the\n+values found in the obligation, possibly yielding a type error.  If we\n+return to our example of the `Convert` trait from the previous\n+section, confirmation is where an error would be reported, because the\n+impl specified that `T` would be `uint`, but the obligation reported\n+`char`. Hence the result of selection would be an error.\n+\n+### Selection during translation\n+\n+During type checking, we do not store the results of trait selection.\n+We simply wish to verify that trait selection will succeed. Then\n+later, at trans time, when we have all concrete types available, we\n+can repeat the trait selection.  In this case, we do not consider any\n+where-clauses to be in scope. We know that therefore each resolution\n+will resolve to a particular impl.\n+\n+One interesting twist has to do with nested obligations. In general, in trans,\n+we only need to do a \"shallow\" selection for an obligation. That is, we wish to\n+identify which impl applies, but we do not (yet) need to decide how to select\n+any nested obligations. Nonetheless, we *do* currently do a complete resolution,\n+and that is because it can sometimes inform the results of type inference. That is,\n+we do not have the full substitutions in terms of the type varibales of the impl available\n+to us, so we must run trait selection to figure everything out.\n+\n+Here is an example:\n+\n+    trait Foo { ... }\n+    impl<U,T:Bar<U>> Foo for Vec<T> { ... }\n+\n+    impl Bar<uint> for int { ... }\n+\n+After one shallow round of selection for an obligation like `Vec<int>\n+: Foo`, we would know which impl we want, and we would know that\n+`T=int`, but we do not know the type of `U`.  We must select the\n+nested obligation `int : Bar<U>` to find out that `U=uint`.\n+\n+It would be good to only do *just as much* nested resolution as\n+necessary. Currently, though, we just do a full resolution.\n+\n+*/"}, {"sha": "78d105c251edb09128a7e736e66d1cd2521a4e93", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,250 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty;\n+use middle::typeck::infer::{InferCtxt, skolemize};\n+use util::nodemap::DefIdMap;\n+use util::ppaux::Repr;\n+\n+use super::Ambiguity;\n+use super::Obligation;\n+use super::FulfillmentError;\n+use super::SelectionError;\n+use super::select::SelectionContext;\n+use super::Unimplemented;\n+\n+/**\n+ * The fulfillment context is used to drive trait resolution.  It\n+ * consists of a list of obligations that must be (eventually)\n+ * satisfied. The job is to track which are satisfied, which yielded\n+ * errors, and which are still pending. At any point, users can call\n+ * `select_where_possible`, and the fulfilment context will try to do\n+ * selection, retaining only those obligations that remain\n+ * ambiguous. This may be helpful in pushing type inference\n+ * along. Once all type inference constraints have been generated, the\n+ * method `select_all_or_error` can be used to report any remaining\n+ * ambiguous cases as errors.\n+ */\n+pub struct FulfillmentContext {\n+    // A list of all obligations that have been registered with this\n+    // fulfillment context.\n+    trait_obligations: Vec<Obligation>,\n+\n+    // For semi-hacky reasons (see FIXME below) we keep the builtin\n+    // trait obligations segregated.\n+    builtin_obligations: Vec<Obligation>,\n+}\n+\n+impl FulfillmentContext {\n+    pub fn new() -> FulfillmentContext {\n+        FulfillmentContext {\n+            trait_obligations: Vec::new(),\n+            builtin_obligations: Vec::new()\n+        }\n+    }\n+\n+    pub fn register_obligation(&mut self,\n+                               tcx: &ty::ctxt,\n+                               obligation: Obligation)\n+    {\n+        debug!(\"register_obligation({})\", obligation.repr(tcx));\n+        match tcx.lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n+            Some(_) => {\n+                self.builtin_obligations.push(obligation);\n+            }\n+            None => {\n+                self.trait_obligations.push(obligation);\n+            }\n+        }\n+    }\n+\n+    pub fn select_all_or_error(&mut self,\n+                               infcx: &InferCtxt,\n+                               param_env: &ty::ParameterEnvironment,\n+                               unboxed_closures: &DefIdMap<ty::UnboxedClosure>)\n+                               -> Result<(),Vec<FulfillmentError>>\n+    {\n+        try!(self.select_where_possible(infcx, param_env,\n+                                        unboxed_closures));\n+\n+        // Anything left is ambiguous.\n+        let errors: Vec<FulfillmentError> =\n+            self.trait_obligations\n+            .iter()\n+            .map(|o| FulfillmentError::new((*o).clone(), Ambiguity))\n+            .collect();\n+\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(errors)\n+        }\n+    }\n+\n+    pub fn select_where_possible(&mut self,\n+                                 infcx: &InferCtxt,\n+                                 param_env: &ty::ParameterEnvironment,\n+                                 unboxed_closures: &DefIdMap<ty::UnboxedClosure>)\n+                                 -> Result<(),Vec<FulfillmentError>>\n+    {\n+        let tcx = infcx.tcx;\n+        let selcx = SelectionContext::new(infcx, param_env,\n+                                          unboxed_closures);\n+\n+        debug!(\"select_where_possible({} obligations) start\",\n+               self.trait_obligations.len());\n+\n+        let mut errors = Vec::new();\n+\n+        loop {\n+            let count = self.trait_obligations.len();\n+\n+            debug!(\"select_where_possible({} obligations) iteration\",\n+                   count);\n+\n+            let mut selections = Vec::new();\n+\n+            // First pass: walk each obligation, retaining\n+            // only those that we cannot yet process.\n+            self.trait_obligations.retain(|obligation| {\n+                match selcx.select(obligation) {\n+                    Ok(None) => {\n+                        true\n+                    }\n+                    Ok(Some(s)) => {\n+                        selections.push(s);\n+                        false\n+                    }\n+                    Err(selection_err) => {\n+                        debug!(\"obligation: {} error: {}\",\n+                               obligation.repr(tcx),\n+                               selection_err.repr(tcx));\n+\n+                        errors.push(FulfillmentError::new(\n+                            (*obligation).clone(),\n+                            SelectionError(selection_err)));\n+                        false\n+                    }\n+                }\n+            });\n+\n+            if self.trait_obligations.len() == count {\n+                // Nothing changed.\n+                break;\n+            }\n+\n+            // Now go through all the successful ones,\n+            // registering any nested obligations for the future.\n+            for selection in selections.move_iter() {\n+                selection.map_move_nested(\n+                    |o| self.register_obligation(tcx, o));\n+            }\n+        }\n+\n+        debug!(\"select_where_possible({} obligations, {} errors) done\",\n+               self.trait_obligations.len(),\n+               errors.len());\n+\n+        if errors.len() == 0 {\n+            Ok(())\n+        } else {\n+            Err(errors)\n+        }\n+    }\n+\n+    pub fn check_builtin_bound_obligations(\n+        &self,\n+        infcx: &InferCtxt)\n+        -> Result<(),Vec<FulfillmentError>>\n+    {\n+        let tcx = infcx.tcx;\n+        let mut errors = Vec::new();\n+        debug!(\"check_builtin_bound_obligations\");\n+        for obligation in self.builtin_obligations.iter() {\n+            debug!(\"obligation={}\", obligation.repr(tcx));\n+\n+            let def_id = obligation.trait_ref.def_id;\n+            let bound = match tcx.lang_items.to_builtin_kind(def_id) {\n+                Some(bound) => { bound }\n+                None => { continue; }\n+            };\n+\n+            let unskol_self_ty = obligation.self_ty();\n+\n+            // Skolemize the self-type so that it no longer contains\n+            // inference variables. Note that this also replaces\n+            // regions with 'static. You might think that this is not\n+            // ok, because checking whether something is `Send`\n+            // implies checking whether it is 'static: that's true,\n+            // but in fact the region bound is fed into region\n+            // inference separately and enforced there (and that has\n+            // even already been done before this code executes,\n+            // generally speaking).\n+            let self_ty = skolemize(infcx, unskol_self_ty);\n+\n+            debug!(\"bound={} self_ty={}\", bound, self_ty.repr(tcx));\n+            if ty::type_is_error(self_ty) {\n+                // Indicates an error that was/will-be\n+                // reported elsewhere.\n+                continue;\n+            }\n+\n+            // Determine if builtin bound is met.\n+            let tc = ty::type_contents(tcx, self_ty);\n+            debug!(\"tc={}\", tc);\n+            let met = match bound {\n+                ty::BoundSend   => tc.is_sendable(tcx),\n+                ty::BoundSized  => tc.is_sized(tcx),\n+                ty::BoundCopy   => tc.is_copy(tcx),\n+                ty::BoundSync   => tc.is_sync(tcx),\n+            };\n+\n+            if met {\n+                continue;\n+            }\n+\n+            // FIXME -- This is kind of a hack: it requently happens\n+            // that some earlier error prevents types from being fully\n+            // inferred, and then we get a bunch of uninteresting\n+            // errors saying something like \"<generic #0> doesn't\n+            // implement Sized\".  It may even be true that we could\n+            // just skip over all checks where the self-ty is an\n+            // inference variable, but I was afraid that there might\n+            // be an inference variable created, registered as an\n+            // obligation, and then never forced by writeback, and\n+            // hence by skipping here we'd be ignoring the fact that\n+            // we don't KNOW the type works out. Though even that\n+            // would probably be harmless, given that we're only\n+            // talking about builtin traits, which are known to be\n+            // inhabited. But in any case I just threw in this check\n+            // for has_errors() to be sure that compilation isn't\n+            // happening anyway. In that case, why inundate the user.\n+            if ty::type_needs_infer(self_ty) &&\n+                tcx.sess.has_errors()\n+            {\n+                debug!(\"skipping printout because self_ty={}\",\n+                       self_ty.repr(tcx));\n+                continue;\n+            }\n+\n+            errors.push(\n+                FulfillmentError::new(\n+                    (*obligation).clone(),\n+                    SelectionError(Unimplemented)));\n+        }\n+\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(errors)\n+        }\n+    }\n+}\n+"}, {"sha": "62b3c982ccd0a4ceed7f5d849e434e7a67e03c6c", "filename": "src/librustc/middle/traits/mod.rs", "status": "added", "additions": 438, "deletions": 0, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,438 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Trait Resolution. See doc.rs.\n+ */\n+\n+use middle::subst;\n+use middle::ty;\n+use middle::typeck::infer::InferCtxt;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::codemap::{Span, DUMMY_SP};\n+use util::nodemap::DefIdMap;\n+\n+pub use self::fulfill::FulfillmentContext;\n+pub use self::select::SelectionContext;\n+pub use self::util::supertraits;\n+pub use self::util::transitive_bounds;\n+pub use self::util::Supertraits;\n+pub use self::util::search_trait_and_supertraits_from_bound;\n+\n+mod coherence;\n+mod fulfill;\n+mod select;\n+mod util;\n+\n+/**\n+ * An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n+ * which the vtable must be found.  The process of finding a vtable is\n+ * called \"resolving\" the `Obligation`. This process consists of\n+ * either identifying an `impl` (e.g., `impl Eq for int`) that\n+ * provides the required vtable, or else finding a bound that is in\n+ * scope. The eventual result is usually a `Selection` (defined below).\n+ */\n+#[deriving(Clone)]\n+pub struct Obligation {\n+    pub cause: ObligationCause,\n+    pub recursion_depth: uint,\n+    pub trait_ref: Rc<ty::TraitRef>,\n+}\n+\n+/**\n+ * Why did we incur this obligation? Used for error reporting.\n+ */\n+#[deriving(Clone)]\n+pub struct ObligationCause {\n+    pub span: Span,\n+    pub code: ObligationCauseCode\n+}\n+\n+#[deriving(Clone)]\n+pub enum ObligationCauseCode {\n+    /// Not well classified or should be obvious from span.\n+    MiscObligation,\n+\n+    /// In an impl of trait X for type Y, type Y must\n+    /// also implement all supertraits of X.\n+    ItemObligation(ast::DefId),\n+\n+    /// Obligation incurred due to an object cast.\n+    ObjectCastObligation(/* Object type */ ty::t),\n+\n+    /// Various cases where expressions must be sized/copy/etc:\n+    AssignmentLhsSized,        // L = X implies that L is Sized\n+    StructInitializerSized,    // S { ... } must be Sized\n+    VariableType(ast::NodeId), // Type of each variable must be Sized\n+    RepeatVec,                 // [T,..n] --> T must be Copy\n+}\n+\n+pub static DUMMY_CAUSE: ObligationCause =\n+    ObligationCause { span: DUMMY_SP,\n+                      code: MiscObligation };\n+\n+pub type Obligations = subst::VecPerParamSpace<Obligation>;\n+\n+pub type Selection = Vtable<Obligation>;\n+\n+#[deriving(Clone,Show)]\n+pub enum SelectionError {\n+    Unimplemented,\n+    Overflow,\n+    OutputTypeParameterMismatch(Rc<ty::TraitRef>, ty::type_err)\n+}\n+\n+pub struct FulfillmentError {\n+    pub obligation: Obligation,\n+    pub code: FulfillmentErrorCode\n+}\n+\n+#[deriving(Clone)]\n+pub enum FulfillmentErrorCode {\n+    SelectionError(SelectionError),\n+    Ambiguity,\n+}\n+\n+/**\n+ * When performing resolution, it is typically the case that there\n+ * can be one of three outcomes:\n+ *\n+ * - `Ok(Some(r))`: success occurred with result `r`\n+ * - `Ok(None)`: could not definitely determine anything, usually due\n+ *   to inconclusive type inference.\n+ * - `Err(e)`: error `e` occurred\n+ */\n+pub type SelectionResult<T> = Result<Option<T>,SelectionError>;\n+\n+#[deriving(PartialEq,Eq,Show)]\n+pub enum EvaluationResult {\n+    EvaluatedToMatch,\n+    EvaluatedToAmbiguity,\n+    EvaluatedToUnmatch\n+}\n+\n+/**\n+ * Given the successful resolution of an obligation, the `Vtable`\n+ * indicates where the vtable comes from. Note that while we call this\n+ * a \"vtable\", it does not necessarily indicate dynamic dispatch at\n+ * runtime. `Vtable` instances just tell the compiler where to find\n+ * methods, but in generic code those methods are typically statically\n+ * dispatched -- only when an object is constructed is a `Vtable`\n+ * instance reified into an actual vtable.\n+ *\n+ * For example, the vtable may be tied to a specific impl (case A),\n+ * or it may be relative to some bound that is in scope (case B).\n+ *\n+ *\n+ * ```\n+ * impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n+ * impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n+ * impl Clone for int { ... }             // Impl_3\n+ *\n+ * fn foo<T:Clone>(concrete: Option<Box<int>>,\n+ *                 param: T,\n+ *                 mixed: Option<T>) {\n+ *\n+ *    // Case A: Vtable points at a specific impl. Only possible when\n+ *    // type is concretely known. If the impl itself has bounded\n+ *    // type parameters, Vtable will carry resolutions for those as well:\n+ *    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n+ *\n+ *    // Case B: Vtable must be provided by caller. This applies when\n+ *    // type is a type parameter.\n+ *    param.clone();    // VtableParam(Oblig_1)\n+ *\n+ *    // Case C: A mix of cases A and B.\n+ *    mixed.clone();    // Vtable(Impl_1, [VtableParam(Oblig_1)])\n+ * }\n+ * ```\n+ *\n+ * ### The type parameter `N`\n+ *\n+ * See explanation on `VtableImpl`.\n+ */\n+#[deriving(Show,Clone)]\n+pub enum Vtable<N> {\n+    /// Vtable identifying a particular impl.\n+    VtableImpl(VtableImpl<N>),\n+\n+    /// Vtable automatically generated for an unboxed closure. The def\n+    /// ID is the ID of the closure expression. This is a `VtableImpl`\n+    /// in spirit, but the impl is generated by the compiler and does\n+    /// not appear in the source.\n+    VtableUnboxedClosure(ast::DefId),\n+\n+    /// Successful resolution to an obligation provided by the caller\n+    /// for some type parameter.\n+    VtableParam(VtableParam),\n+\n+    /// Successful resolution for a builtin trait.\n+    VtableBuiltin,\n+}\n+\n+/**\n+ * Identifies a particular impl in the source, along with a set of\n+ * substitutions from the impl's type/lifetime parameters. The\n+ * `nested` vector corresponds to the nested obligations attached to\n+ * the impl's type parameters.\n+ *\n+ * The type parameter `N` indicates the type used for \"nested\n+ * obligations\" that are required by the impl. During type check, this\n+ * is `Obligation`, as one might expect. During trans, however, this\n+ * is `()`, because trans only requires a shallow resolution of an\n+ * impl, and nested obligations are satisfied later.\n+ */\n+#[deriving(Clone)]\n+pub struct VtableImpl<N> {\n+    pub impl_def_id: ast::DefId,\n+    pub substs: subst::Substs,\n+    pub nested: subst::VecPerParamSpace<N>\n+}\n+\n+/**\n+ * A vtable provided as a parameter by the caller. For example, in a\n+ * function like `fn foo<T:Eq>(...)`, if the `eq()` method is invoked\n+ * on an instance of `T`, the vtable would be of type `VtableParam`.\n+ */\n+#[deriving(Clone)]\n+pub struct VtableParam {\n+    // In the above example, this would `Eq`\n+    pub bound: Rc<ty::TraitRef>,\n+}\n+\n+pub fn try_select_obligation(infcx: &InferCtxt,\n+                             param_env: &ty::ParameterEnvironment,\n+                             unboxed_closures: &DefIdMap<ty::UnboxedClosure>,\n+                             obligation: &Obligation)\n+                             -> SelectionResult<Selection>\n+{\n+    /*!\n+     * Attempts to select the impl/bound/etc for the obligation\n+     * given. Returns `None` if we are unable to resolve, either\n+     * because of ambiguity or due to insufficient inference.  Note\n+     * that selection is a shallow process and hence the result may\n+     * contain nested obligations that must be resolved. The caller is\n+     * responsible for ensuring that those get resolved. (But see\n+     * `try_select_obligation_deep` below.)\n+     */\n+\n+    let selcx = select::SelectionContext::new(infcx, param_env, unboxed_closures);\n+    selcx.select(obligation)\n+}\n+\n+pub fn evaluate_obligation(infcx: &InferCtxt,\n+                           param_env: &ty::ParameterEnvironment,\n+                           obligation: &Obligation,\n+                           unboxed_closures: &DefIdMap<ty::UnboxedClosure>)\n+                           -> EvaluationResult\n+{\n+    /*!\n+     * Attempts to resolve the obligation given. Returns `None` if\n+     * we are unable to resolve, either because of ambiguity or\n+     * due to insufficient inference.\n+     */\n+\n+    let selcx = select::SelectionContext::new(infcx, param_env,\n+                                              unboxed_closures);\n+    selcx.evaluate_obligation(obligation)\n+}\n+\n+pub fn evaluate_impl(infcx: &InferCtxt,\n+                     param_env: &ty::ParameterEnvironment,\n+                     unboxed_closures: &DefIdMap<ty::UnboxedClosure>,\n+                     cause: ObligationCause,\n+                     impl_def_id: ast::DefId,\n+                     self_ty: ty::t)\n+                     -> EvaluationResult\n+{\n+    /*!\n+     * Tests whether the impl `impl_def_id` can be applied to the self\n+     * type `self_ty`. This is similar to \"selection\", but simpler:\n+     *\n+     * - It does not take a full trait-ref as input, so it skips over\n+     *   the \"confirmation\" step which would reconcile output type\n+     *   parameters.\n+     * - It returns an `EvaluationResult`, which is a tri-value return\n+     *   (yes/no/unknown).\n+     */\n+\n+    let selcx = select::SelectionContext::new(infcx, param_env, unboxed_closures);\n+    selcx.evaluate_impl(impl_def_id, cause, self_ty)\n+}\n+\n+pub fn select_inherent_impl(infcx: &InferCtxt,\n+                            param_env: &ty::ParameterEnvironment,\n+                            unboxed_closures: &DefIdMap<ty::UnboxedClosure>,\n+                            cause: ObligationCause,\n+                            impl_def_id: ast::DefId,\n+                            self_ty: ty::t)\n+                            -> SelectionResult<VtableImpl<Obligation>>\n+{\n+    /*!\n+     * Matches the self type of the inherent impl `impl_def_id`\n+     * against `self_ty` and returns the resulting resolution.  This\n+     * routine may modify the surrounding type context (for example,\n+     * it may unify variables).\n+     */\n+\n+    // This routine is only suitable for inherent impls. This is\n+    // because it does not attempt to unify the output type parameters\n+    // from the trait ref against the values from the obligation.\n+    // (These things do not apply to inherent impls, for which there\n+    // is no trait ref nor obligation.)\n+    //\n+    // Matching against non-inherent impls should be done with\n+    // `try_resolve_obligation()`.\n+    assert!(ty::impl_trait_ref(infcx.tcx, impl_def_id).is_none());\n+\n+    let selcx = select::SelectionContext::new(infcx, param_env,\n+                                              unboxed_closures);\n+    selcx.select_inherent_impl(impl_def_id, cause, self_ty)\n+}\n+\n+pub fn is_orphan_impl(tcx: &ty::ctxt,\n+                      impl_def_id: ast::DefId)\n+                      -> bool\n+{\n+    /*!\n+     * True if neither the trait nor self type is local. Note that\n+     * `impl_def_id` must refer to an impl of a trait, not an inherent\n+     * impl.\n+     */\n+\n+    !coherence::impl_is_local(tcx, impl_def_id)\n+}\n+\n+pub fn overlapping_impls(infcx: &InferCtxt,\n+                         impl1_def_id: ast::DefId,\n+                         impl2_def_id: ast::DefId)\n+                         -> bool\n+{\n+    /*!\n+     * True if there exist types that satisfy both of the two given impls.\n+     */\n+\n+    coherence::impl_can_satisfy(infcx, impl1_def_id, impl2_def_id) &&\n+    coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)\n+}\n+\n+pub fn obligations_for_generics(tcx: &ty::ctxt,\n+                                cause: ObligationCause,\n+                                generics: &ty::Generics,\n+                                substs: &subst::Substs)\n+                                -> subst::VecPerParamSpace<Obligation>\n+{\n+    /*!\n+     * Given generics for an impl like:\n+     *\n+     *    impl<A:Foo, B:Bar+Qux> ...\n+     *\n+     * and a substs vector like `<A=A0, B=B0>`, yields a result like\n+     *\n+     *    [[Foo for A0, Bar for B0, Qux for B0], [], []]\n+     */\n+\n+    util::obligations_for_generics(tcx, cause, 0, generics, substs)\n+}\n+\n+pub fn obligation_for_builtin_bound(tcx: &ty::ctxt,\n+                                    cause: ObligationCause,\n+                                    source_ty: ty::t,\n+                                    builtin_bound: ty::BuiltinBound)\n+                                    -> Obligation\n+{\n+    util::obligation_for_builtin_bound(tcx, cause, builtin_bound, 0, source_ty)\n+}\n+\n+impl Obligation {\n+    pub fn new(cause: ObligationCause, trait_ref: Rc<ty::TraitRef>) -> Obligation {\n+        Obligation { cause: cause,\n+                     recursion_depth: 0,\n+                     trait_ref: trait_ref }\n+    }\n+\n+    pub fn misc(span: Span, trait_ref: Rc<ty::TraitRef>) -> Obligation {\n+        Obligation::new(ObligationCause::misc(span), trait_ref)\n+    }\n+\n+    pub fn self_ty(&self) -> ty::t {\n+        self.trait_ref.self_ty()\n+    }\n+}\n+\n+impl ObligationCause {\n+    pub fn new(span: Span, code: ObligationCauseCode) -> ObligationCause {\n+        ObligationCause { span: span, code: code }\n+    }\n+\n+    pub fn misc(span: Span) -> ObligationCause {\n+        ObligationCause { span: span, code: MiscObligation }\n+    }\n+}\n+\n+impl<N> Vtable<N> {\n+    pub fn map_nested<M>(&self, op: |&N| -> M) -> Vtable<M> {\n+        match *self {\n+            VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n+            VtableUnboxedClosure(d) => VtableUnboxedClosure(d),\n+            VtableParam(ref p) => VtableParam((*p).clone()),\n+            VtableBuiltin => VtableBuiltin,\n+        }\n+    }\n+\n+    pub fn map_move_nested<M>(self, op: |N| -> M) -> Vtable<M> {\n+        match self {\n+            VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n+            VtableUnboxedClosure(d) => VtableUnboxedClosure(d),\n+            VtableParam(p) => VtableParam(p),\n+            VtableBuiltin => VtableBuiltin,\n+        }\n+    }\n+}\n+\n+impl<N> VtableImpl<N> {\n+    pub fn map_nested<M>(&self,\n+                         op: |&N| -> M)\n+                         -> VtableImpl<M>\n+    {\n+        VtableImpl {\n+            impl_def_id: self.impl_def_id,\n+            substs: self.substs.clone(),\n+            nested: self.nested.map(op)\n+        }\n+    }\n+\n+    pub fn map_move_nested<M>(self, op: |N| -> M) -> VtableImpl<M> {\n+        let VtableImpl { impl_def_id, substs, nested } = self;\n+        VtableImpl {\n+            impl_def_id: impl_def_id,\n+            substs: substs,\n+            nested: nested.map_move(op)\n+        }\n+    }\n+}\n+\n+impl EvaluationResult {\n+    pub fn potentially_applicable(&self) -> bool {\n+        match *self {\n+            EvaluatedToMatch | EvaluatedToAmbiguity => true,\n+            EvaluatedToUnmatch => false\n+        }\n+    }\n+}\n+\n+impl FulfillmentError {\n+    fn new(obligation: Obligation, code: FulfillmentErrorCode)\n+           -> FulfillmentError\n+    {\n+        FulfillmentError { obligation: obligation, code: code }\n+    }\n+}"}, {"sha": "681e2650f39fa4c31bcb92e41b5633f419a7428c", "filename": "src/librustc/middle/traits/select.rs", "status": "added", "additions": 1024, "deletions": 0, "changes": 1024, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,1024 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*! See `doc.rs` for high-level documentation */\n+\n+use super::{Obligation, ObligationCause};\n+use super::{EvaluationResult, EvaluatedToMatch,\n+            EvaluatedToAmbiguity, EvaluatedToUnmatch};\n+use super::{SelectionError, Unimplemented, Overflow,\n+            OutputTypeParameterMismatch};\n+use super::{Selection};\n+use super::{SelectionResult};\n+use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure};\n+use super::{util};\n+\n+use middle::subst::{Subst, Substs, VecPerParamSpace};\n+use middle::ty;\n+use middle::typeck::check::regionmanip;\n+use middle::typeck::infer;\n+use middle::typeck::infer::InferCtxt;\n+use std::rc::Rc;\n+use syntax::ast;\n+use util::nodemap::DefIdMap;\n+use util::ppaux::Repr;\n+\n+pub struct SelectionContext<'cx, 'tcx:'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    param_env: &'cx ty::ParameterEnvironment,\n+    unboxed_closures: &'cx DefIdMap<ty::UnboxedClosure>,\n+}\n+\n+// pub struct SelectionCache {\n+//     hashmap: RefCell<HashMap<CacheKey, Candidate>>,\n+// }\n+\n+// #[deriving(Hash,Eq,PartialEq)]\n+// struct CacheKey {\n+//     trait_def_id: ast::DefId,\n+//     skol_obligation_self_ty: ty::t,\n+// }\n+\n+enum MatchResult<T> {\n+    Matched(T),\n+    AmbiguousMatch,\n+    NoMatch\n+}\n+\n+/**\n+ * The selection process begins by considering all impls, where\n+ * clauses, and so forth that might resolve an obligation.  Sometimes\n+ * we'll be able to say definitively that (e.g.) an impl does not\n+ * apply to the obligation: perhaps it is defined for `uint` but the\n+ * obligation is for `int`. In that case, we drop the impl out of the\n+ * list.  But the other cases are considered *candidates*.\n+ *\n+ * Candidates can either be definitive or ambiguous. An ambiguous\n+ * candidate is one that might match or might not, depending on how\n+ * type variables wind up being resolved. This only occurs during inference.\n+ *\n+ * For selection to suceed, there must be exactly one non-ambiguous\n+ * candidate.  Usually, it is not possible to have more than one\n+ * definitive candidate, due to the coherence rules. However, there is\n+ * one case where it could occur: if there is a blanket impl for a\n+ * trait (that is, an impl applied to all T), and a type parameter\n+ * with a where clause. In that case, we can have a candidate from the\n+ * where clause and a second candidate from the impl. This is not a\n+ * problem because coherence guarantees us that the impl which would\n+ * be used to satisfy the where clause is the same one that we see\n+ * now. To resolve this issue, therefore, we ignore impls if we find a\n+ * matching where clause. Part of the reason for this is that where\n+ * clauses can give additional information (like, the types of output\n+ * parameters) that would have to be inferred from the impl.\n+ */\n+#[deriving(Clone)]\n+enum Candidate {\n+    MatchedBuiltinCandidate,\n+    AmbiguousBuiltinCandidate,\n+    MatchedParamCandidate(VtableParam),\n+    AmbiguousParamCandidate,\n+    Impl(ImplCandidate),\n+    MatchedUnboxedClosureCandidate(/* closure */ ast::DefId)\n+}\n+\n+#[deriving(Clone)]\n+enum ImplCandidate {\n+    MatchedImplCandidate(ast::DefId),\n+    AmbiguousImplCandidate(ast::DefId),\n+}\n+\n+impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n+    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n+               param_env: &'cx ty::ParameterEnvironment,\n+               unboxed_closures: &'cx DefIdMap<ty::UnboxedClosure>)\n+               -> SelectionContext<'cx, 'tcx> {\n+        SelectionContext { infcx: infcx, param_env: param_env,\n+                           unboxed_closures: unboxed_closures }\n+    }\n+\n+    pub fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Selection\n+    //\n+    // The selection phase tries to identify *how* an obligation will\n+    // be resolved. For example, it will identify which impl or\n+    // parameter bound is to be used. The process can be inconclusive\n+    // if the self type in the obligation is not fully inferred. Selection\n+    // can result in an error in one of two ways:\n+    //\n+    // 1. If no applicable impl or parameter bound can be found.\n+    // 2. If the output type parameters in the obligation do not match\n+    //    those specified by the impl/bound. For example, if the obligation\n+    //    is `Vec<Foo>:Iterable<Bar>`, but the impl specifies\n+    //    `impl<T> Iterable<T> for Vec<T>`, than an error would result.\n+\n+    pub fn select(&self, obligation: &Obligation) -> SelectionResult<Selection> {\n+        /*!\n+         * Evaluates whether the obligation can be satisfied. Returns\n+         * an indication of whether the obligation can be satisfied\n+         * and, if so, by what means. Never affects surrounding typing\n+         * environment.\n+         */\n+\n+        debug!(\"select({})\", obligation.repr(self.tcx()));\n+\n+        match try!(self.candidate_from_obligation(obligation)) {\n+            None => Ok(None),\n+            Some(candidate) => self.confirm_candidate(obligation, candidate),\n+        }\n+    }\n+\n+    pub fn select_inherent_impl(&self,\n+                                impl_def_id: ast::DefId,\n+                                obligation_cause: ObligationCause,\n+                                obligation_self_ty: ty::t)\n+                                -> SelectionResult<VtableImpl<Obligation>>\n+    {\n+        debug!(\"select_inherent_impl(impl_def_id={}, obligation_self_ty={})\",\n+               impl_def_id.repr(self.tcx()),\n+               obligation_self_ty.repr(self.tcx()));\n+\n+        match self.candidate_from_impl(impl_def_id,\n+                                       obligation_cause,\n+                                       obligation_self_ty) {\n+            Some(MatchedImplCandidate(impl_def_id)) => {\n+                let vtable_impl =\n+                    try!(self.confirm_inherent_impl_candidate(\n+                        impl_def_id,\n+                        obligation_cause,\n+                        obligation_self_ty,\n+                        0));\n+                Ok(Some(vtable_impl))\n+            }\n+            Some(AmbiguousImplCandidate(_)) => {\n+                Ok(None)\n+            }\n+            None => {\n+                Err(Unimplemented)\n+            }\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // EVALUATION\n+    //\n+    // Tests whether an obligation can be selected or whether an impl can be\n+    // applied to particular types. It skips the \"confirmation\" step and\n+    // hence completely ignores output type parameters.\n+\n+    pub fn evaluate_obligation(&self,\n+                               obligation: &Obligation)\n+                               -> EvaluationResult\n+    {\n+        /*!\n+         * Evaluates whether the obligation `obligation` can be\n+         * satisfied (by any means).\n+         */\n+\n+        debug!(\"evaluate_obligation({})\",\n+               obligation.repr(self.tcx()));\n+\n+        match self.candidate_from_obligation(obligation) {\n+            Ok(Some(c)) => c.to_evaluation_result(),\n+            Ok(None) => EvaluatedToAmbiguity,\n+            Err(_) => EvaluatedToUnmatch,\n+        }\n+    }\n+\n+    pub fn evaluate_impl(&self,\n+                         impl_def_id: ast::DefId,\n+                         obligation_cause: ObligationCause,\n+                         obligation_self_ty: ty::t)\n+                         -> EvaluationResult\n+    {\n+        /*!\n+         * Evaluates whether the impl with id `impl_def_id` could be\n+         * applied to the self type `obligation_self_ty`. This can be\n+         * used either for trait or inherent impls.\n+         */\n+\n+        debug!(\"evaluate_impl(impl_def_id={}, obligation_self_ty={})\",\n+               impl_def_id.repr(self.tcx()),\n+               obligation_self_ty.repr(self.tcx()));\n+\n+        match self.candidate_from_impl(impl_def_id,\n+                                       obligation_cause,\n+                                       obligation_self_ty) {\n+            Some(c) => c.to_evaluation_result(),\n+            None => EvaluatedToUnmatch,\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // CANDIDATE ASSEMBLY\n+    //\n+    // The selection process begins by examining all in-scope impls,\n+    // caller obligations, and so forth and assembling a list of\n+    // candidates. See `doc.rs` and the `Candidate` type for more details.\n+\n+    fn candidate_from_obligation(&self, obligation: &Obligation)\n+                                 -> SelectionResult<Candidate>\n+    {\n+        debug!(\"candidate_from_obligation({}, self_ty={})\",\n+               obligation.repr(self.tcx()),\n+               self.infcx.ty_to_string(obligation.self_ty()));\n+\n+        let skol_obligation_self_ty =\n+            infer::skolemize(self.infcx, obligation.self_ty());\n+\n+        // First, check the cache.\n+        match self.check_candidate_cache(obligation, skol_obligation_self_ty) {\n+            Some(c) => {\n+                return Ok(Some(c));\n+            }\n+            None => { }\n+        }\n+\n+        let mut candidates =\n+            try!(self.assemble_candidates(obligation,\n+                                          skol_obligation_self_ty));\n+\n+        debug!(\"candidate_from_obligation: {} candidates for {}\",\n+               candidates.len(), obligation.repr(self.tcx()));\n+\n+        // Examine candidates to determine outcome. Ideally we will\n+        // have exactly one candidate that is definitively applicable.\n+\n+        if candidates.len() == 0 {\n+            // Annoying edge case: if there are no impls, then there\n+            // is no way that this trait reference is implemented,\n+            // *unless* it contains unbound variables. In that case,\n+            // it is possible that one of those unbound variables will\n+            // be bound to a new type from some other crate which will\n+            // also contain impls.\n+            let trait_ref = &*obligation.trait_ref;\n+            return if !self.trait_ref_unconstrained(trait_ref) {\n+                debug!(\"candidate_from_obligation({}) -> 0 matches, unimpl\",\n+                       obligation.repr(self.tcx()));\n+                Err(Unimplemented)\n+            } else {\n+                debug!(\"candidate_from_obligation({}) -> 0 matches, ambig\",\n+                       obligation.repr(self.tcx()));\n+                Ok(None)\n+            };\n+        }\n+\n+        if candidates.len() > 1 {\n+            // Ambiguity. Possibly we should report back more\n+            // information on the potential candidates so we can give\n+            // a better error message.\n+            debug!(\"candidate_from_obligation({}) -> multiple matches, ambig\",\n+                   obligation.repr(self.tcx()));\n+\n+            return Ok(None);\n+        }\n+\n+        let candidate = candidates.pop().unwrap();\n+        self.insert_candidate_cache(obligation, skol_obligation_self_ty,\n+                                    candidate.clone());\n+        Ok(Some(candidate))\n+    }\n+\n+    fn check_candidate_cache(&self,\n+                             _obligation: &Obligation,\n+                             _skol_obligation_self_ty: ty::t)\n+                             -> Option<Candidate>\n+    {\n+        // let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n+        //                               skol_obligation_self_ty);\n+        // let hashmap = self.tcx().selection_cache.hashmap.borrow();\n+        // hashmap.find(&cache_key).map(|c| (*c).clone())\n+        None\n+    }\n+\n+    fn insert_candidate_cache(&self,\n+                              _obligation: &Obligation,\n+                              _skol_obligation_self_ty: ty::t,\n+                              _candidate: Candidate)\n+    {\n+        // FIXME -- Enable caching. I think the right place to put the cache\n+        // is in the ParameterEnvironment, not the tcx, because otherwise\n+        // when there are distinct where clauses in scope the cache can get\n+        // confused.\n+        //\n+        //let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n+        //                              skol_obligation_self_ty);\n+        //let mut hashmap = self.tcx().selection_cache.hashmap.borrow_mut();\n+        //hashmap.insert(cache_key, candidate);\n+    }\n+\n+    fn assemble_candidates(&self,\n+                           obligation: &Obligation,\n+                           skol_obligation_self_ty: ty::t)\n+                           -> Result<Vec<Candidate>, SelectionError>\n+    {\n+        // Check for overflow.\n+\n+        let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n+        if obligation.recursion_depth >= recursion_limit {\n+            debug!(\"{} --> overflow\", obligation.repr(self.tcx()));\n+            return Err(Overflow);\n+        }\n+\n+        let mut candidates = Vec::new();\n+\n+        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n+            Some(_) => {\n+                // FIXME -- The treatment of builtin bounds is a bit\n+                // hacky right now. Eventually, the idea is to move\n+                // the logic for selection out of type_contents and\n+                // into this module (And make it based on the generic\n+                // mechanisms of OIBTT2).  However, I want to land\n+                // some code today, so we're going to cut a few\n+                // corners. What we do now is that the trait selection\n+                // code always considers builtin obligations to\n+                // match. The fulfillment code (which also has the job\n+                // of tracking all the traits that must hold) will\n+                // then just accumulate the various\n+                // builtin-bound-related obligations that must be met.\n+                // Later, at the end of typeck, after writeback etc,\n+                // we will rewalk this list and extract all the\n+                // builtin-bound-related obligations and test them\n+                // again using type contents. Part of the motivation\n+                // for this is that the type contents code requires\n+                // that writeback has been completed in some cases.\n+\n+                candidates.push(AmbiguousBuiltinCandidate);\n+            }\n+\n+            None => {\n+                // Other bounds. Consider both in-scope bounds from fn decl\n+                // and applicable impls.\n+\n+                try!(self.assemble_candidates_from_caller_bounds(\n+                    obligation,\n+                    skol_obligation_self_ty,\n+                    &mut candidates));\n+\n+                try!(self.assemble_unboxed_candidates(\n+                    obligation,\n+                    skol_obligation_self_ty,\n+                    &mut candidates));\n+\n+                // If there is a fn bound that applies, forego the\n+                // impl search. It can only generate conflicts.\n+\n+                if candidates.len() == 0 {\n+                    try!(self.assemble_candidates_from_impls(\n+                        obligation,\n+                        skol_obligation_self_ty,\n+                        &mut candidates));\n+                }\n+            }\n+        }\n+\n+        Ok(candidates)\n+    }\n+\n+    fn assemble_candidates_from_caller_bounds(&self,\n+                                              obligation: &Obligation,\n+                                              skol_obligation_self_ty: ty::t,\n+                                              candidates: &mut Vec<Candidate>)\n+                                              -> Result<(),SelectionError>\n+    {\n+        /*!\n+         * Given an obligation like `<SomeTrait for T>`, search the obligations\n+         * that the caller supplied to find out whether it is listed among\n+         * them.\n+         *\n+         * Never affects inference environment.\n+v         */\n+\n+        debug!(\"assemble_candidates_from_caller_bounds({})\",\n+               obligation.repr(self.tcx()));\n+\n+        for caller_obligation in self.param_env.caller_obligations.iter() {\n+            debug!(\"caller_obligation={}\",\n+                   caller_obligation.repr(self.tcx()));\n+\n+            // Skip over obligations that don't apply to\n+            // `self_ty`.\n+            let caller_bound = &caller_obligation.trait_ref;\n+            let caller_self_ty = caller_bound.substs.self_ty().unwrap();\n+            match self.match_self_types(obligation.cause,\n+                                        caller_self_ty,\n+                                        skol_obligation_self_ty) {\n+                AmbiguousMatch => {\n+                    debug!(\"-> AmbiguousParamCandidate\");\n+                    candidates.push(AmbiguousParamCandidate);\n+                    return Ok(());\n+                }\n+                NoMatch => {\n+                    continue;\n+                }\n+                Matched(()) => { }\n+            }\n+\n+            // Search through the trait (and its supertraits) to\n+            // see if it matches the def-id we are looking for.\n+            let caller_bound = (*caller_bound).clone();\n+            match util::search_trait_and_supertraits_from_bound(\n+                self.infcx.tcx, caller_bound,\n+                |d| d == obligation.trait_ref.def_id)\n+            {\n+                Some(vtable_param) => {\n+                    // If so, we're done!\n+                    debug!(\"-> MatchedParamCandidate({})\", vtable_param);\n+                    candidates.push(MatchedParamCandidate(vtable_param));\n+                    return Ok(());\n+                }\n+\n+                None => {\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn assemble_unboxed_candidates(&self,\n+                                   obligation: &Obligation,\n+                                   skol_obligation_self_ty: ty::t,\n+                                   candidates: &mut Vec<Candidate>)\n+                                   -> Result<(),SelectionError>\n+    {\n+        /*!\n+         * Check for the artificial impl that the compiler will create\n+         * for an obligation like `X : FnMut<..>` where `X` is an\n+         * unboxed closure type.\n+         */\n+\n+        let closure_def_id = match ty::get(skol_obligation_self_ty).sty {\n+            ty::ty_unboxed_closure(id, _) => id,\n+            _ => { return Ok(()); }\n+        };\n+\n+        let tcx = self.tcx();\n+        let fn_traits = [\n+            (ty::FnUnboxedClosureKind, tcx.lang_items.fn_trait()),\n+            (ty::FnMutUnboxedClosureKind, tcx.lang_items.fn_mut_trait()),\n+            (ty::FnOnceUnboxedClosureKind, tcx.lang_items.fn_once_trait()),\n+            ];\n+        for tuple in fn_traits.iter() {\n+            let kind = match tuple {\n+                &(kind, Some(ref fn_trait))\n+                    if *fn_trait == obligation.trait_ref.def_id =>\n+                {\n+                    kind\n+                }\n+                _ => continue,\n+            };\n+\n+            // Check to see whether the argument and return types match.\n+            let closure_kind = match self.unboxed_closures.find(&closure_def_id) {\n+                Some(closure) => closure.kind,\n+                None => {\n+                    self.tcx().sess.span_bug(\n+                        obligation.cause.span,\n+                        format!(\"No entry for unboxed closure: {}\",\n+                                closure_def_id.repr(self.tcx())).as_slice());\n+                }\n+            };\n+\n+            if closure_kind != kind {\n+                continue;\n+            }\n+\n+            candidates.push(MatchedUnboxedClosureCandidate(closure_def_id));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn assemble_candidates_from_impls(&self,\n+                                      obligation: &Obligation,\n+                                      skol_obligation_self_ty: ty::t,\n+                                      candidates: &mut Vec<Candidate>)\n+                                      -> Result<(), SelectionError>\n+    {\n+        /*!\n+         * Search for impls that might apply to `obligation`.\n+         */\n+\n+        let all_impls = self.all_impls(obligation.trait_ref.def_id);\n+        for &impl_def_id in all_impls.iter() {\n+            self.infcx.probe(|| {\n+                match self.candidate_from_impl(impl_def_id,\n+                                               obligation.cause,\n+                                               skol_obligation_self_ty) {\n+                    Some(c) => {\n+                        candidates.push(Impl(c));\n+                    }\n+\n+                    None => { }\n+                }\n+            });\n+        }\n+        Ok(())\n+    }\n+\n+    fn candidate_from_impl(&self,\n+                           impl_def_id: ast::DefId,\n+                           obligation_cause: ObligationCause,\n+                           skol_obligation_self_ty: ty::t)\n+                           -> Option<ImplCandidate>\n+    {\n+        match self.match_impl_self_types(impl_def_id,\n+                                         obligation_cause,\n+                                         skol_obligation_self_ty) {\n+            Matched(_) => {\n+                Some(MatchedImplCandidate(impl_def_id))\n+            }\n+\n+            AmbiguousMatch => {\n+                Some(AmbiguousImplCandidate(impl_def_id))\n+            }\n+\n+            NoMatch => {\n+                None\n+            }\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // CONFIRMATION\n+    //\n+    // Confirmation unifies the output type parameters of the trait\n+    // with the values found in the obligation, possibly yielding a\n+    // type error.  See `doc.rs` for more details.\n+\n+    fn confirm_candidate(&self,\n+                         obligation: &Obligation,\n+                         candidate: Candidate)\n+                         -> SelectionResult<Selection>\n+    {\n+        debug!(\"confirm_candidate({}, {})\",\n+               obligation.repr(self.tcx()),\n+               candidate.repr(self.tcx()));\n+\n+        match candidate {\n+            AmbiguousBuiltinCandidate |\n+            AmbiguousParamCandidate |\n+            Impl(AmbiguousImplCandidate(_)) => {\n+                Ok(None)\n+            }\n+\n+            MatchedBuiltinCandidate => {\n+                Ok(Some(VtableBuiltin))\n+            }\n+\n+            MatchedParamCandidate(param) => {\n+                Ok(Some(VtableParam(\n+                    try!(self.confirm_param_candidate(obligation, param)))))\n+            }\n+\n+            Impl(MatchedImplCandidate(impl_def_id)) => {\n+                let vtable_impl = try!(self.confirm_impl_candidate(obligation,\n+                                                                   impl_def_id));\n+                Ok(Some(VtableImpl(vtable_impl)))\n+            }\n+\n+            MatchedUnboxedClosureCandidate(closure_def_id) => {\n+                try!(self.confirm_unboxed_closure_candidate(obligation, closure_def_id));\n+                Ok(Some(VtableUnboxedClosure(closure_def_id)))\n+            }\n+        }\n+    }\n+\n+    fn confirm_param_candidate(&self,\n+                               obligation: &Obligation,\n+                               param: VtableParam)\n+                               -> Result<VtableParam,SelectionError>\n+    {\n+        debug!(\"confirm_param_candidate({},{})\",\n+               obligation.repr(self.tcx()),\n+               param.repr(self.tcx()));\n+\n+        let () = try!(self.confirm(obligation.cause,\n+                                   obligation.trait_ref.clone(),\n+                                   param.bound.clone()));\n+        Ok(param)\n+    }\n+\n+    fn confirm_impl_candidate(&self,\n+                              obligation: &Obligation,\n+                              impl_def_id: ast::DefId)\n+                              -> Result<VtableImpl<Obligation>,SelectionError>\n+    {\n+        debug!(\"confirm_impl_candidate({},{})\",\n+               obligation.repr(self.tcx()),\n+               impl_def_id.repr(self.tcx()));\n+\n+        // For a non-inhernet impl, we begin the same way as an\n+        // inherent impl, by matching the self-type and assembling\n+        // list of nested obligations.\n+        let vtable_impl =\n+            try!(self.confirm_inherent_impl_candidate(\n+                impl_def_id,\n+                obligation.cause,\n+                obligation.trait_ref.self_ty(),\n+                obligation.recursion_depth));\n+\n+        // But then we must also match the output types.\n+        let () = try!(self.confirm_impl_vtable(impl_def_id,\n+                                               obligation.cause,\n+                                               obligation.trait_ref.clone(),\n+                                               &vtable_impl.substs));\n+        Ok(vtable_impl)\n+    }\n+\n+    fn confirm_inherent_impl_candidate(&self,\n+                                       impl_def_id: ast::DefId,\n+                                       obligation_cause: ObligationCause,\n+                                       obligation_self_ty: ty::t,\n+                                       obligation_recursion_depth: uint)\n+                                       -> Result<VtableImpl<Obligation>,\n+                                                 SelectionError>\n+    {\n+        let substs = match self.match_impl_self_types(impl_def_id,\n+                                                      obligation_cause,\n+                                                      obligation_self_ty) {\n+            Matched(substs) => substs,\n+            AmbiguousMatch | NoMatch => {\n+                self.tcx().sess.bug(\n+                    format!(\"Impl {} was matchable against {} but now is not\",\n+                            impl_def_id.repr(self.tcx()),\n+                            obligation_self_ty.repr(self.tcx()))\n+                        .as_slice());\n+            }\n+        };\n+\n+        let impl_obligations =\n+            self.impl_obligations(obligation_cause,\n+                                  obligation_recursion_depth,\n+                                  impl_def_id,\n+                                  &substs);\n+        let vtable_impl = VtableImpl { impl_def_id: impl_def_id,\n+                                       substs: substs,\n+                                       nested: impl_obligations };\n+\n+        Ok(vtable_impl)\n+    }\n+\n+    fn confirm_unboxed_closure_candidate(&self,\n+                                         obligation: &Obligation,\n+                                         closure_def_id: ast::DefId)\n+                                         -> Result<(),SelectionError>\n+    {\n+        debug!(\"confirm_unboxed_closure_candidate({},{})\",\n+               obligation.repr(self.tcx()),\n+               closure_def_id.repr(self.tcx()));\n+\n+        let closure_type = match self.unboxed_closures.find(&closure_def_id) {\n+            Some(closure) => closure.closure_type.clone(),\n+            None => {\n+                self.tcx().sess.span_bug(\n+                    obligation.cause.span,\n+                    format!(\"No entry for unboxed closure: {}\",\n+                            closure_def_id.repr(self.tcx())).as_slice());\n+            }\n+        };\n+\n+        // FIXME(pcwalton): This is a bogus thing to do, but\n+        // it'll do for now until we get the new trait-bound\n+        // region skolemization working.\n+        let (_, new_signature) =\n+            regionmanip::replace_late_bound_regions_in_fn_sig(\n+                self.tcx(),\n+                &closure_type.sig,\n+                |br| self.infcx.next_region_var(\n+                         infer::LateBoundRegion(obligation.cause.span, br)));\n+\n+        let arguments_tuple = *new_signature.inputs.get(0);\n+        let trait_ref = Rc::new(ty::TraitRef {\n+            def_id: obligation.trait_ref.def_id,\n+            substs: Substs::new_trait(\n+                vec![arguments_tuple, new_signature.output],\n+                vec![],\n+                obligation.self_ty())\n+        });\n+\n+        self.confirm(obligation.cause,\n+                     obligation.trait_ref.clone(),\n+                     trait_ref)\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Matching\n+    //\n+    // Matching is a common path used for both evaluation and\n+    // confirmation.  It basically unifies types that appear in impls\n+    // and traits. This does affect the surrounding environment;\n+    // therefore, when used during evaluation, match routines must be\n+    // run inside of a `probe()` so that their side-effects are\n+    // contained.\n+\n+    fn match_impl_self_types(&self,\n+                             impl_def_id: ast::DefId,\n+                             obligation_cause: ObligationCause,\n+                             obligation_self_ty: ty::t)\n+                             -> MatchResult<Substs>\n+    {\n+        /*!\n+         * Determines whether the self type declared against\n+         * `impl_def_id` matches `obligation_self_ty`. If successful,\n+         * returns the substitutions used to make them match. See\n+         * `match_impl()`.  For example, if `impl_def_id` is declared\n+         * as:\n+         *\n+         *    impl<T:Copy> Foo for ~T { ... }\n+         *\n+         * and `obligation_self_ty` is `int`, we'd back an `Err(_)`\n+         * result. But if `obligation_self_ty` were `~int`, we'd get\n+         * back `Ok(T=int)`.\n+         */\n+\n+        // Create fresh type variables for each type parameter declared\n+        // on the impl etc.\n+        let impl_substs = util::fresh_substs_for_impl(self.infcx,\n+                                                      obligation_cause.span,\n+                                                      impl_def_id);\n+\n+        // Find the self type for the impl.\n+        let impl_self_ty = ty::lookup_item_type(self.tcx(), impl_def_id).ty;\n+        let impl_self_ty = impl_self_ty.subst(self.tcx(), &impl_substs);\n+\n+        debug!(\"match_impl_self_types(obligation_self_ty={}, impl_self_ty={})\",\n+               obligation_self_ty.repr(self.tcx()),\n+               impl_self_ty.repr(self.tcx()));\n+\n+        match self.match_self_types(obligation_cause,\n+                                    impl_self_ty,\n+                                    obligation_self_ty) {\n+            Matched(()) => {\n+                debug!(\"Matched impl_substs={}\", impl_substs.repr(self.tcx()));\n+                Matched(impl_substs)\n+            }\n+            AmbiguousMatch => {\n+                debug!(\"AmbiguousMatch\");\n+                AmbiguousMatch\n+            }\n+            NoMatch => {\n+                debug!(\"NoMatch\");\n+                NoMatch\n+            }\n+        }\n+    }\n+\n+    fn match_self_types(&self,\n+                        cause: ObligationCause,\n+\n+                        // The self type provided by the impl/caller-obligation:\n+                        provided_self_ty: ty::t,\n+\n+                        // The self type the obligation is for:\n+                        required_self_ty: ty::t)\n+                        -> MatchResult<()>\n+    {\n+        // FIXME(#5781) -- equating the types is stronger than\n+        // necessary. Should consider variance of trait w/r/t Self.\n+\n+        let origin = infer::RelateSelfType(cause.span);\n+        match self.infcx.eq_types(false,\n+                                  origin,\n+                                  provided_self_ty,\n+                                  required_self_ty) {\n+            Ok(()) => Matched(()),\n+            Err(ty::terr_sorts(ty::expected_found{expected: t1, found: t2})) => {\n+                // This error occurs when there is an unresolved type\n+                // variable in the `required_self_ty` that was forced\n+                // to unify with a non-type-variable. That basically\n+                // means we don't know enough to say with certainty\n+                // whether there is a match or not -- it depends on\n+                // how that type variable is ultimately resolved.\n+                if ty::type_is_skolemized(t1) || ty::type_is_skolemized(t2) {\n+                    AmbiguousMatch\n+                } else {\n+                    NoMatch\n+                }\n+            }\n+            Err(_) => NoMatch,\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Confirmation\n+    //\n+    // The final step of selection: once we know how an obligation is\n+    // is resolved, we confirm that selection in order to have\n+    // side-effects on the typing environment. This step also unifies\n+    // the output type parameters from the obligation with those found\n+    // on the impl/bound, which may yield type errors.\n+\n+    fn confirm_impl_vtable(&self,\n+                           impl_def_id: ast::DefId,\n+                           obligation_cause: ObligationCause,\n+                           obligation_trait_ref: Rc<ty::TraitRef>,\n+                           substs: &Substs)\n+                           -> Result<(), SelectionError>\n+    {\n+        /*!\n+         * Relates the output type parameters from an impl to the\n+         * trait.  This may lead to type errors. The confirmation step\n+         * is separated from the main match procedure because these\n+         * type errors do not cause us to select another impl.\n+         *\n+         * As an example, consider matching the obligation\n+         * `Iterator<char> for Elems<int>` using the following impl:\n+         *\n+         *    impl<T> Iterator<T> for Elems<T> { ... }\n+         *\n+         * The match phase will succeed with substitution `T=int`.\n+         * The confirm step will then try to unify `int` and `char`\n+         * and yield an error.\n+         */\n+\n+        let impl_trait_ref = ty::impl_trait_ref(self.tcx(),\n+                                                impl_def_id).unwrap();\n+        let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n+                                                  substs);\n+        self.confirm(obligation_cause, obligation_trait_ref, impl_trait_ref)\n+    }\n+\n+    fn confirm(&self,\n+               obligation_cause: ObligationCause,\n+               obligation_trait_ref: Rc<ty::TraitRef>,\n+               expected_trait_ref: Rc<ty::TraitRef>)\n+               -> Result<(), SelectionError>\n+    {\n+        /*!\n+         * After we have determined which impl applies, and with what\n+         * substitutions, there is one last step. We have to go back\n+         * and relate the \"output\" type parameters from the obligation\n+         * to the types that are specified in the impl.\n+         *\n+         * For example, imagine we have:\n+         *\n+         *     impl<T> Iterator<T> for Vec<T> { ... }\n+         *\n+         * and our obligation is `Iterator<Foo> for Vec<int>` (note\n+         * the mismatch in the obligation types). Up until this step,\n+         * no error would be reported: the self type is `Vec<int>`,\n+         * and that matches `Vec<T>` with the substitution `T=int`.\n+         * At this stage, we could then go and check that the type\n+         * parameters to the `Iterator` trait match.\n+         * (In terms of the parameters, the `expected_trait_ref`\n+         * here would be `Iterator<int> for Vec<int>`, and the\n+         * `obligation_trait_ref` would be `Iterator<Foo> for Vec<int>`.\n+         *\n+         * Note that this checking occurs *after* the impl has\n+         * selected, because these output type parameters should not\n+         * affect the selection of the impl. Therefore, if there is a\n+         * mismatch, we report an error to the user.\n+         */\n+\n+        let origin = infer::RelateOutputImplTypes(obligation_cause.span);\n+\n+        let obligation_trait_ref = obligation_trait_ref.clone();\n+        match self.infcx.sub_trait_refs(false,\n+                                        origin,\n+                                        expected_trait_ref.clone(),\n+                                        obligation_trait_ref) {\n+            Ok(()) => Ok(()),\n+            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, e))\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Miscellany\n+\n+    fn all_impls(&self, trait_def_id: ast::DefId) -> Vec<ast::DefId> {\n+        /*!\n+         * Returns se tof all impls for a given trait.\n+         */\n+\n+        ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n+                                                            trait_def_id);\n+        match self.tcx().trait_impls.borrow().find(&trait_def_id) {\n+            None => Vec::new(),\n+            Some(impls) => impls.borrow().clone()\n+        }\n+    }\n+\n+    fn impl_obligations(&self,\n+                        cause: ObligationCause,\n+                        recursion_depth: uint,\n+                        impl_def_id: ast::DefId,\n+                        impl_substs: &Substs)\n+                        -> VecPerParamSpace<Obligation>\n+    {\n+        let impl_generics = ty::lookup_item_type(self.tcx(),\n+                                                 impl_def_id).generics;\n+        util::obligations_for_generics(self.tcx(), cause, recursion_depth,\n+                                       &impl_generics, impl_substs)\n+    }\n+\n+    fn trait_ref_unconstrained(&self,\n+                               trait_ref: &ty::TraitRef)\n+                               -> bool\n+    {\n+        /*!\n+         * True if the self type of the trait-ref contains\n+         * unconstrained type variables.\n+         */\n+\n+        let mut found_skol = false;\n+\n+        // Skolemization replaces all unconstrained type vars with\n+        // a SkolemizedTy instance. Then we search to see if we\n+        // found any.\n+        let skol_ty = infer::skolemize(self.infcx, trait_ref.self_ty());\n+        ty::walk_ty(skol_ty, |t| {\n+            match ty::get(t).sty {\n+                ty::ty_infer(ty::SkolemizedTy(_)) => { found_skol = true; }\n+                _ => { }\n+            }\n+        });\n+\n+        found_skol\n+    }\n+}\n+\n+impl Candidate {\n+    fn to_evaluation_result(&self) -> EvaluationResult {\n+        match *self {\n+            Impl(ref i) => i.to_evaluation_result(),\n+\n+            MatchedUnboxedClosureCandidate(..) |\n+            MatchedBuiltinCandidate |\n+            MatchedParamCandidate(..) => {\n+                EvaluatedToMatch\n+            }\n+\n+            AmbiguousBuiltinCandidate |\n+            AmbiguousParamCandidate => {\n+                EvaluatedToAmbiguity\n+            }\n+        }\n+    }\n+}\n+\n+impl ImplCandidate {\n+    fn to_evaluation_result(&self) -> EvaluationResult {\n+        match *self {\n+            MatchedImplCandidate(..) => EvaluatedToMatch,\n+            AmbiguousImplCandidate(..) => EvaluatedToAmbiguity\n+        }\n+    }\n+}\n+\n+impl Repr for Candidate {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            MatchedBuiltinCandidate => format!(\"MatchedBuiltinCandidate\"),\n+            AmbiguousBuiltinCandidate => format!(\"AmbiguousBuiltinCandidate\"),\n+            MatchedUnboxedClosureCandidate(c) => format!(\"MatchedUnboxedClosureCandidate({})\", c),\n+            MatchedParamCandidate(ref r) => format!(\"MatchedParamCandidate({})\",\n+                                                    r.repr(tcx)),\n+            AmbiguousParamCandidate => format!(\"AmbiguousParamCandidate\"),\n+            Impl(ref i) => i.repr(tcx)\n+        }\n+    }\n+}\n+\n+impl Repr for ImplCandidate {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            MatchedImplCandidate(ref d) => format!(\"MatchedImplCandidate({})\",\n+                                                   d.repr(tcx)),\n+            AmbiguousImplCandidate(ref d) => format!(\"AmbiguousImplCandidate({})\",\n+                                                     d.repr(tcx)),\n+        }\n+    }\n+}\n+\n+\n+// impl SelectionCache {\n+//     pub fn new() -> SelectionCache {\n+//         SelectionCache {\n+//             hashmap: RefCell::new(HashMap::new())\n+//         }\n+//     }\n+// }\n+\n+// impl CacheKey {\n+//     pub fn new(trait_def_id: ast::DefId,\n+//                skol_obligation_self_ty: ty::t)\n+//                -> CacheKey\n+//     {\n+//         CacheKey {\n+//             trait_def_id: trait_def_id,\n+//             skol_obligation_self_ty: skol_obligation_self_ty\n+//         }\n+//     }\n+// }"}, {"sha": "11b954f2ba6af68198b61b575f6b64290c261e6d", "filename": "src/librustc/middle/traits/util.rs", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,356 @@\n+\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::subst;\n+use middle::subst::{ParamSpace, Subst, Substs, VecPerParamSpace};\n+use middle::typeck::infer::InferCtxt;\n+use middle::ty;\n+use std::fmt;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use util::ppaux::Repr;\n+\n+use super::{Obligation, ObligationCause, VtableImpl, VtableParam};\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Supertrait iterator\n+\n+pub struct Supertraits<'cx, 'tcx:'cx> {\n+    tcx: &'cx ty::ctxt<'tcx>,\n+    stack: Vec<SupertraitEntry>,\n+}\n+\n+struct SupertraitEntry {\n+    position: uint,\n+    supertraits: Vec<Rc<ty::TraitRef>>,\n+}\n+\n+pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n+                              trait_ref: Rc<ty::TraitRef>)\n+                              -> Supertraits<'cx, 'tcx>\n+{\n+    /*!\n+     * Returns an iterator over the trait reference `T` and all of its\n+     * supertrait references. May contain duplicates. In general\n+     * the ordering is not defined.\n+     *\n+     * Example:\n+     *\n+     * ```\n+     * trait Foo { ... }\n+     * trait Bar : Foo { ... }\n+     * trait Baz : Bar+Foo { ... }\n+     * ```\n+     *\n+     * `supertraits(Baz)` yields `[Baz, Bar, Foo, Foo]` in some order.\n+     */\n+\n+    transitive_bounds(tcx, [trait_ref])\n+}\n+\n+pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n+                                    bounds: &[Rc<ty::TraitRef>])\n+                                    -> Supertraits<'cx, 'tcx>\n+{\n+    let bounds = Vec::from_fn(bounds.len(), |i| bounds[i].clone());\n+    let entry = SupertraitEntry { position: 0, supertraits: bounds };\n+    Supertraits { tcx: tcx, stack: vec![entry] }\n+}\n+\n+impl<'cx, 'tcx> Supertraits<'cx, 'tcx> {\n+    fn push(&mut self, trait_ref: &ty::TraitRef) {\n+        let bounds = ty::bounds_for_trait_ref(self.tcx, trait_ref);\n+        let entry = SupertraitEntry { position: 0,\n+                                      supertraits: bounds.trait_bounds };\n+        self.stack.push(entry);\n+    }\n+\n+    pub fn indices(&self) -> Vec<uint> {\n+        /*!\n+         * Returns the path taken through the trait supertraits to\n+         * reach the current point.\n+         */\n+\n+        self.stack.iter().map(|e| e.position).collect()\n+    }\n+}\n+\n+impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef>> for Supertraits<'cx, 'tcx> {\n+    fn next(&mut self) -> Option<Rc<ty::TraitRef>> {\n+        loop {\n+            // Extract next item from top-most stack frame, if any.\n+            let next_trait = match self.stack.mut_last() {\n+                None => {\n+                    // No more stack frames. Done.\n+                    return None;\n+                }\n+                Some(entry) => {\n+                    let p = entry.position;\n+                    if p < entry.supertraits.len() {\n+                        // Still more supertraits left in the top stack frame.\n+                        entry.position += 1;\n+\n+                        let next_trait =\n+                            (*entry.supertraits.get(p)).clone();\n+                        Some(next_trait)\n+                    } else {\n+                        None\n+                    }\n+                }\n+            };\n+\n+            match next_trait {\n+                Some(next_trait) => {\n+                    self.push(&*next_trait);\n+                    return Some(next_trait);\n+                }\n+\n+                None => {\n+                    // Top stack frame is exhausted, pop it.\n+                    self.stack.pop();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// determine the `self` type, using fresh variables for all variables\n+// declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n+// would return ($0, $1) where $0 and $1 are freshly instantiated type\n+// variables.\n+pub fn fresh_substs_for_impl(infcx: &InferCtxt,\n+                             span: Span,\n+                             impl_def_id: ast::DefId)\n+                             -> Substs\n+{\n+    let tcx = infcx.tcx;\n+    let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n+    infcx.fresh_substs_for_generics(span, &impl_generics)\n+}\n+\n+impl<N> fmt::Show for VtableImpl<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableImpl({})\", self.impl_def_id)\n+    }\n+}\n+\n+impl fmt::Show for VtableParam {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableParam(...)\")\n+    }\n+}\n+\n+pub fn obligations_for_generics(tcx: &ty::ctxt,\n+                                cause: ObligationCause,\n+                                recursion_depth: uint,\n+                                generics: &ty::Generics,\n+                                substs: &Substs)\n+                                -> VecPerParamSpace<Obligation>\n+{\n+    /*! See `super::obligations_for_generics` */\n+\n+    debug!(\"obligations_for_generics(generics={}, substs={})\",\n+           generics.repr(tcx), substs.repr(tcx));\n+\n+    let mut obligations = VecPerParamSpace::empty();\n+\n+    for def in generics.types.iter() {\n+        push_obligations_for_param_bounds(tcx,\n+                                          cause,\n+                                          recursion_depth,\n+                                          def.space,\n+                                          def.index,\n+                                          &def.bounds,\n+                                          substs,\n+                                          &mut obligations);\n+    }\n+\n+    debug!(\"obligations() ==> {}\", obligations.repr(tcx));\n+\n+    return obligations;\n+}\n+\n+fn push_obligations_for_param_bounds(\n+    tcx: &ty::ctxt,\n+    cause: ObligationCause,\n+    recursion_depth: uint,\n+    space: subst::ParamSpace,\n+    index: uint,\n+    param_bounds: &ty::ParamBounds,\n+    param_substs: &Substs,\n+    obligations: &mut VecPerParamSpace<Obligation>)\n+{\n+    let param_ty = *param_substs.types.get(space, index);\n+\n+    for builtin_bound in param_bounds.builtin_bounds.iter() {\n+        obligations.push(\n+            space,\n+            obligation_for_builtin_bound(tcx,\n+                                         cause,\n+                                         builtin_bound,\n+                                         recursion_depth,\n+                                         param_ty));\n+    }\n+\n+    for bound_trait_ref in param_bounds.trait_bounds.iter() {\n+        let bound_trait_ref = bound_trait_ref.subst(tcx, param_substs);\n+        obligations.push(\n+            space,\n+            Obligation { cause: cause,\n+                         recursion_depth: recursion_depth,\n+                         trait_ref: bound_trait_ref });\n+    }\n+}\n+\n+pub fn obligation_for_builtin_bound(\n+    tcx: &ty::ctxt,\n+    cause: ObligationCause,\n+    builtin_bound: ty::BuiltinBound,\n+    recursion_depth: uint,\n+    param_ty: ty::t)\n+    -> Obligation\n+{\n+    match tcx.lang_items.from_builtin_kind(builtin_bound) {\n+        Ok(def_id) => {\n+            Obligation {\n+                cause: cause,\n+                recursion_depth: recursion_depth,\n+                trait_ref: Rc::new(ty::TraitRef {\n+                    def_id: def_id,\n+                    substs: Substs::empty().with_self_ty(param_ty),\n+                }),\n+            }\n+        }\n+        Err(e) => {\n+            tcx.sess.span_bug(cause.span, e.as_slice());\n+        }\n+    }\n+}\n+\n+pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n+                                               caller_bound: Rc<ty::TraitRef>,\n+                                               test: |ast::DefId| -> bool)\n+                                               -> Option<VtableParam>\n+{\n+    /*!\n+     * Starting from a caller obligation `caller_bound` (which has\n+     * coordinates `space`/`i` in the list of caller obligations),\n+     * search through the trait and supertraits to find one where\n+     * `test(d)` is true, where `d` is the def-id of the\n+     * trait/supertrait.  If any is found, return `Some(p)` where `p`\n+     * is the path to that trait/supertrait. Else `None`.\n+     */\n+\n+    for (bound_index, bound) in\n+        transitive_bounds(tcx, &[caller_bound]).enumerate()\n+    {\n+        if test(bound.def_id) {\n+            let vtable_param = VtableParam { bound: bound };\n+            return Some(vtable_param);\n+        }\n+    }\n+\n+    return None;\n+}\n+\n+impl Repr for super::Obligation {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"Obligation(trait_ref={},depth={})\",\n+                self.trait_ref.repr(tcx),\n+                self.recursion_depth)\n+    }\n+}\n+\n+impl<N:Repr> Repr for super::Vtable<N> {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            super::VtableImpl(ref v) =>\n+                v.repr(tcx),\n+\n+            super::VtableUnboxedClosure(ref d) =>\n+                format!(\"VtableUnboxedClosure({})\",\n+                        d.repr(tcx)),\n+\n+            super::VtableParam(ref v) =>\n+                format!(\"VtableParam({})\", v.repr(tcx)),\n+\n+            super::VtableBuiltin =>\n+                format!(\"Builtin\"),\n+        }\n+    }\n+}\n+\n+impl<N:Repr> Repr for super::VtableImpl<N> {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"VtableImpl(impl_def_id={}, substs={}, nested={})\",\n+                self.impl_def_id.repr(tcx),\n+                self.substs.repr(tcx),\n+                self.nested.repr(tcx))\n+    }\n+}\n+\n+impl Repr for super::VtableParam {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"VtableParam(bound={})\",\n+                self.bound.repr(tcx))\n+    }\n+}\n+\n+impl Repr for super::SelectionError {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            super::Unimplemented =>\n+                format!(\"Unimplemented\"),\n+\n+            super::Overflow =>\n+                format!(\"Overflow\"),\n+\n+            super::OutputTypeParameterMismatch(ref t, ref e) =>\n+                format!(\"OutputTypeParameterMismatch({}, {})\",\n+                        t.repr(tcx),\n+                        e.repr(tcx)),\n+        }\n+    }\n+}\n+\n+impl Repr for super::FulfillmentError {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"FulfillmentError({},{})\",\n+                self.obligation.repr(tcx),\n+                self.code.repr(tcx))\n+    }\n+}\n+\n+impl Repr for super::FulfillmentErrorCode {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            super::SelectionError(ref o) => o.repr(tcx),\n+            super::Ambiguity => format!(\"Ambiguity\")\n+        }\n+    }\n+}\n+\n+impl fmt::Show for super::FulfillmentErrorCode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            super::SelectionError(ref e) => write!(f, \"{}\", e),\n+            super::Ambiguity => write!(f, \"Ambiguity\")\n+        }\n+    }\n+}\n+\n+impl Repr for ty::type_err {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        ty::type_err_to_str(tcx, self)\n+    }\n+}\n+"}, {"sha": "0716d8dbf27f42e88df54498347619b02c60bacc", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -75,7 +75,6 @@ use middle::trans::type_of;\n use middle::trans::type_of::*;\n use middle::trans::value::Value;\n use middle::ty;\n-use middle::typeck;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_string};\n use util::sha2::Sha256;\n@@ -540,8 +539,7 @@ pub fn get_res_dtor(ccx: &CrateContext,\n         // Since we're in trans we don't care for any region parameters\n         let ref substs = subst::Substs::erased(substs.types.clone());\n \n-        let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx(), did.node, substs);\n-        let (val, _) = monomorphize::monomorphic_fn(ccx, did, substs, vtables, None);\n+        let (val, _) = monomorphize::monomorphic_fn(ccx, did, substs, None);\n \n         val\n     } else if did.krate == ast::LOCAL_CRATE {"}, {"sha": "ef98a73430264e312169789f419174fdc6c04e5e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 29, "deletions": 82, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -25,7 +25,7 @@ use llvm;\n use metadata::csearch;\n use middle::def;\n use middle::subst;\n-use middle::subst::{Subst, VecPerParamSpace};\n+use middle::subst::{Subst};\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::base::*;\n@@ -47,7 +47,6 @@ use middle::trans::monomorphize;\n use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::ty;\n-use middle::typeck;\n use middle::typeck::coherence::make_substs_for_receiver_types;\n use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n@@ -227,61 +226,27 @@ pub fn trans_fn_ref(bcx: Block, def_id: ast::DefId, node: ExprOrMethodCall) -> V\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n     let substs = node_id_substs(bcx, node);\n-    let vtable_key = match node {\n-        ExprId(id) => MethodCall::expr(id),\n-        MethodCall(method_call) => method_call\n-    };\n-    let vtables = node_vtables(bcx, vtable_key);\n-    debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={}, vtables={})\",\n+    debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={})\",\n            def_id.repr(bcx.tcx()),\n            node,\n-           substs.repr(bcx.tcx()),\n-           vtables.repr(bcx.tcx()));\n-    trans_fn_ref_with_vtables(bcx, def_id, node, substs, vtables)\n+           substs.repr(bcx.tcx()));\n+    trans_fn_ref_with_substs(bcx, def_id, node, substs)\n }\n \n-fn trans_fn_ref_with_vtables_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                   def_id: ast::DefId,\n-                                                   ref_id: ast::NodeId,\n-                                                   substs: subst::Substs,\n-                                                   vtables: typeck::vtable_res)\n-                                                   -> Callee<'blk, 'tcx> {\n+fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                  def_id: ast::DefId,\n+                                                  ref_id: ast::NodeId,\n+                                                  substs: subst::Substs)\n+                                                  -> Callee<'blk, 'tcx> {\n     Callee {\n         bcx: bcx,\n-        data: Fn(trans_fn_ref_with_vtables(bcx,\n-                                           def_id,\n-                                           ExprId(ref_id),\n-                                           substs,\n-                                           vtables)),\n+        data: Fn(trans_fn_ref_with_substs(bcx,\n+                                          def_id,\n+                                          ExprId(ref_id),\n+                                          substs)),\n     }\n }\n \n-fn resolve_default_method_vtables(bcx: Block,\n-                                  impl_id: ast::DefId,\n-                                  substs: &subst::Substs,\n-                                  impl_vtables: typeck::vtable_res)\n-                                  -> typeck::vtable_res\n-{\n-    // Get the vtables that the impl implements the trait at\n-    let impl_res = ty::lookup_impl_vtables(bcx.tcx(), impl_id);\n-\n-    // Build up a param_substs that we are going to resolve the\n-    // trait_vtables under.\n-    let param_substs = param_substs {\n-        substs: (*substs).clone(),\n-        vtables: impl_vtables.clone()\n-    };\n-\n-    let mut param_vtables = resolve_vtables_under_param_substs(\n-        bcx.tcx(), &param_substs, &impl_res);\n-\n-    // Now we pull any vtables for parameters on the actual method.\n-    param_vtables.push_all(subst::FnSpace,\n-                           impl_vtables.get_slice(subst::FnSpace));\n-\n-    param_vtables\n-}\n-\n /// Translates the adapter that deconstructs a `Box<Trait>` object into\n /// `Trait` so that a by-value self method can be called.\n pub fn trans_unboxing_shim(bcx: Block,\n@@ -408,12 +373,11 @@ pub fn trans_unboxing_shim(bcx: Block,\n     llfn\n }\n \n-pub fn trans_fn_ref_with_vtables(\n+pub fn trans_fn_ref_with_substs(\n     bcx: Block,                  //\n     def_id: ast::DefId,          // def id of fn\n     node: ExprOrMethodCall,      // node id of use of fn; may be zero if N/A\n-    substs: subst::Substs,       // values for fn's ty params\n-    vtables: typeck::vtable_res) // vtables for the call\n+    substs: subst::Substs)       // vtables for the call\n     -> ValueRef\n {\n     /*!\n@@ -428,20 +392,18 @@ pub fn trans_fn_ref_with_vtables(\n      *   This parameter may be zero; but, if so, the resulting value may not\n      *   have the right type, so it must be cast before being used.\n      * - `substs`: values for each of the fn/method's parameters\n-     * - `vtables`: values for each bound on each of the type parameters\n      */\n \n-    let _icx = push_ctxt(\"trans_fn_ref_with_vtables\");\n+    let _icx = push_ctxt(\"trans_fn_ref_with_substs\");\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n \n-    debug!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, node={:?}, \\\n-            substs={}, vtables={})\",\n+    debug!(\"trans_fn_ref_with_substs(bcx={}, def_id={}, node={:?}, \\\n+            substs={})\",\n            bcx.to_str(),\n            def_id.repr(tcx),\n            node,\n-           substs.repr(tcx),\n-           vtables.repr(tcx));\n+           substs.repr(tcx));\n \n     assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n \n@@ -456,9 +418,8 @@ pub fn trans_fn_ref_with_vtables(\n     // We need to do a bunch of special handling for default methods.\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n-    let (is_default, def_id, substs, vtables) =\n-        match ty::provided_source(tcx, def_id) {\n-        None => (false, def_id, substs, vtables),\n+    let (is_default, def_id, substs) = match ty::provided_source(tcx, def_id) {\n+        None => (false, def_id, substs),\n         Some(source_id) => {\n             // There are two relevant substitutions when compiling\n             // default methods. First, there is the substitution for\n@@ -491,23 +452,11 @@ pub fn trans_fn_ref_with_vtables(\n \n                     debug!(\"trans_fn_with_vtables - default method: \\\n                             substs = {}, trait_subst = {}, \\\n-                            first_subst = {}, new_subst = {}, \\\n-                            vtables = {}\",\n+                            first_subst = {}, new_subst = {}\",\n                            substs.repr(tcx), trait_ref.substs.repr(tcx),\n-                           first_subst.repr(tcx), new_substs.repr(tcx),\n-                           vtables.repr(tcx));\n-\n-                    let param_vtables =\n-                        resolve_default_method_vtables(bcx,\n-                                                       impl_id,\n-                                                       &substs,\n-                                                       vtables);\n-\n-                    debug!(\"trans_fn_with_vtables - default method: \\\n-                            param_vtables = {}\",\n-                           param_vtables.repr(tcx));\n+                           first_subst.repr(tcx), new_substs.repr(tcx));\n \n-                    (true, source_id, new_substs, param_vtables)\n+                    (true, source_id, new_substs)\n                 }\n             }\n         }\n@@ -556,8 +505,7 @@ pub fn trans_fn_ref_with_vtables(\n         };\n \n         let (val, must_cast) =\n-            monomorphize::monomorphic_fn(ccx, def_id, &substs,\n-                                         vtables, opt_ref_id);\n+            monomorphize::monomorphic_fn(ccx, def_id, &substs, opt_ref_id);\n         let mut val = val;\n         if must_cast && node != ExprId(0) {\n             // Monotype of the REFERENCE to the function (type params\n@@ -678,11 +626,10 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              None,\n                              fty,\n                              |bcx, _| {\n-                                trans_fn_ref_with_vtables_to_callee(bcx,\n-                                                                    did,\n-                                                                    0,\n-                                                                    subst::Substs::empty(),\n-                                                                    VecPerParamSpace::empty())\n+                                trans_fn_ref_with_substs_to_callee(bcx,\n+                                                                   did,\n+                                                                   0,\n+                                                                   subst::Substs::empty())\n                              },\n                              ArgVals(args),\n                              dest)"}, {"sha": "60ae26439b4831ec9f1cbd519209af216ffe1359", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 100, "deletions": 88, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -29,8 +29,11 @@ use middle::trans::datum;\n use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n use middle::trans::type_of;\n+use middle::traits;\n use middle::ty;\n+use middle::ty_fold;\n use middle::typeck;\n+use middle::typeck::infer;\n use util::ppaux::Repr;\n use util::nodemap::{DefIdMap, NodeMap};\n \n@@ -39,6 +42,7 @@ use std::collections::HashMap;\n use libc::{c_uint, c_longlong, c_ulonglong, c_char};\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n+use std::rc::Rc;\n use std::vec::Vec;\n use syntax::ast::Ident;\n use syntax::ast;\n@@ -188,14 +192,12 @@ pub type ExternMap = HashMap<String, ValueRef>;\n // will only be set in the case of default methods.\n pub struct param_substs {\n     pub substs: subst::Substs,\n-    pub vtables: typeck::vtable_res,\n }\n \n impl param_substs {\n     pub fn empty() -> param_substs {\n         param_substs {\n             substs: subst::Substs::trans_empty(),\n-            vtables: subst::VecPerParamSpace::empty(),\n         }\n     }\n \n@@ -204,15 +206,9 @@ impl param_substs {\n     }\n }\n \n-fn param_substs_to_string(this: &param_substs, tcx: &ty::ctxt) -> String {\n-    format!(\"param_substs(substs={},vtables={})\",\n-            this.substs.repr(tcx),\n-            this.vtables.repr(tcx))\n-}\n-\n impl Repr for param_substs {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n-        param_substs_to_string(self, tcx)\n+        self.substs.repr(tcx)\n     }\n }\n \n@@ -766,6 +762,98 @@ pub fn expr_ty_adjusted(bcx: Block, ex: &ast::Expr) -> ty::t {\n     monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n }\n \n+pub fn fulfill_obligation(ccx: &CrateContext,\n+                          span: Span,\n+                          trait_ref: Rc<ty::TraitRef>)\n+                          -> traits::Vtable<()>\n+{\n+    /*!\n+     * Attempts to resolve an obligation. The result is a shallow\n+     * vtable resolution -- meaning that we do not (necessarily) resolve\n+     * all nested obligations on the impl. Note that type check should\n+     * guarantee to us that all nested obligations *could be* resolved\n+     * if we wanted to.\n+     */\n+\n+    let tcx = ccx.tcx();\n+\n+    // Remove any references to regions; this helps improve caching.\n+    let trait_ref = ty_fold::erase_regions(tcx, trait_ref);\n+\n+    // First check the cache.\n+    match ccx.trait_cache().borrow().find(&trait_ref) {\n+        Some(vtable) => {\n+            info!(\"Cache hit: {}\", trait_ref.repr(ccx.tcx()));\n+            return (*vtable).clone();\n+        }\n+        None => { }\n+    }\n+\n+    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id);\n+    let infcx = infer::new_infer_ctxt(tcx);\n+\n+    // Parameter environment is used to give details about type parameters,\n+    // but since we are in trans, everything is fully monomorphized.\n+    let param_env = ty::empty_parameter_environment();\n+    let unboxed_closures = tcx.unboxed_closures.borrow();\n+\n+    // Do the initial selection for the obligation. This yields the\n+    // shallow result we are looking for -- that is, what specific impl.\n+    let selcx = traits::SelectionContext::new(&infcx, &param_env,\n+                                              &*unboxed_closures);\n+    let obligation = traits::Obligation::misc(span, trait_ref.clone());\n+    let selection = match selcx.select(&obligation) {\n+        Ok(Some(selection)) => selection,\n+        Ok(None) => {\n+            tcx.sess.span_bug(\n+                span,\n+                format!(\"Encountered ambiguity selecting `{}` during trans\",\n+                        trait_ref.repr(tcx)).as_slice())\n+        }\n+        Err(e) => {\n+            tcx.sess.span_bug(\n+                span,\n+                format!(\"Encountered error `{}` selecting `{}` during trans\",\n+                        e.repr(tcx),\n+                        trait_ref.repr(tcx)).as_slice())\n+        }\n+    };\n+\n+    // Currently, we use a fulfillment context to completely resolve\n+    // all nested obligations. This is because they can inform the\n+    // inference of the impl's type parameters. However, in principle,\n+    // we only need to do this until the impl's type parameters are\n+    // fully bound. It could be a slight optimization to stop\n+    // iterating early.\n+    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let vtable = selection.map_move_nested(|obligation| {\n+        fulfill_cx.register_obligation(tcx, obligation);\n+    });\n+    match fulfill_cx.select_all_or_error(&infcx, &param_env, &*unboxed_closures) {\n+        Ok(()) => { }\n+        Err(e) => {\n+            tcx.sess.span_bug(\n+                span,\n+                format!(\"Encountered errors `{}` fulfilling `{}` during trans\",\n+                        e.repr(tcx),\n+                        trait_ref.repr(tcx)).as_slice());\n+        }\n+    }\n+\n+    // Use skolemize to simultaneously replace all type variables with\n+    // their bindings and replace all regions with 'static.  This is\n+    // sort of overkill because we do not expect there to be any\n+    // unbound type variables, hence no skolemized types should ever\n+    // be inserted.\n+    let vtable = infer::skolemize(&infcx, vtable);\n+\n+    info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n+    ccx.trait_cache().borrow_mut().insert(trait_ref,\n+                                          vtable.clone());\n+\n+    vtable\n+}\n+\n // Key used to lookup values supplied for type parameters in an expr.\n #[deriving(PartialEq)]\n pub enum ExprOrMethodCall {\n@@ -778,7 +866,8 @@ pub enum ExprOrMethodCall {\n \n pub fn node_id_substs(bcx: Block,\n                       node: ExprOrMethodCall)\n-                      -> subst::Substs {\n+                      -> subst::Substs\n+{\n     let tcx = bcx.tcx();\n \n     let substs = match node {\n@@ -798,87 +887,10 @@ pub fn node_id_substs(bcx: Block,\n                     substs.repr(bcx.tcx())).as_slice());\n     }\n \n+    let substs = substs.erase_regions();\n     substs.substp(tcx, bcx.fcx.param_substs)\n }\n \n-pub fn node_vtables(bcx: Block, id: typeck::MethodCall)\n-                 -> typeck::vtable_res {\n-    bcx.tcx().vtable_map.borrow().find(&id).map(|vts| {\n-        resolve_vtables_in_fn_ctxt(bcx.fcx, vts)\n-    }).unwrap_or_else(|| subst::VecPerParamSpace::empty())\n-}\n-\n-// Apply the typaram substitutions in the FunctionContext to some\n-// vtables. This should eliminate any vtable_params.\n-pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext,\n-                                  vts: &typeck::vtable_res)\n-                                  -> typeck::vtable_res {\n-    resolve_vtables_under_param_substs(fcx.ccx.tcx(),\n-                                       fcx.param_substs,\n-                                       vts)\n-}\n-\n-pub fn resolve_vtables_under_param_substs(tcx: &ty::ctxt,\n-                                          param_substs: &param_substs,\n-                                          vts: &typeck::vtable_res)\n-                                          -> typeck::vtable_res\n-{\n-    vts.map(|ds| {\n-        resolve_param_vtables_under_param_substs(tcx,\n-                                                 param_substs,\n-                                                 ds)\n-    })\n-}\n-\n-pub fn resolve_param_vtables_under_param_substs(tcx: &ty::ctxt,\n-                                                param_substs: &param_substs,\n-                                                ds: &typeck::vtable_param_res)\n-                                                -> typeck::vtable_param_res\n-{\n-    ds.iter().map(|d| {\n-        resolve_vtable_under_param_substs(tcx,\n-                                          param_substs,\n-                                          d)\n-    }).collect()\n-}\n-\n-\n-\n-pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n-                                         param_substs: &param_substs,\n-                                         vt: &typeck::vtable_origin)\n-                                         -> typeck::vtable_origin\n-{\n-    match *vt {\n-        typeck::vtable_static(trait_id, ref vtable_substs, ref sub) => {\n-            let vtable_substs = vtable_substs.substp(tcx, param_substs);\n-            typeck::vtable_static(\n-                trait_id,\n-                vtable_substs,\n-                resolve_vtables_under_param_substs(tcx, param_substs, sub))\n-        }\n-        typeck::vtable_param(n_param, n_bound) => {\n-            find_vtable(tcx, param_substs, n_param, n_bound)\n-        }\n-        typeck::vtable_unboxed_closure(def_id) => {\n-            typeck::vtable_unboxed_closure(def_id)\n-        }\n-        typeck::vtable_error => typeck::vtable_error\n-    }\n-}\n-\n-pub fn find_vtable(tcx: &ty::ctxt,\n-                   ps: &param_substs,\n-                   n_param: typeck::param_index,\n-                   n_bound: uint)\n-                   -> typeck::vtable_origin {\n-    debug!(\"find_vtable(n_param={:?}, n_bound={}, ps={})\",\n-           n_param, n_bound, ps.repr(tcx));\n-\n-    let param_bounds = ps.vtables.get(n_param.space, n_param.index);\n-    param_bounds.get(n_bound).clone()\n-}\n-\n pub fn langcall(bcx: Block,\n                 span: Option<Span>,\n                 msg: &str,"}, {"sha": "093849b47ad9833410b83e30ab1b99512abf5734", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -16,6 +16,7 @@ use llvm::{TargetData};\n use llvm::mk_target_data;\n use metadata::common::LinkMeta;\n use middle::resolve;\n+use middle::traits;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::builder::Builder;\n@@ -103,7 +104,7 @@ pub struct LocalCrateContext {\n     monomorphized: RefCell<HashMap<MonoId, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    vtables: RefCell<HashMap<(ty::t, MonoId), ValueRef>>,\n+    vtables: RefCell<HashMap<(ty::t,Rc<ty::TraitRef>), ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n \n@@ -150,6 +151,9 @@ pub struct LocalCrateContext {\n     /// This is used to perform some basic load-balancing to keep all LLVM\n     /// contexts around the same size.\n     n_llvm_insns: Cell<uint>,\n+\n+    trait_cache: RefCell<HashMap<Rc<ty::TraitRef>,\n+                                 traits::Vtable<()>>>,\n }\n \n pub struct CrateContext<'a, 'tcx: 'a> {\n@@ -426,6 +430,7 @@ impl LocalCrateContext {\n                 eh_personality: RefCell::new(None),\n                 intrinsics: RefCell::new(HashMap::new()),\n                 n_llvm_insns: Cell::new(0u),\n+                trait_cache: RefCell::new(HashMap::new()),\n             };\n \n             local_ccx.int_type = Type::int(&local_ccx.dummy_ccx(shared));\n@@ -617,7 +622,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.monomorphizing\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<HashMap<(ty::t, MonoId), ValueRef>> {\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<HashMap<(ty::t,Rc<ty::TraitRef>), ValueRef>> {\n         &self.local.vtables\n     }\n \n@@ -713,6 +718,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn count_llvm_insn(&self) {\n         self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n     }\n+\n+    pub fn trait_cache(&self) -> &RefCell<HashMap<Rc<ty::TraitRef>, traits::Vtable<()>>> {\n+        &self.local.trait_cache\n+    }\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {"}, {"sha": "af57d49d9d81568dd3834832a2bb075cb9ebebf0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -41,6 +41,7 @@ use middle::def;\n use middle::lang_items::MallocFnLangItem;\n use middle::mem_categorization::Typer;\n use middle::subst;\n+use middle::subst::Subst;\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::asm;\n@@ -78,6 +79,7 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::print::pprust::{expr_to_string};\n use syntax::ptr::P;\n+use std::rc::Rc;\n \n // Destinations\n \n@@ -319,10 +321,18 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 _ => bcx.sess().bug(format!(\"UnsizeStruct with bad sty: {}\",\n                                           bcx.ty_to_string(unsized_ty)).as_slice())\n             },\n-            &ty::UnsizeVtable(..) =>\n+            &ty::UnsizeVtable(ty::TyTrait { def_id: def_id, substs: ref substs, .. }, _) => {\n+                let substs = substs.with_self_ty(unsized_ty);\n+                let trait_ref =\n+                    Rc::new(ty::TraitRef { def_id: def_id,\n+                                           substs: substs });\n+                let trait_ref =\n+                    trait_ref.subst(bcx.tcx(), &bcx.fcx.param_substs.substs);\n+                let box_ty = mk_ty(unsized_ty);\n                 PointerCast(bcx,\n-                            meth::vtable_ptr(bcx, id, mk_ty(unsized_ty)),\n+                            meth::get_vtable(bcx, box_ty, trait_ref),\n                             Type::vtable_ptr(bcx.ccx()))\n+            }\n         }\n     }\n \n@@ -1052,8 +1062,16 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprCast(ref val, _) => {\n             // DPS output mode means this is a trait cast:\n             if ty::type_is_trait(node_id_type(bcx, expr.id)) {\n+                let trait_ref =\n+                    bcx.tcx().object_cast_map.borrow()\n+                                             .find(&expr.id)\n+                                             .map(|t| (*t).clone())\n+                                             .unwrap();\n+                let trait_ref =\n+                    trait_ref.subst(bcx.tcx(), &bcx.fcx.param_substs.substs);\n                 let datum = unpack_datum!(bcx, trans(bcx, &**val));\n-                meth::trans_trait_cast(bcx, datum, expr.id, dest)\n+                meth::trans_trait_cast(bcx, datum, expr.id,\n+                                       trait_ref, dest)\n             } else {\n                 bcx.tcx().sess.span_bug(expr.span,\n                                         \"expr_cast of non-trait\");"}, {"sha": "a87557a26cc67b2272b3f157f25f1524662b4c40", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 199, "deletions": 168, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -13,8 +13,10 @@ use back::abi;\n use llvm;\n use llvm::ValueRef;\n use metadata::csearch;\n+use middle::subst::{Subst,Substs};\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n+use middle::traits;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee::*;\n@@ -26,20 +28,20 @@ use middle::trans::expr::{SaveIn, Ignore};\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::machine;\n-use middle::trans::monomorphize;\n use middle::trans::type_::Type;\n use middle::trans::type_of::*;\n use middle::ty;\n use middle::typeck;\n use middle::typeck::MethodCall;\n-use util::common::indenter;\n use util::ppaux::Repr;\n \n use std::c_str::ToCStr;\n+use std::rc::Rc;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n use syntax::{ast, ast_map, attr, visit};\n use syntax::ast_util::PostExpansionMethod;\n+use syntax::codemap::DUMMY_SP;\n \n // drop_glue pointer, size, align.\n static VTABLE_OFFSET: uint = 3;\n@@ -109,18 +111,12 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                        -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n-    let (origin, method_ty) = match bcx.tcx().method_map\n-                                       .borrow().find(&method_call) {\n-        Some(method) => {\n-            debug!(\"trans_method_callee({:?}, method={})\",\n-                   method_call, method.repr(bcx.tcx()));\n-            (method.origin, method.ty)\n-        }\n-        None => {\n-            bcx.sess().span_bug(bcx.tcx().map.span(method_call.expr_id),\n-                                \"method call expr wasn't in method map\")\n-        }\n-    };\n+    let (origin, method_ty) =\n+        bcx.tcx().method_map\n+                 .borrow()\n+                 .find(&method_call)\n+                 .map(|method| (method.origin.clone(), method.ty))\n+                 .unwrap();\n \n     match origin {\n         typeck::MethodStatic(did) |\n@@ -132,19 +128,21 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                               MethodCall(method_call))),\n             }\n         }\n+\n         typeck::MethodParam(typeck::MethodParam {\n-            trait_id: trait_id,\n-            method_num: off,\n-            param_num: p,\n-            bound_num: b\n+            trait_ref: ref trait_ref,\n+            method_num: method_num\n         }) => {\n-            ty::populate_implementations_for_trait_if_necessary(\n-                bcx.tcx(),\n-                trait_id);\n-\n-            let vtbl = find_vtable(bcx.tcx(), bcx.fcx.param_substs, p, b);\n-            trans_monomorphized_callee(bcx, method_call,\n-                                       trait_id, off, vtbl)\n+            let trait_ref =\n+                Rc::new(trait_ref.subst(bcx.tcx(),\n+                                        &bcx.fcx.param_substs.substs));\n+            let span = bcx.tcx().map.span(method_call.expr_id);\n+            let origin = fulfill_obligation(bcx.ccx(),\n+                                            span,\n+                                            (*trait_ref).clone());\n+            debug!(\"origin = {}\", origin.repr(bcx.tcx()));\n+            trans_monomorphized_callee(bcx, method_call, trait_ref.def_id,\n+                                       method_num, origin)\n         }\n \n         typeck::MethodObject(ref mt) => {\n@@ -169,7 +167,8 @@ pub fn trans_static_method_callee(bcx: Block,\n                                   method_id: ast::DefId,\n                                   trait_id: ast::DefId,\n                                   expr_id: ast::NodeId)\n-                                  -> ValueRef {\n+                                  -> ValueRef\n+{\n     let _icx = push_ctxt(\"meth::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n@@ -178,9 +177,6 @@ pub fn trans_static_method_callee(bcx: Block,\n            method_id,\n            ty::item_path_str(bcx.tcx(), trait_id),\n            expr_id);\n-    let _indenter = indenter();\n-\n-    ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trait_id);\n \n     let mname = if method_id.krate == ast::LOCAL_CRATE {\n         match bcx.tcx().map.get(method_id.node) {\n@@ -196,38 +192,91 @@ pub fn trans_static_method_callee(bcx: Block,\n     } else {\n         csearch::get_item_path(bcx.tcx(), method_id).last().unwrap().name()\n     };\n-    debug!(\"trans_static_method_callee: method_id={:?}, expr_id={:?}, \\\n+    debug!(\"trans_static_method_callee: method_id={}, expr_id={}, \\\n             name={}\", method_id, expr_id, token::get_name(mname));\n \n-    let vtable_key = MethodCall::expr(expr_id);\n-    let vtbls = resolve_vtables_in_fn_ctxt(\n-        bcx.fcx,\n-        ccx.tcx().vtable_map.borrow().get(&vtable_key));\n-\n-    match *vtbls.get_self().unwrap().get(0) {\n-        typeck::vtable_static(impl_did, ref rcvr_substs, ref rcvr_origins) => {\n-            assert!(rcvr_substs.types.all(|t| !ty::type_needs_infer(*t)));\n+    // Find the substitutions for the fn itself. This includes\n+    // type parameters that belong to the trait but also some that\n+    // belong to the method:\n+    let rcvr_substs = node_id_substs(bcx, ExprId(expr_id));\n+    let (rcvr_type, rcvr_self, rcvr_method) = rcvr_substs.types.split();\n+\n+    // Lookup the precise impl being called. To do that, we need to\n+    // create a trait reference identifying the self type and other\n+    // input type parameters. To create that trait reference, we have\n+    // to pick apart the type parameters to identify just those that\n+    // pertain to the trait. This is easiest to explain by example:\n+    //\n+    //     trait Convert {\n+    //         fn from<U:Foo>(n: U) -> Option<Self>;\n+    //     }\n+    //     ...\n+    //     let f = <Vec<int> as Convert>::from::<String>(...)\n+    //\n+    // Here, in this call, which I've written with explicit UFCS\n+    // notation, the set of type parameters will be:\n+    //\n+    //     rcvr_type: [] <-- nothing declared on the trait itself\n+    //     rcvr_self: [Vec<int>] <-- the self type\n+    //     rcvr_method: [String] <-- method type parameter\n+    //\n+    // So we create a trait reference using the first two,\n+    // basically corresponding to `<Vec<int> as Convert>`.\n+    // The remaining type parameters (`rcvr_method`) will be used below.\n+    let trait_substs =\n+        Substs::erased(VecPerParamSpace::new(rcvr_type,\n+                                             rcvr_self,\n+                                             Vec::new()));\n+    debug!(\"trait_substs={}\", trait_substs.repr(bcx.tcx()));\n+    let trait_ref = Rc::new(ty::TraitRef { def_id: trait_id,\n+                                           substs: trait_substs });\n+    let vtbl = fulfill_obligation(bcx.ccx(),\n+                                  DUMMY_SP,\n+                                  trait_ref);\n+\n+    // Now that we know which impl is being used, we can dispatch to\n+    // the actual function:\n+    match vtbl {\n+        traits::VtableImpl(traits::VtableImpl {\n+            impl_def_id: impl_did,\n+            substs: impl_substs,\n+            nested: _ }) =>\n+        {\n+            assert!(impl_substs.types.all(|t| !ty::type_needs_infer(*t)));\n+\n+            // Create the substitutions that are in scope. This combines\n+            // the type parameters from the impl with those declared earlier.\n+            // To see what I mean, consider a possible impl:\n+            //\n+            //    impl<T> Convert for Vec<T> {\n+            //        fn from<U:Foo>(n: U) { ... }\n+            //    }\n+            //\n+            // Recall that we matched `<Vec<int> as Convert>`. Trait\n+            // resolution will have given us a substitution\n+            // containing `impl_substs=[[T=int],[],[]]` (the type\n+            // parameters defined on the impl). We combine\n+            // that with the `rcvr_method` from before, which tells us\n+            // the type parameters from the *method*, to yield\n+            // `callee_substs=[[T=int],[],[U=String]]`.\n+            let (impl_type, impl_self, _) = impl_substs.types.split();\n+            let callee_substs =\n+                Substs::erased(VecPerParamSpace::new(impl_type,\n+                                                     impl_self,\n+                                                     rcvr_method));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n-            let (callee_substs, callee_origins) =\n-                combine_impl_and_methods_tps(\n-                    bcx, ExprId(expr_id),\n-                    (*rcvr_substs).clone(), (*rcvr_origins).clone());\n-\n-            let llfn = trans_fn_ref_with_vtables(bcx, mth_id, ExprId(expr_id),\n-                                                 callee_substs,\n-                                                 callee_origins);\n+            let llfn = trans_fn_ref_with_substs(bcx, mth_id, ExprId(expr_id),\n+                                                callee_substs);\n \n             let callee_ty = node_id_type(bcx, expr_id);\n             let llty = type_of_fn_from_ty(ccx, callee_ty).ptr_to();\n             PointerCast(bcx, llfn, llty)\n         }\n-        typeck::vtable_unboxed_closure(_) => {\n-            bcx.tcx().sess.bug(\"can't call a closure vtable in a static way\");\n-        }\n         _ => {\n-            fail!(\"vtable_param left in monomorphized \\\n-                   function's vtable substs\");\n+            bcx.tcx().sess.bug(\n+                format!(\"static call to invalid vtable: {}\",\n+                        vtbl.repr(bcx.tcx())).as_slice());\n         }\n     }\n }\n@@ -265,33 +314,33 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           method_call: MethodCall,\n                                           trait_id: ast::DefId,\n                                           n_method: uint,\n-                                          vtbl: typeck::vtable_origin)\n+                                          vtable: traits::Vtable<()>)\n                                           -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n-    match vtbl {\n-      typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n-          let ccx = bcx.ccx();\n-          let mname = match ty::trait_item(ccx.tcx(), trait_id, n_method) {\n-              ty::MethodTraitItem(method) => method.ident,\n-          };\n-          let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n-\n-          // create a concatenated set of substitutions which includes\n-          // those from the impl and those from the method:\n-          let (callee_substs, callee_origins) =\n-              combine_impl_and_methods_tps(\n-                  bcx, MethodCall(method_call), rcvr_substs, rcvr_origins);\n-\n-          // translate the function\n-          let llfn = trans_fn_ref_with_vtables(bcx,\n-                                               mth_id,\n-                                               MethodCall(method_call),\n-                                               callee_substs,\n-                                               callee_origins);\n-\n-          Callee { bcx: bcx, data: Fn(llfn) }\n-      }\n-      typeck::vtable_unboxed_closure(closure_def_id) => {\n+    match vtable {\n+        traits::VtableImpl(vtable_impl) => {\n+            let ccx = bcx.ccx();\n+            let impl_did = vtable_impl.impl_def_id;\n+            let mname = match ty::trait_item(ccx.tcx(), trait_id, n_method) {\n+                ty::MethodTraitItem(method) => method.ident,\n+            };\n+            let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n+\n+            // create a concatenated set of substitutions which includes\n+            // those from the impl and those from the method:\n+            let callee_substs =\n+                combine_impl_and_methods_tps(\n+                    bcx, MethodCall(method_call), vtable_impl.substs);\n+\n+            // translate the function\n+            let llfn = trans_fn_ref_with_substs(bcx,\n+                                                mth_id,\n+                                                MethodCall(method_call),\n+                                                callee_substs);\n+\n+            Callee { bcx: bcx, data: Fn(llfn) }\n+        }\n+        traits::VtableUnboxedClosure(closure_def_id) => {\n           // The static region and type parameters are lies, but we're in\n           // trans so it doesn't matter.\n           //\n@@ -300,33 +349,27 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx,\n                 closure_def_id);\n \n-          let llfn = trans_fn_ref_with_vtables(bcx,\n-                                               closure_def_id,\n-                                               MethodCall(method_call),\n-                                               callee_substs,\n-                                               VecPerParamSpace::empty());\n-\n-          Callee {\n-              bcx: bcx,\n-              data: Fn(llfn),\n-          }\n-      }\n-      typeck::vtable_param(..) => {\n-          bcx.tcx().sess.bug(\n-              \"vtable_param left in monomorphized function's vtable substs\");\n-      }\n-      typeck::vtable_error => {\n-          bcx.tcx().sess.bug(\n-              \"vtable_error left in monomorphized function's vtable substs\");\n-      }\n+            let llfn = trans_fn_ref_with_substs(bcx,\n+                                                closure_def_id,\n+                                                MethodCall(method_call),\n+                                                callee_substs);\n+\n+            Callee {\n+                bcx: bcx,\n+                data: Fn(llfn),\n+            }\n+        }\n+        _ => {\n+            bcx.tcx().sess.bug(\n+                \"vtable_param left in monomorphized function's vtable substs\");\n+        }\n     }\n }\n \n fn combine_impl_and_methods_tps(bcx: Block,\n                                 node: ExprOrMethodCall,\n-                                rcvr_substs: subst::Substs,\n-                                rcvr_origins: typeck::vtable_res)\n-                                -> (subst::Substs, typeck::vtable_res)\n+                                rcvr_substs: subst::Substs)\n+                                -> subst::Substs\n {\n     /*!\n      * Creates a concatenated set of substitutions which includes\n@@ -347,33 +390,20 @@ fn combine_impl_and_methods_tps(bcx: Block,\n \n     let ccx = bcx.ccx();\n \n-    let vtable_key = match node {\n-        ExprId(id) => MethodCall::expr(id),\n-        MethodCall(method_call) => method_call\n-    };\n     let node_substs = node_id_substs(bcx, node);\n-    let node_vtables = node_vtables(bcx, vtable_key);\n \n-    debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx()));\n-    debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx()));\n+    debug!(\"rcvr_substs={}\", rcvr_substs.repr(ccx.tcx()));\n+    debug!(\"node_substs={}\", node_substs.repr(ccx.tcx()));\n \n     // Break apart the type parameters from the node and type\n     // parameters from the receiver.\n     let (_, _, node_method) = node_substs.types.split();\n     let (rcvr_type, rcvr_self, rcvr_method) = rcvr_substs.types.clone().split();\n     assert!(rcvr_method.is_empty());\n-    let ty_substs = subst::Substs {\n+    subst::Substs {\n         regions: subst::ErasedRegions,\n         types: subst::VecPerParamSpace::new(rcvr_type, rcvr_self, node_method)\n-    };\n-\n-    // Now do the same work for the vtables.\n-    let (rcvr_type, rcvr_self, rcvr_method) = rcvr_origins.split();\n-    let (_, _, node_method) = node_vtables.split();\n-    assert!(rcvr_method.is_empty());\n-    let vtables = subst::VecPerParamSpace::new(rcvr_type, rcvr_self, node_method);\n-\n-    (ty_substs, vtables)\n+    }\n }\n \n fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -493,43 +523,56 @@ fn get_callee_substitutions_for_unboxed_closure(bcx: Block,\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n-fn get_vtable(bcx: Block,\n-              self_ty: ty::t,\n-              origins: typeck::vtable_param_res)\n-              -> ValueRef\n+///\n+/// The `trait_ref` encodes the erased self type. Hence if we are\n+/// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n+/// `trait_ref` would map `T:Trait`, but `box_ty` would be\n+/// `Foo<T>`. This `box_ty` is primarily used to encode the destructor.\n+/// This will hopefully change now that DST is underway.\n+pub fn get_vtable(bcx: Block,\n+                  box_ty: ty::t,\n+                  trait_ref: Rc<ty::TraitRef>)\n+                  -> ValueRef\n {\n-    debug!(\"get_vtable(self_ty={}, origins={})\",\n-           self_ty.repr(bcx.tcx()),\n-           origins.repr(bcx.tcx()));\n+    debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n+           box_ty.repr(bcx.tcx()),\n+           trait_ref.repr(bcx.tcx()));\n \n+    let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n     // Check the cache.\n-    let hash_id = (self_ty, monomorphize::make_vtable_id(ccx, origins.get(0)));\n-    match ccx.vtables().borrow().find(&hash_id) {\n+    let cache_key = (box_ty, trait_ref.clone());\n+    match ccx.vtables().borrow().find(&cache_key) {\n         Some(&val) => { return val }\n         None => { }\n     }\n \n-    // Not in the cache. Actually build it.\n-    let methods = origins.move_iter().flat_map(|origin| {\n-        match origin {\n-            typeck::vtable_static(id, substs, sub_vtables) => {\n-                emit_vtable_methods(bcx, id, substs, sub_vtables).move_iter()\n+    // Not in the cache. Build it.\n+    let methods = traits::supertraits(tcx, trait_ref.clone()).flat_map(|trait_ref| {\n+        let vtable = fulfill_obligation(bcx.ccx(),\n+                                        DUMMY_SP,\n+                                        trait_ref.clone());\n+        match vtable {\n+            traits::VtableImpl(\n+                traits::VtableImpl {\n+                    impl_def_id: id,\n+                    substs: substs,\n+                    nested: _ }) => {\n+                emit_vtable_methods(bcx, id, substs).move_iter()\n             }\n-            typeck::vtable_unboxed_closure(closure_def_id) => {\n+            traits::VtableUnboxedClosure(closure_def_id) => {\n                 let callee_substs =\n                     get_callee_substitutions_for_unboxed_closure(\n                         bcx,\n                         closure_def_id);\n \n-                let mut llfn = trans_fn_ref_with_vtables(\n+                let mut llfn = trans_fn_ref_with_substs(\n                     bcx,\n                     closure_def_id,\n                     ExprId(0),\n-                    callee_substs.clone(),\n-                    VecPerParamSpace::empty());\n+                    callee_substs.clone());\n \n                 {\n                     let unboxed_closures = bcx.tcx()\n@@ -585,21 +628,27 @@ fn get_vtable(bcx: Block,\n \n                 (vec!(llfn)).move_iter()\n             }\n-            _ => ccx.sess().bug(\"get_vtable: expected a static origin\"),\n+            traits::VtableBuiltin |\n+            traits::VtableParam(..) => {\n+                bcx.sess().bug(\n+                    format!(\"resolved vtable for {} to bad vtable {} in trans\",\n+                            trait_ref.repr(bcx.tcx()),\n+                            vtable.repr(bcx.tcx())).as_slice());\n+            }\n         }\n     });\n \n-    let size_ty = sizing_type_of(ccx, self_ty);\n+    let size_ty = sizing_type_of(ccx, trait_ref.self_ty());\n     let size = machine::llsize_of_alloc(ccx, size_ty);\n     let ll_size = C_uint(ccx, size as uint);\n-    let align = align_of(ccx, self_ty);\n+    let align = align_of(ccx, trait_ref.self_ty());\n     let ll_align = C_uint(ccx, align as uint);\n \n     // Generate a destructor for the vtable.\n-    let drop_glue = glue::get_drop_glue(ccx, self_ty);\n+    let drop_glue = glue::get_drop_glue(ccx, box_ty);\n     let vtable = make_vtable(ccx, drop_glue, ll_size, ll_align, methods);\n \n-    ccx.vtables().borrow_mut().insert(hash_id, vtable);\n+    ccx.vtables().borrow_mut().insert(cache_key, vtable);\n     vtable\n }\n \n@@ -630,8 +679,7 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n \n fn emit_vtable_methods(bcx: Block,\n                        impl_id: ast::DefId,\n-                       substs: subst::Substs,\n-                       vtables: typeck::vtable_res)\n+                       substs: subst::Substs)\n                        -> Vec<ValueRef> {\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx();\n@@ -664,12 +712,11 @@ fn emit_vtable_methods(bcx: Block,\n                            token::get_ident(ident));\n                     C_null(Type::nil(ccx).ptr_to())\n                 } else {\n-                    let mut fn_ref = trans_fn_ref_with_vtables(\n+                    let mut fn_ref = trans_fn_ref_with_substs(\n                         bcx,\n                         m_id,\n                         ExprId(0),\n-                        substs.clone(),\n-                        vtables.clone());\n+                        substs.clone());\n                     if m.explicit_self == ty::ByValueExplicitSelfCategory {\n                         fn_ref = trans_unboxing_shim(bcx,\n                                                      fn_ref,\n@@ -684,29 +731,10 @@ fn emit_vtable_methods(bcx: Block,\n     }).collect()\n }\n \n-pub fn vtable_ptr(bcx: Block,\n-                  id: ast::NodeId,\n-                  self_ty: ty::t) -> ValueRef {\n-    let ccx = bcx.ccx();\n-    let origins = {\n-        let vtable_map = ccx.tcx().vtable_map.borrow();\n-        // This trait cast might be because of implicit coercion\n-        let adjs = ccx.tcx().adjustments.borrow();\n-        let adjust = adjs.find(&id);\n-        let method_call = if adjust.is_some() && ty::adjust_is_object(adjust.unwrap()) {\n-            MethodCall::autoobject(id)\n-        } else {\n-            MethodCall::expr(id)\n-        };\n-        let vres = vtable_map.get(&method_call).get_self().unwrap();\n-        resolve_param_vtables_under_param_substs(ccx.tcx(), bcx.fcx.param_substs, vres)\n-    };\n-    get_vtable(bcx, self_ty, origins)\n-}\n-\n pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     datum: Datum<Expr>,\n                                     id: ast::NodeId,\n+                                    trait_ref: Rc<ty::TraitRef>,\n                                     dest: expr::Dest)\n                                     -> Block<'blk, 'tcx> {\n     /*!\n@@ -717,25 +745,28 @@ pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n      */\n \n     let mut bcx = bcx;\n-    let _icx = push_ctxt(\"meth::trans_cast\");\n+    let _icx = push_ctxt(\"meth::trans_trait_cast\");\n \n     let lldest = match dest {\n         Ignore => {\n-            return datum.clean(bcx, \"trait_cast\", id);\n+            return datum.clean(bcx, \"trait_trait_cast\", id);\n         }\n         SaveIn(dest) => dest\n     };\n \n-    let v_ty = datum.ty;\n-    let llbox_ty = type_of(bcx.ccx(), v_ty);\n+    debug!(\"trans_trait_cast: trait_ref={}\",\n+           trait_ref.repr(bcx.tcx()));\n+\n+    let datum_ty = datum.ty;\n+    let llbox_ty = type_of(bcx.ccx(), datum_ty);\n \n     // Store the pointer into the first half of pair.\n     let llboxdest = GEPi(bcx, lldest, [0u, abi::trt_field_box]);\n     let llboxdest = PointerCast(bcx, llboxdest, llbox_ty.ptr_to());\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n-    let vtable = vtable_ptr(bcx, id, v_ty);\n+    let vtable = get_vtable(bcx, datum_ty, trait_ref);\n     let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());\n     Store(bcx, vtable, llvtabledest);"}, {"sha": "00e9d9f0e39b6af8750a321d1cbbc4ef798f25c8", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -34,17 +34,14 @@ use std::hash::{sip, Hash};\n pub fn monomorphic_fn(ccx: &CrateContext,\n                       fn_id: ast::DefId,\n                       real_substs: &subst::Substs,\n-                      vtables: typeck::vtable_res,\n                       ref_id: Option<ast::NodeId>)\n     -> (ValueRef, bool) {\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             real_substs={}, \\\n-            vtables={}, \\\n             ref_id={:?})\",\n            fn_id.repr(ccx.tcx()),\n            real_substs.repr(ccx.tcx()),\n-           vtables.repr(ccx.tcx()),\n            ref_id);\n \n     assert!(real_substs.types.all(|t| {\n@@ -69,7 +66,6 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     let psubsts = param_substs {\n         substs: (*real_substs).clone(),\n-        vtables: vtables,\n     };\n \n     debug!(\"monomorphic_fn(\\\n@@ -286,7 +282,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     (lldecl, true)\n }\n \n-// Used to identify cached monomorphized functions and vtables\n+// Used to identify cached monomorphized functions\n #[deriving(PartialEq, Eq, Hash)]\n pub struct MonoParamId {\n     pub subst: ty::t,"}, {"sha": "d0b94cb3abb8b12f8500b247dbdd3639e20a6bc9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 122, "deletions": 82, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -28,6 +28,7 @@ use middle::resolve_lifetime;\n use middle::stability;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::subst;\n+use middle::traits;\n use middle::ty;\n use middle::typeck;\n use middle::ty_fold;\n@@ -272,9 +273,7 @@ pub enum UnsizeKind {\n     // An unsize coercion applied to the tail field of a struct.\n     // The uint is the index of the type parameter which is unsized.\n     UnsizeStruct(Box<UnsizeKind>, uint),\n-    UnsizeVtable(ty::ExistentialBounds,\n-                 ast::DefId, /* Trait ID */\n-                 subst::Substs /* Trait substitutions */)\n+    UnsizeVtable(TyTrait, /* the self type of the trait */ ty::t)\n }\n \n #[deriving(Clone)]\n@@ -365,13 +364,13 @@ pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<t> {\n     fn type_of_autoref(cx: &ctxt, autoref: &AutoRef) -> Option<t> {\n         match autoref {\n             &AutoUnsize(ref k) => match k {\n-                &UnsizeVtable(bounds, def_id, ref substs) => {\n+                &UnsizeVtable(TyTrait { def_id, substs: ref substs, bounds }, _) => {\n                     Some(mk_trait(cx, def_id, substs.clone(), bounds))\n                 }\n                 _ => None\n             },\n             &AutoUnsizeUniq(ref k) => match k {\n-                &UnsizeVtable(bounds, def_id, ref substs) => {\n+                &UnsizeVtable(TyTrait { def_id, substs: ref substs, bounds }, _) => {\n                     Some(mk_uniq(cx, mk_trait(cx, def_id, substs.clone(), bounds)))\n                 }\n                 _ => None\n@@ -458,6 +457,10 @@ pub struct ctxt<'tcx> {\n     pub trait_refs: RefCell<NodeMap<Rc<TraitRef>>>,\n     pub trait_defs: RefCell<DefIdMap<Rc<TraitDef>>>,\n \n+    /// Maps from node-id of a trait object cast (like `foo as\n+    /// Box<Trait>`) to the trait reference.\n+    pub object_cast_map: typeck::ObjectCastMap,\n+\n     pub map: ast_map::Map<'tcx>,\n     pub intrinsic_defs: RefCell<DefIdMap<t>>,\n     pub freevars: RefCell<freevars::freevar_map>,\n@@ -499,7 +502,7 @@ pub struct ctxt<'tcx> {\n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    pub inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n+    pub inherent_impls: RefCell<DefIdMap<Rc<Vec<ast::DefId>>>>,\n \n     /// Maps a DefId of an impl to a list of its items.\n     /// Note that this contains all of the impls that we know about,\n@@ -516,9 +519,6 @@ pub struct ctxt<'tcx> {\n     /// about.\n     pub used_mut_nodes: RefCell<NodeSet>,\n \n-    /// vtable resolution information for impl declarations\n-    pub impl_vtables: typeck::impl_vtable_map,\n-\n     /// The set of external nominal types whose implementations have been read.\n     /// This is used for lazy resolution of methods.\n     pub populated_external_types: RefCell<DefIdSet>,\n@@ -536,7 +536,6 @@ pub struct ctxt<'tcx> {\n     pub extern_const_variants: RefCell<DefIdMap<ast::NodeId>>,\n \n     pub method_map: typeck::MethodMap,\n-    pub vtable_map: typeck::vtable_map,\n \n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n \n@@ -1089,7 +1088,13 @@ pub struct RegionVid {\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n-    FloatVar(FloatVid)\n+    FloatVar(FloatVid),\n+    SkolemizedTy(uint),\n+\n+    // FIXME -- once integral fallback is impl'd, we should remove\n+    // this type. It's only needed to prevent spurious errors for\n+    // integers whose type winds up never being constrained.\n+    SkolemizedIntTy(uint),\n }\n \n #[deriving(Clone, Encodable, Decodable, Eq, Hash, Show)]\n@@ -1152,6 +1157,8 @@ impl fmt::Show for InferTy {\n             TyVar(ref v) => v.fmt(f),\n             IntVar(ref v) => v.fmt(f),\n             FloatVar(ref v) => v.fmt(f),\n+            SkolemizedTy(v) => write!(f, \"SkolemizedTy({})\", v),\n+            SkolemizedIntTy(v) => write!(f, \"SkolemizedIntTy({})\", v),\n         }\n     }\n }\n@@ -1207,6 +1214,12 @@ impl Generics {\n     }\n }\n \n+impl TraitRef {\n+    pub fn self_ty(&self) -> ty::t {\n+        self.substs.self_ty().unwrap()\n+    }\n+}\n+\n /// When type checking, we use the `ParameterEnvironment` to track\n /// details about the type/lifetime parameters that are in scope.\n /// It primarily stores the bounds information.\n@@ -1235,6 +1248,14 @@ pub struct ParameterEnvironment {\n     /// may specify stronger requirements). This field indicates the\n     /// region of the callee.\n     pub implicit_region_bound: ty::Region,\n+\n+    /// Obligations that the caller must satisfy. This is basically\n+    /// the set of bounds on the in-scope type parameters, translated\n+    /// into Obligations.\n+    ///\n+    /// Note: This effectively *duplicates* the `bounds` array for\n+    /// now.\n+    pub caller_obligations: VecPerParamSpace<traits::Obligation>,\n }\n \n impl ParameterEnvironment {\n@@ -1249,6 +1270,7 @@ impl ParameterEnvironment {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n+                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -1272,6 +1294,7 @@ impl ParameterEnvironment {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n+                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -1287,6 +1310,7 @@ impl ParameterEnvironment {\n                         let fn_pty = ty::lookup_item_type(cx, fn_def_id);\n \n                         construct_parameter_environment(cx,\n+                                                        item.span,\n                                                         &fn_pty.generics,\n                                                         body.id)\n                     }\n@@ -1296,7 +1320,8 @@ impl ParameterEnvironment {\n                     ast::ItemStatic(..) => {\n                         let def_id = ast_util::local_def(id);\n                         let pty = ty::lookup_item_type(cx, def_id);\n-                        construct_parameter_environment(cx, &pty.generics, id)\n+                        construct_parameter_environment(cx, item.span,\n+                                                        &pty.generics, id)\n                     }\n                     _ => {\n                         cx.sess.span_bug(item.span,\n@@ -1328,7 +1353,14 @@ pub struct Polytype {\n \n /// As `Polytype` but for a trait ref.\n pub struct TraitDef {\n+    /// Generic type definitions. Note that `Self` is listed in here\n+    /// as having a single bound, the trait itself (e.g., in the trait\n+    /// `Eq`, there is a single bound `Self : Eq`). This is so that\n+    /// default methods get to assume that the `Self` parameters\n+    /// implements the trait.\n     pub generics: Generics,\n+\n+    /// The \"supertrait\" bounds.\n     pub bounds: ParamBounds,\n     pub trait_ref: Rc<ty::TraitRef>,\n }\n@@ -1345,14 +1377,15 @@ pub type type_cache = RefCell<DefIdMap<Polytype>>;\n pub type node_type_table = RefCell<HashMap<uint,t>>;\n \n /// Records information about each unboxed closure.\n+#[deriving(Clone)]\n pub struct UnboxedClosure {\n     /// The type of the unboxed closure.\n     pub closure_type: ClosureTy,\n     /// The kind of unboxed closure this is.\n     pub kind: UnboxedClosureKind,\n }\n \n-#[deriving(PartialEq, Eq)]\n+#[deriving(Clone, PartialEq, Eq)]\n pub enum UnboxedClosureKind {\n     FnUnboxedClosureKind,\n     FnMutUnboxedClosureKind,\n@@ -1401,6 +1434,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         item_substs: RefCell::new(NodeMap::new()),\n         trait_refs: RefCell::new(NodeMap::new()),\n         trait_defs: RefCell::new(DefIdMap::new()),\n+        object_cast_map: RefCell::new(NodeMap::new()),\n         map: map,\n         intrinsic_defs: RefCell::new(DefIdMap::new()),\n         freevars: RefCell::new(freevars),\n@@ -1429,14 +1463,12 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         impl_items: RefCell::new(DefIdMap::new()),\n         used_unsafe: RefCell::new(NodeSet::new()),\n         used_mut_nodes: RefCell::new(NodeSet::new()),\n-        impl_vtables: RefCell::new(DefIdMap::new()),\n         populated_external_types: RefCell::new(DefIdSet::new()),\n         populated_external_traits: RefCell::new(DefIdSet::new()),\n         upvar_borrow_map: RefCell::new(HashMap::new()),\n         extern_const_statics: RefCell::new(DefIdMap::new()),\n         extern_const_variants: RefCell::new(DefIdMap::new()),\n         method_map: RefCell::new(FnvHashMap::new()),\n-        vtable_map: RefCell::new(FnvHashMap::new()),\n         dependency_formats: RefCell::new(HashMap::new()),\n         unboxed_closures: RefCell::new(DefIdMap::new()),\n         node_lint_levels: RefCell::new(HashMap::new()),\n@@ -1523,7 +1555,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n           flags |= sflags(substs);\n       }\n-      &ty_trait(box ty::TyTrait { ref substs, ref bounds, .. }) => {\n+      &ty_trait(box TyTrait { ref substs, ref bounds, .. }) => {\n           flags |= sflags(substs);\n           flags |= flags_for_bounds(bounds);\n       }\n@@ -2394,6 +2426,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n             }\n \n             // Scalar and unique types are sendable, and durable\n+            ty_infer(ty::SkolemizedIntTy(_)) |\n             ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(_) | ty::ty_char => {\n                 TC::None\n@@ -2414,7 +2447,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 }\n             }\n \n-            ty_trait(box ty::TyTrait { bounds, .. }) => {\n+            ty_trait(box TyTrait { bounds, .. }) => {\n                 object_contents(cx, bounds) | TC::ReachesFfiUnsafe | TC::Nonsized\n             }\n \n@@ -2909,13 +2942,17 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n }\n \n pub fn type_is_trait(ty: t) -> bool {\n+    type_trait_info(ty).is_some()\n+}\n+\n+pub fn type_trait_info(ty: t) -> Option<&'static TyTrait> {\n     match get(ty).sty {\n         ty_uniq(ty) | ty_rptr(_, mt { ty, ..}) | ty_ptr(mt { ty, ..}) => match get(ty).sty {\n-            ty_trait(..) => true,\n-            _ => false\n+            ty_trait(ref t) => Some(&**t),\n+            _ => None\n         },\n-        ty_trait(..) => true,\n-        _ => false\n+        ty_trait(ref t) => Some(&**t),\n+        _ => None\n     }\n }\n \n@@ -2926,6 +2963,14 @@ pub fn type_is_integral(ty: t) -> bool {\n     }\n }\n \n+pub fn type_is_skolemized(ty: t) -> bool {\n+    match get(ty).sty {\n+      ty_infer(SkolemizedTy(_)) => true,\n+      ty_infer(SkolemizedIntTy(_)) => true,\n+      _ => false\n+    }\n+}\n+\n pub fn type_is_uint(ty: t) -> bool {\n     match get(ty).sty {\n       ty_infer(IntVar(_)) | ty_uint(ast::TyU) => true,\n@@ -3448,7 +3493,7 @@ pub fn unsize_ty(cx: &ctxt,\n                                   format!(\"UnsizeStruct with bad sty: {}\",\n                                           ty_to_string(cx, ty)).as_slice())\n         },\n-        &UnsizeVtable(bounds, def_id, ref substs) => {\n+        &UnsizeVtable(TyTrait { def_id, substs: ref substs, bounds }, _) => {\n             mk_trait(cx, def_id, substs.clone(), bounds)\n         }\n     }\n@@ -3468,10 +3513,10 @@ impl AutoRef {\n }\n \n pub fn method_call_type_param_defs<'tcx, T>(typer: &T,\n-                                            origin: typeck::MethodOrigin)\n+                                            origin: &typeck::MethodOrigin)\n                                             -> VecPerParamSpace<TypeParameterDef>\n                                             where T: mc::Typer<'tcx> {\n-    match origin {\n+    match *origin {\n         typeck::MethodStatic(did) => {\n             ty::lookup_item_type(typer.tcx(), did).generics.types.clone()\n         }\n@@ -3486,16 +3531,16 @@ pub fn method_call_type_param_defs<'tcx, T>(typer: &T,\n             lookup_trait_def(typer.tcx(), def_id).generics.types.clone()\n         }\n         typeck::MethodParam(typeck::MethodParam{\n-            trait_id: trt_id,\n+            trait_ref: ref trait_ref,\n             method_num: n_mth,\n             ..\n         }) |\n         typeck::MethodObject(typeck::MethodObject{\n-                trait_id: trt_id,\n+                trait_ref: ref trait_ref,\n                 method_num: n_mth,\n                 ..\n         }) => {\n-            match ty::trait_item(typer.tcx(), trt_id, n_mth) {\n+            match ty::trait_item(typer.tcx(), trait_ref.def_id, n_mth) {\n                 ty::MethodTraitItem(method) => method.generics.types.clone(),\n             }\n         }\n@@ -3760,6 +3805,8 @@ pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n         ty_infer(TyVar(_)) => \"inferred type\".to_string(),\n         ty_infer(IntVar(_)) => \"integral variable\".to_string(),\n         ty_infer(FloatVar(_)) => \"floating-point variable\".to_string(),\n+        ty_infer(SkolemizedTy(_)) => \"skolemized type\".to_string(),\n+        ty_infer(SkolemizedIntTy(_)) => \"skolemized integral type\".to_string(),\n         ty_param(ref p) => {\n             if p.space == subst::SelfSpace {\n                 \"Self\".to_string()\n@@ -4362,14 +4409,6 @@ pub fn lookup_item_type(cx: &ctxt,\n         || csearch::get_type(cx, did))\n }\n \n-pub fn lookup_impl_vtables(cx: &ctxt,\n-                           did: ast::DefId)\n-                           -> typeck::vtable_res {\n-    lookup_locally_or_in_crate_store(\n-        \"impl_vtables\", did, &mut *cx.impl_vtables.borrow_mut(),\n-        || csearch::get_impl_vtables(cx, did) )\n-}\n-\n /// Given the did of a trait, returns its canonical trait ref.\n pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> Rc<ty::TraitDef> {\n     let mut trait_defs = cx.trait_defs.borrow_mut();\n@@ -4683,7 +4722,7 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n     struct TypeNormalizer<'a, 'tcx: 'a>(&'a ctxt<'tcx>);\n \n     impl<'a, 'tcx> TypeFolder<'tcx> for TypeNormalizer<'a, 'tcx> {\n-        fn tcx<'a>(&'a self) -> &'a ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n+        fn tcx(&self) -> &ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n             match self.tcx().normalized_cache.borrow().find_copy(&t) {\n@@ -4783,42 +4822,11 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n                                         bounds: &[Rc<TraitRef>],\n                                         f: |Rc<TraitRef>| -> bool)\n-                                        -> bool {\n-    for bound_trait_ref in bounds.iter() {\n-        let mut supertrait_set = HashMap::new();\n-        let mut trait_refs = Vec::new();\n-        let mut i = 0;\n-\n-        // Seed the worklist with the trait from the bound\n-        supertrait_set.insert(bound_trait_ref.def_id, ());\n-        trait_refs.push(bound_trait_ref.clone());\n-\n-        // Add the given trait ty to the hash map\n-        while i < trait_refs.len() {\n-            debug!(\"each_bound_trait_and_supertraits(i={:?}, trait_ref={})\",\n-                   i, trait_refs.get(i).repr(tcx));\n-\n-            if !f(trait_refs.get(i).clone()) {\n-                return false;\n-            }\n-\n-            // Add supertraits to supertrait_set\n-            let trait_ref = trait_refs.get(i).clone();\n-            let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n-            for supertrait_ref in trait_def.bounds.trait_bounds.iter() {\n-                let supertrait_ref = supertrait_ref.subst(tcx, &trait_ref.substs);\n-                debug!(\"each_bound_trait_and_supertraits(supertrait_ref={})\",\n-                       supertrait_ref.repr(tcx));\n-\n-                let d_id = supertrait_ref.def_id;\n-                if !supertrait_set.contains_key(&d_id) {\n-                    // FIXME(#5527) Could have same trait multiple times\n-                    supertrait_set.insert(d_id, ());\n-                    trait_refs.push(supertrait_ref.clone());\n-                }\n-            }\n-\n-            i += 1;\n+                                        -> bool\n+{\n+    for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n+        if !f(bound_trait_ref) {\n+            return false;\n         }\n     }\n     return true;\n@@ -4944,6 +4952,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n         return\n     }\n \n+    let mut inherent_impls = Vec::new();\n     csearch::each_implementation_for_type(&tcx.sess.cstore, type_id,\n             |impl_def_id| {\n         let impl_items = csearch::get_impl_items(&tcx.sess.cstore,\n@@ -4975,18 +4984,11 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n \n         // If this is an inherent implementation, record it.\n         if associated_traits.is_none() {\n-            match tcx.inherent_impls.borrow().find(&type_id) {\n-                Some(implementation_list) => {\n-                    implementation_list.borrow_mut().push(impl_def_id);\n-                    return;\n-                }\n-                None => {}\n-            }\n-            tcx.inherent_impls.borrow_mut().insert(type_id,\n-                                                   Rc::new(RefCell::new(vec!(impl_def_id))));\n+            inherent_impls.push(impl_def_id);\n         }\n     });\n \n+    tcx.inherent_impls.borrow_mut().insert(type_id, Rc::new(inherent_impls));\n     tcx.populated_external_types.borrow_mut().insert(type_id);\n }\n \n@@ -5218,7 +5220,7 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n                     }\n                 }\n             }\n-            ty_trait(box ty::TyTrait { def_id: d, bounds, .. }) => {\n+            ty_trait(box TyTrait { def_id: d, bounds, .. }) => {\n                 byte!(17);\n                 did(&mut state, d);\n                 hash!(bounds);\n@@ -5261,8 +5263,22 @@ impl Variance {\n     }\n }\n \n+pub fn empty_parameter_environment() -> ParameterEnvironment {\n+    /*!\n+     * Construct a parameter environment suitable for static contexts\n+     * or other contexts where there are no free type/lifetime\n+     * parameters in scope.\n+     */\n+\n+    ty::ParameterEnvironment { free_substs: Substs::empty(),\n+                               bounds: VecPerParamSpace::empty(),\n+                               caller_obligations: VecPerParamSpace::empty(),\n+                               implicit_region_bound: ty::ReEmpty }\n+}\n+\n pub fn construct_parameter_environment(\n     tcx: &ctxt,\n+    span: Span,\n     generics: &ty::Generics,\n     free_id: ast::NodeId)\n     -> ParameterEnvironment\n@@ -5321,10 +5337,14 @@ pub fn construct_parameter_environment(\n            free_substs.repr(tcx),\n            bounds.repr(tcx));\n \n+    let obligations = traits::obligations_for_generics(tcx, traits::ObligationCause::misc(span),\n+                                                       generics, &free_substs);\n+\n     return ty::ParameterEnvironment {\n         free_substs: free_substs,\n         bounds: bounds,\n         implicit_region_bound: ty::ReScope(free_id),\n+        caller_obligations: obligations,\n     };\n \n     fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,\n@@ -5398,6 +5418,26 @@ impl BorrowKind {\n         }\n     }\n \n+    pub fn to_mutbl_lossy(self) -> ast::Mutability {\n+        /*!\n+         * Returns a mutability `m` such that an `&m T` pointer could\n+         * be used to obtain this borrow kind. Because borrow kinds\n+         * are richer than mutabilities, we sometimes have to pick a\n+         * mutability that is stronger than necessary so that it at\n+         * least *would permit* the borrow in question.\n+         */\n+\n+        match self {\n+            MutBorrow => ast::MutMutable,\n+            ImmBorrow => ast::MutImmutable,\n+\n+            // We have no type correponding to a unique imm borrow, so\n+            // use `&mut`. It gives all the capabilities of an `&uniq`\n+            // and hence is a safe \"over approximation\".\n+            UniqueImmBorrow => ast::MutMutable,\n+        }\n+    }\n+\n     pub fn to_user_str(&self) -> &'static str {\n         match *self {\n             MutBorrow => \"mutable\","}, {"sha": "549f0daef81121c838cff4accc38634c95fc0350", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 117, "deletions": 3, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -8,11 +8,38 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Generalized type folding mechanism.\n+/*!\n+ * Generalized type folding mechanism. The setup is a bit convoluted\n+ * but allows for convenient usage. Let T be an instance of some\n+ * \"foldable type\" (one which implements `TypeFoldable`) and F be an\n+ * instance of a \"folder\" (a type which implements `TypeFolder`). Then\n+ * the setup is intended to be:\n+ *\n+ *     T.fold_with(F) --calls--> F.fold_T(T) --calls--> super_fold_T(F, T)\n+ *\n+ * This way, when you define a new folder F, you can override\n+ * `fold_T()` to customize the behavior, and invoke `super_fold_T()`\n+ * to get the original behavior. Meanwhile, to actually fold\n+ * something, you can just write `T.fold_with(F)`, which is\n+ * convenient. (Note that `fold_with` will also transparently handle\n+ * things like a `Vec<T>` where T is foldable and so on.)\n+ *\n+ * In this ideal setup, the only function that actually *does*\n+ * anything is `super_fold_T`, which traverses the type `T`. Moreover,\n+ * `super_fold_T` should only ever call `T.fold_with()`.\n+ *\n+ * In some cases, we follow a degenerate pattern where we do not have\n+ * a `fold_T` nor `super_fold_T` method. Instead, `T.fold_with`\n+ * traverses the structure directly. This is suboptimal because the\n+ * behavior cannot be overriden, but it's much less work to implement.\n+ * If you ever *do* need an override that doesn't exist, it's not hard\n+ * to convert the degenerate pattern into the proper thing.\n+ */\n \n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty;\n+use middle::traits;\n use middle::typeck;\n use std::rc::Rc;\n use syntax::ast;\n@@ -97,6 +124,10 @@ pub trait TypeFolder<'tcx> {\n     fn fold_item_substs(&mut self, i: ty::ItemSubsts) -> ty::ItemSubsts {\n         super_fold_item_substs(self, i)\n     }\n+\n+    fn fold_obligation(&mut self, o: &traits::Obligation) -> traits::Obligation {\n+        super_fold_obligation(self, o)\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -110,6 +141,12 @@ pub trait TypeFolder<'tcx> {\n // can easily refactor the folding into the TypeFolder trait as\n // needed.\n \n+impl TypeFoldable for () {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, _: &mut F) -> () {\n+        ()\n+    }\n+}\n+\n impl<T:TypeFoldable> TypeFoldable for Option<T> {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n         self.as_ref().map(|t| t.fold_with(folder))\n@@ -296,13 +333,54 @@ impl TypeFoldable for ty::UnsizeKind {\n         match *self {\n             ty::UnsizeLength(len) => ty::UnsizeLength(len),\n             ty::UnsizeStruct(box ref k, n) => ty::UnsizeStruct(box k.fold_with(folder), n),\n-            ty::UnsizeVtable(bounds, def_id, ref substs) => {\n-                ty::UnsizeVtable(bounds.fold_with(folder), def_id, substs.fold_with(folder))\n+            ty::UnsizeVtable(ty::TyTrait{bounds, def_id, substs: ref substs}, self_ty) => {\n+                ty::UnsizeVtable(\n+                    ty::TyTrait {\n+                        bounds: bounds.fold_with(folder),\n+                        def_id: def_id,\n+                        substs: substs.fold_with(folder)\n+                    },\n+                    self_ty.fold_with(folder))\n             }\n         }\n     }\n }\n \n+impl TypeFoldable for traits::Obligation {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation {\n+        folder.fold_obligation(self)\n+    }\n+}\n+\n+impl<N:TypeFoldable> TypeFoldable for traits::VtableImpl<N> {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImpl<N> {\n+        traits::VtableImpl {\n+            impl_def_id: self.impl_def_id,\n+            substs: self.substs.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<N:TypeFoldable> TypeFoldable for traits::Vtable<N> {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<N> {\n+        match *self {\n+            traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n+            traits::VtableUnboxedClosure(d) => traits::VtableUnboxedClosure(d),\n+            traits::VtableParam(ref p) => traits::VtableParam(p.fold_with(folder)),\n+            traits::VtableBuiltin => traits::VtableBuiltin,\n+        }\n+    }\n+}\n+\n+impl TypeFoldable for traits::VtableParam {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableParam {\n+        traits::VtableParam {\n+            bound: self.bound.fold_with(folder),\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // \"super\" routines: these are the default implementations for TypeFolder.\n //\n@@ -482,6 +560,17 @@ pub fn super_fold_item_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n     }\n }\n \n+pub fn super_fold_obligation<'tcx, T:TypeFolder<'tcx>>(this: &mut T,\n+                                                       obligation: &traits::Obligation)\n+                                                       -> traits::Obligation\n+{\n+    traits::Obligation {\n+        cause: obligation.cause,\n+        recursion_depth: obligation.recursion_depth,\n+        trait_ref: obligation.trait_ref.fold_with(this),\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n@@ -591,3 +680,28 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n         }\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Region eraser\n+//\n+// Replaces all free regions with 'static. Useful in trans.\n+\n+pub struct RegionEraser<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+}\n+\n+pub fn erase_regions<T:TypeFoldable>(tcx: &ty::ctxt, t: T) -> T {\n+    let mut eraser = RegionEraser { tcx: tcx };\n+    t.fold_with(&mut eraser)\n+}\n+\n+impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        match r {\n+            ty::ReLateBound(..) | ty::ReEarlyBound(..) => r,\n+            _ => ty::ReStatic\n+        }\n+    }\n+}"}, {"sha": "46aba94a5f12a0ab773f463d7be43bd46ebae106", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -555,11 +555,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                             None);\n                 match tcx.def_map.borrow().find(&pat.id) {\n                     Some(def) => {\n-                        let item_type = ty::lookup_item_type(tcx, def.def_id());\n-                        let substitutions = fcx.infcx().fresh_substs_for_type(\n-                            pat.span, &item_type.generics);\n+                        let struct_ty = fcx.instantiate_item_type(pat.span, def.def_id());\n                         check_struct_pat(pcx, pat.span, fields.as_slice(),\n-                                         etc, def.def_id(), &substitutions);\n+                                         etc, def.def_id(), &struct_ty.substs);\n                     }\n                     None => {\n                         tcx.sess.span_bug(pat.span,"}, {"sha": "074074c13ae907995231cc57a0abc81ac6f20911", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -82,6 +82,7 @@ obtained the type `Foo`, we would never match this method.\n \n use middle::subst;\n use middle::subst::Subst;\n+use middle::traits;\n use middle::ty::*;\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n@@ -91,7 +92,6 @@ use middle::typeck::infer;\n use middle::typeck::MethodCallee;\n use middle::typeck::{MethodOrigin, MethodParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject};\n-use middle::typeck::{param_index};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::TypeAndSubsts;\n use util::common::indenter;\n@@ -538,14 +538,12 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             return\n         }\n \n-        let vcx = self.fcx.vtable_context();\n-\n         // Get the tupled type of the arguments.\n         let arguments_type = *closure_function_type.sig.inputs.get(0);\n         let return_type = closure_function_type.sig.output;\n \n         let closure_region =\n-            vcx.infcx.next_region_var(infer::MiscVariable(self.span));\n+            self.fcx.infcx().next_region_var(infer::MiscVariable(self.span));\n         let unboxed_closure_type = ty::mk_unboxed_closure(self.tcx(),\n                                                           closure_did,\n                                                           closure_region);\n@@ -555,7 +553,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             rcvr_substs: subst::Substs::new_trait(\n                 vec![arguments_type, return_type],\n                 vec![],\n-                *vcx.infcx.next_ty_vars(1).get(0)),\n+                *self.fcx.infcx().next_ty_vars(1).get(0)),\n             method_ty: method,\n             origin: MethodStaticUnboxedClosure(closure_did),\n         });\n@@ -618,7 +616,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         self.push_inherent_candidates_from_bounds_inner(\n             &[trait_ref.clone()],\n-            |_this, new_trait_ref, m, method_num, _bound_num| {\n+            |_this, new_trait_ref, m, method_num| {\n                 let vtable_index =\n                     get_method_index(tcx, &*new_trait_ref,\n                                      trait_ref.clone(), method_num);\n@@ -633,7 +631,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     rcvr_substs: new_trait_ref.substs.clone(),\n                     method_ty: Rc::new(m),\n                     origin: MethodObject(MethodObject {\n-                        trait_id: new_trait_ref.def_id,\n+                        trait_ref: new_trait_ref,\n                         object_trait_id: did,\n                         method_num: method_num,\n                         real_index: vtable_index\n@@ -652,22 +650,20 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             rcvr_ty,\n             param_ty.space,\n             param_ty.idx,\n-            restrict_to,\n-            param_index { space: param_ty.space, index: param_ty.idx });\n+            restrict_to);\n     }\n \n \n     fn push_inherent_candidates_from_bounds(&mut self,\n                                             self_ty: ty::t,\n                                             space: subst::ParamSpace,\n                                             index: uint,\n-                                            restrict_to: Option<DefId>,\n-                                            param: param_index) {\n+                                            restrict_to: Option<DefId>) {\n         let bounds =\n             self.fcx.inh.param_env.bounds.get(space, index).trait_bounds\n             .as_slice();\n         self.push_inherent_candidates_from_bounds_inner(bounds,\n-            |this, trait_ref, m, method_num, bound_num| {\n+            |this, trait_ref, m, method_num| {\n                 match restrict_to {\n                     Some(trait_did) => {\n                         if trait_did != trait_ref.def_id {\n@@ -701,10 +697,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     rcvr_substs: trait_ref.substs.clone(),\n                     method_ty: m,\n                     origin: MethodParam(MethodParam {\n-                        trait_id: trait_ref.def_id,\n+                        trait_ref: trait_ref,\n                         method_num: method_num,\n-                        param_num: param,\n-                        bound_num: bound_num,\n                     })\n                 })\n         })\n@@ -718,15 +712,16 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         mk_cand: |this: &mut LookupContext,\n                   tr: Rc<TraitRef>,\n                   m: Rc<ty::Method>,\n-                  method_num: uint,\n-                  bound_num: uint|\n-                  -> Option<Candidate>) {\n+                  method_num: uint|\n+                  -> Option<Candidate>)\n+    {\n         let tcx = self.tcx();\n-        let mut next_bound_idx = 0; // count only trait bounds\n-\n-        ty::each_bound_trait_and_supertraits(tcx, bounds, |bound_trait_ref| {\n-            let this_bound_idx = next_bound_idx;\n-            next_bound_idx += 1;\n+        let mut cache = HashSet::new();\n+        for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n+            // Already visited this trait, skip it.\n+            if !cache.insert(bound_trait_ref.def_id) {\n+                continue;\n+            }\n \n             let trait_items = ty::trait_items(tcx, bound_trait_ref.def_id);\n             match trait_items.iter().position(|ti| {\n@@ -745,8 +740,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     match mk_cand(self,\n                                   bound_trait_ref,\n                                   method,\n-                                  pos,\n-                                  this_bound_idx) {\n+                                  pos) {\n                         Some(cand) => {\n                             debug!(\"pushing inherent candidate for param: {}\",\n                                    cand.repr(self.tcx()));\n@@ -761,8 +755,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     // check next trait or bound\n                 }\n             }\n-            true\n-        });\n+        }\n     }\n \n \n@@ -773,7 +766,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         let impl_items = self.tcx().impl_items.borrow();\n         for impl_infos in self.tcx().inherent_impls.borrow().find(&did).iter() {\n-            for impl_did in impl_infos.borrow().iter() {\n+            for impl_did in impl_infos.iter() {\n                 let items = impl_items.get(impl_did);\n                 self.push_candidates_from_impl(*impl_did,\n                                                items.as_slice(),\n@@ -825,11 +818,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n-        let vcx = self.fcx.vtable_context();\n         let TypeAndSubsts {\n             substs: impl_substs,\n             ty: impl_ty\n-        } = impl_self_ty(&vcx, span, impl_did);\n+        } = impl_self_ty(self.fcx, span, impl_did);\n \n         let condition = match method.explicit_self {\n             ByReferenceExplicitSelfCategory(_, mt) if mt == MutMutable =>\n@@ -877,7 +869,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                        adjustment {:?} for {}\", adjustment, self.ty_to_string(self_ty));\n                 match adjustment {\n                     Some((self_expr_id, adj)) => {\n-                        self.fcx.write_adjustment(self_expr_id, adj);\n+                        self.fcx.write_adjustment(self_expr_id, self.span, adj);\n                     }\n                     None => {}\n                 }\n@@ -1109,7 +1101,9 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n             ty_err => None,\n \n-            ty_infer(TyVar(_)) => {\n+            ty_infer(TyVar(_)) |\n+            ty_infer(SkolemizedTy(_)) |\n+            ty_infer(SkolemizedIntTy(_)) => {\n                 self.bug(format!(\"unexpected type: {}\",\n                                  self.ty_to_string(self_ty)).as_slice());\n             }\n@@ -1150,6 +1144,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                         Some(self_expr_id) => {\n                             self.fcx.write_adjustment(\n                                 self_expr_id,\n+                                self.span,\n                                 ty::AutoDerefRef(ty::AutoDerefRef {\n                                     autoderefs: autoderefs,\n                                     autoref: Some(kind(region, *mutbl))\n@@ -1209,7 +1204,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n             // return something so we don't get errors for every mutability\n             return Some(MethodCallee {\n-                origin: relevant_candidates.get(0).origin,\n+                origin: relevant_candidates.get(0).origin.clone(),\n                 ty: ty::mk_err(),\n                 substs: subst::Substs::empty()\n             });\n@@ -1237,12 +1232,14 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                        candidate_b.repr(self.tcx()));\n                 match (&candidate_a.origin, &candidate_b.origin) {\n                     (&MethodParam(ref p1), &MethodParam(ref p2)) => {\n-                        let same_trait = p1.trait_id == p2.trait_id;\n-                        let same_method = p1.method_num == p2.method_num;\n-                        let same_param = p1.param_num == p2.param_num;\n-                        // The bound number may be different because\n-                        // multiple bounds may lead to the same trait\n-                        // impl\n+                        let same_trait =\n+                            p1.trait_ref.def_id == p2.trait_ref.def_id;\n+                        let same_method =\n+                            p1.method_num == p2.method_num;\n+                        // it's ok to compare self-ty with `==` here because\n+                        // they are always a TyParam\n+                        let same_param =\n+                            p1.trait_ref.self_ty() == p2.trait_ref.self_ty();\n                         same_trait && same_method && same_param\n                     }\n                     _ => false\n@@ -1369,13 +1366,13 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             }\n         }\n \n-        self.fcx.add_region_obligations_for_parameters(\n-            self.span,\n+        self.fcx.add_obligations_for_parameters(\n+            traits::ObligationCause::misc(self.span),\n             &all_substs,\n             &candidate.method_ty.generics);\n \n         MethodCallee {\n-            origin: candidate.origin,\n+            origin: candidate.origin.clone(),\n             ty: fty,\n             substs: all_substs\n         }\n@@ -1452,10 +1449,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             MethodStaticUnboxedClosure(_) => bad = false,\n             // FIXME: does this properly enforce this on everything now\n             // that self has been merged in? -sully\n-            MethodParam(MethodParam { trait_id: trait_id, .. }) |\n-            MethodObject(MethodObject { trait_id: trait_id, .. }) => {\n+            MethodParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n+            MethodObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n                 bad = self.tcx().destructor_for_type.borrow()\n-                          .contains_key(&trait_id);\n+                          .contains_key(&trait_ref.def_id);\n             }\n         }\n \n@@ -1602,10 +1599,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 self.report_static_candidate(idx, did)\n             }\n             MethodParam(ref mp) => {\n-                self.report_param_candidate(idx, (*mp).trait_id)\n+                self.report_param_candidate(idx, mp.trait_ref.def_id)\n             }\n             MethodObject(ref mo) => {\n-                self.report_trait_candidate(idx, mo.trait_id)\n+                self.report_trait_candidate(idx, mo.trait_ref.def_id)\n             }\n         }\n     }"}, {"sha": "20fe8186adf40fe50100022eb2ae24fae60d0cf8", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 323, "deletions": 196, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -87,6 +87,7 @@ use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::subst;\n use middle::subst::{Subst, Substs, VecPerParamSpace, ParamSpace};\n+use middle::traits;\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{Polytype};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n@@ -102,15 +103,14 @@ use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::method::{DontAutoderefReceiver};\n use middle::typeck::check::method::{IgnoreStaticMethods, ReportStaticMethods};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n-use middle::typeck::check::vtable::VtableContext;\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n use middle::typeck::infer;\n use middle::typeck::rscope::RegionScope;\n use middle::typeck::{lookup_def_ccx};\n use middle::typeck::no_params;\n-use middle::typeck::{require_same_types, vtable_map};\n-use middle::typeck::{MethodCall, MethodMap};\n+use middle::typeck::{require_same_types};\n+use middle::typeck::{MethodCall, MethodMap, ObjectCastMap};\n use middle::typeck::{TypeAndSubsts};\n use middle::typeck;\n use middle::lang_items::TypeIdLangItem;\n@@ -143,12 +143,13 @@ use syntax::visit::Visitor;\n use syntax;\n \n pub mod _match;\n-pub mod vtable;\n+pub mod vtable2; // New trait code\n pub mod writeback;\n pub mod regionmanip;\n pub mod regionck;\n pub mod demand;\n pub mod method;\n+pub mod wf;\n \n /// Fields that are part of a `FnCtxt` which are inherited by\n /// closures defined within the function.  For example:\n@@ -170,9 +171,9 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     item_substs: RefCell<NodeMap<ty::ItemSubsts>>,\n     adjustments: RefCell<NodeMap<ty::AutoAdjustment>>,\n     method_map: MethodMap,\n-    vtable_map: vtable_map,\n     upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n     unboxed_closures: RefCell<DefIdMap<ty::UnboxedClosure>>,\n+    object_cast_map: ObjectCastMap,\n \n     // A mapping from each fn's id to its signature, with all bound\n     // regions replaced with free ones. Unlike the other tables, this\n@@ -190,7 +191,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // then in some expression `let x = Foo { ... }` it will\n     // instantiate the type parameter `T` with a fresh type `$0`. At\n     // the same time, it will record a region obligation of\n-    // `$0:'static`. This will get checked later by regionck.  (We\n+    // `$0:'static`. This will get checked later by regionck. (We\n     // can't generally check these things right away because we have\n     // to wait until types are resolved.)\n     //\n@@ -204,6 +205,9 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n     region_obligations: RefCell<NodeMap<Vec<RegionObligation>>>,\n+\n+    // Tracks trait obligations incurred during this function body.\n+    fulfillment_cx: RefCell<traits::FulfillmentContext>,\n }\n \n struct RegionObligation {\n@@ -335,11 +339,12 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             item_substs: RefCell::new(NodeMap::new()),\n             adjustments: RefCell::new(NodeMap::new()),\n             method_map: RefCell::new(FnvHashMap::new()),\n-            vtable_map: RefCell::new(FnvHashMap::new()),\n+            object_cast_map: RefCell::new(NodeMap::new()),\n             upvar_borrow_map: RefCell::new(HashMap::new()),\n             unboxed_closures: RefCell::new(DefIdMap::new()),\n             fn_sig_map: RefCell::new(NodeMap::new()),\n             region_obligations: RefCell::new(NodeMap::new()),\n+            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n         }\n     }\n }\n@@ -369,20 +374,12 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n         free_substs: subst::Substs::empty(),\n         bounds: subst::VecPerParamSpace::empty(),\n         implicit_region_bound: ty::ReStatic,\n+        caller_obligations: subst::VecPerParamSpace::empty(),\n     };\n     Inherited::new(ccx.tcx, param_env)\n }\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n-struct CheckTypeWellFormedVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n-        check_type_well_formed(self.ccx, i);\n-        visit::walk_item(self, i);\n-    }\n-}\n-\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n@@ -404,8 +401,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemSizedTypesVisitor<'a, 'tcx> {\n \n pub fn check_item_types(ccx: &CrateCtxt) {\n     let krate = ccx.tcx.map.krate();\n-\n-    let mut visit = CheckTypeWellFormedVisitor { ccx: ccx };\n+    let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n     visit::walk_crate(&mut visit, krate);\n \n     // If types are not well-formed, it leads to all manner of errors\n@@ -437,9 +433,10 @@ fn check_bare_fn(ccx: &CrateCtxt,\n             let fcx = check_fn(ccx, fn_ty.fn_style, id, &fn_ty.sig,\n                                decl, id, body, &inh);\n \n-            vtable::resolve_in_block(&fcx, body);\n+            vtable2::select_all_fcx_obligations_or_error(&fcx);\n             regionck::regionck_fn(&fcx, id, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n+            vtable2::check_builtin_bound_obligations(&fcx); // must happen after writeback\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n                                  \"check_bare_fn: function type expected\")\n@@ -451,19 +448,21 @@ struct GatherLocalsVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n-    fn assign(&mut self, nid: ast::NodeId, ty_opt: Option<ty::t>) {\n-            match ty_opt {\n-                None => {\n-                    // infer the variable's type\n-                    let var_id = self.fcx.infcx().next_ty_var_id();\n-                    let var_ty = ty::mk_var(self.fcx.tcx(), var_id);\n-                    self.fcx.inh.locals.borrow_mut().insert(nid, var_ty);\n-                }\n-                Some(typ) => {\n-                    // take type that the user specified\n-                    self.fcx.inh.locals.borrow_mut().insert(nid, typ);\n-                }\n+    fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<ty::t>) -> ty::t {\n+        match ty_opt {\n+            None => {\n+                // infer the variable's type\n+                let var_id = self.fcx.infcx().next_ty_var_id();\n+                let var_ty = ty::mk_var(self.fcx.tcx(), var_id);\n+                self.fcx.inh.locals.borrow_mut().insert(nid, var_ty);\n+                var_ty\n             }\n+            Some(typ) => {\n+                // take type that the user specified\n+                self.fcx.inh.locals.borrow_mut().insert(nid, typ);\n+                typ\n+            }\n+        }\n     }\n }\n \n@@ -474,7 +473,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n             ast::TyInfer => None,\n             _ => Some(self.fcx.to_ty(&*local.ty))\n         };\n-        self.assign(local.id, o_ty);\n+        self.assign(local.span, local.id, o_ty);\n         debug!(\"Local variable {} is assigned type {}\",\n                self.fcx.pat_to_string(&*local.pat),\n                self.fcx.infcx().ty_to_string(\n@@ -484,19 +483,23 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &ast::Pat) {\n-            match p.node {\n-              ast::PatIdent(_, ref path1, _)\n-                  if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) => {\n-                self.assign(p.id, None);\n-                debug!(\"Pattern binding {} is assigned to {}\",\n-                       token::get_ident(path1.node),\n-                       self.fcx.infcx().ty_to_string(\n-                           self.fcx.inh.locals.borrow().get_copy(&p.id)));\n-              }\n-              _ => {}\n-            }\n-            visit::walk_pat(self, p);\n-\n+        match p.node {\n+            ast::PatIdent(_, ref path1, _)\n+                if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) => {\n+                    let var_ty = self.assign(p.span, p.id, None);\n+\n+                    self.fcx.require_type_is_sized(var_ty, p.span,\n+                                                   traits::VariableType(p.id));\n+\n+                    debug!(\"Pattern binding {} is assigned to {} with type {}\",\n+                           token::get_ident(path1.node),\n+                           self.fcx.infcx().ty_to_string(\n+                               self.fcx.inh.locals.borrow().get_copy(&p.id)),\n+                           var_ty.repr(self.fcx.tcx()));\n+                }\n+            _ => {}\n+        }\n+        visit::walk_pat(self, p);\n     }\n \n     fn visit_block(&mut self, b: &ast::Block) {\n@@ -592,11 +595,14 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n-            pat_util::pat_bindings(&tcx.def_map,\n-                                   &*input.pat,\n-                                   |_bm, pat_id, _sp, _path| {\n-                                       visit.assign(pat_id, None);\n-                                   });\n+            pat_util::pat_bindings(\n+                &tcx.def_map,\n+                &*input.pat,\n+                |_bm, pat_id, sp, _path| {\n+                    let var_ty = visit.assign(sp, pat_id, None);\n+                    fcx.require_type_is_sized(var_ty, sp,\n+                                              traits::VariableType(pat_id));\n+                });\n \n             // Check the pattern.\n             let pcx = pat_ctxt {\n@@ -713,71 +719,6 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-fn check_type_well_formed(ccx: &CrateCtxt, item: &ast::Item) {\n-    /*!\n-     * Checks that the field types (in a struct def'n) or\n-     * argument types (in an enum def'n) are well-formed,\n-     * meaning that they do not require any constraints not\n-     * declared in the struct definition itself.\n-     * For example, this definition would be illegal:\n-     *\n-     *     struct Ref<'a, T> { x: &'a T }\n-     *\n-     * because the type did not declare that `T:'a`.\n-     *\n-     * We do this check as a pre-pass before checking fn bodies\n-     * because if these constraints are not included it frequently\n-     * leads to confusing errors in fn bodies. So it's better to check\n-     * the types first.\n-     */\n-\n-    debug!(\"check_type_well_formed(it.id={}, it.ident={})\",\n-           item.id,\n-           ty::item_path_str(ccx.tcx, local_def(item.id)));\n-\n-    match item.node {\n-        ast::ItemStruct(..) => {\n-            check_type_defn(ccx, item, |fcx| {\n-                ty::struct_fields(ccx.tcx, local_def(item.id),\n-                                  &fcx.inh.param_env.free_substs)\n-                    .iter()\n-                    .map(|f| f.mt.ty)\n-                    .collect()\n-            });\n-        }\n-        ast::ItemEnum(..) => {\n-            check_type_defn(ccx, item, |fcx| {\n-                ty::substd_enum_variants(ccx.tcx, local_def(item.id),\n-                                         &fcx.inh.param_env.free_substs)\n-                    .iter()\n-                    .flat_map(|variant| {\n-                        variant.args\n-                            .iter()\n-                            .map(|&arg_ty| arg_ty)\n-                    })\n-                    .collect()\n-            });\n-        }\n-        _ => {}\n-    }\n-\n-    fn check_type_defn(ccx: &CrateCtxt,\n-                       item: &ast::Item,\n-                       lookup_fields: |&FnCtxt| -> Vec<ty::t>)\n-    {\n-        let item_def_id = local_def(item.id);\n-        let polytype = ty::lookup_item_type(ccx.tcx, item_def_id);\n-        let param_env =\n-            ty::construct_parameter_environment(ccx.tcx,\n-                                                &polytype.generics,\n-                                                item.id);\n-        let inh = Inherited::new(ccx.tcx, param_env);\n-        let fcx = blank_fn_ctxt(ccx, &inh, polytype.ty, item.id);\n-        let field_tys = lookup_fields(&fcx);\n-        regionck::regionck_type_defn(&fcx, item.span, field_tys.as_slice());\n-    }\n-}\n-\n pub fn check_item_sized(ccx: &CrateCtxt, it: &ast::Item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n@@ -836,7 +777,6 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                                ast_trait_ref,\n                                                &*impl_trait_ref,\n                                                impl_items.as_slice());\n-                vtable::resolve_impl(ccx.tcx, it, &impl_pty.generics, &*impl_trait_ref);\n             }\n             None => { }\n         }\n@@ -1409,10 +1349,12 @@ fn compare_impl_method(tcx: &ty::ctxt,\n }\n \n fn check_cast(fcx: &FnCtxt,\n+              cast_expr: &ast::Expr,\n               e: &ast::Expr,\n-              t: &ast::Ty,\n-              id: ast::NodeId,\n-              span: Span) {\n+              t: &ast::Ty) {\n+    let id = cast_expr.id;\n+    let span = cast_expr.span;\n+\n     // Find the type of `e`. Supply hints based on the type we are casting to,\n     // if appropriate.\n     let t_1 = fcx.to_ty(t);\n@@ -1443,6 +1385,7 @@ fn check_cast(fcx: &FnCtxt,\n \n     if ty::type_is_trait(t_1) {\n         // This will be looked up later on.\n+        vtable2::check_object_cast(fcx, cast_expr, e, t_1);\n         fcx.write_ty(id, t_1);\n         return\n     }\n@@ -1582,14 +1525,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn err_count_since_creation(&self) -> uint {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n-\n-    pub fn vtable_context<'a>(&'a self) -> VtableContext<'a, 'tcx> {\n-        VtableContext {\n-            infcx: self.infcx(),\n-            param_env: &self.inh.param_env,\n-            unboxed_closures: &self.inh.unboxed_closures,\n-        }\n-    }\n }\n \n impl<'a, 'tcx> RegionScope for infer::InferCtxt<'a, 'tcx> {\n@@ -1629,6 +1564,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.inh.node_types.borrow_mut().insert(node_id, ty);\n     }\n \n+    pub fn write_object_cast(&self,\n+                             key: ast::NodeId,\n+                             trait_ref: Rc<ty::TraitRef>) {\n+        debug!(\"write_object_cast key={} trait_ref={}\",\n+               key, trait_ref.repr(self.tcx()));\n+        self.inh.object_cast_map.borrow_mut().insert(key, trait_ref);\n+    }\n+\n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts) {\n         if !substs.substs.is_noop() {\n             debug!(\"write_substs({}, {}) in fcx {}\",\n@@ -1651,10 +1594,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn write_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n+                                      span: Span,\n                                       derefs: uint) {\n         if derefs == 0 { return; }\n         self.write_adjustment(\n             node_id,\n+            span,\n             ty::AutoDerefRef(ty::AutoDerefRef {\n                 autoderefs: derefs,\n                 autoref: None })\n@@ -1663,11 +1608,109 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n+                            span: Span,\n                             adj: ty::AutoAdjustment) {\n         debug!(\"write_adjustment(node_id={:?}, adj={:?})\", node_id, adj);\n+\n+        // Careful: adjustments can imply trait obligations if we are\n+        // casting from a concrete type to an object type. I think\n+        // it'd probably be nicer to move the logic that creates the\n+        // obligation into the code that creates the adjustment, but\n+        // that's a bit awkward, so instead we go digging and pull the\n+        // obligation out here.\n+        self.register_adjustment_obligations(span, &adj);\n         self.inh.adjustments.borrow_mut().insert(node_id, adj);\n     }\n \n+    fn register_adjustment_obligations(&self,\n+                                       span: Span,\n+                                       adj: &ty::AutoAdjustment) {\n+        match *adj {\n+            ty::AutoAddEnv(..) => { }\n+            ty::AutoDerefRef(ref d_r) => {\n+                match d_r.autoref {\n+                    Some(ref a_r) => {\n+                        self.register_autoref_obligations(span, a_r);\n+                    }\n+                    None => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    fn register_autoref_obligations(&self,\n+                                    span: Span,\n+                                    autoref: &ty::AutoRef) {\n+        match *autoref {\n+            ty::AutoUnsize(ref unsize) => {\n+                self.register_unsize_obligations(span, unsize);\n+            }\n+            ty::AutoPtr(_, _, None) |\n+            ty::AutoUnsafe(_, None) => {\n+            }\n+            ty::AutoPtr(_, _, Some(ref a_r)) |\n+            ty::AutoUnsafe(_, Some(ref a_r)) => {\n+                self.register_autoref_obligations(span, &**a_r)\n+            }\n+            ty::AutoUnsizeUniq(ref unsize) => {\n+                self.register_unsize_obligations(span, unsize);\n+            }\n+        }\n+    }\n+\n+    fn register_unsize_obligations(&self,\n+                                   span: Span,\n+                                   unsize: &ty::UnsizeKind) {\n+        debug!(\"register_unsize_obligations: unsize={:?}\", unsize);\n+\n+        match *unsize {\n+            ty::UnsizeLength(..) => {}\n+            ty::UnsizeStruct(ref u, _) => {\n+                self.register_unsize_obligations(span, &**u)\n+            }\n+            ty::UnsizeVtable(ref ty_trait, self_ty) => {\n+                vtable2::register_object_cast_obligations(self,\n+                                                          span,\n+                                                          ty_trait,\n+                                                          self_ty);\n+            }\n+        }\n+    }\n+\n+    pub fn instantiate_item_type(&self,\n+                                 span: Span,\n+                                 def_id: ast::DefId)\n+                                 -> TypeAndSubsts\n+    {\n+        /*!\n+         * Returns the type of `def_id` with all generics replaced by\n+         * by fresh type/region variables. Also returns the\n+         * substitution from the type parameters on `def_id` to the\n+         * fresh variables.  Registers any trait obligations specified\n+         * on `def_id` at the same time.\n+         */\n+\n+        let polytype =\n+            ty::lookup_item_type(self.tcx(), def_id);\n+        let substs =\n+            self.infcx().fresh_substs_for_generics(\n+                span,\n+                &polytype.generics);\n+        self.add_obligations_for_parameters(\n+            traits::ObligationCause::new(\n+                span,\n+                traits::ItemObligation(def_id)),\n+            &substs,\n+            &polytype.generics);\n+        let monotype =\n+            polytype.ty.subst(self.tcx(), &substs);\n+\n+        TypeAndSubsts {\n+            ty: monotype,\n+            substs: substs\n+        }\n+    }\n+\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_nil());\n     }\n@@ -1678,8 +1721,56 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.write_ty(node_id, ty::mk_err());\n     }\n \n+    pub fn require_type_meets(&self,\n+                              ty: ty::t,\n+                              span: Span,\n+                              code: traits::ObligationCauseCode,\n+                              bound: ty::BuiltinBound)\n+    {\n+        self.register_obligation(\n+            traits::obligation_for_builtin_bound(\n+                self.tcx(),\n+                traits::ObligationCause::new(span, code),\n+                ty,\n+                bound));\n+    }\n+\n+    pub fn require_type_is_sized(&self,\n+                                 ty: ty::t,\n+                                 span: Span,\n+                                 code: traits::ObligationCauseCode)\n+    {\n+        self.require_type_meets(ty, span, code, ty::BoundSized);\n+    }\n+\n+    pub fn require_expr_have_sized_type(&self,\n+                                        expr: &ast::Expr,\n+                                        code: traits::ObligationCauseCode)\n+    {\n+        self.require_type_is_sized(self.expr_ty(expr), expr.span, code);\n+    }\n+\n+    pub fn register_obligation(&self,\n+                               obligation: traits::Obligation)\n+    {\n+        debug!(\"register_obligation({})\",\n+               obligation.repr(self.tcx()));\n+\n+        self.inh.fulfillment_cx\n+            .borrow_mut()\n+            .register_obligation(self.tcx(), obligation);\n+    }\n+\n     pub fn to_ty(&self, ast_t: &ast::Ty) -> ty::t {\n-        ast_ty_to_ty(self, self.infcx(), ast_t)\n+        let t = ast_ty_to_ty(self, self.infcx(), ast_t);\n+\n+        let mut bounds_checker = wf::BoundsChecker::new(self,\n+                                                        ast_t.span,\n+                                                        self.body_id,\n+                                                        None);\n+        bounds_checker.check_ty(t);\n+\n+        t\n     }\n \n     pub fn pat_to_string(&self, pat: &ast::Pat) -> String {\n@@ -1761,7 +1852,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Ok(None) => Ok(()),\n             Err(ref e) => Err((*e)),\n             Ok(Some(adjustment)) => {\n-                self.write_adjustment(expr.id, adjustment);\n+                self.write_adjustment(expr.id, expr.span, adjustment);\n                 Ok(())\n             }\n         }\n@@ -1829,10 +1920,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                   origin: origin });\n     }\n \n-    pub fn add_region_obligations_for_parameters(&self,\n-                                                 span: Span,\n-                                                 substs: &Substs,\n-                                                 generics: &ty::Generics)\n+    pub fn add_obligations_for_parameters(&self,\n+                                          cause: traits::ObligationCause,\n+                                          substs: &Substs,\n+                                          generics: &ty::Generics)\n     {\n         /*!\n          * Given a set of generic parameter definitions (`generics`)\n@@ -1853,10 +1944,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n          * locally.\n          */\n \n-        debug!(\"add_region_obligations_for_parameters(substs={}, generics={})\",\n+        debug!(\"add_obligations_for_parameters(substs={}, generics={})\",\n                substs.repr(self.tcx()),\n                generics.repr(self.tcx()));\n \n+        self.add_trait_obligations_for_generics(cause, substs, generics);\n+        self.add_region_obligations_for_generics(cause, substs, generics);\n+    }\n+\n+    fn add_trait_obligations_for_generics(&self,\n+                                          cause: traits::ObligationCause,\n+                                          substs: &Substs,\n+                                          generics: &ty::Generics) {\n+        let obligations =\n+            traits::obligations_for_generics(self.tcx(),\n+                                             cause,\n+                                             generics,\n+                                             substs);\n+        obligations.map_move(|o| self.register_obligation(o));\n+    }\n+\n+    fn add_region_obligations_for_generics(&self,\n+                                           cause: traits::ObligationCause,\n+                                           substs: &Substs,\n+                                           generics: &ty::Generics)\n+    {\n         assert_eq!(generics.types.iter().len(),\n                    substs.types.iter().len());\n         for (type_def, &type_param) in\n@@ -1867,8 +1979,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                          idx: type_def.index,\n                                          def_id: type_def.def_id };\n             let bounds = type_def.bounds.subst(self.tcx(), substs);\n-            add_region_obligations_for_type_parameter(\n-                self, span, param_ty, &bounds, type_param);\n+            self.add_region_obligations_for_type_parameter(\n+                cause.span, param_ty, &bounds, type_param);\n         }\n \n         assert_eq!(generics.regions.iter().len(),\n@@ -1878,42 +1990,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 substs.regions().iter())\n         {\n             let bounds = region_def.bounds.subst(self.tcx(), substs);\n-            add_region_obligations_for_region_parameter(\n-                self, span, bounds.as_slice(), region_param);\n-        }\n-\n-        fn add_region_obligations_for_type_parameter(\n-            fcx: &FnCtxt,\n-            span: Span,\n-            param_ty: ty::ParamTy,\n-            param_bound: &ty::ParamBounds,\n-            ty: ty::t)\n-        {\n-            // For each declared region bound `T:r`, `T` must outlive `r`.\n-            let region_bounds =\n-                ty::required_region_bounds(\n-                    fcx.tcx(),\n-                    param_bound.opt_region_bound.as_slice(),\n-                    param_bound.builtin_bounds,\n-                    param_bound.trait_bounds.as_slice());\n-            for &r in region_bounds.iter() {\n-                let origin = infer::RelateParamBound(span, param_ty, ty);\n-                fcx.register_region_obligation(origin, ty, r);\n-            }\n+            self.add_region_obligations_for_region_parameter(\n+                cause.span, bounds.as_slice(), region_param);\n         }\n+    }\n \n-        fn add_region_obligations_for_region_parameter(\n-            fcx: &FnCtxt,\n-            span: Span,\n-            region_bounds: &[ty::Region],\n-            region_param: ty::Region)\n-        {\n-            for &b in region_bounds.iter() {\n-                // For each bound `region:b`, `b <= region` must hold\n-                // (i.e., `region` must outlive `b`).\n-                let origin = infer::RelateRegionParamBound(span);\n-                fcx.mk_subr(origin, b, region_param);\n-            }\n+    fn add_region_obligations_for_type_parameter(&self,\n+                                                 span: Span,\n+                                                 param_ty: ty::ParamTy,\n+                                                 param_bound: &ty::ParamBounds,\n+                                                 ty: ty::t)\n+    {\n+        // For each declared region bound `T:r`, `T` must outlive `r`.\n+        let region_bounds =\n+            ty::required_region_bounds(\n+                self.tcx(),\n+                param_bound.opt_region_bound.as_slice(),\n+                param_bound.builtin_bounds,\n+                param_bound.trait_bounds.as_slice());\n+        for &r in region_bounds.iter() {\n+            let origin = infer::RelateParamBound(span, param_ty, ty);\n+            self.register_region_obligation(origin, ty, r);\n+        }\n+    }\n+\n+    fn add_region_obligations_for_region_parameter(&self,\n+                                                   span: Span,\n+                                                   region_bounds: &[ty::Region],\n+                                                   region_param: ty::Region)\n+    {\n+        for &b in region_bounds.iter() {\n+            // For each bound `region:b`, `b <= region` must hold\n+            // (i.e., `region` must outlive `b`).\n+            let origin = infer::RelateRegionParamBound(span);\n+            self.mk_subr(origin, b, region_param);\n         }\n     }\n }\n@@ -2272,7 +2382,7 @@ fn check_method_argument_types(fcx: &FnCtxt,\n fn check_argument_types(fcx: &FnCtxt,\n                         sp: Span,\n                         fn_inputs: &[ty::t],\n-                        callee_expr: &ast::Expr,\n+                        _callee_expr: &ast::Expr,\n                         args: &[P<ast::Expr>],\n                         deref_args: DerefArgs,\n                         variadic: bool,\n@@ -2369,7 +2479,7 @@ fn check_argument_types(fcx: &FnCtxt,\n         // an \"opportunistic\" vtable resolution of any trait\n         // bounds on the call.\n         if check_blocks {\n-            vtable::early_resolve_expr(callee_expr, fcx, true);\n+            vtable2::select_fcx_obligations_where_possible(fcx);\n         }\n \n         // For variadic functions, we don't have a declared type for all of\n@@ -2568,25 +2678,24 @@ fn check_expr_with_lvalue_pref(fcx: &FnCtxt, expr: &ast::Expr,\n     check_expr_with_unifier(fcx, expr, NoExpectation, lvalue_pref, || ())\n }\n \n-\n // determine the `self` type, using fresh variables for all variables\n // declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-pub fn impl_self_ty(vcx: &VtableContext,\n+pub fn impl_self_ty(fcx: &FnCtxt,\n                     span: Span, // (potential) receiver for this impl\n                     did: ast::DefId)\n                     -> TypeAndSubsts {\n-    let tcx = vcx.tcx();\n+    let tcx = fcx.tcx();\n \n     let ity = ty::lookup_item_type(tcx, did);\n     let (n_tps, rps, raw_ty) =\n         (ity.generics.types.len(subst::TypeSpace),\n          ity.generics.regions.get_slice(subst::TypeSpace),\n          ity.ty);\n \n-    let rps = vcx.infcx.region_vars_for_defs(span, rps);\n-    let tps = vcx.infcx.next_ty_vars(n_tps);\n+    let rps = fcx.inh.infcx.region_vars_for_defs(span, rps);\n+    let tps = fcx.inh.infcx.next_ty_vars(n_tps);\n     let substs = subst::Substs::new_type(tps, rps);\n     let substd_ty = raw_ty.subst(tcx, &substs);\n \n@@ -3260,7 +3369,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         match field_ty {\n             Some(field_ty) => {\n                 fcx.write_ty(expr.id, field_ty);\n-                fcx.write_autoderef_adjustment(base.id, autoderefs);\n+                fcx.write_autoderef_adjustment(base.id, base.span, autoderefs);\n                 return;\n             }\n             None => {}\n@@ -3344,7 +3453,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         match field_ty {\n             Some(field_ty) => {\n                 fcx.write_ty(expr.id, field_ty);\n-                fcx.write_autoderef_adjustment(base.id, autoderefs);\n+                fcx.write_autoderef_adjustment(base.id, base.span, autoderefs);\n                 return;\n             }\n             None => {}\n@@ -3467,15 +3576,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                 base_expr: Option<&ast::Expr>) {\n         let tcx = fcx.ccx.tcx;\n \n-        // Look up the number of type parameters and the raw type, and\n-        // determine whether the class is region-parameterized.\n-        let item_type = ty::lookup_item_type(tcx, class_id);\n-        let raw_type = item_type.ty;\n-\n         // Generate the struct type.\n-        let substitutions = fcx.infcx().fresh_substs_for_type(\n-            span, &item_type.generics);\n-        let mut struct_type = raw_type.subst(tcx, &substitutions);\n+        let TypeAndSubsts {\n+            ty: mut struct_type,\n+            substs: struct_substs\n+        } = fcx.instantiate_item_type(span, class_id);\n \n         // Look up and check the fields.\n         let class_fields = ty::lookup_struct_fields(tcx, class_id);\n@@ -3484,7 +3589,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                        span,\n                                        class_id,\n                                        id,\n-                                       substitutions,\n+                                       struct_substs,\n                                        class_fields.as_slice(),\n                                        fields,\n                                        base_expr.is_none());\n@@ -3517,9 +3622,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         // Look up the number of type parameters and the raw type, and\n         // determine whether the enum is region-parameterized.\n-        let item_type = ty::lookup_item_type(tcx, enum_id);\n-        let substitutions = fcx.infcx().fresh_substs_for_type(span, &item_type.generics);\n-        let enum_type = item_type.ty.subst(tcx, &substitutions);\n+        let TypeAndSubsts {\n+            ty: enum_type,\n+            substs: substitutions\n+        } = fcx.instantiate_item_type(span, enum_id);\n \n         // Look up and check the enum variant fields.\n         let variant_fields = ty::lookup_struct_fields(tcx, variant_id);\n@@ -3619,6 +3725,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             span_err!(tcx.sess, lhs.span, E0067, \"illegal left-hand side expression\");\n         }\n \n+        fcx.require_expr_have_sized_type(&**lhs, traits::AssignmentLhsSized);\n+\n         // Overwrite result of check_binop...this preserves existing behavior\n         // but seems quite dubious with regard to user-defined methods\n         // and so forth. - Niko\n@@ -3833,6 +3941,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         check_expr_has_type(fcx, &**rhs, lhs_ty);\n         let rhs_ty = fcx.expr_ty(&**rhs);\n \n+        fcx.require_expr_have_sized_type(&**lhs, traits::AssignmentLhsSized);\n+\n         if ty::type_is_error(lhs_ty) || ty::type_is_error(rhs_ty) {\n             fcx.write_error(id);\n         } else if ty::type_is_bot(lhs_ty) || ty::type_is_bot(rhs_ty) {\n@@ -3863,7 +3973,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprForLoop(ref pat, ref head, ref block, _) => {\n         check_expr(fcx, &**head);\n         let typ = lookup_method_for_for_loop(fcx, &**head, expr.id);\n-        vtable::early_resolve_expr(expr, fcx, true);\n+        vtable2::select_fcx_obligations_where_possible(fcx);\n \n         let pcx = pat_ctxt {\n             fcx: fcx,\n@@ -3958,7 +4068,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             }\n             _ => {}\n         }\n-        check_cast(fcx, &**e, &**t, id, expr.span);\n+        check_cast(fcx, expr, &**e, &**t);\n       }\n       ast::ExprVec(ref args) => {\n         let uty = match expected {\n@@ -4015,6 +4125,16 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             }\n         };\n \n+        if count > 1 {\n+            // For [foo, ..n] where n > 1, `foo` must have\n+            // Copy type:\n+            fcx.require_type_meets(\n+                t,\n+                expr.span,\n+                traits::RepeatVec,\n+                ty::BoundCopy);\n+        }\n+\n         if ty::type_is_error(element_ty) {\n             fcx.write_error(id);\n         } else if ty::type_is_bot(element_ty) {\n@@ -4143,6 +4263,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 }\n             }\n         }\n+\n+        fcx.require_expr_have_sized_type(expr, traits::StructInitializerSized);\n       }\n       ast::ExprField(ref base, ref field, ref tys) => {\n         check_field(fcx, expr, lvalue_pref, &**base, field, tys.as_slice());\n@@ -4167,7 +4289,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                   Some(ty) => {\n                       check_expr_has_type(fcx, &**idx, ty::mk_uint());\n                       fcx.write_ty(id, ty);\n-                      fcx.write_autoderef_adjustment(base.id, autoderefs);\n+                      fcx.write_autoderef_adjustment(base.id, base.span, autoderefs);\n                   }\n                   None => {\n                       // This is an overloaded method.\n@@ -4520,8 +4642,10 @@ pub fn check_const_with_ty(fcx: &FnCtxt,\n \n     check_expr_with_hint(fcx, e, declty);\n     demand::coerce(fcx, e.span, declty, e);\n+    vtable2::select_all_fcx_obligations_or_error(fcx);\n     regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n+    vtable2::check_builtin_bound_obligations(fcx);\n }\n \n /// Checks whether a type can be represented in memory. In particular, it\n@@ -5009,8 +5133,11 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         assert_eq!(substs.regions().len(space), region_defs.len(space));\n     }\n \n-    fcx.add_region_obligations_for_parameters(\n-        span, &substs, &polytype.generics);\n+    fcx.add_obligations_for_parameters(\n+        traits::ObligationCause::new(span,\n+                                     traits::ItemObligation(def.def_id())),\n+        &substs,\n+        &polytype.generics);\n \n     fcx.write_ty_substs(node_id, polytype.ty, ty::ItemSubsts {\n         substs: substs,"}, {"sha": "45ffddf3fe80e57d881a9526dc3727149a7dfce7", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -155,18 +155,9 @@ pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     fcx.infcx().resolve_regions_and_report_errors();\n }\n \n-pub fn regionck_type_defn(fcx: &FnCtxt,\n-                          span: Span,\n-                          component_tys: &[ty::t]) {\n-    let mut rcx = Rcx::new(fcx, 0);\n-    for &component_ty in component_tys.iter() {\n-        // Check that each type outlives the empty region. Since the\n-        // empty region is a subregion of all others, this can't fail\n-        // unless the type does not meet the well-formedness\n-        // requirements.\n-        type_must_outlive(&mut rcx, infer::RelateRegionParamBound(span),\n-                          component_ty, ty::ReEmpty);\n-    }\n+pub fn regionck_item(fcx: &FnCtxt, item: &ast::Item) {\n+    let mut rcx = Rcx::new(fcx, item.id);\n+    rcx.visit_region_obligations(item.id);\n     fcx.infcx().resolve_regions_and_report_errors();\n }\n \n@@ -179,6 +170,26 @@ pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, blk: &ast::Block) {\n     fcx.infcx().resolve_regions_and_report_errors();\n }\n \n+pub fn regionck_ensure_component_tys_wf(fcx: &FnCtxt,\n+                                        span: Span,\n+                                        component_tys: &[ty::t]) {\n+    /*!\n+     * Checks that the types in `component_tys` are well-formed.\n+     * This will add constraints into the region graph.\n+     * Does *not* run `resolve_regions_and_report_errors` and so forth.\n+     */\n+\n+    let mut rcx = Rcx::new(fcx, 0);\n+    for &component_ty in component_tys.iter() {\n+        // Check that each type outlives the empty region. Since the\n+        // empty region is a subregion of all others, this can't fail\n+        // unless the type does not meet the well-formedness\n+        // requirements.\n+        type_must_outlive(&mut rcx, infer::RelateRegionParamBound(span),\n+                          component_ty, ty::ReEmpty);\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n "}, {"sha": "9a70cf574fc4d942ecae922180f0eb7a0fa79aef", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "removed", "additions": 0, "deletions": 1077, "changes": 1077, "blob_url": "https://github.com/rust-lang/rust/blob/cdd46f8592a0ca7eb69110bff0569094951ccc67/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd46f8592a0ca7eb69110bff0569094951ccc67/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=cdd46f8592a0ca7eb69110bff0569094951ccc67", "patch": "@@ -1,1077 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-use middle::ty;\n-use middle::ty::{AutoDerefRef, ParamTy};\n-use middle::ty_fold::TypeFolder;\n-use middle::typeck::astconv::AstConv;\n-use middle::typeck::check::{FnCtxt, impl_self_ty};\n-use middle::typeck::check::{structurally_resolved_type};\n-use middle::typeck::check::regionmanip;\n-use middle::typeck::check::writeback;\n-use middle::typeck::infer::fixup_err_to_string;\n-use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n-use middle::typeck::infer;\n-use middle::typeck::{MethodCall, TypeAndSubsts};\n-use middle::typeck::{param_index, vtable_error, vtable_origin, vtable_param};\n-use middle::typeck::{vtable_param_res, vtable_res, vtable_static};\n-use middle::typeck::{vtable_unboxed_closure};\n-use middle::subst;\n-use middle::subst::{Subst, VecPerParamSpace};\n-use util::common::indenter;\n-use util::nodemap::DefIdMap;\n-use util::ppaux;\n-use util::ppaux::Repr;\n-\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-use std::collections::HashSet;\n-use syntax::ast;\n-use syntax::ast_util;\n-use syntax::codemap::Span;\n-use syntax::print::pprust::expr_to_string;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n-\n-// vtable resolution looks for places where trait bounds are\n-// substituted in and figures out which vtable is used. There is some\n-// extra complication thrown in to support early \"opportunistic\"\n-// vtable resolution. This is a hacky mechanism that is invoked while\n-// typechecking function calls (after typechecking non-closure\n-// arguments and before typechecking closure arguments) in the hope of\n-// solving for the trait parameters from the impl. (For example,\n-// determining that if a parameter bounded by BaseIter<A> is\n-// instantiated with Option<int>, that A = int.)\n-//\n-// In early resolution mode, no vtables are recorded, and a number of\n-// errors are ignored. Early resolution only works if a type is\n-// *fully* resolved. (We could be less restrictive than that, but it\n-// would require much more care, and this seems to work decently in\n-// practice.)\n-//\n-// While resolution on a single type requires the type to be fully\n-// resolved, when resolving a substitution against a list of bounds,\n-// we do not require all of the types to be resolved in advance.\n-// Furthermore, we process substitutions in reverse order, which\n-// allows resolution on later parameters to give information on\n-// earlier params referenced by the typeclass bounds.\n-// It may be better to do something more clever, like processing fully\n-// resolved types first.\n-\n-/// A vtable context includes an inference context, a parameter environment,\n-/// and a list of unboxed closure types.\n-pub struct VtableContext<'a, 'tcx: 'a> {\n-    pub infcx: &'a infer::InferCtxt<'a, 'tcx>,\n-    pub param_env: &'a ty::ParameterEnvironment,\n-    pub unboxed_closures: &'a RefCell<DefIdMap<ty::UnboxedClosure>>,\n-}\n-\n-impl<'a, 'tcx> VtableContext<'a, 'tcx> {\n-    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.infcx.tcx }\n-}\n-\n-fn lookup_vtables(vcx: &VtableContext,\n-                  span: Span,\n-                  type_param_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n-                  substs: &subst::Substs,\n-                  is_early: bool)\n-                  -> VecPerParamSpace<vtable_param_res> {\n-    debug!(\"lookup_vtables(\\\n-           type_param_defs={}, \\\n-           substs={}\",\n-           type_param_defs.repr(vcx.tcx()),\n-           substs.repr(vcx.tcx()));\n-\n-    // We do this backwards for reasons discussed above.\n-    let result = type_param_defs.map_rev(|def| {\n-        let ty = *substs.types.get(def.space, def.index);\n-        lookup_vtables_for_param(vcx, span, Some(substs),\n-                                 &def.bounds, ty, is_early)\n-    });\n-\n-    debug!(\"lookup_vtables result(\\\n-            type_param_defs={}, \\\n-            substs={}, \\\n-            result={})\",\n-           type_param_defs.repr(vcx.tcx()),\n-           substs.repr(vcx.tcx()),\n-           result.repr(vcx.tcx()));\n-\n-    result\n-}\n-\n-fn lookup_vtables_for_param(vcx: &VtableContext,\n-                            span: Span,\n-                            // None for substs means the identity\n-                            substs: Option<&subst::Substs>,\n-                            type_param_bounds: &ty::ParamBounds,\n-                            ty: ty::t,\n-                            is_early: bool)\n-                            -> vtable_param_res {\n-    let tcx = vcx.tcx();\n-\n-    debug!(\"lookup_vtables_for_param(ty={}, type_param_bounds={}, is_early={})\",\n-           ty.repr(vcx.tcx()),\n-           type_param_bounds.repr(vcx.tcx()),\n-           is_early);\n-\n-    // ty is the value supplied for the type parameter A...\n-    let mut param_result = Vec::new();\n-\n-    ty::each_bound_trait_and_supertraits(tcx,\n-                                         type_param_bounds.trait_bounds\n-                                                          .as_slice(),\n-                                         |trait_ref| {\n-        // ...and here trait_ref is each bound that was declared on A,\n-        // expressed in terms of the type parameters.\n-\n-        debug!(\"matching ty={} trait_ref={}\",\n-               ty.repr(vcx.tcx()),\n-               trait_ref.repr(vcx.tcx()));\n-\n-        ty::populate_implementations_for_trait_if_necessary(tcx,\n-                                                            trait_ref.def_id);\n-\n-        // Substitute the values of the type parameters that may\n-        // appear in the bound.\n-        let trait_ref = substs.as_ref().map_or(trait_ref.clone(), |substs| {\n-            debug!(\"about to subst: {}, {}\",\n-                   trait_ref.repr(tcx), substs.repr(tcx));\n-            trait_ref.subst(tcx, *substs)\n-        });\n-\n-        debug!(\"after subst: {}\", trait_ref.repr(tcx));\n-\n-        match lookup_vtable(vcx, span, ty, trait_ref.clone(), is_early) {\n-            Some(vtable) => param_result.push(vtable),\n-            None => {\n-                vcx.tcx().sess.span_err(span,\n-                    format!(\"failed to find an implementation of \\\n-                          trait {} for {}\",\n-                         vcx.infcx.trait_ref_to_string(&*trait_ref),\n-                         vcx.infcx.ty_to_string(ty)).as_slice());\n-                param_result.push(vtable_error)\n-            }\n-        }\n-        true\n-    });\n-\n-    debug!(\"lookup_vtables_for_param result(\\\n-            type_param_bounds={}, \\\n-            ty={}, \\\n-            result={})\",\n-           type_param_bounds.repr(vcx.tcx()),\n-           ty.repr(vcx.tcx()),\n-           param_result.repr(vcx.tcx()));\n-\n-    param_result\n-}\n-\n-fn relate_trait_refs(vcx: &VtableContext,\n-                     span: Span,\n-                     act_trait_ref: Rc<ty::TraitRef>,\n-                     exp_trait_ref: Rc<ty::TraitRef>) {\n-    /*!\n-     *\n-     * Checks that an implementation of `act_trait_ref` is suitable\n-     * for use where `exp_trait_ref` is required and reports an\n-     * error otherwise.\n-     */\n-\n-    match infer::mk_sub_trait_refs(vcx.infcx,\n-                                   false,\n-                                   infer::RelateTraitRefs(span),\n-                                   act_trait_ref.clone(),\n-                                   exp_trait_ref.clone()) {\n-        Ok(()) => {} // Ok.\n-        Err(ref err) => {\n-            // There is an error, but we need to do some work to make\n-            // the message good.\n-            // Resolve any type vars in the trait refs\n-            let r_act_trait_ref =\n-                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(&*act_trait_ref);\n-            let r_exp_trait_ref =\n-                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(&*exp_trait_ref);\n-            // Only print the message if there aren't any previous type errors\n-            // inside the types.\n-            if !ty::trait_ref_contains_error(&r_act_trait_ref) &&\n-                !ty::trait_ref_contains_error(&r_exp_trait_ref)\n-            {\n-                let tcx = vcx.tcx();\n-                span_err!(tcx.sess, span, E0095, \"expected {}, found {} ({})\",\n-                          ppaux::trait_ref_to_string(tcx, &r_exp_trait_ref),\n-                          ppaux::trait_ref_to_string(tcx, &r_act_trait_ref),\n-                          ty::type_err_to_str(tcx, err));\n-            }\n-        }\n-    }\n-}\n-\n-// Look up the vtable implementing the trait `trait_ref` at type `t`\n-fn lookup_vtable(vcx: &VtableContext,\n-                 span: Span,\n-                 ty: ty::t,\n-                 trait_ref: Rc<ty::TraitRef>,\n-                 is_early: bool)\n-                 -> Option<vtable_origin>\n-{\n-    debug!(\"lookup_vtable(ty={}, trait_ref={})\",\n-           ty.repr(vcx.tcx()),\n-           trait_ref.repr(vcx.tcx()));\n-    let _i = indenter();\n-\n-    let ty = match fixup_ty(vcx, span, ty, is_early) {\n-        Some(ty) => ty,\n-        None => {\n-            // fixup_ty can only fail if this is early resolution\n-            assert!(is_early);\n-            // The type has unconstrained type variables in it, so we can't\n-            // do early resolution on it. Return some completely bogus vtable\n-            // information: we aren't storing it anyways.\n-            return Some(vtable_error);\n-        }\n-    };\n-\n-    if ty::type_is_error(ty) {\n-        return Some(vtable_error);\n-    }\n-\n-    // If the type is self or a param, we look at the trait/supertrait\n-    // bounds to see if they include the trait we are looking for.\n-    let vtable_opt = match ty::get(ty).sty {\n-        ty::ty_param(ParamTy {space, idx: n, ..}) => {\n-            let env_bounds = &vcx.param_env.bounds;\n-            let type_param_bounds = &env_bounds.get(space, n).trait_bounds;\n-            lookup_vtable_from_bounds(vcx,\n-                                      span,\n-                                      type_param_bounds.as_slice(),\n-                                      param_index {\n-                                          space: space,\n-                                          index: n,\n-                                      },\n-                                      trait_ref.clone())\n-        }\n-\n-        // Default case just falls through\n-        _ => None\n-    };\n-\n-    if vtable_opt.is_some() { return vtable_opt; }\n-\n-    // If we aren't a self type or param, or it was, but we didn't find it,\n-    // do a search.\n-    search_for_vtable(vcx, span, ty, trait_ref, is_early)\n-}\n-\n-// Given a list of bounds on a type, search those bounds to see if any\n-// of them are the vtable we are looking for.\n-fn lookup_vtable_from_bounds(vcx: &VtableContext,\n-                             span: Span,\n-                             bounds: &[Rc<ty::TraitRef>],\n-                             param: param_index,\n-                             trait_ref: Rc<ty::TraitRef>)\n-                             -> Option<vtable_origin> {\n-    let tcx = vcx.tcx();\n-\n-    let mut n_bound = 0;\n-    let mut ret = None;\n-    ty::each_bound_trait_and_supertraits(tcx, bounds, |bound_trait_ref| {\n-        debug!(\"checking bounds trait {}\",\n-               bound_trait_ref.repr(vcx.tcx()));\n-\n-        if bound_trait_ref.def_id == trait_ref.def_id {\n-            relate_trait_refs(vcx, span, bound_trait_ref, trait_ref.clone());\n-            let vtable = vtable_param(param, n_bound);\n-            debug!(\"found param vtable: {:?}\",\n-                   vtable);\n-            ret = Some(vtable);\n-            false\n-        } else {\n-            n_bound += 1;\n-            true\n-        }\n-    });\n-    ret\n-}\n-\n-fn search_for_unboxed_closure_vtable(vcx: &VtableContext,\n-                                     span: Span,\n-                                     ty: ty::t,\n-                                     trait_ref: Rc<ty::TraitRef>)\n-                                     -> Option<vtable_origin> {\n-    let tcx = vcx.tcx();\n-    let closure_def_id = match ty::get(ty).sty {\n-        ty::ty_unboxed_closure(closure_def_id, _) => closure_def_id,\n-        _ => return None,\n-    };\n-\n-    let fn_traits = [\n-        (ty::FnUnboxedClosureKind, tcx.lang_items.fn_trait()),\n-        (ty::FnMutUnboxedClosureKind, tcx.lang_items.fn_mut_trait()),\n-        (ty::FnOnceUnboxedClosureKind, tcx.lang_items.fn_once_trait()),\n-    ];\n-    for tuple in fn_traits.iter() {\n-        let kind = match tuple {\n-            &(kind, Some(ref fn_trait)) if *fn_trait == trait_ref.def_id => {\n-                kind\n-            }\n-            _ => continue,\n-        };\n-\n-        // Check to see whether the argument and return types match.\n-        let unboxed_closures = tcx.unboxed_closures.borrow();\n-        let closure_type = match unboxed_closures.find(&closure_def_id) {\n-            Some(closure) => {\n-                if closure.kind != kind {\n-                    continue\n-                }\n-                closure.closure_type.clone()\n-            }\n-            None => {\n-                // Try the inherited unboxed closure type map.\n-                let unboxed_closures = vcx.unboxed_closures.borrow();\n-                match unboxed_closures.find(&closure_def_id) {\n-                    Some(closure) => {\n-                        if closure.kind != kind {\n-                            continue\n-                        }\n-                        closure.closure_type.clone()\n-                    }\n-                    None => {\n-                        tcx.sess.span_bug(span,\n-                                          \"didn't find unboxed closure type \\\n-                                           in tcx map or inh map\")\n-                    }\n-                }\n-            }\n-        };\n-\n-        // FIXME(pcwalton): This is a bogus thing to do, but\n-        // it'll do for now until we get the new trait-bound\n-        // region skolemization working.\n-        let (_, new_signature) =\n-            regionmanip::replace_late_bound_regions_in_fn_sig(\n-                tcx,\n-                &closure_type.sig,\n-                |br| {\n-                    vcx.infcx.next_region_var(infer::LateBoundRegion(span,\n-                                                                     br))\n-                });\n-\n-        let arguments_tuple = *new_signature.inputs.get(0);\n-        let corresponding_trait_ref = Rc::new(ty::TraitRef {\n-            def_id: trait_ref.def_id,\n-            substs: subst::Substs::new_trait(\n-                vec![arguments_tuple, new_signature.output],\n-                Vec::new(),\n-                ty)\n-        });\n-\n-        relate_trait_refs(vcx, span, corresponding_trait_ref, trait_ref);\n-        return Some(vtable_unboxed_closure(closure_def_id))\n-    }\n-\n-    None\n-}\n-\n-fn search_for_vtable(vcx: &VtableContext,\n-                     span: Span,\n-                     ty: ty::t,\n-                     trait_ref: Rc<ty::TraitRef>,\n-                     is_early: bool)\n-                     -> Option<vtable_origin> {\n-    let tcx = vcx.tcx();\n-\n-    // First, check to see whether this is a call to the `call` method of an\n-    // unboxed closure. If so, and the arguments match, we're done.\n-    match search_for_unboxed_closure_vtable(vcx,\n-                                            span,\n-                                            ty,\n-                                            trait_ref.clone()) {\n-        Some(vtable_origin) => return Some(vtable_origin),\n-        None => {}\n-    }\n-\n-    // Nope. Continue.\n-\n-    let mut found = Vec::new();\n-    let mut impls_seen = HashSet::new();\n-\n-    // Load the implementations from external metadata if necessary.\n-    ty::populate_implementations_for_trait_if_necessary(tcx,\n-                                                        trait_ref.def_id);\n-\n-    let impls = match tcx.trait_impls.borrow().find_copy(&trait_ref.def_id) {\n-        Some(impls) => impls,\n-        None => {\n-            return None;\n-        }\n-    };\n-    // impls is the list of all impls in scope for trait_ref.\n-    for &impl_did in impls.borrow().iter() {\n-        // im is one specific impl of trait_ref.\n-\n-        // First, ensure we haven't processed this impl yet.\n-        if impls_seen.contains(&impl_did) {\n-            continue;\n-        }\n-        impls_seen.insert(impl_did);\n-\n-        // ty::impl_traits gives us the trait im implements.\n-        //\n-        // If foo implements a trait t, and if t is the same trait as\n-        // trait_ref, we need to unify it with trait_ref in order to\n-        // get all the ty vars sorted out.\n-        let r = ty::impl_trait_ref(tcx, impl_did);\n-        let of_trait_ref = r.expect(\"trait_ref missing on trait impl\");\n-        if of_trait_ref.def_id != trait_ref.def_id { continue; }\n-\n-        // At this point, we know that of_trait_ref is the same trait\n-        // as trait_ref, but possibly applied to different substs.\n-        //\n-        // Next, we check whether the \"for\" ty in the impl is\n-        // compatible with the type that we're casting to a\n-        // trait. That is, if im is:\n-        //\n-        // impl<T> some_trait<T> for self_ty<T> { ... }\n-        //\n-        // we check whether self_ty<T> is the type of the thing that\n-        // we're trying to cast to some_trait.  If not, then we try\n-        // the next impl.\n-        //\n-        // FIXME: document a bit more what this means\n-        let TypeAndSubsts {\n-            substs: substs,\n-            ty: for_ty\n-        } = impl_self_ty(vcx, span, impl_did);\n-        match infer::mk_eqty(vcx.infcx,\n-                             false,\n-                             infer::RelateSelfType(span),\n-                             ty,\n-                             for_ty) {\n-            Err(_) => continue,\n-            Ok(()) => ()\n-        }\n-\n-        // Now, in the previous example, for_ty is bound to\n-        // the type self_ty, and substs is bound to [T].\n-        debug!(\"The self ty is {} and its substs are {}\",\n-               for_ty.repr(tcx),\n-               substs.types.repr(tcx));\n-\n-        // Next, we unify trait_ref -- the type that we want to cast\n-        // to -- with of_trait_ref -- the trait that im implements. At\n-        // this point, we require that they be unifiable with each\n-        // other -- that's what relate_trait_refs does.\n-        //\n-        // For example, in the above example, of_trait_ref would be\n-        // some_trait<T>, so we would be unifying trait_ref<U> (for\n-        // some value of U) with some_trait<T>. This would fail if T\n-        // and U weren't compatible.\n-\n-        let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n-\n-        debug!(\"(checking vtable) num 2 relating trait \\\n-                ty {} to of_trait_ref {}\",\n-               vcx.infcx.trait_ref_to_string(&*trait_ref),\n-               vcx.infcx.trait_ref_to_string(&*of_trait_ref));\n-\n-        relate_trait_refs(vcx, span, of_trait_ref, trait_ref.clone());\n-\n-\n-        // Recall that trait_ref -- the trait type we're casting to --\n-        // is the trait with id trait_ref.def_id applied to the substs\n-        // trait_ref.substs.\n-\n-        // Resolve any sub bounds. Note that there still may be free\n-        // type variables in substs. This might still be OK: the\n-        // process of looking up bounds might constrain some of them.\n-        //\n-        // This does not check built-in traits because those are handled\n-        // later in the kind checking pass.\n-        let im_generics =\n-            ty::lookup_item_type(tcx, impl_did).generics;\n-        let subres = lookup_vtables(vcx,\n-                                    span,\n-                                    &im_generics.types,\n-                                    &substs,\n-                                    is_early);\n-\n-        // substs might contain type variables, so we call\n-        // fixup_substs to resolve them.\n-        let substs_f = match fixup_substs(vcx, span,\n-                                          trait_ref.def_id,\n-                                          substs,\n-                                          is_early) {\n-            Some(ref substs) => (*substs).clone(),\n-            None => {\n-                assert!(is_early);\n-                // Bail out with a bogus answer\n-                return Some(vtable_error);\n-            }\n-        };\n-\n-        debug!(\"The fixed-up substs are {} - \\\n-                they will be unified with the bounds for \\\n-                the target ty, {}\",\n-               substs_f.types.repr(tcx),\n-               trait_ref.repr(tcx));\n-\n-        // Next, we unify the fixed-up substitutions for the impl self\n-        // ty with the substitutions from the trait type that we're\n-        // trying to cast to. connect_trait_tps requires these lists\n-        // of types to unify pairwise.\n-        // I am a little confused about this, since it seems to be\n-        // very similar to the relate_trait_refs we already do,\n-        // but problems crop up if it is removed, so... -sully\n-        connect_trait_tps(vcx, span, &substs_f, trait_ref.clone(), impl_did);\n-\n-        // Finally, we register that we found a matching impl, and\n-        // record the def ID of the impl as well as the resolved list\n-        // of type substitutions for the target trait.\n-        found.push(vtable_static(impl_did, substs_f, subres));\n-    }\n-\n-    match found.len() {\n-        0 => { return None }\n-        1 => return Some(found.get(0).clone()),\n-        _ => {\n-            if !is_early {\n-                span_err!(vcx.tcx().sess, span, E0096,\n-                          \"multiple applicable methods in scope\");\n-            }\n-            return Some(found.get(0).clone());\n-        }\n-    }\n-}\n-\n-\n-fn fixup_substs(vcx: &VtableContext,\n-                span: Span,\n-                id: ast::DefId,\n-                substs: subst::Substs,\n-                is_early: bool)\n-                -> Option<subst::Substs> {\n-    let tcx = vcx.tcx();\n-    // use a dummy type just to package up the substs that need fixing up\n-    let t = ty::mk_trait(tcx,\n-                         id, substs,\n-                         ty::region_existential_bound(ty::ReStatic));\n-    fixup_ty(vcx, span, t, is_early).map(|t_f| {\n-        match ty::get(t_f).sty {\n-          ty::ty_trait(ref inner) => inner.substs.clone(),\n-          _ => fail!(\"t_f should be a trait\")\n-        }\n-    })\n-}\n-\n-fn fixup_ty(vcx: &VtableContext,\n-            span: Span,\n-            ty: ty::t,\n-            is_early: bool)\n-            -> Option<ty::t> {\n-    let tcx = vcx.tcx();\n-    match resolve_type(vcx.infcx, Some(span), ty, resolve_and_force_all_but_regions) {\n-        Ok(new_type) => Some(new_type),\n-        Err(e) if !is_early => {\n-            tcx.sess.span_err(span,\n-                format!(\"cannot determine a type for this bounded type \\\n-                         parameter: {}\",\n-                        fixup_err_to_string(e)).as_slice());\n-            Some(ty::mk_err())\n-        }\n-        Err(_) => {\n-            None\n-        }\n-    }\n-}\n-\n-fn connect_trait_tps(vcx: &VtableContext,\n-                     span: Span,\n-                     impl_substs: &subst::Substs,\n-                     trait_ref: Rc<ty::TraitRef>,\n-                     impl_did: ast::DefId) {\n-    let tcx = vcx.tcx();\n-\n-    let impl_trait_ref = match ty::impl_trait_ref(tcx, impl_did) {\n-        Some(t) => t,\n-        None => vcx.tcx().sess.span_bug(span,\n-                                  \"connect_trait_tps invoked on a type impl\")\n-    };\n-\n-    let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n-    relate_trait_refs(vcx, span, impl_trait_ref, trait_ref);\n-}\n-\n-fn insert_vtables(fcx: &FnCtxt, vtable_key: MethodCall, vtables: vtable_res) {\n-    debug!(\"insert_vtables(vtable_key={}, vtables={})\",\n-           vtable_key, vtables.repr(fcx.tcx()));\n-    fcx.inh.vtable_map.borrow_mut().insert(vtable_key, vtables);\n-}\n-\n-pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n-    fn mutability_allowed(a_mutbl: ast::Mutability,\n-                          b_mutbl: ast::Mutability) -> bool {\n-        a_mutbl == b_mutbl ||\n-        (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n-    }\n-\n-    debug!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n-           ex.id, is_early, expr_to_string(ex));\n-    let _indent = indenter();\n-\n-    let cx = fcx.ccx;\n-    let check_object_cast = |src_ty: ty::t, target_ty: ty::t| {\n-      debug!(\"check_object_cast {} to {}\",\n-             fcx.infcx().ty_to_string(src_ty),\n-             fcx.infcx().ty_to_string(target_ty));\n-      // Check that a cast is of correct types.\n-      match (&ty::get(target_ty).sty, &ty::get(src_ty).sty) {\n-          (&ty::ty_rptr(_, ty::mt{ty, mutbl}), &ty::ty_rptr(_, mt))\n-          | (&ty::ty_ptr(ty::mt{ty, mutbl}), &ty::ty_rptr(_, mt))\n-            if !mutability_allowed(mt.mutbl, mutbl) => {\n-              match ty::get(ty).sty {\n-                  ty::ty_trait(..) => {\n-                      span_err!(fcx.tcx().sess, ex.span, E0097, \"types differ in mutability\");\n-                  }\n-                  _ => {}\n-              }\n-          }\n-          (&ty::ty_uniq(..), &ty::ty_uniq(..) )\n-          | (&ty::ty_ptr(..), &ty::ty_ptr(..) )\n-          | (&ty::ty_ptr(..), &ty::ty_rptr(..)) => {}\n-          (&ty::ty_rptr(r_t, _), &ty::ty_rptr(r_s, _)) => {\n-              infer::mk_subr(fcx.infcx(),\n-                             infer::RelateObjectBound(ex.span),\n-                             r_t,\n-                             r_s);\n-          }\n-          (&ty::ty_uniq(ty), _) => {\n-              match ty::get(ty).sty {\n-                  ty::ty_trait(..) => {\n-                      span_err!(fcx.ccx.tcx.sess, ex.span, E0098,\n-                                \"can only cast an boxed pointer to a boxed object, not a {}\",\n-                                ty::ty_sort_string(fcx.tcx(), src_ty));\n-                  }\n-                  _ => {}\n-              }\n-\n-          }\n-          (&ty::ty_rptr(_, ty::mt{ty, ..}), _) => {\n-              match ty::get(ty).sty {\n-                  ty::ty_trait(..) => {\n-                      span_err!(fcx.ccx.tcx.sess, ex.span, E0099,\n-                                \"can only cast an &-pointer to an &-object, not a {}\",\n-                                ty::ty_sort_string(fcx.tcx(), src_ty));\n-                  }\n-                  _ => {}\n-              }\n-          }\n-          (&ty::ty_ptr(ty::mt{ty, ..}), _) => {\n-              match ty::get(ty).sty {\n-                  ty::ty_trait(..) => {\n-                      span_err!(fcx.ccx.tcx.sess, ex.span, E0160,\n-                                \"can only cast an *-pointer or &-pointer to an *-object, not a {}\",\n-                                ty::ty_sort_string(fcx.tcx(), src_ty));\n-                  }\n-                  _ => {}\n-              }\n-          }\n-          _ => {}\n-      }\n-    };\n-    let resolve_object_cast = |src_ty: ty::t, target_ty: ty::t, key: MethodCall| {\n-      // Look up vtables for the type we're casting to,\n-      // passing in the source and target type.  The source\n-      // must be a pointer type suitable to the object sigil,\n-      // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n-      // Bounds of type's contents are not checked here, but in kind.rs.\n-      match ty::get(target_ty).sty {\n-          ty::ty_trait(box ty::TyTrait {\n-              def_id: target_def_id, substs: ref target_substs, ..\n-          }) => {\n-              let vcx = fcx.vtable_context();\n-\n-              // Take the type parameters from the object\n-              // type, but set the Self type (which is\n-              // unknown, for the object type) to be the type\n-              // we are casting from.\n-              let mut target_types = target_substs.types.clone();\n-              assert!(target_types.get_self().is_none());\n-              target_types.push(subst::SelfSpace, src_ty);\n-\n-              let target_trait_ref = Rc::new(ty::TraitRef {\n-                  def_id: target_def_id,\n-                  substs: subst::Substs {\n-                      regions: target_substs.regions.clone(),\n-                      types: target_types\n-                  }\n-              });\n-\n-              let param_bounds = ty::ParamBounds {\n-                  opt_region_bound: None,\n-                  builtin_bounds: ty::empty_builtin_bounds(),\n-                  trait_bounds: vec!(target_trait_ref)\n-              };\n-\n-              let vtables =\n-                    lookup_vtables_for_param(&vcx,\n-                                             ex.span,\n-                                             None,\n-                                             &param_bounds,\n-                                             src_ty,\n-                                             is_early);\n-\n-              if !is_early {\n-                  let mut r = VecPerParamSpace::empty();\n-                  r.push(subst::SelfSpace, vtables);\n-                  insert_vtables(fcx, key, r);\n-              }\n-          }\n-          _ => {}\n-      }\n-    };\n-    match ex.node {\n-      ast::ExprPath(..) => {\n-        fcx.opt_node_ty_substs(ex.id, |item_substs| {\n-            debug!(\"vtable resolution on parameter bounds for expr {}\",\n-                   ex.repr(fcx.tcx()));\n-            let def = cx.tcx.def_map.borrow().get_copy(&ex.id);\n-            let did = def.def_id();\n-            let item_ty = ty::lookup_item_type(cx.tcx, did);\n-            debug!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n-                   fcx.infcx().ty_to_string(item_ty.ty));\n-            debug!(\"early_resolve_expr: looking up vtables for type params {}\",\n-                   item_ty.generics.types.repr(fcx.tcx()));\n-            let vcx = fcx.vtable_context();\n-            let vtbls = lookup_vtables(&vcx, ex.span,\n-                                       &item_ty.generics.types,\n-                                       &item_substs.substs, is_early);\n-            if !is_early {\n-                insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n-            }\n-        });\n-      }\n-\n-      // Must resolve bounds on methods with bounded params\n-      ast::ExprBinary(_, _, _) |\n-      ast::ExprUnary(_, _) |\n-      ast::ExprAssignOp(_, _, _) |\n-      ast::ExprIndex(_, _) |\n-      ast::ExprMethodCall(_, _, _) |\n-      ast::ExprForLoop(..) |\n-      ast::ExprCall(..) => {\n-        match fcx.inh.method_map.borrow().find(&MethodCall::expr(ex.id)) {\n-          Some(method) => {\n-              debug!(\"vtable resolution on parameter bounds for method call {}\",\n-                     ex.repr(fcx.tcx()));\n-              let type_param_defs =\n-                  ty::method_call_type_param_defs(fcx, method.origin);\n-              let substs = fcx.method_ty_substs(ex.id);\n-              let vcx = fcx.vtable_context();\n-              let vtbls = lookup_vtables(&vcx, ex.span,\n-                                         &type_param_defs,\n-                                         &substs, is_early);\n-              if !is_early {\n-                  insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n-              }\n-          }\n-          None => {}\n-        }\n-      }\n-      ast::ExprCast(ref src, _) => {\n-          debug!(\"vtable resolution on expr {}\", ex.repr(fcx.tcx()));\n-          let target_ty = fcx.expr_ty(ex);\n-          let src_ty = structurally_resolved_type(fcx, ex.span,\n-                                                  fcx.expr_ty(&**src));\n-          check_object_cast(src_ty, target_ty);\n-          match (ty::deref(src_ty, false), ty::deref(target_ty, false)) {\n-              (Some(s), Some(t)) => {\n-                  let key = MethodCall::expr(ex.id);\n-                  resolve_object_cast(s.ty, t.ty, key)\n-              }\n-              _ => {}\n-          }\n-      }\n-      _ => ()\n-    }\n-\n-    // Search for auto-adjustments to find trait coercions\n-    match fcx.inh.adjustments.borrow().find(&ex.id) {\n-        Some(adjustment) => {\n-            match *adjustment {\n-                _ if ty::adjust_is_object(adjustment) => {\n-                    let src_ty = structurally_resolved_type(fcx, ex.span,\n-                                                            fcx.expr_ty(ex));\n-                    match ty::type_of_adjust(fcx.tcx(), adjustment) {\n-                        Some(target_ty) => {\n-                            check_object_cast(src_ty, target_ty)\n-                        }\n-                        None => {}\n-                    }\n-\n-                    match trait_cast_types(fcx, adjustment, src_ty, ex.span) {\n-                        Some((s, t)) => {\n-                            let key = MethodCall::autoobject(ex.id);\n-                            resolve_object_cast(s, t, key)\n-                        }\n-                        None => fail!(\"Couldn't extract types from adjustment\")\n-                    }\n-                }\n-                AutoDerefRef(ref adj) => {\n-                    for autoderef in range(0, adj.autoderefs) {\n-                        let method_call = MethodCall::autoderef(ex.id, autoderef);\n-                        match fcx.inh.method_map.borrow().find(&method_call) {\n-                            Some(method) => {\n-                                debug!(\"vtable resolution on parameter bounds for autoderef {}\",\n-                                       ex.repr(fcx.tcx()));\n-                                let type_param_defs =\n-                                    ty::method_call_type_param_defs(cx.tcx, method.origin);\n-                                let vcx = fcx.vtable_context();\n-                                let vtbls = lookup_vtables(&vcx, ex.span,\n-                                                           &type_param_defs,\n-                                                           &method.substs, is_early);\n-                                if !is_early {\n-                                    insert_vtables(fcx, method_call, vtbls);\n-                                }\n-                            }\n-                            None => {}\n-                        }\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-        None => {}\n-    }\n-}\n-\n-// When we coerce (possibly implicitly) from a concrete type to a trait type, this\n-// function returns the concrete type and trait. This might happen arbitrarily\n-// deep in the adjustment. This function will fail if the adjustment does not\n-// match the source type.\n-// This function will always return types if ty::adjust_is_object is true for the\n-// adjustment\n-fn trait_cast_types(fcx: &FnCtxt,\n-                    adj: &ty::AutoAdjustment,\n-                    src_ty: ty::t,\n-                    sp: Span)\n-                    -> Option<(ty::t, ty::t)> {\n-    fn trait_cast_types_autoref(fcx: &FnCtxt,\n-                                autoref: &ty::AutoRef,\n-                                src_ty: ty::t,\n-                                sp: Span)\n-                                -> Option<(ty::t, ty::t)> {\n-        fn trait_cast_types_unsize(fcx: &FnCtxt,\n-                                   k: &ty::UnsizeKind,\n-                                   src_ty: ty::t,\n-                                   sp: Span)\n-                                   -> Option<(ty::t, ty::t)> {\n-            match k {\n-                &ty::UnsizeVtable(bounds, def_id, ref substs) => {\n-                    Some((src_ty, ty::mk_trait(fcx.tcx(), def_id, substs.clone(), bounds)))\n-                }\n-                &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(src_ty).sty {\n-                    ty::ty_struct(_, ref substs) => {\n-                        let ty_substs = substs.types.get_slice(subst::TypeSpace);\n-                        let field_ty = structurally_resolved_type(fcx, sp, ty_substs[tp_index]);\n-                        trait_cast_types_unsize(fcx, k, field_ty, sp)\n-                    }\n-                    _ => fail!(\"Failed to find a ty_struct to correspond with \\\n-                                UnsizeStruct whilst walking adjustment. Found {}\",\n-                                ppaux::ty_to_string(fcx.tcx(), src_ty))\n-                },\n-                _ => None\n-            }\n-        }\n-\n-        match autoref {\n-            &ty::AutoUnsize(ref k) |\n-            &ty::AutoUnsizeUniq(ref k) => trait_cast_types_unsize(fcx, k, src_ty, sp),\n-            &ty::AutoPtr(_, _, Some(box ref autoref)) |\n-            &ty::AutoUnsafe(_, Some(box ref autoref)) => {\n-                trait_cast_types_autoref(fcx, autoref, src_ty, sp)\n-            }\n-            _ => None\n-        }\n-    }\n-\n-    match adj {\n-        &ty::AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), autoderefs}) => {\n-            let mut derefed_type = src_ty;\n-            for _ in range(0, autoderefs) {\n-                derefed_type = ty::deref(derefed_type, true).unwrap().ty;\n-                derefed_type = structurally_resolved_type(fcx, sp, derefed_type)\n-            }\n-            trait_cast_types_autoref(fcx, autoref, derefed_type, sp)\n-        }\n-        _ => None\n-    }\n-}\n-\n-pub fn resolve_impl(tcx: &ty::ctxt,\n-                    impl_item: &ast::Item,\n-                    impl_generics: &ty::Generics,\n-                    impl_trait_ref: &ty::TraitRef) {\n-    /*!\n-     * The situation is as follows. We have some trait like:\n-     *\n-     *    trait Foo<A:Clone> : Bar {\n-     *        fn method() { ... }\n-     *    }\n-     *\n-     * and an impl like:\n-     *\n-     *    impl<B:Clone> Foo<B> for int { ... }\n-     *\n-     * We want to validate that the various requirements of the trait\n-     * are met:\n-     *\n-     *    A:Clone, Self:Bar\n-     *\n-     * But of course after substituting the types from the impl:\n-     *\n-     *    B:Clone, int:Bar\n-     *\n-     * We store these results away as the \"impl_res\" for use by the\n-     * default methods.\n-     */\n-\n-    debug!(\"resolve_impl(impl_item.id={})\",\n-           impl_item.id);\n-\n-    let param_env = ty::construct_parameter_environment(tcx,\n-                                                        impl_generics,\n-                                                        impl_item.id);\n-\n-    // The impl_trait_ref in our example above would be\n-    //     `Foo<B> for int`\n-    let impl_trait_ref = impl_trait_ref.subst(tcx, &param_env.free_substs);\n-    debug!(\"impl_trait_ref={}\", impl_trait_ref.repr(tcx));\n-\n-    let infcx = &infer::new_infer_ctxt(tcx);\n-    let unboxed_closures = RefCell::new(DefIdMap::new());\n-    let vcx = VtableContext {\n-        infcx: infcx,\n-        param_env: &param_env,\n-        unboxed_closures: &unboxed_closures,\n-    };\n-\n-    // Resolve the vtables for the trait reference on the impl.  This\n-    // serves many purposes, best explained by example. Imagine we have:\n-    //\n-    //    trait A<T:B> : C { fn x(&self) { ... } }\n-    //\n-    // and\n-    //\n-    //    impl A<int> for uint { ... }\n-    //\n-    // In that case, the trait ref will be `A<int> for uint`. Resolving\n-    // this will first check that the various types meet their requirements:\n-    //\n-    // 1. Because of T:B, int must implement the trait B\n-    // 2. Because of the supertrait C, uint must implement the trait C.\n-    //\n-    // Simultaneously, the result of this resolution (`vtbls`), is precisely\n-    // the set of vtable information needed to compile the default method\n-    // `x()` adapted to the impl. (After all, a default method is basically\n-    // the same as:\n-    //\n-    //     fn default_x<T:B, Self:A>(...) { .. .})\n-\n-    let trait_def = ty::lookup_trait_def(tcx, impl_trait_ref.def_id);\n-    let vtbls = lookup_vtables(&vcx,\n-                                   impl_item.span,\n-                                   &trait_def.generics.types,\n-                                   &impl_trait_ref.substs,\n-                                   false);\n-\n-    infcx.resolve_regions_and_report_errors();\n-\n-    let vtbls = writeback::resolve_impl_res(infcx, impl_item.span, &vtbls);\n-    let impl_def_id = ast_util::local_def(impl_item.id);\n-\n-    debug!(\"impl_vtables for {} are {}\",\n-           impl_def_id.repr(tcx),\n-           vtbls.repr(tcx));\n-\n-    tcx.impl_vtables.borrow_mut().insert(impl_def_id, vtbls);\n-}\n-\n-/// Resolve vtables for a method call after typeck has finished.\n-/// Used by trans to monomorphize artificial method callees (e.g. drop).\n-pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,\n-                            substs: &subst::Substs) -> vtable_res {\n-    let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;\n-    let unboxed_closures = RefCell::new(DefIdMap::new());\n-    let vcx = VtableContext {\n-        infcx: &infer::new_infer_ctxt(tcx),\n-        param_env: &ty::construct_parameter_environment(tcx, &ty::Generics::empty(), id),\n-        unboxed_closures: &unboxed_closures,\n-    };\n-\n-    lookup_vtables(&vcx,\n-                   tcx.map.span(id),\n-                   &generics.types,\n-                   substs,\n-                   false)\n-}\n-\n-impl<'a, 'b, 'tcx, 'v> Visitor<'v> for &'a FnCtxt<'b, 'tcx> {\n-    fn visit_expr(&mut self, ex: &ast::Expr) {\n-        early_resolve_expr(ex, *self, false);\n-        visit::walk_expr(self, ex);\n-    }\n-    fn visit_item(&mut self, _: &ast::Item) {\n-        // no-op\n-    }\n-}\n-\n-// Detect points where a trait-bounded type parameter is\n-// instantiated, resolve the impls for the parameters.\n-pub fn resolve_in_block(mut fcx: &FnCtxt, bl: &ast::Block) {\n-    visit::walk_block(&mut fcx, bl);\n-}\n-\n-/// Used in the kind checker after typechecking has finished. Calls\n-/// `any_missing` if any bounds were missing.\n-pub fn check_param_bounds(tcx: &ty::ctxt,\n-                          span: Span,\n-                          parameter_environment: &ty::ParameterEnvironment,\n-                          type_param_defs:\n-                            &VecPerParamSpace<ty::TypeParameterDef>,\n-                          substs: &subst::Substs,\n-                          any_missing: |&ty::TraitRef|) {\n-    let unboxed_closures = RefCell::new(DefIdMap::new());\n-    let vcx = VtableContext {\n-        infcx: &infer::new_infer_ctxt(tcx),\n-        param_env: parameter_environment,\n-        unboxed_closures: &unboxed_closures,\n-    };\n-    let vtable_param_results =\n-        lookup_vtables(&vcx, span, type_param_defs, substs, false);\n-    for (vtable_param_result, type_param_def) in\n-            vtable_param_results.iter().zip(type_param_defs.iter()) {\n-        for (vtable_result, trait_ref) in\n-                vtable_param_result.iter()\n-                                   .zip(type_param_def.bounds\n-                                                      .trait_bounds\n-                                                      .iter()) {\n-            match *vtable_result {\n-                vtable_error => any_missing(&**trait_ref),\n-                vtable_static(..) |\n-                vtable_param(..) |\n-                vtable_unboxed_closure(..) => {}\n-            }\n-        }\n-    }\n-}\n-"}, {"sha": "f75d2622fdb895520d4cb05ff24fa99d5c68d285", "filename": "src/librustc/middle/typeck/check/vtable2.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,407 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::subst::{SelfSpace};\n+use middle::traits;\n+use middle::traits::{SelectionError, Overflow,\n+                     OutputTypeParameterMismatch, Unimplemented};\n+use middle::traits::{Obligation, obligation_for_builtin_bound};\n+use middle::traits::{FulfillmentError, Ambiguity};\n+use middle::traits::{ObligationCause};\n+use middle::ty;\n+use middle::typeck::check::{FnCtxt,\n+                            structurally_resolved_type};\n+use middle::typeck::infer;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use util::ppaux::UserString;\n+use util::ppaux::Repr;\n+\n+/// When reporting an error about a failed trait obligation, it's nice\n+/// to include some context indicating why we were checking that\n+/// obligation in the first place. The span is often enough but\n+/// sometimes it's not. Currently this enum is a bit of a hack and I\n+/// suspect it should be carried in the obligation or more deeply\n+/// integrated somehow.\n+pub enum ErrorReportingContext {\n+    GenericContext,\n+    ImplSupertraitCheck,\n+}\n+\n+pub fn check_object_cast(fcx: &FnCtxt,\n+                         cast_expr: &ast::Expr,\n+                         source_expr: &ast::Expr,\n+                         target_object_ty: ty::t)\n+{\n+    debug!(\"check_object_cast(cast_expr={}, target_object_ty={})\",\n+           cast_expr.repr(fcx.tcx()),\n+           target_object_ty.repr(fcx.tcx()));\n+\n+    // Look up vtables for the type we're casting to,\n+    // passing in the source and target type.  The source\n+    // must be a pointer type suitable to the object sigil,\n+    // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n+    let source_ty = fcx.expr_ty(source_expr);\n+    let source_ty = structurally_resolved_type(fcx, source_expr.span, source_ty);\n+    debug!(\"source_ty={}\", source_ty.repr(fcx.tcx()));\n+    match (&ty::get(source_ty).sty, &ty::get(target_object_ty).sty) {\n+        (&ty::ty_uniq(referent_ty), &ty::ty_uniq(object_trait_ty)) => {\n+            let object_trait = object_trait(&object_trait_ty);\n+\n+            // Ensure that if ~T is cast to ~Trait, then T : Trait\n+            push_cast_obligation(fcx, cast_expr, object_trait, referent_ty);\n+        }\n+\n+        (&ty::ty_rptr(referent_region, ty::mt { ty: referent_ty,\n+                                                mutbl: referent_mutbl }),\n+         &ty::ty_rptr(target_region, ty::mt { ty: object_trait_ty,\n+                                              mutbl: target_mutbl })) =>\n+        {\n+            let object_trait = object_trait(&object_trait_ty);\n+            if !mutability_allowed(referent_mutbl, target_mutbl) {\n+                fcx.tcx().sess.span_err(source_expr.span,\n+                                        \"types differ in mutability\");\n+            } else {\n+                // Ensure that if &'a T is cast to &'b Trait, then T : Trait\n+                push_cast_obligation(fcx, cast_expr,\n+                                     object_trait,\n+                                     referent_ty);\n+\n+                // Ensure that if &'a T is cast to &'b Trait, then 'b <= 'a\n+                infer::mk_subr(fcx.infcx(),\n+                               infer::RelateObjectBound(source_expr.span),\n+                               target_region,\n+                               referent_region);\n+            }\n+        }\n+\n+        (_, &ty::ty_uniq(..)) => {\n+            fcx.ccx.tcx.sess.span_err(\n+                source_expr.span,\n+                format!(\"can only cast an boxed pointer \\\n+                         to a boxed object, not a {}\",\n+                        ty::ty_sort_string(fcx.tcx(), source_ty)).as_slice());\n+        }\n+\n+        (_, &ty::ty_rptr(..)) => {\n+            fcx.ccx.tcx.sess.span_err(\n+                source_expr.span,\n+                format!(\"can only cast a &-pointer \\\n+                         to an &-object, not a {}\",\n+                        ty::ty_sort_string(fcx.tcx(), source_ty)).as_slice());\n+        }\n+\n+        _ => {\n+            fcx.tcx().sess.span_bug(\n+                source_expr.span,\n+                \"expected object type\");\n+        }\n+    }\n+\n+    // Because we currently give unsound lifetimes to the \"ty_box\", I\n+    // could have written &'static ty::TyTrait here, but it seems\n+    // gratuitously unsafe.\n+    fn object_trait<'a>(t: &'a ty::t) -> &'a ty::TyTrait {\n+        match ty::get(*t).sty {\n+            ty::ty_trait(ref ty_trait) => &**ty_trait,\n+            _ => fail!(\"expected ty_trait\")\n+        }\n+    }\n+\n+    fn mutability_allowed(a_mutbl: ast::Mutability,\n+                          b_mutbl: ast::Mutability)\n+                          -> bool {\n+        a_mutbl == b_mutbl ||\n+            (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n+    }\n+\n+    fn push_cast_obligation(fcx: &FnCtxt,\n+                            cast_expr: &ast::Expr,\n+                            object_trait: &ty::TyTrait,\n+                            referent_ty: ty::t) {\n+        let object_trait_ref =\n+            register_object_cast_obligations(fcx,\n+                                             cast_expr.span,\n+                                             object_trait,\n+                                             referent_ty);\n+\n+        // Finally record the object_trait_ref for use during trans\n+        // (it would prob be better not to do this, but it's just kind\n+        // of a pain to have to reconstruct it).\n+        fcx.write_object_cast(cast_expr.id, object_trait_ref);\n+    }\n+}\n+\n+pub fn register_object_cast_obligations(fcx: &FnCtxt,\n+                                        span: Span,\n+                                        object_trait: &ty::TyTrait,\n+                                        referent_ty: ty::t)\n+                                        -> Rc<ty::TraitRef>\n+{\n+    // This is just for better error reporting. Kinda goofy. The object type stuff\n+    // needs some refactoring so there is a more convenient type to pass around.\n+    let object_trait_ty =\n+        ty::mk_trait(fcx.tcx(),\n+                     object_trait.def_id,\n+                     object_trait.substs.clone(),\n+                     object_trait.bounds);\n+\n+    debug!(\"register_object_cast_obligations: referent_ty={} object_trait_ty={}\",\n+           referent_ty.repr(fcx.tcx()),\n+           object_trait_ty.repr(fcx.tcx()));\n+\n+    // Take the type parameters from the object type, but set\n+    // the Self type (which is unknown, for the object type)\n+    // to be the type we are casting from.\n+    let mut object_substs = object_trait.substs.clone();\n+    assert!(object_substs.self_ty().is_none());\n+    object_substs.types.push(SelfSpace, referent_ty);\n+\n+    // Create the obligation for casting from T to Trait.\n+    let object_trait_ref =\n+        Rc::new(ty::TraitRef { def_id: object_trait.def_id,\n+                               substs: object_substs });\n+    let object_obligation =\n+        Obligation::new(\n+            ObligationCause::new(span,\n+                                 traits::ObjectCastObligation(object_trait_ty)),\n+            object_trait_ref.clone());\n+    fcx.register_obligation(object_obligation);\n+\n+    // Create additional obligations for all the various builtin\n+    // bounds attached to the object cast. (In other words, if the\n+    // object type is Foo+Send, this would create an obligation\n+    // for the Send check.)\n+    for builtin_bound in object_trait.bounds.builtin_bounds.iter() {\n+        fcx.register_obligation(\n+            obligation_for_builtin_bound(\n+                fcx.tcx(),\n+                ObligationCause::new(span,\n+                                     traits::ObjectCastObligation(object_trait_ty)),\n+                referent_ty,\n+                builtin_bound));\n+    }\n+\n+    object_trait_ref\n+}\n+\n+pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n+    debug!(\"select_all_fcx_obligations_or_error\");\n+\n+    let mut fulfillment_cx = fcx.inh.fulfillment_cx.borrow_mut();\n+    let r =\n+        fulfillment_cx.select_all_or_error(\n+            fcx.infcx(),\n+            &fcx.inh.param_env,\n+            &*fcx.inh.unboxed_closures.borrow());\n+    match r {\n+        Ok(()) => { }\n+        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n+    }\n+}\n+\n+pub fn check_builtin_bound_obligations(fcx: &FnCtxt) {\n+    /*!\n+     * Hacky second pass to check builtin-bounds obligations *after*\n+     * writeback occurs.\n+     */\n+\n+    match\n+        fcx.inh.fulfillment_cx.borrow()\n+                              .check_builtin_bound_obligations(fcx.infcx())\n+    {\n+        Ok(()) => { }\n+        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n+    }\n+}\n+\n+fn resolve_trait_ref(fcx: &FnCtxt, obligation: &Obligation)\n+                     -> (ty::TraitRef, ty::t)\n+{\n+    let trait_ref =\n+        fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n+            &*obligation.trait_ref);\n+    let self_ty =\n+        trait_ref.substs.self_ty().unwrap();\n+    (trait_ref, self_ty)\n+}\n+\n+pub fn report_fulfillment_errors(fcx: &FnCtxt,\n+                                 errors: &Vec<FulfillmentError>) {\n+    for error in errors.iter() {\n+        report_fulfillment_error(fcx, error);\n+    }\n+}\n+\n+pub fn report_fulfillment_error(fcx: &FnCtxt,\n+                                error: &FulfillmentError) {\n+    match error.code {\n+        SelectionError(ref e) => {\n+            report_selection_error(fcx, &error.obligation, e);\n+        }\n+        Ambiguity => {\n+            maybe_report_ambiguity(fcx, &error.obligation);\n+        }\n+    }\n+}\n+\n+pub fn report_selection_error(fcx: &FnCtxt,\n+                              obligation: &Obligation,\n+                              error: &SelectionError) {\n+    match *error {\n+        Unimplemented => {\n+            let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n+            if !ty::type_is_error(self_ty) {\n+                fcx.tcx().sess.span_err(\n+                    obligation.cause.span,\n+                    format!(\n+                        \"the trait `{}` is not implemented for the type `{}`\",\n+                        trait_ref.user_string(fcx.tcx()),\n+                        self_ty.user_string(fcx.tcx())).as_slice());\n+                note_obligation_cause(fcx, obligation);\n+            }\n+        }\n+        Overflow => {\n+            report_overflow(fcx, obligation);\n+        }\n+        OutputTypeParameterMismatch(ref expected_trait_ref, ref e) => {\n+            let expected_trait_ref =\n+                fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n+                    &**expected_trait_ref);\n+            let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n+            if !ty::type_is_error(self_ty) {\n+                fcx.tcx().sess.span_err(\n+                    obligation.cause.span,\n+                    format!(\n+                        \"type mismatch: the type `{}` implements the trait `{}`, \\\n+                         but the trait `{}` is required ({})\",\n+                        self_ty.user_string(fcx.tcx()),\n+                        expected_trait_ref.user_string(fcx.tcx()),\n+                        trait_ref.user_string(fcx.tcx()),\n+                        ty::type_err_to_str(fcx.tcx(), e)).as_slice());\n+                note_obligation_cause(fcx, obligation);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn report_overflow(fcx: &FnCtxt, obligation: &Obligation) {\n+    let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n+    if ty::type_is_error(self_ty) {\n+        fcx.tcx().sess.span_err(\n+            obligation.cause.span,\n+            format!(\n+                \"could not locate an impl of the trait `{}` for \\\n+                 the type `{}` due to overflow; possible cyclic \\\n+                 dependency between impls\",\n+                trait_ref.user_string(fcx.tcx()),\n+                self_ty.user_string(fcx.tcx())).as_slice());\n+        note_obligation_cause(fcx, obligation);\n+    }\n+}\n+\n+pub fn maybe_report_ambiguity(fcx: &FnCtxt, obligation: &Obligation) {\n+    // Unable to successfully determine, probably means\n+    // insufficient type information, but could mean\n+    // ambiguous impls. The latter *ought* to be a\n+    // coherence violation, so we don't report it here.\n+    let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n+    debug!(\"maybe_report_ambiguity(trait_ref={}, self_ty={}, obligation={})\",\n+           trait_ref.repr(fcx.tcx()),\n+           self_ty.repr(fcx.tcx()),\n+           obligation.repr(fcx.tcx()));\n+    if ty::type_is_error(self_ty) {\n+    } else if ty::type_needs_infer(self_ty) {\n+        fcx.tcx().sess.span_err(\n+            obligation.cause.span,\n+            format!(\n+                \"unable to infer enough type information to \\\n+             locate the impl of the trait `{}` for \\\n+             the type `{}`; type annotations required\",\n+            trait_ref.user_string(fcx.tcx()),\n+            self_ty.user_string(fcx.tcx())).as_slice());\n+        note_obligation_cause(fcx, obligation);\n+    } else if fcx.tcx().sess.err_count() == 0 {\n+         // Ambiguity. Coherence should have reported an error.\n+        fcx.tcx().sess.span_bug(\n+            obligation.cause.span,\n+            format!(\n+                \"coherence failed to report ambiguity: \\\n+                 cannot locate the impl of the trait `{}` for \\\n+                 the type `{}`\",\n+                trait_ref.user_string(fcx.tcx()),\n+                self_ty.user_string(fcx.tcx())).as_slice());\n+    }\n+}\n+\n+pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt) {\n+    /*! Select as many obligations as we can at present. */\n+\n+    match\n+        fcx.inh.fulfillment_cx\n+        .borrow_mut()\n+        .select_where_possible(fcx.infcx(),\n+                               &fcx.inh.param_env,\n+                               &*fcx.inh.unboxed_closures.borrow())\n+    {\n+        Ok(()) => { }\n+        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n+    }\n+}\n+\n+fn note_obligation_cause(fcx: &FnCtxt,\n+                         obligation: &Obligation) {\n+    let tcx = fcx.tcx();\n+    let trait_name = ty::item_path_str(tcx, obligation.trait_ref.def_id);\n+    match obligation.cause.code {\n+        traits::MiscObligation => { }\n+        traits::ItemObligation(item_def_id) => {\n+            let item_name = ty::item_path_str(tcx, item_def_id);\n+            tcx.sess.span_note(\n+                obligation.cause.span,\n+                format!(\n+                    \"the trait `{}` must be implemented because it is required by `{}`\",\n+                    trait_name,\n+                    item_name).as_slice());\n+        }\n+        traits::ObjectCastObligation(object_ty) => {\n+            tcx.sess.span_note(\n+                obligation.cause.span,\n+                format!(\n+                    \"the trait `{}` must be implemented for the cast \\\n+                     to the object type `{}`\",\n+                    trait_name,\n+                    fcx.infcx().ty_to_string(object_ty)).as_slice());\n+        }\n+        traits::RepeatVec => {\n+            tcx.sess.span_note(\n+                obligation.cause.span,\n+                format!(\n+                    \"the `Copy` trait is required because the \\\n+                     repeated element will be copied\").as_slice());\n+        }\n+        traits::VariableType(_) => {\n+            tcx.sess.span_note(\n+                obligation.cause.span,\n+                \"all local variables must have a statically known size\");\n+        }\n+        traits::AssignmentLhsSized => {\n+            tcx.sess.span_note(\n+                obligation.cause.span,\n+                \"the left-hand-side of an assignment must have a statically known size\");\n+        }\n+        traits::StructInitializerSized => {\n+            tcx.sess.span_note(\n+                obligation.cause.span,\n+                \"structs must have a statically known size to be initialized\");\n+        }\n+    }\n+}"}, {"sha": "73c0a4e10fc2a8fcdd047b6c04813448ad261cdf", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,365 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::subst::{Subst};\n+use middle::traits;\n+use middle::ty;\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::typeck::astconv::AstConv;\n+use middle::typeck::check::{FnCtxt, Inherited, blank_fn_ctxt, vtable2, regionck};\n+use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n+use middle::typeck::CrateCtxt;\n+use util::ppaux::Repr;\n+\n+use std::collections::HashSet;\n+use syntax::ast;\n+use syntax::ast_util::{local_def};\n+use syntax::codemap::Span;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+\n+pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n+    ccx: &'ccx CrateCtxt<'ccx, 'tcx>,\n+    cache: HashSet<ty::t>\n+}\n+\n+impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+    pub fn new(ccx: &'ccx CrateCtxt<'ccx, 'tcx>) -> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+        CheckTypeWellFormedVisitor { ccx: ccx, cache: HashSet::new() }\n+    }\n+\n+    fn check_item_well_formed(&mut self, ccx: &CrateCtxt, item: &ast::Item) {\n+        /*!\n+         * Checks that the field types (in a struct def'n) or\n+         * argument types (in an enum def'n) are well-formed,\n+         * meaning that they do not require any constraints not\n+         * declared in the struct definition itself.\n+         * For example, this definition would be illegal:\n+         *\n+         *     struct Ref<'a, T> { x: &'a T }\n+         *\n+         * because the type did not declare that `T:'a`.\n+         *\n+         * We do this check as a pre-pass before checking fn bodies\n+         * because if these constraints are not included it frequently\n+         * leads to confusing errors in fn bodies. So it's better to check\n+         * the types first.\n+         */\n+\n+        debug!(\"check_item_well_formed(it.id={}, it.ident={})\",\n+               item.id,\n+               ty::item_path_str(ccx.tcx, local_def(item.id)));\n+\n+        let ccx = self.ccx;\n+        match item.node {\n+            ast::ItemImpl(..) => {\n+                self.check_impl(item);\n+            }\n+            ast::ItemFn(..) => {\n+                self.check_item_type(item);\n+            }\n+            ast::ItemStatic(..) => {\n+                self.check_item_type(item);\n+            }\n+            ast::ItemStruct(..) => {\n+                self.check_type_defn(item, |fcx| {\n+                    ty::struct_fields(ccx.tcx, local_def(item.id),\n+                                      &fcx.inh.param_env.free_substs)\n+                        .iter()\n+                        .map(|f| f.mt.ty)\n+                        .collect()\n+                });\n+            }\n+            ast::ItemEnum(..) => {\n+                self.check_type_defn(item, |fcx| {\n+                    ty::substd_enum_variants(ccx.tcx, local_def(item.id),\n+                                             &fcx.inh.param_env.free_substs)\n+                        .iter()\n+                        .flat_map(|variant| {\n+                            variant.args\n+                                .iter()\n+                                .map(|&arg_ty| arg_ty)\n+                        })\n+                        .collect()\n+                });\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn with_fcx(&mut self,\n+                ccx: &CrateCtxt,\n+                item: &ast::Item,\n+                f: |&mut CheckTypeWellFormedVisitor, &FnCtxt|) {\n+        let item_def_id = local_def(item.id);\n+        let polytype = ty::lookup_item_type(ccx.tcx, item_def_id);\n+        let param_env =\n+            ty::construct_parameter_environment(ccx.tcx,\n+                                                item.span,\n+                                                &polytype.generics,\n+                                                item.id);\n+        let inh = Inherited::new(ccx.tcx, param_env);\n+        let fcx = blank_fn_ctxt(ccx, &inh, polytype.ty, item.id);\n+        f(self, &fcx);\n+        vtable2::select_all_fcx_obligations_or_error(&fcx);\n+        regionck::regionck_item(&fcx, item);\n+        vtable2::check_builtin_bound_obligations(&fcx);\n+    }\n+\n+    fn check_type_defn(&mut self,\n+                       item: &ast::Item,\n+                       lookup_fields: |&FnCtxt| -> Vec<ty::t>)\n+    {\n+        /*!\n+         * In a type definition, we check that to ensure that the types of the fields are\n+         * well-formed.\n+         */\n+\n+        self.with_fcx(self.ccx, item, |this, fcx| {\n+            let field_tys = lookup_fields(fcx);\n+            let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n+                                                        item.id, Some(&mut this.cache));\n+            for &ty in field_tys.iter() {\n+                // Regions are checked below.\n+                bounds_checker.check_traits_in_ty(ty);\n+            }\n+\n+            regionck::regionck_ensure_component_tys_wf(\n+                fcx, item.span, field_tys.as_slice());\n+        });\n+    }\n+\n+    fn check_item_type(&mut self,\n+                       item: &ast::Item)\n+    {\n+        self.with_fcx(self.ccx, item, |this, fcx| {\n+            let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n+                                                        item.id, Some(&mut this.cache));\n+            let polytype = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n+            let item_ty = polytype.ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            bounds_checker.check_traits_in_ty(item_ty);\n+        });\n+    }\n+\n+    fn check_impl(&mut self,\n+                  item: &ast::Item)\n+    {\n+        self.with_fcx(self.ccx, item, |this, fcx| {\n+            let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n+                                                        item.id, Some(&mut this.cache));\n+\n+            let self_ty = ty::node_id_to_type(fcx.tcx(), item.id);\n+            let self_ty = self_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+\n+            bounds_checker.check_traits_in_ty(self_ty);\n+\n+            let trait_ref = match ty::impl_trait_ref(fcx.tcx(), local_def(item.id)) {\n+                None => { return; }\n+                Some(t) => { t }\n+            };\n+            let trait_ref = (*trait_ref).subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+\n+            // We are stricter on the trait-ref in an impl than the\n+            // self-type.  In particular, we enforce region\n+            // relationships. The reason for this is that (at least\n+            // presently) \"appyling\" an impl does not require that the\n+            // application site check the well-formedness constraints on the\n+            // trait reference. Instead, this is done at the impl site.\n+            // Arguably this is wrong and we should treat the trait-reference\n+            // the same way as we treat the self-type.\n+            bounds_checker.check_trait_ref(&trait_ref);\n+\n+            let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_ref.def_id);\n+\n+            let cause =\n+                traits::ObligationCause::new(\n+                    item.span,\n+                    traits::ItemObligation(trait_ref.def_id));\n+\n+            // Find the supertrait bounds. This will add `int:Bar`.\n+            //\n+            // FIXME -- This is a bit ill-factored. There is very similar\n+            // code in traits::util::obligations_for_generics.\n+            fcx.add_region_obligations_for_type_parameter(item.span,\n+                                                          ty::ParamTy::for_self(trait_ref.def_id),\n+                                                          &trait_def.bounds,\n+                                                          trait_ref.self_ty());\n+            for builtin_bound in trait_def.bounds.builtin_bounds.iter() {\n+                fcx.register_obligation(\n+                    traits::obligation_for_builtin_bound(fcx.tcx(),\n+                                                         cause,\n+                                                         trait_ref.self_ty(),\n+                                                         builtin_bound));\n+            }\n+            for trait_bound in trait_def.bounds.trait_bounds.iter() {\n+                let trait_bound = trait_bound.subst(fcx.tcx(), &trait_ref.substs);\n+                fcx.register_obligation(\n+                    traits::Obligation::new(cause, trait_bound));\n+            }\n+        });\n+    }\n+}\n+\n+impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+    fn visit_item(&mut self, i: &'v ast::Item) {\n+        self.check_item_well_formed(self.ccx, i);\n+        visit::walk_item(self, i);\n+    }\n+}\n+\n+pub struct BoundsChecker<'cx,'tcx:'cx> {\n+    fcx: &'cx FnCtxt<'cx,'tcx>,\n+    span: Span,\n+    scope_id: ast::NodeId,\n+    binding_count: uint,\n+    cache: Option<&'cx mut HashSet<ty::t>>,\n+}\n+\n+impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n+    pub fn new(fcx: &'cx FnCtxt<'cx,'tcx>,\n+               span: Span,\n+               scope_id: ast::NodeId,\n+               cache: Option<&'cx mut HashSet<ty::t>>)\n+               -> BoundsChecker<'cx,'tcx> {\n+        BoundsChecker { fcx: fcx, span: span, scope_id: scope_id,\n+                        cache: cache, binding_count: 0 }\n+    }\n+\n+    pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef) {\n+        /*!\n+         * Given a trait ref like `A : Trait<B>`, where `Trait` is\n+         * defined as (say):\n+         *\n+         *     trait Trait<B:OtherTrait> : Copy { ... }\n+         *\n+         * This routine will check that `B : OtherTrait` and `A :\n+         * Trait<B>`. It will also recursively check that the types\n+         * `A` and `B` are well-formed.\n+         *\n+         * Note that it does not (currently, at least)\n+         * check that `A : Copy` (that check is delegated to the point\n+         * where impl `A : Trait<B>` is implemented).\n+         */\n+\n+        let trait_def = ty::lookup_trait_def(self.fcx.tcx(), trait_ref.def_id);\n+\n+        self.fcx.add_obligations_for_parameters(\n+            traits::ObligationCause::new(\n+                self.span,\n+                traits::ItemObligation(trait_ref.def_id)),\n+            &trait_ref.substs,\n+            &trait_def.generics);\n+\n+        for &ty in trait_ref.substs.types.iter() {\n+            self.check_traits_in_ty(ty);\n+        }\n+    }\n+\n+    pub fn check_ty(&mut self, ty: ty::t) {\n+        ty.fold_with(self);\n+    }\n+\n+    fn check_traits_in_ty(&mut self, ty: ty::t) {\n+        // When checking types outside of a type def'n, we ignore\n+        // region obligations. See discussion below in fold_ty().\n+        self.binding_count += 1;\n+        ty.fold_with(self);\n+        self.binding_count -= 1;\n+    }\n+}\n+\n+impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.fcx.tcx()\n+    }\n+\n+    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+        debug!(\"BoundsChecker t={}\",\n+               t.repr(self.tcx()));\n+\n+        match self.cache {\n+            Some(ref mut cache) => {\n+                if !cache.insert(t) {\n+                    // Already checked this type! Don't check again.\n+                    debug!(\"cached\");\n+                    return t;\n+                }\n+            }\n+            None => { }\n+        }\n+\n+        match ty::get(t).sty{\n+            ty::ty_struct(type_id, ref substs) |\n+            ty::ty_enum(type_id, ref substs) => {\n+                let polytype = ty::lookup_item_type(self.fcx.tcx(), type_id);\n+\n+                if self.binding_count == 0 {\n+                    self.fcx.add_obligations_for_parameters(\n+                        traits::ObligationCause::new(self.span,\n+                                                     traits::ItemObligation(type_id)),\n+                        substs,\n+                        &polytype.generics);\n+                } else {\n+                    // There are two circumstances in which we ignore\n+                    // region obligations.\n+                    //\n+                    // The first is when we are inside of a closure\n+                    // type. This is because in that case the region\n+                    // obligations for the parameter types are things\n+                    // that the closure body gets to assume and the\n+                    // caller must prove at the time of call. In other\n+                    // words, if there is a type like `<'a, 'b> | &'a\n+                    // &'b int |`, it is well-formed, and caller will\n+                    // have to show that `'b : 'a` at the time of\n+                    // call.\n+                    //\n+                    // The second is when we are checking for\n+                    // well-formedness outside of a type def'n or fn\n+                    // body. This is for a similar reason: in general,\n+                    // we only do WF checking for regions in the\n+                    // result of expressions and type definitions, so\n+                    // to as allow for implicit where clauses.\n+                    //\n+                    // (I believe we should do the same for traits, but\n+                    // that will require an RFC. -nmatsakis)\n+                    self.fcx.add_trait_obligations_for_generics(\n+                        traits::ObligationCause::new(self.span,\n+                                                     traits::ItemObligation(type_id)),\n+                        substs,\n+                        &polytype.generics);\n+                }\n+\n+                self.fold_substs(substs);\n+            }\n+            ty::ty_bare_fn(ty::BareFnTy{sig: ref fn_sig, ..}) |\n+            ty::ty_closure(box ty::ClosureTy{sig: ref fn_sig, ..}) => {\n+                self.binding_count += 1;\n+\n+                let (_, fn_sig) =\n+                    replace_late_bound_regions_in_fn_sig(\n+                        self.fcx.tcx(), fn_sig,\n+                        |br| ty::ReFree(ty::FreeRegion{scope_id: self.scope_id,\n+                                                       bound_region: br}));\n+\n+                debug!(\"late-bound regions replaced: {}\",\n+                       fn_sig.repr(self.tcx()));\n+\n+                self.fold_sig(&fn_sig);\n+\n+                self.binding_count -= 1;\n+            }\n+            ref sty => {\n+                self.fold_sty(sty);\n+            }\n+        }\n+\n+        t // we're not folding to produce a new type, so just return `t` here\n+    }\n+}"}, {"sha": "ffe019b314a87c32289482e5fc30073b84f26506", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -44,6 +44,7 @@ pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     wbcx.visit_expr(e);\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_unboxed_closures();\n+    wbcx.visit_object_cast_map();\n }\n \n pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n@@ -63,6 +64,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     }\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_unboxed_closures();\n+    wbcx.visit_object_cast_map();\n }\n \n pub fn resolve_impl_res(infcx: &infer::InferCtxt,\n@@ -128,8 +130,6 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n         self.visit_node_id(ResolvingExpr(e.span), e.id);\n         self.visit_method_map_entry(ResolvingExpr(e.span),\n                                     MethodCall::expr(e.id));\n-        self.visit_vtable_map_entry(ResolvingExpr(e.span),\n-                                    MethodCall::expr(e.id));\n \n         match e.node {\n             ast::ExprFnBlock(_, ref decl, _) |\n@@ -235,6 +235,27 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n+    fn visit_object_cast_map(&self) {\n+        if self.fcx.writeback_errors.get() {\n+            return\n+        }\n+\n+        for (&node_id, trait_ref) in self.fcx\n+                                            .inh\n+                                            .object_cast_map\n+                                            .borrow()\n+                                            .iter()\n+        {\n+            let span = ty::expr_span(self.tcx(), node_id);\n+            let reason = ResolvingExpr(span);\n+            let closure_ty = self.resolve(trait_ref, reason);\n+            self.tcx()\n+                .object_cast_map\n+                .borrow_mut()\n+                .insert(node_id, closure_ty);\n+        }\n+    }\n+\n     fn visit_node_id(&self, reason: ResolveReason, id: ast::NodeId) {\n         // Resolve any borrowings for the node with id `id`\n         self.visit_adjustments(reason, id);\n@@ -284,13 +305,11 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         for autoderef in range(0, adj.autoderefs) {\n                             let method_call = MethodCall::autoderef(id, autoderef);\n                             self.visit_method_map_entry(reason, method_call);\n-                            self.visit_vtable_map_entry(reason, method_call);\n                         }\n \n                         if adj_object {\n                             let method_call = MethodCall::autoobject(id);\n                             self.visit_method_map_entry(reason, method_call);\n-                            self.visit_vtable_map_entry(reason, method_call);\n                         }\n \n                         ty::AutoDerefRef(ty::AutoDerefRef {\n@@ -329,22 +348,6 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn visit_vtable_map_entry(&self,\n-                              reason: ResolveReason,\n-                              vtable_key: MethodCall) {\n-        // Resolve any vtable map entry\n-        match self.fcx.inh.vtable_map.borrow_mut().pop(&vtable_key) {\n-            Some(origins) => {\n-                let r_origins = self.resolve(&origins, reason);\n-                debug!(\"writeback::resolve_vtable_map_entry(\\\n-                        vtable_key={}, vtables={:?})\",\n-                       vtable_key, r_origins.repr(self.tcx()));\n-                self.tcx().vtable_map.borrow_mut().insert(vtable_key, r_origins);\n-            }\n-            None => {}\n-        }\n-    }\n-\n     fn resolve<T:ResolveIn>(&self, t: &T, reason: ResolveReason) -> T {\n         t.resolve_in(&mut Resolver::new(self.fcx, reason))\n     }\n@@ -504,3 +507,11 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         }\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+// During type check, we store promises with the result of trait\n+// lookup rather than the actual results (because the results are not\n+// necessarily available immediately). These routines unwind the\n+// promises. It is expected that we will have already reported any\n+// errors that may be encountered, so if the promises store an error,\n+// a dummy result is returned."}, {"sha": "76c5cab234f375008bc59de619976d7835fa45c7", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "renamed", "additions": 36, "deletions": 307, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,12 +10,13 @@\n \n // Coherence phase\n //\n-// The job of the coherence phase of typechecking is to ensure that each trait\n-// has at most one implementation for each type. Then we build a mapping from\n-// each trait in the system to its implementations.\n+// The job of the coherence phase of typechecking is to ensure that\n+// each trait has at most one implementation for each type. This is\n+// done by the orphan and overlap modules. Then we build up various\n+// mappings. That mapping code resides here.\n \n \n-use metadata::csearch::{each_impl, get_impl_trait, each_implementation_for_trait};\n+use metadata::csearch::{each_impl, get_impl_trait};\n use metadata::csearch;\n use middle::subst;\n use middle::subst::{Substs};\n@@ -35,27 +36,24 @@ use middle::typeck::CrateCtxt;\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n-use middle::typeck::infer;\n-use util::ppaux::Repr;\n-use middle::def::{DefStruct, DefTy};\n+use std::collections::{HashSet};\n+use std::cell::RefCell;\n+use std::rc::Rc;\n use syntax::ast::{Crate, DefId};\n-use syntax::ast::{Item, ItemEnum, ItemImpl, ItemMod, ItemStruct};\n-use syntax::ast::{LOCAL_CRATE, TraitRef, TyPath};\n+use syntax::ast::{Item, ItemImpl};\n+use syntax::ast::{LOCAL_CRATE, TraitRef};\n use syntax::ast;\n use syntax::ast_map::NodeItem;\n use syntax::ast_map;\n use syntax::ast_util::{local_def};\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::codemap::{Span};\n use syntax::parse::token;\n use syntax::visit;\n+use util::nodemap::{DefIdMap, FnvHashMap};\n+use util::ppaux::Repr;\n \n-use std::collections::HashSet;\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-\n-struct UniversalQuantificationResult {\n-    monotype: t\n-}\n+mod orphan;\n+mod overlap;\n \n fn get_base_type(inference_context: &InferCtxt,\n                  span: Span,\n@@ -96,53 +94,6 @@ fn get_base_type(inference_context: &InferCtxt,\n     }\n }\n \n-fn type_is_defined_in_local_crate(tcx: &ty::ctxt, original_type: t) -> bool {\n-    /*!\n-     *\n-     * For coherence, when we have `impl Trait for Type`, we need to\n-     * guarantee that `Type` is \"local\" to the\n-     * crate.  For our purposes, this means that it must contain\n-     * some nominal type defined in this crate.\n-     */\n-\n-    let mut found_nominal = false;\n-    ty::walk_ty(original_type, |t| {\n-        match get(t).sty {\n-            ty_enum(def_id, _) |\n-            ty_struct(def_id, _) |\n-            ty_unboxed_closure(def_id, _) => {\n-                if def_id.krate == ast::LOCAL_CRATE {\n-                    found_nominal = true;\n-                }\n-            }\n-            ty_trait(box ty::TyTrait { def_id, .. }) => {\n-                if def_id.krate == ast::LOCAL_CRATE {\n-                    found_nominal = true;\n-                }\n-            }\n-            ty_uniq(..) => {\n-                match tcx.lang_items.owned_box() {\n-                    Some(did) if did.krate == ast::LOCAL_CRATE => {\n-                        found_nominal = true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            ty_box(..) => {\n-                match tcx.lang_items.gc() {\n-                    Some(did) if did.krate == ast::LOCAL_CRATE => {\n-                        found_nominal = true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            _ => { }\n-        }\n-    });\n-    return found_nominal;\n-}\n-\n // Returns the def ID of the base type, if there is one.\n fn get_base_type_def_id(inference_context: &InferCtxt,\n                         span: Span,\n@@ -185,6 +136,7 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n struct CoherenceChecker<'a, 'tcx: 'a> {\n     crate_context: &'a CrateCtxt<'a, 'tcx>,\n     inference_context: InferCtxt<'a, 'tcx>,\n+    inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n }\n \n struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n@@ -214,57 +166,6 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n     }\n }\n \n-struct PrivilegedScopeVisitor<'a, 'tcx: 'a> {\n-    cc: &'a CoherenceChecker<'a, 'tcx>\n-}\n-\n-impl<'a, 'tcx, 'v> visit::Visitor<'v> for PrivilegedScopeVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &Item) {\n-\n-        match item.node {\n-            ItemMod(ref module_) => {\n-                // Then visit the module items.\n-                visit::walk_mod(self, module_);\n-            }\n-            ItemImpl(_, None, ref ast_ty, _) => {\n-                if !self.cc.ast_type_is_defined_in_local_crate(&**ast_ty) {\n-                    // This is an error.\n-                    let session = &self.cc.crate_context.tcx.sess;\n-                    span_err!(session, item.span, E0116,\n-                              \"cannot associate methods with a type outside the \\\n-                               crate the type is defined in; define and implement \\\n-                               a trait or new type instead\");\n-                }\n-            }\n-            ItemImpl(_, Some(ref trait_ref), _, _) => {\n-                let tcx = self.cc.crate_context.tcx;\n-                // `for_ty` is `Type` in `impl Trait for Type`\n-                let for_ty = ty::node_id_to_type(tcx, item.id);\n-                if !type_is_defined_in_local_crate(tcx, for_ty) {\n-                    // This implementation is not in scope of its base\n-                    // type. This still might be OK if the trait is\n-                    // defined in the same crate.\n-\n-                    let trait_def_id =\n-                        self.cc.trait_ref_to_trait_def_id(trait_ref);\n-\n-                    if trait_def_id.krate != LOCAL_CRATE {\n-                        let session = &self.cc.crate_context.tcx.sess;\n-                        span_err!(session, item.span, E0117,\n-                                  \"cannot provide an extension implementation \\\n-                                   where both trait and type are not defined in this crate\");\n-                    }\n-                }\n-\n-                visit::walk_item(self, item);\n-            }\n-            _ => {\n-                visit::walk_item(self, item);\n-            }\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     fn check(&self, krate: &Crate) {\n         // Check implementations and traits. This populates the tables\n@@ -273,11 +174,14 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let mut visitor = CoherenceCheckVisitor { cc: self };\n         visit::walk_crate(&mut visitor, krate);\n \n-        // Check that there are no overlapping trait instances\n-        self.check_implementation_coherence();\n-\n-        // Check whether traits with base types are in privileged scopes.\n-        self.check_privileged_scopes(krate);\n+        // Copy over the inherent impls we gathered up during the walk into\n+        // the tcx.\n+        let mut tcx_inherent_impls =\n+            self.crate_context.tcx.inherent_impls.borrow_mut();\n+        for (k, v) in self.inherent_impls.borrow().iter() {\n+            tcx_inherent_impls.insert((*k).clone(),\n+                                      Rc::new((*v.borrow()).clone()));\n+        }\n \n         // Bring in external crates. It's fine for this to happen after the\n         // coherence checks, because we ensure by construction that no errors\n@@ -290,7 +194,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         self.populate_destructor_table();\n     }\n \n-    fn check_implementation(&self, item: &Item,\n+    fn check_implementation(&self,\n+                            item: &Item,\n                             associated_traits: &[TraitRef]) {\n         let tcx = self.crate_context.tcx;\n         let impl_did = local_def(item.id);\n@@ -299,25 +204,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         // If there are no traits, then this implementation must have a\n         // base type.\n \n-        if associated_traits.len() == 0 {\n-            debug!(\"(checking implementation) no associated traits for item '{}'\",\n-                   token::get_ident(item.ident));\n-\n-            match get_base_type_def_id(&self.inference_context,\n-                                       item.span,\n-                                       self_type.ty) {\n-                None => {\n-                    let session = &self.crate_context.tcx.sess;\n-                    span_err!(session, item.span, E0118,\n-                              \"no base type found for inherent implementation; \\\n-                               implement a trait or new type instead\");\n-                }\n-                Some(_) => {\n-                    // Nothing to do.\n-                }\n-            }\n-        }\n-\n         let impl_items = self.create_impl_from_item(item);\n \n         for associated_trait in associated_traits.iter() {\n@@ -408,187 +294,32 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        let tcx = self.crate_context.tcx;\n-        match tcx.inherent_impls.borrow().find(&base_def_id) {\n+        match self.inherent_impls.borrow().find(&base_def_id) {\n             Some(implementation_list) => {\n                 implementation_list.borrow_mut().push(impl_def_id);\n                 return;\n             }\n             None => {}\n         }\n \n-        tcx.inherent_impls.borrow_mut().insert(base_def_id,\n-                                               Rc::new(RefCell::new(vec!(impl_def_id))));\n+        self.inherent_impls.borrow_mut().insert(\n+            base_def_id,\n+            Rc::new(RefCell::new(vec!(impl_def_id))));\n     }\n \n     fn add_trait_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n+        debug!(\"add_trait_impl: base_def_id={} impl_def_id={}\",\n+               base_def_id, impl_def_id);\n         ty::record_trait_implementation(self.crate_context.tcx,\n                                         base_def_id,\n                                         impl_def_id);\n     }\n \n-    fn check_implementation_coherence(&self) {\n-        for trait_id in self.crate_context.tcx.trait_impls.borrow().keys() {\n-            self.check_implementation_coherence_of(*trait_id);\n-        }\n-    }\n-\n-    fn check_implementation_coherence_of(&self, trait_def_id: DefId) {\n-        // Unify pairs of polytypes.\n-        self.iter_impls_of_trait_local(trait_def_id, |impl_a| {\n-            let polytype_a =\n-                self.get_self_type_for_implementation(impl_a);\n-\n-            // \"We have an impl of trait <trait_def_id> for type <polytype_a>,\n-            // and that impl is <impl_a>\"\n-            self.iter_impls_of_trait(trait_def_id, |impl_b| {\n-\n-                // An impl is coherent with itself\n-                if impl_a != impl_b {\n-                    let polytype_b = self.get_self_type_for_implementation(\n-                            impl_b);\n-\n-                    if self.polytypes_unify(polytype_a.clone(), polytype_b) {\n-                        let session = &self.crate_context.tcx.sess;\n-                        span_err!(session, self.span_of_impl(impl_a), E0119,\n-                                  \"conflicting implementations for trait `{}`\",\n-                                  ty::item_path_str(self.crate_context.tcx, trait_def_id));\n-                        if impl_b.krate == LOCAL_CRATE {\n-                            span_note!(session, self.span_of_impl(impl_b),\n-                                       \"note conflicting implementation here\");\n-                        } else {\n-                            let crate_store = &self.crate_context.tcx.sess.cstore;\n-                            let cdata = crate_store.get_crate_data(impl_b.krate);\n-                            span_note!(session, self.span_of_impl(impl_a),\n-                                       \"conflicting implementation in crate `{}`\",\n-                                       cdata.name);\n-                        }\n-                    }\n-                }\n-            })\n-        })\n-    }\n-\n-    fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |DefId|) {\n-        self.iter_impls_of_trait_local(trait_def_id, |x| f(x));\n-\n-        if trait_def_id.krate == LOCAL_CRATE {\n-            return;\n-        }\n-\n-        let crate_store = &self.crate_context.tcx.sess.cstore;\n-        csearch::each_implementation_for_trait(crate_store, trait_def_id, |impl_def_id| {\n-            // Is this actually necessary?\n-            let _ = lookup_item_type(self.crate_context.tcx, impl_def_id);\n-            f(impl_def_id);\n-        });\n-    }\n-\n-    fn iter_impls_of_trait_local(&self, trait_def_id: DefId, f: |DefId|) {\n-        match self.crate_context.tcx.trait_impls.borrow().find(&trait_def_id) {\n-            Some(impls) => {\n-                for &impl_did in impls.borrow().iter() {\n-                    f(impl_did);\n-                }\n-            }\n-            None => { /* no impls? */ }\n-        }\n-    }\n-\n-    fn polytypes_unify(&self,\n-                       polytype_a: Polytype,\n-                       polytype_b: Polytype)\n-                       -> bool {\n-        let universally_quantified_a =\n-            self.universally_quantify_polytype(polytype_a);\n-        let universally_quantified_b =\n-            self.universally_quantify_polytype(polytype_b);\n-\n-        return self.can_unify_universally_quantified(\n-            &universally_quantified_a, &universally_quantified_b) ||\n-            self.can_unify_universally_quantified(\n-            &universally_quantified_b, &universally_quantified_a);\n-    }\n-\n-    // Converts a polytype to a monotype by replacing all parameters with\n-    // type variables. Returns the monotype and the type variables created.\n-    fn universally_quantify_polytype(&self, polytype: Polytype)\n-                                     -> UniversalQuantificationResult\n-    {\n-        let substitutions =\n-            self.inference_context.fresh_substs_for_type(DUMMY_SP,\n-                                                         &polytype.generics);\n-        let monotype = polytype.ty.subst(self.crate_context.tcx, &substitutions);\n-\n-        UniversalQuantificationResult {\n-            monotype: monotype\n-        }\n-    }\n-\n-    fn can_unify_universally_quantified<'a>(&self,\n-                                            a: &'a UniversalQuantificationResult,\n-                                            b: &'a UniversalQuantificationResult)\n-                                            -> bool\n-    {\n-        infer::can_mk_subty(&self.inference_context,\n-                            a.monotype,\n-                            b.monotype).is_ok()\n-    }\n-\n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n                                         -> Polytype {\n         self.crate_context.tcx.tcache.borrow().get_copy(&impl_did)\n     }\n \n-    // Privileged scope checking\n-    fn check_privileged_scopes(&self, krate: &Crate) {\n-        let mut visitor = PrivilegedScopeVisitor{ cc: self };\n-        visit::walk_crate(&mut visitor, krate);\n-    }\n-\n-    fn trait_ref_to_trait_def_id(&self, trait_ref: &TraitRef) -> DefId {\n-        let def_map = &self.crate_context.tcx.def_map;\n-        let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n-        let trait_id = trait_def.def_id();\n-        return trait_id;\n-    }\n-\n-    /// For coherence, when we have `impl Type`, we need to guarantee that\n-    /// `Type` is \"local\" to the crate. For our purposes, this means that it\n-    /// must precisely name some nominal type defined in this crate.\n-    fn ast_type_is_defined_in_local_crate(&self, original_type: &ast::Ty) -> bool {\n-        match original_type.node {\n-            TyPath(_, _, path_id) => {\n-                match self.crate_context.tcx.def_map.borrow().get_copy(&path_id) {\n-                    DefTy(def_id) | DefStruct(def_id) => {\n-                        if def_id.krate != LOCAL_CRATE {\n-                            return false;\n-                        }\n-\n-                        // Make sure that this type precisely names a nominal\n-                        // type.\n-                        match self.crate_context.tcx.map.find(def_id.node) {\n-                            None => {\n-                                self.crate_context.tcx.sess.span_bug(\n-                                    original_type.span,\n-                                    \"resolve didn't resolve this type?!\");\n-                            }\n-                            Some(NodeItem(item)) => {\n-                                match item.node {\n-                                    ItemStruct(..) | ItemEnum(..) => true,\n-                                    _ => false,\n-                                }\n-                            }\n-                            Some(_) => false,\n-                        }\n-                    }\n-                    _ => false\n-                }\n-            }\n-            _ => false\n-        }\n-    }\n-\n     // Converts an implementation in the AST to a vector of items.\n     fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n@@ -623,11 +354,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         }\n     }\n \n-    fn span_of_impl(&self, impl_did: DefId) -> Span {\n-        assert_eq!(impl_did.krate, LOCAL_CRATE);\n-        self.crate_context.tcx.map.span(impl_did.node)\n-    }\n-\n     // External crate handling\n \n     fn add_external_impl(&self,\n@@ -824,5 +550,8 @@ pub fn check_coherence(crate_context: &CrateCtxt) {\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n+        inherent_impls: RefCell::new(FnvHashMap::new()),\n     }.check(crate_context.tcx.map.krate());\n+    orphan::check(crate_context.tcx);\n+    overlap::check(crate_context.tcx);\n }", "previous_filename": "src/librustc/middle/typeck/coherence.rs"}, {"sha": "e7139e1229b23c69f162b00fc6a3f097363cad3e", "filename": "src/librustc/middle/typeck/coherence/orphan.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Orphan checker: every impl either implements a trait defined in this\n+ * crate or pertains to a type defined in this crate.\n+ */\n+\n+use middle::traits;\n+use middle::ty;\n+use syntax::ast::{Item, ItemImpl};\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::visit;\n+use util::ppaux::Repr;\n+\n+pub fn check(tcx: &ty::ctxt) {\n+    let mut orphan = OrphanChecker { tcx: tcx };\n+    visit::walk_crate(&mut orphan, tcx.map.krate());\n+}\n+\n+struct OrphanChecker<'cx, 'tcx:'cx> {\n+    tcx: &'cx ty::ctxt<'tcx>\n+}\n+\n+impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n+    fn visit_item(&mut self, item: &'v ast::Item) {\n+        let def_id = ast_util::local_def(item.id);\n+        match item.node {\n+            ast::ItemImpl(_, None, _, _) => {\n+                // For inherent impls, self type must be a nominal type\n+                // defined in this crate.\n+                debug!(\"coherence2::orphan check: inherent impl {}\", item.repr(self.tcx));\n+                let self_ty = ty::lookup_item_type(self.tcx, def_id).ty;\n+                match ty::get(self_ty).sty {\n+                    ty::ty_enum(def_id, _) |\n+                    ty::ty_struct(def_id, _) => {\n+                        if def_id.krate != ast::LOCAL_CRATE {\n+                            span_err!(self.tcx.sess, item.span, E0116,\n+                                      \"cannot associate methods with a type outside the \\\n+                                      crate the type is defined in; define and implement \\\n+                                      a trait or new type instead\");\n+                        }\n+                    }\n+                    _ => {\n+                        span_err!(self.tcx.sess, item.span, E0118,\n+                                  \"no base type found for inherent implementation; \\\n+                                   implement a trait or new type instead\");\n+                    }\n+                }\n+            }\n+            ast::ItemImpl(_, Some(_), _, _) => {\n+                // \"Trait\" impl\n+                debug!(\"coherence2::orphan check: trait impl {}\", item.repr(self.tcx));\n+                if traits::is_orphan_impl(self.tcx, def_id) {\n+                    span_err!(self.tcx.sess, item.span, E0117,\n+                              \"cannot provide an extension implementation \\\n+                               where both trait and type are not defined in this crate\");\n+                }\n+            }\n+            _ => {\n+                // Not an impl\n+            }\n+        }\n+\n+        visit::walk_item(self, item);\n+    }\n+}"}, {"sha": "48f71d95c429aa87591169559607e60a0923bafe", "filename": "src/librustc/middle/typeck/coherence/overlap.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Overlap: No two impls for the same trait are implemented for the\n+ * same type.\n+ */\n+\n+use middle::traits;\n+use middle::ty;\n+use middle::typeck::infer::{new_infer_ctxt};\n+use middle::typeck::infer;\n+use syntax::ast::{DefId};\n+use syntax::ast::{LOCAL_CRATE};\n+use syntax::ast;\n+use syntax::codemap::{Span};\n+use util::ppaux::Repr;\n+\n+pub fn check(tcx: &ty::ctxt) {\n+    let overlap = OverlapChecker { tcx: tcx };\n+    overlap.check_for_overlapping_impls();\n+}\n+\n+struct OverlapChecker<'cx, 'tcx:'cx> {\n+    tcx: &'cx ty::ctxt<'tcx>\n+}\n+\n+impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n+    fn check_for_overlapping_impls(&self) {\n+        debug!(\"check_for_overlapping_impls\");\n+        let trait_impls = self.tcx.trait_impls.borrow();\n+        for trait_def_id in trait_impls.keys() {\n+            self.check_for_overlapping_impls_of_trait(*trait_def_id);\n+        }\n+    }\n+\n+    fn check_for_overlapping_impls_of_trait(&self,\n+                                            trait_def_id: ast::DefId)\n+    {\n+        debug!(\"check_for_overlapping_impls_of_trait(trait_def_id={})\",\n+               trait_def_id.repr(self.tcx));\n+\n+        // FIXME -- it seems like this method actually pushes\n+        // duplicate impls onto the list\n+        ty::populate_implementations_for_type_if_necessary(self.tcx,\n+                                                           trait_def_id);\n+\n+        let mut impls = Vec::new();\n+        self.push_impls_of_trait(trait_def_id, &mut impls);\n+\n+        for (i, &impl1_def_id) in impls.iter().enumerate() {\n+            if impl1_def_id.krate != ast::LOCAL_CRATE {\n+                // we don't need to check impls if both are external;\n+                // that's the other crate's job.\n+                continue;\n+            }\n+\n+            for &impl2_def_id in impls.slice_from(i+1).iter() {\n+                self.check_if_impls_overlap(trait_def_id,\n+                                            impl1_def_id,\n+                                            impl2_def_id);\n+            }\n+        }\n+    }\n+\n+    fn check_if_impls_overlap(&self,\n+                              trait_def_id: ast::DefId,\n+                              impl1_def_id: ast::DefId,\n+                              impl2_def_id: ast::DefId)\n+    {\n+        assert_eq!(impl1_def_id.krate, ast::LOCAL_CRATE);\n+\n+        debug!(\"check_if_impls_overlap({}, {}, {})\",\n+               trait_def_id.repr(self.tcx),\n+               impl1_def_id.repr(self.tcx),\n+               impl2_def_id.repr(self.tcx));\n+\n+        let infcx = infer::new_infer_ctxt(self.tcx);\n+        if !traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n+            return;\n+        }\n+\n+        span_err!(self.tcx.sess, self.span_of_impl(impl1_def_id), E0119,\n+                  \"conflicting implementations for trait `{}`\",\n+                  ty::item_path_str(self.tcx, trait_def_id));\n+\n+        if impl2_def_id.krate == ast::LOCAL_CRATE {\n+            span_note!(self.tcx.sess, self.span_of_impl(impl2_def_id),\n+                       \"note conflicting implementation here\");\n+        } else {\n+            let crate_store = &self.tcx.sess.cstore;\n+            let cdata = crate_store.get_crate_data(impl2_def_id.krate);\n+            span_note!(self.tcx.sess, self.span_of_impl(impl1_def_id),\n+                       \"conflicting implementation in crate `{}`\",\n+                       cdata.name);\n+        }\n+    }\n+\n+    fn push_impls_of_trait(&self,\n+                           trait_def_id: ast::DefId,\n+                           out: &mut Vec<ast::DefId>) {\n+        match self.tcx.trait_impls.borrow().find(&trait_def_id) {\n+            Some(impls) => { out.push_all(impls.borrow().as_slice()); }\n+            None => { /* no impls */ }\n+        }\n+    }\n+\n+    fn span_of_impl(&self, impl_did: ast::DefId) -> Span {\n+        assert_eq!(impl_did.krate, ast::LOCAL_CRATE);\n+        self.tcx.map.span(impl_did.node)\n+    }\n+}"}, {"sha": "e0a35dc72a39f4220546a736b335e96d9fb2a812", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -327,10 +327,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         let sty_b = &ty::get(b).sty;\n         match (sty_a, sty_b) {\n-            (&ty::ty_rptr(_, ty::mt{ty: t_a, ..}), &ty::ty_rptr(_, mt_b)) => {\n+            (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_rptr(_, mt_b)) => {\n                 self.unpack_actual_value(t_a, |sty_a| {\n-                    match self.unsize_ty(sty_a, mt_b.ty) {\n+                    match self.unsize_ty(t_a, sty_a, mt_b.ty) {\n                         Some((ty, kind)) => {\n+                            if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n+                                return Err(ty::terr_mutability);\n+                            }\n+\n                             let coercion = Coercion(self.get_ref().trace.clone());\n                             let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n                             let ty = ty::mk_rptr(self.get_ref().infcx.tcx,\n@@ -349,10 +353,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     }\n                 })\n             }\n-            (&ty::ty_rptr(_, ty::mt{ty: t_a, ..}), &ty::ty_ptr(mt_b)) => {\n+            (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_ptr(mt_b)) => {\n                 self.unpack_actual_value(t_a, |sty_a| {\n-                    match self.unsize_ty(sty_a, mt_b.ty) {\n+                    match self.unsize_ty(t_a, sty_a, mt_b.ty) {\n                         Some((ty, kind)) => {\n+                            if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n+                                return Err(ty::terr_mutability);\n+                            }\n+\n                             let ty = ty::mk_ptr(self.get_ref().infcx.tcx,\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n@@ -370,7 +378,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             (&ty::ty_uniq(t_a), &ty::ty_uniq(t_b)) => {\n                 self.unpack_actual_value(t_a, |sty_a| {\n-                    match self.unsize_ty(sty_a, t_b) {\n+                    match self.unsize_ty(t_a, sty_a, t_b) {\n                         Some((ty, kind)) => {\n                             let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n@@ -393,6 +401,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // performed to unsize it.\n     // E.g., `[T, ..n]` -> `([T], UnsizeLength(n))`\n     fn unsize_ty(&self,\n+                 ty_a: ty::t,\n                  sty_a: &ty::sty,\n                  ty_b: ty::t)\n                  -> Option<(ty::t, ty::UnsizeKind)> {\n@@ -412,9 +421,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                           def_id,\n                                           substs.clone(),\n                                           bounds);\n-                    Some((ty, ty::UnsizeVtable(bounds,\n-                                               def_id,\n-                                               substs.clone())))\n+                    Some((ty, ty::UnsizeVtable(ty::TyTrait { def_id: def_id,\n+                                                             bounds: bounds,\n+                                                             substs: substs.clone() },\n+                                               ty_a)))\n                 }\n                 (&ty::ty_struct(did_a, ref substs_a), &ty::ty_struct(did_b, ref substs_b))\n                   if did_a == did_b => {\n@@ -432,7 +442,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                         if self.get_ref().infcx.try(|| sub.tys(*tp_a, *tp_b)).is_ok() {\n                             continue;\n                         }\n-                        match self.unpack_actual_value(*tp_a, |tp| self.unsize_ty(tp, *tp_b)) {\n+                        match\n+                            self.unpack_actual_value(\n+                                *tp_a,\n+                                |tp| self.unsize_ty(*tp_a, tp, *tp_b))\n+                        {\n                             Some((new_tp, k)) => {\n                                 // Check that the whole types match.\n                                 let mut new_substs = substs_a.clone();\n@@ -471,14 +485,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        debug!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={}, b_mutbl={})\",\n                a.repr(tcx), sty_a,\n-               b.repr(tcx));\n+               b.repr(tcx), b_mutbl);\n \n         let coercion = Coercion(self.get_ref().trace.clone());\n         let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n-        self.coerce_object(a, sty_a, b,\n+        self.coerce_object(a, sty_a, b, b_mutbl,\n                            |tr| ty::mk_rptr(tcx, r_a, ty::mt{ mutbl: b_mutbl, ty: tr }),\n                            || AutoPtr(r_a, b_mutbl, None))\n     }\n@@ -491,11 +505,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        debug!(\"coerce_unsafe_object(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_unsafe_object(a={}, sty_a={:?}, b={}, b_mutbl={})\",\n                a.repr(tcx), sty_a,\n-               b.repr(tcx));\n+               b.repr(tcx), b_mutbl);\n \n-        self.coerce_object(a, sty_a, b,\n+        self.coerce_object(a, sty_a, b, b_mutbl,\n                            |tr| ty::mk_ptr(tcx, ty::mt{ mutbl: b_mutbl, ty: tr }),\n                            || AutoUnsafe(b_mutbl, None))\n     }\n@@ -504,19 +518,23 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                      a: ty::t,\n                      sty_a: &ty::sty,\n                      b: ty::t,\n+                     b_mutbl: ast::Mutability,\n                      mk_ty: |ty::t| -> ty::t,\n                      mk_adjust: || -> ty::AutoRef) -> CoerceResult\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n         match *sty_a {\n-            ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+            ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty::get(ty).sty {\n                 ty::ty_trait(box ty::TyTrait {\n                         def_id,\n                         ref substs,\n                         bounds,\n                         ..\n-                    }) => {\n+                    }) =>\n+                {\n+                    debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n+\n                     let tr = ty::mk_trait(tcx, def_id, substs.clone(), bounds);\n                     try!(self.subtype(mk_ty(tr), b));\n                     Ok(Some(AutoDerefRef(AutoDerefRef {\n@@ -618,3 +636,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         })))\n     }\n }\n+\n+fn can_coerce_mutbls(from_mutbl: ast::Mutability,\n+                     to_mutbl: ast::Mutability)\n+                     -> bool {\n+    match (from_mutbl, to_mutbl) {\n+        (ast::MutMutable, ast::MutMutable) => true,\n+        (ast::MutImmutable, ast::MutImmutable) => true,\n+        (ast::MutMutable, ast::MutImmutable) => true,\n+        (ast::MutImmutable, ast::MutMutable) => false,\n+    }\n+}"}, {"sha": "4412b7d94d4687b4a33b939a5ecd038217f32bc4", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -34,7 +34,7 @@\n \n \n use middle::subst;\n-use middle::subst::Substs;\n+use middle::subst::{ErasedRegions, NonerasedRegions, Substs};\n use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n use middle::ty::{IntType, UintType};\n use middle::ty::{BuiltinBounds};\n@@ -113,29 +113,40 @@ pub trait Combine<'tcx> {\n             let a_tps = a_subst.types.get_slice(space);\n             let b_tps = b_subst.types.get_slice(space);\n             let tps = try!(self.tps(space, a_tps, b_tps));\n+            substs.types.replace(space, tps);\n+        }\n \n-            let a_regions = a_subst.regions().get_slice(space);\n-            let b_regions = b_subst.regions().get_slice(space);\n-\n-            let mut invariance = Vec::new();\n-            let r_variances = match variances {\n-                Some(ref variances) => variances.regions.get_slice(space),\n-                None => {\n-                    for _ in a_regions.iter() {\n-                        invariance.push(ty::Invariant);\n-                    }\n-                    invariance.as_slice()\n-                }\n-            };\n+        match (&a_subst.regions, &b_subst.regions) {\n+            (&ErasedRegions, _) | (_, &ErasedRegions) => {\n+                substs.regions = ErasedRegions;\n+            }\n \n-            let regions = try!(relate_region_params(self,\n-                                                    item_def_id,\n-                                                    r_variances,\n-                                                    a_regions,\n-                                                    b_regions));\n+            (&NonerasedRegions(ref a), &NonerasedRegions(ref b)) => {\n+                for &space in subst::ParamSpace::all().iter() {\n+                    let a_regions = a.get_slice(space);\n+                    let b_regions = b.get_slice(space);\n \n-            substs.types.replace(space, tps);\n-            substs.mut_regions().replace(space, regions);\n+                    let mut invariance = Vec::new();\n+                    let r_variances = match variances {\n+                        Some(ref variances) => {\n+                            variances.regions.get_slice(space)\n+                        }\n+                        None => {\n+                            for _ in a_regions.iter() {\n+                                invariance.push(ty::Invariant);\n+                            }\n+                            invariance.as_slice()\n+                        }\n+                    };\n+\n+                    let regions = try!(relate_region_params(self,\n+                                                            item_def_id,\n+                                                            r_variances,\n+                                                            a_regions,\n+                                                            b_regions));\n+                    substs.mut_regions().replace(space, regions);\n+                }\n+            }\n         }\n \n         return Ok(substs);"}, {"sha": "4f663df58824a14abb9e8ae072f4b2f436c65dae", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -363,6 +363,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n             infer::ExprAssignable(_) => \"mismatched types\",\n             infer::RelateTraitRefs(_) => \"mismatched traits\",\n             infer::RelateSelfType(_) => \"mismatched types\",\n+            infer::RelateOutputImplTypes(_) => \"mismatched types\",\n             infer::MatchExpressionArm(_, _) => \"match arms have incompatible types\",\n             infer::IfExpression(_) => \"if and else have incompatible types\",\n         };\n@@ -1465,7 +1466,11 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n                         format!(\"traits are compatible\")\n                     }\n                     infer::RelateSelfType(_) => {\n-                        format!(\"type matches impl\")\n+                        format!(\"self type matches impl self type\")\n+                    }\n+                    infer::RelateOutputImplTypes(_) => {\n+                        format!(\"trait type parameters matches those \\\n+                                 specified on the impl\")\n                     }\n                     infer::MatchExpressionArm(_, _) => {\n                         format!(\"match arms have compatible types\")"}, {"sha": "db90593b5b36bc2a5c44791be752a5238ce92e57", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 121, "deletions": 40, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -26,6 +26,7 @@ use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n use middle::ty;\n use middle::ty_fold;\n+use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::coercion::Coerce;\n@@ -57,6 +58,7 @@ pub mod lattice;\n pub mod lub;\n pub mod region_inference;\n pub mod resolve;\n+mod skolemize;\n pub mod sub;\n pub mod test;\n pub mod type_variable;\n@@ -114,9 +116,12 @@ pub enum TypeOrigin {\n     // Relating trait refs when resolving vtables\n     RelateTraitRefs(Span),\n \n-    // Relating trait refs when resolving vtables\n+    // Relating self types when resolving vtables\n     RelateSelfType(Span),\n \n+    // Relating trait type parameters to those found in impl etc\n+    RelateOutputImplTypes(Span),\n+\n     // Computing common supertype in the arms of a match expression\n     MatchExpressionArm(Span, Span),\n \n@@ -262,6 +267,7 @@ pub enum RegionVariableOrigin {\n     BoundRegionInCoherence(ast::Name),\n }\n \n+#[deriving(Show)]\n pub enum fixup_err {\n     unresolved_int_ty(IntVid),\n     unresolved_float_ty(FloatVid),\n@@ -336,17 +342,12 @@ pub fn mk_subty(cx: &InferCtxt,\n                 origin: TypeOrigin,\n                 a: ty::t,\n                 b: ty::t)\n-             -> ures {\n+                -> ures\n+{\n     debug!(\"mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    indent(|| {\n-        cx.commit_if_ok(|| {\n-            let trace = TypeTrace {\n-                origin: origin,\n-                values: Types(expected_found(a_is_expected, a, b))\n-            };\n-            cx.sub(a_is_expected, trace).tys(a, b)\n-        })\n-    }).to_ures()\n+    cx.commit_if_ok(|| {\n+        cx.sub_types(a_is_expected, origin, a, b)\n+    })\n }\n \n pub fn can_mk_subty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n@@ -356,8 +357,8 @@ pub fn can_mk_subty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(expected_found(true, a, b))\n         };\n-        cx.sub(true, trace).tys(a, b)\n-    }).to_ures()\n+        cx.sub(true, trace).tys(a, b).to_ures()\n+    })\n }\n \n pub fn can_mk_eqty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n@@ -393,6 +394,14 @@ pub fn verify_param_bound(cx: &InferCtxt,\n \n     cx.region_vars.verify_param_bound(origin, param_ty, a, bs);\n }\n+\n+pub fn skolemize<T:TypeFoldable+Repr>(cx: &InferCtxt, a: T) -> T {\n+    let mut skol = skolemize::TypeSkolemizer::new(cx);\n+    let b = a.fold_with(&mut skol);\n+    debug!(\"skol(a={}) -> {}\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    b\n+}\n+\n pub fn mk_eqty(cx: &InferCtxt,\n                a_is_expected: bool,\n                origin: TypeOrigin,\n@@ -401,40 +410,28 @@ pub fn mk_eqty(cx: &InferCtxt,\n             -> ures\n {\n     debug!(\"mk_eqty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.commit_if_ok(|| {\n-        let trace = TypeTrace {\n-            origin: origin,\n-            values: Types(expected_found(a_is_expected, a, b))\n-        };\n-        try!(cx.equate(a_is_expected, trace).tys(a, b));\n-        Ok(())\n-    })\n+    cx.commit_if_ok(\n+        || cx.eq_types(a_is_expected, origin, a, b))\n }\n \n pub fn mk_sub_trait_refs(cx: &InferCtxt,\n                          a_is_expected: bool,\n                          origin: TypeOrigin,\n                          a: Rc<ty::TraitRef>,\n                          b: Rc<ty::TraitRef>)\n-    -> ures\n+                         -> ures\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n            a.repr(cx.tcx), b.repr(cx.tcx));\n-    indent(|| {\n-        cx.commit_if_ok(|| {\n-            let trace = TypeTrace {\n-                origin: origin,\n-                values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n-            };\n-            let suber = cx.sub(a_is_expected, trace);\n-            suber.trait_refs(&*a, &*b)\n-        })\n-    }).to_ures()\n+    cx.commit_if_ok(\n+        || cx.sub_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n }\n \n fn expected_found<T>(a_is_expected: bool,\n                      a: T,\n-                     b: T) -> ty::expected_found<T> {\n+                     b: T)\n+                     -> ty::expected_found<T>\n+{\n     if a_is_expected {\n         ty::expected_found {expected: a, found: b}\n     } else {\n@@ -629,7 +626,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    pub fn probe<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn probe<R>(&self, f: || -> R) -> R {\n         debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -643,6 +640,54 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     {\n         self.region_vars.add_given(sub, sup);\n     }\n+\n+    pub fn sub_types(&self,\n+                     a_is_expected: bool,\n+                     origin: TypeOrigin,\n+                     a: ty::t,\n+                     b: ty::t)\n+                     -> ures\n+    {\n+        debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n+        let trace = TypeTrace {\n+            origin: origin,\n+            values: Types(expected_found(a_is_expected, a, b))\n+        };\n+        self.sub(a_is_expected, trace).tys(a, b).to_ures()\n+    }\n+\n+    pub fn eq_types(&self,\n+                    a_is_expected: bool,\n+                    origin: TypeOrigin,\n+                    a: ty::t,\n+                    b: ty::t)\n+                    -> ures\n+    {\n+        let trace = TypeTrace {\n+            origin: origin,\n+            values: Types(expected_found(a_is_expected, a, b))\n+        };\n+        self.equate(a_is_expected, trace).tys(a, b).to_ures()\n+    }\n+\n+    pub fn sub_trait_refs(&self,\n+                          a_is_expected: bool,\n+                          origin: TypeOrigin,\n+                          a: Rc<ty::TraitRef>,\n+                          b: Rc<ty::TraitRef>)\n+                          -> ures\n+    {\n+        debug!(\"sub_trait_refs({} <: {})\",\n+               a.repr(self.tcx),\n+               b.repr(self.tcx));\n+        let trace = TypeTrace {\n+            origin: origin,\n+            values: TraitRefs(expected_found(a_is_expected,\n+                                             a.clone(), b.clone()))\n+        };\n+        let suber = self.sub(a_is_expected, trace);\n+        suber.trait_refs(&*a, &*b).to_ures()\n+    }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -685,17 +730,40 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n-    pub fn fresh_substs_for_type(&self,\n-                                 span: Span,\n-                                 generics: &ty::Generics)\n-                                 -> subst::Substs\n+    pub fn fresh_substs_for_generics(&self,\n+                                     span: Span,\n+                                     generics: &ty::Generics)\n+                                     -> subst::Substs\n     {\n         /*!\n          * Given a set of generics defined on a type or impl, returns\n          * a substitution mapping each type/region parameter to a\n          * fresh inference variable.\n          */\n-        assert!(generics.types.len(subst::SelfSpace) == 0);\n+\n+        let type_params =\n+            generics.types.map(\n+                |_| self.next_ty_var());\n+        let region_params =\n+            generics.regions.map(\n+                |d| self.next_region_var(EarlyBoundRegion(span, d.name)));\n+        subst::Substs::new(type_params, region_params)\n+    }\n+\n+    pub fn fresh_substs_for_trait(&self,\n+                                  span: Span,\n+                                  generics: &ty::Generics,\n+                                  self_ty: ty::t)\n+                                  -> subst::Substs\n+    {\n+        /*!\n+         * Given a set of generics defined on a trait, returns a\n+         * substitution mapping each output type/region parameter to a\n+         * fresh inference variable, and mapping the self type to\n+         * `self_ty`.\n+         */\n+\n+        assert!(generics.types.len(subst::SelfSpace) == 1);\n         assert!(generics.types.len(subst::FnSpace) == 0);\n         assert!(generics.regions.len(subst::SelfSpace) == 0);\n         assert!(generics.regions.len(subst::FnSpace) == 0);\n@@ -704,7 +772,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n         let regions = self.region_vars_for_defs(span, region_param_defs);\n         let type_parameters = self.next_ty_vars(type_parameter_count);\n-        subst::Substs::new_type(type_parameters, regions)\n+        subst::Substs::new_trait(type_parameters, regions, self_ty)\n     }\n \n     pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {\n@@ -731,6 +799,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         trait_ref_to_string(self.tcx, &t)\n     }\n \n+    pub fn contains_unbound_type_variables(&self, typ: ty::t) -> ty::t {\n+        match resolve_type(self,\n+                           None,\n+                           typ, resolve_nested_tvar | resolve_ivar) {\n+          Ok(new_type) => new_type,\n+          Err(_) => typ\n+        }\n+    }\n+\n     pub fn resolve_type_vars_if_possible(&self, typ: ty::t) -> ty::t {\n         match resolve_type(self,\n                            None,\n@@ -907,6 +984,7 @@ impl TypeOrigin {\n             Misc(span) => span,\n             RelateTraitRefs(span) => span,\n             RelateSelfType(span) => span,\n+            RelateOutputImplTypes(span) => span,\n             MatchExpressionArm(match_span, _) => match_span,\n             IfExpression(span) => span,\n         }\n@@ -929,6 +1007,9 @@ impl Repr for TypeOrigin {\n             RelateSelfType(a) => {\n                 format!(\"RelateSelfType({})\", a.repr(tcx))\n             }\n+            RelateOutputImplTypes(a) => {\n+                format!(\"RelateOutputImplTypes({})\", a.repr(tcx))\n+            }\n             MatchExpressionArm(a, b) => {\n                 format!(\"MatchExpressionArm({}, {})\", a.repr(tcx), b.repr(tcx))\n             }"}, {"sha": "2c0b2dbe2ba79d880f51e5479316d27e98410cfc", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -46,15 +46,13 @@\n // future).  If you want to resolve everything but one type, you are\n // probably better off writing `resolve_all - resolve_ivar`.\n \n-\n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n use middle::ty::{IntType, UintType};\n use middle::ty;\n use middle::ty_fold;\n use middle::typeck::infer::{fixup_err, fres, InferCtxt};\n use middle::typeck::infer::{unresolved_int_ty,unresolved_float_ty,unresolved_ty};\n use syntax::codemap::Span;\n-use util::common::indent;\n use util::ppaux::{Repr, ty_to_string};\n \n pub static resolve_nested_tvar: uint = 0b0000000001;\n@@ -94,7 +92,7 @@ pub fn resolver<'a, 'tcx>(infcx: &'a InferCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for ResolveState<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -114,7 +112,8 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n \n     pub fn resolve_type_chk(&mut self,\n                             typ: ty::t)\n-                            -> fres<ty::t> {\n+                            -> fres<ty::t>\n+    {\n         self.err = None;\n \n         debug!(\"Resolving {} (modes={:x})\",\n@@ -126,22 +125,24 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n \n         let rty = self.resolve_type(typ);\n         match self.err {\n-          None => {\n-            debug!(\"Resolved {} to {} (modes={:x})\",\n-                   ty_to_string(self.infcx.tcx, typ),\n-                   ty_to_string(self.infcx.tcx, rty),\n-                   self.modes);\n-            return Ok(rty);\n-          }\n-          Some(e) => return Err(e)\n+            None => {\n+                debug!(\"Resolved {} to {} (modes={:x})\",\n+                       ty_to_string(self.infcx.tcx, typ),\n+                       ty_to_string(self.infcx.tcx, rty),\n+                       self.modes);\n+                return Ok(rty);\n+            }\n+            Some(e) => {\n+                return Err(e);\n+            }\n         }\n     }\n \n     pub fn resolve_region_chk(&mut self,\n                               orig: ty::Region)\n                               -> fres<ty::Region> {\n         self.err = None;\n-        let resolved = indent(|| self.resolve_region(orig) );\n+        let resolved = self.resolve_region(orig);\n         match self.err {\n           None => Ok(resolved),\n           Some(e) => Err(e)"}, {"sha": "e1d48407f2e437ae8bf3a6af0d8a06ed743ddf18", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Skolemization is the process of replacing unknown variables with\n+ * fresh types. The idea is that the type, after skolemization,\n+ * contains no inference variables but instead contains either a value\n+ * for each variable (if the variable had already fresh \"arbitrary\"\n+ * types wherever a variable would have been.\n+ *\n+ * Skolemization is used wherever we want to test what the type\n+ * inferencer knows \"so far\". The primary place it is used right now\n+ * is in the trait matching algorithm, which needs to be able to test\n+ * whether an `impl` self type matches some other type X -- *without*\n+ * affecting `X`. That means if that if the type `X` is in fact an\n+ * unbound type variable, we want the match to be regarded as\n+ * ambiguous, because depending on what type that type variable is\n+ * ultimately assigned, the match may or may not succeed.\n+ *\n+ * Note that you should be careful not to allow the output of\n+ * skolemization to leak to the user in error messages or in any other\n+ * form. Skolemization is only really useful as an internal detail.\n+ *\n+ * __An important detail concerning regions.__ The skolemizer also\n+ * replaces *all* regions with 'static. The reason behind this is\n+ * that, in general, we do not take region relationships into account\n+ * when making type-overloaded decisions. This is important because of\n+ * the design of the region inferencer, which is not based on\n+ * unification but rather on accumulating and then solving a set of\n+ * constraints. In contrast, the type inferencer assigns a value to\n+ * each type variable only once, and it does so as soon as it can, so\n+ * it is reasonable to ask what the type inferencer knows \"so far\".\n+ */\n+\n+use middle::ty;\n+use middle::ty_fold;\n+use middle::ty_fold::TypeFoldable;\n+use middle::ty_fold::TypeFolder;\n+\n+use super::InferCtxt;\n+use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n+use super::unify::SimplyUnifiable;\n+use super::unify::UnifyKey;\n+\n+pub struct TypeSkolemizer<'a, 'tcx:'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    skolemization_count: uint\n+}\n+\n+impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n+    pub fn new<'tcx>(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeSkolemizer<'a, 'tcx> {\n+        TypeSkolemizer { infcx: infcx, skolemization_count: 0 }\n+    }\n+\n+    fn probe_ty(&mut self, v: ty::TyVid) -> ty::t {\n+        self.skolemize_if_none(self.infcx.type_variables.borrow().probe(v), ty::SkolemizedTy)\n+    }\n+\n+    fn probe_unifiable<V:SimplyUnifiable,K:UnifyKey<Option<V>>>(&mut self, k: K) -> ty::t {\n+        self.skolemize_if_none(self.infcx.probe_var(k), ty::SkolemizedIntTy)\n+    }\n+\n+    fn skolemize_if_none(&mut self, o: Option<ty::t>,\n+                         skolemizer: |uint| -> ty::InferTy)\n+                         -> ty::t {\n+        match o {\n+            Some(t) => t.fold_with(self),\n+            None => {\n+                let index = self.skolemization_count;\n+                self.skolemization_count += 1;\n+                ty::mk_infer(self.tcx(), skolemizer(index))\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> &'b ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        match r {\n+            ty::ReEarlyBound(..) |\n+            ty::ReLateBound(..) => {\n+                // leave bound regions alone\n+                r\n+            }\n+\n+            ty::ReStatic |\n+            ty::ReFree(_) |\n+            ty::ReScope(_) |\n+            ty::ReInfer(_) |\n+            ty::ReEmpty => {\n+                // replace all free regions with 'static\n+                ty::ReStatic\n+            }\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+        match ty::get(t).sty {\n+            ty::ty_infer(ty::TyVar(v)) => {\n+                self.probe_ty(v)\n+            }\n+\n+            ty::ty_infer(ty::IntVar(v)) => {\n+                self.probe_unifiable(v)\n+            }\n+\n+            ty::ty_infer(ty::FloatVar(v)) => {\n+                self.probe_unifiable(v)\n+            }\n+\n+            ty::ty_infer(ty::SkolemizedTy(_)) |\n+            ty::ty_infer(ty::SkolemizedIntTy(_)) => {\n+                self.tcx().sess.bug(\"Cannot skolemize a skolemized type\");\n+            }\n+\n+            ty::ty_open(..) => {\n+                self.tcx().sess.bug(\"Cannot skolemize an open existential type\");\n+            }\n+\n+            ty::ty_nil |\n+            ty::ty_bot |\n+            ty::ty_bool |\n+            ty::ty_char |\n+            ty::ty_int(..) |\n+            ty::ty_uint(..) |\n+            ty::ty_float(..) |\n+            ty::ty_enum(..) |\n+            ty::ty_box(..) |\n+            ty::ty_uniq(..) |\n+            ty::ty_str |\n+            ty::ty_err |\n+            ty::ty_vec(..) |\n+            ty::ty_ptr(..) |\n+            ty::ty_rptr(..) |\n+            ty::ty_bare_fn(..) |\n+            ty::ty_closure(..) |\n+            ty::ty_trait(..) |\n+            ty::ty_struct(..) |\n+            ty::ty_unboxed_closure(..) |\n+            ty::ty_tup(..) |\n+            ty::ty_param(..) => {\n+                ty_fold::super_fold_ty(self, t)\n+            }\n+        }\n+    }\n+}"}, {"sha": "301582d55d6eb0bbfc6fca57126e468bbe6bf485", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -258,6 +258,7 @@ impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n  * relationship.\n  */\n pub trait SimplyUnifiable : Clone + PartialEq + Repr {\n+    fn to_type(&self) -> ty::t;\n     fn to_type_err(expected_found<Self>) -> ty::type_err;\n }\n \n@@ -286,6 +287,7 @@ pub trait InferCtxtMethodsForSimplyUnifiableTypes<V:SimplyUnifiable,\n                     a_id: K,\n                     b: V)\n                     -> ures;\n+    fn probe_var(&self, a_id: K) -> Option<ty::t>;\n }\n \n impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n@@ -370,6 +372,16 @@ impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n             }\n         }\n     }\n+\n+    fn probe_var(&self, a_id: K) -> Option<ty::t> {\n+        let tcx = self.tcx;\n+        let table = UnifyKey::unification_table(self);\n+        let node_a = table.borrow_mut().get(tcx, a_id);\n+        match node_a.value {\n+            None => None,\n+            Some(ref a_t) => Some(a_t.to_type())\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -393,6 +405,13 @@ impl UnifyKey<Option<IntVarValue>> for ty::IntVid {\n }\n \n impl SimplyUnifiable for IntVarValue {\n+    fn to_type(&self) -> ty::t {\n+        match *self {\n+            ty::IntType(i) => ty::mk_mach_int(i),\n+            ty::UintType(i) => ty::mk_mach_uint(i),\n+        }\n+    }\n+\n     fn to_type_err(err: expected_found<IntVarValue>) -> ty::type_err {\n         return ty::terr_int_mismatch(err);\n     }\n@@ -422,6 +441,10 @@ impl UnifyValue for Option<ast::FloatTy> {\n }\n \n impl SimplyUnifiable for ast::FloatTy {\n+    fn to_type(&self) -> ty::t {\n+        ty::mk_mach_float(*self)\n+    }\n+\n     fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err {\n         return ty::terr_float_mismatch(err);\n     }"}, {"sha": "7a913699280bce8b42de68cebe16d231ce76e806", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -71,9 +71,10 @@ use middle::ty;\n use util::common::time;\n use util::ppaux::Repr;\n use util::ppaux;\n-use util::nodemap::{DefIdMap, FnvHashMap};\n+use util::nodemap::{NodeMap, FnvHashMap};\n \n use std::cell::RefCell;\n+use std::rc::Rc;\n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n@@ -92,7 +93,7 @@ pub struct param_index {\n     pub index: uint\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone)]\n pub enum MethodOrigin {\n     // fully statically resolved method\n     MethodStatic(ast::DefId),\n@@ -110,27 +111,21 @@ pub enum MethodOrigin {\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone)]\n pub struct MethodParam {\n-    // the trait containing the method to be invoked\n-    pub trait_id: ast::DefId,\n+    // the precise trait reference that occurs as a bound -- this may\n+    // be a supertrait of what the user actually typed.\n+    pub trait_ref: Rc<ty::TraitRef>,\n \n-    // index of the method to be invoked amongst the trait's methods\n+    // index of uint in the list of methods for the trait\n     pub method_num: uint,\n-\n-    // index of the type parameter (from those that are in scope) that is\n-    // the type of the receiver\n-    pub param_num: param_index,\n-\n-    // index of the bound for this type parameter which specifies the trait\n-    pub bound_num: uint,\n }\n \n // details for a method invoked with a receiver whose type is an object\n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone)]\n pub struct MethodObject {\n     // the (super)trait containing the method to be invoked\n-    pub trait_id: ast::DefId,\n+    pub trait_ref: Rc<ty::TraitRef>,\n \n     // the actual base trait id of the object\n     pub object_trait_id: ast::DefId,\n@@ -154,7 +149,7 @@ pub struct MethodCallee {\n \n /**\n  * With method calls, we store some extra information in\n- * side tables (i.e method_map, vtable_map). We use\n+ * side tables (i.e method_map). We use\n  * MethodCall as a key to index into these tables instead of\n  * just directly using the expression's NodeId. The reason\n  * for this being that we may apply adjustments (coercions)\n@@ -276,10 +271,9 @@ impl Repr for vtable_origin {\n     }\n }\n \n-pub type vtable_map = RefCell<FnvHashMap<MethodCall, vtable_res>>;\n-\n-\n-pub type impl_vtable_map = RefCell<DefIdMap<vtable_res>>;\n+// For every explicit cast into an object type, maps from the cast\n+// expr to the associated trait ref.\n+pub type ObjectCastMap = RefCell<NodeMap<Rc<ty::TraitRef>>>;\n \n pub struct CrateCtxt<'a, 'tcx: 'a> {\n     // A mapping from method call sites to traits that have that method."}, {"sha": "be4a1c95e55509e1b8430c043fc5936c6fd9fe3b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -496,7 +496,13 @@ pub fn parameterized(cx: &ctxt,\n \n     if cx.sess.verbose() {\n         for t in substs.types.get_slice(subst::SelfSpace).iter() {\n-            strs.push(format!(\"for {}\", t.repr(cx)));\n+            strs.push(format!(\"self {}\", t.repr(cx)));\n+        }\n+\n+        // generally there shouldn't be any substs in the fn param\n+        // space, but in verbose mode, print them out.\n+        for t in substs.types.get_slice(subst::FnSpace).iter() {\n+            strs.push(format!(\"fn {}\", t.repr(cx)));\n         }\n     }\n \n@@ -539,15 +545,15 @@ impl Repr for () {\n     }\n }\n \n-impl<T:Repr> Repr for Rc<T> {\n+impl<'a,T:Repr> Repr for &'a T {\n     fn repr(&self, tcx: &ctxt) -> String {\n         (&**self).repr(tcx)\n     }\n }\n \n-impl<'a, T:Repr> Repr for &'a T {\n+impl<T:Repr> Repr for Rc<T> {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        (*self).repr(tcx)\n+        (&**self).repr(tcx)\n     }\n }\n \n@@ -690,7 +696,11 @@ impl Repr for ty::ParamBounds {\n \n impl Repr for ty::TraitRef {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        trait_ref_to_string(tcx, self)\n+        let base = ty::item_path_str(tcx, self.def_id);\n+        let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n+        format!(\"<{} as {}>\",\n+                self.substs.self_ty().repr(tcx),\n+                parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics))\n     }\n }\n \n@@ -962,18 +972,16 @@ impl Repr for typeck::MethodOrigin {\n \n impl Repr for typeck::MethodParam {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"MethodParam({},{:?},{:?},{:?})\",\n-                self.trait_id.repr(tcx),\n-                self.method_num,\n-                self.param_num,\n-                self.bound_num)\n+        format!(\"MethodParam({},{})\",\n+                self.trait_ref.repr(tcx),\n+                self.method_num)\n     }\n }\n \n impl Repr for typeck::MethodObject {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"MethodObject({},{:?},{:?})\",\n-                self.trait_id.repr(tcx),\n+                self.trait_ref.repr(tcx),\n                 self.method_num,\n                 self.real_index)\n     }\n@@ -1231,3 +1239,4 @@ impl<A:Repr,B:Repr> Repr for (A,B) {\n         format!(\"({},{})\", a.repr(tcx), b.repr(tcx))\n     }\n }\n+"}, {"sha": "7272425761e026824f065224208c44e62c9f1a84", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -226,7 +226,7 @@ fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n     match tcx.inherent_impls.borrow().find(&did) {\n         None => {}\n         Some(i) => {\n-            impls.extend(i.borrow().iter().map(|&did| { build_impl(cx, tcx, did) }));\n+            impls.extend(i.iter().map(|&did| { build_impl(cx, tcx, did) }));\n         }\n     }\n "}, {"sha": "b7475c8c077fc3b5f65eb327079f21c6ae9d7820", "filename": "src/librustuv/access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -136,7 +136,7 @@ impl<'a, T: Send> DerefMut<T> for Guard<'a, T> {\n }\n \n #[unsafe_destructor]\n-impl<'a, T> Drop for Guard<'a, T> {\n+impl<'a, T:Send> Drop for Guard<'a, T> {\n     fn drop(&mut self) {\n         // This guard's homing missile is still armed, so we're guaranteed to be\n         // on the same I/O event loop, so this unsafety should be ok."}, {"sha": "9177fa4a6b446958c7e418b44752ee6ef688b86c", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -379,7 +379,7 @@ pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n     receives: Cell<uint>,\n     // can't share in an arc\n-    marker: marker::NoSync,\n+    _marker: marker::NoSync,\n }\n \n /// An iterator over messages on a receiver, this iterator will block\n@@ -397,7 +397,7 @@ pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n     sends: Cell<uint>,\n     // can't share in an arc\n-    marker: marker::NoSync,\n+    _marker: marker::NoSync,\n }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n@@ -406,7 +406,7 @@ pub struct Sender<T> {\n pub struct SyncSender<T> {\n     inner: Arc<UnsafeCell<sync::Packet<T>>>,\n     // can't share in an arc\n-    marker: marker::NoSync,\n+    _marker: marker::NoSync,\n }\n \n /// This enumeration is the list of the possible reasons that try_recv could not\n@@ -543,7 +543,7 @@ impl<T: Send> Sender<T> {\n         Sender {\n             inner: UnsafeCell::new(inner),\n             sends: Cell::new(0),\n-            marker: marker::NoSync,\n+            _marker: marker::NoSync,\n         }\n     }\n \n@@ -719,7 +719,7 @@ impl<T: Send> Drop for Sender<T> {\n \n impl<T: Send> SyncSender<T> {\n     fn new(inner: Arc<UnsafeCell<sync::Packet<T>>>) -> SyncSender<T> {\n-        SyncSender { inner: inner, marker: marker::NoSync }\n+        SyncSender { inner: inner, _marker: marker::NoSync }\n     }\n \n     /// Sends a value on this synchronous channel.\n@@ -807,7 +807,7 @@ impl<T: Send> Drop for SyncSender<T> {\n \n impl<T: Send> Receiver<T> {\n     fn new(inner: Flavor<T>) -> Receiver<T> {\n-        Receiver { inner: UnsafeCell::new(inner), receives: Cell::new(0), marker: marker::NoSync }\n+        Receiver { inner: UnsafeCell::new(inner), receives: Cell::new(0), _marker: marker::NoSync }\n     }\n \n     /// Blocks waiting for a value on this receiver"}, {"sha": "521a7d0bd73d7ae9a4aa94f46b90966804807a10", "filename": "src/libsync/deque.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Flibsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fdeque.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -87,15 +87,15 @@ struct Deque<T> {\n /// There may only be one worker per deque.\n pub struct Worker<T> {\n     deque: Arc<Deque<T>>,\n-    noshare: marker::NoSync,\n+    _noshare: marker::NoSync,\n }\n \n /// The stealing half of the work-stealing deque. Stealers have access to the\n /// opposite end of the deque from the worker, and they only have access to the\n /// `steal` method.\n pub struct Stealer<T> {\n     deque: Arc<Deque<T>>,\n-    noshare: marker::NoSync,\n+    _noshare: marker::NoSync,\n }\n \n /// When stealing some data, this is an enumeration of the possible outcomes.\n@@ -153,8 +153,8 @@ impl<T: Send> BufferPool<T> {\n     pub fn deque(&self) -> (Worker<T>, Stealer<T>) {\n         let a = Arc::new(Deque::new(self.clone()));\n         let b = a.clone();\n-        (Worker { deque: a, noshare: marker::NoSync },\n-         Stealer { deque: b, noshare: marker::NoSync })\n+        (Worker { deque: a, _noshare: marker::NoSync },\n+         Stealer { deque: b, _noshare: marker::NoSync })\n     }\n \n     fn alloc(&mut self, bits: uint) -> Box<Buffer<T>> {\n@@ -217,7 +217,7 @@ impl<T: Send> Stealer<T> {\n \n impl<T: Send> Clone for Stealer<T> {\n     fn clone(&self) -> Stealer<T> {\n-        Stealer { deque: self.deque.clone(), noshare: marker::NoSync }\n+        Stealer { deque: self.deque.clone(), _noshare: marker::NoSync }\n     }\n }\n "}, {"sha": "cf07dc02b9609cf509788b23042e05d077fd70e8", "filename": "src/test/compile-fail/bad-method-typaram-kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn foo<T:'static>() {\n-    1u.bar::<T>(); //~ ERROR: does not fulfill `Send`\n+    1u.bar::<T>(); //~ ERROR `core::kinds::Send` is not implemented\n }\n \n trait bar {"}, {"sha": "4e0ad8088bee47c6d3fda00c68b4cbbbb29551db", "filename": "src/test/compile-fail/bad-sized.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -16,10 +16,8 @@ trait Trait {}\n \n pub fn main() {\n     let x: Vec<Trait + Sized> = Vec::new();\n-    //~^ ERROR instantiating a type parameter with an incompatible type `Trait+Sized`, which does not fulfill `Sized`\n-    //~^^ ERROR instantiating a type parameter with an incompatible type `Trait+Sized`, which does not fulfill `Sized`\n-    //~^^^ ERROR instantiating a type parameter with an incompatible type `Trait+Sized`, which does not fulfill `Sized`\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n+    //~^^ ERROR the trait `core::kinds::Sized` is not implemented\n     let x: Vec<Box<RefCell<Trait + Sized>>> = Vec::new();\n-    //~^ ERROR instantiating a type parameter with an incompatible type `Trait+Sized`, which does not fulfill `Sized`\n-    //~^^ ERROR instantiating a type parameter with an incompatible type `Trait+Sized`, which does not fulfill `Sized`\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }"}, {"sha": "f3b9c395e45145206dea3aecc332e1da1f4b9d3f", "filename": "src/test/compile-fail/builtin-superkinds-double-superkind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-double-superkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-double-superkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-double-superkind.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -13,9 +13,9 @@\n \n trait Foo : Send+Sync { }\n \n-impl <T: Sync> Foo for (T,) { } //~ ERROR cannot implement this trait\n+impl <T: Sync+'static> Foo for (T,) { } //~ ERROR the trait `core::kinds::Send` is not implemented\n \n-impl <T: Send> Foo for (T,T) { } //~ ERROR cannot implement this trait\n+impl <T: Send> Foo for (T,T) { } //~ ERROR the trait `core::kinds::Sync` is not implemented\n \n impl <T: Send+Sync> Foo for (T,T,T) { } // (ok)\n "}, {"sha": "76835c9955f6ea6af3ae2cf6d035414daee7e4da", "filename": "src/test/compile-fail/builtin-superkinds-in-metadata.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-in-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-in-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-in-metadata.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -21,6 +21,7 @@ struct X<T>(T);\n \n impl <T:Sync> RequiresShare for X<T> { }\n \n-impl <T:Sync> RequiresRequiresShareAndSend for X<T> { } //~ ERROR cannot implement this trait\n+impl <T:Sync+'static> RequiresRequiresShareAndSend for X<T> { }\n+//~^ ERROR the trait `core::kinds::Send` is not implemented\n \n fn main() { }"}, {"sha": "86d3d7e9cbc6cca5e105bf28d5ba805a1ac0e9ea", "filename": "src/test/compile-fail/builtin-superkinds-self-type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -12,12 +12,12 @@\n // to use capabilities granted by builtin kinds as supertraits.\n \n trait Foo : Sync+'static {\n-    fn foo(self, mut chan: Sender<Self>) {\n-        chan.send(self); //~ ERROR does not fulfill `Send`\n-    }\n+    fn foo(self, mut chan: Sender<Self>) { }\n }\n \n impl <T: Sync> Foo for T { }\n+//~^ ERROR the parameter type `T` may not live long enough\n+//~^^ ERROR the parameter type `T` may not live long enough\n \n fn main() {\n     let (tx, rx) = channel();"}, {"sha": "fda83c03a7dce9c8252817d500c035fe709b29d1", "filename": "src/test/compile-fail/builtin-superkinds-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -14,6 +14,6 @@\n trait Foo : Send { }\n \n impl <'a> Foo for &'a mut () { }\n-//~^ ERROR which does not fulfill `Send`, cannot implement this trait\n+//~^ ERROR does not fulfill the required lifetime\n \n fn main() { }"}, {"sha": "e77177f7f6d296ad68929b9498913dedcef45bb2", "filename": "src/test/compile-fail/builtin-superkinds-typaram-not-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-typaram-not-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-typaram-not-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-typaram-not-send.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -12,6 +12,6 @@\n \n trait Foo : Send { }\n \n-impl <T: Sync> Foo for T { } //~ ERROR cannot implement this trait\n+impl <T: Sync+'static> Foo for T { } //~ ERROR the trait `core::kinds::Send` is not implemented\n \n fn main() { }"}, {"sha": "b6277a3e2bd9863fbc9b07063826ef9809174145", "filename": "src/test/compile-fail/comm-not-freeze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -11,7 +11,7 @@\n fn test<T: Sync>() {}\n \n fn main() {\n-    test::<Sender<int>>();        //~ ERROR: does not fulfill `Sync`\n-    test::<Receiver<int>>();        //~ ERROR: does not fulfill `Sync`\n-    test::<Sender<int>>();  //~ ERROR: does not fulfill `Sync`\n+    test::<Sender<int>>();        //~ ERROR: `core::kinds::Sync` is not implemented\n+    test::<Receiver<int>>();        //~ ERROR: `core::kinds::Sync` is not implemented\n+    test::<Sender<int>>();  //~ ERROR: `core::kinds::Sync` is not implemented\n }"}, {"sha": "c1aa6ccd9bde6ff20ab6b687a91a7ed81b21af29", "filename": "src/test/compile-fail/conflicting-implementations-aux.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fconflicting-implementations-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fconflicting-implementations-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconflicting-implementations-aux.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -15,10 +15,7 @@\n extern crate trait_impl_conflict;\n use trait_impl_conflict::Foo;\n \n-impl<A> Foo for A {\n-//~^ ERROR conflicting implementations for trait `trait_impl_conflict::Foo`\n-//~^^ ERROR cannot provide an extension implementation where both trait and type\n-//          are not defined in this crate\n+impl<A> Foo for A { //~ ERROR E0117\n }\n \n fn main() {"}, {"sha": "b5a04491111bf7bb00370ed5efd32326787774df", "filename": "src/test/compile-fail/conflicting-implementations.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fconflicting-implementations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fconflicting-implementations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconflicting-implementations.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: conflicting implementations for trait `Foo`\n trait Foo {\n }\n \n-impl Foo for int {\n+impl Foo for int { //~ ERROR conflicting implementations\n \n }\n \n-impl<A> Foo for A {\n+impl<A> Foo for A { //~ NOTE conflicting implementation here\n \n }\n "}, {"sha": "1da88f2e2577eadae5c035f1accf85cdc18b1486", "filename": "src/test/compile-fail/deriving-span-Default-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-struct.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -18,7 +18,7 @@ struct Error;\n \n #[deriving(Default)]\n struct Struct {\n-    x: Error //~ ERROR\n+    x: Error //~ ERROR `core::default::Default` is not implemented\n }\n \n fn main() {}"}, {"sha": "fb7759c6032e86687dfd11bfd145e05ca81c25d6", "filename": "src/test/compile-fail/deriving-span-Zero-struct.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -16,11 +16,9 @@ extern crate rand;\n \n struct Error;\n \n-#[deriving(Zero)]   //~ ERROR failed to find an implementation\n+#[deriving(Zero)]   //~ ERROR not implemented\n struct Struct {\n-    x: Error //~ ERROR failed to find an implementation\n-    //~^ ERROR failed to find an implementation\n-    //~^^ ERROR type `Error` does not implement any method in scope\n+    x: Error\n }\n \n fn main() {}"}, {"sha": "193e4b5c6b2d51a665d9ac18a3a80c35909d2daf", "filename": "src/test/compile-fail/deriving-span-Zero-tuple-struct.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -16,11 +16,9 @@ extern crate rand;\n \n struct Error;\n \n-#[deriving(Zero)]   //~ ERROR failed to find an implementation\n+#[deriving(Zero)]   //~ ERROR not implemented\n struct Struct(\n-    Error //~ ERROR\n-    //~^ ERROR failed to find an implementation\n-    //~^^ ERROR type `Error` does not implement any method in scope\n+    Error\n );\n \n fn main() {}"}, {"sha": "8304afa1141ee7b9701f9fbcf92c2d9eeb6debb2", "filename": "src/test/compile-fail/drop-on-non-struct.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -8,12 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-\n-type Foo = Vec<u8>;\n-\n-impl Drop for Foo {\n-//~^ ERROR cannot provide an extension implementation\n+impl Drop for int {\n+    //~^ ERROR the Drop trait may only be implemented on structures\n+    //~^^ ERROR cannot provide an extension implementation\n     fn drop(&mut self) {\n         println!(\"kaboom\");\n     }"}, {"sha": "112a424427a864298ee5ff7d1a41e1aa4f6425ff", "filename": "src/test/compile-fail/dst-bad-assign-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -42,6 +42,6 @@ pub fn main() {\n     // Assignment.\n     let f5: &mut Fat<ToBar> = &mut Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n     let z: Box<ToBar> = box Bar1 {f: 36};\n-    f5.ptr = *z;  //~ ERROR dynamically sized type on lhs of assignment\n-    //~^ ERROR E0161\n+    f5.ptr = *z;\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }"}, {"sha": "f18f4a36640c9d0ebd9ba614834da28e46f771c3", "filename": "src/test/compile-fail/dst-bad-assign.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -43,4 +43,5 @@ pub fn main() {\n     let f5: &mut Fat<ToBar> = &mut Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n     let z: Box<ToBar> = box Bar1 {f: 36};\n     f5.ptr = Bar1 {f: 36}; //~ ERROR mismatched types: expected `ToBar`, found `Bar1`\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented for the type `ToBar`\n }"}, {"sha": "4247f91a4fc53e6f3fbe74f15c93dc6385b92826", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -28,5 +28,5 @@ pub fn main() {\n     let f1 = Fat { ptr: Foo };\n     let f2: &Fat<Foo> = &f1;\n     let f3: &Fat<Bar> = f2;\n-    //~^ ERROR failed to find an implementation of trait Bar for Foo\n+    //~^ ERROR the trait `Bar` is not implemented for the type `Foo`\n }"}, {"sha": "e1a754b633208bbdf8abc0db523e74b3397d851a", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -22,10 +22,10 @@ pub fn main() {\n     // With a vec of ints.\n     let f1 = Fat { ptr: [1, 2, 3] };\n     let f2: &Fat<[int, ..3]> = &f1;\n-    let f3: &mut Fat<[int]> = f2; //~ ERROR cannot borrow immutable dereference\n+    let f3: &mut Fat<[int]> = f2; //~ ERROR mismatched types\n \n     // With a trait.\n     let f1 = Fat { ptr: Foo };\n     let f2: &Fat<Foo> = &f1;\n-    let f3: &mut Fat<Bar> = f2; //~ ERROR cannot borrow immutable dereference\n+    let f3: &mut Fat<Bar> = f2; //~ ERROR mismatched types\n }"}, {"sha": "c3a814e3f44ff12b7f5b093461fee4f70b00c9a4", "filename": "src/test/compile-fail/dst-bad-coercions.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -30,10 +30,9 @@ pub fn main() {\n     let y: &T = x; //~ ERROR mismatched types\n \n     // Test that we cannot convert an immutable ptr to a mutable one using *-ptrs\n-    let x: &mut T = &S; //~ ERROR types differ in mutability\n-    let x: *mut T = &S; //~ ERROR types differ in mutability\n-    let x: *mut S = &S;\n-    //~^ ERROR mismatched types\n+    let x: &mut T = &S; //~ ERROR mismatched types\n+    let x: *mut T = &S; //~ ERROR mismatched types\n+    let x: *mut S = &S; //~ ERROR mismatched types\n \n     // The below four sets of tests test that we cannot implicitly deref a *-ptr\n     // during a coercion."}, {"sha": "506322d41f531c975fc0ec82d8a3636eed758727", "filename": "src/test/compile-fail/dst-bad-deep.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -21,6 +21,5 @@ pub fn main() {\n     let f: Fat<[int, ..3]> = Fat { ptr: [5i, 6, 7] };\n     let g: &Fat<[int]> = &f;\n     let h: &Fat<Fat<[int]>> = &Fat { ptr: *g };\n-    //~^ ERROR trying to initialise a dynamically sized struct\n-    //~^^ ERROR E0161\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }"}, {"sha": "750b475adb2bb847ef48e81234b3b669f01d4fa2", "filename": "src/test/compile-fail/dst-sized-trait-param.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-sized-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fdst-sized-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-sized-trait-param.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that when you implement a trait that has a sized type\n+// parameter, the corresponding value must be sized. Also that the\n+// self type must be sized if appropriate.\n+\n+trait Foo<T> { fn take(self, x: &T) { } } // Note: T is sized\n+\n+impl Foo<[int]> for uint { }\n+//~^ ERROR the trait `core::kinds::Sized` is not implemented for the type `[int]`\n+\n+impl Foo<int> for [uint] { }\n+//~^ ERROR the trait `core::kinds::Sized` is not implemented for the type `[uint]`\n+\n+pub fn main() { }"}, {"sha": "3d25c7ee772f626f95963eb35bf63d26d7003355", "filename": "src/test/compile-fail/error-should-say-copy-not-pod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ferror-should-say-copy-not-pod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ferror-should-say-copy-not-pod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ferror-should-say-copy-not-pod.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -13,5 +13,5 @@\n fn check_bound<T:Copy>(_: T) {}\n \n fn main() {\n-    check_bound(\"nocopy\".to_string()); //~ ERROR does not fulfill `Copy`\n+    check_bound(\"nocopy\".to_string()); //~ ERROR the trait `core::kinds::Copy` is not implemented\n }"}, {"sha": "194047ce848f6e8d2104d13055eb1b1cf8870ff6", "filename": "src/test/compile-fail/ifmt-unimpl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     format!(\"{:d}\", \"3\");\n-    //~^ ERROR: failed to find an implementation of trait core::fmt::Signed\n+    //~^ ERROR: the trait `core::fmt::Signed` is not implemented\n }"}, {"sha": "69a35bcbd7b1153a7a105a67e3b86719847b3cb5", "filename": "src/test/compile-fail/impl-bounds-checking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fimpl-bounds-checking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fimpl-bounds-checking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-bounds-checking.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -17,7 +17,7 @@ trait Getter<T: Clone2> {\n     fn get(&self) -> T;\n }\n \n-impl Getter<int> for int { //~ ERROR failed to find an implementation of trait Clone2 for int\n+impl Getter<int> for int { //~ ERROR the trait `Clone2` is not implemented\n     fn get(&self) -> int { *self }\n }\n "}, {"sha": "75b9626a6596f4590823b0e5962fdfd16181cc6b", "filename": "src/test/compile-fail/issue-14915.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -15,8 +15,8 @@ fn main() {\n     let y: Gc<int> = box (GC) 0;\n \n     println!(\"{}\", x + 1); //~ ERROR binary operation `+` cannot be applied to type `Box<int>`\n-    //~^ ERROR cannot determine a type for this bounded type parameter: unconstrained type\n+    //~^ ERROR unable to infer enough type information\n     println!(\"{}\", y + 1);\n     //~^ ERROR binary operation `+` cannot be applied to type `Gc<int>`\n-    //~^^ ERROR cannot determine a type for this bounded type parameter: unconstrained type\n+    //~^^ ERROR unable to infer enough type information\n }"}, {"sha": "981abf6cc23d8867cd58ba26874d85926034cee9", "filename": "src/test/compile-fail/issue-3907-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -17,6 +17,6 @@ struct S {\n     name: int\n }\n \n-fn bar(_x: Foo) {} //~ ERROR variable `_x` has dynamically sized type\n+fn bar(_x: Foo) {} //~ ERROR the trait `core::kinds::Sized` is not implemented\n \n fn main() {}"}, {"sha": "d0830ff8e4d76efda060130a8ebed5ff539128ce", "filename": "src/test/compile-fail/issue-5035-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -11,6 +11,6 @@\n trait I {}\n type K = I+'static;\n \n-fn foo(_x: K) {} //~ ERROR: variable `_x` has dynamically sized type\n+fn foo(_x: K) {} //~ ERROR: the trait `core::kinds::Sized` is not implemented\n \n fn main() {}"}, {"sha": "71b1bcd69da333afb71ff123bd1316e31857e0ce", "filename": "src/test/compile-fail/issue-5883.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -15,10 +15,9 @@ struct Struct {\n }\n \n fn new_struct(r: A+'static) -> Struct {\n-    //~^ ERROR variable `r` has dynamically sized type\n-    Struct { r: r } //~ ERROR trying to initialise a dynamically sized struct\n-    //~^ ERROR E0161\n-    //~^^ ERROR E0161\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n+    Struct { r: r }\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }\n \n trait Curve {}"}, {"sha": "701bee85fd732fce8044b3b1d80a2e6d40d3be3a", "filename": "src/test/compile-fail/issue-6458-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -11,5 +11,6 @@\n extern crate debug;\n \n fn main() {\n-    format!(\"{:?}\", None); //~ ERROR: cannot determine a type for this bounded\n+    // Unconstrained type:\n+    format!(\"{:?}\", None); //~ ERROR: E0101\n }"}, {"sha": "3d16ff0a3fac93188ac1770a7d72cfdcfa352167", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -32,10 +32,5 @@ struct A {\n \n fn main() {\n     let a = A {v: box B{v: None} as Box<Foo+Send>};\n-    //~^ ERROR cannot pack type `Box<B>`, which does not fulfill `Send`, as a trait bounded by Send\n-    let v = Rc::new(RefCell::new(a));\n-    let w = v.clone();\n-    let b = &*v;\n-    let mut b = b.borrow_mut();\n-    b.v.set(w.clone());\n+    //~^ ERROR the trait `core::kinds::Send` is not implemented for the type `B`\n }"}, {"sha": "3524d11d1842a621e2c05952cb956479a1eddb8c", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -34,29 +34,29 @@ fn test<'a,T,U:Copy>(_: &'a int) {\n     assert_copy::<&'a [int]>();\n \n     // ...unless they are mutable\n-    assert_copy::<&'static mut int>(); //~ ERROR does not fulfill\n-    assert_copy::<&'a mut int>();  //~ ERROR does not fulfill\n+    assert_copy::<&'static mut int>(); //~ ERROR `core::kinds::Copy` is not implemented\n+    assert_copy::<&'a mut int>();  //~ ERROR `core::kinds::Copy` is not implemented\n \n     // ~ pointers are not ok\n-    assert_copy::<Box<int>>();   //~ ERROR does not fulfill\n-    assert_copy::<String>();   //~ ERROR does not fulfill\n-    assert_copy::<Vec<int> >(); //~ ERROR does not fulfill\n-    assert_copy::<Box<&'a mut int>>(); //~ ERROR does not fulfill\n+    assert_copy::<Box<int>>();   //~ ERROR `core::kinds::Copy` is not implemented\n+    assert_copy::<String>();   //~ ERROR `core::kinds::Copy` is not implemented\n+    assert_copy::<Vec<int> >(); //~ ERROR `core::kinds::Copy` is not implemented\n+    assert_copy::<Box<&'a mut int>>(); //~ ERROR `core::kinds::Copy` is not implemented\n \n     // borrowed object types are generally ok\n     assert_copy::<&'a Dummy>();\n     assert_copy::<&'a Dummy+Copy>();\n     assert_copy::<&'static Dummy+Copy>();\n \n     // owned object types are not ok\n-    assert_copy::<Box<Dummy>>(); //~ ERROR does not fulfill\n-    assert_copy::<Box<Dummy+Copy>>(); //~ ERROR does not fulfill\n+    assert_copy::<Box<Dummy>>(); //~ ERROR `core::kinds::Copy` is not implemented\n+    assert_copy::<Box<Dummy+Copy>>(); //~ ERROR `core::kinds::Copy` is not implemented\n \n     // mutable object types are not ok\n-    assert_copy::<&'a mut Dummy+Copy>();  //~ ERROR does not fulfill\n+    assert_copy::<&'a mut Dummy+Copy>();  //~ ERROR `core::kinds::Copy` is not implemented\n \n     // closures are like an `&mut` object\n-    assert_copy::<||>(); //~ ERROR does not fulfill\n+    assert_copy::<||>(); //~ ERROR `core::kinds::Copy` is not implemented\n \n     // unsafe ptrs are ok\n     assert_copy::<*const int>();\n@@ -74,11 +74,11 @@ fn test<'a,T,U:Copy>(_: &'a int) {\n     assert_copy::<MyStruct>();\n \n     // structs containing non-POD are not ok\n-    assert_copy::<MyNoncopyStruct>(); //~ ERROR does not fulfill\n+    assert_copy::<MyNoncopyStruct>(); //~ ERROR `core::kinds::Copy` is not implemented\n \n     // managed or ref counted types are not ok\n-    assert_copy::<Gc<int>>();   //~ ERROR does not fulfill\n-    assert_copy::<Rc<int>>();   //~ ERROR does not fulfill\n+    assert_copy::<Gc<int>>();   //~ ERROR `core::kinds::Copy` is not implemented\n+    assert_copy::<Rc<int>>();   //~ ERROR `core::kinds::Copy` is not implemented\n }\n \n pub fn main() {"}, {"sha": "6b25289567b27157a8042a0271222ad1fcf64e06", "filename": "src/test/compile-fail/kindck-impl-type-params-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -19,5 +19,5 @@ fn take_param<T:Foo>(foo: &T) { }\n fn main() {\n     let x = box 3i;\n     take_param(&x);\n-    //~^ ERROR instantiating a type parameter with an incompatible type\n+    //~^ ERROR the trait `core::kinds::Copy` is not implemented\n }"}, {"sha": "c92887965c0d2010eae0c3556555e453001871dd", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -20,20 +20,22 @@ impl<T: Send + Copy> Gettable<T> for S<T> {}\n fn f<T>(val: T) {\n     let t: S<T> = S;\n     let a = &t as &Gettable<T>;\n-    //~^ ERROR instantiating a type parameter with an incompatible type `T`\n+    //~^ ERROR the trait `core::kinds::Send` is not implemented\n+    //~^^ ERROR the trait `core::kinds::Copy` is not implemented\n     let a: &Gettable<T> = &t;\n-    //~^ ERROR instantiating a type parameter with an incompatible type `T`\n+    //~^ ERROR the trait `core::kinds::Send` is not implemented\n+    //~^^ ERROR the trait `core::kinds::Copy` is not implemented\n }\n \n-fn main() {\n-    let t: S<&int> = S;\n-    let a = &t as &Gettable<&int>;\n-    //~^ ERROR instantiating a type parameter with an incompatible type\n+fn foo<'a>() {\n+    let t: S<&'a int> = S;\n+    let a = &t as &Gettable<&'a int>;\n     let t: Box<S<String>> = box S;\n     let a = t as Box<Gettable<String>>;\n-    //~^ ERROR instantiating a type parameter with an incompatible type\n+    //~^ ERROR the trait `core::kinds::Copy` is not implemented\n     let t: Box<S<String>> = box S;\n     let a: Box<Gettable<String>> = t;\n-    //~^ ERROR instantiating a type parameter with an incompatible type\n+    //~^ ERROR the trait `core::kinds::Copy` is not implemented\n }\n \n+fn main() { }"}, {"sha": "51ee38d5cfed2af9c3a4483e0e8461b914cfcd55", "filename": "src/test/compile-fail/kindck-inherited-copy-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -23,8 +23,8 @@ fn take_param<T:Foo>(foo: &T) { }\n \n fn main() {\n     let x = box 3i;\n-    take_param(&x); //~ ERROR does not fulfill `Copy`\n+    take_param(&x); //~ ERROR `core::kinds::Copy` is not implemented\n \n     let y = &x;\n-    let z = &x as &Foo; //~ ERROR does not fulfill `Copy`\n+    let z = &x as &Foo; //~ ERROR `core::kinds::Copy` is not implemented\n }"}, {"sha": "d87d1a33ca13144c87d8ab425e7c9f10f7e39245", "filename": "src/test/compile-fail/kindck-proc-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-proc-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-proc-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-proc-bounds.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -13,10 +13,10 @@ fn is_freeze<T: Sync>() {}\n \n fn foo<'a>() {\n     is_send::<proc()>();\n-    //~^ ERROR: instantiating a type parameter with an incompatible type\n+    //~^ ERROR: the trait `core::kinds::Send` is not implemented\n \n     is_freeze::<proc()>();\n-    //~^ ERROR: instantiating a type parameter with an incompatible type\n+    //~^ ERROR: the trait `core::kinds::Sync` is not implemented\n }\n \n fn main() { }"}, {"sha": "9217d05002d88115674cd036d9549c1e3d311aa1", "filename": "src/test/compile-fail/kindck-send-object.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -19,19 +19,20 @@ trait Message : Send { }\n // careful with object types, who knows what they close over...\n \n fn object_ref_with_static_bound_not_ok() {\n-    assert_send::<&'static Dummy+'static>(); //~ ERROR does not fulfill\n+    assert_send::<&'static Dummy+'static>();\n+    //~^ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n fn box_object_with_no_bound_not_ok<'a>() {\n-    assert_send::<Box<Dummy>>(); //~ ERROR does not fulfill\n+    assert_send::<Box<Dummy>>(); //~ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n fn proc_with_no_bound_not_ok<'a>() {\n-    assert_send::<proc()>(); //~ ERROR does not fulfill\n+    assert_send::<proc()>(); //~ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n fn closure_with_no_bound_not_ok<'a>() {\n-    assert_send::<||:'static>(); //~ ERROR does not fulfill\n+    assert_send::<||:'static>(); //~ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n fn object_with_send_bound_ok() {"}, {"sha": "9b0991e9ac6deeec2af892e9326e091c3dd75ab5", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -18,6 +18,7 @@ trait Dummy { }\n // careful with object types, who knows what they close over...\n fn test51<'a>() {\n     assert_send::<&'a Dummy>(); //~ ERROR does not fulfill the required lifetime\n+    //~^ ERROR the trait `core::kinds::Send` is not implemented\n }\n fn test52<'a>() {\n     assert_send::<&'a Dummy+Send>(); //~ ERROR does not fulfill the required lifetime\n@@ -35,10 +36,12 @@ fn test61() {\n // them not ok\n fn test_70<'a>() {\n     assert_send::<proc():'a>(); //~ ERROR does not fulfill the required lifetime\n+    //~^ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n fn test_71<'a>() {\n     assert_send::<Box<Dummy+'a>>(); //~ ERROR does not fulfill the required lifetime\n+    //~^ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n fn main() { }"}, {"sha": "d46c6e68c05c20e5e38d4fdf07f8a53295bafc0f", "filename": "src/test/compile-fail/kindck-send-object2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -14,11 +14,11 @@ fn assert_send<T:Send>() { }\n trait Dummy { }\n \n fn test50() {\n-    assert_send::<&'static Dummy>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<&'static Dummy>(); //~ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n fn test53() {\n-    assert_send::<Box<Dummy>>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<Box<Dummy>>(); //~ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n // ...unless they are properly bounded"}, {"sha": "a9bbfcfa26263c50fba60f3bcab62077bf7b5e0b", "filename": "src/test/compile-fail/kindck-send-unsafe.rs~rust-lang_master", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs%7Erust-lang_master", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs%7Erust-lang_master", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs%7Erust-lang_master?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn assert_send<T:Send>() { }\n+\n+// unsafe ptrs are ok unless they point at unsendable things\n+fn test70() {\n+    assert_send::<*mut int>();\n+}\n+fn test71<'a>() {\n+    assert_send::<*mut &'a int>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+fn main() {\n+}"}, {"sha": "cbe391324794fe4a60e5851b987bf839ab7d307d", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -18,6 +18,5 @@ fn main() {\n     let x: Box<HashMap<int, int>> = box HashMap::new();\n     let x: Box<Map<int, int>> = x;\n     let y: Box<Map<uint, int>> = box x;\n-    //~^ ERROR failed to find an implementation of trait collections::Map<uint,int>\n-    //~^^ ERROR failed to find an implementation of trait core::collections::Collection\n+    //~^ ERROR the trait `collections::Map<uint,int>` is not implemented\n }"}, {"sha": "d620c13cc2520d15efb0d934bc44811a6dc094d4", "filename": "src/test/compile-fail/marker-no-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fmarker-no-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fmarker-no-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmarker-no-copy.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -14,5 +14,5 @@ fn foo<P:Copy>(p: P) { }\n \n fn main()\n {\n-    foo(marker::NoCopy); //~ ERROR does not fulfill\n+    foo(marker::NoCopy); //~ ERROR the trait `core::kinds::Copy` is not implemented\n }"}, {"sha": "813e2548398b51304ab2ee03558c32a12350b9b8", "filename": "src/test/compile-fail/marker-no-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fmarker-no-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fmarker-no-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmarker-no-send.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -14,5 +14,5 @@ fn foo<P:Send>(p: P) { }\n \n fn main()\n {\n-    foo(marker::NoSend); //~ ERROR does not fulfill `Send`\n+    foo(marker::NoSend); //~ ERROR the trait `core::kinds::Send` is not implemented\n }"}, {"sha": "735e61fa139f0195e9bb24416af25c33af05767b", "filename": "src/test/compile-fail/marker-no-share.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fmarker-no-share.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fmarker-no-share.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmarker-no-share.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -14,5 +14,5 @@ fn foo<P: Sync>(p: P) { }\n \n fn main()\n {\n-    foo(marker::NoSync); //~ ERROR does not fulfill `Sync`\n+    foo(marker::NoSync); //~ ERROR the trait `core::kinds::Sync` is not implemented\n }"}, {"sha": "60921c041356fc39137aac8fc87af2489baf7d7c", "filename": "src/test/compile-fail/mut-not-freeze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -14,5 +14,5 @@ fn f<T: Sync>(_: T) {}\n \n fn main() {\n     let x = RefCell::new(0i);\n-    f(x); //~ ERROR: which does not fulfill `Sync`\n+    f(x); //~ ERROR `core::kinds::Sync` is not implemented\n }"}, {"sha": "96937524ad51319b33f031bd2b417337f64275f4", "filename": "src/test/compile-fail/mutable-enum-indirect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -19,5 +19,5 @@ fn bar<T: Sync>(_: T) {}\n \n fn main() {\n     let x = A(marker::NoSync);\n-    bar(&x); //~ ERROR type parameter with an incompatible type\n+    bar(&x); //~ ERROR the trait `core::kinds::Sync` is not implemented\n }"}, {"sha": "f58350cf0934faec0dc8bc02824eec313b1e13fe", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -36,7 +36,8 @@ fn main() {\n     let x = foo(Port(box(GC) ()));\n \n     task::spawn(proc() {\n-        let y = x;   //~ ERROR does not fulfill `Send`\n+        let y = x;\n+        //~^ ERROR does not fulfill `Send`\n         println!(\"{:?}\", y);\n     });\n }"}, {"sha": "2235a265bba16ec998341d11e11d6f78b94134d8", "filename": "src/test/compile-fail/no_send-enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno_send-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno_send-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_send-enum.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -19,6 +19,5 @@ fn bar<T: Send>(_: T) {}\n fn main() {\n     let x = A(marker::NoSend);\n     bar(x);\n-    //~^ ERROR instantiating a type parameter with an incompatible type `Foo`,\n-    //         which does not fulfill `Send`\n+    //~^ ERROR `core::kinds::Send` is not implemented\n }"}, {"sha": "c05b17afe1d27bf960eb7217fc6e7f3089efb668", "filename": "src/test/compile-fail/no_send-rc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno_send-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno_send-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_send-rc.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -15,6 +15,5 @@ fn bar<T: Send>(_: T) {}\n fn main() {\n     let x = Rc::new(5i);\n     bar(x);\n-    //~^ ERROR instantiating a type parameter with an incompatible type `alloc::rc::Rc<int>`,\n-    //         which does not fulfill `Send`\n+    //~^ ERROR `core::kinds::Send` is not implemented\n }"}, {"sha": "6e84578e92e3b9d0ea29ba92fa324be45fc846d5", "filename": "src/test/compile-fail/no_send-struct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno_send-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno_send-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_send-struct.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -20,6 +20,5 @@ fn bar<T: Send>(_: T) {}\n fn main() {\n     let x = Foo { a: 5, ns: marker::NoSend };\n     bar(x);\n-    //~^ ERROR instantiating a type parameter with an incompatible type `Foo`,\n-    //         which does not fulfill `Send`\n+    //~^ ERROR the trait `core::kinds::Send` is not implemented\n }"}, {"sha": "1a692dab6d49011efab646195338c7874332a92d", "filename": "src/test/compile-fail/no_share-enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno_share-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno_share-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_share-enum.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -17,6 +17,5 @@ fn bar<T: Sync>(_: T) {}\n fn main() {\n     let x = A(marker::NoSync);\n     bar(x);\n-    //~^ ERROR instantiating a type parameter with an incompatible type `Foo`,\n-    //         which does not fulfill `Sync`\n+    //~^ ERROR the trait `core::kinds::Sync` is not implemented\n }"}, {"sha": "5572f72d8fe834313a5c8a81f84647f16b560af1", "filename": "src/test/compile-fail/no_share-rc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno_share-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno_share-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_share-rc.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -16,6 +16,5 @@ fn bar<T: Sync>(_: T) {}\n fn main() {\n     let x = Rc::new(RefCell::new(5i));\n     bar(x);\n-    //~^ ERROR instantiating a type parameter with an incompatible type\n-    //         `std::rc::Rc<std::cell::RefCell<int>>`, which does not fulfill `Sync`\n+    //~^ ERROR the trait `core::kinds::Sync` is not implemented\n }"}, {"sha": "1379a9f7382b006678b007d268ecf93238a305eb", "filename": "src/test/compile-fail/no_share-struct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno_share-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fno_share-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_share-struct.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -17,6 +17,5 @@ fn bar<T: Sync>(_: T) {}\n fn main() {\n     let x = Foo { a: 5, m: marker::NoSync };\n     bar(x);\n-    //~^ ERROR instantiating a type parameter with an incompatible type `Foo`,\n-    //         which does not fulfill `Sync`\n+    //~^ ERROR the trait `core::kinds::Sync` is not implemented\n }"}, {"sha": "cfaf149a49cac6f4d4d2b2f45897e4d63688dd0a", "filename": "src/test/compile-fail/object-does-not-impl-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -14,6 +14,6 @@\n \n trait Foo {}\n fn take_foo<F:Foo>(f: F) {}\n-fn take_object(f: Box<Foo>) { take_foo(f); } //~ ERROR failed to find an implementation of trait\n-//~^ ERROR failed to find an implementation\n+fn take_object(f: Box<Foo>) { take_foo(f); }\n+//~^ ERROR the trait `Foo` is not implemented\n fn main() {}"}, {"sha": "0e8bb40e0ffee01357bae2610b948078587603a1", "filename": "src/test/compile-fail/pinned-deep-copy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -43,8 +43,7 @@ fn main() {\n     {\n         // Can't do this copy\n         let x = box box box A {y: r(i)};\n-        let _z = x.clone(); //~ ERROR failed to find an implementation\n-        //~^ ERROR failed to find an implementation\n+        let _z = x.clone(); //~ ERROR not implemented\n         println!(\"{:?}\", x);\n     }\n     println!(\"{:?}\", *i);"}, {"sha": "c6a9f67cfc651babc3b6e836a1933dfeaca78047", "filename": "src/test/compile-fail/regions-bound-missing-bound-in-impl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -12,8 +12,6 @@\n // nominal types (but not on other types) and that they are type\n // checked.\n \n-#![no_std]\n-\n struct Inv<'a> { // invariant w/r/t 'a\n     x: &'a mut &'a int\n }"}, {"sha": "50190411bf09bd770d9311ccb3b32dd58f88baf0", "filename": "src/test/compile-fail/regions-bounded-by-send.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -58,6 +58,7 @@ fn box_with_region_not_ok<'a>() {\n \n fn object_with_random_bound_not_ok<'a>() {\n     assert_send::<&'a Dummy+'a>(); //~ ERROR does not fulfill\n+    //~^ ERROR not implemented\n }\n \n fn object_with_send_bound_not_ok<'a>() {\n@@ -66,10 +67,12 @@ fn object_with_send_bound_not_ok<'a>() {\n \n fn proc_with_lifetime_not_ok<'a>() {\n     assert_send::<proc():'a>(); //~ ERROR does not fulfill\n+    //~^ ERROR not implemented\n }\n \n fn closure_with_lifetime_not_ok<'a>() {\n     assert_send::<||:'a>(); //~ ERROR does not fulfill\n+    //~^ ERROR not implemented\n }\n \n // unsafe pointers are ok unless they point at unsendable things"}, {"sha": "279139d8de96a0e1520074b1d802027173acc7ea", "filename": "src/test/compile-fail/regions-bounded-method-type-parameters.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![no_std]\n-\n // Check that explicit region bounds are allowed on the various\n // nominal types (but not on other types) and that they are type\n // checked."}, {"sha": "adc960b069d05d89f798d1a7e7673c5445e1189a", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![no_std]\n-\n #![allow(dead_code)]\n \n trait Deref {"}, {"sha": "773d6e2c703655433b6afa9355de737a2e225ae5", "filename": "src/test/compile-fail/regions-lifetime-bounds-on-fns.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![no_std]\n-\n fn a<'a, 'b:'a>(x: &mut &'a int, y: &mut &'b int) {\n     // Note: this is legal because of the `'b:'a` declaration.\n     *x = *y;"}, {"sha": "8fdf586b3d1de4ec3a88cefcc140ce102c79ec08", "filename": "src/test/compile-fail/repeat-to-run-dtor-twice.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Frepeat-to-run-dtor-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Frepeat-to-run-dtor-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat-to-run-dtor-twice.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -24,5 +24,6 @@ impl Drop for Foo {\n \n fn main() {\n     let a = Foo { x: 3 };\n-    let _ = [ a, ..5 ];     //~ ERROR copying a value of non-copyable type\n+    let _ = [ a, ..5 ];\n+    //~^ ERROR the trait `core::kinds::Copy` is not implemented for the type `Foo`\n }"}, {"sha": "e9997083babd2d0336d6287319d1b87fdab8e110", "filename": "src/test/compile-fail/task-rng-isnt-sendable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -16,5 +16,5 @@ fn test_send<S: Send>() {}\n \n pub fn main() {\n     test_send::<rand::TaskRng>();\n-    //~^ ERROR: incompatible type `std::rand::TaskRng`, which does not fulfill `Send`\n+    //~^ ERROR `core::kinds::Send` is not implemented\n }"}, {"sha": "85a2761172d6136d6973d940217826eabeb99be2", "filename": "src/test/compile-fail/trait-bounds-not-on-bare-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -14,7 +14,7 @@ trait Foo {\n // This should emit the less confusing error, not the more confusing one.\n \n fn foo(_x: Foo + Send) {\n-    //~^ERROR variable `_x` has dynamically sized type `Foo+Send`\n+    //~^ERROR the trait `core::kinds::Sized` is not implemented\n }\n \n fn main() { }"}, {"sha": "4233fa843eb611d0ca02e51b74a11f428b121a53", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-locals.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -16,12 +16,11 @@ struct Foo<T:Trait> {\n \n fn main() {\n     let foo = Foo {\n-    //~^ ERROR failed to find an implementation\n-    //~^^ ERROR instantiating a type parameter with an incompatible type\n+    //~^ ERROR not implemented\n         x: 3i\n     };\n+\n     let baz: Foo<uint> = fail!();\n-    //~^ ERROR failed to find an implementation\n-    //~^^ ERROR instantiating a type parameter with an incompatible type\n+    //~^ ERROR not implemented\n }\n "}, {"sha": "c26cccc8b146c292f3e3e9aff8483f4552255030", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-static.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-static.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -15,8 +15,7 @@ struct Foo<T:Trait> {\n }\n \n static X: Foo<uint> = Foo {\n-//~^ ERROR failed to find an implementation\n-//~^^ ERROR instantiating a type parameter with an incompatible type\n+//~^ ERROR not implemented\n     x: 1,\n };\n "}, {"sha": "d01f9d59fb43725275f03ed24ae38b64f59db9fd", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-xc.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -15,22 +15,11 @@ extern crate trait_bounds_on_structs_and_enums_xc;\n use trait_bounds_on_structs_and_enums_xc::{Bar, Foo, Trait};\n \n fn explode(x: Foo<uint>) {}\n-//~^ ERROR failed to find an implementation\n-//~^^ ERROR instantiating a type parameter with an incompatible type\n+//~^ ERROR not implemented\n \n fn kaboom(y: Bar<f32>) {}\n-//~^ ERROR failed to find an implementation\n-//~^^ ERROR instantiating a type parameter with an incompatible type\n+//~^ ERROR not implemented\n \n fn main() {\n-    let foo = Foo {\n-    //~^ ERROR failed to find an implementation\n-    //~^^ ERROR instantiating a type parameter with an incompatible type\n-        x: 3i\n-    };\n-    let bar: Bar<f64> = return;\n-    //~^ ERROR failed to find an implementation\n-    //~^^ ERROR instantiating a type parameter with an incompatible type\n-    let _ = bar;\n }\n "}, {"sha": "d3689067aef715d34a307258406bc28e825be028", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-xc1.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc1.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:trait_bounds_on_structs_and_enums_xc.rs\n+\n+extern crate trait_bounds_on_structs_and_enums_xc;\n+\n+use trait_bounds_on_structs_and_enums_xc::{Bar, Foo, Trait};\n+\n+fn main() {\n+    let foo = Foo {\n+    //~^ ERROR not implemented\n+        x: 3i\n+    };\n+    let bar: Bar<f64> = return;\n+    //~^ ERROR not implemented\n+    let _ = bar;\n+}\n+"}, {"sha": "5fe8e435e68067102f7615d47a386e3a05bd8677", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -20,40 +20,34 @@ enum Bar<T:Trait> {\n     CBar(uint),\n }\n \n-fn explode(x: Foo<uint>) {}\n-//~^ ERROR failed to find an implementation\n-//~^^ ERROR instantiating a type parameter with an incompatible type\n+fn explode(x: Foo<u32>) {}\n+//~^ ERROR not implemented\n \n fn kaboom(y: Bar<f32>) {}\n-//~^ ERROR failed to find an implementation\n-//~^^ ERROR instantiating a type parameter with an incompatible type\n+//~^ ERROR not implemented\n \n-impl<T> Foo<T> { //~ ERROR failed to find an implementation\n-//~^ ERROR instantiating a type parameter with an incompatible type\n+impl<T> Foo<T> {\n+//~^ ERROR the trait `Trait` is not implemented\n     fn uhoh() {}\n }\n \n struct Baz {\n-//~^ ERROR failed to find an implementation\n-//~^^ ERROR instantiating a type parameter with an incompatible type\n+//~^ ERROR not implemented\n     a: Foo<int>,\n }\n \n enum Boo {\n-//~^ ERROR failed to find an implementation\n-//~^^ ERROR instantiating a type parameter with an incompatible type\n+//~^ ERROR not implemented\n     Quux(Bar<uint>),\n }\n \n struct Badness<T> {\n-//~^ ERROR failed to find an implementation\n-//~^^ ERROR instantiating a type parameter with an incompatible type\n+//~^ ERROR not implemented\n     b: Foo<T>,\n }\n \n enum MoreBadness<T> {\n-//~^ ERROR failed to find an implementation\n-//~^^ ERROR instantiating a type parameter with an incompatible type\n+//~^ ERROR not implemented\n     EvenMoreBadness(Bar<T>),\n }\n \n@@ -64,15 +58,10 @@ trait PolyTrait<T> {\n struct Struct;\n \n impl PolyTrait<Foo<uint>> for Struct {\n-//~^ ERROR failed to find an implementation\n-//~^^ ERROR instantiating a type parameter with an incompatible type\n+//~^ ERROR not implemented\n     fn whatever() {}\n }\n \n fn main() {\n-    let bar: Bar<f64> = return;\n-    //~^ ERROR failed to find an implementation\n-    //~^^ ERROR instantiating a type parameter with an incompatible type\n-    let _ = bar;\n }\n "}, {"sha": "74982946d7ddd6f591e2440d55843e53cf5d7245", "filename": "src/test/compile-fail/trait-coercion-generic-bad.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -25,7 +25,6 @@ impl Trait<&'static str> for Struct {\n \n fn main() {\n     let s: Box<Trait<int>> = box Struct { person: \"Fred\" };\n-    //~^ ERROR expected Trait<int>, found Trait<&'static str>\n-    //~^^ ERROR expected Trait<int>, found Trait<&'static str>\n+    //~^ ERROR type mismatch\n     s.f(1);\n }"}, {"sha": "580aea651857b1ec966aa0724f9d2e4d4d07f25d", "filename": "src/test/compile-fail/type-params-in-different-spaces-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-2.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -15,12 +15,12 @@ trait Tr<T> {\n // these compile as if Self: Tr<U>, even tho only Self: Tr<Self or T>\n trait A:    Tr<Self> {\n     fn test<U>(u: U) -> Self {\n-        Tr::op(u)   //~ ERROR expected Tr<U>, found Tr<Self>\n+        Tr::op(u)   //~ ERROR type mismatch\n     }\n }\n trait B<T>: Tr<T> {\n     fn test<U>(u: U) -> Self {\n-        Tr::op(u)   //~ ERROR expected Tr<U>, found Tr<T>\n+        Tr::op(u)   //~ ERROR type mismatch\n     }\n }\n "}, {"sha": "7c74cdc890d8519bc3c200a70ffb305b9f26dd28", "filename": "src/test/compile-fail/typeck-unsafe-always-share.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftypeck-unsafe-always-share.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Ftypeck-unsafe-always-share.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-unsafe-always-share.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -39,5 +39,5 @@ fn main() {\n \n     let ns = NoSync{m: marker::NoSync};\n     test(ns);\n-    //~^ ERROR instantiating a type parameter with an incompatible type `NoSync`, which does not fulfill `Sync`\n+    //~^ ERROR `core::kinds::Sync` is not implemented\n }"}, {"sha": "a96bde7cca4cdcb06ce12c1140709b7b9aa22e32", "filename": "src/test/compile-fail/unboxed-closures-vtable-mismatch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -18,8 +18,7 @@ fn call_it<F:FnMut<(int,int),int>>(y: int, mut f: F) -> int {\n \n pub fn main() {\n     let f = |&mut: x: uint, y: int| -> int { (x as int) + y };\n-    let z = call_it(3, f);  //~ ERROR expected core::ops::FnMut\n-    //~^ ERROR expected core::ops::FnMut\n+    let z = call_it(3, f);  //~ ERROR type mismatch\n     println!(\"{}\", z);\n }\n "}, {"sha": "27f1da75c3aef60c6e5a61d4b3978a751164d9e3", "filename": "src/test/compile-fail/unboxed-closures-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -17,6 +17,6 @@ fn c<F:|: int, int| -> int>(f: F) -> int {\n fn main() {\n     let z: int = 7;\n     assert_eq!(c(|&: x: int, y| x + y + z), 10);\n-    //~^ ERROR failed to find an implementation\n+    //~^ ERROR not implemented\n }\n "}, {"sha": "940ca76582802a0cfc06099b5b0ad0529351b770", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -20,7 +20,6 @@ impl Drop for r {\n \n fn main() {\n     let i = box r { b: true };\n-    let _j = i.clone(); //~ ERROR failed to find an implementation\n-    //~^ ERROR failed to find an implementation\n+    let _j = i.clone(); //~ ERROR not implemented\n     println!(\"{:?}\", i);\n }"}, {"sha": "7d6cdaef85b2f35ca70deec321b5876f7a862d5e", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -16,5 +16,5 @@ fn f<T:Send>(_i: T) {\n \n fn main() {\n     let i = box box(GC) 100i;\n-    f(i); //~ ERROR does not fulfill `Send`\n+    f(i); //~ ERROR `core::kinds::Send` is not implemented\n }"}, {"sha": "54b1fdea7190d0dfd5bb773f1a729faaae622574", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -36,10 +36,8 @@ fn main() {\n     let r1 = vec!(box r { i: i1 });\n     let r2 = vec!(box r { i: i2 });\n     f(r1.clone(), r2.clone());\n-    //~^ ERROR failed to find an implementation of\n-    //~^^ ERROR failed to find an implementation of\n-    //~^^^ ERROR failed to find an implementation of\n-    //~^^^^ ERROR failed to find an implementation of\n+    //~^ ERROR the trait `core::clone::Clone` is not implemented\n+    //~^^ ERROR the trait `core::clone::Clone` is not implemented\n     println!(\"{:?}\", (r2, i1.get()));\n     println!(\"{:?}\", (r1, i2.get()));\n }"}, {"sha": "c3fea8e86d4f469536cfcbd967488010d4e6422a", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -28,6 +28,6 @@ fn foo(i:int, j: Gc<String>) -> foo {\n \n fn main() {\n   let cat = \"kitty\".to_string();\n-  let (tx, _) = channel(); //~ ERROR does not fulfill `Send`\n-  tx.send(foo(42, box(GC) (cat))); //~ ERROR does not fulfill `Send`\n+  let (tx, _) = channel(); //~ ERROR `core::kinds::Send` is not implemented\n+  tx.send(foo(42, box(GC) (cat))); //~ ERROR `core::kinds::Send` is not implemented\n }"}, {"sha": "7b5d42954117cb313ba9f28cb26791f616c48405", "filename": "src/test/compile-fail/unsized-bare-typaram.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsized-bare-typaram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsized-bare-typaram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-bare-typaram.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: instantiating a type parameter with an incompatible type\n fn bar<T: Sized>() { }\n-fn foo<Sized? T>() { bar::<T>() }\n+fn foo<Sized? T>() { bar::<T>() } //~ ERROR the trait `core::kinds::Sized` is not implemented\n fn main() { }"}, {"sha": "edef3ae6492692487879c1a27da0e0fa23059cc0", "filename": "src/test/compile-fail/unsized-enum.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsized-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsized-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-enum.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -8,7 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: instantiating a type parameter with an incompatible type\n+enum Foo<T> { FooSome(T), FooNone }\n+\n fn bar<T: Sized>() { }\n-fn foo<Sized? T>() { bar::<Option<T>>() }\n+fn foo<Sized? T>() { bar::<Foo<T>>() }\n+//~^ ERROR the trait `core::kinds::Sized` is not implemented\n+//~^^ ERROR the trait `core::kinds::Sized` is not implemented\n+//\n+// One error is for T being provided to Foo<T>, the other is\n+// for Foo<T> being provided to bar.\n+\n fn main() { }"}, {"sha": "58aba1a264648ab5cf174f162aff169f752a10f1", "filename": "src/test/compile-fail/unsized-struct.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsized-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsized-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-struct.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -8,10 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: instantiating a type parameter with an incompatible type\n-\n struct Foo<T> { data: T }\n \n fn bar<T: Sized>() { }\n fn foo<Sized? T>() { bar::<Foo<T>>() }\n+//~^ ERROR the trait `core::kinds::Sized` is not implemented\n+//~^^ ERROR the trait `core::kinds::Sized` is not implemented\n+// One error is for the T in Foo<T>, the other is for Foo<T> as a value\n+// for bar's type parameter.\n+\n fn main() { }"}, {"sha": "fba1237340fe56274b4000e26b05442d71eb13f1", "filename": "src/test/compile-fail/unsized3.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized3.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -8,20 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test sized-ness checking in substitution.\n+// Test sized-ness checking in substitution within fn bodies..\n \n \n // Unbounded.\n fn f1<Sized? X>(x: &X) {\n-    f2::<X>(x); //~ ERROR instantiating a type parameter with an incompatible type `X`, which does n\n+    f2::<X>(x);\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }\n fn f2<X>(x: &X) {\n }\n \n // Bounded.\n trait T for Sized? {}\n fn f3<Sized? X: T>(x: &X) {\n-    f4::<X>(x); //~ ERROR instantiating a type parameter with an incompatible type `X`, which does n\n+    f4::<X>(x);\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }\n fn f4<X: T>(x: &X) {\n }\n@@ -34,7 +36,8 @@ enum E<Sized? X> {\n fn f5<Y>(x: &Y) {}\n fn f6<Sized? X>(x: &X) {}\n fn f7<Sized? X>(x1: &E<X>, x2: &E<X>) {\n-    f5(x1); //~ERROR instantiating a type parameter with an incompatible type `E<X>`, which does not\n+    f5(x1);\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n     f6(x2); // ok\n }\n \n@@ -45,40 +48,18 @@ struct S<Sized? X> {\n }\n \n fn f8<Sized? X>(x1: &S<X>, x2: &S<X>) {\n-    f5(x1); //~ERROR instantiating a type parameter with an incompatible type `S<X>`, which does not\n+    f5(x1);\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n     f6(x2); // ok\n }\n \n // Test some tuples.\n fn f9<Sized? X>(x1: Box<S<X>>, x2: Box<E<X>>) {\n-    f5(&(*x1, 34i)); //~ERROR E0161\n-    //~^ ERROR instantiating a type parameter with an incompatible type\n-    f5(&(32i, *x2)); //~ERROR E0161\n-    //~^ ERROR instantiating a type parameter with an incompatible type\n+    f5(&(*x1, 34i));\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n+    f5(&(32i, *x2));\n+    //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }\n \n-// impl - bounded\n-trait T1<Z: T> {\n-}\n-struct S3<Sized? Y>;\n-impl<Sized? X: T> T1<X> for S3<X> { //~ ERROR instantiating a type parameter with an incompatible\n-}\n-\n-// impl - unbounded\n-trait T2<Z> {\n-}\n-impl<Sized? X> T2<X> for S3<X> { //~ ERROR instantiating a type parameter with an incompatible type\n-}\n-\n-// impl - struct\n-trait T3<Sized? Z> {\n-}\n-struct S4<Y>;\n-impl<Sized? X> T3<X> for S4<X> { //~ ERROR instantiating a type parameter with an incompatible type\n-}\n-impl<Sized? X> S4<X> { //~ ERROR instantiating a type parameter with an incompatible type\n-}\n-\n-\n pub fn main() {\n }"}, {"sha": "0efd178f75b8c479a831a9f6e8456d773ac26c5a", "filename": "src/test/compile-fail/unsized6.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized6.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -14,33 +14,29 @@\n trait T for Sized? {}\n \n fn f1<Sized? X>(x: &X) {\n-    let _: X; //~ERROR variable `_` has dynamically sized type `X`\n-    let _: (int, (X, int)); //~ERROR variable `_` has dynamically sized type `(int,(X,int))`\n-    let y: X; //~ERROR variable `y` has dynamically sized type `X`\n-    let y: (int, (X, int)); //~ERROR variable `y` has dynamically sized type `(int,(X,int))`\n+    let _: X; // <-- this is OK, no bindings created, no initializer.\n+    let _: (int, (X, int)); // same\n+    let y: X; //~ERROR the trait `core::kinds::Sized` is not implemented\n+    let y: (int, (X, int)); //~ERROR the trait `core::kinds::Sized` is not implemented\n }\n fn f2<Sized? X: T>(x: &X) {\n-    let _: X; //~ERROR variable `_` has dynamically sized type `X`\n-    let _: (int, (X, int)); //~ERROR variable `_` has dynamically sized type `(int,(X,int))`\n-    let y: X; //~ERROR variable `y` has dynamically sized type `X`\n-    let y: (int, (X, int)); //~ERROR variable `y` has dynamically sized type `(int,(X,int))`\n+    let y: X; //~ERROR the trait `core::kinds::Sized` is not implemented\n+    let y: (int, (X, int)); //~ERROR the trait `core::kinds::Sized` is not implemented\n }\n \n fn f3<Sized? X>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n-    let y: X = *x1; //~ERROR variable `y` has dynamically sized type `X`\n-    let y = *x2; //~ERROR variable `y` has dynamically sized type `X`\n-    let (y, z) = (*x3, 4i); //~ERROR variable `y` has dynamically sized type `X`\n-    //~^ ERROR E0161\n+    let y: X = *x1; //~ERROR the trait `core::kinds::Sized` is not implemented\n+    let y = *x2; //~ERROR the trait `core::kinds::Sized` is not implemented\n+    let (y, z) = (*x3, 4i); //~ERROR the trait `core::kinds::Sized` is not implemented\n }\n fn f4<Sized? X: T>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n-    let y: X = *x1;         //~ERROR variable `y` has dynamically sized type `X`\n-    let y = *x2;            //~ERROR variable `y` has dynamically sized type `X`\n-    let (y, z) = (*x3, 4i); //~ERROR variable `y` has dynamically sized type `X`\n-    //~^ ERROR E0161\n+    let y: X = *x1;         //~ERROR the trait `core::kinds::Sized` is not implemented\n+    let y = *x2;            //~ERROR the trait `core::kinds::Sized` is not implemented\n+    let (y, z) = (*x3, 4i); //~ERROR the trait `core::kinds::Sized` is not implemented\n }\n \n-fn g1<Sized? X>(x: X) {} //~ERROR variable `x` has dynamically sized type `X`\n-fn g2<Sized? X: T>(x: X) {} //~ERROR variable `x` has dynamically sized type `X`\n+fn g1<Sized? X>(x: X) {} //~ERROR the trait `core::kinds::Sized` is not implemented\n+fn g2<Sized? X: T>(x: X) {} //~ERROR the trait `core::kinds::Sized` is not implemented\n \n pub fn main() {\n }"}, {"sha": "fd9dffe00d2d50a28b64e22fffdb246f7707ef5c", "filename": "src/test/compile-fail/unsized7.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized7.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test sized-ness checking in substitution in impls.\n+\n+trait T for Sized? {}\n+\n+// I would like these to fail eventually.\n+// impl - bounded\n+trait T1<Z: T> {\n+}\n+struct S3<Sized? Y>;\n+impl<Sized? X: T> T1<X> for S3<X> {\n+    //~^ ERROR `core::kinds::Sized` is not implemented for the type `X`\n+}\n+\n+// impl - unbounded\n+trait T2<Z> {\n+}\n+struct S4<Sized? Y>;\n+impl<Sized? X> T2<X> for S4<X> {\n+    //~^ ERROR `core::kinds::Sized` is not implemented for the type `X`\n+}\n+\n+// impl - struct\n+trait T3<Sized? Z> {\n+}\n+struct S5<Y>;\n+impl<Sized? X> T3<X> for S5<X> { //~ ERROR not implemented\n+}\n+\n+impl<Sized? X> S5<X> { //~ ERROR not implemented\n+}\n+\n+\n+fn main() { }"}, {"sha": "bfd52d69cb217210472b6c66df1511e8877a1b6b", "filename": "src/test/compile-fail/vec-res-add.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: failed to find an implementation\n-\n struct r {\n   i:int\n }\n@@ -25,5 +23,7 @@ fn main() {\n     let i = vec!(r(0));\n     let j = vec!(r(1));\n     let k = i + j;\n+    //~^ ERROR not implemented\n     println!(\"{}\", j);\n+    //~^ ERROR not implemented\n }"}, {"sha": "12cfe9c20fa9b5e6ba7d085e33ea949bfc1720a6", "filename": "src/test/compile-fail/vtable-res-trait-param.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -24,8 +24,7 @@ impl TraitB for int {\n \n fn call_it<B:TraitB>(b: B)  -> int {\n     let y = 4u;\n-    b.gimme_an_a(y) //~ ERROR failed to find an implementation of trait TraitA\n-    //~^ ERROR failed to find an implementation of trait TraitA\n+    b.gimme_an_a(y) //~ ERROR the trait `TraitA` is not implemented\n }\n \n fn main() {"}, {"sha": "4a4a5f3193d3af085083f5444af4cf0092dca131", "filename": "src/test/compile-fail/where-clauses-unsatisfied.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -15,9 +15,6 @@ struct Struct;\n \n fn main() {\n     drop(equal(&Struct, &Struct))\n-    //~^ ERROR failed to find an implementation of trait core::cmp::Eq\n-    //~^^ ERROR failed to find an implementation of trait core::cmp::PartialEq\n-    //~^^^ ERROR failed to find an implementation of trait core::cmp::Eq\n-    //~^^^^ ERROR failed to find an implementation of trait core::cmp::PartialEq\n+    //~^ ERROR the trait `core::cmp::Eq` is not implemented\n }\n "}, {"sha": "6d7715ed9a5a039012a1428c774236ade4bed296", "filename": "src/test/run-pass/drop-struct-as-object.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Frun-pass%2Fdrop-struct-as-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Frun-pass%2Fdrop-struct-as-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-struct-as-object.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that destructor on a struct runs successfully after the struct\n+// is boxed and converted to an object.\n+\n+static mut value: uint = 0;\n+\n+struct Cat {\n+    name : uint,\n+}\n+\n+trait Dummy {\n+    fn get(&self) -> uint;\n+}\n+\n+impl Dummy for Cat {\n+    fn get(&self) -> uint { self.name }\n+}\n+\n+impl Drop for Cat {\n+    fn drop(&mut self) {\n+        unsafe { value = self.name; }\n+    }\n+}\n+\n+pub fn main() {\n+    {\n+        let x = box Cat {name: 22};\n+        let nyan: Box<Dummy> = x as Box<Dummy>;\n+    }\n+    unsafe {\n+        assert_eq!(value, 22);\n+    }\n+}"}, {"sha": "f8bc0929bfa807fc0481a5b4ffd61d2714ee687c", "filename": "src/test/run-pass/object-one-type-two-traits.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Frun-pass%2Fobject-one-type-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946654a721d6fd5eeb91e93293cdc2cba83c78b9/src%2Ftest%2Frun-pass%2Fobject-one-type-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-one-type-two-traits.rs?ref=946654a721d6fd5eeb91e93293cdc2cba83c78b9", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Testing creating two vtables with the same self type, but different\n+// traits.\n+\n+use std::any::Any;\n+use std::any::AnyRefExt;\n+\n+trait Wrap {\n+    fn get(&self) -> int;\n+    fn wrap(self: Box<Self>) -> Box<Any+'static>;\n+}\n+\n+impl Wrap for int {\n+    fn get(&self) -> int {\n+        *self\n+    }\n+    fn wrap(self: Box<int>) -> Box<Any+'static> {\n+        self as Box<Any+'static>\n+    }\n+}\n+\n+fn is<T:'static>(x: &Any) -> bool {\n+    x.is::<T>()\n+}\n+\n+fn main() {\n+    let x = box 22i as Box<Wrap>;\n+    println!(\"x={}\", x.get());\n+    let y = x.wrap();\n+}"}]}