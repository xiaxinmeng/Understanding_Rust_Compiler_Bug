{"sha": "58b6d46d5a91cc2fceccd583f22cb7c92dca89c9", "node_id": "C_kwDOAAsO6NoAKDU4YjZkNDZkNWE5MWNjMmZjZWNjZDU4M2YyMmNiN2M5MmRjYTg5Yzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-03T07:49:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-03T07:49:59Z"}, "message": "Auto merge of #12333 - nolanderc:order-import-assist, r=Veykril\n\nOrder auto-imports by relevance\n\nFixes #10337.\n\nBasically we sort the imports according to how \"far away\" the imported item is from where we want to import it to. This change makes it so that imports from the current crate are sorted before any third-party crates. Additionally, we make an exception for builtin crates (`std`, `core`, etc.) so that they are sorted before any third-party crates.\n\nThere are probably other heuristics that should be added to improve the experience (such as preferring imports that are common elsewhere in the same crate, and ranking crates depending on the dependency graph). However, I think this is a first good step.\n\nPS. This is my first time contributing here, so please be gentle if I have missed something obvious :-)", "tree": {"sha": "aa2b7e3fad73f8fb85b7f76e10899b6e0b141602", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa2b7e3fad73f8fb85b7f76e10899b6e0b141602"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58b6d46d5a91cc2fceccd583f22cb7c92dca89c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58b6d46d5a91cc2fceccd583f22cb7c92dca89c9", "html_url": "https://github.com/rust-lang/rust/commit/58b6d46d5a91cc2fceccd583f22cb7c92dca89c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58b6d46d5a91cc2fceccd583f22cb7c92dca89c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea15e1000fda6ef0bd9aed9569884da301e73db5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea15e1000fda6ef0bd9aed9569884da301e73db5", "html_url": "https://github.com/rust-lang/rust/commit/ea15e1000fda6ef0bd9aed9569884da301e73db5"}, {"sha": "8e5b318d99d3d215ab0ae84b1a80e8034975002d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e5b318d99d3d215ab0ae84b1a80e8034975002d", "html_url": "https://github.com/rust-lang/rust/commit/8e5b318d99d3d215ab0ae84b1a80e8034975002d"}], "stats": {"total": 144, "additions": 142, "deletions": 2}, "files": [{"sha": "1ec24d8fcc336c267a0afdb1723b2c65823c8b6a", "filename": "crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 142, "deletions": 2, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/58b6d46d5a91cc2fceccd583f22cb7c92dca89c9/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b6d46d5a91cc2fceccd583f22cb7c92dca89c9/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=58b6d46d5a91cc2fceccd583f22cb7c92dca89c9", "patch": "@@ -1,7 +1,10 @@\n+use std::cmp::Reverse;\n+\n+use hir::{db::HirDatabase, Module};\n use ide_db::{\n     helpers::mod_path_to_ast,\n     imports::{\n-        import_assets::{ImportAssets, ImportCandidate},\n+        import_assets::{ImportAssets, ImportCandidate, LocatedImport},\n         insert_use::{insert_use, ImportScope},\n     },\n };\n@@ -107,6 +110,19 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n     // we aren't interested in different namespaces\n     proposed_imports.dedup_by(|a, b| a.import_path == b.import_path);\n+\n+    let current_node = match ctx.covering_element() {\n+        NodeOrToken::Node(node) => Some(node),\n+        NodeOrToken::Token(token) => token.parent(),\n+    };\n+\n+    let current_module =\n+        current_node.as_ref().and_then(|node| ctx.sema.scope(node)).map(|scope| scope.module());\n+\n+    // prioritize more relevant imports\n+    proposed_imports\n+        .sort_by_key(|import| Reverse(relevance_score(ctx, import, current_module.as_ref())));\n+\n     for import in proposed_imports {\n         acc.add_group(\n             &group_label,\n@@ -158,11 +174,135 @@ fn group_label(import_candidate: &ImportCandidate) -> GroupLabel {\n     GroupLabel(name)\n }\n \n+/// Determine how relevant a given import is in the current context. Higher scores are more\n+/// relevant.\n+fn relevance_score(\n+    ctx: &AssistContext,\n+    import: &LocatedImport,\n+    current_module: Option<&Module>,\n+) -> i32 {\n+    let mut score = 0;\n+\n+    let db = ctx.db();\n+\n+    let item_module = match import.item_to_import {\n+        hir::ItemInNs::Types(item) | hir::ItemInNs::Values(item) => item.module(db),\n+        hir::ItemInNs::Macros(makro) => Some(makro.module(db)),\n+    };\n+\n+    match item_module.zip(current_module) {\n+        // get the distance between the imported path and the current module\n+        // (prefer items that are more local)\n+        Some((item_module, current_module)) => {\n+            score -= module_distance_hueristic(db, &current_module, &item_module) as i32;\n+        }\n+\n+        // could not find relevant modules, so just use the length of the path as an estimate\n+        None => return -(2 * import.import_path.len() as i32),\n+    }\n+\n+    score\n+}\n+\n+/// A heuristic that gives a higher score to modules that are more separated.\n+fn module_distance_hueristic(db: &dyn HirDatabase, current: &Module, item: &Module) -> usize {\n+    // get the path starting from the item to the respective crate roots\n+    let mut current_path = current.path_to_root(db);\n+    let mut item_path = item.path_to_root(db);\n+\n+    // we want paths going from the root to the item\n+    current_path.reverse();\n+    item_path.reverse();\n+\n+    // length of the common prefix of the two paths\n+    let prefix_length = current_path.iter().zip(&item_path).take_while(|(a, b)| a == b).count();\n+\n+    // how many modules differ between the two paths (all modules, removing any duplicates)\n+    let distinct_length = current_path.len() + item_path.len() - 2 * prefix_length;\n+\n+    // cost of importing from another crate\n+    let crate_boundary_cost = if current.krate() == item.krate() {\n+        0\n+    } else if item.krate().is_builtin(db) {\n+        2\n+    } else {\n+        4\n+    };\n+\n+    distinct_length + crate_boundary_cost\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n \n-    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use hir::Semantics;\n+    use ide_db::{\n+        assists::AssistResolveStrategy,\n+        base_db::{fixture::WithFixture, FileRange},\n+        RootDatabase,\n+    };\n+\n+    use crate::tests::{\n+        check_assist, check_assist_not_applicable, check_assist_target, TEST_CONFIG,\n+    };\n+\n+    fn check_auto_import_order(before: &str, order: &[&str]) {\n+        let (db, file_id, range_or_offset) = RootDatabase::with_range_or_offset(before);\n+        let frange = FileRange { file_id, range: range_or_offset.into() };\n+\n+        let sema = Semantics::new(&db);\n+        let config = TEST_CONFIG;\n+        let ctx = AssistContext::new(sema, &config, frange);\n+        let mut acc = Assists::new(&ctx, AssistResolveStrategy::All);\n+        auto_import(&mut acc, &ctx);\n+        let assists = acc.finish();\n+\n+        let labels = assists.iter().map(|assist| assist.label.to_string()).collect::<Vec<_>>();\n+\n+        assert_eq!(labels, order);\n+    }\n+\n+    #[test]\n+    fn prefer_shorter_paths() {\n+        let before = r\"\n+//- /main.rs crate:main deps:foo,bar\n+HashMap$0::new();\n+\n+//- /lib.rs crate:foo\n+pub mod collections { pub struct HashMap; }\n+\n+//- /lib.rs crate:bar\n+pub mod collections { pub mod hash_map { pub struct HashMap; } }\n+        \";\n+\n+        check_auto_import_order(\n+            before,\n+            &[\"Import `foo::collections::HashMap`\", \"Import `bar::collections::hash_map::HashMap`\"],\n+        )\n+    }\n+\n+    #[test]\n+    fn prefer_same_crate() {\n+        let before = r\"\n+//- /main.rs crate:main deps:foo\n+HashMap$0::new();\n+\n+mod collections {\n+    pub mod hash_map {\n+        pub struct HashMap;\n+    }\n+}\n+\n+//- /lib.rs crate:foo\n+pub struct HashMap;\n+        \";\n+\n+        check_auto_import_order(\n+            before,\n+            &[\"Import `collections::hash_map::HashMap`\", \"Import `foo::HashMap`\"],\n+        )\n+    }\n \n     #[test]\n     fn not_applicable_if_scope_inside_macro() {"}]}