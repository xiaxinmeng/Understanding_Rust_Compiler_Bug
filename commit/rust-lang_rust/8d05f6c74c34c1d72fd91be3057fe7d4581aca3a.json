{"sha": "8d05f6c74c34c1d72fd91be3057fe7d4581aca3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMDVmNmM3NGMzNGMxZDcyZmQ5MWJlMzA1N2ZlN2Q0NTgxYWNhM2E=", "commit": {"author": {"name": "Barosl LEE", "email": "github@barosl.com", "date": "2015-01-20T17:16:51Z"}, "committer": {"name": "Barosl LEE", "email": "github@barosl.com", "date": "2015-01-20T17:16:51Z"}, "message": "Rollup merge of #21388 - aochagavia:collections, r=Gankro\n\n**Breaking change**: `VecMap::into_iter` now consumes the `VecMap`. To fix it you should pass the VecMap by value instead of by reference.\r\n\r\n[breaking-change]\r\n\r\nr? @Gankro", "tree": {"sha": "4167dffdf61a44b0622eeac989aeeba0e9cdc435", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4167dffdf61a44b0622eeac989aeeba0e9cdc435"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d05f6c74c34c1d72fd91be3057fe7d4581aca3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d05f6c74c34c1d72fd91be3057fe7d4581aca3a", "html_url": "https://github.com/rust-lang/rust/commit/8d05f6c74c34c1d72fd91be3057fe7d4581aca3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d05f6c74c34c1d72fd91be3057fe7d4581aca3a/comments", "author": {"login": "barosl", "id": 573768, "node_id": "MDQ6VXNlcjU3Mzc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/573768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/barosl", "html_url": "https://github.com/barosl", "followers_url": "https://api.github.com/users/barosl/followers", "following_url": "https://api.github.com/users/barosl/following{/other_user}", "gists_url": "https://api.github.com/users/barosl/gists{/gist_id}", "starred_url": "https://api.github.com/users/barosl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/barosl/subscriptions", "organizations_url": "https://api.github.com/users/barosl/orgs", "repos_url": "https://api.github.com/users/barosl/repos", "events_url": "https://api.github.com/users/barosl/events{/privacy}", "received_events_url": "https://api.github.com/users/barosl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "barosl", "id": 573768, "node_id": "MDQ6VXNlcjU3Mzc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/573768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/barosl", "html_url": "https://github.com/barosl", "followers_url": "https://api.github.com/users/barosl/followers", "following_url": "https://api.github.com/users/barosl/following{/other_user}", "gists_url": "https://api.github.com/users/barosl/gists{/gist_id}", "starred_url": "https://api.github.com/users/barosl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/barosl/subscriptions", "organizations_url": "https://api.github.com/users/barosl/orgs", "repos_url": "https://api.github.com/users/barosl/repos", "events_url": "https://api.github.com/users/barosl/events{/privacy}", "received_events_url": "https://api.github.com/users/barosl/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d6568fcb2ceac47104c0f7017d39328e5d871b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6568fcb2ceac47104c0f7017d39328e5d871b1", "html_url": "https://github.com/rust-lang/rust/commit/3d6568fcb2ceac47104c0f7017d39328e5d871b1"}, {"sha": "b4090aa730640bc0dbd06a8ec5cf32b842c166e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4090aa730640bc0dbd06a8ec5cf32b842c166e2", "html_url": "https://github.com/rust-lang/rust/commit/b4090aa730640bc0dbd06a8ec5cf32b842c166e2"}], "stats": {"total": 82, "additions": 71, "deletions": 11}, "files": [{"sha": "7ff2e9535886c67e43cdc10405503923a905a58a", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 71, "deletions": 11, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8d05f6c74c34c1d72fd91be3057fe7d4581aca3a/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d05f6c74c34c1d72fd91be3057fe7d4581aca3a/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=8d05f6c74c34c1d72fd91be3057fe7d4581aca3a", "patch": "@@ -186,7 +186,7 @@ impl<V> VecMap<V> {\n         }\n     }\n \n-    /// Returns an iterator visiting all keys in ascending order by the keys.\n+    /// Returns an iterator visiting all keys in ascending order of the keys.\n     /// The iterator's element type is `uint`.\n     #[stable]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n@@ -196,7 +196,7 @@ impl<V> VecMap<V> {\n         Keys { iter: self.iter().map(first) }\n     }\n \n-    /// Returns an iterator visiting all values in ascending order by the keys.\n+    /// Returns an iterator visiting all values in ascending order of the keys.\n     /// The iterator's element type is `&'r V`.\n     #[stable]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n@@ -206,7 +206,7 @@ impl<V> VecMap<V> {\n         Values { iter: self.iter().map(second) }\n     }\n \n-    /// Returns an iterator visiting all key-value pairs in ascending order by the keys.\n+    /// Returns an iterator visiting all key-value pairs in ascending order of the keys.\n     /// The iterator's element type is `(uint, &'r V)`.\n     ///\n     /// # Examples\n@@ -233,7 +233,7 @@ impl<V> VecMap<V> {\n         }\n     }\n \n-    /// Returns an iterator visiting all key-value pairs in ascending order by the keys,\n+    /// Returns an iterator visiting all key-value pairs in ascending order of the keys,\n     /// with mutable references to the values.\n     /// The iterator's element type is `(uint, &'r mut V)`.\n     ///\n@@ -264,8 +264,8 @@ impl<V> VecMap<V> {\n         }\n     }\n \n-    /// Returns an iterator visiting all key-value pairs in ascending order by\n-    /// the keys, emptying (but not consuming) the original `VecMap`.\n+    /// Returns an iterator visiting all key-value pairs in ascending order of\n+    /// the keys, consuming the original `VecMap`.\n     /// The iterator's element type is `(uint, &'r V)`.\n     ///\n     /// # Examples\n@@ -278,20 +278,46 @@ impl<V> VecMap<V> {\n     /// map.insert(3, \"c\");\n     /// map.insert(2, \"b\");\n     ///\n-    /// // Not possible with .iter()\n     /// let vec: Vec<(uint, &str)> = map.into_iter().collect();\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[stable]\n-    pub fn into_iter(&mut self) -> IntoIter<V> {\n+    pub fn into_iter(self) -> IntoIter<V> {\n+        fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n+            v.map(|v| (i, v))\n+        }\n+        let filter: fn((uint, Option<V>)) -> Option<(uint, V)> = filter; // coerce to fn ptr\n+\n+        IntoIter { iter: self.v.into_iter().enumerate().filter_map(filter) }\n+    }\n+\n+    /// Returns an iterator visiting all key-value pairs in ascending order of\n+    /// the keys, emptying (but not consuming) the original `VecMap`.\n+    /// The iterator's element type is `(uint, &'r V)`. Keeps the allocated memory for reuse.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecMap;\n+    ///\n+    /// let mut map = VecMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(3, \"c\");\n+    /// map.insert(2, \"b\");\n+    ///\n+    /// let vec: Vec<(uint, &str)> = map.drain().collect();\n+    ///\n+    /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain<'a>(&'a mut self) -> Drain<'a, V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n         }\n         let filter: fn((uint, Option<V>)) -> Option<(uint, V)> = filter; // coerce to fn ptr\n \n-        let values = replace(&mut self.v, vec!());\n-        IntoIter { iter: values.into_iter().enumerate().filter_map(filter) }\n+        Drain { iter: self.v.drain().enumerate().filter_map(filter) }\n     }\n \n     /// Return the number of elements in the map.\n@@ -673,6 +699,28 @@ pub struct IntoIter<V> {\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n+#[unstable]\n+pub struct Drain<'a, V> {\n+    iter: FilterMap<\n+    (uint, Option<V>),\n+    (uint, V),\n+    Enumerate<vec::Drain<'a, Option<V>>>,\n+    fn((uint, Option<V>)) -> Option<(uint, V)>>\n+}\n+\n+#[unstable]\n+impl<'a, V> Iterator for Drain<'a, V> {\n+    type Item = (uint, V);\n+\n+    fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+#[unstable]\n+impl<'a, V> DoubleEndedIterator for Drain<'a, V> {\n+    fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n+}\n+\n #[stable]\n impl<'a, V> Iterator for Keys<'a, V> {\n     type Item = uint;\n@@ -918,7 +966,19 @@ mod test_map {\n             assert_eq!(v, box 2i);\n         }\n         assert!(called);\n-        m.insert(2, box 1i);\n+    }\n+\n+    #[test]\n+    fn test_drain_iterator() {\n+        let mut map = VecMap::new();\n+        map.insert(1, \"a\");\n+        map.insert(3, \"c\");\n+        map.insert(2, \"b\");\n+\n+        let vec: Vec<(usize, &str)> = map.drain().collect();\n+\n+        assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+        assert_eq!(map.len(), 0);\n     }\n \n     #[test]"}]}