{"sha": "2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2", "node_id": "C_kwDOAAsO6NoAKDJhYTRhYTcwZGRkMTFlYmM1NjY2N2RiYjM5MDdjOTNhNWEwMTc2YzI", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-08-16T19:48:04Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-08-16T19:48:04Z"}, "message": "rustdoc: factor Type::QPath out into its own box\n\nThis reduces the size of Type.", "tree": {"sha": "aed8324936a1f72c5286fe25e883f52eaca33025", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aed8324936a1f72c5286fe25e883f52eaca33025"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2", "html_url": "https://github.com/rust-lang/rust/commit/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a39bdb1d6b9eaf23f2636baee0949d67890abcd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a39bdb1d6b9eaf23f2636baee0949d67890abcd8", "html_url": "https://github.com/rust-lang/rust/commit/a39bdb1d6b9eaf23f2636baee0949d67890abcd8"}], "stats": {"total": 87, "additions": 47, "deletions": 40}, "files": [{"sha": "5441a7bd29ec00624512afd0681506dedc4a8e74", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2", "patch": "@@ -551,13 +551,15 @@ where\n                 }\n                 WherePredicate::EqPredicate { lhs, rhs } => {\n                     match lhs {\n-                        Type::QPath { ref assoc, ref self_type, ref trait_, .. } => {\n+                        Type::QPath(box QPathData {\n+                            ref assoc, ref self_type, ref trait_, ..\n+                        }) => {\n                             let ty = &*self_type;\n                             let mut new_trait = trait_.clone();\n \n                             if self.is_fn_trait(trait_) && assoc.name == sym::Output {\n                                 ty_to_fn\n-                                    .entry(*ty.clone())\n+                                    .entry(ty.clone())\n                                     .and_modify(|e| {\n                                         *e = (e.0.clone(), Some(rhs.ty().unwrap().clone()))\n                                     })\n@@ -582,7 +584,7 @@ where\n                                 // to 'T: Iterator<Item=u8>'\n                                 GenericArgs::AngleBracketed { ref mut bindings, .. } => {\n                                     bindings.push(TypeBinding {\n-                                        assoc: *assoc.clone(),\n+                                        assoc: assoc.clone(),\n                                         kind: TypeBindingKind::Equality { term: rhs },\n                                     });\n                                 }\n@@ -596,7 +598,7 @@ where\n                                 }\n                             }\n \n-                            let bounds = ty_to_bounds.entry(*ty.clone()).or_default();\n+                            let bounds = ty_to_bounds.entry(ty.clone()).or_default();\n \n                             bounds.insert(GenericBound::TraitBound(\n                                 PolyTrait { trait_: new_trait, generic_params: Vec::new() },\n@@ -613,7 +615,7 @@ where\n                             ));\n                             // Avoid creating any new duplicate bounds later in the outer\n                             // loop\n-                            ty_to_traits.entry(*ty.clone()).or_default().insert(trait_.clone());\n+                            ty_to_traits.entry(ty.clone()).or_default().insert(trait_.clone());\n                         }\n                         _ => panic!(\"Unexpected LHS {:?} for {:?}\", lhs, item_def_id),\n                     }"}, {"sha": "bd5dfa4947b4b6c93069c2b46104a7dc8b84ea5e", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2", "patch": "@@ -672,7 +672,7 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n \n     g.where_predicates.retain(|pred| match pred {\n         clean::WherePredicate::BoundPredicate {\n-            ty: clean::QPath { self_type: box clean::Generic(ref s), trait_, .. },\n+            ty: clean::QPath(box clean::QPathData { self_type: clean::Generic(ref s), trait_, .. }),\n             bounds,\n             ..\n         } => !(bounds.is_empty() || *s == kw::SelfUpper && trait_.def_id() == trait_did),"}, {"sha": "5e34134597fa900ad462f82131684c17a06cbe4f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2", "patch": "@@ -410,12 +410,12 @@ fn clean_projection<'tcx>(\n         self_type.def_id(&cx.cache)\n     };\n     let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n-    Type::QPath {\n-        assoc: Box::new(projection_to_path_segment(ty, cx)),\n+    Type::QPath(Box::new(QPathData {\n+        assoc: projection_to_path_segment(ty, cx),\n         should_show_cast,\n-        self_type: Box::new(self_type),\n+        self_type,\n         trait_,\n-    }\n+    }))\n }\n \n fn compute_should_show_cast(self_def_id: Option<DefId>, trait_: &Path, self_type: &Type) -> bool {\n@@ -1182,7 +1182,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                     .where_predicates\n                     .drain_filter(|pred| match *pred {\n                         WherePredicate::BoundPredicate {\n-                            ty: QPath { ref assoc, ref self_type, ref trait_, .. },\n+                            ty: QPath(box QPathData { ref assoc, ref self_type, ref trait_, .. }),\n                             ..\n                         } => {\n                             if assoc.name != my_name {\n@@ -1191,7 +1191,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                             if trait_.def_id() != assoc_item.container_id(tcx) {\n                                 return false;\n                             }\n-                            match **self_type {\n+                            match *self_type {\n                                 Generic(ref s) if *s == kw::SelfUpper => {}\n                                 _ => return false,\n                             }\n@@ -1324,15 +1324,12 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             let self_def_id = DefId::local(qself.hir_id.owner.local_def_index);\n             let self_type = clean_ty(qself, cx);\n             let should_show_cast = compute_should_show_cast(Some(self_def_id), &trait_, &self_type);\n-            Type::QPath {\n-                assoc: Box::new(clean_path_segment(\n-                    p.segments.last().expect(\"segments were empty\"),\n-                    cx,\n-                )),\n+            Type::QPath(Box::new(QPathData {\n+                assoc: clean_path_segment(p.segments.last().expect(\"segments were empty\"), cx),\n                 should_show_cast,\n-                self_type: Box::new(self_type),\n+                self_type,\n                 trait_,\n-            }\n+            }))\n         }\n         hir::QPath::TypeRelative(qself, segment) => {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n@@ -1347,12 +1344,12 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             let self_def_id = res.opt_def_id();\n             let self_type = clean_ty(qself, cx);\n             let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n-            Type::QPath {\n-                assoc: Box::new(clean_path_segment(segment, cx)),\n+            Type::QPath(Box::new(QPathData {\n+                assoc: clean_path_segment(segment, cx),\n                 should_show_cast,\n-                self_type: Box::new(self_type),\n+                self_type,\n                 trait_,\n-            }\n+            }))\n         }\n         hir::QPath::LangItem(..) => bug!(\"clean: requiring documentation of lang item\"),\n     }"}, {"sha": "7bbd2b19f2e0d89ab06c9828d630984c677562a2", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2", "patch": "@@ -1556,13 +1556,7 @@ pub(crate) enum Type {\n     BorrowedRef { lifetime: Option<Lifetime>, mutability: Mutability, type_: Box<Type> },\n \n     /// A qualified path to an associated item: `<Type as Trait>::Name`\n-    QPath {\n-        assoc: Box<PathSegment>,\n-        self_type: Box<Type>,\n-        /// FIXME: compute this field on demand.\n-        should_show_cast: bool,\n-        trait_: Path,\n-    },\n+    QPath(Box<QPathData>),\n \n     /// A type that is inferred: `_`\n     Infer,\n@@ -1660,8 +1654,8 @@ impl Type {\n     }\n \n     pub(crate) fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n-        if let QPath { self_type, trait_, assoc, .. } = self {\n-            Some((self_type, trait_.def_id(), *assoc.clone()))\n+        if let QPath(box QPathData { self_type, trait_, assoc, .. }) = self {\n+            Some((self_type, trait_.def_id(), assoc.clone()))\n         } else {\n             None\n         }\n@@ -1685,7 +1679,7 @@ impl Type {\n             Slice(..) => PrimitiveType::Slice,\n             Array(..) => PrimitiveType::Array,\n             RawPointer(..) => PrimitiveType::RawPointer,\n-            QPath { ref self_type, .. } => return self_type.inner_def_id(cache),\n+            QPath(box QPathData { ref self_type, .. }) => return self_type.inner_def_id(cache),\n             Generic(_) | Infer | ImplTrait(_) => return None,\n         };\n         cache.and_then(|c| Primitive(t).def_id(c))\n@@ -1699,6 +1693,15 @@ impl Type {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub(crate) struct QPathData {\n+    pub assoc: PathSegment,\n+    pub self_type: Type,\n+    /// FIXME: compute this field on demand.\n+    pub should_show_cast: bool,\n+    pub trait_: Path,\n+}\n+\n /// A primitive (aka, builtin) type.\n ///\n /// This represents things like `i32`, `str`, etc.\n@@ -2490,11 +2493,11 @@ mod size_asserts {\n     // These are in alphabetical order, which is easy to maintain.\n     static_assert_size!(Crate, 72); // frequently moved by-value\n     static_assert_size!(DocFragment, 32);\n-    static_assert_size!(GenericArg, 80);\n+    static_assert_size!(GenericArg, 64);\n     static_assert_size!(GenericArgs, 32);\n     static_assert_size!(GenericParamDef, 56);\n     static_assert_size!(Item, 56);\n     static_assert_size!(ItemKind, 112);\n     static_assert_size!(PathSegment, 40);\n-    static_assert_size!(Type, 72);\n+    static_assert_size!(Type, 56);\n }"}, {"sha": "b023792e95a58e4292478c2db0eab95a010eec27", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2", "patch": "@@ -1079,7 +1079,12 @@ fn fmt_type<'cx>(\n                 write!(f, \"impl {}\", print_generic_bounds(bounds, cx))\n             }\n         }\n-        clean::QPath { ref assoc, ref self_type, ref trait_, should_show_cast } => {\n+        clean::QPath(box clean::QPathData {\n+            ref assoc,\n+            ref self_type,\n+            ref trait_,\n+            should_show_cast,\n+        }) => {\n             if f.alternate() {\n                 if should_show_cast {\n                     write!(f, \"<{:#} as {:#}>::\", self_type.print(cx), trait_.print(cx))?"}, {"sha": "1ac5186f9f6a83996f38a6aafc3cf3a3ead49863", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2", "patch": "@@ -2623,8 +2623,8 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n             clean::Type::BorrowedRef { type_, .. } => {\n                 work.push_back(*type_);\n             }\n-            clean::Type::QPath { self_type, trait_, .. } => {\n-                work.push_back(*self_type);\n+            clean::Type::QPath(box clean::QPathData { self_type, trait_, .. }) => {\n+                work.push_back(self_type);\n                 process_path(trait_.def_id());\n             }\n             _ => {}"}, {"sha": "6221591ca25e084633f8ea18c419e970a3fe1aba", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=2aa4aa70ddd11ebc56667dbb3907c93a5a0176c2", "patch": "@@ -480,10 +480,10 @@ impl FromWithTcx<clean::Type> for Type {\n                 mutable: mutability == ast::Mutability::Mut,\n                 type_: Box::new((*type_).into_tcx(tcx)),\n             },\n-            QPath { assoc, self_type, trait_, .. } => Type::QualifiedPath {\n+            QPath(box clean::QPathData { assoc, self_type, trait_, .. }) => Type::QualifiedPath {\n                 name: assoc.name.to_string(),\n                 args: Box::new(assoc.args.clone().into_tcx(tcx)),\n-                self_type: Box::new((*self_type).into_tcx(tcx)),\n+                self_type: Box::new(self_type.into_tcx(tcx)),\n                 trait_: trait_.into_tcx(tcx),\n             },\n         }"}]}