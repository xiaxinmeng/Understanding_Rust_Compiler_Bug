{"sha": "50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwOTMyYjVmNGUzYTVmMWI2Yzk1NTEwMGRhNWIzMGQ3N2JjZDI5ZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-30T18:08:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-30T18:08:58Z"}, "message": "Auto merge of #36864 - steveklabnik:rollup, r=steveklabnik\n\nRollup of 13 pull requests\n\n- Successful merges: #36529, #36535, #36576, #36623, #36711, #36750, #36810, #36829, #36833, #36841, #36842, #36851, #36860\n- Failed merges:", "tree": {"sha": "dbce305f5d8ea4c390a3aa27831a7756e6b22981", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbce305f5d8ea4c390a3aa27831a7756e6b22981"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "html_url": "https://github.com/rust-lang/rust/commit/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "954873055a998a06841ac19b39b1fe18a6641731", "url": "https://api.github.com/repos/rust-lang/rust/commits/954873055a998a06841ac19b39b1fe18a6641731", "html_url": "https://github.com/rust-lang/rust/commit/954873055a998a06841ac19b39b1fe18a6641731"}, {"sha": "af1df9880f603320bde62c8786f2208d659ce8ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/af1df9880f603320bde62c8786f2208d659ce8ae", "html_url": "https://github.com/rust-lang/rust/commit/af1df9880f603320bde62c8786f2208d659ce8ae"}], "stats": {"total": 195, "additions": 116, "deletions": 79}, "files": [{"sha": "e6f18f9f7ba557726f9078ac320e0577a92318ae", "filename": "RELEASES.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -54,7 +54,7 @@ Diagnostics\n   Most common editors supporting Rust have been updated to work with it. It was\n   previously described [on the Rust blog]\n   (https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html).\n-* [In error descriptions, references are now described in plain english,\n+* [In error descriptions, references are now described in plain English,\n   instead of as \"&-ptr\"]\n   (https://github.com/rust-lang/rust/pull/35611)\n * [In error type descriptions, unknown numeric types are named `{integer}` or\n@@ -148,7 +148,7 @@ Libraries\n   (https://github.com/rust-lang/rust/pull/34946)\n * [`hash_map::Entry`, `hash_map::VacantEntry` and `hash_map::OccupiedEntry`\n   implement `Debug`]\n-  (https://github.com/rust-lang/rust/pull/34946)\n+  (https://github.com/rust-lang/rust/pull/34937)\n * [`btree_map::Entry`, `btree_map::VacantEntry` and `btree_map::OccupiedEntry`\n   implement `Debug`]\n   (https://github.com/rust-lang/rust/pull/34885)\n@@ -885,7 +885,7 @@ Cargo\n Performance\n -----------\n \n-* [The time complexity of comparing variables for equivalence during type \n+* [The time complexity of comparing variables for equivalence during type\n   unification is reduced from _O_(_n_!) to _O_(_n_)][1.9tu]. This leads\n   to major compilation time improvement in some scenarios.\n * [`ToString` is specialized for `str`, giving it the same performance"}, {"sha": "d845ad6feb0013deb3856982f1e11a5c1d894201", "filename": "src/doc/book/references-and-borrowing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -86,7 +86,7 @@ fn main() {\n         return v.iter().fold(0, |a, &b| a + b);\n     }\n     // Borrow two vectors and sum them.\n-    // This kind of borrowing does not allow mutation to the borrowed.\n+    // This kind of borrowing does not allow mutation through the borrowed reference.\n     fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n         // do stuff with v1 and v2\n         let s1 = sum_vec(v1);"}, {"sha": "20970ab7a351254322cedef0f6efb4198e95dc75", "filename": "src/doc/reference.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -3959,6 +3959,16 @@ the top-level type for the implementation of the called method. If no such metho\n found, `.deref()` is called and the compiler continues to search for the method\n implementation in the returned type `U`.\n \n+## The `Send` trait\n+\n+The `Send` trait indicates that a value of this type is safe to send from one \n+thread to another.\n+\n+## The 'Sync' trait\n+\n+The 'Sync' trait indicates that a value of this type is safe to share between\n+multiple threads.\n+\n # Memory model\n \n A Rust program's memory consists of a static set of *items* and a *heap*."}, {"sha": "28f4dda1408830264612d571a35d7f651868f988", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -244,12 +244,14 @@ impl<T: ?Sized> Box<T> {\n     /// the destructor of `T` and free the allocated memory. Since the\n     /// way `Box` allocates and releases memory is unspecified, the\n     /// only valid pointer to pass to this function is the one taken\n-    /// from another `Box` via the `Box::into_raw` function.\n+    /// from another `Box` via the [`Box::into_raw`] function.\n     ///\n     /// This function is unsafe because improper use may lead to\n     /// memory problems. For example, a double-free may occur if the\n     /// function is called twice on the same raw pointer.\n     ///\n+    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -269,12 +271,14 @@ impl<T: ?Sized> Box<T> {\n     /// memory previously managed by the `Box`. In particular, the\n     /// caller should properly destroy `T` and release the memory. The\n     /// proper way to do so is to convert the raw pointer back into a\n-    /// `Box` with the `Box::from_raw` function.\n+    /// `Box` with the [`Box::from_raw`] function.\n     ///\n     /// Note: this is an associated function, which means that you have\n     /// to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n+    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "6b705ca039fd881b4f1d261c764f0b78c9eb1b60", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -168,7 +168,7 @@ impl<T> [T] {\n         core_slice::SliceExt::len(self)\n     }\n \n-    /// Returns true if the slice has a length of 0\n+    /// Returns true if the slice has a length of 0.\n     ///\n     /// # Example\n     ///\n@@ -402,7 +402,7 @@ impl<T> [T] {\n         core_slice::SliceExt::get_unchecked_mut(self, index)\n     }\n \n-    /// Returns an raw pointer to the slice's buffer\n+    /// Returns an raw pointer to the slice's buffer.\n     ///\n     /// The caller must ensure that the slice outlives the pointer this\n     /// function returns, or else it will end up pointing to garbage.\n@@ -468,7 +468,7 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n     /// v.swap(1, 3);\n     /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n@@ -483,7 +483,7 @@ impl<T> [T] {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [1, 2, 3];\n     /// v.reverse();\n     /// assert!(v == [3, 2, 1]);\n@@ -567,9 +567,9 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over `size` elements of the slice at a\n-    /// time. The chunks are slices and do not overlap. If `size` does not divide the\n-    /// length of the slice, then the last chunk will not have length\n-    /// `size`.\n+    /// time. The chunks are slices and do not overlap. If `size` does\n+    /// not divide the length of the slice, then the last chunk will\n+    /// not have length `size`.\n     ///\n     /// # Panics\n     ///\n@@ -656,7 +656,7 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [1, 2, 3, 4, 5, 6];\n     ///\n     /// // scoped to restrict the lifetime of the borrows\n@@ -754,7 +754,7 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to returning at most `n` items.  The matched element is\n+    /// `pred`, limited to returning at most `n` items. The matched element is\n     /// not contained in the subslices.\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n@@ -781,7 +781,7 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to returning at most `n` items.  The matched element is\n+    /// `pred`, limited to returning at most `n` items. The matched element is\n     /// not contained in the subslices.\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n@@ -835,7 +835,7 @@ impl<T> [T] {\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to returning at most `n` items. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n+    /// the slice and works backwards. The matched element is not contained in\n     /// the subslices.\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n@@ -922,9 +922,9 @@ impl<T> [T] {\n     ///\n     /// Looks up a series of four elements. The first is found, with a\n     /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n+    /// found; the fourth could match any position in `[1, 4]`.\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     ///\n     /// assert_eq!(s.binary_search(&13),  Ok(9));\n@@ -956,9 +956,9 @@ impl<T> [T] {\n     ///\n     /// Looks up a series of four elements. The first is found, with a\n     /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n+    /// found; the fourth could match any position in `[1, 4]`.\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     ///\n     /// let seek = 13;\n@@ -982,21 +982,23 @@ impl<T> [T] {\n     /// Binary search a sorted slice with a key extraction function.\n     ///\n     /// Assumes that the slice is sorted by the key, for instance with\n-    /// `sort_by_key` using the same key extraction function.\n+    /// [`sort_by_key`] using the same key extraction function.\n     ///\n     /// If a matching value is found then returns `Ok`, containing the\n     /// index for the matched element; if no match is found then `Err`\n     /// is returned, containing the index where a matching element could\n     /// be inserted while maintaining sorted order.\n     ///\n+    /// [`sort_by_key`]: #method.sort_by_key\n+    ///\n     /// # Examples\n     ///\n     /// Looks up a series of four elements in a slice of pairs sorted by\n     /// their second elements. The first is found, with a uniquely\n     /// determined position; the second and third are not found; the\n-    /// fourth could match any position in `[1,4]`.\n+    /// fourth could match any position in `[1, 4]`.\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n     ///          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n     ///          (1, 21), (2, 34), (4, 55)];\n@@ -1023,7 +1025,7 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [-5, 4, 1, -3, 2];\n     ///\n     /// v.sort();\n@@ -1045,7 +1047,7 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [-5i32, 4, 1, -3, 2];\n     ///\n     /// v.sort_by_key(|k| k.abs());\n@@ -1067,7 +1069,7 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [5, 4, 1, 3, 2];\n     /// v.sort_by(|a, b| a.cmp(b));\n     /// assert!(v == [1, 2, 3, 4, 5]);\n@@ -1094,7 +1096,7 @@ impl<T> [T] {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut dst = [0, 0, 0];\n     /// let src = [1, 2, 3];\n     ///\n@@ -1116,7 +1118,7 @@ impl<T> [T] {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut dst = [0, 0, 0];\n     /// let src = [1, 2, 3];\n     ///"}, {"sha": "96efe1a03e351095898bbead31653ec78ae5f13f", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -697,7 +697,7 @@ impl str {\n     ///\n     /// Basic usage:\n     ///\n-    /// ```rust\n+    /// ```\n     /// let bananas = \"bananas\";\n     ///\n     /// assert!(bananas.ends_with(\"anas\"));\n@@ -900,7 +900,7 @@ impl str {\n     ///\n     /// It does _not_ give you:\n     ///\n-    /// ```rust,ignore\n+    /// ```,ignore\n     /// assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n     /// ```\n     ///"}, {"sha": "119828ea43c61c31ce419b1c173ae0fd795f542b", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -21,7 +21,7 @@\n //!\n //! There are multiple ways to create a new `String` from a string literal:\n //!\n-//! ```rust\n+//! ```\n //! let s = \"Hello\".to_string();\n //!\n //! let s = String::from(\"world\");\n@@ -31,7 +31,7 @@\n //! You can create a new `String` from an existing one by concatenating with\n //! `+`:\n //!\n-//! ```rust\n+//! ```\n //! let s = \"Hello\".to_string();\n //!\n //! let message = s + \" world!\";\n@@ -40,7 +40,7 @@\n //! If you have a vector of valid UTF-8 bytes, you can make a `String` out of\n //! it. You can do the reverse too.\n //!\n-//! ```rust\n+//! ```\n //! let sparkle_heart = vec![240, 159, 146, 150];\n //!\n //! // We know these bytes are valid, so we'll use `unwrap()`."}, {"sha": "ed6eb62c9677ebdc5bafd47aba8dc359724f2728", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -1769,7 +1769,7 @@ impl<T> IntoIter<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// # #![feature(vec_into_iter_as_slice)]\n     /// let vec = vec!['a', 'b', 'c'];\n     /// let mut into_iter = vec.into_iter();\n@@ -1788,7 +1788,7 @@ impl<T> IntoIter<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// # #![feature(vec_into_iter_as_slice)]\n     /// let vec = vec!['a', 'b', 'c'];\n     /// let mut into_iter = vec.into_iter();"}, {"sha": "036633fe89dc67d514c7e27dd84fbe68610149c0", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -10,10 +10,13 @@\n \n //! Functionality for ordering and comparison.\n //!\n-//! This module defines both `PartialOrd` and `PartialEq` traits which are used\n+//! This module defines both [`PartialOrd`] and [`PartialEq`] traits which are used\n //! by the compiler to implement comparison operators. Rust programs may\n-//! implement `PartialOrd` to overload the `<`, `<=`, `>`, and `>=` operators,\n-//! and may implement `PartialEq` to overload the `==` and `!=` operators.\n+//! implement [`PartialOrd`] to overload the `<`, `<=`, `>`, and `>=` operators,\n+//! and may implement [`PartialEq`] to overload the `==` and `!=` operators.\n+//!\n+//! [`PartialOrd`]: trait.PartialOrd.html\n+//! [`PartialEq`]: trait.PartialEq.html\n //!\n //! # Examples\n //!"}, {"sha": "a9f53d3abb8b913bc6a68fb522654c0ca4022dd6", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -794,7 +794,7 @@ pub trait UpperExp {\n /// assert_eq!(output, \"Hello world!\");\n /// ```\n ///\n-/// Please note that using [`write!`][write_macro] might be preferrable. Example:\n+/// Please note that using [`write!`] might be preferrable. Example:\n ///\n /// ```\n /// use std::fmt::Write;\n@@ -805,7 +805,7 @@ pub trait UpperExp {\n /// assert_eq!(output, \"Hello world!\");\n /// ```\n ///\n-/// [write_macro]: ../../std/macro.write!.html\n+/// [`write!`]: ../../std/macro.write.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn write(output: &mut Write, args: Arguments) -> Result {\n     let mut formatter = Formatter {"}, {"sha": "72e951a7c347c1f2c73f76c06d78e880c84472c2", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -14,7 +14,7 @@\n //!\n //! Some of these traits are imported by the prelude, so they are available in\n //! every Rust program. Only operators backed by traits can be overloaded. For\n-//! example, the addition operator (`+`) can be overloaded through the `Add`\n+//! example, the addition operator (`+`) can be overloaded through the [`Add`]\n //! trait, but since the assignment operator (`=`) has no backing trait, there\n //! is no way of overloading its semantics. Additionally, this module does not\n //! provide any mechanism to create new operators. If traitless overloading or\n@@ -30,17 +30,18 @@\n //! contexts involving built-in types, this is usually not a problem.\n //! However, using these operators in generic code, requires some\n //! attention if values have to be reused as opposed to letting the operators\n-//! consume them. One option is to occasionally use `clone()`.\n+//! consume them. One option is to occasionally use [`clone()`].\n //! Another option is to rely on the types involved providing additional\n //! operator implementations for references. For example, for a user-defined\n //! type `T` which is supposed to support addition, it is probably a good\n-//! idea to have both `T` and `&T` implement the traits `Add<T>` and `Add<&T>`\n-//! so that generic code can be written without unnecessary cloning.\n+//! idea to have both `T` and `&T` implement the traits [`Add<T>`][`Add`] and\n+//! [`Add<&T>`][`Add`] so that generic code can be written without unnecessary\n+//! cloning.\n //!\n //! # Examples\n //!\n-//! This example creates a `Point` struct that implements `Add` and `Sub`, and\n-//! then demonstrates adding and subtracting two `Point`s.\n+//! This example creates a `Point` struct that implements [`Add`] and [`Sub`],\n+//! and then demonstrates adding and subtracting two `Point`s.\n //!\n //! ```rust\n //! use std::ops::{Add, Sub};\n@@ -75,18 +76,14 @@\n //! See the documentation for each trait for an example implementation.\n //!\n //! The [`Fn`], [`FnMut`], and [`FnOnce`] traits are implemented by types that can be\n-//! invoked like functions. Note that `Fn` takes `&self`, `FnMut` takes `&mut\n-//! self` and `FnOnce` takes `self`. These correspond to the three kinds of\n+//! invoked like functions. Note that [`Fn`] takes `&self`, [`FnMut`] takes `&mut\n+//! self` and [`FnOnce`] takes `self`. These correspond to the three kinds of\n //! methods that can be invoked on an instance: call-by-reference,\n //! call-by-mutable-reference, and call-by-value. The most common use of these\n //! traits is to act as bounds to higher-level functions that take functions or\n //! closures as arguments.\n //!\n-//! [`Fn`]: trait.Fn.html\n-//! [`FnMut`]: trait.FnMut.html\n-//! [`FnOnce`]: trait.FnOnce.html\n-//!\n-//! Taking a `Fn` as a parameter:\n+//! Taking a [`Fn`] as a parameter:\n //!\n //! ```rust\n //! fn call_with_one<F>(func: F) -> usize\n@@ -99,7 +96,7 @@\n //! assert_eq!(call_with_one(double), 2);\n //! ```\n //!\n-//! Taking a `FnMut` as a parameter:\n+//! Taking a [`FnMut`] as a parameter:\n //!\n //! ```rust\n //! fn do_twice<F>(mut func: F)\n@@ -118,7 +115,7 @@\n //! assert_eq!(x, 5);\n //! ```\n //!\n-//! Taking a `FnOnce` as a parameter:\n+//! Taking a [`FnOnce`] as a parameter:\n //!\n //! ```rust\n //! fn consume_with_relish<F>(func: F)\n@@ -140,6 +137,13 @@\n //!\n //! // `consume_and_return_x` can no longer be invoked at this point\n //! ```\n+//!\n+//! [`Fn`]: trait.Fn.html\n+//! [`FnMut`]: trait.FnMut.html\n+//! [`FnOnce`]: trait.FnOnce.html\n+//! [`Add`]: trait.Add.html\n+//! [`Sub`]: trait.Sub.html\n+//! [`clone()`]: ../clone/trait.Clone.html#tymethod.clone\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -1873,7 +1877,7 @@ macro_rules! shr_assign_impl_all {\n shr_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n \n /// The `Index` trait is used to specify the functionality of indexing operations\n-/// like `arr[idx]` when used in an immutable context.\n+/// like `container[index]` when used in an immutable context.\n ///\n /// # Examples\n ///\n@@ -1924,50 +1928,50 @@ pub trait Index<Idx: ?Sized> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output: ?Sized;\n \n-    /// The method for the indexing (`Foo[Bar]`) operation\n+    /// The method for the indexing (`container[index]`) operation\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index(&self, index: Idx) -> &Self::Output;\n }\n \n /// The `IndexMut` trait is used to specify the functionality of indexing\n-/// operations like `arr[idx]`, when used in a mutable context.\n+/// operations like `container[index]`, when used in a mutable context.\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `IndexMut`. When `Foo[Bar]` happens, it ends up\n-/// calling `index_mut`, and therefore, `main` prints `Indexing!`.\n+/// A trivial implementation of `IndexMut` for a type `Foo`. When `&mut Foo[2]`\n+/// happens, it ends up calling `index_mut`, and therefore, `main` prints\n+/// `Mutable indexing with 2!`.\n ///\n /// ```\n /// use std::ops::{Index, IndexMut};\n ///\n /// #[derive(Copy, Clone)]\n /// struct Foo;\n-/// struct Bar;\n ///\n-/// impl Index<Bar> for Foo {\n+/// impl Index<usize> for Foo {\n ///     type Output = Foo;\n ///\n-///     fn index<'a>(&'a self, _index: Bar) -> &'a Foo {\n+///     fn index(&self, _index: usize) -> &Foo {\n ///         self\n ///     }\n /// }\n ///\n-/// impl IndexMut<Bar> for Foo {\n-///     fn index_mut<'a>(&'a mut self, _index: Bar) -> &'a mut Foo {\n-///         println!(\"Indexing!\");\n+/// impl IndexMut<usize> for Foo {\n+///     fn index_mut(&mut self, index: usize) -> &mut Foo {\n+///         println!(\"Mutable indexing with {}!\", index);\n ///         self\n ///     }\n /// }\n ///\n /// fn main() {\n-///     &mut Foo[Bar];\n+///     &mut Foo[2];\n /// }\n /// ```\n #[lang = \"index_mut\"]\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n-    /// The method for the indexing (`Foo[Bar]`) operation\n+    /// The method for the mutable indexing (`container[index]`) operation\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n }"}, {"sha": "e308a2d8e0375486e9669124c38a61e740bf0417", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -1264,15 +1264,13 @@ pub trait BufRead: Read {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn consume(&mut self, amt: usize);\n \n-    /// Read all bytes into `buf` until the delimiter `byte` is reached.\n+    /// Read all bytes into `buf` until the delimiter `byte` or EOF is reached.\n     ///\n     /// This function will read bytes from the underlying stream until the\n     /// delimiter or EOF is found. Once found, all bytes up to, and including,\n     /// the delimiter (if found) will be appended to `buf`.\n     ///\n-    /// If this reader is currently at EOF then this function will not modify\n-    /// `buf` and will return `Ok(n)` where `n` is the number of bytes which\n-    /// were read.\n+    /// If successful, this function will return the total number of bytes read.\n     ///\n     /// # Errors\n     ///\n@@ -1315,9 +1313,7 @@ pub trait BufRead: Read {\n     /// up to, and including, the delimiter (if found) will be appended to\n     /// `buf`.\n     ///\n-    /// If this reader is currently at EOF then this function will not modify\n-    /// `buf` and will return `Ok(n)` where `n` is the number of bytes which\n-    /// were read.\n+    /// If successful, this function will return the total number of bytes read.\n     ///\n     /// # Errors\n     ///"}, {"sha": "674b00095370efc6945aaf79ee8c60a223d9f6da", "filename": "src/libstd/process.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -8,7 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Working with processes.\n+//! A module for working with processes.\n+//!\n+//! # Examples\n+//!\n+//! Basic usage where we try to execute the `cat` shell command:\n+//!\n+//! ```should_panic\n+//! use std::process::Command;\n+//!\n+//! let mut child = Command::new(\"/bin/cat\")\n+//!                         .arg(\"file.txt\")\n+//!                         .spawn()\n+//!                         .expect(\"failed to execute child\");\n+//!\n+//! let ecode = child.wait()\n+//!                  .expect(\"failed to wait on child\");\n+//!\n+//! assert!(ecode.success());\n+//! ```\n \n #![stable(feature = \"process\", since = \"1.0.0\")]\n "}, {"sha": "a634c8f77a45ca684513a8aa7f55b3ef64534a17", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -151,7 +151,7 @@\n //!\n //! [`Cell`]: ../cell/struct.Cell.html\n //! [`RefCell`]: ../cell/struct.RefCell.html\n-//! [`thread_local!`]: ../macro.thread_local!.html\n+//! [`thread_local!`]: ../macro.thread_local.html\n //! [`with`]: struct.LocalKey.html#method.with\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "6854f1e14fa137e3f3fa2ef99d98705b3bb5d271", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50932b5f4e3a5f1b6c955100da5b30d77bcd29d3/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=50932b5f4e3a5f1b6c955100da5b30d77bcd29d3", "patch": "@@ -118,7 +118,7 @@ pub struct Instant(time::Instant);\n pub struct SystemTime(time::SystemTime);\n \n /// An error returned from the `duration_since` method on `SystemTime`,\n-/// used to learn about why how far in the opposite direction a timestamp lies.\n+/// used to learn how far in the opposite direction a system time lies.\n #[derive(Clone, Debug)]\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n pub struct SystemTimeError(Duration);"}]}