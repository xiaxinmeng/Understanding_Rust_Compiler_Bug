{"sha": "b8f60f3fc47f0f94666721b9fdfebf95ab5fc444", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZjYwZjNmYzQ3ZjBmOTQ2NjY3MjFiOWZkZmViZjk1YWI1ZmM0NDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-13T13:09:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-13T13:09:40Z"}, "message": "Auto merge of #49800 - ishitatsuyuki:intern-goal, r=nikomatsakis\n\ntraits: Implement interning for Goal and Clause\n\nr? @nikomatsakis\n\nClose #49054\n\nContains some refactoring for the interning mechanism, mainly aimed at reducing pain when changing types of interning map.\n\nThis should be mostly good, although I'm not sure with the naming of `Goal::from_poly_domain_goal`.", "tree": {"sha": "79579455a0100fd7c65a3c673a0ffcb6d170312d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79579455a0100fd7c65a3c673a0ffcb6d170312d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444", "html_url": "https://github.com/rust-lang/rust/commit/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99d4886ead646da864cff7963f540a44acd4af05", "url": "https://api.github.com/repos/rust-lang/rust/commits/99d4886ead646da864cff7963f540a44acd4af05", "html_url": "https://github.com/rust-lang/rust/commit/99d4886ead646da864cff7963f540a44acd4af05"}, {"sha": "b15df80345acd9e58824b638d67eec258952d268", "url": "https://api.github.com/repos/rust-lang/rust/commits/b15df80345acd9e58824b638d67eec258952d268", "html_url": "https://github.com/rust-lang/rust/commit/b15df80345acd9e58824b638d67eec258952d268"}], "stats": {"total": 210, "additions": 151, "deletions": 59}, "files": [{"sha": "32fd93cf20a1f7599175205ec62829c553e09b1b", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b8f60f3fc47f0f94666721b9fdfebf95ab5fc444", "patch": "@@ -23,13 +23,12 @@ use infer::outlives::env::OutlivesEnvironment;\n use middle::region;\n use middle::const_val::ConstEvalErr;\n use ty::subst::Substs;\n-use ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, ToPredicate};\n+use ty::{self, AdtKind, Slice, Ty, TyCtxt, TypeFoldable, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n use infer::{InferCtxt};\n \n use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n-use std::convert::From;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -280,37 +279,39 @@ pub enum QuantifierKind {\n     Existential,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Goal<'tcx> {\n-    // FIXME: use interned refs instead of `Box`\n-    Implies(Vec<Clause<'tcx>>, Box<Goal<'tcx>>),\n-    And(Box<Goal<'tcx>>, Box<Goal<'tcx>>),\n-    Not(Box<Goal<'tcx>>),\n+    Implies(&'tcx Slice<Clause<'tcx>>, &'tcx Goal<'tcx>),\n+    And(&'tcx Goal<'tcx>, &'tcx Goal<'tcx>),\n+    Not(&'tcx Goal<'tcx>),\n     DomainGoal(DomainGoal<'tcx>),\n-    Quantified(QuantifierKind, Box<ty::Binder<Goal<'tcx>>>)\n-}\n-\n-impl<'tcx> From<DomainGoal<'tcx>> for Goal<'tcx> {\n-    fn from(domain_goal: DomainGoal<'tcx>) -> Self {\n-        Goal::DomainGoal(domain_goal)\n-    }\n+    Quantified(QuantifierKind, ty::Binder<&'tcx Goal<'tcx>>)\n }\n \n-impl<'tcx> From<PolyDomainGoal<'tcx>> for Goal<'tcx> {\n-    fn from(domain_goal: PolyDomainGoal<'tcx>) -> Self {\n+impl<'tcx> Goal<'tcx> {\n+    pub fn from_poly_domain_goal<'a>(\n+        domain_goal: PolyDomainGoal<'tcx>,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ) -> Goal<'tcx> {\n         match domain_goal.no_late_bound_regions() {\n             Some(p) => p.into(),\n             None => Goal::Quantified(\n                 QuantifierKind::Universal,\n-                Box::new(domain_goal.map_bound(|p| p.into()))\n+                domain_goal.map_bound(|p| tcx.mk_goal(Goal::from(p)))\n             ),\n         }\n     }\n }\n \n+impl<'tcx> From<DomainGoal<'tcx>> for Goal<'tcx> {\n+    fn from(domain_goal: DomainGoal<'tcx>) -> Self {\n+        Goal::DomainGoal(domain_goal)\n+    }\n+}\n+\n /// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n /// Harrop Formulas\".\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Clause<'tcx> {\n     Implies(ProgramClause<'tcx>),\n     ForAll(ty::Binder<ProgramClause<'tcx>>),\n@@ -322,13 +323,13 @@ pub enum Clause<'tcx> {\n /// it with the reverse implication operator `:-` to emphasize the way\n /// that programs are actually solved (via backchaining, which starts\n /// with the goal to solve and proceeds from there).\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ProgramClause<'tcx> {\n     /// This goal will be considered true...\n     pub goal: DomainGoal<'tcx>,\n \n     /// ...if we can prove these hypotheses (there may be no hypotheses at all):\n-    pub hypotheses: Vec<Goal<'tcx>>,\n+    pub hypotheses: &'tcx Slice<Goal<'tcx>>,\n }\n \n pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;"}, {"sha": "523cd42940e27b7ef3798476ad2f06d23fcc271a", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=b8f60f3fc47f0f94666721b9fdfebf95ab5fc444", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n use traits;\n use traits::project::Normalized;\n use ty::{self, Lift, TyCtxt};\n@@ -557,6 +558,28 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<traits::Goal<'tcx>> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        folder.tcx().intern_goals(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx traits::Goal<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = (**self).fold_with(folder);\n+        folder.tcx().mk_goal(v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        (**self).visit_with(visitor)\n+    }\n+}\n+\n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::ProgramClause<'tcx> {\n         goal,\n@@ -570,3 +593,14 @@ EnumTypeFoldableImpl! {\n         (traits::Clause::ForAll)(clause),\n     }\n }\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<traits::Clause<'tcx>> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        folder.tcx().intern_clauses(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}"}, {"sha": "88a2619c7e3ddca41e78edc5844fa7237acf7171", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 71, "deletions": 18, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b8f60f3fc47f0f94666721b9fdfebf95ab5fc444", "patch": "@@ -38,6 +38,7 @@ use ty::subst::{Kind, Substs};\n use ty::ReprOptions;\n use ty::Instance;\n use traits;\n+use traits::{Clause, Goal};\n use ty::{self, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorInterior, Region, Const};\n@@ -125,34 +126,40 @@ impl<'tcx> GlobalArenas<'tcx> {\n     }\n }\n \n+type InternedSet<'tcx, T> = Lock<FxHashSet<Interned<'tcx, T>>>;\n+\n pub struct CtxtInterners<'tcx> {\n     /// The arena that types, regions, etc are allocated from\n     arena: &'tcx DroplessArena,\n \n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n-    type_: Lock<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n-    type_list: Lock<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n-    substs: Lock<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n-    canonical_var_infos: Lock<FxHashSet<Interned<'tcx, Slice<CanonicalVarInfo>>>>,\n-    region: Lock<FxHashSet<Interned<'tcx, RegionKind>>>,\n-    existential_predicates: Lock<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n-    predicates: Lock<FxHashSet<Interned<'tcx, Slice<Predicate<'tcx>>>>>,\n-    const_: Lock<FxHashSet<Interned<'tcx, Const<'tcx>>>>,\n+    type_: InternedSet<'tcx, TyS<'tcx>>,\n+    type_list: InternedSet<'tcx, Slice<Ty<'tcx>>>,\n+    substs: InternedSet<'tcx, Substs<'tcx>>,\n+    canonical_var_infos: InternedSet<'tcx, Slice<CanonicalVarInfo>>,\n+    region: InternedSet<'tcx, RegionKind>,\n+    existential_predicates: InternedSet<'tcx, Slice<ExistentialPredicate<'tcx>>>,\n+    predicates: InternedSet<'tcx, Slice<Predicate<'tcx>>>,\n+    const_: InternedSet<'tcx, Const<'tcx>>,\n+    clauses: InternedSet<'tcx, Slice<Clause<'tcx>>>,\n+    goals: InternedSet<'tcx, Slice<Goal<'tcx>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n     fn new(arena: &'tcx DroplessArena) -> CtxtInterners<'tcx> {\n         CtxtInterners {\n-            arena: arena,\n-            type_: Lock::new(FxHashSet()),\n-            type_list: Lock::new(FxHashSet()),\n-            substs: Lock::new(FxHashSet()),\n-            canonical_var_infos: Lock::new(FxHashSet()),\n-            region: Lock::new(FxHashSet()),\n-            existential_predicates: Lock::new(FxHashSet()),\n-            predicates: Lock::new(FxHashSet()),\n-            const_: Lock::new(FxHashSet()),\n+            arena,\n+            type_: Default::default(),\n+            type_list: Default::default(),\n+            substs: Default::default(),\n+            region: Default::default(),\n+            existential_predicates: Default::default(),\n+            canonical_var_infos: Default::default(),\n+            predicates: Default::default(),\n+            const_: Default::default(),\n+            clauses: Default::default(),\n+            goals: Default::default(),\n         }\n     }\n \n@@ -2099,6 +2106,20 @@ impl<'tcx: 'lcx, 'lcx> Borrow<Const<'lcx>> for Interned<'tcx, Const<'tcx>> {\n     }\n }\n \n+impl<'tcx: 'lcx, 'lcx> Borrow<[Clause<'lcx>]>\n+for Interned<'tcx, Slice<Clause<'tcx>>> {\n+    fn borrow<'a>(&'a self) -> &'a [Clause<'lcx>] {\n+        &self.0[..]\n+    }\n+}\n+\n+impl<'tcx: 'lcx, 'lcx> Borrow<[Goal<'lcx>]>\n+for Interned<'tcx, Slice<Goal<'tcx>>> {\n+    fn borrow<'a>(&'a self) -> &'a [Goal<'lcx>] {\n+        &self.0[..]\n+    }\n+}\n+\n macro_rules! intern_method {\n     ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n                                             $alloc_method:ident,\n@@ -2196,7 +2217,9 @@ slice_interners!(\n     existential_predicates: _intern_existential_predicates(ExistentialPredicate),\n     predicates: _intern_predicates(Predicate),\n     type_list: _intern_type_list(Ty),\n-    substs: _intern_substs(Kind)\n+    substs: _intern_substs(Kind),\n+    clauses: _intern_clauses(Clause),\n+    goals: _intern_goals(Goal)\n );\n \n // This isn't a perfect fit: CanonicalVarInfo slices are always\n@@ -2501,6 +2524,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn intern_clauses(self, ts: &[Clause<'tcx>]) -> &'tcx Slice<Clause<'tcx>> {\n+        if ts.len() == 0 {\n+            Slice::empty()\n+        } else {\n+            self._intern_clauses(ts)\n+        }\n+    }\n+\n+    pub fn intern_goals(self, ts: &[Goal<'tcx>]) -> &'tcx Slice<Goal<'tcx>> {\n+        if ts.len() == 0 {\n+            Slice::empty()\n+        } else {\n+            self._intern_goals(ts)\n+        }\n+    }\n+\n     pub fn mk_fn_sig<I>(self,\n                         inputs: I,\n                         output: I::Item,\n@@ -2547,6 +2586,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_substs(iter::once(s).chain(t.into_iter().cloned()).map(Kind::from))\n     }\n \n+    pub fn mk_clauses<I: InternAs<[Clause<'tcx>],\n+        &'tcx Slice<Clause<'tcx>>>>(self, iter: I) -> I::Output {\n+        iter.intern_with(|xs| self.intern_clauses(xs))\n+    }\n+\n+    pub fn mk_goals<I: InternAs<[Goal<'tcx>],\n+        &'tcx Slice<Goal<'tcx>>>>(self, iter: I) -> I::Output {\n+        iter.intern_with(|xs| self.intern_goals(xs))\n+    }\n+\n+    pub fn mk_goal(self, goal: Goal<'tcx>) -> &'tcx Goal {\n+        &self.mk_goals(iter::once(goal))[0]\n+    }\n+\n     pub fn lint_node<S: Into<MultiSpan>>(self,\n                                          lint: &'static Lint,\n                                          id: NodeId,"}, {"sha": "d317f5a494b782b2ab6d80f71f93500393b73762", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=b8f60f3fc47f0f94666721b9fdfebf95ab5fc444", "patch": "@@ -39,7 +39,7 @@ use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n use traits::specialization_graph;\n use traits::Clause;\n-use ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n+use ty::{self, CrateInherentImpls, ParamEnvAnd, Slice, Ty, TyCtxt};\n use ty::steal::Steal;\n use ty::subst::Substs;\n use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n@@ -445,7 +445,7 @@ define_maps! { <'tcx>\n \n     [] fn features_query: features_node(CrateNum) -> Lrc<feature_gate::Features>,\n \n-    [] fn program_clauses_for: ProgramClausesFor(DefId) -> Lrc<Vec<Clause<'tcx>>>,\n+    [] fn program_clauses_for: ProgramClausesFor(DefId) -> Lrc<&'tcx Slice<Clause<'tcx>>>,\n \n     [] fn wasm_custom_sections: WasmCustomSections(CrateNum) -> Lrc<Vec<DefId>>,\n     [] fn wasm_import_module_map: WasmImportModuleMap(CrateNum)"}, {"sha": "df6793e8a604c2e0ba43cf42d21d4e388aacaae5", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f60f3fc47f0f94666721b9fdfebf95ab5fc444/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=b8f60f3fc47f0f94666721b9fdfebf95ab5fc444", "patch": "@@ -11,12 +11,14 @@\n use rustc::hir::{self, ImplPolarity};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, Slice, TyCtxt};\n use rustc::ty::subst::Substs;\n-use rustc::traits::{WhereClauseAtom, PolyDomainGoal, DomainGoal, ProgramClause, Clause};\n+use rustc::traits::{WhereClauseAtom, PolyDomainGoal, DomainGoal, ProgramClause, Clause, Goal};\n use syntax::ast;\n use rustc_data_structures::sync::Lrc;\n \n+use std::iter;\n+\n trait Lower<T> {\n     /// Lower a rustc construction (e.g. `ty::TraitPredicate`) to a chalk-like type.\n     fn lower(&self) -> T;\n@@ -113,7 +115,7 @@ impl<'tcx> IntoFromEnvGoal for DomainGoal<'tcx> {\n }\n \n crate fn program_clauses_for<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-    -> Lrc<Vec<Clause<'tcx>>>\n+                                       -> Lrc<&'tcx Slice<Clause<'tcx>>>\n {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let item = tcx.hir.expect_item(node_id);\n@@ -122,12 +124,12 @@ crate fn program_clauses_for<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefI\n         hir::ItemImpl(..) => program_clauses_for_impl(tcx, def_id),\n \n         // FIXME: other constructions e.g. traits, associated types...\n-        _ => Lrc::new(vec![]),\n+        _ => Lrc::new(tcx.mk_clauses(iter::empty::<Clause>())),\n     }\n }\n \n fn program_clauses_for_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-    -> Lrc<Vec<Clause<'tcx>>>\n+                                       -> Lrc<&'tcx Slice<Clause<'tcx>>>\n {\n     // `trait Trait<P1..Pn> where WC { .. } // P0 == Self`\n \n@@ -147,18 +149,18 @@ fn program_clauses_for_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefI\n         }\n     };\n     // `FromEnv(Self: Trait<P1..Pn>)`\n-    let from_env = DomainGoal::FromEnv(trait_pred.lower()).into();\n+    let from_env = Goal::from(DomainGoal::FromEnv(trait_pred.lower()));\n     // `Implemented(Self: Trait<P1..Pn>)`\n     let impl_trait = DomainGoal::Holds(WhereClauseAtom::Implemented(trait_pred));\n \n     // `Implemented(Self: Trait<P1..Pn>) :- FromEnv(Self: Trait<P1..Pn>)`\n     let implemented_from_env = ProgramClause {\n         goal: impl_trait,\n-        hypotheses: vec![from_env],\n+        hypotheses: tcx.mk_goals(iter::once(from_env)),\n     };\n-    let mut clauses = vec![\n+    let clauses = iter::once(\n         Clause::ForAll(ty::Binder::dummy(implemented_from_env))\n-    ];\n+    );\n \n     // Rule Implied-Bound-From-Trait\n     //\n@@ -175,14 +177,14 @@ fn program_clauses_for_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefI\n     let where_clauses = &tcx.predicates_of(def_id).predicates;\n     let implied_bound_clauses =\n         where_clauses[1..].into_iter()\n-        .map(|wc| implied_bound_from_trait(trait_pred, wc));\n-    clauses.extend(implied_bound_clauses);\n+        .map(|wc| implied_bound_from_trait(tcx, trait_pred, wc));\n \n-    Lrc::new(clauses)\n+    Lrc::new(tcx.mk_clauses(clauses.chain(implied_bound_clauses)))\n }\n \n /// For a given `where_clause`, returns a clause `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`.\n-fn implied_bound_from_trait<'tcx>(\n+fn implied_bound_from_trait<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_pred: ty::TraitPredicate<'tcx>,\n     where_clause: &ty::Predicate<'tcx>,\n ) -> Clause<'tcx> {\n@@ -193,16 +195,16 @@ fn implied_bound_from_trait<'tcx>(\n     Clause::ForAll(\n         where_clause.lower().map_bound(|goal| ProgramClause {\n             goal: goal.into_from_env_goal(),\n-            hypotheses: vec![impl_trait.into()],\n+            hypotheses: tcx.mk_goals(iter::once(Goal::from(impl_trait))),\n         })\n     )\n }\n \n fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-    -> Lrc<Vec<Clause<'tcx>>>\n+                                      -> Lrc<&'tcx Slice<Clause<'tcx>>>\n {\n     if let ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n-        return Lrc::new(vec![]);\n+        return Lrc::new(tcx.mk_clauses(iter::empty::<Clause>()));\n     }\n \n     // Rule Implemented-From-Impl (see rustc guide)\n@@ -224,9 +226,11 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n      // `Implemented(A0: Trait<A1..An>) :- WC`\n     let clause = ProgramClause {\n         goal: trait_pred,\n-        hypotheses: where_clauses.into_iter().map(|wc| wc.into()).collect()\n+        hypotheses: tcx.mk_goals(\n+            where_clauses.into_iter().map(|wc| Goal::from_poly_domain_goal(wc, tcx))\n+        )\n     };\n-    Lrc::new(vec![Clause::ForAll(ty::Binder::dummy(clause))])\n+    Lrc::new(tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::dummy(clause)))))\n }\n \n pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -248,7 +252,7 @@ impl<'a, 'tcx> ClauseDumper<'a, 'tcx > {\n         for attr in attrs {\n             if attr.check_name(\"rustc_dump_program_clauses\") {\n                 let clauses = self.tcx.program_clauses_for(def_id);\n-                for clause in &*clauses {\n+                for clause in *clauses {\n                     // Skip the top-level binder for a less verbose output\n                     let program_clause = match clause {\n                         Clause::Implies(program_clause) => program_clause,"}]}