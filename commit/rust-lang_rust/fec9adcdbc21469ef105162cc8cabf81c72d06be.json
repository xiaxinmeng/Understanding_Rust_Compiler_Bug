{"sha": "fec9adcdbc21469ef105162cc8cabf81c72d06be", "node_id": "C_kwDOAAsO6NoAKGZlYzlhZGNkYmMyMTQ2OWVmMTA1MTYyY2M4Y2FiZjgxYzcyZDA2YmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-21T19:43:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-21T19:43:11Z"}, "message": "Auto merge of #110648 - Dylan-DPC:rollup-em3ovcq, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #110333 (rustc_metadata: Split `children` into multiple tables)\n - #110501 (rustdoc: fix ICE from rustc_resolve and librustdoc parse divergence)\n - #110608 (Specialize some `io::Read` and `io::Write` methods for `VecDeque<u8>` and `&[u8]`)\n - #110632 (Panic instead of truncating if the incremental on-disk cache is too big)\n - #110633 (More `mem::take` in `library`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "64187970c869f390de938eb05ae0c8f22e5f3752", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64187970c869f390de938eb05ae0c8f22e5f3752"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fec9adcdbc21469ef105162cc8cabf81c72d06be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fec9adcdbc21469ef105162cc8cabf81c72d06be", "html_url": "https://github.com/rust-lang/rust/commit/fec9adcdbc21469ef105162cc8cabf81c72d06be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fec9adcdbc21469ef105162cc8cabf81c72d06be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa4cc63a6bd6f32903269e52b8f59b284d0e76c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa4cc63a6bd6f32903269e52b8f59b284d0e76c4", "html_url": "https://github.com/rust-lang/rust/commit/fa4cc63a6bd6f32903269e52b8f59b284d0e76c4"}, {"sha": "482e407a1f4a2c67e7fe98682612b78b35025e7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/482e407a1f4a2c67e7fe98682612b78b35025e7a", "html_url": "https://github.com/rust-lang/rust/commit/482e407a1f4a2c67e7fe98682612b78b35025e7a"}], "stats": {"total": 193, "additions": 153, "deletions": 40}, "files": [{"sha": "601281fddbaa6a4020a5a24161b89084067cccea", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -876,16 +876,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             variant_did,\n             ctor,\n             data.discr,\n-            self.root\n-                .tables\n-                .children\n-                .get(self, index)\n-                .expect(\"fields are not encoded for a variant\")\n-                .decode(self)\n-                .map(|index| ty::FieldDef {\n-                    did: self.local_def_id(index),\n-                    name: self.item_name(index),\n-                    vis: self.get_visibility(index),\n+            self.get_associated_item_or_field_def_ids(index)\n+                .map(|did| ty::FieldDef {\n+                    did,\n+                    name: self.item_name(did.index),\n+                    vis: self.get_visibility(did.index),\n                 })\n                 .collect(),\n             adt_kind,\n@@ -910,7 +905,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         let variants = if let ty::AdtKind::Enum = adt_kind {\n             self.root\n                 .tables\n-                .children\n+                .module_children_non_reexports\n                 .get(self, item_id)\n                 .expect(\"variants are not encoded for an enum\")\n                 .decode(self)\n@@ -1022,11 +1017,9 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 }\n             } else {\n                 // Iterate over all children.\n-                for child_index in self.root.tables.children.get(self, id).unwrap().decode(self) {\n-                    // FIXME: Do not encode RPITITs as a part of this list.\n-                    if self.root.tables.opt_rpitit_info.get(self, child_index).is_none() {\n-                        yield self.get_mod_child(child_index, sess);\n-                    }\n+                let non_reexports = self.root.tables.module_children_non_reexports.get(self, id);\n+                for child_index in non_reexports.unwrap().decode(self) {\n+                    yield self.get_mod_child(child_index, sess);\n                 }\n \n                 let reexports = self.root.tables.module_children_reexports.get(self, id);\n@@ -1058,17 +1051,16 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .map_or(false, |ident| ident.name == kw::SelfLower)\n     }\n \n-    fn get_associated_item_def_ids(\n+    fn get_associated_item_or_field_def_ids(\n         self,\n         id: DefIndex,\n-        sess: &'a Session,\n     ) -> impl Iterator<Item = DefId> + 'a {\n         self.root\n             .tables\n-            .children\n+            .associated_item_or_field_def_ids\n             .get(self, id)\n-            .expect(\"associated items not encoded for an item\")\n-            .decode((self, sess))\n+            .unwrap_or_else(|| self.missing(\"associated_item_or_field_def_ids\", id))\n+            .decode(self)\n             .map(move |child_index| self.local_def_id(child_index))\n     }\n "}, {"sha": "141980912b1d6dbaf5085685687ec1280580b28e", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -276,7 +276,7 @@ provide! { tcx, def_id, other, cdata,\n         tcx.calculate_dtor(def_id, |_,_| Ok(()))\n     }\n     associated_item_def_ids => {\n-        tcx.arena.alloc_from_iter(cdata.get_associated_item_def_ids(def_id.index, tcx.sess))\n+        tcx.arena.alloc_from_iter(cdata.get_associated_item_or_field_def_ids(def_id.index))\n     }\n     associated_item => { cdata.get_associated_item(def_id.index, tcx.sess) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }"}, {"sha": "14c1b9d5589fec533be86e2619a5d1de4ac9aa7f", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -1367,7 +1367,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         if adt_def.is_enum() {\n             let module_children = tcx.module_children_non_reexports(local_def_id);\n-            record_array!(self.tables.children[def_id] <-\n+            record_array!(self.tables.module_children_non_reexports[def_id] <-\n                 module_children.iter().map(|def_id| def_id.local_def_index));\n         } else {\n             // For non-enum, there is only one variant, and its def_id is the adt's.\n@@ -1385,7 +1385,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             record!(self.tables.variant_data[variant.def_id] <- data);\n \n             self.tables.constness.set_some(variant.def_id.index, hir::Constness::Const);\n-            record_array!(self.tables.children[variant.def_id] <- variant.fields.iter().map(|f| {\n+            record_array!(self.tables.associated_item_or_field_def_ids[variant.def_id] <- variant.fields.iter().map(|f| {\n                 assert!(f.did.is_local());\n                 f.did.index\n             }));\n@@ -1415,7 +1415,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             record!(self.tables.expn_that_defined[def_id] <- tcx.expn_that_defined(local_def_id));\n         } else {\n             let non_reexports = tcx.module_children_non_reexports(local_def_id);\n-            record_array!(self.tables.children[def_id] <-\n+            record_array!(self.tables.module_children_non_reexports[def_id] <-\n                 non_reexports.iter().map(|def_id| def_id.local_def_index));\n \n             record_defaulted_array!(self.tables.module_children_reexports[def_id] <-\n@@ -1617,7 +1617,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n         let record_associated_item_def_ids = |this: &mut Self, def_ids: &[DefId]| {\n-            record_array!(this.tables.children[def_id] <- def_ids.iter().map(|&def_id| {\n+            record_array!(this.tables.associated_item_or_field_def_ids[def_id] <- def_ids.iter().map(|&def_id| {\n                 assert!(def_id.is_local());\n                 def_id.index\n             }))\n@@ -1678,6 +1678,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Trait(..) => {\n                 record!(self.tables.trait_def[def_id] <- self.tcx.trait_def(def_id));\n \n+                let module_children = tcx.module_children_non_reexports(item.owner_id.def_id);\n+                record_array!(self.tables.module_children_non_reexports[def_id] <-\n+                    module_children.iter().map(|def_id| def_id.local_def_index));\n+\n                 let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n                 record_associated_item_def_ids(self, associated_item_def_ids);\n                 for &item_def_id in associated_item_def_ids {"}, {"sha": "f2302c0ad43c906353a91c49e164addb3d063a78", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -361,7 +361,8 @@ define_tables! {\n \n - optional:\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,\n-    children: Table<DefIndex, LazyArray<DefIndex>>,\n+    module_children_non_reexports: Table<DefIndex, LazyArray<DefIndex>>,\n+    associated_item_or_field_def_ids: Table<DefIndex, LazyArray<DefIndex>>,\n     opt_def_kind: Table<DefIndex, DefKind>,\n     visibility: Table<DefIndex, LazyValue<ty::Visibility<DefIndex>>>,\n     def_span: Table<DefIndex, LazyValue<Span>>,"}, {"sha": "1c370b299619252d55b9aa06bacdf2fc0914cdbc", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -670,9 +670,10 @@ rustc_queries! {\n         desc { \"computing the inferred outlives predicates for items in this crate\" }\n     }\n \n-    /// Maps from an impl/trait `DefId` to a list of the `DefId`s of its items.\n+    /// Maps from an impl/trait or struct/variant `DefId`\n+    /// to a list of the `DefId`s of its associated items or fields.\n     query associated_item_def_ids(key: DefId) -> &'tcx [DefId] {\n-        desc { |tcx| \"collecting associated items of `{}`\", tcx.def_path_str(key) }\n+        desc { |tcx| \"collecting associated items or fields of `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }"}, {"sha": "c05323c2d6ca8d4a7a7c7a9a62388939f13e5d9f", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -300,7 +300,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n                     interpret_alloc_index.reserve(new_n - n);\n                     for idx in n..new_n {\n                         let id = encoder.interpret_allocs[idx];\n-                        let pos = encoder.position() as u32;\n+                        let pos: u32 = encoder.position().try_into().unwrap();\n                         interpret_alloc_index.push(pos);\n                         interpret::specialized_encode_alloc_id(&mut encoder, tcx, id);\n                     }"}, {"sha": "d433391f272e02d7d2f4b4f318ff2f2aac98fd7a", "filename": "compiler/rustc_resolve/src/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -367,6 +367,7 @@ fn preprocess_link(link: &str) -> Box<str> {\n     let link = link.strip_suffix(\"{}\").unwrap_or(link);\n     let link = link.strip_suffix(\"[]\").unwrap_or(link);\n     let link = if link != \"!\" { link.strip_suffix('!').unwrap_or(link) } else { link };\n+    let link = link.trim();\n     strip_generics_from_path(link).unwrap_or_else(|_| link.into())\n }\n "}, {"sha": "e3ca6eb7833f4408a5d90c6796b04f5dd4c6c5fb", "filename": "library/alloc/src/vec/drain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -197,7 +197,7 @@ impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n             }\n         }\n \n-        let iter = mem::replace(&mut self.iter, (&mut []).iter());\n+        let iter = mem::take(&mut self.iter);\n         let drop_len = iter.len();\n \n         let mut vec = self.vec;"}, {"sha": "b2dd92a2379a83ea3c305cbc871139950040c067", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -685,7 +685,7 @@ where\n             None\n         } else {\n             self.finished = true;\n-            Some(mem::replace(&mut self.v, &mut []))\n+            Some(mem::take(&mut self.v))\n         }\n     }\n }\n@@ -749,7 +749,7 @@ where\n         match idx_opt {\n             None => self.finish(),\n             Some(idx) => {\n-                let tmp = mem::replace(&mut self.v, &mut []);\n+                let tmp = mem::take(&mut self.v);\n                 let (head, tail) = tmp.split_at_mut(idx);\n                 self.v = head;\n                 Some(&mut tail[1..])\n@@ -830,7 +830,7 @@ where\n         if idx == self.v.len() {\n             self.finished = true;\n         }\n-        let tmp = mem::replace(&mut self.v, &mut []);\n+        let tmp = mem::take(&mut self.v);\n         let (head, tail) = tmp.split_at_mut(idx);\n         self.v = tail;\n         Some(head)\n@@ -876,7 +876,7 @@ where\n         if idx == 0 {\n             self.finished = true;\n         }\n-        let tmp = mem::replace(&mut self.v, &mut []);\n+        let tmp = mem::take(&mut self.v);\n         let (head, tail) = tmp.split_at_mut(idx);\n         self.v = head;\n         Some(tail)"}, {"sha": "a7428776d8f86978241a69a36fabe4c68aca0ed8", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -9,6 +9,7 @@ use crate::io::{\n     self, BorrowedCursor, BufRead, ErrorKind, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write,\n };\n use crate::mem;\n+use crate::str;\n \n // =============================================================================\n // Forwarding implementations\n@@ -307,6 +308,17 @@ impl Read for &[u8] {\n         *self = &self[len..];\n         Ok(len)\n     }\n+\n+    #[inline]\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n+        let content = str::from_utf8(self).map_err(|_| {\n+            io::const_io_error!(ErrorKind::InvalidData, \"stream did not contain valid UTF-8\")\n+        })?;\n+        buf.push_str(content);\n+        let len = self.len();\n+        *self = &self[len..];\n+        Ok(len)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -336,7 +348,7 @@ impl Write for &mut [u8] {\n     #[inline]\n     fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         let amt = cmp::min(data.len(), self.len());\n-        let (a, b) = mem::replace(self, &mut []).split_at_mut(amt);\n+        let (a, b) = mem::take(self).split_at_mut(amt);\n         a.copy_from_slice(&data[..amt]);\n         *self = b;\n         Ok(amt)\n@@ -434,6 +446,33 @@ impl<A: Allocator> Read for VecDeque<u8, A> {\n         self.drain(..n);\n         Ok(())\n     }\n+\n+    #[inline]\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        // The total len is known upfront so we can reserve it in a single call.\n+        let len = self.len();\n+        buf.reserve(len);\n+\n+        let (front, back) = self.as_slices();\n+        buf.extend_from_slice(front);\n+        buf.extend_from_slice(back);\n+        self.clear();\n+        Ok(len)\n+    }\n+\n+    #[inline]\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n+        // We have to use a single contiguous slice because the `VecDequeue` might be split in the\n+        // middle of an UTF-8 character.\n+        let len = self.len();\n+        let content = self.make_contiguous();\n+        let string = str::from_utf8(content).map_err(|_| {\n+            io::const_io_error!(ErrorKind::InvalidData, \"stream did not contain valid UTF-8\")\n+        })?;\n+        buf.push_str(string);\n+        self.clear();\n+        Ok(len)\n+    }\n }\n \n /// Write is implemented for `VecDeque<u8>` by appending to the `VecDeque`, growing it as needed.\n@@ -445,6 +484,21 @@ impl<A: Allocator> Write for VecDeque<u8, A> {\n         Ok(buf.len())\n     }\n \n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let len = bufs.iter().map(|b| b.len()).sum();\n+        self.reserve(len);\n+        for buf in bufs {\n+            self.extend(&**buf);\n+        }\n+        Ok(len)\n+    }\n+\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        true\n+    }\n+\n     #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n         self.extend(buf);"}, {"sha": "8c1c8cac0efa71eb049f7ec6ac97cd329d11b333", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -253,7 +253,7 @@ mod tests;\n \n use crate::cmp;\n use crate::fmt;\n-use crate::mem::replace;\n+use crate::mem::take;\n use crate::ops::{Deref, DerefMut};\n use crate::slice;\n use crate::str;\n@@ -1186,7 +1186,7 @@ impl<'a> IoSliceMut<'a> {\n             }\n         }\n \n-        *bufs = &mut replace(bufs, &mut [])[remove..];\n+        *bufs = &mut take(bufs)[remove..];\n         if bufs.is_empty() {\n             assert!(n == accumulated_len, \"advancing io slices beyond their length\");\n         } else {\n@@ -1329,7 +1329,7 @@ impl<'a> IoSlice<'a> {\n             }\n         }\n \n-        *bufs = &mut replace(bufs, &mut [])[remove..];\n+        *bufs = &mut take(bufs)[remove..];\n         if bufs.is_empty() {\n             assert!(n == accumulated_len, \"advancing io slices beyond their length\");\n         } else {"}, {"sha": "6372fca74e0d703c27e4c0c00ffe2012b96214e4", "filename": "library/std/src/sys/unsupported/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fio.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -30,7 +30,7 @@ impl<'a> IoSliceMut<'a> {\n \n     #[inline]\n     pub fn advance(&mut self, n: usize) {\n-        let slice = mem::replace(&mut self.0, &mut []);\n+        let slice = mem::take(&mut self.0);\n         let (_, remaining) = slice.split_at_mut(n);\n         self.0 = remaining;\n     }"}, {"sha": "ef9c56f759296748fa04d0f553750ae90125f204", "filename": "tests/rustdoc-ui/intra-doc/issue-110495-suffix-with-space.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.rs?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -0,0 +1,6 @@\n+// this test used to ICE\n+#![deny(rustdoc::broken_intra_doc_links)]\n+//! [Clone ()]. //~ ERROR unresolved\n+//! [Clone !]. //~ ERROR incompatible\n+//! [`Clone ()`]. //~ ERROR unresolved\n+//! [`Clone !`]. //~ ERROR incompatible"}, {"sha": "8669b0c20865cdaa6d545910281a13ecb02998de", "filename": "tests/rustdoc-ui/intra-doc/issue-110495-suffix-with-space.stderr", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fec9adcdbc21469ef105162cc8cabf81c72d06be/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fec9adcdbc21469ef105162cc8cabf81c72d06be/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.stderr?ref=fec9adcdbc21469ef105162cc8cabf81c72d06be", "patch": "@@ -0,0 +1,54 @@\n+error: unresolved link to `Clone`\n+  --> $DIR/issue-110495-suffix-with-space.rs:3:6\n+   |\n+LL | //! [Clone ()].\n+   |      ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-110495-suffix-with-space.rs:2:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - //! [Clone ()].\n+LL + //! [trait@Clone ].\n+   |\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/issue-110495-suffix-with-space.rs:4:6\n+   |\n+LL | //! [Clone !].\n+   |      ^^^^^^^ this link resolved to a derive macro, which is not a macro\n+   |\n+help: to link to the derive macro, prefix with `derive@`\n+   |\n+LL - //! [Clone !].\n+LL + //! [derive@Clone ].\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/issue-110495-suffix-with-space.rs:5:7\n+   |\n+LL | //! [`Clone ()`].\n+   |       ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - //! [`Clone ()`].\n+LL + //! [`trait@Clone (`].\n+   |\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/issue-110495-suffix-with-space.rs:6:7\n+   |\n+LL | //! [`Clone !`].\n+   |       ^^^^^^^ this link resolved to a derive macro, which is not a macro\n+   |\n+help: to link to the derive macro, prefix with `derive@`\n+   |\n+LL | //! [`derive@Clone !`].\n+   |       +++++++\n+\n+error: aborting due to 4 previous errors\n+"}]}