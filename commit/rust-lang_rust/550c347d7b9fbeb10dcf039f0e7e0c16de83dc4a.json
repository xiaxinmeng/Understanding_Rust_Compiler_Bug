{"sha": "550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MGMzNDdkN2I5ZmJlYjEwZGNmMDM5ZjBlN2UwYzE2ZGU4M2RjNGE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-04T07:00:59Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-07T05:19:57Z"}, "message": "rustuv: Deal with the rtio changes", "tree": {"sha": "e8fd9224bc7abaa698f89bc6a8c7c716208af01b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8fd9224bc7abaa698f89bc6a8c7c716208af01b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "html_url": "https://github.com/rust-lang/rust/commit/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51348b068b88d71426d9de93762575cd2bb9a5f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/51348b068b88d71426d9de93762575cd2bb9a5f5", "html_url": "https://github.com/rust-lang/rust/commit/51348b068b88d71426d9de93762575cd2bb9a5f5"}], "stats": {"total": 865, "additions": 319, "deletions": 546}, "files": [{"sha": "daca3005f12ffcd099463bc3211988121dba6d44", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 12, "deletions": 56, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ai = std::io::net::addrinfo;\n use libc::c_int;\n use libc;\n use std::mem;\n use std::ptr::null;\n use std::rt::task::BlockedTask;\n+use std::rt::rtio;\n \n use net;\n use super::{Loop, UvError, Request, wait_until_woken_after, wakeup};\n@@ -33,7 +33,9 @@ pub struct GetAddrInfoRequest;\n \n impl GetAddrInfoRequest {\n     pub fn run(loop_: &Loop, node: Option<&str>, service: Option<&str>,\n-               hints: Option<ai::Hint>) -> Result<Vec<ai::Info>, UvError> {\n+               hints: Option<rtio::AddrinfoHint>)\n+        -> Result<Vec<rtio::AddrinfoInfo>, UvError>\n+    {\n         assert!(node.is_some() || service.is_some());\n         let (_c_node, c_node_ptr) = match node {\n             Some(n) => {\n@@ -54,20 +56,11 @@ impl GetAddrInfoRequest {\n         };\n \n         let hint = hints.map(|hint| {\n-            let mut flags = 0;\n-            each_ai_flag(|cval, aival| {\n-                if hint.flags & (aival as uint) != 0 {\n-                    flags |= cval as i32;\n-                }\n-            });\n-            let socktype = 0;\n-            let protocol = 0;\n-\n             libc::addrinfo {\n-                ai_flags: flags,\n+                ai_flags: 0,\n                 ai_family: hint.family as c_int,\n-                ai_socktype: socktype,\n-                ai_protocol: protocol,\n+                ai_socktype: 0,\n+                ai_protocol: 0,\n                 ai_addrlen: 0,\n                 ai_canonname: null(),\n                 ai_addr: null(),\n@@ -119,22 +112,8 @@ impl Drop for Addrinfo {\n     }\n }\n \n-fn each_ai_flag(_f: |c_int, ai::Flag|) {\n-    /* FIXME: do we really want to support these?\n-    unsafe {\n-        f(uvll::rust_AI_ADDRCONFIG(), ai::AddrConfig);\n-        f(uvll::rust_AI_ALL(), ai::All);\n-        f(uvll::rust_AI_CANONNAME(), ai::CanonName);\n-        f(uvll::rust_AI_NUMERICHOST(), ai::NumericHost);\n-        f(uvll::rust_AI_NUMERICSERV(), ai::NumericServ);\n-        f(uvll::rust_AI_PASSIVE(), ai::Passive);\n-        f(uvll::rust_AI_V4MAPPED(), ai::V4Mapped);\n-    }\n-    */\n-}\n-\n // Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n-pub fn accum_addrinfo(addr: &Addrinfo) -> Vec<ai::Info> {\n+pub fn accum_addrinfo(addr: &Addrinfo) -> Vec<rtio::AddrinfoInfo> {\n     unsafe {\n         let mut addr = addr.handle;\n \n@@ -143,35 +122,12 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> Vec<ai::Info> {\n             let rustaddr = net::sockaddr_to_addr(mem::transmute((*addr).ai_addr),\n                                                  (*addr).ai_addrlen as uint);\n \n-            let mut flags = 0;\n-            each_ai_flag(|cval, aival| {\n-                if (*addr).ai_flags & cval != 0 {\n-                    flags |= aival as uint;\n-                }\n-            });\n-\n-            /* FIXME: do we really want to support these\n-            let protocol = match (*addr).ai_protocol {\n-                p if p == uvll::rust_IPPROTO_UDP() => Some(ai::UDP),\n-                p if p == uvll::rust_IPPROTO_TCP() => Some(ai::TCP),\n-                _ => None,\n-            };\n-            let socktype = match (*addr).ai_socktype {\n-                p if p == uvll::rust_SOCK_STREAM() => Some(ai::Stream),\n-                p if p == uvll::rust_SOCK_DGRAM() => Some(ai::Datagram),\n-                p if p == uvll::rust_SOCK_RAW() => Some(ai::Raw),\n-                _ => None,\n-            };\n-            */\n-            let protocol = None;\n-            let socktype = None;\n-\n-            addrs.push(ai::Info {\n+            addrs.push(rtio::AddrinfoInfo {\n                 address: rustaddr,\n                 family: (*addr).ai_family as uint,\n-                socktype: socktype,\n-                protocol: protocol,\n-                flags: flags,\n+                socktype: 0,\n+                protocol: 0,\n+                flags: 0,\n             });\n             if (*addr).ai_next.is_not_null() {\n                 addr = (*addr).ai_next;"}, {"sha": "5167ce5aff2d98430b9646f2f96c6ee2d9c5d333", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use alloc::arc::Arc;\n use std::mem;\n+use std::rt::exclusive::Exclusive;\n use std::rt::rtio::{Callback, RemoteCallback};\n-use std::unstable::sync::Exclusive;\n \n use uvll;\n use super::{Loop, UvHandle};\n@@ -22,12 +23,12 @@ pub struct AsyncWatcher {\n \n     // A flag to tell the callback to exit, set from the dtor. This is\n     // almost never contested - only in rare races with the dtor.\n-    exit_flag: Exclusive<bool>\n+    exit_flag: Arc<Exclusive<bool>>,\n }\n \n struct Payload {\n     callback: Box<Callback:Send>,\n-    exit_flag: Exclusive<bool>,\n+    exit_flag: Arc<Exclusive<bool>>,\n }\n \n impl AsyncWatcher {\n@@ -36,7 +37,7 @@ impl AsyncWatcher {\n         assert_eq!(unsafe {\n             uvll::uv_async_init(loop_.handle, handle, async_cb)\n         }, 0);\n-        let flag = Exclusive::new(false);\n+        let flag = Arc::new(Exclusive::new(false));\n         let payload = box Payload { callback: cb, exit_flag: flag.clone() };\n         unsafe {\n             let payload: *u8 = mem::transmute(payload);\n@@ -80,9 +81,7 @@ extern fn async_cb(handle: *uvll::uv_async_t) {\n     // could be called in the other thread, missing the final\n     // callback while still destroying the handle.\n \n-    let should_exit = unsafe {\n-        payload.exit_flag.with_imm(|&should_exit| should_exit)\n-    };\n+    let should_exit = unsafe { *payload.exit_flag.lock() };\n \n     payload.callback.call();\n \n@@ -108,16 +107,13 @@ impl RemoteCallback for AsyncWatcher {\n \n impl Drop for AsyncWatcher {\n     fn drop(&mut self) {\n-        unsafe {\n-            self.exit_flag.with(|should_exit| {\n-                // NB: These two things need to happen atomically. Otherwise\n-                // the event handler could wake up due to a *previous*\n-                // signal and see the exit flag, destroying the handle\n-                // before the final send.\n-                *should_exit = true;\n-                uvll::uv_async_send(self.handle)\n-            })\n-        }\n+        let mut should_exit = unsafe { self.exit_flag.lock() };\n+        // NB: These two things need to happen atomically. Otherwise\n+        // the event handler could wake up due to a *previous*\n+        // signal and see the exit flag, destroying the handle\n+        // before the final send.\n+        *should_exit = true;\n+        unsafe { uvll::uv_async_send(self.handle) }\n     }\n }\n "}, {"sha": "4b1343045de376219398b7137b5dc6aa689ca338", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 46, "deletions": 62, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -12,9 +12,9 @@ use libc::{c_int, c_char, c_void, ssize_t};\n use libc;\n use std::c_str::CString;\n use std::c_str;\n-use std::io::{FileStat, IoError};\n-use std::io;\n use std::mem;\n+use std::os;\n+use std::rt::rtio::{IoResult, IoError};\n use std::rt::rtio;\n use std::rt::task::BlockedTask;\n \n@@ -56,21 +56,23 @@ impl FsRequest {\n         })\n     }\n \n-    pub fn lstat(loop_: &Loop, path: &CString) -> Result<FileStat, UvError> {\n+    pub fn lstat(loop_: &Loop, path: &CString)\n+        -> Result<rtio::FileStat, UvError>\n+    {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_lstat(loop_.handle, req, path.with_ref(|p| p),\n                               cb)\n         }).map(|req| req.mkstat())\n     }\n \n-    pub fn stat(loop_: &Loop, path: &CString) -> Result<FileStat, UvError> {\n+    pub fn stat(loop_: &Loop, path: &CString) -> Result<rtio::FileStat, UvError> {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_stat(loop_.handle, req, path.with_ref(|p| p),\n                              cb)\n         }).map(|req| req.mkstat())\n     }\n \n-    pub fn fstat(loop_: &Loop, fd: c_int) -> Result<FileStat, UvError> {\n+    pub fn fstat(loop_: &Loop, fd: c_int) -> Result<rtio::FileStat, UvError> {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_fstat(loop_.handle, req, fd, cb)\n         }).map(|req| req.mkstat())\n@@ -269,40 +271,30 @@ impl FsRequest {\n         unsafe { uvll::get_ptr_from_fs_req(self.req) }\n     }\n \n-    pub fn mkstat(&self) -> FileStat {\n+    pub fn mkstat(&self) -> rtio::FileStat {\n         let stat = self.get_stat();\n         fn to_msec(stat: uvll::uv_timespec_t) -> u64 {\n             // Be sure to cast to u64 first to prevent overflowing if the tv_sec\n             // field is a 32-bit integer.\n             (stat.tv_sec as u64) * 1000 + (stat.tv_nsec as u64) / 1000000\n         }\n-        let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-            libc::S_IFREG => io::TypeFile,\n-            libc::S_IFDIR => io::TypeDirectory,\n-            libc::S_IFIFO => io::TypeNamedPipe,\n-            libc::S_IFBLK => io::TypeBlockSpecial,\n-            libc::S_IFLNK => io::TypeSymlink,\n-            _ => io::TypeUnknown,\n-        };\n-        FileStat {\n+        rtio::FileStat {\n             size: stat.st_size as u64,\n-            kind: kind,\n-            perm: io::FilePermission::from_bits_truncate(stat.st_mode as u32),\n+            kind: stat.st_mode as u64,\n+            perm: stat.st_mode as u64,\n             created: to_msec(stat.st_birthtim),\n             modified: to_msec(stat.st_mtim),\n             accessed: to_msec(stat.st_atim),\n-            unstable: io::UnstableFileStat {\n-                device: stat.st_dev as u64,\n-                inode: stat.st_ino as u64,\n-                rdev: stat.st_rdev as u64,\n-                nlink: stat.st_nlink as u64,\n-                uid: stat.st_uid as u64,\n-                gid: stat.st_gid as u64,\n-                blksize: stat.st_blksize as u64,\n-                blocks: stat.st_blocks as u64,\n-                flags: stat.st_flags as u64,\n-                gen: stat.st_gen as u64,\n-            }\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize: stat.st_blksize as u64,\n+            blocks: stat.st_blocks as u64,\n+            flags: stat.st_flags as u64,\n+            gen: stat.st_gen as u64,\n         }\n     }\n }\n@@ -369,29 +361,26 @@ impl FileWatcher {\n         }\n     }\n \n-    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n+    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> IoResult<int> {\n         let _m = self.fire_homing_missile();\n         let r = FsRequest::read(&self.loop_, self.fd, buf, offset);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n+    fn base_write(&mut self, buf: &[u8], offset: i64) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         let r = FsRequest::write(&self.loop_, self.fd, buf, offset);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn seek_common(&self, pos: i64, whence: c_int) ->\n-        Result<u64, IoError>{\n-        unsafe {\n-            match libc::lseek(self.fd, pos as libc::off_t, whence) {\n-                -1 => {\n-                    Err(IoError {\n-                        kind: io::OtherIoError,\n-                        desc: \"Failed to lseek.\",\n-                        detail: None\n-                    })\n-                },\n-                n => Ok(n as u64)\n-            }\n+    fn seek_common(&self, pos: i64, whence: c_int) -> IoResult<u64>{\n+        match unsafe { libc::lseek(self.fd, pos as libc::off_t, whence) } {\n+            -1 => {\n+                Err(IoError {\n+                    code: os::errno() as uint,\n+                    extra: 0,\n+                    detail: None,\n+                })\n+            },\n+            n => Ok(n as u64)\n         }\n     }\n }\n@@ -425,47 +414,47 @@ impl Drop for FileWatcher {\n }\n \n impl rtio::RtioFileStream for FileWatcher {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n         self.base_read(buf, -1)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.base_write(buf, -1)\n     }\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n         self.base_read(buf, offset as i64)\n     }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n         self.base_write(buf, offset as i64)\n     }\n-    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> {\n+    fn seek(&mut self, pos: i64, whence: rtio::SeekStyle) -> IoResult<u64> {\n         use libc::{SEEK_SET, SEEK_CUR, SEEK_END};\n         let whence = match whence {\n-            io::SeekSet => SEEK_SET,\n-            io::SeekCur => SEEK_CUR,\n-            io::SeekEnd => SEEK_END\n+            rtio::SeekSet => SEEK_SET,\n+            rtio::SeekCur => SEEK_CUR,\n+            rtio::SeekEnd => SEEK_END\n         };\n         self.seek_common(pos, whence)\n     }\n-    fn tell(&self) -> Result<u64, IoError> {\n+    fn tell(&self) -> IoResult<u64> {\n         use libc::SEEK_CUR;\n \n         self.seek_common(0, SEEK_CUR)\n     }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n+    fn fsync(&mut self) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         FsRequest::fsync(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n     }\n-    fn datasync(&mut self) -> Result<(), IoError> {\n+    fn datasync(&mut self) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         FsRequest::datasync(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n     }\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         let r = FsRequest::truncate(&self.loop_, self.fd, offset);\n         r.map_err(uv_error_to_io_error)\n     }\n \n-    fn fstat(&mut self) -> Result<FileStat, IoError> {\n+    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n         let _m = self.fire_homing_missile();\n         FsRequest::fstat(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n     }\n@@ -475,7 +464,6 @@ impl rtio::RtioFileStream for FileWatcher {\n mod test {\n     use libc::c_int;\n     use libc::{O_CREAT, O_RDWR, O_RDONLY, S_IWUSR, S_IRUSR};\n-    use std::io;\n     use std::str;\n     use super::FsRequest;\n     use super::super::Loop;\n@@ -562,10 +550,6 @@ mod test {\n         let result = FsRequest::mkdir(l(), path, mode);\n         assert!(result.is_ok());\n \n-        let result = FsRequest::stat(l(), path);\n-        assert!(result.is_ok());\n-        assert!(result.unwrap().kind == io::TypeDirectory);\n-\n         let result = FsRequest::rmdir(l(), path);\n         assert!(result.is_ok());\n "}, {"sha": "644ac4e45f6569e62ee82b890fd0f23d3898e5a0", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -153,8 +153,7 @@ mod test {\n     use green::sched;\n     use green::{SchedPool, PoolConfig};\n     use std::rt::rtio::RtioUdpSocket;\n-    use std::io::test::next_test_ip4;\n-    use std::task::TaskOpts;\n+    use std::rt::task::TaskOpts;\n \n     use net::UdpWatcher;\n     use super::super::local_loop;\n@@ -172,7 +171,7 @@ mod test {\n         });\n \n         pool.spawn(TaskOpts::new(), proc() {\n-            let listener = UdpWatcher::bind(local_loop(), next_test_ip4());\n+            let listener = UdpWatcher::bind(local_loop(), ::next_test_ip4());\n             tx.send(listener.unwrap());\n         });\n \n@@ -193,18 +192,18 @@ mod test {\n         });\n \n         pool.spawn(TaskOpts::new(), proc() {\n-            let addr1 = next_test_ip4();\n-            let addr2 = next_test_ip4();\n+            let addr1 = ::next_test_ip4();\n+            let addr2 = ::next_test_ip4();\n             let listener = UdpWatcher::bind(local_loop(), addr2);\n             tx.send((listener.unwrap(), addr1));\n             let mut listener = UdpWatcher::bind(local_loop(), addr1).unwrap();\n-            listener.sendto([1, 2, 3, 4], addr2).unwrap();\n+            listener.sendto([1, 2, 3, 4], addr2).ok().unwrap();\n         });\n \n         let task = pool.task(TaskOpts::new(), proc() {\n             let (mut watcher, addr) = rx.recv();\n             let mut buf = [0, ..10];\n-            assert_eq!(watcher.recvfrom(buf).unwrap(), (4, addr));\n+            assert!(watcher.recvfrom(buf).ok().unwrap() == (4, addr));\n         });\n         pool.spawn_sched().send(sched::TaskFromFriend(task));\n "}, {"sha": "cbbb961e048e787e853998caae7ffcd93da11d75", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 57, "deletions": 33, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -51,16 +51,14 @@ extern crate alloc;\n \n use libc::{c_int, c_void};\n use std::fmt;\n-use std::io::IoError;\n-use std::io;\n use std::mem;\n use std::ptr::null;\n use std::ptr;\n use std::rt::local::Local;\n use std::rt::rtio;\n+use std::rt::rtio::{IoResult, IoError};\n use std::rt::task::{BlockedTask, Task};\n use std::str::raw::from_c_str;\n-use std::str;\n use std::task;\n \n pub use self::async::AsyncWatcher;\n@@ -391,40 +389,39 @@ fn error_smoke_test() {\n     assert_eq!(err.to_str(), \"EOF: end of file\".to_string());\n }\n \n+#[cfg(unix)]\n pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n-    unsafe {\n-        // Importing error constants\n-\n-        // uv error descriptions are static\n-        let UvError(errcode) = uverr;\n-        let c_desc = uvll::uv_strerror(errcode);\n-        let desc = str::raw::c_str_to_static_slice(c_desc);\n-\n-        let kind = match errcode {\n-            uvll::UNKNOWN => io::OtherIoError,\n-            uvll::OK => io::OtherIoError,\n-            uvll::EOF => io::EndOfFile,\n-            uvll::EACCES => io::PermissionDenied,\n-            uvll::ECONNREFUSED => io::ConnectionRefused,\n-            uvll::ECONNRESET => io::ConnectionReset,\n-            uvll::ENOTCONN => io::NotConnected,\n-            uvll::ENOENT => io::FileNotFound,\n-            uvll::EPIPE => io::BrokenPipe,\n-            uvll::ECONNABORTED => io::ConnectionAborted,\n-            uvll::EADDRNOTAVAIL => io::ConnectionRefused,\n-            uvll::ECANCELED => io::TimedOut,\n+    let UvError(errcode) = uverr;\n+    IoError {\n+        code: if errcode == uvll::EOF {libc::EOF as uint} else {-errcode as uint},\n+        extra: 0,\n+        detail: Some(uverr.desc()),\n+    }\n+}\n+\n+#[cfg(windows)]\n+pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n+    let UvError(errcode) = uverr;\n+    IoError {\n+        code: match errcode {\n+            uvll::EOF => io::EOF,\n+            uvll::EACCES => io::ERROR_ACCESS_DENIED,\n+            uvll::ECONNREFUSED => io::WSAECONNREFUSED,\n+            uvll::ECONNRESET => io::WSAECONNRESET,\n+            uvll::ENOTCONN => io::WSAENOTCONN,\n+            uvll::ENOENT => io::ERROR_NOT_FOUND,\n+            uvll::EPIPE => io::ERROR_BROKEN_PIPE,\n+            uvll::ECONNABORTED => io::WSAECONNABORTED,\n+            uvll::EADDRNOTAVAIL => io::WSAEADDRNOTAVAIL,\n+            uvll::ECANCELED => libc::ERROR_OPERATION_ABORTED,\n             err => {\n                 uvdebug!(\"uverr.code {}\", err as int);\n                 // FIXME: Need to map remaining uv error types\n-                io::OtherIoError\n+                -1\n             }\n-        };\n-\n-        IoError {\n-            kind: kind,\n-            desc: desc,\n-            detail: None\n-        }\n+        },\n+        extra: 0,\n+        detail: Some(uverr.desc()),\n     }\n }\n \n@@ -437,7 +434,7 @@ pub fn status_to_maybe_uv_error(status: c_int) -> Option<UvError> {\n     }\n }\n \n-pub fn status_to_io_result(status: c_int) -> Result<(), IoError> {\n+pub fn status_to_io_result(status: c_int) -> IoResult<()> {\n     if status >= 0 {Ok(())} else {Err(uv_error_to_io_error(UvError(status)))}\n }\n \n@@ -471,6 +468,33 @@ fn local_loop() -> &'static mut uvio::UvIoFactory {\n     }\n }\n \n+#[cfg(test)]\n+fn next_test_ip4() -> std::rt::rtio::SocketAddr {\n+    use std::io;\n+    use std::rt::rtio;\n+\n+    let io::net::ip::SocketAddr { ip, port } = io::test::next_test_ip4();\n+    let ip = match ip {\n+        io::net::ip::Ipv4Addr(a, b, c, d) => rtio::Ipv4Addr(a, b, c, d),\n+        _ => unreachable!(),\n+    };\n+    rtio::SocketAddr { ip: ip, port: port }\n+}\n+\n+#[cfg(test)]\n+fn next_test_ip6() -> std::rt::rtio::SocketAddr {\n+    use std::io;\n+    use std::rt::rtio;\n+\n+    let io::net::ip::SocketAddr { ip, port } = io::test::next_test_ip6();\n+    let ip = match ip {\n+        io::net::ip::Ipv6Addr(a, b, c, d, e, f, g, h) =>\n+            rtio::Ipv6Addr(a, b, c, d, e, f, g, h),\n+        _ => unreachable!(),\n+    };\n+    rtio::SocketAddr { ip: ip, port: port }\n+}\n+\n #[cfg(test)]\n mod test {\n     use std::mem::transmute;"}, {"sha": "e7bdc25a1fd91d6bb07ea5021998f1ba52351ccd", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 74, "deletions": 77, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -10,12 +10,10 @@\n \n use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n use libc;\n-use std::io;\n-use std::io::IoError;\n-use std::io::net::ip;\n use std::mem;\n use std::ptr;\n use std::rt::rtio;\n+use std::rt::rtio::IoError;\n use std::rt::task::BlockedTask;\n \n use homing::{HomingIO, HomeHandle};\n@@ -36,7 +34,7 @@ pub fn htons(u: u16) -> u16 { mem::to_be16(u) }\n pub fn ntohs(u: u16) -> u16 { mem::from_be16(u) }\n \n pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n-                        len: uint) -> ip::SocketAddr {\n+                        len: uint) -> rtio::SocketAddr {\n     match storage.ss_family as c_int {\n         libc::AF_INET => {\n             assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n@@ -48,8 +46,8 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let b = (ip >> 16) as u8;\n             let c = (ip >>  8) as u8;\n             let d = (ip >>  0) as u8;\n-            ip::SocketAddr {\n-                ip: ip::Ipv4Addr(a, b, c, d),\n+            rtio::SocketAddr {\n+                ip: rtio::Ipv4Addr(a, b, c, d),\n                 port: ntohs(storage.sin_port),\n             }\n         }\n@@ -66,8 +64,8 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let f = ntohs(storage.sin6_addr.s6_addr[5]);\n             let g = ntohs(storage.sin6_addr.s6_addr[6]);\n             let h = ntohs(storage.sin6_addr.s6_addr[7]);\n-            ip::SocketAddr {\n-                ip: ip::Ipv6Addr(a, b, c, d, e, f, g, h),\n+            rtio::SocketAddr {\n+                ip: rtio::Ipv6Addr(a, b, c, d, e, f, g, h),\n                 port: ntohs(storage.sin6_port),\n             }\n         }\n@@ -77,11 +75,11 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n     }\n }\n \n-fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n+fn addr_to_sockaddr(addr: rtio::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     unsafe {\n         let mut storage: libc::sockaddr_storage = mem::zeroed();\n         let len = match addr.ip {\n-            ip::Ipv4Addr(a, b, c, d) => {\n+            rtio::Ipv4Addr(a, b, c, d) => {\n                 let ip = (a as u32 << 24) |\n                          (b as u32 << 16) |\n                          (c as u32 <<  8) |\n@@ -95,7 +93,7 @@ fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n                 };\n                 mem::size_of::<libc::sockaddr_in>()\n             }\n-            ip::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+            rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n                 let storage: &mut libc::sockaddr_in6 =\n                     mem::transmute(&mut storage);\n                 storage.sin6_family = libc::AF_INET6 as libc::sa_family_t;\n@@ -126,7 +124,7 @@ enum SocketNameKind {\n }\n \n fn socket_name(sk: SocketNameKind,\n-               handle: *c_void) -> Result<ip::SocketAddr, IoError> {\n+               handle: *c_void) -> Result<rtio::SocketAddr, IoError> {\n     let getsockname = match sk {\n         TcpPeer => uvll::uv_tcp_getpeername,\n         Tcp     => uvll::uv_tcp_getsockname,\n@@ -201,7 +199,7 @@ impl TcpWatcher {\n     }\n \n     pub fn connect(io: &mut UvIoFactory,\n-                   address: ip::SocketAddr,\n+                   address: rtio::SocketAddr,\n                    timeout: Option<u64>) -> Result<TcpWatcher, UvError> {\n         let tcp = TcpWatcher::new(io);\n         let cx = ConnectCtx { status: -1, task: None, timer: None };\n@@ -218,7 +216,7 @@ impl HomingIO for TcpWatcher {\n }\n \n impl rtio::RtioSocket for TcpWatcher {\n-    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(Tcp, self.handle)\n     }\n@@ -231,7 +229,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n \n         // see comments in close_read about this check\n         if guard.access.is_closed() {\n-            return Err(io::standard_error(io::EndOfFile))\n+            return Err(uv_error_to_io_error(UvError(uvll::EOF)))\n         }\n \n         self.stream.read(buf).map_err(uv_error_to_io_error)\n@@ -243,7 +241,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n         self.stream.write(buf, guard.can_timeout).map_err(uv_error_to_io_error)\n     }\n \n-    fn peer_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n+    fn peer_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(TcpPeer, self.handle)\n     }\n@@ -350,7 +348,7 @@ impl Drop for TcpWatcher {\n // TCP listeners (unbound servers)\n \n impl TcpListener {\n-    pub fn bind(io: &mut UvIoFactory, address: ip::SocketAddr)\n+    pub fn bind(io: &mut UvIoFactory, address: rtio::SocketAddr)\n                 -> Result<Box<TcpListener>, UvError> {\n         let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n         assert_eq!(unsafe {\n@@ -385,7 +383,7 @@ impl UvHandle<uvll::uv_tcp_t> for TcpListener {\n }\n \n impl rtio::RtioSocket for TcpListener {\n-    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(Tcp, self.handle)\n     }\n@@ -439,7 +437,7 @@ impl HomingIO for TcpAcceptor {\n }\n \n impl rtio::RtioSocket for TcpAcceptor {\n-    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(Tcp, self.listener.handle)\n     }\n@@ -492,7 +490,7 @@ pub struct UdpWatcher {\n struct UdpRecvCtx {\n     task: Option<BlockedTask>,\n     buf: Option<Buf>,\n-    result: Option<(ssize_t, Option<ip::SocketAddr>)>,\n+    result: Option<(ssize_t, Option<rtio::SocketAddr>)>,\n }\n \n struct UdpSendCtx {\n@@ -502,7 +500,7 @@ struct UdpSendCtx {\n }\n \n impl UdpWatcher {\n-    pub fn bind(io: &mut UvIoFactory, address: ip::SocketAddr)\n+    pub fn bind(io: &mut UvIoFactory, address: rtio::SocketAddr)\n                 -> Result<UdpWatcher, UvError> {\n         let udp = UdpWatcher {\n             handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n@@ -536,15 +534,15 @@ impl HomingIO for UdpWatcher {\n }\n \n impl rtio::RtioSocket for UdpWatcher {\n-    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(Udp, self.handle)\n     }\n }\n \n impl rtio::RtioUdpSocket for UdpWatcher {\n     fn recvfrom(&mut self, buf: &mut [u8])\n-        -> Result<(uint, ip::SocketAddr), IoError>\n+        -> Result<(uint, rtio::SocketAddr), IoError>\n     {\n         let loop_ = self.uv_loop();\n         let m = self.fire_homing_missile();\n@@ -609,7 +607,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         }\n     }\n \n-    fn sendto(&mut self, buf: &[u8], dst: ip::SocketAddr) -> Result<(), IoError> {\n+    fn sendto(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> Result<(), IoError> {\n         let m = self.fire_homing_missile();\n         let loop_ = self.uv_loop();\n         let guard = try!(self.write_access.grant(m));\n@@ -675,7 +673,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         }\n     }\n \n-    fn join_multicast(&mut self, multi: ip::IpAddr) -> Result<(), IoError> {\n+    fn join_multicast(&mut self, multi: rtio::IpAddr) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             multi.to_str().with_c_str(|m_addr| {\n@@ -686,7 +684,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         })\n     }\n \n-    fn leave_multicast(&mut self, multi: ip::IpAddr) -> Result<(), IoError> {\n+    fn leave_multicast(&mut self, multi: rtio::IpAddr) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             multi.to_str().with_c_str(|m_addr| {\n@@ -843,38 +841,37 @@ pub fn shutdown(handle: *uvll::uv_stream_t, loop_: &Loop) -> Result<(), IoError>\n mod test {\n     use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioTcpAcceptor,\n                         RtioUdpSocket};\n-    use std::io::test::{next_test_ip4, next_test_ip6};\n \n     use super::{UdpWatcher, TcpWatcher, TcpListener};\n     use super::super::local_loop;\n \n     #[test]\n     fn connect_close_ip4() {\n-        match TcpWatcher::connect(local_loop(), next_test_ip4(), None) {\n+        match TcpWatcher::connect(local_loop(), ::next_test_ip4(), None) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_string()),\n         }\n     }\n \n     #[test]\n     fn connect_close_ip6() {\n-        match TcpWatcher::connect(local_loop(), next_test_ip6(), None) {\n+        match TcpWatcher::connect(local_loop(), ::next_test_ip6(), None) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_string()),\n         }\n     }\n \n     #[test]\n     fn udp_bind_close_ip4() {\n-        match UdpWatcher::bind(local_loop(), next_test_ip4()) {\n+        match UdpWatcher::bind(local_loop(), ::next_test_ip4()) {\n             Ok(..) => {}\n             Err(..) => fail!()\n         }\n     }\n \n     #[test]\n     fn udp_bind_close_ip6() {\n-        match UdpWatcher::bind(local_loop(), next_test_ip6()) {\n+        match UdpWatcher::bind(local_loop(), ::next_test_ip6()) {\n             Ok(..) => {}\n             Err(..) => fail!()\n         }\n@@ -883,7 +880,7 @@ mod test {\n     #[test]\n     fn listen_ip4() {\n         let (tx, rx) = channel();\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n \n         spawn(proc() {\n             let w = match TcpListener::bind(local_loop(), addr) {\n@@ -919,7 +916,7 @@ mod test {\n     #[test]\n     fn listen_ip6() {\n         let (tx, rx) = channel();\n-        let addr = next_test_ip6();\n+        let addr = ::next_test_ip6();\n \n         spawn(proc() {\n             let w = match TcpListener::bind(local_loop(), addr) {\n@@ -955,16 +952,16 @@ mod test {\n     #[test]\n     fn udp_recv_ip4() {\n         let (tx, rx) = channel();\n-        let client = next_test_ip4();\n-        let server = next_test_ip4();\n+        let client = ::next_test_ip4();\n+        let server = ::next_test_ip4();\n \n         spawn(proc() {\n             match UdpWatcher::bind(local_loop(), server) {\n                 Ok(mut w) => {\n                     tx.send(());\n                     let mut buf = [0u8, ..10];\n                     match w.recvfrom(buf) {\n-                        Ok((10, addr)) => assert_eq!(addr, client),\n+                        Ok((10, addr)) => assert!(addr == client),\n                         e => fail!(\"{:?}\", e),\n                     }\n                     for i in range(0, 10u8) {\n@@ -987,16 +984,16 @@ mod test {\n     #[test]\n     fn udp_recv_ip6() {\n         let (tx, rx) = channel();\n-        let client = next_test_ip6();\n-        let server = next_test_ip6();\n+        let client = ::next_test_ip6();\n+        let server = ::next_test_ip6();\n \n         spawn(proc() {\n             match UdpWatcher::bind(local_loop(), server) {\n                 Ok(mut w) => {\n                     tx.send(());\n                     let mut buf = [0u8, ..10];\n                     match w.recvfrom(buf) {\n-                        Ok((10, addr)) => assert_eq!(addr, client),\n+                        Ok((10, addr)) => assert!(addr == client),\n                         e => fail!(\"{:?}\", e),\n                     }\n                     for i in range(0, 10u8) {\n@@ -1018,15 +1015,15 @@ mod test {\n \n     #[test]\n     fn test_read_read_read() {\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n         static MAX: uint = 5000;\n         let (tx, rx) = channel();\n \n         spawn(proc() {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut acceptor = listener.listen().unwrap();\n+            let mut acceptor = listener.listen().ok().unwrap();\n             tx.send(());\n-            let mut stream = acceptor.accept().unwrap();\n+            let mut stream = acceptor.accept().ok().unwrap();\n             let buf = [1, .. 2048];\n             let mut total_bytes_written = 0;\n             while total_bytes_written < MAX {\n@@ -1041,7 +1038,7 @@ mod test {\n         let mut buf = [0, .. 2048];\n         let mut total_bytes_read = 0;\n         while total_bytes_read < MAX {\n-            let nread = stream.read(buf).unwrap();\n+            let nread = stream.read(buf).ok().unwrap();\n             total_bytes_read += nread;\n             for i in range(0u, nread) {\n                 assert_eq!(buf[i], 1);\n@@ -1053,8 +1050,8 @@ mod test {\n     #[test]\n     #[ignore(cfg(windows))] // FIXME(#10102) server never sees second packet\n     fn test_udp_twice() {\n-        let server_addr = next_test_ip4();\n-        let client_addr = next_test_ip4();\n+        let server_addr = ::next_test_ip4();\n+        let client_addr = ::next_test_ip4();\n         let (tx, rx) = channel();\n \n         spawn(proc() {\n@@ -1068,22 +1065,22 @@ mod test {\n         tx.send(());\n         let mut buf1 = [0];\n         let mut buf2 = [0];\n-        let (nread1, src1) = server.recvfrom(buf1).unwrap();\n-        let (nread2, src2) = server.recvfrom(buf2).unwrap();\n+        let (nread1, src1) = server.recvfrom(buf1).ok().unwrap();\n+        let (nread2, src2) = server.recvfrom(buf2).ok().unwrap();\n         assert_eq!(nread1, 1);\n         assert_eq!(nread2, 1);\n-        assert_eq!(src1, client_addr);\n-        assert_eq!(src2, client_addr);\n+        assert!(src1 == client_addr);\n+        assert!(src2 == client_addr);\n         assert_eq!(buf1[0], 1);\n         assert_eq!(buf2[0], 2);\n     }\n \n     #[test]\n     fn test_udp_many_read() {\n-        let server_out_addr = next_test_ip4();\n-        let server_in_addr = next_test_ip4();\n-        let client_out_addr = next_test_ip4();\n-        let client_in_addr = next_test_ip4();\n+        let server_out_addr = ::next_test_ip4();\n+        let server_in_addr = ::next_test_ip4();\n+        let client_out_addr = ::next_test_ip4();\n+        let client_in_addr = ::next_test_ip4();\n         static MAX: uint = 500_000;\n \n         let (tx1, rx1) = channel::<()>();\n@@ -1106,9 +1103,9 @@ mod test {\n                 // check if the client has received enough\n                 let res = server_in.recvfrom(buf);\n                 assert!(res.is_ok());\n-                let (nread, src) = res.unwrap();\n+                let (nread, src) = res.ok().unwrap();\n                 assert_eq!(nread, 1);\n-                assert_eq!(src, client_out_addr);\n+                assert!(src == client_out_addr);\n             }\n             assert!(total_bytes_sent >= MAX);\n         });\n@@ -1127,8 +1124,8 @@ mod test {\n             // wait for data\n             let res = client_in.recvfrom(buf);\n             assert!(res.is_ok());\n-            let (nread, src) = res.unwrap();\n-            assert_eq!(src, server_out_addr);\n+            let (nread, src) = res.ok().unwrap();\n+            assert!(src == server_out_addr);\n             total_bytes_recv += nread;\n             for i in range(0u, nread) {\n                 assert_eq!(buf[i], 1);\n@@ -1140,33 +1137,33 @@ mod test {\n \n     #[test]\n     fn test_read_and_block() {\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n         let (tx, rx) = channel::<Receiver<()>>();\n \n         spawn(proc() {\n             let rx = rx.recv();\n             let mut stream = TcpWatcher::connect(local_loop(), addr, None).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n             rx.recv();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n             rx.recv();\n         });\n \n         let listener = TcpListener::bind(local_loop(), addr).unwrap();\n-        let mut acceptor = listener.listen().unwrap();\n+        let mut acceptor = listener.listen().ok().unwrap();\n         let (tx2, rx2) = channel();\n         tx.send(rx2);\n-        let mut stream = acceptor.accept().unwrap();\n+        let mut stream = acceptor.accept().ok().unwrap();\n         let mut buf = [0, .. 2048];\n \n         let expected = 32;\n         let mut current = 0;\n         let mut reads = 0;\n \n         while current < expected {\n-            let nread = stream.read(buf).unwrap();\n+            let nread = stream.read(buf).ok().unwrap();\n             for i in range(0u, nread) {\n                 let val = buf[i] as uint;\n                 assert_eq!(val, current % 8);\n@@ -1183,14 +1180,14 @@ mod test {\n \n     #[test]\n     fn test_simple_tcp_server_and_client_on_diff_threads() {\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n \n         spawn(proc() {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut acceptor = listener.listen().unwrap();\n-            let mut stream = acceptor.accept().unwrap();\n+            let mut acceptor = listener.listen().ok().unwrap();\n+            let mut stream = acceptor.accept().ok().unwrap();\n             let mut buf = [0, .. 2048];\n-            let nread = stream.read(buf).unwrap();\n+            let nread = stream.read(buf).ok().unwrap();\n             assert_eq!(nread, 8);\n             for i in range(0u, nread) {\n                 assert_eq!(buf[i], i as u8);\n@@ -1201,27 +1198,27 @@ mod test {\n         while stream.is_err() {\n             stream = TcpWatcher::connect(local_loop(), addr, None);\n         }\n-        stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n+        stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n     }\n \n     #[should_fail] #[test]\n     fn tcp_listener_fail_cleanup() {\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n         let w = TcpListener::bind(local_loop(), addr).unwrap();\n-        let _w = w.listen().unwrap();\n+        let _w = w.listen().ok().unwrap();\n         fail!();\n     }\n \n     #[should_fail] #[test]\n     fn tcp_stream_fail_cleanup() {\n         let (tx, rx) = channel();\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n \n         spawn(proc() {\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut w = w.listen().unwrap();\n+            let mut w = w.listen().ok().unwrap();\n             tx.send(());\n-            drop(w.accept().unwrap());\n+            drop(w.accept().ok().unwrap());\n         });\n         rx.recv();\n         let _w = TcpWatcher::connect(local_loop(), addr, None).unwrap();\n@@ -1230,14 +1227,14 @@ mod test {\n \n     #[should_fail] #[test]\n     fn udp_listener_fail_cleanup() {\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n         let _w = UdpWatcher::bind(local_loop(), addr).unwrap();\n         fail!();\n     }\n \n     #[should_fail] #[test]\n     fn udp_fail_other_task() {\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n         let (tx, rx) = channel();\n \n         // force the handle to be created on a different scheduler, failure in"}, {"sha": "e5c134b6b92687b7285f3b88935efd9158bbe104", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -10,10 +10,9 @@\n \n use libc;\n use std::c_str::CString;\n-use std::io::IoError;\n-use std::io;\n use std::mem;\n-use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n+use std::rt::rtio;\n+use std::rt::rtio::IoResult;\n use std::rt::task::BlockedTask;\n \n use homing::{HomingIO, HomeHandle};\n@@ -39,8 +38,8 @@ pub struct PipeWatcher {\n pub struct PipeListener {\n     home: HomeHandle,\n     pipe: *uvll::uv_pipe_t,\n-    outgoing: Sender<Result<Box<RtioPipe:Send>, IoError>>,\n-    incoming: Receiver<Result<Box<RtioPipe:Send>, IoError>>,\n+    outgoing: Sender<IoResult<Box<rtio::RtioPipe:Send>>>,\n+    incoming: Receiver<IoResult<Box<rtio::RtioPipe:Send>>>,\n }\n \n pub struct PipeAcceptor {\n@@ -111,37 +110,37 @@ impl PipeWatcher {\n     }\n }\n \n-impl RtioPipe for PipeWatcher {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+impl rtio::RtioPipe for PipeWatcher {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let m = self.fire_homing_missile();\n         let guard = try!(self.read_access.grant(m));\n \n         // see comments in close_read about this check\n         if guard.access.is_closed() {\n-            return Err(io::standard_error(io::EndOfFile))\n+            return Err(uv_error_to_io_error(UvError(uvll::EOF)))\n         }\n \n         self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let m = self.fire_homing_missile();\n         let guard = try!(self.write_access.grant(m));\n         self.stream.write(buf, guard.can_timeout).map_err(uv_error_to_io_error)\n     }\n \n-    fn clone(&self) -> Box<RtioPipe:Send> {\n+    fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n         box PipeWatcher {\n             stream: StreamWatcher::new(self.stream.handle),\n             defused: false,\n             home: self.home.clone(),\n             refcount: self.refcount.clone(),\n             read_access: self.read_access.clone(),\n             write_access: self.write_access.clone(),\n-        } as Box<RtioPipe:Send>\n+        } as Box<rtio::RtioPipe:Send>\n     }\n \n-    fn close_read(&mut self) -> Result<(), IoError> {\n+    fn close_read(&mut self) -> IoResult<()> {\n         // The current uv_shutdown method only shuts the writing half of the\n         // connection, and no method is provided to shut down the reading half\n         // of the connection. With a lack of method, we emulate shutting down\n@@ -168,7 +167,7 @@ impl RtioPipe for PipeWatcher {\n         Ok(())\n     }\n \n-    fn close_write(&mut self) -> Result<(), IoError> {\n+    fn close_write(&mut self) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         net::shutdown(self.stream.handle, &self.uv_loop())\n     }\n@@ -248,8 +247,8 @@ impl PipeListener {\n     }\n }\n \n-impl RtioUnixListener for PipeListener {\n-    fn listen(~self) -> Result<Box<RtioUnixAcceptor:Send>, IoError> {\n+impl rtio::RtioUnixListener for PipeListener {\n+    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor:Send>> {\n         // create the acceptor object from ourselves\n         let mut acceptor = box PipeAcceptor {\n             listener: self,\n@@ -259,7 +258,7 @@ impl RtioUnixListener for PipeListener {\n         let _m = acceptor.fire_homing_missile();\n         // FIXME: the 128 backlog should be configurable\n         match unsafe { uvll::uv_listen(acceptor.listener.pipe, 128, listen_cb) } {\n-            0 => Ok(acceptor as Box<RtioUnixAcceptor:Send>),\n+            0 => Ok(acceptor as Box<rtio::RtioUnixAcceptor:Send>),\n             n => Err(uv_error_to_io_error(UvError(n))),\n         }\n     }\n@@ -284,7 +283,7 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n             });\n             let client = PipeWatcher::new_home(&loop_, pipe.home().clone(), false);\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle()) }, 0);\n-            Ok(box client as Box<RtioPipe:Send>)\n+            Ok(box client as Box<rtio::RtioPipe:Send>)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n@@ -300,8 +299,8 @@ impl Drop for PipeListener {\n \n // PipeAcceptor implementation and traits\n \n-impl RtioUnixAcceptor for PipeAcceptor {\n-    fn accept(&mut self) -> Result<Box<RtioPipe:Send>, IoError> {\n+impl rtio::RtioUnixAcceptor for PipeAcceptor {\n+    fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe:Send>> {\n         self.timeout.accept(&self.listener.incoming)\n     }\n \n@@ -366,19 +365,19 @@ mod tests {\n \n         spawn(proc() {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n-            let mut p = p.listen().unwrap();\n+            let mut p = p.listen().ok().unwrap();\n             tx.send(());\n-            let mut client = p.accept().unwrap();\n+            let mut client = p.accept().ok().unwrap();\n             let mut buf = [0];\n-            assert!(client.read(buf).unwrap() == 1);\n+            assert!(client.read(buf).ok().unwrap() == 1);\n             assert_eq!(buf[0], 1);\n             assert!(client.write([2]).is_ok());\n         });\n         rx.recv();\n         let mut c = PipeWatcher::connect(local_loop(), &path.to_c_str(), None).unwrap();\n         assert!(c.write([1]).is_ok());\n         let mut buf = [0];\n-        assert!(c.read(buf).unwrap() == 1);\n+        assert!(c.read(buf).ok().unwrap() == 1);\n         assert_eq!(buf[0], 2);\n     }\n \n@@ -390,9 +389,9 @@ mod tests {\n \n         spawn(proc() {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n-            let mut p = p.listen().unwrap();\n+            let mut p = p.listen().ok().unwrap();\n             tx.send(());\n-            drop(p.accept().unwrap());\n+            drop(p.accept().ok().unwrap());\n         });\n         rx.recv();\n         let _c = PipeWatcher::connect(local_loop(), &path.to_c_str(), None).unwrap();"}, {"sha": "aa87582da26d87bca60dd1c7f42b06f935cb06c6", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -10,11 +10,10 @@\n \n use libc::c_int;\n use libc;\n-use std::io::IoError;\n-use std::io::process;\n use std::ptr;\n use std::c_str::CString;\n-use std::rt::rtio::{ProcessConfig, RtioProcess};\n+use std::rt::rtio;\n+use std::rt::rtio::IoResult;\n use std::rt::task::BlockedTask;\n \n use homing::{HomingIO, HomeHandle};\n@@ -33,7 +32,7 @@ pub struct Process {\n     to_wake: Option<BlockedTask>,\n \n     /// Collected from the exit_cb\n-    exit_status: Option<process::ProcessExit>,\n+    exit_status: Option<rtio::ProcessExit>,\n \n     /// Lazily initialized timeout timer\n     timer: Option<Box<TimerWatcher>>,\n@@ -51,7 +50,7 @@ impl Process {\n     ///\n     /// Returns either the corresponding process object or an error which\n     /// occurred.\n-    pub fn spawn(io_loop: &mut UvIoFactory, cfg: ProcessConfig)\n+    pub fn spawn(io_loop: &mut UvIoFactory, cfg: rtio::ProcessConfig)\n                 -> Result<(Box<Process>, Vec<Option<PipeWatcher>>), UvError> {\n         let mut io = vec![cfg.stdin, cfg.stdout, cfg.stderr];\n         for slot in cfg.extra_io.iter() {\n@@ -137,28 +136,28 @@ extern fn on_exit(handle: *uvll::uv_process_t,\n \n     assert!(p.exit_status.is_none());\n     p.exit_status = Some(match term_signal {\n-        0 => process::ExitStatus(exit_status as int),\n-        n => process::ExitSignal(n as int),\n+        0 => rtio::ExitStatus(exit_status as int),\n+        n => rtio::ExitSignal(n as int),\n     });\n \n     if p.to_wake.is_none() { return }\n     wakeup(&mut p.to_wake);\n }\n \n unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n-                    io: &process::StdioContainer,\n+                    io: &rtio::StdioContainer,\n                     io_loop: &mut UvIoFactory) -> Option<PipeWatcher> {\n     match *io {\n-        process::Ignored => {\n+        rtio::Ignored => {\n             uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE);\n             None\n         }\n-        process::InheritFd(fd) => {\n+        rtio::InheritFd(fd) => {\n             uvll::set_stdio_container_flags(dst, uvll::STDIO_INHERIT_FD);\n             uvll::set_stdio_container_fd(dst, fd);\n             None\n         }\n-        process::CreatePipe(readable, writable) => {\n+        rtio::CreatePipe(readable, writable) => {\n             let mut flags = uvll::STDIO_CREATE_PIPE as libc::c_int;\n             if readable {\n                 flags |= uvll::STDIO_READABLE_PIPE as libc::c_int;\n@@ -231,12 +230,12 @@ impl UvHandle<uvll::uv_process_t> for Process {\n     fn uv_handle(&self) -> *uvll::uv_process_t { self.handle }\n }\n \n-impl RtioProcess for Process {\n+impl rtio::RtioProcess for Process {\n     fn id(&self) -> libc::pid_t {\n         unsafe { uvll::process_pid(self.handle) as libc::pid_t }\n     }\n \n-    fn kill(&mut self, signal: int) -> Result<(), IoError> {\n+    fn kill(&mut self, signal: int) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         match unsafe {\n             uvll::uv_process_kill(self.handle, signal as libc::c_int)\n@@ -246,7 +245,7 @@ impl RtioProcess for Process {\n         }\n     }\n \n-    fn wait(&mut self) -> Result<process::ProcessExit, IoError> {\n+    fn wait(&mut self) -> IoResult<rtio::ProcessExit> {\n         // Make sure (on the home scheduler) that we have an exit status listed\n         let _m = self.fire_homing_missile();\n         match self.exit_status {"}, {"sha": "a3694bfe9c2beed46199f5a7f825f48fa636b994", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -23,8 +23,8 @@\n use alloc::arc::Arc;\n use libc::c_void;\n use std::mem;\n+use std::rt::mutex::NativeMutex;\n use std::rt::task::BlockedTask;\n-use std::unstable::mutex::NativeMutex;\n use mpsc = std::sync::mpsc_queue;\n \n use async::AsyncWatcher;"}, {"sha": "fd0b6acb8ae746ecef398637aeae07240f4faceb", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use libc::c_int;\n-use std::io::signal::Signum;\n-use std::rt::rtio::RtioSignal;\n+use std::rt::rtio::{RtioSignal, Callback};\n \n use homing::{HomingIO, HomeHandle};\n use super::{UvError, UvHandle};\n@@ -21,18 +20,16 @@ pub struct SignalWatcher {\n     handle: *uvll::uv_signal_t,\n     home: HomeHandle,\n \n-    channel: Sender<Signum>,\n-    signal: Signum,\n+    cb: Box<Callback:Send>,\n }\n \n impl SignalWatcher {\n-    pub fn new(io: &mut UvIoFactory, signum: Signum, channel: Sender<Signum>)\n+    pub fn new(io: &mut UvIoFactory, signum: int, cb: Box<Callback:Send>)\n                -> Result<Box<SignalWatcher>, UvError> {\n         let s = box SignalWatcher {\n             handle: UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL),\n             home: io.make_handle(),\n-            channel: channel,\n-            signal: signum,\n+            cb: cb,\n         };\n         assert_eq!(unsafe {\n             uvll::uv_signal_init(io.uv_loop(), s.handle)\n@@ -48,10 +45,9 @@ impl SignalWatcher {\n     }\n }\n \n-extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n+extern fn signal_cb(handle: *uvll::uv_signal_t, _signum: c_int) {\n     let s: &mut SignalWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n-    assert_eq!(signum as int, s.signal as int);\n-    let _ = s.channel.send_opt(s.signal);\n+    let _ = s.cb.call();\n }\n \n impl HomingIO for SignalWatcher {\n@@ -70,25 +66,3 @@ impl Drop for SignalWatcher {\n         self.close();\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::super::local_loop;\n-    use std::io::signal;\n-    use super::SignalWatcher;\n-\n-    #[test]\n-    fn closing_channel_during_drop_doesnt_kill_everything() {\n-        // see issue #10375, relates to timers as well.\n-        let (tx, rx) = channel();\n-        let _signal = SignalWatcher::new(local_loop(), signal::Interrupt,\n-                                         tx);\n-\n-        spawn(proc() {\n-            let _ = rx.recv_opt();\n-        });\n-\n-        // when we drop the SignalWatcher we're going to destroy the channel,\n-        // which must wake up the task on the other end\n-    }\n-}"}, {"sha": "1c191d476edb9efa27750192bb823d1ea654cc89", "filename": "src/librustuv/timeout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use libc::c_int;\n-use std::io::IoResult;\n use std::mem;\n use std::rt::task::BlockedTask;\n+use std::rt::rtio::IoResult;\n \n use access;\n use homing::{HomeHandle, HomingMissile, HomingIO};"}, {"sha": "b940774323a2a57dae027e26afaf0fa07da7cfb0", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 11, "deletions": 161, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::mem;\n-use std::rt::rtio::RtioTimer;\n+use std::rt::rtio::{RtioTimer, Callback};\n use std::rt::task::BlockedTask;\n \n use homing::{HomeHandle, HomingIO};\n@@ -27,8 +27,8 @@ pub struct TimerWatcher {\n \n pub enum NextAction {\n     WakeTask,\n-    SendOnce(Sender<()>),\n-    SendMany(Sender<()>, uint),\n+    CallOnce(Box<Callback:Send>),\n+    CallMany(Box<Callback:Send>, uint),\n }\n \n impl TimerWatcher {\n@@ -103,36 +103,28 @@ impl RtioTimer for TimerWatcher {\n         self.stop();\n     }\n \n-    fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n-        let (tx, rx) = channel();\n-\n+    fn oneshot(&mut self, msecs: u64, cb: Box<Callback:Send>) {\n         // similarly to the destructor, we must drop the previous action outside\n         // of the homing missile\n         let _prev_action = {\n             let _m = self.fire_homing_missile();\n             self.id += 1;\n             self.stop();\n             self.start(timer_cb, msecs, 0);\n-            mem::replace(&mut self.action, Some(SendOnce(tx)))\n+            mem::replace(&mut self.action, Some(CallOnce(cb)))\n         };\n-\n-        return rx;\n     }\n \n-    fn period(&mut self, msecs: u64) -> Receiver<()> {\n-        let (tx, rx) = channel();\n-\n+    fn period(&mut self, msecs: u64, cb: Box<Callback:Send>) {\n         // similarly to the destructor, we must drop the previous action outside\n         // of the homing missile\n         let _prev_action = {\n             let _m = self.fire_homing_missile();\n             self.id += 1;\n             self.stop();\n             self.start(timer_cb, msecs, msecs);\n-            mem::replace(&mut self.action, Some(SendMany(tx, self.id)))\n+            mem::replace(&mut self.action, Some(CallMany(cb, self.id)))\n         };\n-\n-        return rx;\n     }\n }\n \n@@ -145,9 +137,9 @@ extern fn timer_cb(handle: *uvll::uv_timer_t) {\n             let task = timer.blocker.take_unwrap();\n             let _ = task.wake().map(|t| t.reawaken());\n         }\n-        SendOnce(chan) => { let _ = chan.send_opt(()); }\n-        SendMany(chan, id) => {\n-            let _ = chan.send_opt(());\n+        CallOnce(mut cb) => { cb.call() }\n+        CallMany(mut cb, id) => {\n+            cb.call();\n \n             // Note that the above operation could have performed some form of\n             // scheduling. This means that the timer may have decided to insert\n@@ -158,7 +150,7 @@ extern fn timer_cb(handle: *uvll::uv_timer_t) {\n             // for you. We're guaranteed to all be running on the same thread,\n             // so there's no need for any synchronization here.\n             if timer.id == id {\n-                timer.action = Some(SendMany(chan, id));\n+                timer.action = Some(CallMany(cb, id));\n             }\n         }\n     }\n@@ -179,145 +171,3 @@ impl Drop for TimerWatcher {\n         };\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use std::rt::rtio::RtioTimer;\n-    use super::super::local_loop;\n-    use super::TimerWatcher;\n-\n-    #[test]\n-    fn oneshot() {\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let port = timer.oneshot(1);\n-        port.recv();\n-        let port = timer.oneshot(1);\n-        port.recv();\n-    }\n-\n-    #[test]\n-    fn override() {\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let oport = timer.oneshot(1);\n-        let pport = timer.period(1);\n-        timer.sleep(1);\n-        assert_eq!(oport.recv_opt(), Err(()));\n-        assert_eq!(pport.recv_opt(), Err(()));\n-        timer.oneshot(1).recv();\n-    }\n-\n-    #[test]\n-    fn period() {\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let port = timer.period(1);\n-        port.recv();\n-        port.recv();\n-        let port2 = timer.period(1);\n-        port2.recv();\n-        port2.recv();\n-    }\n-\n-    #[test]\n-    fn sleep() {\n-        let mut timer = TimerWatcher::new(local_loop());\n-        timer.sleep(1);\n-        timer.sleep(1);\n-    }\n-\n-    #[test] #[should_fail]\n-    fn oneshot_fail() {\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let _port = timer.oneshot(1);\n-        fail!();\n-    }\n-\n-    #[test] #[should_fail]\n-    fn period_fail() {\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let _port = timer.period(1);\n-        fail!();\n-    }\n-\n-    #[test] #[should_fail]\n-    fn normal_fail() {\n-        let _timer = TimerWatcher::new(local_loop());\n-        fail!();\n-    }\n-\n-    #[test]\n-    fn closing_channel_during_drop_doesnt_kill_everything() {\n-        // see issue #10375\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let timer_port = timer.period(1000);\n-\n-        spawn(proc() {\n-            let _ = timer_port.recv_opt();\n-        });\n-\n-        // when we drop the TimerWatcher we're going to destroy the channel,\n-        // which must wake up the task on the other end\n-    }\n-\n-    #[test]\n-    fn reset_doesnt_switch_tasks() {\n-        // similar test to the one above.\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let timer_port = timer.period(1000);\n-\n-        spawn(proc() {\n-            let _ = timer_port.recv_opt();\n-        });\n-\n-        drop(timer.oneshot(1));\n-    }\n-    #[test]\n-    fn reset_doesnt_switch_tasks2() {\n-        // similar test to the one above.\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let timer_port = timer.period(1000);\n-\n-        spawn(proc() {\n-            let _ = timer_port.recv_opt();\n-        });\n-\n-        timer.sleep(1);\n-    }\n-\n-    #[test]\n-    fn sender_goes_away_oneshot() {\n-        let port = {\n-            let mut timer = TimerWatcher::new(local_loop());\n-            timer.oneshot(1000)\n-        };\n-        assert_eq!(port.recv_opt(), Err(()));\n-    }\n-\n-    #[test]\n-    fn sender_goes_away_period() {\n-        let port = {\n-            let mut timer = TimerWatcher::new(local_loop());\n-            timer.period(1000)\n-        };\n-        assert_eq!(port.recv_opt(), Err(()));\n-    }\n-\n-    #[test]\n-    fn receiver_goes_away_oneshot() {\n-        let mut timer1 = TimerWatcher::new(local_loop());\n-        drop(timer1.oneshot(1));\n-        let mut timer2 = TimerWatcher::new(local_loop());\n-        // while sleeping, the prevous timer should fire and not have its\n-        // callback do something terrible.\n-        timer2.sleep(2);\n-    }\n-\n-    #[test]\n-    fn receiver_goes_away_period() {\n-        let mut timer1 = TimerWatcher::new(local_loop());\n-        drop(timer1.period(1));\n-        let mut timer2 = TimerWatcher::new(local_loop());\n-        // while sleeping, the prevous timer should fire and not have its\n-        // callback do something terrible.\n-        timer2.sleep(2);\n-    }\n-}"}, {"sha": "828a3d0c63b0aaea2109647706b625e2723e9cfb", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n use libc;\n-use std::io::IoError;\n use std::ptr;\n-use std::rt::rtio::RtioTTY;\n+use std::rt::rtio::{RtioTTY, IoResult};\n \n use homing::{HomingIO, HomeHandle};\n use stream::StreamWatcher;\n@@ -80,17 +79,17 @@ impl TtyWatcher {\n }\n \n impl RtioTTY for TtyWatcher {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let _m = self.fire_homing_missile();\n         self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         self.stream.write(buf, false).map_err(uv_error_to_io_error)\n     }\n \n-    fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {\n+    fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n         let raw = raw as libc::c_int;\n         let _m = self.fire_homing_missile();\n         match unsafe { uvll::uv_tty_set_mode(self.tty, raw) } {\n@@ -100,7 +99,7 @@ impl RtioTTY for TtyWatcher {\n     }\n \n     #[allow(unused_mut)]\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n         let mut width: libc::c_int = 0;\n         let mut height: libc::c_int = 0;\n         let widthptr: *libc::c_int = &width;"}, {"sha": "cf2a2d73d4d9f11e2b7e2efda60db9366a7e44c3", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 50, "deletions": 54, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=550c347d7b9fbeb10dcf039f0e7e0c16de83dc4a", "patch": "@@ -11,20 +11,13 @@\n //! The implementation of `rtio` for libuv\n \n use std::c_str::CString;\n-use std::io::IoError;\n-use std::io::net::ip::SocketAddr;\n-use std::io::signal::Signum;\n-use std::io::{FileMode, FileAccess, Open, Append, Truncate, Read, Write,\n-              ReadWrite, FileStat};\n-use std::io;\n use std::mem;\n use libc::c_int;\n use libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY, S_IRUSR,\n                 S_IWUSR};\n use libc;\n use std::rt::rtio;\n-use std::rt::rtio::{ProcessConfig, IoFactory, EventLoop};\n-use ai = std::io::net::addrinfo;\n+use std::rt::rtio::{ProcessConfig, IoFactory, EventLoop, IoResult};\n \n #[cfg(test)] use std::rt::thread::Thread;\n \n@@ -147,36 +140,38 @@ impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n-    fn tcp_connect(&mut self, addr: SocketAddr, timeout: Option<u64>)\n-                   -> Result<Box<rtio::RtioTcpStream:Send>, IoError> {\n+    fn tcp_connect(&mut self, addr: rtio::SocketAddr, timeout: Option<u64>)\n+                   -> IoResult<Box<rtio::RtioTcpStream:Send>> {\n         match TcpWatcher::connect(self, addr, timeout) {\n             Ok(t) => Ok(box t as Box<rtio::RtioTcpStream:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn tcp_bind(&mut self, addr: SocketAddr)\n-                -> Result<Box<rtio::RtioTcpListener:Send>, IoError> {\n+    fn tcp_bind(&mut self, addr: rtio::SocketAddr)\n+                -> IoResult<Box<rtio::RtioTcpListener:Send>> {\n         match TcpListener::bind(self, addr) {\n             Ok(t) => Ok(t as Box<rtio::RtioTcpListener:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn udp_bind(&mut self, addr: SocketAddr)\n-                -> Result<Box<rtio::RtioUdpSocket:Send>, IoError> {\n+    fn udp_bind(&mut self, addr: rtio::SocketAddr)\n+                -> IoResult<Box<rtio::RtioUdpSocket:Send>> {\n         match UdpWatcher::bind(self, addr) {\n             Ok(u) => Ok(box u as Box<rtio::RtioUdpSocket:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn timer_init(&mut self) -> Result<Box<rtio::RtioTimer:Send>, IoError> {\n+    fn timer_init(&mut self) -> IoResult<Box<rtio::RtioTimer:Send>> {\n         Ok(TimerWatcher::new(self) as Box<rtio::RtioTimer:Send>)\n     }\n \n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> Result<Vec<ai::Info>, IoError> {\n+                          hint: Option<rtio::AddrinfoHint>)\n+        -> IoResult<Vec<rtio::AddrinfoInfo>>\n+    {\n         let r = GetAddrInfoRequest::run(&self.loop_, host, servname, hint);\n         r.map_err(uv_error_to_io_error)\n     }\n@@ -187,20 +182,22 @@ impl IoFactory for UvIoFactory {\n             Box<rtio::RtioFileStream:Send>\n     }\n \n-    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n-               -> Result<Box<rtio::RtioFileStream:Send>, IoError> {\n+    fn fs_open(&mut self, path: &CString, fm: rtio::FileMode,\n+               fa: rtio::FileAccess)\n+        -> IoResult<Box<rtio::RtioFileStream:Send>>\n+    {\n         let flags = match fm {\n-            io::Open => 0,\n-            io::Append => libc::O_APPEND,\n-            io::Truncate => libc::O_TRUNC,\n+            rtio::Open => 0,\n+            rtio::Append => libc::O_APPEND,\n+            rtio::Truncate => libc::O_TRUNC,\n         };\n         // Opening with a write permission must silently create the file.\n         let (flags, mode) = match fa {\n-            io::Read => (flags | libc::O_RDONLY, 0),\n-            io::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n-                          libc::S_IRUSR | libc::S_IWUSR),\n-            io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n-                              libc::S_IRUSR | libc::S_IWUSR),\n+            rtio::Read => (flags | libc::O_RDONLY, 0),\n+            rtio::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n+                            libc::S_IRUSR | libc::S_IWUSR),\n+            rtio::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n+                                libc::S_IRUSR | libc::S_IWUSR),\n         };\n \n         match FsRequest::open(self, path, flags as int, mode as int) {\n@@ -209,69 +206,66 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError> {\n+    fn fs_unlink(&mut self, path: &CString) -> IoResult<()> {\n         let r = FsRequest::unlink(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_lstat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n+    fn fs_lstat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n         let r = FsRequest::lstat(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n+    fn fs_stat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n         let r = FsRequest::stat(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_mkdir(&mut self, path: &CString,\n-                perm: io::FilePermission) -> Result<(), IoError> {\n-        let r = FsRequest::mkdir(&self.loop_, path, perm.bits() as c_int);\n+    fn fs_mkdir(&mut self, path: &CString, perm: uint) -> IoResult<()> {\n+        let r = FsRequest::mkdir(&self.loop_, path, perm as c_int);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError> {\n+    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()> {\n         let r = FsRequest::rmdir(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError> {\n+    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()> {\n         let r = FsRequest::rename(&self.loop_, path, to);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_chmod(&mut self, path: &CString,\n-                perm: io::FilePermission) -> Result<(), IoError> {\n-        let r = FsRequest::chmod(&self.loop_, path, perm.bits() as c_int);\n+    fn fs_chmod(&mut self, path: &CString, perm: uint) -> IoResult<()> {\n+        let r = FsRequest::chmod(&self.loop_, path, perm as c_int);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_readdir(&mut self, path: &CString, flags: c_int)\n-        -> Result<Vec<CString>, IoError>\n+        -> IoResult<Vec<CString>>\n     {\n         let r = FsRequest::readdir(&self.loop_, path, flags);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_link(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n+    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n         let r = FsRequest::link(&self.loop_, src, dst);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n+    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n         let r = FsRequest::symlink(&self.loop_, src, dst);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> Result<(), IoError> {\n+    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> IoResult<()> {\n         let r = FsRequest::chown(&self.loop_, path, uid, gid);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_readlink(&mut self, path: &CString) -> Result<CString, IoError> {\n+    fn fs_readlink(&mut self, path: &CString) -> IoResult<CString> {\n         let r = FsRequest::readlink(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_utime(&mut self, path: &CString, atime: u64, mtime: u64)\n-        -> Result<(), IoError>\n+        -> IoResult<()>\n     {\n         let r = FsRequest::utime(&self.loop_, path, atime, mtime);\n         r.map_err(uv_error_to_io_error)\n     }\n \n     fn spawn(&mut self, cfg: ProcessConfig)\n-            -> Result<(Box<rtio::RtioProcess:Send>,\n-                       Vec<Option<Box<rtio::RtioPipe:Send>>>),\n-                      IoError>\n+            -> IoResult<(Box<rtio::RtioProcess:Send>,\n+                         Vec<Option<Box<rtio::RtioPipe:Send>>>)>\n     {\n         match Process::spawn(self, cfg) {\n             Ok((p, io)) => {\n@@ -284,45 +278,47 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn kill(&mut self, pid: libc::pid_t, signum: int) -> Result<(), IoError> {\n+    fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> {\n         Process::kill(pid, signum).map_err(uv_error_to_io_error)\n     }\n \n     fn unix_bind(&mut self, path: &CString)\n-                 -> Result<Box<rtio::RtioUnixListener:Send>, IoError> {\n+                 -> IoResult<Box<rtio::RtioUnixListener:Send>> {\n         match PipeListener::bind(self, path) {\n             Ok(p) => Ok(p as Box<rtio::RtioUnixListener:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n     fn unix_connect(&mut self, path: &CString, timeout: Option<u64>)\n-                    -> Result<Box<rtio::RtioPipe:Send>, IoError> {\n+                    -> IoResult<Box<rtio::RtioPipe:Send>> {\n         match PipeWatcher::connect(self, path, timeout) {\n             Ok(p) => Ok(box p as Box<rtio::RtioPipe:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n     fn tty_open(&mut self, fd: c_int, readable: bool)\n-            -> Result<Box<rtio::RtioTTY:Send>, IoError> {\n+            -> IoResult<Box<rtio::RtioTTY:Send>> {\n         match TtyWatcher::new(self, fd, readable) {\n             Ok(tty) => Ok(box tty as Box<rtio::RtioTTY:Send>),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n     fn pipe_open(&mut self, fd: c_int)\n-                 -> Result<Box<rtio::RtioPipe:Send>, IoError> {\n+        -> IoResult<Box<rtio::RtioPipe:Send>>\n+    {\n         match PipeWatcher::open(self, fd) {\n             Ok(s) => Ok(box s as Box<rtio::RtioPipe:Send>),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n-    fn signal(&mut self, signum: Signum, channel: Sender<Signum>)\n-        -> Result<Box<rtio::RtioSignal:Send>, IoError> {\n-        match SignalWatcher::new(self, signum, channel) {\n+    fn signal(&mut self, signum: int, cb: Box<rtio::Callback:Send>)\n+        -> IoResult<Box<rtio::RtioSignal:Send>>\n+    {\n+        match SignalWatcher::new(self, signum, cb) {\n             Ok(s) => Ok(s as Box<rtio::RtioSignal:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }"}]}