{"sha": "caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZWQ4MGJhNGJhOGQ5ZjRkM2ZhOGFhOWFmNmM0MDkyZDc3OWNkOWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-26T09:41:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-26T09:41:28Z"}, "message": "Auto merge of #53629 - nnethercote:lazier-SparseBitMatrix, r=nikomatsakis\n\nLazier sparse bit matrix\n\nA small NLL win.\n\nr? @nikomatsakis", "tree": {"sha": "666c2e90cb0c69ba5f0312ca6da6d68fba6cc5b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/666c2e90cb0c69ba5f0312ca6da6d68fba6cc5b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d", "html_url": "https://github.com/rust-lang/rust/commit/caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ede55518431154bc761f7b2438cce9078c162700", "url": "https://api.github.com/repos/rust-lang/rust/commits/ede55518431154bc761f7b2438cce9078c162700", "html_url": "https://github.com/rust-lang/rust/commit/ede55518431154bc761f7b2438cce9078c162700"}, {"sha": "002f03b654845667023cdaad8af988909a030bfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/002f03b654845667023cdaad8af988909a030bfe", "html_url": "https://github.com/rust-lang/rust/commit/002f03b654845667023cdaad8af988909a030bfe"}], "stats": {"total": 72, "additions": 38, "deletions": 34}, "files": [{"sha": "642d24f48313a26cb76f4880863c115f713f8829", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d", "patch": "@@ -318,48 +318,57 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     }\n }\n \n-/// A moderately sparse bit matrix: rows are appended lazily, but columns\n-/// within appended rows are instantiated fully upon creation.\n+/// A moderately sparse bit matrix, in which rows are instantiated lazily.\n+///\n+/// Initially, every row has no explicit representation. If any bit within a\n+/// row is set, the entire row is instantiated as\n+/// `Some(<full-column-width-BitArray>)`. Furthermore, any previously\n+/// uninstantiated rows prior to it will be instantiated as `None`. Those prior\n+/// rows may themselves become fully instantiated later on if any of their bits\n+/// are set.\n #[derive(Clone, Debug)]\n pub struct SparseBitMatrix<R, C>\n where\n     R: Idx,\n     C: Idx,\n {\n-    columns: usize,\n-    vector: IndexVec<R, BitArray<C>>,\n+    num_columns: usize,\n+    rows: IndexVec<R, Option<BitArray<C>>>,\n }\n \n impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// Create a new empty sparse bit matrix with no rows or columns.\n-    pub fn new(columns: usize) -> Self {\n+    pub fn new(num_columns: usize) -> Self {\n         Self {\n-            columns,\n-            vector: IndexVec::new(),\n+            num_columns,\n+            rows: IndexVec::new(),\n         }\n     }\n \n-    fn ensure_row(&mut self, row: R) {\n-        let columns = self.columns;\n-        self.vector\n-            .ensure_contains_elem(row, || BitArray::new(columns));\n+    fn ensure_row(&mut self, row: R) -> &mut BitArray<C> {\n+        // Instantiate any missing rows up to and including row `row` with an\n+        // empty BitArray.\n+        self.rows.ensure_contains_elem(row, || None);\n+\n+        // Then replace row `row` with a full BitArray if necessary.\n+        let num_columns = self.num_columns;\n+        self.rows[row].get_or_insert_with(|| BitArray::new(num_columns))\n     }\n \n     /// Sets the cell at `(row, column)` to true. Put another way, insert\n     /// `column` to the bitset for `row`.\n     ///\n     /// Returns true if this changed the matrix, and false otherwise.\n     pub fn add(&mut self, row: R, column: C) -> bool {\n-        self.ensure_row(row);\n-        self.vector[row].insert(column)\n+        self.ensure_row(row).insert(column)\n     }\n \n     /// Do the bits from `row` contain `column`? Put another way, is\n     /// the matrix cell at `(row, column)` true?  Put yet another way,\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n     pub fn contains(&self, row: R, column: C) -> bool {\n-        self.vector.get(row).map_or(false, |r| r.contains(column))\n+        self.row(row).map_or(false, |r| r.contains(column))\n     }\n \n     /// Add the bits from row `read` to the bits from row `write`,\n@@ -370,49 +379,44 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// `write` can reach everything that `read` can (and\n     /// potentially more).\n     pub fn merge(&mut self, read: R, write: R) -> bool {\n-        if read == write || self.vector.get(read).is_none() {\n+        if read == write || self.row(read).is_none() {\n             return false;\n         }\n \n         self.ensure_row(write);\n-        let (bitvec_read, bitvec_write) = self.vector.pick2_mut(read, write);\n-        bitvec_write.merge(bitvec_read)\n+        if let (Some(bitvec_read), Some(bitvec_write)) = self.rows.pick2_mut(read, write) {\n+            bitvec_write.merge(bitvec_read)\n+        } else {\n+            unreachable!()\n+        }\n     }\n \n     /// Merge a row, `from`, into the `into` row.\n     pub fn merge_into(&mut self, into: R, from: &BitArray<C>) -> bool {\n-        self.ensure_row(into);\n-        self.vector[into].merge(from)\n+        self.ensure_row(into).merge(from)\n     }\n \n     /// Add all bits to the given row.\n     pub fn add_all(&mut self, row: R) {\n-        self.ensure_row(row);\n-        self.vector[row].insert_all();\n-    }\n-\n-    /// Number of elements in the matrix.\n-    pub fn len(&self) -> usize {\n-        self.vector.len()\n+        self.ensure_row(row).insert_all();\n     }\n \n     pub fn rows(&self) -> impl Iterator<Item = R> {\n-        self.vector.indices()\n+        self.rows.indices()\n     }\n \n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n-        self.vector.get(row).into_iter().flat_map(|r| r.iter())\n-    }\n-\n-    /// Iterates through each row and the accompanying bit set.\n-    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a BitArray<C>)> + 'a {\n-        self.vector.iter_enumerated()\n+        self.row(row).into_iter().flat_map(|r| r.iter())\n     }\n \n     pub fn row(&self, row: R) -> Option<&BitArray<C>> {\n-        self.vector.get(row)\n+        if let Some(Some(row)) = self.rows.get(row) {\n+            Some(row)\n+        } else {\n+            None\n+        }\n     }\n }\n "}]}