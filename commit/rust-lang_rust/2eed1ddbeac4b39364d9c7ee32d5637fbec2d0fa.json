{"sha": "2eed1ddbeac4b39364d9c7ee32d5637fbec2d0fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlZWQxZGRiZWFjNGIzOTM2NGQ5YzdlZTMyZDU2MzdmYmVjMmQwZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-23T22:36:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-23T22:36:33Z"}, "message": "auto merge of #19246 : frewsxcv/rust/json-cleanup, r=jakub-\n\nWas looking through the JSON code and cleaned parts of it up", "tree": {"sha": "c13730274ebca09cce187494dce37056d200bca9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c13730274ebca09cce187494dce37056d200bca9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2eed1ddbeac4b39364d9c7ee32d5637fbec2d0fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2eed1ddbeac4b39364d9c7ee32d5637fbec2d0fa", "html_url": "https://github.com/rust-lang/rust/commit/2eed1ddbeac4b39364d9c7ee32d5637fbec2d0fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2eed1ddbeac4b39364d9c7ee32d5637fbec2d0fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "html_url": "https://github.com/rust-lang/rust/commit/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c"}, {"sha": "02355b87261385533b46bbce632aeb5f9baf3bf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/02355b87261385533b46bbce632aeb5f9baf3bf4", "html_url": "https://github.com/rust-lang/rust/commit/02355b87261385533b46bbce632aeb5f9baf3bf4"}], "stats": {"total": 134, "additions": 63, "deletions": 71}, "files": [{"sha": "4a2ca58fc9269f6c8c5c12bb202be811c8bd07d0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 63, "deletions": 71, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/2eed1ddbeac4b39364d9c7ee32d5637fbec2d0fa/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eed1ddbeac4b39364d9c7ee32d5637fbec2d0fa/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=2eed1ddbeac4b39364d9c7ee32d5637fbec2d0fa", "patch": "@@ -1166,7 +1166,7 @@ impl Stack {\n     /// at the top.\n     pub fn get<'l>(&'l self, idx: uint) -> StackElement<'l> {\n         match self.stack[idx] {\n-            InternalIndex(i) => { Index(i) }\n+            InternalIndex(i) => Index(i),\n             InternalKey(start, size) => {\n                 Key(str::from_utf8(\n                     self.str_buffer[start as uint .. start as uint + size as uint]).unwrap())\n@@ -1643,69 +1643,65 @@ impl<T: Iterator<char>> Parser<T> {\n     fn parse_start(&mut self) -> JsonEvent {\n         let val = self.parse_value();\n         self.state = match val {\n-            Error(_) => { ParseFinished }\n-            ArrayStart => { ParseArray(true) }\n-            ObjectStart => { ParseObject(true) }\n-            _ => { ParseBeforeFinish }\n+            Error(_) => ParseFinished,\n+            ArrayStart => ParseArray(true),\n+            ObjectStart => ParseObject(true),\n+            _ => ParseBeforeFinish,\n         };\n         return val;\n     }\n \n     fn parse_array(&mut self, first: bool) -> JsonEvent {\n         if self.ch_is(']') {\n             if !first {\n-                return self.error_event(InvalidSyntax);\n-            }\n-            if self.stack.is_empty() {\n-                self.state = ParseBeforeFinish;\n+                self.error_event(InvalidSyntax)\n             } else {\n-                self.state = if self.stack.last_is_index() {\n+                self.state = if self.stack.is_empty() {\n+                    ParseBeforeFinish\n+                } else if self.stack.last_is_index() {\n                     ParseArrayComma\n                 } else {\n                     ParseObjectComma\n-                }\n+                };\n+                self.bump();\n+                ArrayEnd\n             }\n-            self.bump();\n-            return ArrayEnd;\n-        }\n-        if first {\n-            self.stack.push_index(0);\n+        } else {\n+            if first {\n+                self.stack.push_index(0);\n+            }\n+            let val = self.parse_value();\n+            self.state = match val {\n+                Error(_) => ParseFinished,\n+                ArrayStart => ParseArray(true),\n+                ObjectStart => ParseObject(true),\n+                _ => ParseArrayComma,\n+            };\n+            val\n         }\n-\n-        let val = self.parse_value();\n-\n-        self.state = match val {\n-            Error(_) => { ParseFinished }\n-            ArrayStart => { ParseArray(true) }\n-            ObjectStart => { ParseObject(true) }\n-            _ => { ParseArrayComma }\n-        };\n-        return val;\n     }\n \n     fn parse_array_comma_or_end(&mut self) -> Option<JsonEvent> {\n         if self.ch_is(',') {\n             self.stack.bump_index();\n             self.state = ParseArray(false);\n             self.bump();\n-            return None;\n+            None\n         } else if self.ch_is(']') {\n             self.stack.pop();\n-            if self.stack.is_empty() {\n-                self.state = ParseBeforeFinish;\n+            self.state = if self.stack.is_empty() {\n+                ParseBeforeFinish\n+            } else if self.stack.last_is_index() {\n+                ParseArrayComma\n             } else {\n-                self.state = if self.stack.last_is_index() {\n-                    ParseArrayComma\n-                } else {\n-                    ParseObjectComma\n-                }\n-            }\n+                ParseObjectComma\n+            };\n             self.bump();\n-            return Some(ArrayEnd);\n+            Some(ArrayEnd)\n         } else if self.eof() {\n-            return Some(self.error_event(EOFWhileParsingArray));\n+            Some(self.error_event(EOFWhileParsingArray))\n         } else {\n-            return Some(self.error_event(InvalidSyntax));\n+            Some(self.error_event(InvalidSyntax))\n         }\n     }\n \n@@ -1718,15 +1714,13 @@ impl<T: Iterator<char>> Parser<T> {\n                     self.stack.pop();\n                 }\n             }\n-            if self.stack.is_empty() {\n-                self.state = ParseBeforeFinish;\n+            self.state = if self.stack.is_empty() {\n+                ParseBeforeFinish\n+            } else if self.stack.last_is_index() {\n+                ParseArrayComma\n             } else {\n-                self.state = if self.stack.last_is_index() {\n-                    ParseArrayComma\n-                } else {\n-                    ParseObjectComma\n-                }\n-            }\n+                ParseObjectComma\n+            };\n             self.bump();\n             return ObjectEnd;\n         }\n@@ -1737,7 +1731,7 @@ impl<T: Iterator<char>> Parser<T> {\n             return self.error_event(KeyMustBeAString);\n         }\n         let s = match self.parse_str() {\n-            Ok(s) => { s }\n+            Ok(s) => s,\n             Err(e) => {\n                 self.state = ParseFinished;\n                 return Error(e);\n@@ -1756,25 +1750,23 @@ impl<T: Iterator<char>> Parser<T> {\n         let val = self.parse_value();\n \n         self.state = match val {\n-            Error(_) => { ParseFinished }\n-            ArrayStart => { ParseArray(true) }\n-            ObjectStart => { ParseObject(true) }\n-            _ => { ParseObjectComma }\n+            Error(_) => ParseFinished,\n+            ArrayStart => ParseArray(true),\n+            ObjectStart => ParseObject(true),\n+            _ => ParseObjectComma,\n         };\n         return val;\n     }\n \n     fn parse_object_end(&mut self) -> JsonEvent {\n         if self.ch_is('}') {\n-            if self.stack.is_empty() {\n-                self.state = ParseBeforeFinish;\n+            self.state = if self.stack.is_empty() {\n+                ParseBeforeFinish\n+            } else if self.stack.last_is_index() {\n+                ParseArrayComma\n             } else {\n-                self.state = if self.stack.last_is_index() {\n-                    ParseArrayComma\n-                } else {\n-                    ParseObjectComma\n-                }\n-            }\n+                ParseObjectComma\n+            };\n             self.bump();\n             ObjectEnd\n         } else if self.eof() {\n@@ -1852,23 +1844,23 @@ impl<T: Iterator<char>> Builder<T> {\n     }\n \n     fn build_value(&mut self) -> Result<Json, BuilderError> {\n-        return match self.token {\n-            Some(NullValue) => { Ok(Null) }\n-            Some(I64Value(n)) => { Ok(I64(n)) }\n-            Some(U64Value(n)) => { Ok(U64(n)) }\n-            Some(F64Value(n)) => { Ok(F64(n)) }\n-            Some(BooleanValue(b)) => { Ok(Boolean(b)) }\n+        match self.token {\n+            Some(NullValue) => Ok(Null),\n+            Some(I64Value(n)) => Ok(I64(n)),\n+            Some(U64Value(n)) => Ok(U64(n)),\n+            Some(F64Value(n)) => Ok(F64(n)),\n+            Some(BooleanValue(b)) => Ok(Boolean(b)),\n             Some(StringValue(ref mut s)) => {\n                 let mut temp = string::String::new();\n                 swap(s, &mut temp);\n                 Ok(String(temp))\n             }\n-            Some(Error(e)) => { Err(e) }\n-            Some(ArrayStart) => { self.build_array() }\n-            Some(ObjectStart) => { self.build_object() }\n-            Some(ObjectEnd) => { self.parser.error(InvalidSyntax) }\n-            Some(ArrayEnd) => { self.parser.error(InvalidSyntax) }\n-            None => { self.parser.error(EOFWhileParsingValue) }\n+            Some(Error(e)) => Err(e),\n+            Some(ArrayStart) => self.build_array(),\n+            Some(ObjectStart) => self.build_object(),\n+            Some(ObjectEnd) => self.parser.error(InvalidSyntax),\n+            Some(ArrayEnd) => self.parser.error(InvalidSyntax),\n+            None => self.parser.error(EOFWhileParsingValue),\n         }\n     }\n "}]}