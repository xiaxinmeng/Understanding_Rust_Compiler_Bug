{"sha": "58224bc65910ae94cff81b2cdcd74a435498f5f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MjI0YmM2NTkxMGFlOTRjZmY4MWIyY2RjZDc0YTQzNTQ5OGY1ZjI=", "commit": {"author": {"name": "Sergey Parilin", "email": "Sergey.Parilin@fxdd.com", "date": "2019-03-27T15:09:51Z"}, "committer": {"name": "Sergey Parilin", "email": "Sergey.Parilin@fxdd.com", "date": "2019-03-27T15:23:26Z"}, "message": "profiling crate first draft", "tree": {"sha": "c36dd7c9b4f8118f44787731d79ee657fdd139e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c36dd7c9b4f8118f44787731d79ee657fdd139e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58224bc65910ae94cff81b2cdcd74a435498f5f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58224bc65910ae94cff81b2cdcd74a435498f5f2", "html_url": "https://github.com/rust-lang/rust/commit/58224bc65910ae94cff81b2cdcd74a435498f5f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58224bc65910ae94cff81b2cdcd74a435498f5f2/comments", "author": null, "committer": null, "parents": [{"sha": "afe96b75eae99fe2dcd7fb7c99e15507290b3d5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/afe96b75eae99fe2dcd7fb7c99e15507290b3d5f", "html_url": "https://github.com/rust-lang/rust/commit/afe96b75eae99fe2dcd7fb7c99e15507290b3d5f"}], "stats": {"total": 177, "additions": 177, "deletions": 0}, "files": [{"sha": "5d68105f6f8cedf615f4999e4b59ec3f79894248", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58224bc65910ae94cff81b2cdcd74a435498f5f2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/58224bc65910ae94cff81b2cdcd74a435498f5f2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=58224bc65910ae94cff81b2cdcd74a435498f5f2", "patch": "@@ -1066,6 +1066,13 @@ dependencies = [\n  \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ra_prof\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"ra_project_model\"\n version = \"0.1.0\""}, {"sha": "19ce217831369b7ec17f3bfa9eabaeb17a40b591", "filename": "crates/ra_prof/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58224bc65910ae94cff81b2cdcd74a435498f5f2/crates%2Fra_prof%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/58224bc65910ae94cff81b2cdcd74a435498f5f2/crates%2Fra_prof%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2FCargo.toml?ref=58224bc65910ae94cff81b2cdcd74a435498f5f2", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_prof\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+publish = false\n+\n+[dependencies]\n+lazy_static = \"1.3.0\"\n\\ No newline at end of file"}, {"sha": "55ad45fb79ecf5b59740d736791729fbf091c56f", "filename": "crates/ra_prof/src/lib.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/58224bc65910ae94cff81b2cdcd74a435498f5f2/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58224bc65910ae94cff81b2cdcd74a435498f5f2/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=58224bc65910ae94cff81b2cdcd74a435498f5f2", "patch": "@@ -0,0 +1,161 @@\n+extern crate lazy_static;\n+\n+use std::cell::RefCell;\n+use std::time;\n+use std::fmt;\n+use std::mem;\n+use std::io::{stderr, StderrLock, Write};\n+use std::iter::repeat;\n+use std::collections::{HashSet};\n+use std::default::Default;\n+use std::iter::FromIterator;\n+use std::sync::RwLock;\n+\n+use lazy_static::lazy_static;\n+\n+type Message = (usize, u64, String);\n+\n+pub struct Profiler {\n+    desc: String,\n+}\n+\n+pub struct Filter {\n+    depth: usize,\n+    allowed: Vec<String>,\n+}\n+\n+struct ProfileStack {\n+    starts: Vec<time::Instant>,\n+    messages: Vec<Message>,\n+    filter_data: FilterData,\n+}\n+\n+impl ProfileStack {\n+    fn new() -> ProfileStack {\n+        ProfileStack { starts: Vec::new(), messages: Vec::new(), filter_data: Default::default() }\n+    }\n+}\n+\n+#[derive(Default)]\n+struct FilterData {\n+    depth: usize,\n+    version: usize,\n+    allowed: HashSet<String>,\n+}\n+\n+impl Clone for FilterData {\n+    fn clone(&self) -> FilterData {\n+        let set = HashSet::from_iter(self.allowed.iter().cloned());\n+        FilterData { depth: self.depth, allowed: set, version: self.version }\n+    }\n+}\n+\n+lazy_static! {\n+    static ref FILTER: RwLock<FilterData> = RwLock::new(Default::default());\n+}\n+\n+thread_local!(static PROFILE_STACK: RefCell<ProfileStack> = RefCell::new(ProfileStack::new()));\n+\n+pub fn set_filter(f: Filter) {\n+    let mut old = FILTER.write().unwrap();\n+    let set = HashSet::from_iter(f.allowed.iter().cloned());\n+    let filter_data = FilterData { depth: f.depth, allowed: set, version: old.version + 1 };\n+    *old = filter_data;\n+}\n+\n+pub fn profile<T: fmt::Display>(desc: T) -> Profiler {\n+    PROFILE_STACK.with(|stack| {\n+        let mut stack = stack.borrow_mut();\n+        if stack.starts.len() == 0 {\n+            match FILTER.try_read() {\n+                Ok(f) => {\n+                    if f.version > stack.filter_data.version {\n+                        stack.filter_data = f.clone();\n+                    }\n+                }\n+                Err(_) => (),\n+            };\n+        }\n+        let desc_str = desc.to_string();\n+        if desc_str.is_empty() {\n+            Profiler { desc: desc_str }\n+        } else if stack.starts.len() < stack.filter_data.depth\n+            && stack.filter_data.allowed.contains(&desc_str)\n+        {\n+            stack.starts.push(time::Instant::now());\n+            Profiler { desc: desc_str }\n+        } else {\n+            Profiler { desc: String::new() }\n+        }\n+    })\n+}\n+\n+impl Drop for Profiler {\n+    fn drop(&mut self) {\n+        if self.desc.is_empty() {\n+            return;\n+        }\n+        PROFILE_STACK.with(|stack| {\n+            let mut stack = stack.borrow_mut();\n+            let start = stack.starts.pop().unwrap();\n+            let duration = start.elapsed();\n+            let duration_ms = duration.as_secs() * 1000 + u64::from(duration.subsec_millis());\n+            let stack_len = stack.starts.len();\n+            let msg = (stack_len, duration_ms, mem::replace(&mut self.desc, String::new()));\n+            stack.messages.push(msg);\n+            if stack_len == 0 {\n+                let stdout = stderr();\n+                print(0, &stack.messages, 1, &mut stdout.lock());\n+                stack.messages.clear();\n+            }\n+        });\n+    }\n+}\n+\n+fn print(lvl: usize, msgs: &[Message], enabled: usize, stdout: &mut StderrLock<'_>) {\n+    if lvl > enabled {\n+        return;\n+    }\n+    let mut last = 0;\n+    for (i, &(l, time, ref msg)) in msgs.iter().enumerate() {\n+        if l != lvl {\n+            continue;\n+        }\n+        writeln!(\n+            stdout,\n+            \"{} {:6}ms - {}\",\n+            repeat(\"    \").take(lvl + 1).collect::<String>(),\n+            time,\n+            msg\n+        )\n+        .expect(\"printing profiling info to stdout\");\n+\n+        print(lvl + 1, &msgs[last..i], enabled, stdout);\n+        last = i;\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use super::profile;\n+    use super::set_filter;\n+    use super::Filter;\n+\n+    #[test]\n+    fn test_basic_profile() {\n+        let s = vec![\"profile1\".to_string(), \"profile2\".to_string()];\n+        let f = Filter { depth: 2, allowed: s };\n+        set_filter(f);\n+        profiling_function1();\n+    }\n+\n+    fn profiling_function1() {\n+        let _p = profile(\"profile1\");\n+        profiling_function2();\n+    }\n+\n+    fn profiling_function2() {\n+        let _p = profile(\"profile2\");\n+    }\n+}"}]}