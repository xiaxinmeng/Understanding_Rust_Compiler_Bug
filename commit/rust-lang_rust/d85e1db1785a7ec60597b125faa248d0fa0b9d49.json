{"sha": "d85e1db1785a7ec60597b125faa248d0fa0b9d49", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NWUxZGIxNzg1YTdlYzYwNTk3YjEyNWZhYTI0OGQwZmEwYjlkNDk=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-02-05T00:56:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-05T00:56:26Z"}, "message": "Merge pull request #2393 from RReverser/macro_rules\n\nFormat stable macro_rules", "tree": {"sha": "4b06ef7da6f60a209a2faa9589c0e80cc776ac2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b06ef7da6f60a209a2faa9589c0e80cc776ac2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d85e1db1785a7ec60597b125faa248d0fa0b9d49", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJad6u6CRBK7hj4Ov3rIwAAdHIIAJ76m3RG0uT3qCQzJvPK163G\naoOn3DWqfd+W5M3/5qtggKUcPSzEC2L8MHP9IGo30R9Clo5sacyKWDKGqTUxk6+r\nA/G+jU6wDkBuh4xQhsqYdaFNhGWV4dcZclRw9agke1xmRUkqwNblzLAayuhZzbyh\ns1OuflBw8dS6aIUQ8YcBeVpkFNkv0DztYnd0WlHCJfkjCw9asyiULHHCN94bBUUr\nKoJ6S03ZJTPQtYdL3DBFf3BRiDI4bDSFJ/YFAPZd0PDVuXG5UPegid4blWntO0R8\n+PxPf40s+nqX8M0WC684THoRev5DFAj44vvzjjcL7uTEZr2MOHMcWvs51cMFgWY=\n=LDZk\n-----END PGP SIGNATURE-----\n", "payload": "tree 4b06ef7da6f60a209a2faa9589c0e80cc776ac2b\nparent 18ba02ea70b9d6e9fba5306c6b7f2cd84df5d452\nparent 8691c64e9970043f13ed3d5a6f1ac62ced7159f3\nauthor Seiichi Uchida <seuchida@gmail.com> 1517792186 +0900\ncommitter GitHub <noreply@github.com> 1517792186 +0900\n\nMerge pull request #2393 from RReverser/macro_rules\n\nFormat stable macro_rules"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d85e1db1785a7ec60597b125faa248d0fa0b9d49", "html_url": "https://github.com/rust-lang/rust/commit/d85e1db1785a7ec60597b125faa248d0fa0b9d49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d85e1db1785a7ec60597b125faa248d0fa0b9d49/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18ba02ea70b9d6e9fba5306c6b7f2cd84df5d452", "url": "https://api.github.com/repos/rust-lang/rust/commits/18ba02ea70b9d6e9fba5306c6b7f2cd84df5d452", "html_url": "https://github.com/rust-lang/rust/commit/18ba02ea70b9d6e9fba5306c6b7f2cd84df5d452"}, {"sha": "8691c64e9970043f13ed3d5a6f1ac62ced7159f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8691c64e9970043f13ed3d5a6f1ac62ced7159f3", "html_url": "https://github.com/rust-lang/rust/commit/8691c64e9970043f13ed3d5a6f1ac62ced7159f3"}], "stats": {"total": 397, "additions": 288, "deletions": 109}, "files": [{"sha": "1acad99688a25cc8563813acd7cbc505e7fdb1eb", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d85e1db1785a7ec60597b125faa248d0fa0b9d49/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e1db1785a7ec60597b125faa248d0fa0b9d49/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=d85e1db1785a7ec60597b125faa248d0fa0b9d49", "patch": "@@ -97,14 +97,14 @@ fn execute() -> i32 {\n }\n \n macro_rules! print_usage {\n-    ($print:ident, $opts:ident, $reason:expr) => ({\n+    ($print: ident, $opts: ident, $reason: expr) => {{\n         let msg = format!(\"{}\\nusage: cargo fmt [options]\", $reason);\n         $print!(\n             \"{}\\nThis utility formats all bin and lib files of the current crate using rustfmt. \\\n              Arguments after `--` are passed to rustfmt.\",\n             $opts.usage(&msg)\n         );\n-    })\n+    }};\n }\n \n fn print_usage_to_stdout(opts: &Options, reason: &str) {"}, {"sha": "cca1779a4a8d0fb6d2f8b04df06c65dbe0ff710f", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e1db1785a7ec60597b125faa248d0fa0b9d49/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e1db1785a7ec60597b125faa248d0fa0b9d49/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=d85e1db1785a7ec60597b125faa248d0fa0b9d49", "patch": "@@ -36,7 +36,7 @@ macro_rules! is_nightly_channel {\n         option_env!(\"CFG_RELEASE_CHANNEL\")\n             .map(|c| c == \"nightly\")\n             .unwrap_or(true)\n-    }\n+    };\n }\n \n macro_rules! configuration_option_enum{"}, {"sha": "3abfe6239fd0136d77fea8d5c0b4b69c918f2419", "filename": "src/macros.rs", "status": "modified", "additions": 158, "deletions": 75, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/d85e1db1785a7ec60597b125faa248d0fa0b9d49/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e1db1785a7ec60597b125faa248d0fa0b9d49/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=d85e1db1785a7ec60597b125faa248d0fa0b9d49", "patch": "@@ -33,6 +33,8 @@ use syntax::util::ThinVec;\n use codemap::SpanUtils;\n use comment::{contains_comment, remove_trailing_white_spaces, FindUncommented};\n use expr::{rewrite_array, rewrite_call_inner};\n+use lists::{itemize_list, write_list, DefinitiveListTactic, ListFormatting, SeparatorPlace,\n+            SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use utils::{format_visibility, mk_sp};\n@@ -101,7 +103,7 @@ fn parse_macro_arg(parser: &mut Parser) -> Option<MacroArg> {\n                     parser.sess.span_diagnostic.reset_err_count();\n                 }\n             }\n-        }\n+        };\n     }\n \n     parse_macro_arg!(Expr, parse_expr);\n@@ -283,6 +285,7 @@ pub fn rewrite_macro(\n \n pub fn rewrite_macro_def(\n     context: &RewriteContext,\n+    shape: Shape,\n     indent: Indent,\n     def: &ast::MacroDef,\n     ident: ast::Ident,\n@@ -291,88 +294,67 @@ pub fn rewrite_macro_def(\n ) -> Option<String> {\n     let snippet = Some(remove_trailing_white_spaces(context.snippet(span)));\n \n-    if def.legacy {\n-        return snippet;\n-    }\n-\n     let mut parser = MacroParser::new(def.stream().into_trees());\n-    let mut parsed_def = match parser.parse() {\n+    let parsed_def = match parser.parse() {\n         Some(def) => def,\n         None => return snippet,\n     };\n \n-    // Only attempt to format function-like macros.\n-    if parsed_def.branches.len() != 1 || parsed_def.branches[0].args_paren_kind != DelimToken::Paren\n-    {\n-        // FIXME(#1539): implement for non-sugared macros.\n-        return snippet;\n-    }\n+    let mut result = if def.legacy {\n+        String::from(\"macro_rules!\")\n+    } else {\n+        format!(\"{}macro\", format_visibility(vis))\n+    };\n \n-    let branch = parsed_def.branches.remove(0);\n-    let args_str = format_macro_args(branch.args)?;\n+    result += \" \";\n+    result += &ident.name.as_str();\n \n-    // The macro body is the most interesting part. It might end up as various\n-    // AST nodes, but also has special variables (e.g, `$foo`) which can't be\n-    // parsed as regular Rust code (and note that these can be escaped using\n-    // `$$`). We'll try and format like an AST node, but we'll substitute\n-    // variables for new names with the same length first.\n+    let multi_branch_style = def.legacy || parsed_def.branches.len() != 1;\n \n-    let old_body = context.snippet(branch.body).trim();\n-    let (body_str, substs) = match replace_names(old_body) {\n-        Some(result) => result,\n-        None => return snippet,\n+    let arm_shape = if multi_branch_style {\n+        shape\n+            .block_indent(context.config.tab_spaces())\n+            .with_max_width(context.config)\n+    } else {\n+        shape\n     };\n \n-    // We'll hack the indent below, take this into account when formatting,\n-    let mut config = context.config.clone();\n-    let new_width = config.max_width() - indent.block_indent(&config).width();\n-    config.set().max_width(new_width);\n-    config.set().hide_parse_errors(true);\n-\n-    // First try to format as items, then as statements.\n-    let new_body = match ::format_snippet(&body_str, &config) {\n-        Some(new_body) => new_body,\n-        None => match ::format_code_block(&body_str, &config) {\n-            Some(new_body) => new_body,\n-            None => return snippet,\n-        },\n+    let branch_items = itemize_list(\n+        context.codemap,\n+        parsed_def.branches.iter(),\n+        \"}\",\n+        \";\",\n+        |branch| branch.span.lo(),\n+        |branch| branch.span.hi(),\n+        |branch| branch.rewrite(context, arm_shape, multi_branch_style),\n+        context.codemap.span_after(span, \"{\"),\n+        span.hi(),\n+        false,\n+    ).collect::<Vec<_>>();\n+\n+    let fmt = ListFormatting {\n+        tactic: DefinitiveListTactic::Vertical,\n+        separator: if def.legacy { \";\" } else { \"\" },\n+        trailing_separator: SeparatorTactic::Always,\n+        separator_place: SeparatorPlace::Back,\n+        shape: arm_shape,\n+        ends_with_newline: true,\n+        preserve_newline: true,\n+        config: context.config,\n     };\n \n-    // Indent the body since it is in a block.\n-    let indent_str = indent.block_indent(&config).to_string(&config);\n-    let mut new_body = new_body\n-        .lines()\n-        .map(|l| {\n-            if l.is_empty() {\n-                l.to_owned()\n-            } else {\n-                format!(\"{}{}\", indent_str, l)\n-            }\n-        })\n-        .collect::<Vec<_>>()\n-        .join(\"\\n\");\n-\n-    // Undo our replacement of macro variables.\n-    // FIXME: this could be *much* more efficient.\n-    for (old, new) in &substs {\n-        if old_body.find(new).is_some() {\n-            debug!(\n-                \"rewrite_macro_def: bailing matching variable: `{}` in `{}`\",\n-                new, ident\n-            );\n-            return snippet;\n-        }\n-        new_body = new_body.replace(new, old);\n+    if multi_branch_style {\n+        result += \" {\\n\";\n+        result += &arm_shape.indent.to_string(context.config);\n     }\n \n-    let result = format!(\n-        \"{}macro {}({}) {{\\n{}\\n{}}}\",\n-        format_visibility(vis),\n-        ident,\n-        args_str,\n-        new_body,\n-        indent.to_string(context.config),\n-    );\n+    result += write_list(&branch_items, &fmt)?.as_str();\n+\n+    if multi_branch_style {\n+        result += \"\\n\";\n+        result += &indent.to_string(context.config);\n+        result += \"}\";\n+    }\n \n     Some(result)\n }\n@@ -714,24 +696,34 @@ impl MacroParser {\n \n     // `(` ... `)` `=>` `{` ... `}`\n     fn parse_branch(&mut self) -> Option<MacroBranch> {\n-        let (args_paren_kind, args) = match self.toks.next()? {\n+        let tok = self.toks.next()?;\n+        let (lo, args_paren_kind) = match tok {\n             TokenTree::Token(..) => return None,\n-            TokenTree::Delimited(_, ref d) => (d.delim, d.tts.clone()),\n+            TokenTree::Delimited(sp, ref d) => (sp.lo(), d.delim),\n         };\n+        let args = tok.joint().into();\n         match self.toks.next()? {\n             TokenTree::Token(_, Token::FatArrow) => {}\n             _ => return None,\n         }\n-        let body = match self.toks.next()? {\n+        let (mut hi, body) = match self.toks.next()? {\n             TokenTree::Token(..) => return None,\n             TokenTree::Delimited(sp, _) => {\n                 let data = sp.data();\n-                Span::new(data.lo + BytePos(1), data.hi - BytePos(1), data.ctxt)\n+                (\n+                    data.hi,\n+                    Span::new(data.lo + BytePos(1), data.hi - BytePos(1), data.ctxt),\n+                )\n             }\n         };\n+        if let Some(TokenTree::Token(sp, Token::Semi)) = self.toks.look_ahead(0) {\n+            self.toks.next();\n+            hi = sp.hi();\n+        }\n         Some(MacroBranch {\n-            args,\n+            span: mk_sp(lo, hi),\n             args_paren_kind,\n+            args,\n             body,\n         })\n     }\n@@ -745,11 +737,102 @@ struct Macro {\n // FIXME: it would be more efficient to use references to the token streams\n // rather than clone them, if we can make the borrowing work out.\n struct MacroBranch {\n-    args: ThinTokenStream,\n+    span: Span,\n     args_paren_kind: DelimToken,\n+    args: ThinTokenStream,\n     body: Span,\n }\n \n+impl MacroBranch {\n+    fn rewrite(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        multi_branch_style: bool,\n+    ) -> Option<String> {\n+        // Only attempt to format function-like macros.\n+        if self.args_paren_kind != DelimToken::Paren {\n+            // FIXME(#1539): implement for non-sugared macros.\n+            return None;\n+        }\n+\n+        let mut result = format_macro_args(self.args.clone())?;\n+\n+        if multi_branch_style {\n+            result += \" =>\";\n+        }\n+\n+        // The macro body is the most interesting part. It might end up as various\n+        // AST nodes, but also has special variables (e.g, `$foo`) which can't be\n+        // parsed as regular Rust code (and note that these can be escaped using\n+        // `$$`). We'll try and format like an AST node, but we'll substitute\n+        // variables for new names with the same length first.\n+\n+        let old_body = context.snippet(self.body).trim();\n+        let (body_str, substs) = replace_names(old_body)?;\n+\n+        let mut config = context.config.clone();\n+        config.set().hide_parse_errors(true);\n+\n+        result += \" {\";\n+\n+        let has_block_body = old_body.starts_with('{');\n+\n+        let body_indent = if has_block_body {\n+            shape.indent\n+        } else {\n+            // We'll hack the indent below, take this into account when formatting,\n+            let body_indent = shape.indent.block_indent(&config);\n+            let new_width = config.max_width() - body_indent.width();\n+            config.set().max_width(new_width);\n+            body_indent\n+        };\n+\n+        // First try to format as items, then as statements.\n+        let new_body = match ::format_snippet(&body_str, &config) {\n+            Some(new_body) => new_body,\n+            None => match ::format_code_block(&body_str, &config) {\n+                Some(new_body) => new_body,\n+                None => return None,\n+            },\n+        };\n+\n+        // Indent the body since it is in a block.\n+        let indent_str = body_indent.to_string(&config);\n+        let mut new_body = new_body\n+            .trim_right()\n+            .lines()\n+            .fold(String::new(), |mut s, l| {\n+                if !l.is_empty() {\n+                    s += &indent_str;\n+                }\n+                s + l + \"\\n\"\n+            });\n+\n+        // Undo our replacement of macro variables.\n+        // FIXME: this could be *much* more efficient.\n+        for (old, new) in &substs {\n+            if old_body.find(new).is_some() {\n+                debug!(\"rewrite_macro_def: bailing matching variable: `{}`\", new);\n+                return None;\n+            }\n+            new_body = new_body.replace(new, old);\n+        }\n+\n+        if has_block_body {\n+            result += new_body.trim();\n+        } else if !new_body.is_empty() {\n+            result += \"\\n\";\n+            result += &new_body;\n+            result += &shape.indent.to_string(&config);\n+        }\n+\n+        result += \"}\";\n+\n+        Some(result)\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "a431f3a544a6e39e23a30a9c89bf93013765e3c4", "filename": "src/spanned.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d85e1db1785a7ec60597b125faa248d0fa0b9d49/src%2Fspanned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e1db1785a7ec60597b125faa248d0fa0b9d49/src%2Fspanned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fspanned.rs?ref=d85e1db1785a7ec60597b125faa248d0fa0b9d49", "patch": "@@ -20,32 +20,30 @@ pub trait Spanned {\n }\n \n macro_rules! span_with_attrs_lo_hi {\n-    ($this:ident, $lo:expr, $hi:expr) => {\n-        {\n-            let attrs = outer_attributes(&$this.attrs);\n-            if attrs.is_empty() {\n-                mk_sp($lo, $hi)\n-            } else {\n-                mk_sp(attrs[0].span.lo(), $hi)\n-            }\n+    ($this: ident, $lo: expr, $hi: expr) => {{\n+        let attrs = outer_attributes(&$this.attrs);\n+        if attrs.is_empty() {\n+            mk_sp($lo, $hi)\n+        } else {\n+            mk_sp(attrs[0].span.lo(), $hi)\n         }\n-    }\n+    }};\n }\n \n macro_rules! span_with_attrs {\n-    ($this:ident) => {\n+    ($this: ident) => {\n         span_with_attrs_lo_hi!($this, $this.span.lo(), $this.span.hi())\n-    }\n+    };\n }\n \n macro_rules! implement_spanned {\n-    ($this:ty) => {\n+    ($this: ty) => {\n         impl Spanned for $this {\n             fn span(&self) -> Span {\n                 span_with_attrs!(self)\n             }\n         }\n-    }\n+    };\n }\n \n // Implement `Spanned` for structs with `attrs` field."}, {"sha": "443dc6c7a05edc558131a1e2842b86a372babfce", "filename": "src/utils.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d85e1db1785a7ec60597b125faa248d0fa0b9d49/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e1db1785a7ec60597b125faa248d0fa0b9d49/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=d85e1db1785a7ec60597b125faa248d0fa0b9d49", "patch": "@@ -342,9 +342,9 @@ macro_rules! msg {\n // For format_missing and last_pos, need to use the source callsite (if applicable).\n // Required as generated code spans aren't guaranteed to follow on from the last span.\n macro_rules! source {\n-    ($this:ident, $sp: expr) => {\n+    ($this: ident, $sp: expr) => {\n         $sp.source_callsite()\n-    }\n+    };\n }\n \n pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n@@ -353,28 +353,29 @@ pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n \n // Return true if the given span does not intersect with file lines.\n macro_rules! out_of_file_lines_range {\n-    ($self:ident, $span:expr) => {\n-        !$self.config\n+    ($self: ident, $span: expr) => {\n+        !$self\n+            .config\n             .file_lines()\n             .intersects(&$self.codemap.lookup_line_range($span))\n-    }\n+    };\n }\n \n macro_rules! skip_out_of_file_lines_range {\n-    ($self:ident, $span:expr) => {\n+    ($self: ident, $span: expr) => {\n         if out_of_file_lines_range!($self, $span) {\n             return None;\n         }\n-    }\n+    };\n }\n \n macro_rules! skip_out_of_file_lines_range_visitor {\n-    ($self:ident, $span:expr) => {\n+    ($self: ident, $span: expr) => {\n         if out_of_file_lines_range!($self, $span) {\n             $self.push_rewrite($span, None);\n             return;\n         }\n-    }\n+    };\n }\n \n // Wraps String in an Option. Returns Some when the string adheres to the"}, {"sha": "cd6c0740ee6d5c589b2188add75ab680d0e3a34f", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d85e1db1785a7ec60597b125faa248d0fa0b9d49/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e1db1785a7ec60597b125faa248d0fa0b9d49/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=d85e1db1785a7ec60597b125faa248d0fa0b9d49", "patch": "@@ -463,6 +463,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             ast::ItemKind::MacroDef(ref def) => {\n                 let rewrite = rewrite_macro_def(\n                     &self.get_context(),\n+                    self.shape(),\n                     self.block_indent,\n                     def,\n                     item.ident,"}, {"sha": "7d14f44971d5827f8d1f5f5ebcec2cfc9d23e802", "filename": "tests/source/macro_rules.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d85e1db1785a7ec60597b125faa248d0fa0b9d49/tests%2Fsource%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e1db1785a7ec60597b125faa248d0fa0b9d49/tests%2Fsource%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmacro_rules.rs?ref=d85e1db1785a7ec60597b125faa248d0fa0b9d49", "patch": "@@ -0,0 +1,51 @@\n+macro_rules! m {\n+\t// a\n+\t($expr :expr,  $( $func : ident    ) *   ) => {\n+\t\t{\n+\t\tlet    x =    $expr;\n+\t\t\t\t\t\t\t\t\t                $func (\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tx\n+\t\t\t\t\t\t\t\t\t\t\t)\n+\t}\n+\t};\n+\n+\t\t\t\t/* b */\n+\n+   \t()           => {/* c */};\n+\n+\t\t \t\t\t\t(@tag)   =>\n+\t\t\t\t\t\t {\n+\n+\t\t\t\t\t\t };\n+\n+// d\n+( $item:ident  ) =>      {\n+\tmod macro_item    {  struct $item ; }\n+};\n+}\n+\n+macro m2 {\n+\t// a\n+\t($expr :expr,  $( $func : ident    ) *   ) => {\n+\t\t{\n+\t\tlet    x =    $expr;\n+\t\t\t\t\t\t\t\t\t                $func (\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tx\n+\t\t\t\t\t\t\t\t\t\t\t)\n+\t}\n+\t}\n+\n+\t\t\t\t/* b */\n+\n+   \t()           => {/* c */}\n+\n+\t\t \t\t\t\t(@tag)   =>\n+\t\t\t\t\t\t {\n+\n+\t\t\t\t\t\t }\n+\n+// d\n+( $item:ident  ) =>      {\n+\tmod macro_item    {  struct $item ; }\n+}\n+}"}, {"sha": "c76a6492a9d3303f23c189c6bc462751243642a9", "filename": "tests/target/macro_not_expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e1db1785a7ec60597b125faa248d0fa0b9d49/tests%2Ftarget%2Fmacro_not_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e1db1785a7ec60597b125faa248d0fa0b9d49/tests%2Ftarget%2Fmacro_not_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmacro_not_expr.rs?ref=d85e1db1785a7ec60597b125faa248d0fa0b9d49", "patch": "@@ -1,5 +1,5 @@\n macro_rules! test {\n-    ($($t:tt)*) => {}\n+    ($($t: tt)*) => {};\n }\n \n fn main() {"}, {"sha": "647d442034fae98c2b6f76ef727d7fcb265d33c3", "filename": "tests/target/macro_rules.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d85e1db1785a7ec60597b125faa248d0fa0b9d49/tests%2Ftarget%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e1db1785a7ec60597b125faa248d0fa0b9d49/tests%2Ftarget%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmacro_rules.rs?ref=d85e1db1785a7ec60597b125faa248d0fa0b9d49", "patch": "@@ -0,0 +1,43 @@\n+macro_rules! m {\n+    // a\n+    ($expr: expr, $($func: ident)*) => {{\n+        let x = $expr;\n+        $func(x)\n+    }};\n+\n+    /* b */\n+    () => {\n+        /* c */\n+    };\n+\n+    (@tag) => {};\n+\n+    // d\n+    ($item: ident) => {\n+        mod macro_item {\n+            struct $item;\n+        }\n+    };\n+}\n+\n+macro m2 {\n+    // a\n+    ($expr: expr, $($func: ident)*) => {{\n+        let x = $expr;\n+        $func(x)\n+    }}\n+\n+    /* b */\n+    () => {\n+        /* c */\n+    }\n+\n+    (@tag) => {}\n+\n+    // d\n+    ($item: ident) => {\n+        mod macro_item {\n+            struct $item;\n+        }\n+    }\n+}"}, {"sha": "9b32c6623bbd56e05e2d94aa4f305e2c283cc643", "filename": "tests/target/macros.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d85e1db1785a7ec60597b125faa248d0fa0b9d49/tests%2Ftarget%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e1db1785a7ec60597b125faa248d0fa0b9d49/tests%2Ftarget%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmacros.rs?ref=d85e1db1785a7ec60597b125faa248d0fa0b9d49", "patch": "@@ -141,7 +141,7 @@ fn issue_1555() {\n \n fn issue1178() {\n     macro_rules! foo {\n-        (#[$attr:meta] $name:ident) => {}\n+        (#[$attr: meta] $name: ident) => {};\n     }\n \n     foo!(\n@@ -246,11 +246,15 @@ fn __bindgen_test_layout_HandleWithDtor_open0_int_close0_instantiation() {\n \n // #878\n macro_rules! try_opt {\n-    ($expr:expr) => (match $expr {\n-        Some(val) => val,\n+    ($expr: expr) => {\n+        match $expr {\n+            Some(val) => val,\n \n-        None => { return None; }\n-    })\n+            None => {\n+                return None;\n+            }\n+        }\n+    };\n }\n \n // #2214\n@@ -885,9 +889,7 @@ fn macro_in_pattern_position() {\n     };\n }\n \n-macro foo() {\n-\n-}\n+macro foo() {}\n \n pub macro bar($x: ident + $y: expr;) {\n     fn foo($x: Foo) {"}]}