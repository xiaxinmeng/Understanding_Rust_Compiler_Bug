{"sha": "0e6896b22951c606b2b78640bb1e3a3ccbb86efe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNjg5NmIyMjk1MWM2MDZiMmI3ODY0MGJiMWUzYTNjY2JiODZlZmU=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2019-07-14T21:46:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-14T21:46:59Z"}, "message": "Merge pull request #3683 from calebcartwright/accept-manifest-path\n\nAdd --manifest-path support to cargo fmt", "tree": {"sha": "82e9486910779127da6eadcff809455b90bf927c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82e9486910779127da6eadcff809455b90bf927c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e6896b22951c606b2b78640bb1e3a3ccbb86efe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdK6LUCRBK7hj4Ov3rIwAAdHIIAILgUlou2UMQPUFlPsTvlBzN\n77UQQPV436Wh8NY1ZIb0flZmI6nNOJuXg0wqJaXjePV0h/ssVaSz/jZWg3YEhVLH\nQLuyMzm22MMsdwvfwSWH2bl7pWoMc0uJveBD0NewwxPsWPD4PvtwURwsKvcaXyBm\nGmeSCDr7UgmxD0+KpBCVUyRxxYy4sP1nk7C3a9p0Zk0VnSbnN8MUWA6sUxgiiv9/\nvFcbOjWxLK1/4MPzuL6EsS8naBXcEh6+Y12ykJK8tO/6IcihFfl0OfsWnhm18Bpp\n3+WaVCVISlr8H/Csc/l3h2oKxHMBfkRgqf2gdgDU12Szs9Wzm+DE4Jd335eD+c4=\n=5kgy\n-----END PGP SIGNATURE-----\n", "payload": "tree 82e9486910779127da6eadcff809455b90bf927c\nparent 71289e1d230d19f223e45b0abe75ae976f567900\nparent 6f67f077529525cb5f96803f17295079656f4058\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1563140819 +0200\ncommitter GitHub <noreply@github.com> 1563140819 +0200\n\nMerge pull request #3683 from calebcartwright/accept-manifest-path\n\nAdd --manifest-path support to cargo fmt"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e6896b22951c606b2b78640bb1e3a3ccbb86efe", "html_url": "https://github.com/rust-lang/rust/commit/0e6896b22951c606b2b78640bb1e3a3ccbb86efe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e6896b22951c606b2b78640bb1e3a3ccbb86efe/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71289e1d230d19f223e45b0abe75ae976f567900", "url": "https://api.github.com/repos/rust-lang/rust/commits/71289e1d230d19f223e45b0abe75ae976f567900", "html_url": "https://github.com/rust-lang/rust/commit/71289e1d230d19f223e45b0abe75ae976f567900"}, {"sha": "6f67f077529525cb5f96803f17295079656f4058", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f67f077529525cb5f96803f17295079656f4058", "html_url": "https://github.com/rust-lang/rust/commit/6f67f077529525cb5f96803f17295079656f4058"}], "stats": {"total": 68, "additions": 56, "deletions": 12}, "files": [{"sha": "7651a0ee4372f2ff2df319b7f79bed45d382720c", "filename": "src/cargo-fmt/main.rs", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0e6896b22951c606b2b78640bb1e3a3ccbb86efe/src%2Fcargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6896b22951c606b2b78640bb1e3a3ccbb86efe/src%2Fcargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo-fmt%2Fmain.rs?ref=0e6896b22951c606b2b78640bb1e3a3ccbb86efe", "patch": "@@ -41,6 +41,10 @@ pub struct Opts {\n     #[structopt(short = \"p\", long = \"package\", value_name = \"package\")]\n     packages: Vec<String>,\n \n+    /// Specify path to Cargo.toml\n+    #[structopt(long = \"manifest-path\", value_name = \"manifest-path\")]\n+    manifest_path: Option<String>,\n+\n     /// Options passed to rustfmt\n     // 'raw = true' to make `--` explicit.\n     #[structopt(name = \"rustfmt_options\", raw(raw = \"true\"))]\n@@ -97,7 +101,26 @@ fn execute() -> i32 {\n \n     let strategy = CargoFmtStrategy::from_opts(&opts);\n \n-    handle_command_status(format_crate(verbosity, &strategy, opts.rustfmt_options))\n+    if let Some(specified_manifest_path) = opts.manifest_path {\n+        if !specified_manifest_path.ends_with(\"Cargo.toml\") {\n+            print_usage_to_stderr(\"the manifest-path must be a path to a Cargo.toml file\");\n+            return FAILURE;\n+        }\n+        let manifest_path = PathBuf::from(specified_manifest_path);\n+        handle_command_status(format_crate(\n+            verbosity,\n+            &strategy,\n+            opts.rustfmt_options,\n+            Some(&manifest_path),\n+        ))\n+    } else {\n+        handle_command_status(format_crate(\n+            verbosity,\n+            &strategy,\n+            opts.rustfmt_options,\n+            None,\n+        ))\n+    }\n }\n \n fn print_usage_to_stderr(reason: &str) {\n@@ -149,8 +172,9 @@ fn format_crate(\n     verbosity: Verbosity,\n     strategy: &CargoFmtStrategy,\n     rustfmt_args: Vec<String>,\n+    manifest_path: Option<&Path>,\n ) -> Result<i32, io::Error> {\n-    let targets = get_targets(strategy)?;\n+    let targets = get_targets(strategy, manifest_path)?;\n \n     // Currently only bin and lib files get formatted.\n     run_rustfmt(&targets, &rustfmt_args, verbosity)\n@@ -227,13 +251,20 @@ impl CargoFmtStrategy {\n }\n \n /// Based on the specified `CargoFmtStrategy`, returns a set of main source files.\n-fn get_targets(strategy: &CargoFmtStrategy) -> Result<BTreeSet<Target>, io::Error> {\n+fn get_targets(\n+    strategy: &CargoFmtStrategy,\n+    manifest_path: Option<&Path>,\n+) -> Result<BTreeSet<Target>, io::Error> {\n     let mut targets = BTreeSet::new();\n \n     match *strategy {\n-        CargoFmtStrategy::Root => get_targets_root_only(&mut targets)?,\n-        CargoFmtStrategy::All => get_targets_recursive(None, &mut targets, &mut BTreeSet::new())?,\n-        CargoFmtStrategy::Some(ref hitlist) => get_targets_with_hitlist(hitlist, &mut targets)?,\n+        CargoFmtStrategy::Root => get_targets_root_only(manifest_path, &mut targets)?,\n+        CargoFmtStrategy::All => {\n+            get_targets_recursive(manifest_path, &mut targets, &mut BTreeSet::new())?\n+        }\n+        CargoFmtStrategy::Some(ref hitlist) => {\n+            get_targets_with_hitlist(manifest_path, hitlist, &mut targets)?\n+        }\n     }\n \n     if targets.is_empty() {\n@@ -246,12 +277,24 @@ fn get_targets(strategy: &CargoFmtStrategy) -> Result<BTreeSet<Target>, io::Erro\n     }\n }\n \n-fn get_targets_root_only(targets: &mut BTreeSet<Target>) -> Result<(), io::Error> {\n-    let metadata = get_cargo_metadata(None, false)?;\n-    let current_dir = env::current_dir()?.canonicalize()?;\n-    let current_dir_manifest = current_dir.join(\"Cargo.toml\");\n+fn get_targets_root_only(\n+    manifest_path: Option<&Path>,\n+    targets: &mut BTreeSet<Target>,\n+) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(manifest_path, false)?;\n     let workspace_root_path = PathBuf::from(&metadata.workspace_root).canonicalize()?;\n-    let in_workspace_root = workspace_root_path == current_dir;\n+    let (in_workspace_root, current_dir_manifest) = if let Some(target_manifest) = manifest_path {\n+        (\n+            workspace_root_path == target_manifest,\n+            target_manifest.canonicalize()?,\n+        )\n+    } else {\n+        let current_dir = env::current_dir()?.canonicalize()?;\n+        (\n+            workspace_root_path == current_dir,\n+            current_dir.join(\"Cargo.toml\"),\n+        )\n+    };\n \n     let package_targets = match metadata.packages.len() {\n         1 => metadata.packages.into_iter().next().unwrap().targets,\n@@ -319,10 +362,11 @@ fn get_targets_recursive(\n }\n \n fn get_targets_with_hitlist(\n+    manifest_path: Option<&Path>,\n     hitlist: &[String],\n     targets: &mut BTreeSet<Target>,\n ) -> Result<(), io::Error> {\n-    let metadata = get_cargo_metadata(None, false)?;\n+    let metadata = get_cargo_metadata(manifest_path, false)?;\n \n     let mut workspace_hitlist: BTreeSet<&String> = BTreeSet::from_iter(hitlist);\n "}]}