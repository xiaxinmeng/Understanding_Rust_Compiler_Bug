{"sha": "ec9ade938e9e4aa710f4351e48a8fda1037352aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjOWFkZTkzOGU5ZTRhYTcxMGY0MzUxZTQ4YThmZGExMDM3MzUyYWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-25T01:48:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-08T00:18:07Z"}, "message": "std: Add close_{read,write}() methods to I/O\n\nTwo new methods were added to TcpStream and UnixStream:\n\n    fn close_read(&mut self) -> IoResult<()>;\n    fn close_write(&mut self) -> IoResult<()>;\n\nThese two methods map to shutdown()'s behavior (the system call on unix),\nclosing the reading or writing half of a duplex stream. These methods are\nprimarily added to allow waking up a pending read in another task. By closing\nthe reading half of a connection, all pending readers will be woken up and will\nreturn with EndOfFile. The close_write() method was added for symmetry with\nclose_read(), and I imagine that it will be quite useful at some point.\n\nImplementation-wise, librustuv got the short end of the stick this time. The\nnative versions just delegate to the shutdown() syscall (easy). The uv versions\ncan leverage uv_shutdown() for tcp/unix streams, but only for closing the\nwriting half. Closing the reading half is done through some careful dancing to\nwake up a pending reader.\n\nAs usual, windows likes to be different from unix. The windows implementation\nuses shutdown() for sockets, but shutdown() is not available for named pipes.\nInstead, CancelIoEx was used with same fancy synchronization to make sure\neveryone knows what's up.\n\ncc #11165", "tree": {"sha": "0446a1bf50f2243bba01f7b5a6a964966b31e82c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0446a1bf50f2243bba01f7b5a6a964966b31e82c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec9ade938e9e4aa710f4351e48a8fda1037352aa", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec9ade938e9e4aa710f4351e48a8fda1037352aa", "html_url": "https://github.com/rust-lang/rust/commit/ec9ade938e9e4aa710f4351e48a8fda1037352aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec9ade938e9e4aa710f4351e48a8fda1037352aa/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef6daf9935da103f1b915a5c9904794da79b0b60", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef6daf9935da103f1b915a5c9904794da79b0b60", "html_url": "https://github.com/rust-lang/rust/commit/ef6daf9935da103f1b915a5c9904794da79b0b60"}], "stats": {"total": 632, "additions": 534, "deletions": 98}, "files": [{"sha": "5f67be22068dbd6b94d489e3b8964864228344f4", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -118,7 +118,7 @@ pub use consts::os::bsd44::{SOL_SOCKET, SO_KEEPALIVE, SO_ERROR};\n pub use consts::os::bsd44::{SO_REUSEADDR, SO_BROADCAST, SHUT_WR, IP_MULTICAST_LOOP};\n pub use consts::os::bsd44::{IP_ADD_MEMBERSHIP, IP_DROP_MEMBERSHIP};\n pub use consts::os::bsd44::{IPV6_ADD_MEMBERSHIP, IPV6_DROP_MEMBERSHIP};\n-pub use consts::os::bsd44::{IP_MULTICAST_TTL, IP_TTL};\n+pub use consts::os::bsd44::{IP_MULTICAST_TTL, IP_TTL, SHUT_RD};\n \n pub use funcs::c95::ctype::{isalnum, isalpha, iscntrl, isdigit};\n pub use funcs::c95::ctype::{islower, isprint, ispunct, isspace};\n@@ -226,6 +226,8 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(windows)] pub use consts::os::extra::{FILE_WRITE_ATTRIBUTES, FILE_READ_ATTRIBUTES};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_PIPE_BUSY, ERROR_IO_PENDING};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_PIPE_CONNECTED, WAIT_OBJECT_0};\n+#[cfg(windows)] pub use consts::os::extra::{ERROR_NOT_FOUND};\n+#[cfg(windows)] pub use consts::os::extra::{ERROR_OPERATION_ABORTED};\n #[cfg(windows)] pub use types::os::common::bsd44::{SOCKET};\n #[cfg(windows)] pub use types::os::common::posix01::{stat, utimbuf};\n #[cfg(windows)] pub use types::os::arch::extra::{HANDLE, BOOL, LPSECURITY_ATTRIBUTES};\n@@ -1740,8 +1742,10 @@ pub mod consts {\n             pub static ERROR_NO_DATA: c_int = 232;\n             pub static ERROR_INVALID_ADDRESS : c_int = 487;\n             pub static ERROR_PIPE_CONNECTED: c_int = 535;\n+            pub static ERROR_OPERATION_ABORTED: c_int = 995;\n             pub static ERROR_IO_PENDING: c_int = 997;\n             pub static ERROR_FILE_INVALID : c_int = 1006;\n+            pub static ERROR_NOT_FOUND: c_int = 1168;\n             pub static INVALID_HANDLE_VALUE : c_int = -1;\n \n             pub static DELETE : DWORD = 0x00010000;"}, {"sha": "4fdd05a8b42f8dfaaafc1565f3b235259339e58a", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -61,4 +61,6 @@ extern \"system\" {\n                       optlen: *mut libc::c_int) -> libc::c_int;\n \n     pub fn CancelIo(hFile: libc::HANDLE) -> libc::BOOL;\n+    pub fn CancelIoEx(hFile: libc::HANDLE,\n+                      lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n }"}, {"sha": "84ea0d29434beb4d6b99f0afc0e440ea3af33b78", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -12,12 +12,12 @@\n \n use libc::{c_int, c_void};\n use libc;\n-use std::sync::arc::UnsafeArc;\n use std::c_str::CString;\n use std::io::IoError;\n use std::io;\n use std::mem;\n use std::rt::rtio;\n+use std::sync::arc::UnsafeArc;\n \n use io::{IoResult, retry, keep_going};\n \n@@ -178,6 +178,17 @@ impl rtio::RtioPipe for FileDesc {\n     fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n         box FileDesc { inner: self.inner.clone() } as Box<rtio::RtioPipe:Send>\n     }\n+\n+    // Only supported on named pipes currently. Note that this doesn't have an\n+    // impact on the std::io primitives, this is never called via\n+    // std::io::PipeStream. If the functionality is exposed in the future, then\n+    // these methods will need to be implemented.\n+    fn close_read(&mut self) -> Result<(), IoError> {\n+        Err(io::standard_error(io::InvalidInput))\n+    }\n+    fn close_write(&mut self) -> Result<(), IoError> {\n+        Err(io::standard_error(io::InvalidInput))\n+    }\n }\n \n impl rtio::RtioTTY for FileDesc {"}, {"sha": "c2acd91d476c4c13b77652f577beca512d8a8a8a", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -210,6 +210,17 @@ impl rtio::RtioPipe for FileDesc {\n     fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n         box FileDesc { inner: self.inner.clone() } as Box<rtio::RtioPipe:Send>\n     }\n+\n+    // Only supported on named pipes currently. Note that this doesn't have an\n+    // impact on the std::io primitives, this is never called via\n+    // std::io::PipeStream. If the functionality is exposed in the future, then\n+    // these methods will need to be implemented.\n+    fn close_read(&mut self) -> IoResult<()> {\n+        Err(io::standard_error(io::InvalidInput))\n+    }\n+    fn close_write(&mut self) -> IoResult<()> {\n+        Err(io::standard_error(io::InvalidInput))\n+    }\n }\n \n impl rtio::RtioTTY for FileDesc {"}, {"sha": "a54fe911ae0bd2eaf31afcfa2a70d84d943dc592", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -357,9 +357,10 @@ impl rtio::RtioTcpStream for TcpStream {\n         } as Box<rtio::RtioTcpStream:Send>\n     }\n     fn close_write(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(unsafe {\n-            libc::shutdown(self.fd(), libc::SHUT_WR)\n-        })\n+        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n+    }\n+    fn close_read(&mut self) -> IoResult<()> {\n+        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n     }\n }\n "}, {"sha": "94aca1ef748b4de57243bfa6b301f14138a9c916", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -149,6 +149,13 @@ impl rtio::RtioPipe for UnixStream {\n             inner: self.inner.clone(),\n         } as Box<rtio::RtioPipe:Send>\n     }\n+\n+    fn close_write(&mut self) -> IoResult<()> {\n+        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n+    }\n+    fn close_read(&mut self) -> IoResult<()> {\n+        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "8050123cedcfbc2ee0fdb66e02d433c3316f5024", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 145, "deletions": 30, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -84,13 +84,17 @@\n //! the test suite passing (the suite is in libstd), and that's good enough for\n //! me!\n \n-use std::c_str::CString;\n use libc;\n+use std::c_str::CString;\n+use std::intrinsics;\n+use std::io;\n use std::os::win32::as_utf16_p;\n+use std::os;\n use std::ptr;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n-use std::intrinsics;\n+use std::sync::atomics;\n+use std::unstable::mutex;\n \n use super::IoResult;\n use super::c;\n@@ -124,6 +128,20 @@ impl Drop for Event {\n \n struct Inner {\n     handle: libc::HANDLE,\n+    lock: mutex::NativeMutex,\n+    read_closed: atomics::AtomicBool,\n+    write_closed: atomics::AtomicBool,\n+}\n+\n+impl Inner {\n+    fn new(handle: libc::HANDLE) -> Inner {\n+        Inner {\n+            handle: handle,\n+            lock: unsafe { mutex::NativeMutex::new() },\n+            read_closed: atomics::AtomicBool::new(false),\n+            write_closed: atomics::AtomicBool::new(false),\n+        }\n+    }\n }\n \n impl Drop for Inner {\n@@ -218,7 +236,7 @@ impl UnixStream {\n             loop {\n                 match UnixStream::try_connect(p) {\n                     Some(handle) => {\n-                        let inner = Inner { handle: handle };\n+                        let inner = Inner::new(handle);\n                         let mut mode = libc::PIPE_TYPE_BYTE |\n                                        libc::PIPE_READMODE_BYTE |\n                                        libc::PIPE_WAIT;\n@@ -275,6 +293,24 @@ impl UnixStream {\n     }\n \n     fn handle(&self) -> libc::HANDLE { unsafe { (*self.inner.get()).handle } }\n+\n+    fn read_closed(&self) -> bool {\n+        unsafe { (*self.inner.get()).read_closed.load(atomics::SeqCst) }\n+    }\n+\n+    fn write_closed(&self) -> bool {\n+        unsafe { (*self.inner.get()).write_closed.load(atomics::SeqCst) }\n+    }\n+\n+    fn cancel_io(&self) -> IoResult<()> {\n+        match unsafe { c::CancelIoEx(self.handle(), ptr::mut_null()) } {\n+            0 if os::errno() == libc::ERROR_NOT_FOUND as uint => {\n+                Ok(())\n+            }\n+            0 => Err(super::last_error()),\n+            _ => Ok(())\n+        }\n+    }\n }\n \n impl rtio::RtioPipe for UnixStream {\n@@ -287,31 +323,60 @@ impl rtio::RtioPipe for UnixStream {\n         let mut overlapped: libc::OVERLAPPED = unsafe { intrinsics::init() };\n         overlapped.hEvent = self.read.get_ref().handle();\n \n+        // Pre-flight check to see if the reading half has been closed. This\n+        // must be done before issuing the ReadFile request, but after we\n+        // acquire the lock.\n+        //\n+        // See comments in close_read() about why this lock is necessary.\n+        let guard = unsafe { (*self.inner.get()).lock.lock() };\n+        if self.read_closed() {\n+            return Err(io::standard_error(io::EndOfFile))\n+        }\n+\n+        // Issue a nonblocking requests, succeeding quickly if it happened to\n+        // succeed.\n         let ret = unsafe {\n             libc::ReadFile(self.handle(),\n                            buf.as_ptr() as libc::LPVOID,\n                            buf.len() as libc::DWORD,\n                            &mut bytes_read,\n                            &mut overlapped)\n         };\n-        if ret == 0 {\n-            let err = unsafe { libc::GetLastError() };\n-            if err == libc::ERROR_IO_PENDING as libc::DWORD {\n-                let ret = unsafe {\n-                    libc::GetOverlappedResult(self.handle(),\n-                                              &mut overlapped,\n-                                              &mut bytes_read,\n-                                              libc::TRUE)\n-                };\n-                if ret == 0 {\n-                    return Err(super::last_error())\n-                }\n-            } else {\n+        if ret != 0 { return Ok(bytes_read as uint) }\n+\n+        // If our errno doesn't say that the I/O is pending, then we hit some\n+        // legitimate error and reeturn immediately.\n+        if os::errno() != libc::ERROR_IO_PENDING as uint {\n+            return Err(super::last_error())\n+        }\n+\n+        // Now that we've issued a successful nonblocking request, we need to\n+        // wait for it to finish. This can all be done outside the lock because\n+        // we'll see any invocation of CancelIoEx. We also call this in a loop\n+        // because we're woken up if the writing half is closed, we just need to\n+        // realize that the reading half wasn't closed and we go right back to\n+        // sleep.\n+        drop(guard);\n+        loop {\n+            let ret = unsafe {\n+                libc::GetOverlappedResult(self.handle(),\n+                                          &mut overlapped,\n+                                          &mut bytes_read,\n+                                          libc::TRUE)\n+            };\n+            // If we succeeded, or we failed for some reason other than\n+            // CancelIoEx, return immediately\n+            if ret != 0 { return Ok(bytes_read as uint) }\n+            if os::errno() != libc::ERROR_OPERATION_ABORTED as uint {\n                 return Err(super::last_error())\n             }\n-        }\n \n-        Ok(bytes_read as uint)\n+            // If the reading half is now closed, then we're done. If we woke up\n+            // because the writing half was closed, keep trying.\n+            if self.read_closed() {\n+                return Err(io::standard_error(io::EndOfFile))\n+            }\n+        }\n     }\n \n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n@@ -325,27 +390,47 @@ impl rtio::RtioPipe for UnixStream {\n \n         while offset < buf.len() {\n             let mut bytes_written = 0;\n+\n+            // This sequence below is quite similar to the one found in read().\n+            // Some careful looping is done to ensure that if close_write() is\n+            // invoked we bail out early, and if close_read() is invoked we keep\n+            // going after we woke up.\n+            //\n+            // See comments in close_read() about why this lock is necessary.\n+            let guard = unsafe { (*self.inner.get()).lock.lock() };\n+            if self.write_closed() {\n+                return Err(io::standard_error(io::BrokenPipe))\n+            }\n             let ret = unsafe {\n                 libc::WriteFile(self.handle(),\n                                 buf.slice_from(offset).as_ptr() as libc::LPVOID,\n                                 (buf.len() - offset) as libc::DWORD,\n                                 &mut bytes_written,\n                                 &mut overlapped)\n             };\n+            drop(guard);\n+\n             if ret == 0 {\n-                let err = unsafe { libc::GetLastError() };\n-                if err == libc::ERROR_IO_PENDING as libc::DWORD {\n-                    let ret = unsafe {\n-                        libc::GetOverlappedResult(self.handle(),\n-                                                  &mut overlapped,\n-                                                  &mut bytes_written,\n-                                                  libc::TRUE)\n-                    };\n-                    if ret == 0 {\n+                if os::errno() != libc::ERROR_IO_PENDING as uint {\n+                    return Err(super::last_error())\n+                }\n+                let ret = unsafe {\n+                    libc::GetOverlappedResult(self.handle(),\n+                                              &mut overlapped,\n+                                              &mut bytes_written,\n+                                              libc::TRUE)\n+                };\n+                // If we weren't aborted, this was a legit error, if we were\n+                // aborted, then check to see if the write half was actually\n+                // closed or whether we woke up from the read half closing.\n+                if ret == 0 {\n+                    if os::errno() != libc::ERROR_OPERATION_ABORTED as uint {\n                         return Err(super::last_error())\n                     }\n-                } else {\n-                    return Err(super::last_error())\n+                    if self.write_closed() {\n+                        return Err(io::standard_error(io::BrokenPipe))\n+                    }\n+                    continue; // retry\n                 }\n             }\n             offset += bytes_written as uint;\n@@ -360,6 +445,36 @@ impl rtio::RtioPipe for UnixStream {\n             write: None,\n         } as Box<rtio::RtioPipe:Send>\n     }\n+\n+    fn close_read(&mut self) -> IoResult<()> {\n+        // On windows, there's no actual shutdown() method for pipes, so we're\n+        // forced to emulate the behavior manually at the application level. To\n+        // do this, we need to both cancel any pending requests, as well as\n+        // prevent all future requests from succeeding. These two operations are\n+        // not atomic with respect to one another, so we must use a lock to do\n+        // so.\n+        //\n+        // The read() code looks like:\n+        //\n+        //      1. Make sure the pipe is still open\n+        //      2. Submit a read request\n+        //      3. Wait for the read request to finish\n+        //\n+        // The race this lock is preventing is if another thread invokes\n+        // close_read() between steps 1 and 2. By atomically executing steps 1\n+        // and 2 with a lock with respect to close_read(), we're guaranteed that\n+        // no thread will erroneously sit in a read forever.\n+        let _guard = unsafe { (*self.inner.get()).lock.lock() };\n+        unsafe { (*self.inner.get()).read_closed.store(true, atomics::SeqCst) }\n+        self.cancel_io()\n+    }\n+\n+    fn close_write(&mut self) -> IoResult<()> {\n+        // see comments in close_read() for why this lock is necessary\n+        let _guard = unsafe { (*self.inner.get()).lock.lock() };\n+        unsafe { (*self.inner.get()).write_closed.store(true, atomics::SeqCst) }\n+        self.cancel_io()\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -520,7 +635,7 @@ impl UnixAcceptor {\n \n         // Transfer ownership of our handle into this stream\n         Ok(UnixStream {\n-            inner: UnsafeArc::new(Inner { handle: handle }),\n+            inner: UnsafeArc::new(Inner::new(handle)),\n             read: None,\n             write: None,\n         })"}, {"sha": "f96fa1e5be6e6069ec6f34ad397c1745232bb5f3", "filename": "src/librustuv/access.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -33,6 +33,7 @@ pub struct Guard<'a> {\n struct Inner {\n     queue: Vec<BlockedTask>,\n     held: bool,\n+    closed: bool,\n }\n \n impl Access {\n@@ -41,6 +42,7 @@ impl Access {\n             inner: UnsafeArc::new(Inner {\n                 queue: vec![],\n                 held: false,\n+                closed: false,\n             })\n         }\n     }\n@@ -64,6 +66,15 @@ impl Access {\n \n         Guard { access: self, missile: Some(missile) }\n     }\n+\n+    pub fn close(&self, _missile: &HomingMissile) {\n+        // This unsafety is OK because with a homing missile we're guaranteed to\n+        // be the only task looking at the `closed` flag (and are therefore\n+        // allowed to modify it). Additionally, no atomics are necessary because\n+        // everyone's running on the same thread and has already done the\n+        // necessary synchronization to be running on this thread.\n+        unsafe { (*self.inner.get()).closed = true; }\n+    }\n }\n \n impl Clone for Access {\n@@ -72,6 +83,14 @@ impl Clone for Access {\n     }\n }\n \n+impl<'a> Guard<'a> {\n+    pub fn is_closed(&self) -> bool {\n+        // See above for why this unsafety is ok, it just applies to the read\n+        // instead of the write.\n+        unsafe { (*self.access.inner.get()).closed }\n+    }\n+}\n+\n #[unsafe_destructor]\n impl<'a> Drop for Guard<'a> {\n     fn drop(&mut self) {"}, {"sha": "0ddf50921fdd23375e5e6c4bbd7e9d7cb373dd50", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 57, "deletions": 43, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -11,6 +11,7 @@\n use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n use libc;\n use std::cast;\n+use std::io;\n use std::io::{IoError, IoResult};\n use std::io::net::ip;\n use std::mem;\n@@ -411,7 +412,13 @@ impl rtio::RtioSocket for TcpWatcher {\n impl rtio::RtioTcpStream for TcpWatcher {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let m = self.fire_homing_missile();\n-        let _g = self.read_access.grant(m);\n+        let access = self.read_access.grant(m);\n+\n+        // see comments in close_read about this check\n+        if access.is_closed() {\n+            return Err(io::standard_error(io::EndOfFile))\n+        }\n+\n         self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n \n@@ -466,36 +473,17 @@ impl rtio::RtioTcpStream for TcpWatcher {\n         } as Box<rtio::RtioTcpStream:Send>\n     }\n \n-    fn close_write(&mut self) -> Result<(), IoError> {\n-        struct Ctx {\n-            slot: Option<BlockedTask>,\n-            status: c_int,\n-        }\n-        let mut req = Request::new(uvll::UV_SHUTDOWN);\n-\n-        return match unsafe {\n-            uvll::uv_shutdown(req.handle, self.handle, shutdown_cb)\n-        } {\n-            0 => {\n-                req.defuse(); // uv callback now owns this request\n-                let mut cx = Ctx { slot: None, status: 0 };\n-\n-                wait_until_woken_after(&mut cx.slot, &self.uv_loop(), || {\n-                    req.set_data(&cx);\n-                });\n-\n-                status_to_io_result(cx.status)\n-            }\n-            n => Err(uv_error_to_io_error(UvError(n)))\n-        };\n+    fn close_read(&mut self) -> Result<(), IoError> {\n+        // see comments in PipeWatcher::close_read\n+        let m = self.fire_homing_missile();\n+        self.read_access.close(&m);\n+        self.stream.cancel_read(m);\n+        Ok(())\n+    }\n \n-        extern fn shutdown_cb(req: *uvll::uv_shutdown_t, status: libc::c_int) {\n-            let req = Request::wrap(req);\n-            assert!(status != uvll::ECANCELED);\n-            let cx: &mut Ctx = unsafe { req.get_data() };\n-            cx.status = status;\n-            wakeup(&mut cx.slot);\n-        }\n+    fn close_write(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_homing_missile();\n+        shutdown(self.handle, &self.uv_loop())\n     }\n }\n \n@@ -704,7 +692,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         let m = self.fire_homing_missile();\n         let _g = self.read_access.grant(m);\n \n-        let a = match unsafe {\n+        return match unsafe {\n             uvll::uv_udp_recv_start(self.handle, alloc_cb, recv_cb)\n         } {\n             0 => {\n@@ -725,23 +713,21 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             }\n             n => Err(uv_error_to_io_error(UvError(n)))\n         };\n-        return a;\n \n         extern fn alloc_cb(handle: *uvll::uv_udp_t,\n                            _suggested_size: size_t,\n                            buf: *mut Buf) {\n             unsafe {\n-                let cx: &mut Ctx =\n-                    cast::transmute(uvll::get_data_for_uv_handle(handle));\n+                let cx = &mut *(uvll::get_data_for_uv_handle(handle) as *mut Ctx);\n                 *buf = cx.buf.take().expect(\"recv alloc_cb called more than once\")\n             }\n         }\n \n         extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: *Buf,\n                           addr: *libc::sockaddr, _flags: c_uint) {\n             assert!(nread != uvll::ECANCELED as ssize_t);\n-            let cx: &mut Ctx = unsafe {\n-                cast::transmute(uvll::get_data_for_uv_handle(handle))\n+            let cx = unsafe {\n+                &mut *(uvll::get_data_for_uv_handle(handle) as *mut Ctx)\n             };\n \n             // When there's no data to read the recv callback can be a no-op.\n@@ -752,13 +738,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                 return\n             }\n \n-            unsafe {\n-                assert_eq!(uvll::uv_udp_recv_stop(handle), 0)\n-            }\n-\n-            let cx: &mut Ctx = unsafe {\n-                cast::transmute(uvll::get_data_for_uv_handle(handle))\n-            };\n+            unsafe { assert_eq!(uvll::uv_udp_recv_stop(handle), 0) }\n             let addr = if addr == ptr::null() {\n                 None\n             } else {\n@@ -900,6 +880,40 @@ impl Drop for UdpWatcher {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Shutdown helper\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub fn shutdown(handle: *uvll::uv_stream_t, loop_: &Loop) -> Result<(), IoError> {\n+    struct Ctx {\n+        slot: Option<BlockedTask>,\n+        status: c_int,\n+    }\n+    let mut req = Request::new(uvll::UV_SHUTDOWN);\n+\n+    return match unsafe { uvll::uv_shutdown(req.handle, handle, shutdown_cb) } {\n+        0 => {\n+            req.defuse(); // uv callback now owns this request\n+            let mut cx = Ctx { slot: None, status: 0 };\n+\n+            wait_until_woken_after(&mut cx.slot, loop_, || {\n+                req.set_data(&cx);\n+            });\n+\n+            status_to_io_result(cx.status)\n+        }\n+        n => Err(uv_error_to_io_error(UvError(n)))\n+    };\n+\n+    extern fn shutdown_cb(req: *uvll::uv_shutdown_t, status: libc::c_int) {\n+        let req = Request::wrap(req);\n+        assert!(status != uvll::ECANCELED);\n+        let cx: &mut Ctx = unsafe { req.get_data() };\n+        cx.status = status;\n+        wakeup(&mut cx.slot);\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioTcpAcceptor,"}, {"sha": "7fec4051761de5604bba8eac589148f6a6a9d10b", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -11,6 +11,7 @@\n use libc;\n use std::c_str::CString;\n use std::io::IoError;\n+use std::io;\n use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n \n use access::Access;\n@@ -111,7 +112,13 @@ impl PipeWatcher {\n impl RtioPipe for PipeWatcher {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let m = self.fire_homing_missile();\n-        let _g = self.read_access.grant(m);\n+        let access = self.read_access.grant(m);\n+\n+        // see comments in close_read about this check\n+        if access.is_closed() {\n+            return Err(io::standard_error(io::EndOfFile))\n+        }\n+\n         self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n \n@@ -131,6 +138,35 @@ impl RtioPipe for PipeWatcher {\n             write_access: self.write_access.clone(),\n         } as Box<RtioPipe:Send>\n     }\n+\n+    fn close_read(&mut self) -> Result<(), IoError> {\n+        // The current uv_shutdown method only shuts the writing half of the\n+        // connection, and no method is provided to shut down the reading half\n+        // of the connection. With a lack of method, we emulate shutting down\n+        // the reading half of the connection by manually returning early from\n+        // all future calls to `read`.\n+        //\n+        // Note that we must be careful to ensure that *all* cloned handles see\n+        // the closing of the read half, so we stored the \"is closed\" bit in the\n+        // Access struct, not in our own personal watcher. Additionally, the\n+        // homing missile is used as a locking mechanism to ensure there is no\n+        // contention over this bit.\n+        //\n+        // To shutdown the read half, we must first flag the access as being\n+        // closed, and then afterwards we cease any pending read. Note that this\n+        // ordering is crucial because we could in theory be rescheduled during\n+        // the uv_read_stop which means that another read invocation could leak\n+        // in before we set the flag.\n+        let m = self.fire_homing_missile();\n+        self.read_access.close(&m);\n+        self.stream.cancel_read(m);\n+        Ok(())\n+    }\n+\n+    fn close_write(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_homing_missile();\n+        net::shutdown(self.stream.handle, &self.uv_loop())\n+    }\n }\n \n impl HomingIO for PipeWatcher {"}, {"sha": "a1b606709d87d95609e491c60b4adbd985c33cfa", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -14,6 +14,7 @@ use std::ptr;\n use std::rt::task::BlockedTask;\n \n use Loop;\n+use homing::HomingMissile;\n use super::{UvError, Buf, slice_to_uv_buf, Request, wait_until_woken_after,\n             ForbidUnwind, wakeup};\n use uvll;\n@@ -57,6 +58,7 @@ impl StreamWatcher {\n     // Wrappers should ensure to always reset the field to an appropriate value\n     // if they rely on the field to perform an action.\n     pub fn new(stream: *uvll::uv_stream_t) -> StreamWatcher {\n+        unsafe { uvll::set_data_for_uv_handle(stream, 0 as *int) }\n         StreamWatcher {\n             handle: stream,\n             last_write_req: None,\n@@ -70,21 +72,21 @@ impl StreamWatcher {\n \n         let mut rcx = ReadContext {\n             buf: Some(slice_to_uv_buf(buf)),\n-            result: 0,\n+            // if the read is canceled, we'll see eof, otherwise this will get\n+            // overwritten\n+            result: uvll::EOF as ssize_t,\n             task: None,\n         };\n         // When reading a TTY stream on windows, libuv will invoke alloc_cb\n         // immediately as part of the call to alloc_cb. What this means is that\n         // we must be ready for this to happen (by setting the data in the uv\n         // handle). In theory this otherwise doesn't need to happen until after\n         // the read is succesfully started.\n-        unsafe {\n-            uvll::set_data_for_uv_handle(self.handle, &rcx)\n-        }\n+        unsafe { uvll::set_data_for_uv_handle(self.handle, &rcx) }\n \n         // Send off the read request, but don't block until we're sure that the\n         // read request is queued.\n-        match unsafe {\n+        let ret = match unsafe {\n             uvll::uv_read_start(self.handle, alloc_cb, read_cb)\n         } {\n             0 => {\n@@ -96,6 +98,29 @@ impl StreamWatcher {\n                 }\n             }\n             n => Err(UvError(n))\n+        };\n+        // Make sure a read cancellation sees that there's no pending read\n+        unsafe { uvll::set_data_for_uv_handle(self.handle, 0 as *int) }\n+        return ret;\n+    }\n+\n+    pub fn cancel_read(&mut self, m: HomingMissile) {\n+        // When we invoke uv_read_stop, it cancels the read and alloc\n+        // callbacks. We need to manually wake up a pending task (if one was\n+        // present). Note that we wake up the task *outside* the homing missile\n+        // to ensure that we don't switch schedulers when we're not supposed to.\n+        assert_eq!(unsafe { uvll::uv_read_stop(self.handle) }, 0);\n+        let data = unsafe {\n+            let data = uvll::get_data_for_uv_handle(self.handle);\n+            if data.is_null() { return }\n+            uvll::set_data_for_uv_handle(self.handle, 0 as *int);\n+            &mut *(data as *mut ReadContext)\n+        };\n+        let task = data.task.take();\n+        drop(m);\n+        match task {\n+            Some(task) => { let _ = task.wake().map(|t| t.reawaken()); }\n+            None => {}\n         }\n     }\n "}, {"sha": "d07b2e556d612bd2830620ae0d51ff4343904946", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 110, "deletions": 3, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -32,7 +32,7 @@ use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n ///\n /// # Example\n ///\n-/// ```rust\n+/// ```no_run\n /// # #![allow(unused_must_use)]\n /// use std::io::net::tcp::TcpStream;\n /// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n@@ -109,6 +109,48 @@ impl TcpStream {\n             None => self.obj.letdie(),\n         }\n     }\n+\n+    /// Closes the reading half of this connection.\n+    ///\n+    /// This method will close the reading portion of this connection, causing\n+    /// all pending and future reads to immediately return with an error.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// # #![allow(unused_must_use)]\n+    /// use std::io::timer;\n+    /// use std::io::net::tcp::TcpStream;\n+    /// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+    ///\n+    /// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n+    /// let mut stream = TcpStream::connect(addr).unwrap();\n+    /// let stream2 = stream.clone();\n+    ///\n+    /// spawn(proc() {\n+    ///     // close this stream after one second\n+    ///     timer::sleep(1000);\n+    ///     let mut stream = stream2;\n+    ///     stream.close_read();\n+    /// });\n+    ///\n+    /// // wait for some data, will get canceled after one second\n+    /// let mut buf = [0];\n+    /// stream.read(buf);\n+    /// ```\n+    ///\n+    /// Note that this method affects all cloned handles associated with this\n+    /// stream, not just this one handle.\n+    pub fn close_read(&mut self) -> IoResult<()> { self.obj.close_read() }\n+\n+    /// Closes the writing half of this connection.\n+    ///\n+    /// This method will close the writing portion of this connection, causing\n+    /// all future writes to immediately return with an error.\n+    ///\n+    /// Note that this method affects all cloned handles associated with this\n+    /// stream, not just this one handle.\n+    pub fn close_write(&mut self) -> IoResult<()> { self.obj.close_write() }\n }\n \n impl Clone for TcpStream {\n@@ -839,7 +881,11 @@ mod test {\n \n         // Also make sure that even though the timeout is expired that we will\n         // continue to receive any pending connections.\n-        let l = TcpStream::connect(addr).unwrap();\n+        let (tx, rx) = channel();\n+        spawn(proc() {\n+            tx.send(TcpStream::connect(addr).unwrap());\n+        });\n+        let l = rx.recv();\n         for i in range(0, 1001) {\n             match a.accept() {\n                 Ok(..) => break,\n@@ -853,8 +899,69 @@ mod test {\n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n         spawn(proc() {\n-            drop(TcpStream::connect(addr));\n+            drop(TcpStream::connect(addr).unwrap());\n         });\n         a.accept().unwrap();\n     })\n+\n+    iotest!(fn close_readwrite_smoke() {\n+        let addr = next_test_ip4();\n+        let a = TcpListener::bind(addr).listen().unwrap();\n+        let (_tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut a = a;\n+            let _s = a.accept().unwrap();\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut b = [0];\n+        let mut s = TcpStream::connect(addr).unwrap();\n+        let mut s2 = s.clone();\n+\n+        // closing should prevent reads/writes\n+        s.close_write().unwrap();\n+        assert!(s.write([0]).is_err());\n+        s.close_read().unwrap();\n+        assert!(s.read(b).is_err());\n+\n+        // closing should affect previous handles\n+        assert!(s2.write([0]).is_err());\n+        assert!(s2.read(b).is_err());\n+\n+        // closing should affect new handles\n+        let mut s3 = s.clone();\n+        assert!(s3.write([0]).is_err());\n+        assert!(s3.read(b).is_err());\n+\n+        // make sure these don't die\n+        let _ = s2.close_read();\n+        let _ = s2.close_write();\n+        let _ = s3.close_read();\n+        let _ = s3.close_write();\n+    })\n+\n+    iotest!(fn close_read_wakes_up() {\n+        let addr = next_test_ip4();\n+        let a = TcpListener::bind(addr).listen().unwrap();\n+        let (_tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut a = a;\n+            let _s = a.accept().unwrap();\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = TcpStream::connect(addr).unwrap();\n+        let s2 = s.clone();\n+        let (tx, rx) = channel();\n+        spawn(proc() {\n+            let mut s2 = s2;\n+            assert!(s2.read([0]).is_err());\n+            tx.send(());\n+        });\n+        // this should wake up the child task\n+        s.close_read().unwrap();\n+\n+        // this test will never finish if the child doesn't wake up\n+        rx.recv();\n+    })\n }"}, {"sha": "bbe39885c030c39f53892b205adbba58217aadbc", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 91, "deletions": 11, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -28,7 +28,6 @@ use prelude::*;\n \n use c_str::ToCStr;\n use clone::Clone;\n-use io::pipe::PipeStream;\n use io::{Listener, Acceptor, Reader, Writer, IoResult};\n use kinds::Send;\n use owned::Box;\n@@ -37,14 +36,10 @@ use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n \n /// A stream which communicates over a named pipe.\n pub struct UnixStream {\n-    obj: PipeStream,\n+    obj: Box<RtioPipe:Send>,\n }\n \n impl UnixStream {\n-    fn new(obj: Box<RtioPipe:Send>) -> UnixStream {\n-        UnixStream { obj: PipeStream::new(obj) }\n-    }\n-\n     /// Connect to a pipe named by `path`. This will attempt to open a\n     /// connection to the underlying socket.\n     ///\n@@ -62,7 +57,7 @@ impl UnixStream {\n     /// ```\n     pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> {\n         LocalIo::maybe_raise(|io| {\n-            io.unix_connect(&path.to_c_str(), None).map(UnixStream::new)\n+            io.unix_connect(&path.to_c_str(), None).map(|p| UnixStream { obj: p })\n         })\n     }\n \n@@ -86,9 +81,28 @@ impl UnixStream {\n                                       timeout_ms: u64) -> IoResult<UnixStream> {\n         LocalIo::maybe_raise(|io| {\n             let s = io.unix_connect(&path.to_c_str(), Some(timeout_ms));\n-            s.map(UnixStream::new)\n+            s.map(|p| UnixStream { obj: p })\n         })\n     }\n+\n+\n+    /// Closes the reading half of this connection.\n+    ///\n+    /// This method will close the reading portion of this connection, causing\n+    /// all pending and future reads to immediately return with an error.\n+    ///\n+    /// Note that this method affects all cloned handles associated with this\n+    /// stream, not just this one handle.\n+    pub fn close_read(&mut self) -> IoResult<()> { self.obj.close_read() }\n+\n+    /// Closes the writing half of this connection.\n+    ///\n+    /// This method will close the writing portion of this connection, causing\n+    /// all pending and future writes to immediately return with an error.\n+    ///\n+    /// Note that this method affects all cloned handles associated with this\n+    /// stream, not just this one handle.\n+    pub fn close_write(&mut self) -> IoResult<()> { self.obj.close_write() }\n }\n \n impl Clone for UnixStream {\n@@ -174,7 +188,7 @@ impl UnixAcceptor {\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n     fn accept(&mut self) -> IoResult<UnixStream> {\n-        self.obj.accept().map(UnixStream::new)\n+        self.obj.accept().map(|s| UnixStream { obj: s })\n     }\n }\n \n@@ -431,7 +445,12 @@ mod tests {\n \n         // Also make sure that even though the timeout is expired that we will\n         // continue to receive any pending connections.\n-        let l = UnixStream::connect(&addr).unwrap();\n+        let (tx, rx) = channel();\n+        let addr2 = addr.clone();\n+        spawn(proc() {\n+            tx.send(UnixStream::connect(&addr2).unwrap());\n+        });\n+        let l = rx.recv();\n         for i in range(0, 1001) {\n             match a.accept() {\n                 Ok(..) => break,\n@@ -446,7 +465,7 @@ mod tests {\n         a.set_timeout(None);\n         let addr2 = addr.clone();\n         spawn(proc() {\n-            drop(UnixStream::connect(&addr2));\n+            drop(UnixStream::connect(&addr2).unwrap());\n         });\n         a.accept().unwrap();\n     })\n@@ -461,4 +480,65 @@ mod tests {\n         let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n         assert!(UnixStream::connect_timeout(&addr, 100).is_ok());\n     })\n+\n+    iotest!(fn close_readwrite_smoke() {\n+        let addr = next_test_unix();\n+        let a = UnixListener::bind(&addr).listen().unwrap();\n+        let (_tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut a = a;\n+            let _s = a.accept().unwrap();\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut b = [0];\n+        let mut s = UnixStream::connect(&addr).unwrap();\n+        let mut s2 = s.clone();\n+\n+        // closing should prevent reads/writes\n+        s.close_write().unwrap();\n+        assert!(s.write([0]).is_err());\n+        s.close_read().unwrap();\n+        assert!(s.read(b).is_err());\n+\n+        // closing should affect previous handles\n+        assert!(s2.write([0]).is_err());\n+        assert!(s2.read(b).is_err());\n+\n+        // closing should affect new handles\n+        let mut s3 = s.clone();\n+        assert!(s3.write([0]).is_err());\n+        assert!(s3.read(b).is_err());\n+\n+        // make sure these don't die\n+        let _ = s2.close_read();\n+        let _ = s2.close_write();\n+        let _ = s3.close_read();\n+        let _ = s3.close_write();\n+    })\n+\n+    iotest!(fn close_read_wakes_up() {\n+        let addr = next_test_unix();\n+        let a = UnixListener::bind(&addr).listen().unwrap();\n+        let (_tx, rx) = channel::<()>();\n+        spawn(proc() {\n+            let mut a = a;\n+            let _s = a.accept().unwrap();\n+            let _ = rx.recv_opt();\n+        });\n+\n+        let mut s = UnixStream::connect(&addr).unwrap();\n+        let s2 = s.clone();\n+        let (tx, rx) = channel();\n+        spawn(proc() {\n+            let mut s2 = s2;\n+            assert!(s2.read([0]).is_err());\n+            tx.send(());\n+        });\n+        // this should wake up the child task\n+        s.close_read().unwrap();\n+\n+        // this test will never finish if the child doesn't wake up\n+        rx.recv();\n+    })\n }"}, {"sha": "c5afe7887adc53dfd1a592c87ff6c83921b12f59", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9ade938e9e4aa710f4351e48a8fda1037352aa/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=ec9ade938e9e4aa710f4351e48a8fda1037352aa", "patch": "@@ -221,6 +221,7 @@ pub trait RtioTcpStream : RtioSocket {\n     fn letdie(&mut self) -> IoResult<()>;\n     fn clone(&self) -> Box<RtioTcpStream:Send>;\n     fn close_write(&mut self) -> IoResult<()>;\n+    fn close_read(&mut self) -> IoResult<()>;\n }\n \n pub trait RtioSocket {\n@@ -274,6 +275,9 @@ pub trait RtioPipe {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n     fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n     fn clone(&self) -> Box<RtioPipe:Send>;\n+\n+    fn close_write(&mut self) -> IoResult<()>;\n+    fn close_read(&mut self) -> IoResult<()>;\n }\n \n pub trait RtioUnixListener {"}]}