{"sha": "c0df1c8c432e856c4317c5c7585c86c54bcb46a2", "node_id": "C_kwDOAAsO6NoAKGMwZGYxYzhjNDMyZTg1NmM0MzE3YzVjNzU4NWM4NmM1NGJjYjQ2YTI", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-11-15T18:50:11Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-06-14T07:24:51Z"}, "message": "remove drain-on-drop behavior from vec::DrainFilter and add #[must_use]", "tree": {"sha": "474ad9d4f0515a218559d7a49ab75055d24a2a16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/474ad9d4f0515a218559d7a49ab75055d24a2a16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0df1c8c432e856c4317c5c7585c86c54bcb46a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0df1c8c432e856c4317c5c7585c86c54bcb46a2", "html_url": "https://github.com/rust-lang/rust/commit/c0df1c8c432e856c4317c5c7585c86c54bcb46a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa8762b7b6c2b75d6c83fb011ee8fa4874168829", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa8762b7b6c2b75d6c83fb011ee8fa4874168829", "html_url": "https://github.com/rust-lang/rust/commit/fa8762b7b6c2b75d6c83fb011ee8fa4874168829"}], "stats": {"total": 163, "additions": 32, "deletions": 131}, "files": [{"sha": "bf8ad5faac48219b13be34d004ba2c4a6318367a", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=c0df1c8c432e856c4317c5c7585c86c54bcb46a2", "patch": "@@ -753,20 +753,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        errors.drain_filter(|error| {\n+        errors.retain(|error| {\n             let Error::Invalid(\n                 provided_idx,\n                 expected_idx,\n                 Compatibility::Incompatible(Some(e)),\n-            ) = error else { return false };\n+            ) = error else { return true };\n             let (provided_ty, provided_span) = provided_arg_tys[*provided_idx];\n             let trace =\n                 mk_trace(provided_span, formal_and_expected_inputs[*expected_idx], provided_ty);\n             if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308) {\n                 self.err_ctxt().report_and_explain_type_error(trace, *e).emit();\n-                return true;\n+                return false;\n             }\n-            false\n+            true\n         });\n \n         // We're done if we found errors, but we already emitted them."}, {"sha": "0a1e971f268e3cce987585257e439ad65689c878", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=c0df1c8c432e856c4317c5c7585c86c54bcb46a2", "patch": "@@ -1170,11 +1170,11 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             };\n \n             let mut deduped: SsoHashSet<_> = Default::default();\n-            result.obligations.drain_filter(|projected_obligation| {\n+            result.obligations.retain(|projected_obligation| {\n                 if !deduped.insert(projected_obligation.clone()) {\n-                    return true;\n+                    return false;\n                 }\n-                false\n+                true\n             });\n \n             if use_cache {"}, {"sha": "ebee3d6eca0882dfae5357c8ebd47f54ee2252a2", "filename": "library/alloc/src/vec/drain_filter.rs", "status": "modified", "additions": 15, "deletions": 91, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs?ref=c0df1c8c432e856c4317c5c7585c86c54bcb46a2", "patch": "@@ -1,5 +1,4 @@\n use crate::alloc::{Allocator, Global};\n-use core::mem::{ManuallyDrop, SizedTypeProperties};\n use core::ptr;\n use core::slice;\n \n@@ -20,6 +19,7 @@ use super::Vec;\n /// ```\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n #[derive(Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct DrainFilter<\n     'a,\n     T,\n@@ -55,59 +55,6 @@ where\n     pub fn allocator(&self) -> &A {\n         self.vec.allocator()\n     }\n-\n-    /// Keep unyielded elements in the source `Vec`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(drain_filter)]\n-    /// #![feature(drain_keep_rest)]\n-    ///\n-    /// let mut vec = vec!['a', 'b', 'c'];\n-    /// let mut drain = vec.drain_filter(|_| true);\n-    ///\n-    /// assert_eq!(drain.next().unwrap(), 'a');\n-    ///\n-    /// // This call keeps 'b' and 'c' in the vec.\n-    /// drain.keep_rest();\n-    ///\n-    /// // If we wouldn't call `keep_rest()`,\n-    /// // `vec` would be empty.\n-    /// assert_eq!(vec, ['b', 'c']);\n-    /// ```\n-    #[unstable(feature = \"drain_keep_rest\", issue = \"101122\")]\n-    pub fn keep_rest(self) {\n-        // At this moment layout looks like this:\n-        //\n-        //  _____________________/-- old_len\n-        // /                     \\\n-        // [kept] [yielded] [tail]\n-        //        \\_______/ ^-- idx\n-        //                \\-- del\n-        //\n-        // Normally `Drop` impl would drop [tail] (via .for_each(drop), ie still calling `pred`)\n-        //\n-        // 1. Move [tail] after [kept]\n-        // 2. Update length of the original vec to `old_len - del`\n-        //    a. In case of ZST, this is the only thing we want to do\n-        // 3. Do *not* drop self, as everything is put in a consistent state already, there is nothing to do\n-        let mut this = ManuallyDrop::new(self);\n-\n-        unsafe {\n-            // ZSTs have no identity, so we don't need to move them around.\n-            if !T::IS_ZST && this.idx < this.old_len && this.del > 0 {\n-                let ptr = this.vec.as_mut_ptr();\n-                let src = ptr.add(this.idx);\n-                let dst = src.sub(this.del);\n-                let tail_len = this.old_len - this.idx;\n-                src.copy_to(dst, tail_len);\n-            }\n-\n-            let new_len = this.old_len - this.del;\n-            this.vec.set_len(new_len);\n-        }\n-    }\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n@@ -154,44 +101,21 @@ where\n     F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n-        struct BackshiftOnDrop<'a, 'b, T, F, A: Allocator>\n-        where\n-            F: FnMut(&mut T) -> bool,\n-        {\n-            drain: &'b mut DrainFilter<'a, T, F, A>,\n-        }\n-\n-        impl<'a, 'b, T, F, A: Allocator> Drop for BackshiftOnDrop<'a, 'b, T, F, A>\n-        where\n-            F: FnMut(&mut T) -> bool,\n-        {\n-            fn drop(&mut self) {\n-                unsafe {\n-                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n-                        // This is a pretty messed up state, and there isn't really an\n-                        // obviously right thing to do. We don't want to keep trying\n-                        // to execute `pred`, so we just backshift all the unprocessed\n-                        // elements and tell the vec that they still exist. The backshift\n-                        // is required to prevent a double-drop of the last successfully\n-                        // drained item prior to a panic in the predicate.\n-                        let ptr = self.drain.vec.as_mut_ptr();\n-                        let src = ptr.add(self.drain.idx);\n-                        let dst = src.sub(self.drain.del);\n-                        let tail_len = self.drain.old_len - self.drain.idx;\n-                        src.copy_to(dst, tail_len);\n-                    }\n-                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n-                }\n+        unsafe {\n+            if self.idx < self.old_len && self.del > 0 {\n+                // This is a pretty messed up state, and there isn't really an\n+                // obviously right thing to do. We don't want to keep trying\n+                // to execute `pred`, so we just backshift all the unprocessed\n+                // elements and tell the vec that they still exist. The backshift\n+                // is required to prevent a double-drop of the last successfully\n+                // drained item prior to a panic in the predicate.\n+                let ptr = self.vec.as_mut_ptr();\n+                let src = ptr.add(self.idx);\n+                let dst = src.sub(self.del);\n+                let tail_len = self.old_len - self.idx;\n+                src.copy_to(dst, tail_len);\n             }\n-        }\n-\n-        let backshift = BackshiftOnDrop { drain: self };\n-\n-        // Attempt to consume any remaining elements if the filter predicate\n-        // has not yet panicked. We'll backshift any remaining elements\n-        // whether we've already panicked or if the consumption here panics.\n-        if !backshift.drain.panic_flag {\n-            backshift.drain.for_each(drop);\n+            self.vec.set_len(self.old_len - self.del);\n         }\n     }\n }"}, {"sha": "75f1a96c4c4473cc0e3af489c04bf33b75ac418a", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=c0df1c8c432e856c4317c5c7585c86c54bcb46a2", "patch": "@@ -2892,6 +2892,12 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// If the closure returns false, the element will remain in the vector and will not be yielded\n     /// by the iterator.\n     ///\n+    /// If the returned `DrainFilter` is not exhausted, e.g. because it is dropped without iterating\n+    /// or the iteration short-circuits, then the remaining elements will be retained.\n+    /// Use [`retain`] with a negated predicate if you do not need the returned iterator.\n+    ///\n+    /// [`retain`]: Vec::retain\n+    ///\n     /// Using this method is equivalent to the following code:\n     ///\n     /// ```"}, {"sha": "acb744ad9a0816f17994a2103219e5be01ee2039", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=c0df1c8c432e856c4317c5c7585c86c54bcb46a2", "patch": "@@ -1608,36 +1608,7 @@ fn drain_filter_unconsumed() {\n     let mut vec = vec![1, 2, 3, 4];\n     let drain = vec.drain_filter(|&mut x| x % 2 != 0);\n     drop(drain);\n-    assert_eq!(vec, [2, 4]);\n-}\n-\n-#[test]\n-fn test_drain_filter_keep_rest() {\n-    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n-    let mut drain = v.drain_filter(|&mut x| x % 2 == 0);\n-    assert_eq!(drain.next(), Some(0));\n-    assert_eq!(drain.next(), Some(2));\n-\n-    drain.keep_rest();\n-    assert_eq!(v, &[1, 3, 4, 5, 6]);\n-}\n-\n-#[test]\n-fn test_drain_filter_keep_rest_all() {\n-    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n-    v.drain_filter(|_| true).keep_rest();\n-    assert_eq!(v, &[0, 1, 2, 3, 4, 5, 6]);\n-}\n-\n-#[test]\n-fn test_drain_filter_keep_rest_none() {\n-    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n-    let mut drain = v.drain_filter(|_| true);\n-\n-    drain.by_ref().for_each(drop);\n-\n-    drain.keep_rest();\n-    assert_eq!(v, &[]);\n+    assert_eq!(vec, [1, 2, 3, 4]);\n }\n \n #[test]"}, {"sha": "870cfa93058aad3596757a5e0bd2e33b241797dc", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0df1c8c432e856c4317c5c7585c86c54bcb46a2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c0df1c8c432e856c4317c5c7585c86c54bcb46a2", "patch": "@@ -158,13 +158,13 @@ pub(crate) fn try_inline_glob(\n                 .filter_map(|child| child.res.opt_def_id())\n                 .collect();\n             let mut items = build_module_items(cx, did, visited, inlined_names, Some(&reexports));\n-            items.drain_filter(|item| {\n+            items.retain(|item| {\n                 if let Some(name) = item.name {\n                     // If an item with the same type and name already exists,\n                     // it takes priority over the inlined stuff.\n-                    !inlined_names.insert((item.type_(), name))\n+                    inlined_names.insert((item.type_(), name))\n                 } else {\n-                    false\n+                    true\n                 }\n             });\n             Some(items)"}]}