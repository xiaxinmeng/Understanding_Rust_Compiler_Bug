{"sha": "2f1df3cd74603bf1ba7f2e1c8833407a176cc66e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMWRmM2NkNzQ2MDNiZjFiYTdmMmUxYzg4MzM0MDdhMTc2Y2M2NmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-15T17:32:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-15T17:32:34Z"}, "message": "Merge #2855\n\n2855: More fluent API r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "3fd74d1aa420b04f5c9e3aaf84ebb62e553ddb9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fd74d1aa420b04f5c9e3aaf84ebb62e553ddb9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeH0yyCRBK7hj4Ov3rIwAAdHIIAGd8+5Xjo5YYkqZCn2m4VvDO\nEGrg9uMJMewtGpfvCKeriGWSmaEMR/XjJZfOzD6j/aFXzmEMtSVYAbO1nEst0nRb\nlAPCN7ecsWeGHOFpTa95oCsg8GcW42FHPFhkeZ4NzFBr5N397oATYtQYXS/7jrHK\nuVmm0msISq+qWYii30OEXTCypg/R2sj/uO8dqAReQwo1xJV/FDBjhdiUVE7PBzDr\nM25qdXkdGkauDws90Kmzv6RT8Tc0giE88YvZbT8dLLC/chCrh4bwTwq9Jy8Wj7YL\nA3IqakzjdkVEXfBqk6KzVIIybpGH1YOY03mIijg8tBEAkG5R/3oEQfH7waFF7qs=\n=wBUB\n-----END PGP SIGNATURE-----\n", "payload": "tree 3fd74d1aa420b04f5c9e3aaf84ebb62e553ddb9c\nparent c0661ce7444223b0fff1f5d54adb41022ab788cb\nparent 7d2d3ac3db6ea7bbb3d77569495176da3b2992e6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1579109554 +0000\ncommitter GitHub <noreply@github.com> 1579109554 +0000\n\nMerge #2855\n\n2855: More fluent API r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e", "html_url": "https://github.com/rust-lang/rust/commit/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0661ce7444223b0fff1f5d54adb41022ab788cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0661ce7444223b0fff1f5d54adb41022ab788cb", "html_url": "https://github.com/rust-lang/rust/commit/c0661ce7444223b0fff1f5d54adb41022ab788cb"}, {"sha": "7d2d3ac3db6ea7bbb3d77569495176da3b2992e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d2d3ac3db6ea7bbb3d77569495176da3b2992e6", "html_url": "https://github.com/rust-lang/rust/commit/7d2d3ac3db6ea7bbb3d77569495176da3b2992e6"}], "stats": {"total": 96, "additions": 48, "deletions": 48}, "files": [{"sha": "8cc2fb160d374541865cae898e99464800b77fe2", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=2f1df3cd74603bf1ba7f2e1c8833407a176cc66e", "patch": "@@ -35,7 +35,7 @@ fn find_path_inner(\n     let def_map = db.crate_def_map(from.krate);\n     let from_scope: &crate::item_scope::ItemScope = &def_map.modules[from.local_id].scope;\n     if let Some((name, _)) = from_scope.name_of(item) {\n-        return Some(ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]));\n+        return Some(ModPath::from_segments(PathKind::Plain, vec![name.clone()]));\n     }\n \n     // - if the item is the crate root, return `crate`\n@@ -45,12 +45,12 @@ fn find_path_inner(\n             local_id: def_map.root,\n         }))\n     {\n-        return Some(ModPath::from_simple_segments(PathKind::Crate, Vec::new()));\n+        return Some(ModPath::from_segments(PathKind::Crate, Vec::new()));\n     }\n \n     // - if the item is the module we're in, use `self`\n     if item == ItemInNs::Types(from.into()) {\n-        return Some(ModPath::from_simple_segments(PathKind::Super(0), Vec::new()));\n+        return Some(ModPath::from_segments(PathKind::Super(0), Vec::new()));\n     }\n \n     // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n@@ -61,14 +61,14 @@ fn find_path_inner(\n                 local_id: parent_id,\n             }))\n         {\n-            return Some(ModPath::from_simple_segments(PathKind::Super(1), Vec::new()));\n+            return Some(ModPath::from_segments(PathKind::Super(1), Vec::new()));\n         }\n     }\n \n     // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n     for (name, def_id) in &def_map.extern_prelude {\n         if item == ItemInNs::Types(*def_id) {\n-            return Some(ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]));\n+            return Some(ModPath::from_segments(PathKind::Plain, vec![name.clone()]));\n         }\n     }\n \n@@ -79,7 +79,7 @@ fn find_path_inner(\n             &prelude_def_map.modules[prelude_module.local_id].scope;\n         if let Some((name, vis)) = prelude_scope.name_of(item) {\n             if vis.is_visible_from(db, from) {\n-                return Some(ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]));\n+                return Some(ModPath::from_segments(PathKind::Plain, vec![name.clone()]));\n             }\n         }\n     }"}, {"sha": "ab290e2c98a8486f3f3ad4c5e76262f5423d01af", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=2f1df3cd74603bf1ba7f2e1c8833407a176cc66e", "patch": "@@ -39,10 +39,7 @@ impl ModPath {\n         lower::lower_path(path, hygiene).map(|it| it.mod_path)\n     }\n \n-    pub fn from_simple_segments(\n-        kind: PathKind,\n-        segments: impl IntoIterator<Item = Name>,\n-    ) -> ModPath {\n+    pub fn from_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> ModPath {\n         let segments = segments.into_iter().collect::<Vec<_>>();\n         ModPath { kind, segments }\n     }\n@@ -240,15 +237,15 @@ impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n         Path {\n             type_anchor: None,\n-            mod_path: ModPath::from_simple_segments(PathKind::Plain, iter::once(name)),\n+            mod_path: ModPath::from_segments(PathKind::Plain, iter::once(name)),\n             generic_args: vec![None],\n         }\n     }\n }\n \n impl From<Name> for ModPath {\n     fn from(name: Name) -> ModPath {\n-        ModPath::from_simple_segments(PathKind::Plain, iter::once(name))\n+        ModPath::from_segments(PathKind::Plain, iter::once(name))\n     }\n }\n \n@@ -311,7 +308,7 @@ macro_rules! __known_path {\n macro_rules! __path {\n     ($start:ident $(:: $seg:ident)*) => ({\n         $crate::__known_path!($start $(:: $seg)*);\n-        $crate::path::ModPath::from_simple_segments($crate::path::PathKind::Abs, vec![\n+        $crate::path::ModPath::from_segments($crate::path::PathKind::Abs, vec![\n             $crate::path::__name![$start], $($crate::path::__name![$seg],)*\n         ])\n     });"}, {"sha": "531878174edc2b4adda94f6537a1bdf79bd659ec", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=2f1df3cd74603bf1ba7f2e1c8833407a176cc66e", "patch": "@@ -84,7 +84,7 @@ fn convert_path(prefix: Option<ModPath>, path: ast::Path, hygiene: &Hygiene) ->\n                     res\n                 }\n                 Either::Right(crate_id) => {\n-                    return Some(ModPath::from_simple_segments(\n+                    return Some(ModPath::from_segments(\n                         PathKind::DollarCrate(crate_id),\n                         iter::empty(),\n                     ))\n@@ -95,19 +95,19 @@ fn convert_path(prefix: Option<ModPath>, path: ast::Path, hygiene: &Hygiene) ->\n             if prefix.is_some() {\n                 return None;\n             }\n-            ModPath::from_simple_segments(PathKind::Crate, iter::empty())\n+            ModPath::from_segments(PathKind::Crate, iter::empty())\n         }\n         ast::PathSegmentKind::SelfKw => {\n             if prefix.is_some() {\n                 return None;\n             }\n-            ModPath::from_simple_segments(PathKind::Super(0), iter::empty())\n+            ModPath::from_segments(PathKind::Super(0), iter::empty())\n         }\n         ast::PathSegmentKind::SuperKw => {\n             if prefix.is_some() {\n                 return None;\n             }\n-            ModPath::from_simple_segments(PathKind::Super(1), iter::empty())\n+            ModPath::from_segments(PathKind::Super(1), iter::empty())\n         }\n         ast::PathSegmentKind::Type { .. } => {\n             // not allowed in imports"}, {"sha": "d88a0cf4bf50de91884d168f73a8e716dd0cc61d", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=2f1df3cd74603bf1ba7f2e1c8833407a176cc66e", "patch": "@@ -22,9 +22,8 @@ impl ast::BinExpr {\n     #[must_use]\n     pub fn replace_op(&self, op: SyntaxKind) -> Option<ast::BinExpr> {\n         let op_node: SyntaxElement = self.op_details()?.0.into();\n-        let to_insert: Option<SyntaxElement> = Some(tokens::op(op).into());\n-        let replace_range = RangeInclusive::new(op_node.clone(), op_node);\n-        Some(replace_children(self, replace_range, to_insert.into_iter()))\n+        let to_insert: Option<SyntaxElement> = Some(make::token(op).into());\n+        Some(replace_children(self, single_node(op_node), to_insert))\n     }\n }\n \n@@ -40,11 +39,10 @@ impl ast::FnDef {\n         } else {\n             to_insert.push(make::tokens::single_space().into());\n             to_insert.push(body.syntax().clone().into());\n-            return insert_children(self, InsertPosition::Last, to_insert.into_iter());\n+            return insert_children(self, InsertPosition::Last, to_insert);\n         };\n         to_insert.push(body.syntax().clone().into());\n-        let replace_range = RangeInclusive::new(old_body_or_semi.clone(), old_body_or_semi);\n-        replace_children(self, replace_range, to_insert.into_iter())\n+        replace_children(self, single_node(old_body_or_semi), to_insert)\n     }\n }\n \n@@ -77,7 +75,7 @@ impl ast::ItemList {\n         let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n         let to_insert: ArrayVec<[SyntaxElement; 2]> =\n             [ws.ws().into(), item.syntax().clone().into()].into();\n-        insert_children(self, position, to_insert.into_iter())\n+        insert_children(self, position, to_insert)\n     }\n \n     fn l_curly(&self) -> Option<SyntaxElement> {\n@@ -109,9 +107,7 @@ impl ast::ItemList {\n         let to_insert = iter::once(ws.ws().into());\n         match existing_ws {\n             None => insert_children(self, InsertPosition::After(l_curly), to_insert),\n-            Some(ws) => {\n-                replace_children(self, RangeInclusive::new(ws.clone().into(), ws.into()), to_insert)\n-            }\n+            Some(ws) => replace_children(self, single_node(ws), to_insert),\n         }\n     }\n }\n@@ -188,7 +184,7 @@ impl ast::RecordFieldList {\n             InsertPosition::After(anchor) => after_field!(anchor),\n         };\n \n-        insert_children(self, position, to_insert.iter().cloned())\n+        insert_children(self, position, to_insert)\n     }\n \n     fn l_curly(&self) -> Option<SyntaxElement> {\n@@ -207,7 +203,7 @@ impl ast::TypeParam {\n             Some(it) => it.syntax().clone().into(),\n             None => colon.clone().into(),\n         };\n-        replace_children(self, RangeInclusive::new(colon.into(), end), iter::empty())\n+        replace_children(self, colon.into()..=end, iter::empty())\n     }\n }\n \n@@ -224,17 +220,18 @@ fn strip_attrs_and_docs_inner(mut node: SyntaxNode) -> SyntaxNode {\n             Some(el) if el.kind() == WHITESPACE => el.clone(),\n             Some(_) | None => start.clone(),\n         };\n-        node = algo::replace_children(&node, RangeInclusive::new(start, end), &mut iter::empty());\n+        node = algo::replace_children(&node, start..=end, &mut iter::empty());\n     }\n     node\n }\n \n #[must_use]\n pub fn replace_descendants<N: AstNode, D: AstNode>(\n     parent: &N,\n-    replacement_map: impl Iterator<Item = (D, D)>,\n+    replacement_map: impl IntoIterator<Item = (D, D)>,\n ) -> N {\n     let map = replacement_map\n+        .into_iter()\n         .map(|(from, to)| (from.syntax().clone().into(), to.syntax().clone().into()))\n         .collect::<FxHashMap<SyntaxElement, _>>();\n     let new_syntax = algo::replace_descendants(parent.syntax(), &|n| map.get(n).cloned());\n@@ -348,19 +345,25 @@ fn prev_tokens(token: SyntaxToken) -> impl Iterator<Item = SyntaxToken> {\n fn insert_children<N: AstNode>(\n     parent: &N,\n     position: InsertPosition<SyntaxElement>,\n-    mut to_insert: impl Iterator<Item = SyntaxElement>,\n+    to_insert: impl IntoIterator<Item = SyntaxElement>,\n ) -> N {\n-    let new_syntax = algo::insert_children(parent.syntax(), position, &mut to_insert);\n+    let new_syntax = algo::insert_children(parent.syntax(), position, &mut to_insert.into_iter());\n     N::cast(new_syntax).unwrap()\n }\n \n+fn single_node(element: impl Into<SyntaxElement>) -> RangeInclusive<SyntaxElement> {\n+    let element = element.into();\n+    element.clone()..=element\n+}\n+\n #[must_use]\n fn replace_children<N: AstNode>(\n     parent: &N,\n     to_replace: RangeInclusive<SyntaxElement>,\n-    mut to_insert: impl Iterator<Item = SyntaxElement>,\n+    to_insert: impl IntoIterator<Item = SyntaxElement>,\n ) -> N {\n-    let new_syntax = algo::replace_children(parent.syntax(), to_replace, &mut to_insert);\n+    let new_syntax =\n+        algo::replace_children(parent.syntax(), to_replace, &mut to_insert.into_iter());\n     N::cast(new_syntax).unwrap()\n }\n "}, {"sha": "4a79d0dec51b7c6f93ea6196047a43ef4b733933", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1df3cd74603bf1ba7f2e1c8833407a176cc66e/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=2f1df3cd74603bf1ba7f2e1c8833407a176cc66e", "patch": "@@ -2,7 +2,7 @@\n //! of smaller pieces.\n use itertools::Itertools;\n \n-use crate::{algo, ast, AstNode, SourceFile};\n+use crate::{algo, ast, AstNode, SourceFile, SyntaxKind, SyntaxToken};\n \n pub fn name(text: &str) -> ast::Name {\n     ast_from_text(&format!(\"mod {};\", text))\n@@ -181,28 +181,28 @@ pub fn let_stmt(pattern: ast::Pat, initializer: Option<ast::Expr>) -> ast::LetSt\n     ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n }\n \n+pub fn token(kind: SyntaxKind) -> SyntaxToken {\n+    tokens::SOURCE_FILE\n+        .tree()\n+        .syntax()\n+        .descendants_with_tokens()\n+        .filter_map(|it| it.into_token())\n+        .find(|it| it.kind() == kind)\n+        .unwrap_or_else(|| panic!(\"unhandled token: {:?}\", kind))\n+}\n+\n fn ast_from_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n     parse.tree().syntax().descendants().find_map(N::cast).unwrap()\n }\n \n pub mod tokens {\n-    use crate::{AstNode, Parse, SourceFile, SyntaxKind, SyntaxKind::*, SyntaxToken, T};\n+    use crate::{AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n     use once_cell::sync::Lazy;\n \n-    static SOURCE_FILE: Lazy<Parse<SourceFile>> =\n+    pub(super) static SOURCE_FILE: Lazy<Parse<SourceFile>> =\n         Lazy::new(|| SourceFile::parse(\"const C: () = (1 != 1, 2 == 2)\\n;\"));\n \n-    pub fn op(op: SyntaxKind) -> SyntaxToken {\n-        SOURCE_FILE\n-            .tree()\n-            .syntax()\n-            .descendants_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == op)\n-            .unwrap()\n-    }\n-\n     pub fn comma() -> SyntaxToken {\n         SOURCE_FILE\n             .tree()"}]}