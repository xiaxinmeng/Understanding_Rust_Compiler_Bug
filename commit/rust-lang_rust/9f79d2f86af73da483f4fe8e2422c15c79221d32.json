{"sha": "9f79d2f86af73da483f4fe8e2422c15c79221d32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNzlkMmY4NmFmNzNkYTQ4M2Y0ZmU4ZTI0MjJjMTVjNzkyMjFkMzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-28T11:20:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-28T11:20:41Z"}, "message": "Auto merge of #50997 - michaelwoerister:pre-analyze-filemaps, r=Mark-Simulacrum\n\n Make FileMap::{lines, multibyte_chars, non_narrow_chars} non-mutable.\n\nThis PR removes most of the interior mutability from `FileMap`, which should be beneficial, especially in a multithreaded setting. This is achieved by initializing the state in question when the filemap is constructed instead of during lexing. Hopefully this doesn't degrade performance.\n\ncc @wesleywiser", "tree": {"sha": "b7ecb398641e49cb195212763ae13c5d4a28a537", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7ecb398641e49cb195212763ae13c5d4a28a537"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f79d2f86af73da483f4fe8e2422c15c79221d32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f79d2f86af73da483f4fe8e2422c15c79221d32", "html_url": "https://github.com/rust-lang/rust/commit/9f79d2f86af73da483f4fe8e2422c15c79221d32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f79d2f86af73da483f4fe8e2422c15c79221d32/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d84ad59710728c936edd7396e287d42f1e319cf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d84ad59710728c936edd7396e287d42f1e319cf1", "html_url": "https://github.com/rust-lang/rust/commit/d84ad59710728c936edd7396e287d42f1e319cf1"}, {"sha": "a1f8a6ce80a340d51074071c0d9e30eb14f65d25", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1f8a6ce80a340d51074071c0d9e30eb14f65d25", "html_url": "https://github.com/rust-lang/rust/commit/a1f8a6ce80a340d51074071c0d9e30eb14f65d25"}], "stats": {"total": 785, "additions": 553, "deletions": 232}, "files": [{"sha": "a93390552641ce7b1306cd9a6402dbb13f0aad83", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -2779,6 +2779,7 @@ name = \"syntax_pos\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n+ \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n  \"scoped-tls 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\","}, {"sha": "0dca7d6d856fe80059a82d1805a5ebd77899385e", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -456,27 +456,21 @@ impl<'a> HashStable<StableHashingContext<'a>> for FileMap {\n         src_hash.hash_stable(hcx, hasher);\n \n         // We only hash the relative position within this filemap\n-        lines.with_lock(|lines| {\n-            lines.len().hash_stable(hcx, hasher);\n-            for &line in lines.iter() {\n-                stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n-            }\n-        });\n+        lines.len().hash_stable(hcx, hasher);\n+        for &line in lines.iter() {\n+            stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n+        }\n \n         // We only hash the relative position within this filemap\n-        multibyte_chars.with_lock(|multibyte_chars| {\n-            multibyte_chars.len().hash_stable(hcx, hasher);\n-            for &char_pos in multibyte_chars.iter() {\n-                stable_multibyte_char(char_pos, start_pos).hash_stable(hcx, hasher);\n-            }\n-        });\n+        multibyte_chars.len().hash_stable(hcx, hasher);\n+        for &char_pos in multibyte_chars.iter() {\n+            stable_multibyte_char(char_pos, start_pos).hash_stable(hcx, hasher);\n+        }\n \n-        non_narrow_chars.with_lock(|non_narrow_chars| {\n-            non_narrow_chars.len().hash_stable(hcx, hasher);\n-            for &char_pos in non_narrow_chars.iter() {\n-                stable_non_narrow_char(char_pos, start_pos).hash_stable(hcx, hasher);\n-            }\n-        });\n+        non_narrow_chars.len().hash_stable(hcx, hasher);\n+        for &char_pos in non_narrow_chars.iter() {\n+            stable_non_narrow_char(char_pos, start_pos).hash_stable(hcx, hasher);\n+        }\n     }\n }\n "}, {"sha": "aa42b4072bd8a62a98c3b4420593b92b207bf248", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -623,7 +623,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n         let len = BytePos::decode(self)?;\n \n         let file_lo = self.file_index_to_file(file_lo_index);\n-        let lo = file_lo.lines.borrow()[line_lo - 1] + col_lo;\n+        let lo = file_lo.lines[line_lo - 1] + col_lo;\n         let hi = lo + len;\n \n         let expn_info_tag = u8::decode(self)?;"}, {"sha": "1985900b3e1170b05e03e4ae8bf48207997807a2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -1138,9 +1138,9 @@ impl<'a, 'tcx> CrateMetadata {\n                                       src_hash,\n                                       start_pos,\n                                       end_pos,\n-                                      lines,\n-                                      multibyte_chars,\n-                                      non_narrow_chars,\n+                                      mut lines,\n+                                      mut multibyte_chars,\n+                                      mut non_narrow_chars,\n                                       name_hash,\n                                       .. } = filemap_to_import;\n \n@@ -1151,15 +1151,12 @@ impl<'a, 'tcx> CrateMetadata {\n             // `CodeMap::new_imported_filemap()` will then translate those\n             // coordinates to their new global frame of reference when the\n             // offset of the FileMap is known.\n-            let mut lines = lines.into_inner();\n             for pos in &mut lines {\n                 *pos = *pos - start_pos;\n             }\n-            let mut multibyte_chars = multibyte_chars.into_inner();\n             for mbc in &mut multibyte_chars {\n                 mbc.pos = mbc.pos - start_pos;\n             }\n-            let mut non_narrow_chars = non_narrow_chars.into_inner();\n             for swc in &mut non_narrow_chars {\n                 *swc = *swc - start_pos;\n             }"}, {"sha": "1d5429bdf8f7d124d498d9f0243b2ce6e49aa8e3", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 32, "deletions": 99, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -211,8 +211,7 @@ impl CodeMap {\n         }\n     }\n \n-    /// Creates a new filemap without setting its line information. If you don't\n-    /// intend to set the line information yourself, you should use new_filemap_and_lines.\n+    /// Creates a new filemap.\n     /// This does not ensure that only one FileMap exists per file name.\n     pub fn new_filemap(&self, filename: FileName, src: String) -> Lrc<FileMap> {\n         let start_pos = self.next_start_pos();\n@@ -247,22 +246,6 @@ impl CodeMap {\n         filemap\n     }\n \n-    /// Creates a new filemap and sets its line information.\n-    /// This does not ensure that only one FileMap exists per file name.\n-    pub fn new_filemap_and_lines(&self, filename: &Path, src: &str) -> Lrc<FileMap> {\n-        let fm = self.new_filemap(filename.to_owned().into(), src.to_owned());\n-        let mut byte_pos: u32 = fm.start_pos.0;\n-        for line in src.lines() {\n-            // register the start of this line\n-            fm.next_line(BytePos(byte_pos));\n-\n-            // update byte_pos to include this line and the \\n at the end\n-            byte_pos += line.len() as u32 + 1;\n-        }\n-        fm\n-    }\n-\n-\n     /// Allocates a new FileMap representing a source file from an external\n     /// crate. The source code of such an \"imported filemap\" is not available,\n     /// but we still know enough to generate accurate debuginfo location\n@@ -305,9 +288,9 @@ impl CodeMap {\n             external_src: Lock::new(ExternalSource::AbsentOk),\n             start_pos,\n             end_pos,\n-            lines: Lock::new(file_local_lines),\n-            multibyte_chars: Lock::new(file_local_multibyte_chars),\n-            non_narrow_chars: Lock::new(file_local_non_narrow_chars),\n+            lines: file_local_lines,\n+            multibyte_chars: file_local_multibyte_chars,\n+            non_narrow_chars: file_local_non_narrow_chars,\n             name_hash,\n         });\n \n@@ -345,21 +328,22 @@ impl CodeMap {\n         match self.lookup_line(pos) {\n             Ok(FileMapAndLine { fm: f, line: a }) => {\n                 let line = a + 1; // Line numbers start at 1\n-                let linebpos = (*f.lines.borrow())[a];\n+                let linebpos = f.lines[a];\n                 let linechpos = self.bytepos_to_file_charpos(linebpos);\n                 let col = chpos - linechpos;\n \n                 let col_display = {\n-                    let non_narrow_chars = f.non_narrow_chars.borrow();\n-                    let start_width_idx = non_narrow_chars\n+                    let start_width_idx = f\n+                        .non_narrow_chars\n                         .binary_search_by_key(&linebpos, |x| x.pos())\n                         .unwrap_or_else(|x| x);\n-                    let end_width_idx = non_narrow_chars\n+                    let end_width_idx = f\n+                        .non_narrow_chars\n                         .binary_search_by_key(&pos, |x| x.pos())\n                         .unwrap_or_else(|x| x);\n                     let special_chars = end_width_idx - start_width_idx;\n-                    let non_narrow: usize =\n-                        non_narrow_chars[start_width_idx..end_width_idx]\n+                    let non_narrow: usize = f\n+                        .non_narrow_chars[start_width_idx..end_width_idx]\n                         .into_iter()\n                         .map(|x| x.width())\n                         .sum();\n@@ -380,12 +364,12 @@ impl CodeMap {\n             }\n             Err(f) => {\n                 let col_display = {\n-                    let non_narrow_chars = f.non_narrow_chars.borrow();\n-                    let end_width_idx = non_narrow_chars\n+                    let end_width_idx = f\n+                        .non_narrow_chars\n                         .binary_search_by_key(&pos, |x| x.pos())\n                         .unwrap_or_else(|x| x);\n-                    let non_narrow: usize =\n-                        non_narrow_chars[0..end_width_idx]\n+                    let non_narrow: usize = f\n+                        .non_narrow_chars[0..end_width_idx]\n                         .into_iter()\n                         .map(|x| x.width())\n                         .sum();\n@@ -830,22 +814,22 @@ impl CodeMap {\n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n-        for mbc in map.multibyte_chars.borrow().iter() {\n+        for mbc in map.multibyte_chars.iter() {\n             debug!(\"{}-byte char at {:?}\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 // every character is at least one byte, so we only\n                 // count the actual extra bytes.\n-                total_extra_bytes += mbc.bytes - 1;\n+                total_extra_bytes += mbc.bytes as u32 - 1;\n                 // We should never see a byte position in the middle of a\n                 // character\n-                assert!(bpos.to_usize() >= mbc.pos.to_usize() + mbc.bytes);\n+                assert!(bpos.to_u32() >= mbc.pos.to_u32() + mbc.bytes as u32);\n             } else {\n                 break;\n             }\n         }\n \n-        assert!(map.start_pos.to_usize() + total_extra_bytes <= bpos.to_usize());\n-        CharPos(bpos.to_usize() - map.start_pos.to_usize() - total_extra_bytes)\n+        assert!(map.start_pos.to_u32() + total_extra_bytes <= bpos.to_u32());\n+        CharPos(bpos.to_usize() - map.start_pos.to_usize() - total_extra_bytes as usize)\n     }\n \n     // Return the index of the filemap (in self.files) which contains pos.\n@@ -1028,51 +1012,16 @@ impl FilePathMapping {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use std::borrow::Cow;\n     use rustc_data_structures::sync::Lrc;\n \n-    #[test]\n-    fn t1 () {\n-        let cm = CodeMap::new(FilePathMapping::empty());\n-        let fm = cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n-                                \"first line.\\nsecond line\".to_string());\n-        fm.next_line(BytePos(0));\n-        // Test we can get lines with partial line info.\n-        assert_eq!(fm.get_line(0), Some(Cow::from(\"first line.\")));\n-        // TESTING BROKEN BEHAVIOR: line break declared before actual line break.\n-        fm.next_line(BytePos(10));\n-        assert_eq!(fm.get_line(1), Some(Cow::from(\".\")));\n-        fm.next_line(BytePos(12));\n-        assert_eq!(fm.get_line(2), Some(Cow::from(\"second line\")));\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn t2 () {\n-        let cm = CodeMap::new(FilePathMapping::empty());\n-        let fm = cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n-                                \"first line.\\nsecond line\".to_string());\n-        // TESTING *REALLY* BROKEN BEHAVIOR:\n-        fm.next_line(BytePos(0));\n-        fm.next_line(BytePos(10));\n-        fm.next_line(BytePos(2));\n-    }\n-\n     fn init_code_map() -> CodeMap {\n         let cm = CodeMap::new(FilePathMapping::empty());\n-        let fm1 = cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n-                                 \"first line.\\nsecond line\".to_string());\n-        let fm2 = cm.new_filemap(PathBuf::from(\"empty.rs\").into(),\n-                                 \"\".to_string());\n-        let fm3 = cm.new_filemap(PathBuf::from(\"blork2.rs\").into(),\n-                                 \"first line.\\nsecond line\".to_string());\n-\n-        fm1.next_line(BytePos(0));\n-        fm1.next_line(BytePos(12));\n-        fm2.next_line(fm2.start_pos);\n-        fm3.next_line(fm3.start_pos);\n-        fm3.next_line(fm3.start_pos + BytePos(12));\n-\n+        cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n+                       \"first line.\\nsecond line\".to_string());\n+        cm.new_filemap(PathBuf::from(\"empty.rs\").into(),\n+                       \"\".to_string());\n+        cm.new_filemap(PathBuf::from(\"blork2.rs\").into(),\n+                       \"first line.\\nsecond line\".to_string());\n         cm\n     }\n \n@@ -1125,26 +1074,10 @@ mod tests {\n     fn init_code_map_mbc() -> CodeMap {\n         let cm = CodeMap::new(FilePathMapping::empty());\n         // \u20ac is a three byte utf8 char.\n-        let fm1 =\n-            cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n-                           \"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_string());\n-        let fm2 = cm.new_filemap(PathBuf::from(\"blork2.rs\").into(),\n-                                 \"first line\u20ac\u20ac.\\n\u20ac second line\".to_string());\n-\n-        fm1.next_line(BytePos(0));\n-        fm1.next_line(BytePos(28));\n-        fm2.next_line(fm2.start_pos);\n-        fm2.next_line(fm2.start_pos + BytePos(20));\n-\n-        fm1.record_multibyte_char(BytePos(3), 3);\n-        fm1.record_multibyte_char(BytePos(9), 3);\n-        fm1.record_multibyte_char(BytePos(12), 3);\n-        fm1.record_multibyte_char(BytePos(15), 3);\n-        fm1.record_multibyte_char(BytePos(18), 3);\n-        fm2.record_multibyte_char(fm2.start_pos + BytePos(10), 3);\n-        fm2.record_multibyte_char(fm2.start_pos + BytePos(13), 3);\n-        fm2.record_multibyte_char(fm2.start_pos + BytePos(18), 3);\n-\n+        cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n+                       \"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_string());\n+        cm.new_filemap(PathBuf::from(\"blork2.rs\").into(),\n+                       \"first line\u20ac\u20ac.\\n\u20ac second line\".to_string());\n         cm\n     }\n \n@@ -1196,7 +1129,7 @@ mod tests {\n         let cm = CodeMap::new(FilePathMapping::empty());\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n         let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(Path::new(\"blork.rs\"), inputtext);\n+        cm.new_filemap(Path::new(\"blork.rs\").to_owned().into(), inputtext.to_string());\n         let span = span_from_selection(inputtext, selection);\n \n         // check that we are extracting the text we thought we were extracting\n@@ -1239,7 +1172,7 @@ mod tests {\n         let inputtext  = \"bbbb BB\\ncc CCC\\n\";\n         let selection1 = \"     ~~\\n      \\n\";\n         let selection2 = \"       \\n   ~~~\\n\";\n-        cm.new_filemap_and_lines(Path::new(\"blork.rs\"), inputtext);\n+        cm.new_filemap(Path::new(\"blork.rs\").to_owned().into(), inputtext.to_owned());\n         let span1 = span_from_selection(inputtext, selection1);\n         let span2 = span_from_selection(inputtext, selection2);\n "}, {"sha": "9cd410d424394643bafb156d6f7c44a613b2b80c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -1495,17 +1495,19 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                     match String::from_utf8(buf) {\n                         Ok(src) => {\n+                            let src_interned = Symbol::intern(&src);\n+\n                             // Add this input file to the code map to make it available as\n                             // dependency information\n-                            self.cx.codemap().new_filemap_and_lines(&filename, &src);\n+                            self.cx.codemap().new_filemap(filename.into(), src);\n \n                             let include_info = vec![\n                                 dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n                                         attr::mk_name_value_item_str(Ident::from_str(\"file\"),\n                                                                      dummy_spanned(file)))),\n                                 dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n                                         attr::mk_name_value_item_str(Ident::from_str(\"contents\"),\n-                                                            dummy_spanned(Symbol::intern(&src))))),\n+                                                            dummy_spanned(src_interned)))),\n                             ];\n \n                             let include_ident = Ident::from_str(\"include\");"}, {"sha": "669536f519ce31274453123b7ea42d384851921d", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -150,11 +150,13 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n     };\n     match String::from_utf8(bytes) {\n         Ok(src) => {\n+            let interned_src = Symbol::intern(&src);\n+\n             // Add this input file to the code map to make it available as\n             // dependency information\n-            cx.codemap().new_filemap_and_lines(&file, &src);\n+            cx.codemap().new_filemap(file.into(), src);\n \n-            base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&src)))\n+            base::MacEager::expr(cx.expr_str(sp, interned_src))\n         }\n         Err(_) => {\n             cx.span_err(sp,\n@@ -182,7 +184,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n         Ok(..) => {\n             // Add this input file to the code map to make it available as\n             // dependency information, but don't enter it's contents\n-            cx.codemap().new_filemap_and_lines(&file, \"\");\n+            cx.codemap().new_filemap(file.into(), \"\".to_string());\n \n             base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Lrc::new(bytes))))\n         }"}, {"sha": "3995a9b8689e77e7a4b2f139ee019cef55ccc8f7", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -240,9 +240,11 @@ fn read_block_comment(rdr: &mut StringReader,\n     let mut lines: Vec<String> = Vec::new();\n \n     // Count the number of chars since the start of the line by rescanning.\n-    let mut src_index = rdr.src_index(rdr.filemap.line_begin_pos());\n+    let mut src_index = rdr.src_index(rdr.filemap.line_begin_pos(rdr.pos));\n     let end_src_index = rdr.src_index(rdr.pos);\n-    assert!(src_index <= end_src_index);\n+    assert!(src_index <= end_src_index,\n+        \"src_index={}, end_src_index={}, line_begin_pos={}\",\n+        src_index, end_src_index, rdr.filemap.line_begin_pos(rdr.pos).to_u32());\n     let mut n = 0;\n     while src_index < end_src_index {\n         let c = char_at(&rdr.src, src_index);"}, {"sha": "dcc71e787785289558e18a8872aac5dc23a15c4d", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -51,11 +51,7 @@ pub struct StringReader<'a> {\n     pub ch: Option<char>,\n     pub filemap: Lrc<syntax_pos::FileMap>,\n     /// Stop reading src at this index.\n-    end_src_index: usize,\n-    /// Whether to record new-lines and multibyte chars in filemap.\n-    /// This is only necessary the first time a filemap is lexed.\n-    /// If part of a filemap is being re-lexed, this should be set to false.\n-    save_new_lines_and_multibyte: bool,\n+    pub end_src_index: usize,\n     // cached:\n     peek_tok: token::Token,\n     peek_span: Span,\n@@ -188,7 +184,6 @@ impl<'a> StringReader<'a> {\n             ch: Some('\\n'),\n             filemap,\n             end_src_index: src.len(),\n-            save_new_lines_and_multibyte: true,\n             // dummy values; not read\n             peek_tok: token::Eof,\n             peek_span: syntax_pos::DUMMY_SP,\n@@ -225,7 +220,6 @@ impl<'a> StringReader<'a> {\n         let mut sr = StringReader::new_raw_internal(sess, begin.fm, None);\n \n         // Seek the lexer to the right byte range.\n-        sr.save_new_lines_and_multibyte = false;\n         sr.next_pos = span.lo();\n         sr.end_src_index = sr.src_index(span.hi());\n \n@@ -458,18 +452,6 @@ impl<'a> StringReader<'a> {\n             let next_ch = char_at(&self.src, next_src_index);\n             let next_ch_len = next_ch.len_utf8();\n \n-            if self.ch.unwrap() == '\\n' {\n-                if self.save_new_lines_and_multibyte {\n-                    self.filemap.next_line(self.next_pos);\n-                }\n-            }\n-            if next_ch_len > 1 {\n-                if self.save_new_lines_and_multibyte {\n-                    self.filemap.record_multibyte_char(self.next_pos, next_ch_len);\n-                }\n-            }\n-            self.filemap.record_width(self.next_pos, next_ch);\n-\n             self.ch = Some(next_ch);\n             self.pos = self.next_pos;\n             self.next_pos = self.next_pos + Pos::from_usize(next_ch_len);"}, {"sha": "c7e4fbd1073d7c06cb8657c0cd12f4d0b07a2b54", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -51,7 +51,7 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n         let output = Arc::new(Mutex::new(Vec::new()));\n \n         let code_map = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n-        code_map.new_filemap_and_lines(Path::new(\"test.rs\"), &file_text);\n+        code_map.new_filemap(Path::new(\"test.rs\").to_owned().into(), file_text.to_owned());\n \n         let primary_span = make_span(&file_text, &span_labels[0].start, &span_labels[0].end);\n         let mut msp = MultiSpan::from_span(primary_span);"}, {"sha": "08ee2e0f3762647939d95879baf4251efd979d18", "filename": "src/libsyntax_pos/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax_pos%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax_pos%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2FCargo.toml?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -14,3 +14,4 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n arena = { path = \"../libarena\" }\n scoped-tls = { version = \"0.1.1\", features = [\"nightly\"] }\n unicode-width = \"0.1.4\"\n+cfg-if = \"0.1.2\""}, {"sha": "c7c0263e4593240f039cb1bf6fa4cb90cbe1516b", "filename": "src/libsyntax_pos/analyze_filemap.rs", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax_pos%2Fanalyze_filemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax_pos%2Fanalyze_filemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fanalyze_filemap.rs?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -0,0 +1,436 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use unicode_width::UnicodeWidthChar;\n+use super::*;\n+\n+/// Find all newlines, multi-byte characters, and non-narrow characters in a\n+/// FileMap.\n+///\n+/// This function will use an SSE2 enhanced implementation if hardware support\n+/// is detected at runtime.\n+pub fn analyze_filemap(\n+    src: &str,\n+    filemap_start_pos: BytePos)\n+    -> (Vec<BytePos>, Vec<MultiByteChar>, Vec<NonNarrowChar>)\n+{\n+    let mut lines = vec![filemap_start_pos];\n+    let mut multi_byte_chars = vec![];\n+    let mut non_narrow_chars = vec![];\n+\n+    // Calls the right implementation, depending on hardware support available.\n+    analyze_filemap_dispatch(src,\n+                             filemap_start_pos,\n+                             &mut lines,\n+                             &mut multi_byte_chars,\n+                             &mut non_narrow_chars);\n+\n+    // The code above optimistically registers a new line *after* each \\n\n+    // it encounters. If that point is already outside the filemap, remove\n+    // it again.\n+    if let Some(&last_line_start) = lines.last() {\n+        let file_map_end = filemap_start_pos + BytePos::from_usize(src.len());\n+        assert!(file_map_end >= last_line_start);\n+        if last_line_start == file_map_end {\n+            lines.pop();\n+        }\n+    }\n+\n+    (lines, multi_byte_chars, non_narrow_chars)\n+}\n+\n+cfg_if! {\n+    if #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"),\n+                 not(stage0)))] {\n+        fn analyze_filemap_dispatch(src: &str,\n+                                    filemap_start_pos: BytePos,\n+                                    lines: &mut Vec<BytePos>,\n+                                    multi_byte_chars: &mut Vec<MultiByteChar>,\n+                                    non_narrow_chars: &mut Vec<NonNarrowChar>) {\n+            if is_x86_feature_detected!(\"sse2\") {\n+                unsafe {\n+                    analyze_filemap_sse2(src,\n+                                         filemap_start_pos,\n+                                         lines,\n+                                         multi_byte_chars,\n+                                         non_narrow_chars);\n+                }\n+            } else {\n+                analyze_filemap_generic(src,\n+                                        src.len(),\n+                                        filemap_start_pos,\n+                                        lines,\n+                                        multi_byte_chars,\n+                                        non_narrow_chars);\n+\n+            }\n+        }\n+\n+        /// Check 16 byte chunks of text at a time. If the chunk contains\n+        /// something other than printable ASCII characters and newlines, the\n+        /// function falls back to the generic implementation. Otherwise it uses\n+        /// SSE2 intrinsics to quickly find all newlines.\n+        #[target_feature(enable = \"sse2\")]\n+        unsafe fn analyze_filemap_sse2(src: &str,\n+                                       output_offset: BytePos,\n+                                       lines: &mut Vec<BytePos>,\n+                                       multi_byte_chars: &mut Vec<MultiByteChar>,\n+                                       non_narrow_chars: &mut Vec<NonNarrowChar>) {\n+            #[cfg(target_arch = \"x86\")]\n+            use std::arch::x86::*;\n+            #[cfg(target_arch = \"x86_64\")]\n+            use std::arch::x86_64::*;\n+\n+            const CHUNK_SIZE: usize = 16;\n+\n+            let src_bytes = src.as_bytes();\n+\n+            let chunk_count = src.len() / CHUNK_SIZE;\n+\n+            // This variable keeps track of where we should start decoding a\n+            // chunk. If a multi-byte character spans across chunk boundaries,\n+            // we need to skip that part in the next chunk because we already\n+            // handled it.\n+            let mut intra_chunk_offset = 0;\n+\n+            for chunk_index in 0 .. chunk_count {\n+                let ptr = src_bytes.as_ptr() as *const __m128i;\n+                // We don't know if the pointer is aligned to 16 bytes, so we\n+                // use `loadu`, which supports unaligned loading.\n+                let chunk = _mm_loadu_si128(ptr.offset(chunk_index as isize));\n+\n+                // For character in the chunk, see if its byte value is < 0, which\n+                // indicates that it's part of a UTF-8 char.\n+                let multibyte_test = _mm_cmplt_epi8(chunk, _mm_set1_epi8(0));\n+                // Create a bit mask from the comparison results.\n+                let multibyte_mask = _mm_movemask_epi8(multibyte_test);\n+\n+                // If the bit mask is all zero, we only have ASCII chars here:\n+                if multibyte_mask == 0 {\n+                    assert!(intra_chunk_offset == 0);\n+\n+                    // Check if there are any control characters in the chunk. All\n+                    // control characters that we can encounter at this point have a\n+                    // byte value less than 32 or ...\n+                    let control_char_test0 = _mm_cmplt_epi8(chunk, _mm_set1_epi8(32));\n+                    let control_char_mask0 = _mm_movemask_epi8(control_char_test0);\n+\n+                    // ... it's the ASCII 'DEL' character with a value of 127.\n+                    let control_char_test1 = _mm_cmpeq_epi8(chunk, _mm_set1_epi8(127));\n+                    let control_char_mask1 = _mm_movemask_epi8(control_char_test1);\n+\n+                    let control_char_mask = control_char_mask0 | control_char_mask1;\n+\n+                    if control_char_mask != 0 {\n+                        // Check for newlines in the chunk\n+                        let newlines_test = _mm_cmpeq_epi8(chunk, _mm_set1_epi8(b'\\n' as i8));\n+                        let newlines_mask = _mm_movemask_epi8(newlines_test);\n+\n+                        if control_char_mask == newlines_mask {\n+                            // All control characters are newlines, record them\n+                            let mut newlines_mask = 0xFFFF0000 | newlines_mask as u32;\n+                            let output_offset = output_offset +\n+                                BytePos::from_usize(chunk_index * CHUNK_SIZE + 1);\n+\n+                            loop {\n+                                let index = newlines_mask.trailing_zeros();\n+\n+                                if index >= CHUNK_SIZE as u32 {\n+                                    // We have arrived at the end of the chunk.\n+                                    break\n+                                }\n+\n+                                lines.push(BytePos(index) + output_offset);\n+\n+                                // Clear the bit, so we can find the next one.\n+                                newlines_mask &= (!1) << index;\n+                            }\n+\n+                            // We are done for this chunk. All control characters were\n+                            // newlines and we took care of those.\n+                            continue\n+                        } else {\n+                            // Some of the control characters are not newlines,\n+                            // fall through to the slow path below.\n+                        }\n+                    } else {\n+                        // No control characters, nothing to record for this chunk\n+                        continue\n+                    }\n+                }\n+\n+                // The slow path.\n+                // There are control chars in here, fallback to generic decoding.\n+                let scan_start = chunk_index * CHUNK_SIZE + intra_chunk_offset;\n+                intra_chunk_offset = analyze_filemap_generic(\n+                    &src[scan_start .. ],\n+                    CHUNK_SIZE - intra_chunk_offset,\n+                    BytePos::from_usize(scan_start) + output_offset,\n+                    lines,\n+                    multi_byte_chars,\n+                    non_narrow_chars\n+                );\n+            }\n+\n+            // There might still be a tail left to analyze\n+            let tail_start = chunk_count * CHUNK_SIZE + intra_chunk_offset;\n+            if tail_start < src.len() {\n+                analyze_filemap_generic(&src[tail_start as usize ..],\n+                                        src.len() - tail_start,\n+                                        output_offset + BytePos::from_usize(tail_start),\n+                                        lines,\n+                                        multi_byte_chars,\n+                                        non_narrow_chars);\n+            }\n+        }\n+    } else {\n+\n+        // The target (or compiler version) does not support SSE2 ...\n+        fn analyze_filemap_dispatch(src: &str,\n+                                    filemap_start_pos: BytePos,\n+                                    lines: &mut Vec<BytePos>,\n+                                    multi_byte_chars: &mut Vec<MultiByteChar>,\n+                                    non_narrow_chars: &mut Vec<NonNarrowChar>) {\n+            analyze_filemap_generic(src,\n+                                    src.len(),\n+                                    filemap_start_pos,\n+                                    lines,\n+                                    multi_byte_chars,\n+                                    non_narrow_chars);\n+        }\n+    }\n+}\n+\n+// `scan_len` determines the number of bytes in `src` to scan. Note that the\n+// function can read past `scan_len` if a multi-byte character start within the\n+// range but extends past it. The overflow is returned by the function.\n+fn analyze_filemap_generic(src: &str,\n+                           scan_len: usize,\n+                           output_offset: BytePos,\n+                           lines: &mut Vec<BytePos>,\n+                           multi_byte_chars: &mut Vec<MultiByteChar>,\n+                           non_narrow_chars: &mut Vec<NonNarrowChar>)\n+                           -> usize\n+{\n+    assert!(src.len() >= scan_len);\n+    let mut i = 0;\n+    let src_bytes = src.as_bytes();\n+\n+    while i < scan_len {\n+        let byte = unsafe {\n+            // We verified that i < scan_len <= src.len()\n+            *src_bytes.get_unchecked(i as usize)\n+        };\n+\n+        // How much to advance in order to get to the next UTF-8 char in the\n+        // string.\n+        let mut char_len = 1;\n+\n+        if byte < 32 {\n+            // This is an ASCII control character, it could be one of the cases\n+            // that are interesting to us.\n+\n+            let pos = BytePos::from_usize(i) + output_offset;\n+\n+            match byte {\n+                b'\\n' => {\n+                    lines.push(pos + BytePos(1));\n+                }\n+                b'\\t' => {\n+                    non_narrow_chars.push(NonNarrowChar::Tab(pos));\n+                }\n+                _ => {\n+                    non_narrow_chars.push(NonNarrowChar::ZeroWidth(pos));\n+                }\n+            }\n+        } else if byte >= 127 {\n+            // The slow path:\n+            // This is either ASCII control character \"DEL\" or the beginning of\n+            // a multibyte char. Just decode to `char`.\n+            let c = (&src[i..]).chars().next().unwrap();\n+            char_len = c.len_utf8();\n+\n+            let pos = BytePos::from_usize(i) + output_offset;\n+\n+            if char_len > 1 {\n+                assert!(char_len >=2 && char_len <= 4);\n+                let mbc = MultiByteChar {\n+                    pos,\n+                    bytes: char_len as u8,\n+                };\n+                multi_byte_chars.push(mbc);\n+            }\n+\n+            // Assume control characters are zero width.\n+            // FIXME: How can we decide between `width` and `width_cjk`?\n+            let char_width = UnicodeWidthChar::width(c).unwrap_or(0);\n+\n+            if char_width != 1 {\n+                non_narrow_chars.push(NonNarrowChar::new(pos, char_width));\n+            }\n+        }\n+\n+        i += char_len;\n+    }\n+\n+    i - scan_len\n+}\n+\n+\n+\n+macro_rules! test {\n+    (case: $test_name:ident,\n+     text: $text:expr,\n+     filemap_start_pos: $filemap_start_pos:expr,\n+     lines: $lines:expr,\n+     multi_byte_chars: $multi_byte_chars:expr,\n+     non_narrow_chars: $non_narrow_chars:expr,) => (\n+\n+    #[test]\n+    fn $test_name() {\n+\n+        let (lines, multi_byte_chars, non_narrow_chars) =\n+            analyze_filemap($text, BytePos($filemap_start_pos));\n+\n+        let expected_lines: Vec<BytePos> = $lines\n+            .into_iter()\n+            .map(|pos| BytePos(pos))\n+            .collect();\n+\n+        assert_eq!(lines, expected_lines);\n+\n+        let expected_mbcs: Vec<MultiByteChar> = $multi_byte_chars\n+            .into_iter()\n+            .map(|(pos, bytes)| MultiByteChar {\n+                pos: BytePos(pos),\n+                bytes,\n+            })\n+            .collect();\n+\n+        assert_eq!(multi_byte_chars, expected_mbcs);\n+\n+        let expected_nncs: Vec<NonNarrowChar> = $non_narrow_chars\n+            .into_iter()\n+            .map(|(pos, width)| {\n+                NonNarrowChar::new(BytePos(pos), width)\n+            })\n+            .collect();\n+\n+        assert_eq!(non_narrow_chars, expected_nncs);\n+    })\n+}\n+\n+test!(\n+    case: empty_text,\n+    text: \"\",\n+    filemap_start_pos: 0,\n+    lines: vec![],\n+    multi_byte_chars: vec![],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: newlines_short,\n+    text: \"a\\nc\",\n+    filemap_start_pos: 0,\n+    lines: vec![0, 2],\n+    multi_byte_chars: vec![],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: newlines_long,\n+    text: \"012345678\\nabcdef012345678\\na\",\n+    filemap_start_pos: 0,\n+    lines: vec![0, 10, 26],\n+    multi_byte_chars: vec![],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: newline_and_multi_byte_char_in_same_chunk,\n+    text: \"01234\u03b2789\\nbcdef0123456789abcdef\",\n+    filemap_start_pos: 0,\n+    lines: vec![0, 11],\n+    multi_byte_chars: vec![(5, 2)],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: newline_and_control_char_in_same_chunk,\n+    text: \"01234\\u{07}6789\\nbcdef0123456789abcdef\",\n+    filemap_start_pos: 0,\n+    lines: vec![0, 11],\n+    multi_byte_chars: vec![],\n+    non_narrow_chars: vec![(5, 0)],\n+);\n+\n+test!(\n+    case: multi_byte_char_short,\n+    text: \"a\u03b2c\",\n+    filemap_start_pos: 0,\n+    lines: vec![0],\n+    multi_byte_chars: vec![(1, 2)],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: multi_byte_char_long,\n+    text: \"0123456789abc\u0394f012345\u03b2\",\n+    filemap_start_pos: 0,\n+    lines: vec![0],\n+    multi_byte_chars: vec![(13, 2), (22, 2)],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: multi_byte_char_across_chunk_boundary,\n+    text: \"0123456789abcde\u0394123456789abcdef01234\",\n+    filemap_start_pos: 0,\n+    lines: vec![0],\n+    multi_byte_chars: vec![(15, 2)],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: multi_byte_char_across_chunk_boundary_tail,\n+    text: \"0123456789abcde\u0394....\",\n+    filemap_start_pos: 0,\n+    lines: vec![0],\n+    multi_byte_chars: vec![(15, 2)],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: non_narrow_short,\n+    text: \"0\\t2\",\n+    filemap_start_pos: 0,\n+    lines: vec![0],\n+    multi_byte_chars: vec![],\n+    non_narrow_chars: vec![(1, 4)],\n+);\n+\n+test!(\n+    case: non_narrow_long,\n+    text: \"01\\t3456789abcdef01234567\\u{07}9\",\n+    filemap_start_pos: 0,\n+    lines: vec![0],\n+    multi_byte_chars: vec![],\n+    non_narrow_chars: vec![(2, 4), (24, 0)],\n+);\n+\n+test!(\n+    case: output_offset_all,\n+    text: \"01\\t345\\n789abc\u0394f01234567\\u{07}9\\nbc\u0394f\",\n+    filemap_start_pos: 1000,\n+    lines: vec![0 + 1000, 7 + 1000, 27 + 1000],\n+    multi_byte_chars: vec![(13 + 1000, 2), (29 + 1000, 2)],\n+    non_narrow_chars: vec![(2 + 1000, 4), (24 + 1000, 0)],\n+);"}, {"sha": "55dec31511c37f506825d111b00dffe50e051c62", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 52, "deletions": 81, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f79d2f86af73da483f4fe8e2422c15c79221d32/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=9f79d2f86af73da483f4fe8e2422c15c79221d32", "patch": "@@ -24,6 +24,7 @@\n #![feature(optin_builtin_traits)]\n #![allow(unused_attributes)]\n #![feature(specialization)]\n+#![feature(stdsimd)]\n \n use std::borrow::Cow;\n use std::cell::Cell;\n@@ -47,6 +48,9 @@ use serialize::{Encodable, Decodable, Encoder, Decoder};\n extern crate serialize;\n extern crate serialize as rustc_serialize; // used by deriving\n \n+#[macro_use]\n+extern crate cfg_if;\n+\n extern crate unicode_width;\n \n pub mod edition;\n@@ -58,6 +62,8 @@ pub use span_encoding::{Span, DUMMY_SP};\n \n pub mod symbol;\n \n+mod analyze_filemap;\n+\n pub struct Globals {\n     symbol_interner: Lock<symbol::Interner>,\n     span_interner: Lock<span_encoding::SpanInterner>,\n@@ -652,16 +658,16 @@ impl From<Vec<Span>> for MultiSpan {\n pub const NO_EXPANSION: SyntaxContext = SyntaxContext::empty();\n \n /// Identifies an offset of a multi-byte character in a FileMap\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n pub struct MultiByteChar {\n     /// The absolute offset of the character in the CodeMap\n     pub pos: BytePos,\n     /// The number of bytes, >=2\n-    pub bytes: usize,\n+    pub bytes: u8,\n }\n \n /// Identifies an offset of a non-narrow character in a FileMap\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n pub enum NonNarrowChar {\n     /// Represents a zero-width character\n     ZeroWidth(BytePos),\n@@ -779,11 +785,11 @@ pub struct FileMap {\n     /// The end position of this source in the CodeMap\n     pub end_pos: BytePos,\n     /// Locations of lines beginnings in the source code\n-    pub lines: Lock<Vec<BytePos>>,\n+    pub lines: Vec<BytePos>,\n     /// Locations of multi-byte characters in the source code\n-    pub multibyte_chars: Lock<Vec<MultiByteChar>>,\n+    pub multibyte_chars: Vec<MultiByteChar>,\n     /// Width of characters that are not narrow in the source code\n-    pub non_narrow_chars: Lock<Vec<NonNarrowChar>>,\n+    pub non_narrow_chars: Vec<NonNarrowChar>,\n     /// A hash of the filename, used for speeding up the incr. comp. hashing.\n     pub name_hash: u128,\n }\n@@ -797,7 +803,7 @@ impl Encodable for FileMap {\n             s.emit_struct_field(\"start_pos\", 4, |s| self.start_pos.encode(s))?;\n             s.emit_struct_field(\"end_pos\", 5, |s| self.end_pos.encode(s))?;\n             s.emit_struct_field(\"lines\", 6, |s| {\n-                let lines = self.lines.borrow();\n+                let lines = &self.lines[..];\n                 // store the length\n                 s.emit_u32(lines.len() as u32)?;\n \n@@ -843,10 +849,10 @@ impl Encodable for FileMap {\n                 Ok(())\n             })?;\n             s.emit_struct_field(\"multibyte_chars\", 7, |s| {\n-                (*self.multibyte_chars.borrow()).encode(s)\n+                self.multibyte_chars.encode(s)\n             })?;\n             s.emit_struct_field(\"non_narrow_chars\", 8, |s| {\n-                (*self.non_narrow_chars.borrow()).encode(s)\n+                self.non_narrow_chars.encode(s)\n             })?;\n             s.emit_struct_field(\"name_hash\", 9, |s| {\n                 self.name_hash.encode(s)\n@@ -914,9 +920,9 @@ impl Decodable for FileMap {\n                 src: None,\n                 src_hash,\n                 external_src: Lock::new(ExternalSource::AbsentOk),\n-                lines: Lock::new(lines),\n-                multibyte_chars: Lock::new(multibyte_chars),\n-                non_narrow_chars: Lock::new(non_narrow_chars),\n+                lines,\n+                multibyte_chars,\n+                non_narrow_chars,\n                 name_hash,\n             })\n         })\n@@ -949,6 +955,9 @@ impl FileMap {\n         };\n         let end_pos = start_pos.to_usize() + src.len();\n \n+        let (lines, multibyte_chars, non_narrow_chars) =\n+            analyze_filemap::analyze_filemap(&src[..], start_pos);\n+\n         FileMap {\n             name,\n             name_was_remapped,\n@@ -959,37 +968,17 @@ impl FileMap {\n             external_src: Lock::new(ExternalSource::Unneeded),\n             start_pos,\n             end_pos: Pos::from_usize(end_pos),\n-            lines: Lock::new(Vec::new()),\n-            multibyte_chars: Lock::new(Vec::new()),\n-            non_narrow_chars: Lock::new(Vec::new()),\n+            lines,\n+            multibyte_chars,\n+            non_narrow_chars,\n             name_hash,\n         }\n     }\n \n-    /// EFFECT: register a start-of-line offset in the\n-    /// table of line-beginnings.\n-    /// UNCHECKED INVARIANT: these offsets must be added in the right\n-    /// order and must be in the right places; there is shared knowledge\n-    /// about what ends a line between this file and parse.rs\n-    /// WARNING: pos param here is the offset relative to start of CodeMap,\n-    /// and CodeMap will append a newline when adding a filemap without a newline at the end,\n-    /// so the safe way to call this is with value calculated as\n-    /// filemap.start_pos + newline_offset_relative_to_the_start_of_filemap.\n-    pub fn next_line(&self, pos: BytePos) {\n-        // the new charpos must be > the last one (or it's the first one).\n-        let mut lines = self.lines.borrow_mut();\n-        let line_len = lines.len();\n-        assert!(line_len == 0 || ((*lines)[line_len - 1] < pos));\n-        lines.push(pos);\n-    }\n-\n     /// Return the BytePos of the beginning of the current line.\n-    pub fn line_begin_pos(&self) -> BytePos {\n-        let lines = self.lines.borrow();\n-        match lines.last() {\n-            Some(&line_pos) => line_pos,\n-            None => self.start_pos,\n-        }\n+    pub fn line_begin_pos(&self, pos: BytePos) -> BytePos {\n+        let line_index = self.lookup_line(pos).unwrap();\n+        self.lines[line_index]\n     }\n \n     /// Add externally loaded source.\n@@ -1040,8 +1029,7 @@ impl FileMap {\n         }\n \n         let begin = {\n-            let lines = self.lines.borrow();\n-            let line = if let Some(line) = lines.get(line_number) {\n+            let line = if let Some(line) = self.lines.get(line_number) {\n                 line\n             } else {\n                 return None;\n@@ -1059,35 +1047,6 @@ impl FileMap {\n         }\n     }\n \n-    pub fn record_multibyte_char(&self, pos: BytePos, bytes: usize) {\n-        assert!(bytes >=2 && bytes <= 4);\n-        let mbc = MultiByteChar {\n-            pos,\n-            bytes,\n-        };\n-        self.multibyte_chars.borrow_mut().push(mbc);\n-    }\n-\n-    #[inline]\n-    pub fn record_width(&self, pos: BytePos, ch: char) {\n-        let width = match ch {\n-            '\\t' =>\n-                // Tabs will consume 4 columns.\n-                4,\n-            '\\n' =>\n-                // Make newlines take one column so that displayed spans can point them.\n-                1,\n-            ch =>\n-                // Assume control characters are zero width.\n-                // FIXME: How can we decide between `width` and `width_cjk`?\n-                unicode_width::UnicodeWidthChar::width(ch).unwrap_or(0),\n-        };\n-        // Only record non-narrow characters.\n-        if width != 1 {\n-            self.non_narrow_chars.borrow_mut().push(NonNarrowChar::new(pos, width));\n-        }\n-    }\n-\n     pub fn is_real_file(&self) -> bool {\n         self.name.is_real()\n     }\n@@ -1100,21 +1059,20 @@ impl FileMap {\n         self.end_pos.0 - self.start_pos.0\n     }\n     pub fn count_lines(&self) -> usize {\n-        self.lines.borrow().len()\n+        self.lines.len()\n     }\n \n     /// Find the line containing the given position. The return value is the\n     /// index into the `lines` array of this FileMap, not the 1-based line\n     /// number. If the filemap is empty or the position is located before the\n     /// first line, None is returned.\n     pub fn lookup_line(&self, pos: BytePos) -> Option<usize> {\n-        let lines = self.lines.borrow();\n-        if lines.len() == 0 {\n+        if self.lines.len() == 0 {\n             return None;\n         }\n \n-        let line_index = lookup_line(&lines[..], pos);\n-        assert!(line_index < lines.len() as isize);\n+        let line_index = lookup_line(&self.lines[..], pos);\n+        assert!(line_index < self.lines.len() as isize);\n         if line_index >= 0 {\n             Some(line_index as usize)\n         } else {\n@@ -1127,12 +1085,11 @@ impl FileMap {\n             return (self.start_pos, self.end_pos);\n         }\n \n-        let lines = self.lines.borrow();\n-        assert!(line_index < lines.len());\n-        if line_index == (lines.len() - 1) {\n-            (lines[line_index], self.end_pos)\n+        assert!(line_index < self.lines.len());\n+        if line_index == (self.lines.len() - 1) {\n+            (self.lines[line_index], self.end_pos)\n         } else {\n-            (lines[line_index], lines[line_index + 1])\n+            (self.lines[line_index], self.lines[line_index + 1])\n         }\n     }\n \n@@ -1156,6 +1113,8 @@ fn remove_bom(src: &mut String) {\n pub trait Pos {\n     fn from_usize(n: usize) -> Self;\n     fn to_usize(&self) -> usize;\n+    fn from_u32(n: u32) -> Self;\n+    fn to_u32(&self) -> u32;\n }\n \n /// A byte offset. Keep this small (currently 32-bits), as AST contains\n@@ -1177,7 +1136,13 @@ impl Pos for BytePos {\n     fn from_usize(n: usize) -> BytePos { BytePos(n as u32) }\n \n     #[inline(always)]\n-    fn to_usize(&self) -> usize { let BytePos(n) = *self; n as usize }\n+    fn to_usize(&self) -> usize { self.0 as usize }\n+\n+    #[inline(always)]\n+    fn from_u32(n: u32) -> BytePos { BytePos(n) }\n+\n+    #[inline(always)]\n+    fn to_u32(&self) -> u32 { self.0 }\n }\n \n impl Add for BytePos {\n@@ -1215,7 +1180,13 @@ impl Pos for CharPos {\n     fn from_usize(n: usize) -> CharPos { CharPos(n) }\n \n     #[inline(always)]\n-    fn to_usize(&self) -> usize { let CharPos(n) = *self; n }\n+    fn to_usize(&self) -> usize { self.0 }\n+\n+    #[inline(always)]\n+    fn from_u32(n: u32) -> CharPos { CharPos(n as usize) }\n+\n+    #[inline(always)]\n+    fn to_u32(&self) -> u32 { self.0 as u32}\n }\n \n impl Add for CharPos {"}]}