{"sha": "3e5de06135fa9a857931191101d61a4abe149c96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNWRlMDYxMzVmYTlhODU3OTMxMTkxMTAxZDYxYTRhYmUxNDljOTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-29T19:10:02Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-09-24T01:23:17Z"}, "message": "librustc: Change fold to use traits instead of `@fn`.", "tree": {"sha": "761478a49c1f1c2796e7f367c96688bc9794471f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/761478a49c1f1c2796e7f367c96688bc9794471f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e5de06135fa9a857931191101d61a4abe149c96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e5de06135fa9a857931191101d61a4abe149c96", "html_url": "https://github.com/rust-lang/rust/commit/3e5de06135fa9a857931191101d61a4abe149c96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e5de06135fa9a857931191101d61a4abe149c96/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97053995046636c0e11d23c4f0523d278a4210c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/97053995046636c0e11d23c4f0523d278a4210c9", "html_url": "https://github.com/rust-lang/rust/commit/97053995046636c0e11d23c4f0523d278a4210c9"}], "stats": {"total": 2505, "additions": 1291, "deletions": 1214}, "files": [{"sha": "fc1b034de97e1a86d90ed3142e50d73fd5d80fa0", "filename": "src/librustc/front/assign_node_ids.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs?ref=3e5de06135fa9a857931191101d61a4abe149c96", "patch": "@@ -11,9 +11,22 @@\n use driver::session::Session;\n \n use syntax::ast;\n-use syntax::ast_util;\n+use syntax::fold::ast_fold;\n+\n+struct NodeIdAssigner {\n+    sess: Session,\n+}\n+\n+impl ast_fold for NodeIdAssigner {\n+    fn new_id(&self, old_id: ast::NodeId) -> ast::NodeId {\n+        assert_eq!(old_id, ast::DUMMY_NODE_ID);\n+        self.sess.next_node_id()\n+    }\n+}\n \n pub fn assign_node_ids(sess: Session, crate: @ast::Crate) -> @ast::Crate {\n-    let fold = ast_util::node_id_assigner(|| sess.next_node_id());\n+    let fold = NodeIdAssigner {\n+        sess: sess,\n+    };\n     @fold.fold_crate(crate)\n }"}, {"sha": "fc1794fb93547a93925925bc6c6f71a8046bc06d", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=3e5de06135fa9a857931191101d61a4abe149c96", "patch": "@@ -10,6 +10,7 @@\n \n \n use std::option;\n+use syntax::fold::ast_fold;\n use syntax::{ast, fold, attr};\n \n type in_cfg_pred = @fn(attrs: &[ast::Attribute]) -> bool;\n@@ -26,21 +27,34 @@ pub fn strip_unconfigured_items(crate: @ast::Crate) -> @ast::Crate {\n     }\n }\n \n-pub fn strip_items(crate: &ast::Crate, in_cfg: in_cfg_pred)\n-    -> @ast::Crate {\n+struct ItemRemover {\n+    ctxt: @Context,\n+}\n \n-    let ctxt = @Context { in_cfg: in_cfg };\n+impl fold::ast_fold for ItemRemover {\n+    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+        fold_mod(self.ctxt, module, self)\n+    }\n+    fn fold_block(&self, block: &ast::Block) -> ast::Block {\n+        fold_block(self.ctxt, block, self)\n+    }\n+    fn fold_foreign_mod(&self, foreign_module: &ast::foreign_mod)\n+                        -> ast::foreign_mod {\n+        fold_foreign_mod(self.ctxt, foreign_module, self)\n+    }\n+    fn fold_item_underscore(&self, item: &ast::item_) -> ast::item_ {\n+        fold_item_underscore(self.ctxt, item, self)\n+    }\n+}\n \n-    let precursor = @fold::AstFoldFns {\n-          fold_mod: |a,b| fold_mod(ctxt, a, b),\n-          fold_block: |a,b| fold_block(ctxt, a, b),\n-          fold_foreign_mod: |a,b| fold_foreign_mod(ctxt, a, b),\n-          fold_item_underscore: |a,b| fold_item_underscore(ctxt, a, b),\n-          .. *fold::default_ast_fold()\n+pub fn strip_items(crate: &ast::Crate, in_cfg: in_cfg_pred) -> @ast::Crate {\n+    let ctxt = @Context {\n+        in_cfg: in_cfg,\n     };\n-\n-    let fold = fold::make_fold(precursor);\n-    @fold.fold_crate(crate)\n+    let precursor = ItemRemover {\n+        ctxt: ctxt,\n+    };\n+    @precursor.fold_crate(crate)\n }\n \n fn filter_item(cx: @Context, item: @ast::item) ->\n@@ -56,7 +70,7 @@ fn filter_view_item<'r>(cx: @Context, view_item: &'r ast::view_item)-> Option<&'\n     }\n }\n \n-fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n+fn fold_mod(cx: @Context, m: &ast::_mod, fld: &ItemRemover) -> ast::_mod {\n     let filtered_items = do  m.items.iter().filter_map |a| {\n         filter_item(cx, *a).and_then(|x| fld.fold_item(x))\n     }.collect();\n@@ -78,12 +92,12 @@ fn filter_foreign_item(cx: @Context, item: @ast::foreign_item) ->\n     } else { option::None }\n }\n \n-fn fold_foreign_mod(\n-    cx: @Context,\n-    nm: &ast::foreign_mod,\n-    fld: @fold::ast_fold\n-) -> ast::foreign_mod {\n-    let filtered_items = nm.items.iter().filter_map(|a| filter_foreign_item(cx, *a)).collect();\n+fn fold_foreign_mod(cx: @Context, nm: &ast::foreign_mod, fld: &ItemRemover)\n+                    -> ast::foreign_mod {\n+    let filtered_items = nm.items\n+                           .iter()\n+                           .filter_map(|a| filter_foreign_item(cx, *a))\n+                           .collect();\n     let filtered_view_items = do nm.view_items.iter().filter_map |a| {\n         do filter_view_item(cx, a).map_move |x| {\n             fld.fold_view_item(x)\n@@ -97,8 +111,8 @@ fn fold_foreign_mod(\n     }\n }\n \n-fn fold_item_underscore(cx: @Context, item: &ast::item_,\n-                        fld: @fold::ast_fold) -> ast::item_ {\n+fn fold_item_underscore(cx: @Context, item: &ast::item_, fld: &ItemRemover)\n+                        -> ast::item_ {\n     let item = match *item {\n         ast::item_impl(ref a, ref b, ref c, ref methods) => {\n             let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n@@ -133,11 +147,7 @@ fn filter_stmt(cx: @Context, stmt: @ast::Stmt) ->\n     }\n }\n \n-fn fold_block(\n-    cx: @Context,\n-    b: &ast::Block,\n-    fld: @fold::ast_fold\n-) -> ast::Block {\n+fn fold_block(cx: @Context, b: &ast::Block, fld: &ItemRemover) -> ast::Block {\n     let resulting_stmts = do b.stmts.iter().filter_map |a| {\n         filter_stmt(cx, *a).and_then(|stmt| fld.fold_stmt(stmt))\n     }.collect();"}, {"sha": "ab407806bcc678755e7c83c1a3d4df059e0e8317", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 96, "deletions": 83, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=3e5de06135fa9a857931191101d61a4abe149c96", "patch": "@@ -16,6 +16,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap::dummy_sp;\n use syntax::codemap;\n+use syntax::fold::ast_fold;\n use syntax::fold;\n use syntax::opt_vec;\n \n@@ -38,91 +39,103 @@ fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"no_implicit_prelude\")\n }\n \n-fn inject_libstd_ref(sess: Session, crate: &ast::Crate) -> @ast::Crate {\n-    fn spanned<T>(x: T) -> codemap::Spanned<T> {\n-        codemap::Spanned { node: x, span: dummy_sp() }\n+fn spanned<T>(x: T) -> codemap::Spanned<T> {\n+    codemap::Spanned {\n+        node: x,\n+        span: dummy_sp(),\n     }\n+}\n \n-    let precursor = @fold::AstFoldFns {\n-        fold_crate: |crate, fld| {\n-            let n1 = ast::DUMMY_NODE_ID;\n-            let vi1 = ast::view_item {\n-                node: ast::view_item_extern_mod(\n-                        sess.ident_of(\"std\"), None, ~[], n1),\n-                attrs: ~[\n-                    attr::mk_attr(\n-                        attr::mk_name_value_item_str(@\"vers\", STD_VERSION.to_managed()))\n-                ],\n-                vis: ast::private,\n-                span: dummy_sp()\n-            };\n-\n-            let vis = vec::append(~[vi1], crate.module.view_items);\n-            let mut new_module = ast::_mod {\n-                view_items: vis,\n-                ..crate.module.clone()\n-            };\n-\n-            if !no_prelude(crate.attrs) {\n-                // only add `use std::prelude::*;` if there wasn't a\n-                // `#[no_implicit_prelude];` at the crate level.\n-                new_module = fld.fold_mod(&new_module);\n-            }\n-\n-            // FIXME #2543: Bad copy.\n-            ast::Crate {\n-                module: new_module,\n-                ..(*crate).clone()\n-            }\n-        },\n-        fold_item: |item, fld| {\n-            if !no_prelude(item.attrs) {\n-                // only recur if there wasn't `#[no_implicit_prelude];`\n-                // on this item, i.e. this means that the prelude is not\n-                // implicitly imported though the whole subtree\n-                fold::noop_fold_item(item, fld)\n-            } else {\n-                Some(item)\n-            }\n-        },\n-        fold_mod: |module, fld| {\n-            let n2 = ast::DUMMY_NODE_ID;\n-\n-            let prelude_path = ast::Path {\n-                span: dummy_sp(),\n-                global: false,\n-                segments: ~[\n-                    ast::PathSegment {\n-                        identifier: sess.ident_of(\"std\"),\n-                        lifetime: None,\n-                        types: opt_vec::Empty,\n-                    },\n-                    ast::PathSegment {\n-                        identifier: sess.ident_of(\"prelude\"),\n-                        lifetime: None,\n-                        types: opt_vec::Empty,\n-                    },\n-                ],\n-            };\n-\n-            let vp = @spanned(ast::view_path_glob(prelude_path, n2));\n-            let vi2 = ast::view_item { node: ast::view_item_use(~[vp]),\n-                                        attrs: ~[],\n-                                        vis: ast::private,\n-                                        span: dummy_sp() };\n-\n-            let vis = vec::append(~[vi2], module.view_items);\n-\n-            // FIXME #2543: Bad copy.\n-            let new_module = ast::_mod {\n-                view_items: vis,\n-                ..(*module).clone()\n-            };\n-            fold::noop_fold_mod(&new_module, fld)\n-        },\n-        ..*fold::default_ast_fold()\n-    };\n+struct StandardLibraryInjector {\n+    sess: Session,\n+}\n \n-    let fold = fold::make_fold(precursor);\n+impl fold::ast_fold for StandardLibraryInjector {\n+    fn fold_crate(&self, crate: &ast::Crate) -> ast::Crate {\n+        let version = STD_VERSION.to_managed();\n+        let vi1 = ast::view_item {\n+            node: ast::view_item_extern_mod(self.sess.ident_of(\"std\"),\n+                                            None,\n+                                            ~[],\n+                                            ast::DUMMY_NODE_ID),\n+            attrs: ~[\n+                attr::mk_attr(attr::mk_name_value_item_str(@\"vers\", version))\n+            ],\n+            vis: ast::private,\n+            span: dummy_sp()\n+        };\n+\n+        let vis = vec::append(~[vi1], crate.module.view_items);\n+        let mut new_module = ast::_mod {\n+            view_items: vis,\n+            ..crate.module.clone()\n+        };\n+\n+        if !no_prelude(crate.attrs) {\n+            // only add `use std::prelude::*;` if there wasn't a\n+            // `#[no_implicit_prelude];` at the crate level.\n+            new_module = self.fold_mod(&new_module);\n+        }\n+\n+        // FIXME #2543: Bad copy.\n+        ast::Crate {\n+            module: new_module,\n+            ..(*crate).clone()\n+        }\n+    }\n+\n+    fn fold_item(&self, item: @ast::item) -> Option<@ast::item> {\n+        if !no_prelude(item.attrs) {\n+            // only recur if there wasn't `#[no_implicit_prelude];`\n+            // on this item, i.e. this means that the prelude is not\n+            // implicitly imported though the whole subtree\n+            fold::noop_fold_item(item, self)\n+        } else {\n+            Some(item)\n+        }\n+    }\n+\n+    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+        let prelude_path = ast::Path {\n+            span: dummy_sp(),\n+            global: false,\n+            segments: ~[\n+                ast::PathSegment {\n+                    identifier: self.sess.ident_of(\"std\"),\n+                    lifetime: None,\n+                    types: opt_vec::Empty,\n+                },\n+                ast::PathSegment {\n+                    identifier: self.sess.ident_of(\"prelude\"),\n+                    lifetime: None,\n+                    types: opt_vec::Empty,\n+                },\n+            ],\n+        };\n+\n+        let vp = @spanned(ast::view_path_glob(prelude_path,\n+                                              ast::DUMMY_NODE_ID));\n+        let vi2 = ast::view_item {\n+            node: ast::view_item_use(~[vp]),\n+            attrs: ~[],\n+            vis: ast::private,\n+            span: dummy_sp(),\n+        };\n+\n+        let vis = vec::append(~[vi2], module.view_items);\n+\n+        // FIXME #2543: Bad copy.\n+        let new_module = ast::_mod {\n+            view_items: vis,\n+            ..(*module).clone()\n+        };\n+        fold::noop_fold_mod(&new_module, self)\n+    }\n+}\n+\n+fn inject_libstd_ref(sess: Session, crate: &ast::Crate) -> @ast::Crate {\n+    let fold = StandardLibraryInjector {\n+        sess: sess,\n+    };\n     @fold.fold_crate(crate)\n }"}, {"sha": "d2baee6c961cd1477e8daadf4318d0a84f19f01e", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 87, "deletions": 88, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=3e5de06135fa9a857931191101d61a4abe149c96", "patch": "@@ -21,6 +21,7 @@ use syntax::attr;\n use syntax::codemap::{dummy_sp, Span, ExpnInfo, NameAndSpan};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n+use syntax::fold::ast_fold;\n use syntax::fold;\n use syntax::opt_vec;\n use syntax::print::pprust;\n@@ -61,9 +62,89 @@ pub fn modify_for_testing(sess: session::Session,\n     }\n }\n \n-fn generate_test_harness(sess: session::Session,\n-                         crate: @ast::Crate)\n-                      -> @ast::Crate {\n+struct TestHarnessGenerator {\n+    cx: @mut TestCtxt,\n+}\n+\n+impl fold::ast_fold for TestHarnessGenerator {\n+    fn fold_crate(&self, c: &ast::Crate) -> ast::Crate {\n+        let folded = fold::noop_fold_crate(c, self);\n+\n+        // Add a special __test module to the crate that will contain code\n+        // generated for the test harness\n+        ast::Crate {\n+            module: add_test_module(self.cx, &folded.module),\n+            .. folded\n+        }\n+    }\n+\n+    fn fold_item(&self, i: @ast::item) -> Option<@ast::item> {\n+        self.cx.path.push(i.ident);\n+        debug!(\"current path: %s\",\n+               ast_util::path_name_i(self.cx.path.clone()));\n+\n+        if is_test_fn(self.cx, i) || is_bench_fn(i) {\n+            match i.node {\n+                ast::item_fn(_, purity, _, _, _)\n+                    if purity == ast::unsafe_fn => {\n+                    let sess = self.cx.sess;\n+                    sess.span_fatal(i.span,\n+                                    \"unsafe functions cannot be used for \\\n+                                     tests\");\n+                }\n+                _ => {\n+                    debug!(\"this is a test function\");\n+                    let test = Test {\n+                        span: i.span,\n+                        path: self.cx.path.clone(),\n+                        bench: is_bench_fn(i),\n+                        ignore: is_ignored(self.cx, i),\n+                        should_fail: should_fail(i)\n+                    };\n+                    self.cx.testfns.push(test);\n+                    // debug!(\"have %u test/bench functions\",\n+                    //        cx.testfns.len());\n+                }\n+            }\n+        }\n+\n+        let res = fold::noop_fold_item(i, self);\n+        self.cx.path.pop();\n+        return res;\n+    }\n+\n+    fn fold_mod(&self, m: &ast::_mod) -> ast::_mod {\n+        // Remove any #[main] from the AST so it doesn't clash with\n+        // the one we're going to add. Only if compiling an executable.\n+\n+        fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n+            if !*cx.sess.building_library {\n+                @ast::item {\n+                    attrs: do item.attrs.iter().filter_map |attr| {\n+                        if \"main\" != attr.name() {\n+                            Some(*attr)\n+                        } else {\n+                            None\n+                        }\n+                    }.collect(),\n+                    .. (*item).clone()\n+                }\n+            } else {\n+                item\n+            }\n+        }\n+\n+        let mod_nomain = ast::_mod {\n+            view_items: m.view_items.clone(),\n+            items: m.items.iter().map(|i| nomain(self.cx, *i)).collect(),\n+        };\n+\n+        fold::noop_fold_mod(&mod_nomain, self)\n+    }\n+}\n+\n+fn generate_test_harness(sess: session::Session, crate: @ast::Crate)\n+                         -> @ast::Crate {\n     let cx: @mut TestCtxt = @mut TestCtxt {\n         sess: sess,\n         crate: crate,\n@@ -81,12 +162,9 @@ fn generate_test_harness(sess: session::Session,\n         }\n     });\n \n-    let precursor = @fold::AstFoldFns {\n-        fold_crate: |a,b| fold_crate(cx, a, b),\n-        fold_item: |a,b| fold_item(cx, a, b),\n-        fold_mod: |a,b| fold_mod(cx, a, b),.. *fold::default_ast_fold()};\n-\n-    let fold = fold::make_fold(precursor);\n+    let fold = TestHarnessGenerator {\n+        cx: cx\n+    };\n     let res = @fold.fold_crate(&*crate);\n     ext_cx.bt_pop();\n     return res;\n@@ -101,85 +179,6 @@ fn strip_test_functions(crate: &ast::Crate) -> @ast::Crate {\n     }\n }\n \n-fn fold_mod(cx: @mut TestCtxt,\n-            m: &ast::_mod,\n-            fld: @fold::ast_fold)\n-         -> ast::_mod {\n-    // Remove any #[main] from the AST so it doesn't clash with\n-    // the one we're going to add. Only if compiling an executable.\n-\n-    fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n-        if !*cx.sess.building_library {\n-            @ast::item {\n-                attrs: do item.attrs.iter().filter_map |attr| {\n-                    if \"main\" != attr.name() {\n-                        Some(*attr)\n-                    } else {\n-                        None\n-                    }\n-                }.collect(),\n-                .. (*item).clone()\n-            }\n-        } else {\n-            item\n-        }\n-    }\n-\n-    let mod_nomain = ast::_mod {\n-        view_items: m.view_items.clone(),\n-        items: m.items.iter().map(|i| nomain(cx, *i)).collect(),\n-    };\n-\n-    fold::noop_fold_mod(&mod_nomain, fld)\n-}\n-\n-fn fold_crate(cx: @mut TestCtxt, c: &ast::Crate, fld: @fold::ast_fold)\n-              -> ast::Crate {\n-    let folded = fold::noop_fold_crate(c, fld);\n-\n-    // Add a special __test module to the crate that will contain code\n-    // generated for the test harness\n-    ast::Crate {\n-        module: add_test_module(cx, &folded.module),\n-        .. folded\n-    }\n-}\n-\n-\n-fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n-          -> Option<@ast::item> {\n-    cx.path.push(i.ident);\n-    debug!(\"current path: %s\",\n-           ast_util::path_name_i(cx.path.clone()));\n-\n-    if is_test_fn(cx, i) || is_bench_fn(i) {\n-        match i.node {\n-          ast::item_fn(_, purity, _, _, _) if purity == ast::unsafe_fn => {\n-            let sess = cx.sess;\n-            sess.span_fatal(\n-                i.span,\n-                \"unsafe functions cannot be used for tests\");\n-          }\n-          _ => {\n-            debug!(\"this is a test function\");\n-            let test = Test {\n-                span: i.span,\n-                path: cx.path.clone(),\n-                bench: is_bench_fn(i),\n-                ignore: is_ignored(cx, i),\n-                should_fail: should_fail(i)\n-            };\n-            cx.testfns.push(test);\n-            // debug!(\"have %u test/bench functions\", cx.testfns.len());\n-          }\n-        }\n-    }\n-\n-    let res = fold::noop_fold_item(i, fld);\n-    cx.path.pop();\n-    return res;\n-}\n-\n fn is_test_fn(cx: @mut TestCtxt, i: @ast::item) -> bool {\n     let has_test_attr = attr::contains_name(i.attrs, \"test\");\n "}, {"sha": "6521b4bb3ccd9334c0c08b9f662bdebc7963bffa", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3e5de06135fa9a857931191101d61a4abe149c96", "patch": "@@ -287,26 +287,24 @@ fn encode_ast(ebml_w: &mut writer::Encoder, item: ast::inlined_item) {\n     ebml_w.end_tag();\n }\n \n-// Produces a simplified copy of the AST which does not include things\n-// that we do not need to or do not want to export.  For example, we\n-// do not include any nested items: if these nested items are to be\n-// inlined, their AST will be exported separately (this only makes\n-// sense because, in Rust, nested items are independent except for\n-// their visibility).\n-//\n-// As it happens, trans relies on the fact that we do not export\n-// nested items, as otherwise it would get confused when translating\n-// inlined items.\n-fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n-    fn drop_nested_items(blk: &ast::Block, fld: @fold::ast_fold) -> ast::Block {\n+struct NestedItemsDropper {\n+    contents: (),\n+}\n+\n+impl fold::ast_fold for NestedItemsDropper {\n+    fn fold_block(&self, blk: &ast::Block) -> ast::Block {\n         let stmts_sans_items = do blk.stmts.iter().filter_map |stmt| {\n             match stmt.node {\n-              ast::StmtExpr(_, _) | ast::StmtSemi(_, _) |\n-              ast::StmtDecl(@codemap::Spanned { node: ast::DeclLocal(_), span: _}, _)\n-                => Some(*stmt),\n-              ast::StmtDecl(@codemap::Spanned { node: ast::DeclItem(_), span: _}, _)\n-                => None,\n-              ast::StmtMac(*) => fail!(\"unexpanded macro in astencode\")\n+                ast::StmtExpr(_, _) | ast::StmtSemi(_, _) |\n+                ast::StmtDecl(@codemap::Spanned {\n+                    node: ast::DeclLocal(_),\n+                    span: _\n+                }, _) => Some(*stmt),\n+                ast::StmtDecl(@codemap::Spanned {\n+                    node: ast::DeclItem(_),\n+                    span: _\n+                }, _) => None,\n+                ast::StmtMac(*) => fail!(\"unexpanded macro in astencode\")\n             }\n         }.collect();\n         let blk_sans_items = ast::Block {\n@@ -318,13 +316,24 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n             rules: blk.rules,\n             span: blk.span,\n         };\n-        fold::noop_fold_block(&blk_sans_items, fld)\n+        fold::noop_fold_block(&blk_sans_items, self)\n     }\n+}\n \n-    let fld = fold::make_fold(@fold::AstFoldFns {\n-        fold_block: drop_nested_items,\n-        .. *fold::default_ast_fold()\n-    });\n+// Produces a simplified copy of the AST which does not include things\n+// that we do not need to or do not want to export.  For example, we\n+// do not include any nested items: if these nested items are to be\n+// inlined, their AST will be exported separately (this only makes\n+// sense because, in Rust, nested items are independent except for\n+// their visibility).\n+//\n+// As it happens, trans relies on the fact that we do not export\n+// nested items, as otherwise it would get confused when translating\n+// inlined items.\n+fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n+    let fld = NestedItemsDropper {\n+        contents: (),\n+    };\n \n     match *ii {\n         //hack: we're not dropping items\n@@ -341,14 +350,24 @@ fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     Decodable::decode(&mut d)\n }\n \n+struct AstRenumberer {\n+    xcx: @ExtendedDecodeContext,\n+}\n+\n+impl fold::ast_fold for AstRenumberer {\n+    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n+        self.xcx.tr_id(id)\n+    }\n+    fn new_span(&self, span: Span) -> Span {\n+        self.xcx.tr_span(span)\n+    }\n+}\n+\n fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n     -> ast::inlined_item {\n-    let fld = fold::make_fold(@fold::AstFoldFns{\n-        new_id: |a| xcx.tr_id(a),\n-        new_span: |a| xcx.tr_span(a),\n-        .. *fold::default_ast_fold()\n-    });\n-\n+    let fld = AstRenumberer {\n+        xcx: xcx,\n+    };\n     match ii {\n         ast::ii_item(i) => ast::ii_item(fld.fold_item(i).unwrap()),\n         ast::ii_method(d, is_provided, m) =>"}, {"sha": "02524b65020999876b4a925b955f6b8306ff24fb", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=3e5de06135fa9a857931191101d61a4abe149c96", "patch": "@@ -18,6 +18,8 @@ use syntax::codemap::{dummy_sp, Spanned};\n use syntax::ext::base::ExtCtxt;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::attr::AttrMetaMethods;\n+use syntax::fold::ast_fold;\n+use rustc::back::link::output_type_exe;\n use rustc::back::link;\n use rustc::driver::session::{lib_crate, bin_crate};\n use context::{in_target, StopBefore, Link, Assemble, BuildContext};\n@@ -70,9 +72,8 @@ struct ReadyCtx {\n     fns: ~[ListenerFn]\n }\n \n-fn fold_mod(_ctx: @mut ReadyCtx,\n-            m: &ast::_mod,\n-            fold: @fold::ast_fold) -> ast::_mod {\n+fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &CrateSetup)\n+            -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n             attrs: do item.attrs.iter().filter_map |attr| {\n@@ -94,9 +95,8 @@ fn fold_mod(_ctx: @mut ReadyCtx,\n     }, fold)\n }\n \n-fn fold_item(ctx: @mut ReadyCtx,\n-             item: @ast::item,\n-             fold: @fold::ast_fold) -> Option<@ast::item> {\n+fn fold_item(ctx: @mut ReadyCtx, item: @ast::item, fold: &CrateSetup)\n+             -> Option<@ast::item> {\n     ctx.path.push(item.ident);\n \n     let mut cmds = ~[];\n@@ -134,6 +134,19 @@ fn fold_item(ctx: @mut ReadyCtx,\n     res\n }\n \n+struct CrateSetup {\n+    ctx: @mut ReadyCtx,\n+}\n+\n+impl fold::ast_fold for CrateSetup {\n+    fn fold_item(&self, item: @ast::item) -> Option<@ast::item> {\n+        fold_item(self.ctx, item, self)\n+    }\n+    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+        fold_mod(self.ctx, module, self)\n+    }\n+}\n+\n /// Generate/filter main function, add the list of commands, etc.\n pub fn ready_crate(sess: session::Session,\n                    crate: @ast::Crate) -> @ast::Crate {\n@@ -144,15 +157,9 @@ pub fn ready_crate(sess: session::Session,\n         path: ~[],\n         fns: ~[]\n     };\n-    let precursor = @fold::AstFoldFns {\n-        // fold_crate: fold::wrap(|a, b| fold_crate(ctx, a, b)),\n-        fold_item: |a, b| fold_item(ctx, a, b),\n-        fold_mod: |a, b| fold_mod(ctx, a, b),\n-        .. *fold::default_ast_fold()\n+    let fold = CrateSetup {\n+        ctx: ctx,\n     };\n-\n-    let fold = fold::make_fold(precursor);\n-\n     @fold.fold_crate(crate)\n }\n "}, {"sha": "2e47050ad6a62ec4a6296155c5e6c133bd45f48f", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3e5de06135fa9a857931191101d61a4abe149c96", "patch": "@@ -12,7 +12,6 @@ use ast::*;\n use ast;\n use ast_util;\n use codemap::{Span, dummy_sp};\n-use fold;\n use opt_vec;\n use parse::token;\n use visit::Visitor;\n@@ -371,21 +370,6 @@ pub fn empty_generics() -> Generics {\n               ty_params: opt_vec::Empty}\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Assigning node ids\n-\n-fn node_id_assigner(next_id: @fn() -> ast::NodeId) -> @fold::ast_fold {\n-    let precursor = @fold::AstFoldFns {\n-        new_id: |old_id| {\n-            assert_eq!(old_id, ast::DUMMY_NODE_ID);\n-            next_id()\n-        },\n-        ..*fold::default_ast_fold()\n-    };\n-\n-    fold::make_fold(precursor)\n-}\n-\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n "}, {"sha": "aa4238ae9082a75973f480f766008302ab4c2829", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3e5de06135fa9a857931191101d61a4abe149c96", "patch": "@@ -15,6 +15,7 @@ use ast_util;\n use codemap::{Span, respan, dummy_sp};\n use ext::base::ExtCtxt;\n use ext::quote::rt::*;\n+use fold;\n use opt_vec;\n use opt_vec::OptVec;\n \n@@ -862,3 +863,32 @@ impl AstBuilder for @ExtCtxt {\n                                 ast::view_path_glob(self.path(sp, path), ast::DUMMY_NODE_ID))])\n     }\n }\n+\n+struct Duplicator {\n+    cx: @ExtCtxt,\n+}\n+\n+impl fold::ast_fold for Duplicator {\n+    fn new_id(&self, _: NodeId) -> NodeId { \n+        ast::DUMMY_NODE_ID\n+    }\n+}\n+\n+pub trait Duplicate {\n+    //\n+    // Duplication functions\n+    //\n+    // These functions just duplicate AST nodes.\n+    //\n+\n+    fn duplicate(&self, cx: @ExtCtxt) -> Self;\n+}\n+\n+impl Duplicate for @ast::Expr {\n+    fn duplicate(&self, cx: @ExtCtxt) -> @ast::Expr {\n+        let folder = @Duplicator {\n+            cx: cx,\n+        } as @fold::ast_fold;\n+        folder.fold_expr(*self)\n+    }\n+}"}, {"sha": "0aefbe31338f71aea2d87143de0d7ccb026587a7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 314, "deletions": 151, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3e5de06135fa9a857931191101d61a4abe149c96", "patch": "@@ -10,7 +10,7 @@\n \n use ast::{Block, Crate, DeclLocal, Expr_, ExprMac, SyntaxContext};\n use ast::{Local, Ident, mac_invoc_tt};\n-use ast::{item_mac, Mrk, Stmt_, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n+use ast::{item_mac, Mrk, Stmt, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n use ast::{token_tree};\n use ast;\n use ast_util::{mtwt_outer_mark, new_rename, new_mark};\n@@ -21,6 +21,7 @@ use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan};\n use ext::base::*;\n use fold::*;\n+use opt_vec;\n use parse;\n use parse::{parse_item_from_source_str};\n use parse::token;\n@@ -32,12 +33,10 @@ use std::vec;\n \n pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n-                   e: &Expr_,\n-                   span: Span,\n-                   fld: @ast_fold,\n-                   orig: @fn(&Expr_, Span, @ast_fold) -> (Expr_, Span))\n-                -> (Expr_, Span) {\n-    match *e {\n+                   e: @ast::Expr,\n+                   fld: &MacroExpander)\n+                   -> @ast::Expr {\n+    match e.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ExprMac(ref mac) => {\n@@ -66,7 +65,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                         }\n                         Some(@SE(NormalTT(expandfun, exp_span))) => {\n                             cx.bt_push(ExpnInfo {\n-                                call_site: span,\n+                                call_site: e.span,\n                                 callee: NameAndSpan {\n                                     name: extnamestr,\n                                     span: exp_span,\n@@ -101,12 +100,19 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             // mark after:\n                             let marked_after = mark_expr(expanded,fm);\n \n-                            //keep going, outside-in\n+                            // Keep going, outside-in.\n+                            //\n+                            // XXX(pcwalton): Is it necessary to clone the\n+                            // node here?\n                             let fully_expanded =\n                                 fld.fold_expr(marked_after).node.clone();\n                             cx.bt_pop();\n \n-                            (fully_expanded, span)\n+                            @ast::Expr {\n+                                id: ast::DUMMY_NODE_ID,\n+                                node: fully_expanded,\n+                                span: e.span,\n+                            }\n                         }\n                         _ => {\n                             cx.span_fatal(\n@@ -125,8 +131,48 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n         ast::ExprForLoop(src_pat, src_expr, ref src_loop_block, opt_ident) => {\n             // Expand any interior macros etc.\n             // NB: we don't fold pats yet. Curious.\n-            let src_expr = fld.fold_expr(src_expr);\n-            let src_loop_block = fld.fold_block(src_loop_block);\n+            let src_expr = fld.fold_expr(src_expr).clone();\n+            let src_loop_block = fld.fold_block(src_loop_block).clone();\n+\n+            let span = e.span;\n+\n+            pub fn mk_expr(_: @ExtCtxt, span: Span, node: Expr_)\n+                           -> @ast::Expr {\n+                @ast::Expr {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: node,\n+                    span: span,\n+                }\n+            }\n+\n+            fn mk_block(_: @ExtCtxt,\n+                        stmts: &[@ast::Stmt],\n+                        expr: Option<@ast::Expr>,\n+                        span: Span)\n+                        -> ast::Block {\n+                ast::Block {\n+                    view_items: ~[],\n+                    stmts: stmts.to_owned(),\n+                    expr: expr,\n+                    id: ast::DUMMY_NODE_ID,\n+                    rules: ast::DefaultBlock,\n+                    span: span,\n+                }\n+            }\n+\n+            fn mk_simple_path(ident: ast::Ident, span: Span) -> ast::Path {\n+                ast::Path {\n+                    span: span,\n+                    global: false,\n+                    segments: ~[\n+                        ast::PathSegment {\n+                            identifier: ident,\n+                            lifetime: None,\n+                            types: opt_vec::Empty,\n+                        }\n+                    ],\n+                }\n+            }\n \n             // to:\n             //\n@@ -182,10 +228,14 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                  ~[iter_decl_stmt],\n                                  Some(loop_expr));\n \n-            (ast::ExprBlock(block), span)\n+            @ast::Expr {\n+                id: ast::DUMMY_NODE_ID,\n+                node: ast::ExprBlock(block),\n+                span: span,\n+            }\n         }\n \n-        _ => orig(e, span, fld)\n+        _ => noop_fold_expr(e, fld)\n     }\n }\n \n@@ -201,12 +251,10 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n                         cx: @ExtCtxt,\n                         module_: &ast::_mod,\n-                        fld: @ast_fold,\n-                        orig: @fn(&ast::_mod, @ast_fold) -> ast::_mod)\n-                     -> ast::_mod {\n-\n+                        fld: &MacroExpander)\n+                        -> ast::_mod {\n     // Fold the contents first:\n-    let module_ = orig(module_, fld);\n+    let module_ = noop_fold_mod(module_, fld);\n \n     // For each item, look through the attributes.  If any of them are\n     // decorated with \"item decorators\", then use that function to transform\n@@ -233,7 +281,10 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n         }\n     };\n \n-    ast::_mod { items: new_items, ..module_ }\n+    ast::_mod {\n+        items: new_items,\n+        ..module_\n+    }\n }\n \n // eval $e with a new exts frame:\n@@ -256,19 +307,20 @@ static special_block_name : &'static str = \" block\";\n pub fn expand_item(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n                    it: @ast::item,\n-                   fld: @ast_fold,\n-                   orig: @fn(@ast::item, @ast_fold) -> Option<@ast::item>)\n-                -> Option<@ast::item> {\n+                   fld: &MacroExpander)\n+                   -> Option<@ast::item> {\n     match it.node {\n         ast::item_mac(*) => expand_item_mac(extsbox, cx, it, fld),\n         ast::item_mod(_) | ast::item_foreign_mod(_) => {\n             cx.mod_push(it.ident);\n             let macro_escape = contains_macro_escape(it.attrs);\n-            let result = with_exts_frame!(extsbox,macro_escape,orig(it,fld));\n+            let result = with_exts_frame!(extsbox,\n+                                          macro_escape,\n+                                          noop_fold_item(it, fld));\n             cx.mod_pop();\n             result\n         },\n-        _ => orig(it,fld)\n+        _ => noop_fold_item(it, fld)\n     }\n }\n \n@@ -280,11 +332,15 @@ pub fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n-                       cx: @ExtCtxt, it: @ast::item,\n-                       fld: @ast_fold)\n-                    -> Option<@ast::item> {\n+                       cx: @ExtCtxt,\n+                       it: @ast::item,\n+                       fld: &MacroExpander)\n+                       -> Option<@ast::item> {\n     let (pth, tts, ctxt) = match it.node {\n-        item_mac(codemap::Spanned { node: mac_invoc_tt(ref pth, ref tts, ctxt), _}) => {\n+        item_mac(codemap::Spanned {\n+            node: mac_invoc_tt(ref pth, ref tts, ctxt),\n+            _\n+        }) => {\n             (pth, (*tts).clone(), ctxt)\n         }\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n@@ -382,40 +438,39 @@ fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n // expand a stmt\n pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n-                   s: &Stmt_,\n-                   sp: Span,\n-                   fld: @ast_fold,\n-                   orig: @fn(&Stmt_, Span, @ast_fold)\n-                             -> (Option<Stmt_>, Span))\n-                -> (Option<Stmt_>, Span) {\n+                   s: &Stmt,\n+                   fld: &MacroExpander)\n+                   -> Option<@Stmt> {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n-    let (pth, tts, semi, ctxt) = match *s {\n+    let (pth, tts, semi, ctxt) = match s.node {\n         StmtMac(ref mac, semi) => {\n             match mac.node {\n                 mac_invoc_tt(ref pth, ref tts, ctxt) => {\n                     (pth, (*tts).clone(), semi, ctxt)\n                 }\n             }\n         }\n-        _ => return expand_non_macro_stmt(*extsbox,s,sp,fld,orig)\n+        _ => return expand_non_macro_stmt(*extsbox, s, fld)\n     };\n     if (pth.segments.len() > 1u) {\n-        cx.span_fatal(\n-            pth.span,\n-            fmt!(\"expected macro name without module \\\n-                  separators\"));\n+        cx.span_fatal(pth.span,\n+                      \"expected macro name without module separators\");\n     }\n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n-    let (fully_expanded, sp) = match (*extsbox).find(&extname.name) {\n-        None =>\n-            cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", extnamestr)),\n+    let fully_expanded: @ast::Stmt = match (*extsbox).find(&extname.name) {\n+        None => {\n+            cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", extnamestr))\n+        }\n \n         Some(@SE(NormalTT(expandfun, exp_span))) => {\n             cx.bt_push(ExpnInfo {\n-                call_site: sp,\n-                callee: NameAndSpan { name: extnamestr, span: exp_span }\n+                call_site: s.span,\n+                callee: NameAndSpan {\n+                    name: extnamestr,\n+                    span: exp_span,\n+                }\n             });\n             let fm = fresh_mark();\n             // mark before expansion:\n@@ -426,32 +481,40 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             // not the current mac.span.\n             let mac_span = original_span(cx);\n \n-            let expanded = match expandfun(cx, mac_span.call_site,\n-                                           marked_tts, marked_ctxt) {\n-                MRExpr(e) =>\n-                    @codemap::Spanned { node: StmtExpr(e, ast::DUMMY_NODE_ID),\n-                                        span: e.span},\n+            let expanded = match expandfun(cx,\n+                                           mac_span.call_site,\n+                                           marked_tts,\n+                                           marked_ctxt) {\n+                MRExpr(e) => {\n+                    @codemap::Spanned {\n+                        node: StmtExpr(e, ast::DUMMY_NODE_ID),\n+                        span: e.span,\n+                    }\n+                }\n                 MRAny(_,_,stmt_mkr) => stmt_mkr(),\n                 _ => cx.span_fatal(\n                     pth.span,\n                     fmt!(\"non-stmt macro in stmt pos: %s\", extnamestr))\n             };\n             let marked_after = mark_stmt(expanded,fm);\n \n-            //keep going, outside-in\n+            // Keep going, outside-in.\n             let fully_expanded = match fld.fold_stmt(marked_after) {\n                 Some(stmt) => {\n                     let fully_expanded = &stmt.node;\n                     cx.bt_pop();\n-                    (*fully_expanded).clone()\n+                    @Spanned {\n+                        span: stmt.span,\n+                        node: (*fully_expanded).clone(),\n+                    }\n                 }\n                 None => {\n                     cx.span_fatal(pth.span,\n                                   \"macro didn't expand to a statement\")\n                 }\n             };\n \n-            (fully_expanded, sp)\n+            fully_expanded\n         }\n \n         _ => {\n@@ -460,24 +523,28 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n         }\n     };\n \n-    (match fully_expanded {\n-        StmtExpr(e, stmt_id) if semi => Some(StmtSemi(e, stmt_id)),\n-        _ => { Some(fully_expanded) } /* might already have a semi */\n-    }, sp)\n-\n+    match fully_expanded.node {\n+        StmtExpr(e, stmt_id) if semi => {\n+            Some(@Spanned {\n+                span: fully_expanded.span,\n+                node: StmtSemi(e, stmt_id),\n+            })\n+        }\n+        _ => Some(fully_expanded), /* might already have a semi */\n+    }\n }\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n-fn expand_non_macro_stmt (exts: SyntaxEnv,\n-                          s: &Stmt_,\n-                          sp: Span,\n-                          fld: @ast_fold,\n-                          orig: @fn(&Stmt_, Span, @ast_fold) -> (Option<Stmt_>, Span))\n-    -> (Option<Stmt_>,Span) {\n+fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n+                         -> Option<@Stmt> {\n     // is it a let?\n-    match *s {\n-        StmtDecl(@Spanned{node: DeclLocal(ref local), span: stmt_span}, node_id) => {\n+    match s.node {\n+        StmtDecl(@Spanned {\n+            node: DeclLocal(ref local),\n+            span: stmt_span\n+        },\n+        node_id) => {\n             let block_info = get_block_info(exts);\n             let pending_renames = block_info.pending_renames;\n \n@@ -515,19 +582,24 @@ fn expand_non_macro_stmt (exts: SyntaxEnv,\n             // also, don't forget to expand the init:\n             let new_init_opt = init.map(|e| fld.fold_expr(*e));\n             let rewritten_local =\n-                @Local{is_mutbl:is_mutbl,\n-                       ty:ty,\n-                       pat:rewritten_pat,\n-                       init:new_init_opt,\n-                       id:id,\n-                       span:span};\n-            (Some(StmtDecl(@Spanned{node:DeclLocal(rewritten_local),\n-                                     span: stmt_span},node_id)),\n-             sp)\n+                @Local {\n+                    is_mutbl: is_mutbl,\n+                    ty: ty,\n+                    pat: rewritten_pat,\n+                    init: new_init_opt,\n+                    id: id,\n+                    span: span,\n+                };\n+            Some(@Spanned {\n+                node: StmtDecl(@Spanned {\n+                        node: DeclLocal(rewritten_local),\n+                        span: stmt_span\n+                    },\n+                    node_id),\n+                span: span\n+            })\n         },\n-        _ => {\n-            orig(s, sp, fld)\n-        }\n+        _ => noop_fold_stmt(s, fld),\n     }\n }\n \n@@ -628,18 +700,18 @@ pub fn new_path_finder(paths: @mut ~[ast::Path]) -> @mut Visitor<()> {\n \n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n pub fn expand_block(extsbox: @mut SyntaxEnv,\n-                    _cx: @ExtCtxt,\n+                    _: @ExtCtxt,\n                     blk: &Block,\n-                    fld: @ast_fold,\n-                    _orig: @fn(&Block, @ast_fold) -> Block)\n-                 -> Block {\n+                    fld: &MacroExpander)\n+                    -> Block {\n     // see note below about treatment of exts table\n     with_exts_frame!(extsbox,false,\n                      expand_block_elts(*extsbox, blk, fld))\n }\n \n // expand the elements of a block.\n-pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: @ast_fold) -> Block {\n+pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n+                         -> Block {\n     let block_info = get_block_info(exts);\n     let pending_renames = block_info.pending_renames;\n     let rename_fld = renames_to_fold(pending_renames);\n@@ -680,9 +752,47 @@ fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n     }\n }\n \n+struct IdentRenamer {\n+    renames: @mut ~[(ast::Ident,ast::Name)],\n+}\n+\n+impl ast_fold for IdentRenamer {\n+    fn fold_ident(&self, id: ast::Ident) -> ast::Ident {\n+        let new_ctxt = self.renames.iter().fold(id.ctxt, |ctxt, &(from, to)| {\n+            new_rename(from, to, ctxt)\n+        });\n+        ast::Ident {\n+            name: id.name,\n+            ctxt: new_ctxt,\n+        }\n+    }\n+}\n+\n+// given a mutable list of renames, return a tree-folder that applies those\n+// renames.\n+fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n+    @IdentRenamer {\n+        renames: renames,\n+    } as @ast_fold\n+}\n+\n+// perform a bunch of renames\n+fn apply_pending_renames(folder : @ast_fold, stmt : ast::Stmt) -> @ast::Stmt {\n+    match folder.fold_stmt(&stmt) {\n+        Some(s) => s,\n+        None => fail!(fmt!(\"renaming of stmt produced None\"))\n+    }\n+}\n+\n+\n+\n pub fn new_span(cx: @ExtCtxt, sp: Span) -> Span {\n     /* this discards information in the case of macro-defining macros */\n-    return Span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n+    Span {\n+        lo: sp.lo,\n+        hi: sp.hi,\n+        expn_info: cx.backtrace(),\n+    }\n }\n \n // FIXME (#2247): this is a moderately bad kludge to inject some macros into\n@@ -1025,10 +1135,28 @@ pub fn std_macros() -> @str {\n }\";\n }\n \n+struct Injector {\n+    sm: @ast::item,\n+}\n+\n+impl ast_fold for Injector {\n+    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+        // Just inject the standard macros at the start of the first module\n+        // in the crate: that is, at the start of the crate file itself.\n+        let items = vec::append(~[ self.sm ], module.items);\n+        ast::_mod {\n+            items: items,\n+            ..(*module).clone() // FIXME #2543: Bad copy.\n+        }\n+    }\n+}\n+\n // add a bunch of macros as though they were placed at the head of the\n // program (ick). This should run before cfg stripping.\n pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n-                         cfg: ast::CrateConfig, c: &Crate) -> @Crate {\n+                         cfg: ast::CrateConfig,\n+                         c: @Crate)\n+                         -> @Crate {\n     let sm = match parse_item_from_source_str(@\"<std-macros>\",\n                                               std_macros(),\n                                               cfg.clone(),\n@@ -1038,48 +1166,80 @@ pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n         None => fail!(\"expected core macros to parse correctly\")\n     };\n \n-    let injecter = @AstFoldFns {\n-        fold_mod: |modd, _| {\n-            // just inject the std macros at the start of the first\n-            // module in the crate (i.e the crate file itself.)\n-            let items = vec::append(~[sm], modd.items);\n-            ast::_mod {\n-                items: items,\n-                // FIXME #2543: Bad copy.\n-                .. (*modd).clone()\n-            }\n-        },\n-        .. *default_ast_fold()\n-    };\n-    @make_fold(injecter).fold_crate(c)\n+    let injector = @Injector {\n+        sm: sm,\n+    } as @ast_fold;\n+    @injector.fold_crate(c)\n+}\n+\n+struct NoOpFolder {\n+    contents: (),\n+}\n+\n+impl ast_fold for NoOpFolder {}\n+\n+struct MacroExpander {\n+    extsbox: @mut SyntaxEnv,\n+    cx: @ExtCtxt,\n+}\n+\n+impl ast_fold for MacroExpander {\n+    fn fold_expr(&self, expr: @ast::Expr) -> @ast::Expr {\n+        expand_expr(self.extsbox,\n+                    self.cx,\n+                    expr,\n+                    self)\n+    }\n+\n+    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+        expand_mod_items(self.extsbox,\n+                         self.cx,\n+                         module,\n+                         self)\n+    }\n+\n+    fn fold_item(&self, item: @ast::item) -> Option<@ast::item> {\n+        expand_item(self.extsbox,\n+                    self.cx,\n+                    item,\n+                    self)\n+    }\n+\n+    fn fold_stmt(&self, stmt: &ast::Stmt) -> Option<@ast::Stmt> {\n+        expand_stmt(self.extsbox,\n+                    self.cx,\n+                    stmt,\n+                    self)\n+    }\n+\n+    fn fold_block(&self, block: &ast::Block) -> ast::Block {\n+        expand_block(self.extsbox,\n+                     self.cx,\n+                     block,\n+                     self)\n+    }\n+\n+    fn new_span(&self, span: Span) -> Span {\n+        new_span(self.cx, span)\n+    }\n }\n \n pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n-                    cfg: ast::CrateConfig, c: &Crate) -> @Crate {\n+                    cfg: ast::CrateConfig,\n+                    c: &Crate) -> @Crate {\n     // adding *another* layer of indirection here so that the block\n     // visitor can swap out one exts table for another for the duration\n     // of the block.  The cleaner alternative would be to thread the\n     // exts table through the fold, but that would require updating\n     // every method/element of AstFoldFns in fold.rs.\n-    let extsbox = @mut syntax_expander_table();\n-    let afp = default_ast_fold();\n+    let extsbox = syntax_expander_table();\n     let cx = ExtCtxt::new(parse_sess, cfg.clone());\n-    let f_pre = @AstFoldFns {\n-        fold_expr: |expr,span,recur|\n-            expand_expr(extsbox, cx, expr, span, recur, afp.fold_expr),\n-        fold_mod: |modd,recur|\n-            expand_mod_items(extsbox, cx, modd, recur, afp.fold_mod),\n-        fold_item: |item,recur|\n-            expand_item(extsbox, cx, item, recur, afp.fold_item),\n-        fold_stmt: |stmt,span,recur|\n-            expand_stmt(extsbox, cx, stmt, span, recur, afp.fold_stmt),\n-        fold_block: |blk,recur|\n-            expand_block(extsbox, cx, blk, recur, afp.fold_block),\n-        new_span: |a| new_span(cx, a),\n-        .. *afp};\n-    let f = make_fold(f_pre);\n-\n-    let ret = @f.fold_crate(c);\n+    let expander = @MacroExpander {\n+        extsbox: @mut extsbox,\n+        cx: cx,\n+    } as @ast_fold;\n+\n+    let ret = @expander.fold_crate(c);\n     parse_sess.span_diagnostic.handler().abort_if_errors();\n     return ret;\n }\n@@ -1145,53 +1305,56 @@ impl CtxtFn for Repainter {\n     }\n }\n \n-// given a function from ctxts to ctxts, produce\n-// an ast_fold that applies that function to all ctxts:\n-pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @AstFoldFns {\n-    let afp = default_ast_fold();\n-    let fi : @fn(ast::Ident, @ast_fold) -> ast::Ident =\n-        |ast::Ident{name, ctxt}, _| {\n-        ast::Ident{name:name,ctxt:cf.f(ctxt)}\n-    };\n-    let fm : @fn(&ast::mac_, Span, @ast_fold) -> (ast::mac_,Span) =\n-        |m, sp, fld| {\n-        match *m {\n-            mac_invoc_tt(ref path, ref tts, ctxt) =>\n-            (mac_invoc_tt(fld.fold_path(path),\n-                          fold_tts(*tts,fld),\n-                          cf.f(ctxt)),\n-            sp)\n-        }\n+pub struct ContextWrapper {\n+    context_function: @CtxtFn,\n+}\n \n-    };\n-    @AstFoldFns{\n-        fold_ident : fi,\n-        fold_mac : fm,\n-        .. *afp\n+impl ast_fold for ContextWrapper {\n+    fn fold_ident(&self, id: ast::Ident) -> ast::Ident {\n+        let ast::Ident {\n+            name,\n+            ctxt\n+        } = id;\n+        ast::Ident {\n+            name: name,\n+            ctxt: self.context_function.f(ctxt),\n+        }\n+    }\n+    fn fold_mac(&self, m: &ast::mac) -> ast::mac {\n+        let macro = match m.node {\n+            mac_invoc_tt(ref path, ref tts, ctxt) => {\n+                mac_invoc_tt(self.fold_path(path),\n+                             fold_tts(*tts, self),\n+                             self.context_function.f(ctxt))\n+            }\n+        };\n+        Spanned {\n+            node: macro,\n+            span: m.span,\n+        }\n     }\n }\n \n-\n-\n-// given a mutable list of renames, return a tree-folder that applies those\n-// renames.\n-// FIXME #4536: currently pub to allow testing\n-pub fn renames_to_fold(renames : @mut ~[(ast::Ident,ast::Name)]) -> @AstFoldFns {\n-    fun_to_ctxt_folder(@MultiRenamer{renames : renames})\n+// given a function from ctxts to ctxts, produce\n+// an ast_fold that applies that function to all ctxts:\n+pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @ContextWrapper {\n+    @ContextWrapper {\n+        context_function: cf as @CtxtFn,\n+    }\n }\n \n // just a convenience:\n-pub fn new_mark_folder(m : Mrk) -> @AstFoldFns {\n+pub fn new_mark_folder(m: Mrk) -> @ContextWrapper {\n     fun_to_ctxt_folder(@Marker{mark:m})\n }\n \n-pub fn new_rename_folder(from : ast::Ident, to : ast::Name) -> @AstFoldFns {\n+pub fn new_rename_folder(from: ast::Ident, to: ast::Name) -> @ContextWrapper {\n     fun_to_ctxt_folder(@Renamer{from:from,to:to})\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n fn mark_tts(tts : &[token_tree], m : Mrk) -> ~[token_tree] {\n-    fold_tts(tts,new_mark_folder(m) as @ast_fold)\n+    fold_tts(tts,new_mark_folder(m))\n }\n \n // apply a given mark to the given expr. Used following the expansion of a macro."}, {"sha": "18ddee3417152e08e3d3e4b9688b9f4f1a46a9d9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 635, "deletions": 805, "changes": 1440, "blob_url": "https://github.com/rust-lang/rust/blob/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5de06135fa9a857931191101d61a4abe149c96/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3e5de06135fa9a857931191101d61a4abe149c96", "patch": "@@ -14,227 +14,434 @@ use codemap::{Span, Spanned};\n use parse::token;\n use opt_vec::OptVec;\n \n-// this file defines an ast_fold trait for objects that can perform\n-// a \"fold\" on Rust ASTs. It also contains a structure that implements\n-// that trait, and a \"default_fold\" whose fields contain closures\n-// that perform \"default traversals\", visiting all of the sub-elements\n-// and re-assembling the result. The \"fun_to_ident_folder\" in the\n-// test module provides a simple example of creating a very simple\n-// fold that only looks at identifiers.\n-\n+// We may eventually want to be able to fold over type parameters, too.\n pub trait ast_fold {\n-    fn fold_crate(@self, &Crate) -> Crate;\n-    fn fold_view_item(@self, &view_item) -> view_item;\n-    fn fold_foreign_item(@self, @foreign_item) -> @foreign_item;\n-    fn fold_item(@self, @item) -> Option<@item>;\n-    fn fold_struct_field(@self, @struct_field) -> @struct_field;\n-    fn fold_item_underscore(@self, &item_) -> item_;\n-    fn fold_type_method(@self, m: &TypeMethod) -> TypeMethod;\n-    fn fold_method(@self, @method) -> @method;\n-    fn fold_block(@self, &Block) -> Block;\n-    fn fold_stmt(@self, &Stmt) -> Option<@Stmt>;\n-    fn fold_arm(@self, &Arm) -> Arm;\n-    fn fold_pat(@self, @Pat) -> @Pat;\n-    fn fold_decl(@self, @Decl) -> Option<@Decl>;\n-    fn fold_expr(@self, @Expr) -> @Expr;\n-    fn fold_ty(@self, &Ty) -> Ty;\n-    fn fold_mod(@self, &_mod) -> _mod;\n-    fn fold_foreign_mod(@self, &foreign_mod) -> foreign_mod;\n-    fn fold_variant(@self, &variant) -> variant;\n-    fn fold_ident(@self, Ident) -> Ident;\n-    fn fold_path(@self, &Path) -> Path;\n-    fn fold_local(@self, @Local) -> @Local;\n-    fn fold_mac(@self, &mac) -> mac;\n-    fn map_exprs(@self, @fn(@Expr) -> @Expr, &[@Expr]) -> ~[@Expr];\n-    fn new_id(@self, NodeId) -> NodeId;\n-    fn new_span(@self, Span) -> Span;\n-\n-    // New style, using default methods:\n-\n-    fn fold_variant_arg(@self, va: &variant_arg) -> variant_arg {\n-        variant_arg {\n-            ty: self.fold_ty(&va.ty),\n-            id: self.new_id(va.id)\n-        }\n-    }\n-\n-    fn fold_spanned<T>(@self, s: &Spanned<T>, f: &fn(&T) -> T) -> Spanned<T> {\n-        Spanned {\n-            node: f(&s.node),\n-            span: self.new_span(s.span)\n-        }\n+    fn fold_crate(&self, c: &Crate) -> Crate {\n+        noop_fold_crate(c, self)\n     }\n \n-    fn fold_view_path(@self, vp: &view_path) -> view_path {\n-        self.fold_spanned(vp, |v| self.fold_view_path_(v))\n+    fn fold_meta_items(&self, meta_items: &[@MetaItem]) -> ~[@MetaItem] {\n+        meta_items.map(|x| fold_meta_item_(*x, self))\n     }\n \n-    fn fold_view_paths(@self, vps: &[@view_path]) -> ~[@view_path] {\n-        vps.map(|vp| @self.fold_view_path(*vp))\n+    fn fold_view_paths(&self, view_paths: &[@view_path]) -> ~[@view_path] {\n+        view_paths.map(|view_path| {\n+            let inner_view_path = match view_path.node {\n+                view_path_simple(ref ident, ref path, node_id) => {\n+                    view_path_simple(ident.clone(),\n+                                     self.fold_path(path),\n+                                     self.new_id(node_id))\n+                }\n+                view_path_glob(ref path, node_id) => {\n+                    view_path_glob(self.fold_path(path), self.new_id(node_id))\n+                }\n+                view_path_list(ref path, ref path_list_idents, node_id) => {\n+                    view_path_list(self.fold_path(path),\n+                                   path_list_idents.map(|path_list_ident| {\n+                                    let id = self.new_id(path_list_ident.node\n+                                                                        .id);\n+                                    Spanned {\n+                                        node: path_list_ident_ {\n+                                            name: path_list_ident.node\n+                                                                 .name\n+                                                                 .clone(),\n+                                            id: id,\n+                                        },\n+                                        span: self.new_span(\n+                                            path_list_ident.span)\n+                                   }\n+                                  }),\n+                                  self.new_id(node_id))\n+                }\n+            };\n+            @Spanned {\n+                node: inner_view_path,\n+                span: self.new_span(view_path.span),\n+            }\n+        })\n     }\n \n-    fn fold_view_path_(@self, vp: &view_path_) -> view_path_ {\n-        match *vp {\n-            view_path_simple(ident, ref path, node_id) => {\n-                view_path_simple(self.fold_ident(ident),\n-                                 self.fold_path(path),\n-                                 self.new_id(node_id))\n-            }\n-            view_path_glob(ref path, node_id) => {\n-                view_path_glob(self.fold_path(path),\n-                               self.new_id(node_id))\n+    fn fold_view_item(&self, vi: &view_item) -> view_item {\n+        let inner_view_item = match vi.node {\n+            view_item_extern_mod(ref ident,\n+                                 string,\n+                                 ref meta_items,\n+                                 node_id) => {\n+                view_item_extern_mod(ident.clone(),\n+                                     string,\n+                                     self.fold_meta_items(*meta_items),\n+                                     self.new_id(node_id))\n             }\n-            view_path_list(ref path, ref idents, node_id) => {\n-                view_path_list(self.fold_path(path),\n-                               self.fold_path_list_idents(*idents),\n-                               self.new_id(node_id))\n+            view_item_use(ref view_paths) => {\n+                view_item_use(self.fold_view_paths(*view_paths))\n             }\n+        };\n+        view_item {\n+            node: inner_view_item,\n+            attrs: vi.attrs.map(|a| fold_attribute_(*a, self)),\n+            vis: vi.vis,\n+            span: self.new_span(vi.span),\n+        }\n+    }\n+\n+    fn fold_foreign_item(&self, ni: @foreign_item) -> @foreign_item {\n+        let fold_attribute = |x| fold_attribute_(x, self);\n+\n+        @ast::foreign_item {\n+            ident: self.fold_ident(ni.ident),\n+            attrs: ni.attrs.map(|x| fold_attribute(*x)),\n+            node:\n+                match ni.node {\n+                    foreign_item_fn(ref fdec, ref generics) => {\n+                        foreign_item_fn(\n+                            ast::fn_decl {\n+                                inputs: fdec.inputs.map(|a| fold_arg_(a,\n+                                                                      self)),\n+                                output: self.fold_ty(&fdec.output),\n+                                cf: fdec.cf,\n+                            },\n+                            fold_generics(generics, self))\n+                    }\n+                    foreign_item_static(ref t, m) => {\n+                        foreign_item_static(self.fold_ty(t), m)\n+                    }\n+                },\n+            id: self.new_id(ni.id),\n+            span: self.new_span(ni.span),\n+            vis: ni.vis,\n         }\n     }\n \n-    fn fold_path_list_idents(@self, idents: &[path_list_ident]) -> ~[path_list_ident] {\n-        idents.map(|i| self.fold_path_list_ident(i))\n+    fn fold_item(&self, i: @item) -> Option<@item> {\n+        noop_fold_item(i, self)\n     }\n \n-    fn fold_path_list_ident(@self, ident: &path_list_ident) -> path_list_ident {\n-        self.fold_spanned(ident, |i| self.fold_path_list_ident_(i))\n-    }\n+    fn fold_struct_field(&self, sf: @struct_field) -> @struct_field {\n+        let fold_attribute = |x| fold_attribute_(x, self);\n \n-    fn fold_path_list_ident_(@self, ident: &path_list_ident_) -> path_list_ident_ {\n-        path_list_ident_ {\n-            name: self.fold_ident(ident.name),\n-            id: self.new_id(ident.id)\n+        @Spanned {\n+            node: ast::struct_field_ {\n+                kind: sf.node.kind,\n+                id: self.new_id(sf.node.id),\n+                ty: self.fold_ty(&sf.node.ty),\n+                attrs: sf.node.attrs.map(|e| fold_attribute(*e))\n+            },\n+            span: self.new_span(sf.span)\n         }\n     }\n \n-    fn fold_arg(@self, a: &arg) -> arg {\n-        arg {\n-            is_mutbl: a.is_mutbl,\n-            ty: self.fold_ty(&a.ty),\n-            pat: self.fold_pat(a.pat),\n-            id: self.new_id(a.id),\n+    fn fold_item_underscore(&self, i: &item_) -> item_ {\n+        noop_fold_item_underscore(i, self)\n+    }\n+\n+    fn fold_type_method(&self, m: &TypeMethod) -> TypeMethod {\n+        noop_fold_type_method(m, self)\n+    }\n+\n+    fn fold_method(&self, m: @method) -> @method {\n+        @ast::method {\n+            ident: self.fold_ident(m.ident),\n+            attrs: m.attrs.map(|a| fold_attribute_(*a, self)),\n+            generics: fold_generics(&m.generics, self),\n+            explicit_self: m.explicit_self,\n+            purity: m.purity,\n+            decl: fold_fn_decl(&m.decl, self),\n+            body: self.fold_block(&m.body),\n+            id: self.new_id(m.id),\n+            span: self.new_span(m.span),\n+            self_id: self.new_id(m.self_id),\n+            vis: m.vis,\n         }\n     }\n \n-    fn fold_trait_ref(@self, p: &trait_ref) -> trait_ref {\n-        trait_ref {\n-            path: self.fold_path(&p.path),\n-            ref_id: self.new_id(p.ref_id),\n+    fn fold_block(&self, b: &Block) -> Block {\n+        noop_fold_block(b, self)\n+    }\n+\n+    fn fold_stmt(&self, s: &Stmt) -> Option<@Stmt> {\n+        noop_fold_stmt(s, self)\n+    }\n+\n+    fn fold_arm(&self, a: &Arm) -> Arm {\n+        Arm {\n+            pats: a.pats.map(|x| self.fold_pat(*x)),\n+            guard: a.guard.map_move(|x| self.fold_expr(x)),\n+            body: self.fold_block(&a.body),\n         }\n     }\n \n-    fn fold_ty_param_bound(@self, tpb: &TyParamBound) -> TyParamBound {\n-        match *tpb {\n-            TraitTyParamBound(ref ty) => {\n-                TraitTyParamBound(self.fold_trait_ref(ty))\n+    fn fold_pat(&self, p: @Pat) -> @Pat {\n+        let node = match p.node {\n+            PatWild => PatWild,\n+            PatIdent(binding_mode, ref pth, ref sub) => {\n+                PatIdent(binding_mode,\n+                         self.fold_path(pth),\n+                         sub.map_move(|x| self.fold_pat(x)))\n+            }\n+            PatLit(e) => PatLit(self.fold_expr(e)),\n+            PatEnum(ref pth, ref pats) => {\n+                PatEnum(self.fold_path(pth),\n+                        pats.map(|pats| pats.map(|x| self.fold_pat(*x))))\n             }\n-            RegionTyParamBound => {\n-                RegionTyParamBound\n+            PatStruct(ref pth, ref fields, etc) => {\n+                let pth_ = self.fold_path(pth);\n+                let fs = do fields.map |f| {\n+                    ast::FieldPat {\n+                        ident: f.ident,\n+                        pat: self.fold_pat(f.pat)\n+                    }\n+                };\n+                PatStruct(pth_, fs, etc)\n             }\n+            PatTup(ref elts) => PatTup(elts.map(|x| self.fold_pat(*x))),\n+            PatBox(inner) => PatBox(self.fold_pat(inner)),\n+            PatUniq(inner) => PatUniq(self.fold_pat(inner)),\n+            PatRegion(inner) => PatRegion(self.fold_pat(inner)),\n+            PatRange(e1, e2) => {\n+                PatRange(self.fold_expr(e1), self.fold_expr(e2))\n+            },\n+            PatVec(ref before, ref slice, ref after) => {\n+                PatVec(before.map(|x| self.fold_pat(*x)),\n+                       slice.map_move(|x| self.fold_pat(x)),\n+                       after.map(|x| self.fold_pat(*x)))\n+            }\n+        };\n+\n+        @Pat {\n+            id: self.new_id(p.id),\n+            span: self.new_span(p.span),\n+            node: node,\n         }\n     }\n \n-    fn fold_ty_param(@self, tp: &TyParam) -> TyParam {\n-        TyParam {\n-            ident: self.fold_ident(tp.ident),\n-            id: self.new_id(tp.id),\n-            bounds: tp.bounds.map(|x| self.fold_ty_param_bound(x))\n+    fn fold_decl(&self, d: @Decl) -> Option<@Decl> {\n+        let node = match d.node {\n+            DeclLocal(ref l) => Some(DeclLocal(self.fold_local(*l))),\n+            DeclItem(it) => {\n+                match self.fold_item(it) {\n+                    Some(it_folded) => Some(DeclItem(it_folded)),\n+                    None => None,\n+                }\n+            }\n+        };\n+\n+        node.map_move(|node| {\n+            @Spanned {\n+                node: node,\n+                span: d.span,\n+            }\n+        })\n+    }\n+\n+    fn fold_expr(&self, e: @Expr) -> @Expr {\n+        noop_fold_expr(e, self)\n+    }\n+\n+    fn fold_ty(&self, t: &Ty) -> Ty {\n+        let node = match t.node {\n+            ty_nil | ty_bot | ty_infer => t.node.clone(),\n+            ty_box(ref mt) => ty_box(fold_mt(mt, self)),\n+            ty_uniq(ref mt) => ty_uniq(fold_mt(mt, self)),\n+            ty_vec(ref mt) => ty_vec(fold_mt(mt, self)),\n+            ty_ptr(ref mt) => ty_ptr(fold_mt(mt, self)),\n+            ty_rptr(region, ref mt) => ty_rptr(region, fold_mt(mt, self)),\n+            ty_closure(ref f) => {\n+                ty_closure(@TyClosure {\n+                    sigil: f.sigil,\n+                    purity: f.purity,\n+                    region: f.region,\n+                    onceness: f.onceness,\n+                    bounds: fold_opt_bounds(&f.bounds, self),\n+                    decl: fold_fn_decl(&f.decl, self),\n+                    lifetimes: f.lifetimes.map(|l| fold_lifetime(l, self)),\n+                })\n+            }\n+            ty_bare_fn(ref f) => {\n+                ty_bare_fn(@TyBareFn {\n+                    lifetimes: f.lifetimes.map(|l| fold_lifetime(l, self)),\n+                    purity: f.purity,\n+                    abis: f.abis,\n+                    decl: fold_fn_decl(&f.decl, self)\n+                })\n+            }\n+            ty_tup(ref tys) => ty_tup(tys.map(|ty| self.fold_ty(ty))),\n+            ty_path(ref path, ref bounds, id) => {\n+                ty_path(self.fold_path(path),\n+                        fold_opt_bounds(bounds, self),\n+                        self.new_id(id))\n+            }\n+            ty_fixed_length_vec(ref mt, e) => {\n+                ty_fixed_length_vec(fold_mt(mt, self), self.fold_expr(e))\n+            }\n+            ty_mac(ref mac) => ty_mac(self.fold_mac(mac)),\n+            ty_typeof(expr) => ty_typeof(self.fold_expr(expr)),\n+        };\n+        Ty {\n+            id: self.new_id(t.id),\n+            span: self.new_span(t.span),\n+            node: node,\n         }\n     }\n \n-    fn fold_ty_params(@self, tps: &OptVec<TyParam>) -> OptVec<TyParam> {\n-        tps.map(|tp| self.fold_ty_param(tp))\n+    fn fold_mod(&self, m: &_mod) -> _mod {\n+        noop_fold_mod(m, self)\n     }\n \n-    fn fold_lifetime(@self, l: &Lifetime) -> Lifetime {\n-        Lifetime {\n-            id: self.new_id(l.id),\n-            span: self.new_span(l.span),\n-            ident: l.ident, // Folding this ident causes hygiene errors - ndm\n+    fn fold_foreign_mod(&self, nm: &foreign_mod) -> foreign_mod {\n+        ast::foreign_mod {\n+            sort: nm.sort,\n+            abis: nm.abis,\n+            view_items: nm.view_items\n+                          .iter()\n+                          .map(|x| self.fold_view_item(x))\n+                          .collect(),\n+            items: nm.items\n+                     .iter()\n+                     .map(|x| self.fold_foreign_item(*x))\n+                     .collect(),\n         }\n     }\n \n-    fn fold_lifetimes(@self, lts: &OptVec<Lifetime>) -> OptVec<Lifetime> {\n-        lts.map(|l| self.fold_lifetime(l))\n+    fn fold_variant(&self, v: &variant) -> variant {\n+        let kind;\n+        match v.node.kind {\n+            tuple_variant_kind(ref variant_args) => {\n+                kind = tuple_variant_kind(variant_args.map(|x|\n+                    fold_variant_arg_(x, self)))\n+            }\n+            struct_variant_kind(ref struct_def) => {\n+                kind = struct_variant_kind(@ast::struct_def {\n+                    fields: struct_def.fields.iter()\n+                        .map(|f| self.fold_struct_field(*f)).collect(),\n+                    ctor_id: struct_def.ctor_id.map(|c| self.new_id(*c))\n+                })\n+            }\n+        }\n+\n+        let fold_attribute = |x| fold_attribute_(x, self);\n+        let attrs = v.node.attrs.map(|x| fold_attribute(*x));\n+\n+        let de = match v.node.disr_expr {\n+          Some(e) => Some(self.fold_expr(e)),\n+          None => None\n+        };\n+        let node = ast::variant_ {\n+            name: v.node.name,\n+            attrs: attrs,\n+            kind: kind,\n+            id: self.new_id(v.node.id),\n+            disr_expr: de,\n+            vis: v.node.vis,\n+        };\n+        Spanned {\n+            node: node,\n+            span: self.new_span(v.span),\n+        }\n     }\n \n+    fn fold_ident(&self, i: Ident) -> Ident {\n+        i\n+    }\n \n-    fn fold_meta_item(@self, mi: &MetaItem) -> @MetaItem {\n-        @self.fold_spanned(mi, |n| match *n {\n-                MetaWord(id) => {\n-                    MetaWord(id)\n-                }\n-                MetaList(id, ref mis) => {\n-                    MetaList(id, self.fold_meta_items(*mis))\n-                }\n-                MetaNameValue(id, s) => {\n-                    MetaNameValue(id, s)\n-                }\n+    fn fold_path(&self, p: &Path) -> Path {\n+        ast::Path {\n+            span: self.new_span(p.span),\n+            global: p.global,\n+            segments: p.segments.map(|segment| ast::PathSegment {\n+                identifier: self.fold_ident(segment.identifier),\n+                lifetime: segment.lifetime,\n+                types: segment.types.map(|typ| self.fold_ty(typ)),\n             })\n+        }\n     }\n \n-    fn fold_meta_items(@self, mis: &[@MetaItem]) -> ~[@MetaItem] {\n-        mis.map(|&mi| self.fold_meta_item(mi))\n+    fn fold_local(&self, l: @Local) -> @Local {\n+        @Local {\n+            is_mutbl: l.is_mutbl,\n+            ty: self.fold_ty(&l.ty),\n+            pat: self.fold_pat(l.pat),\n+            init: l.init.map_move(|e| self.fold_expr(e)),\n+            id: self.new_id(l.id),\n+            span: self.new_span(l.span),\n+        }\n     }\n \n-    fn fold_attribute(@self, at: &Attribute) -> Attribute {\n+    fn fold_mac(&self, macro: &mac) -> mac {\n         Spanned {\n-            span: self.new_span(at.span),\n-            node: Attribute_ {\n-                style: at.node.style,\n-                value: self.fold_meta_item(at.node.value),\n-                is_sugared_doc: at.node.is_sugared_doc\n-            }\n+            node: match macro.node {\n+                mac_invoc_tt(ref p, ref tts, ctxt) => {\n+                    mac_invoc_tt(self.fold_path(p),\n+                                 fold_tts(*tts, self),\n+                                 ctxt)\n+                }\n+            },\n+            span: self.new_span(macro.span)\n         }\n     }\n \n-    fn fold_attributes(@self, attrs: &[Attribute]) -> ~[Attribute] {\n-        attrs.map(|x| self.fold_attribute(x))\n+    fn map_exprs(&self, f: &fn(@Expr) -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n+        es.map(|x| f(*x))\n+    }\n+\n+    fn new_id(&self, i: NodeId) -> NodeId {\n+        i\n+    }\n+\n+    fn new_span(&self, sp: Span) -> Span {\n+        sp\n     }\n }\n \n-// We may eventually want to be able to fold over type parameters, too\n-\n-pub struct AstFoldFns {\n-    //unlike the others, item_ is non-trivial\n-    fold_crate: @fn(&Crate, @ast_fold) -> Crate,\n-    fold_view_item: @fn(&view_item_, @ast_fold) -> view_item_,\n-    fold_foreign_item: @fn(@foreign_item, @ast_fold) -> @foreign_item,\n-    fold_item: @fn(@item, @ast_fold) -> Option<@item>,\n-    fold_struct_field: @fn(@struct_field, @ast_fold) -> @struct_field,\n-    fold_item_underscore: @fn(&item_, @ast_fold) -> item_,\n-    fold_type_method: @fn(&TypeMethod, @ast_fold) -> TypeMethod,\n-    fold_method: @fn(@method, @ast_fold) -> @method,\n-    fold_block: @fn(&Block, @ast_fold) -> Block,\n-    fold_stmt: @fn(&Stmt_, Span, @ast_fold) -> (Option<Stmt_>, Span),\n-    fold_arm: @fn(&Arm, @ast_fold) -> Arm,\n-    fold_pat: @fn(&Pat_, Span, @ast_fold) -> (Pat_, Span),\n-    fold_decl: @fn(&Decl_, Span, @ast_fold) -> (Option<Decl_>, Span),\n-    fold_expr: @fn(&Expr_, Span, @ast_fold) -> (Expr_, Span),\n-    fold_ty: @fn(&ty_, Span, @ast_fold) -> (ty_, Span),\n-    fold_mod: @fn(&_mod, @ast_fold) -> _mod,\n-    fold_foreign_mod: @fn(&foreign_mod, @ast_fold) -> foreign_mod,\n-    fold_variant: @fn(&variant_, Span, @ast_fold) -> (variant_, Span),\n-    fold_ident: @fn(Ident, @ast_fold) -> Ident,\n-    fold_path: @fn(&Path, @ast_fold) -> Path,\n-    fold_local: @fn(@Local, @ast_fold) -> @Local,\n-    fold_mac: @fn(&mac_, Span, @ast_fold) -> (mac_, Span),\n-    map_exprs: @fn(@fn(@Expr) -> @Expr, &[@Expr]) -> ~[@Expr],\n-    new_id: @fn(NodeId) -> NodeId,\n-    new_span: @fn(Span) -> Span\n+/* some little folds that probably aren't useful to have in ast_fold itself*/\n+\n+//used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n+fn fold_meta_item_<T:ast_fold>(mi: @MetaItem, fld: &T) -> @MetaItem {\n+    @Spanned {\n+        node:\n+            match mi.node {\n+                MetaWord(id) => MetaWord(id),\n+                MetaList(id, ref mis) => {\n+                    let fold_meta_item = |x| fold_meta_item_(x, fld);\n+                    MetaList(\n+                        id,\n+                        mis.map(|e| fold_meta_item(*e))\n+                    )\n+                }\n+                MetaNameValue(id, s) => MetaNameValue(id, s)\n+            },\n+        span: fld.new_span(mi.span) }\n }\n \n-pub type ast_fold_fns = @AstFoldFns;\n+//used in noop_fold_item and noop_fold_crate\n+fn fold_attribute_<T:ast_fold>(at: Attribute, fld: &T) -> Attribute {\n+    Spanned {\n+        span: fld.new_span(at.span),\n+        node: ast::Attribute_ {\n+            style: at.node.style,\n+            value: fold_meta_item_(at.node.value, fld),\n+            is_sugared_doc: at.node.is_sugared_doc\n+        }\n+    }\n+}\n \n-/* some little folds that probably aren't useful to have in ast_fold itself*/\n+//used in noop_fold_foreign_item and noop_fold_fn_decl\n+fn fold_arg_<T:ast_fold>(a: &arg, fld: &T) -> arg {\n+    ast::arg {\n+        is_mutbl: a.is_mutbl,\n+        ty: fld.fold_ty(&a.ty),\n+        pat: fld.fold_pat(a.pat),\n+        id: fld.new_id(a.id),\n+    }\n+}\n \n-pub fn fold_tts(tts : &[token_tree], fld: @ast_fold) -> ~[token_tree] {\n+// build a new vector of tts by appling the ast_fold's fold_ident to\n+// all of the identifiers in the token trees.\n+pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &T) -> ~[token_tree] {\n     do tts.map |tt| {\n         match *tt {\n             tt_tok(span, ref tok) =>\n             tt_tok(span,maybe_fold_ident(tok,fld)),\n-            tt_delim(ref tts) =>\n-            tt_delim(@mut fold_tts(**tts, fld)),\n+            tt_delim(ref tts) => tt_delim(@mut fold_tts(**tts, fld)),\n             tt_seq(span, ref pattern, ref sep, is_optional) =>\n             tt_seq(span,\n                    @mut fold_tts(**pattern, fld),\n@@ -247,33 +454,68 @@ pub fn fold_tts(tts : &[token_tree], fld: @ast_fold) -> ~[token_tree] {\n }\n \n // apply ident folder if it's an ident, otherwise leave it alone\n-fn maybe_fold_ident(t : &token::Token, f: @ast_fold) -> token::Token {\n+fn maybe_fold_ident<T:ast_fold>(t: &token::Token, fld: &T) -> token::Token {\n     match *t {\n-        token::IDENT(id,followed_by_colons) =>\n-        token::IDENT(f.fold_ident(id),followed_by_colons),\n+        token::IDENT(id, followed_by_colons) => {\n+            token::IDENT(fld.fold_ident(id), followed_by_colons)\n+        }\n         _ => (*t).clone()\n     }\n }\n \n-pub fn fold_fn_decl(decl: &ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n+pub fn fold_fn_decl<T:ast_fold>(decl: &ast::fn_decl, fld: &T)\n+                                -> ast::fn_decl {\n     ast::fn_decl {\n-        inputs: decl.inputs.map(|x| fld.fold_arg(x)),\n+        inputs: decl.inputs.map(|x| fold_arg_(x, fld)), // bad copy\n         output: fld.fold_ty(&decl.output),\n         cf: decl.cf,\n     }\n }\n \n-pub fn fold_generics(generics: &Generics, fld: @ast_fold) -> Generics {\n-    Generics {ty_params: fld.fold_ty_params(&generics.ty_params),\n-              lifetimes: fld.fold_lifetimes(&generics.lifetimes)}\n+fn fold_ty_param_bound<T:ast_fold>(tpb: &TyParamBound, fld: &T)\n+                                   -> TyParamBound {\n+    match *tpb {\n+        TraitTyParamBound(ref ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n+        RegionTyParamBound => RegionTyParamBound\n+    }\n }\n \n-pub fn noop_fold_crate(c: &Crate, fld: @ast_fold) -> Crate {\n-    Crate {\n-        module: fld.fold_mod(&c.module),\n-        attrs: fld.fold_attributes(c.attrs),\n-        config: fld.fold_meta_items(c.config),\n-        span: fld.new_span(c.span),\n+pub fn fold_ty_param<T:ast_fold>(tp: &TyParam, fld: &T) -> TyParam {\n+    TyParam {\n+        ident: tp.ident,\n+        id: fld.new_id(tp.id),\n+        bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld)),\n+    }\n+}\n+\n+pub fn fold_ty_params<T:ast_fold>(tps: &OptVec<TyParam>, fld: &T)\n+                                  -> OptVec<TyParam> {\n+    tps.map(|tp| fold_ty_param(tp, fld))\n+}\n+\n+pub fn fold_lifetime<T:ast_fold>(l: &Lifetime, fld: &T) -> Lifetime {\n+    Lifetime {\n+        id: fld.new_id(l.id),\n+        span: fld.new_span(l.span),\n+        ident: l.ident\n+    }\n+}\n+\n+pub fn fold_lifetimes<T:ast_fold>(lts: &OptVec<Lifetime>, fld: &T)\n+                                  -> OptVec<Lifetime> {\n+    lts.map(|l| fold_lifetime(l, fld))\n+}\n+\n+pub fn fold_generics<T:ast_fold>(generics: &Generics, fld: &T) -> Generics {\n+    Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n+              lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n+}\n+\n+fn fold_struct_def<T:ast_fold>(struct_def: @ast::struct_def, fld: &T)\n+                               -> @ast::struct_def {\n+    @ast::struct_def {\n+        fields: struct_def.fields.map(|f| fold_struct_field(*f, fld)),\n+        ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(*cid)),\n     }\n }\n \n@@ -291,753 +533,333 @@ fn noop_fold_view_item(vi: &view_item_, fld: @ast_fold) -> view_item_ {\n     }\n }\n \n-fn noop_fold_foreign_item(ni: @foreign_item, fld: @ast_fold)\n-    -> @foreign_item {\n-    @ast::foreign_item {\n-        ident: fld.fold_ident(ni.ident),\n-        attrs: fld.fold_attributes(ni.attrs),\n-        node:\n-            match ni.node {\n-                foreign_item_fn(ref fdec, ref generics) => {\n-                    foreign_item_fn(\n-                        ast::fn_decl {\n-                            inputs: fdec.inputs.map(|a| fld.fold_arg(a)),\n-                            output: fld.fold_ty(&fdec.output),\n-                            cf: fdec.cf,\n-                        },\n-                        fold_generics(generics, fld))\n-                }\n-                foreign_item_static(ref t, m) => {\n-                    foreign_item_static(fld.fold_ty(t), m)\n-                }\n-            },\n-        id: fld.new_id(ni.id),\n-        span: fld.new_span(ni.span),\n-        vis: ni.vis,\n+fn fold_trait_ref<T:ast_fold>(p: &trait_ref, fld: &T) -> trait_ref {\n+    ast::trait_ref {\n+        path: fld.fold_path(&p.path),\n+        ref_id: fld.new_id(p.ref_id),\n     }\n }\n \n-pub fn noop_fold_item(i: @item, fld: @ast_fold) -> Option<@item> {\n-    Some(@ast::item { ident: fld.fold_ident(i.ident),\n-                      attrs: fld.fold_attributes(i.attrs),\n-                      id: fld.new_id(i.id),\n-                      node: fld.fold_item_underscore(&i.node),\n-                      vis: i.vis,\n-                      span: fld.new_span(i.span) })\n-}\n-\n-fn noop_fold_struct_field(sf: @struct_field, fld: @ast_fold)\n-                       -> @struct_field {\n+fn fold_struct_field<T:ast_fold>(f: @struct_field, fld: &T) -> @struct_field {\n     @Spanned {\n         node: ast::struct_field_ {\n-            kind: sf.node.kind,\n-            id: fld.new_id(sf.node.id),\n-            ty: fld.fold_ty(&sf.node.ty),\n-            attrs: fld.fold_attributes(sf.node.attrs),\n+            kind: f.node.kind,\n+            id: fld.new_id(f.node.id),\n+            ty: fld.fold_ty(&f.node.ty),\n+            attrs: f.node.attrs.map(|a| fold_attribute_(*a, fld)),\n         },\n-        span: sf.span\n+        span: fld.new_span(f.span),\n     }\n }\n \n-pub fn noop_fold_type_method(m: &TypeMethod, fld: @ast_fold) -> TypeMethod {\n-    TypeMethod {\n-        ident: fld.fold_ident(m.ident),\n-        attrs: fld.fold_attributes(m.attrs),\n-        purity: m.purity,\n-        decl: fold_fn_decl(&m.decl, fld),\n-        generics: fold_generics(&m.generics, fld),\n-        explicit_self: m.explicit_self,\n-        id: fld.new_id(m.id),\n-        span: fld.new_span(m.span),\n+fn fold_field_<T:ast_fold>(field: Field, folder: &T) -> Field {\n+    ast::Field {\n+        ident: folder.fold_ident(field.ident),\n+        expr: folder.fold_expr(field.expr),\n+        span: folder.new_span(field.span),\n     }\n }\n \n-pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n+fn fold_mt<T:ast_fold>(mt: &mt, folder: &T) -> mt {\n+    mt {\n+        ty: ~folder.fold_ty(mt.ty),\n+        mutbl: mt.mutbl,\n+    }\n+}\n+\n+fn fold_field<T:ast_fold>(f: TypeField, folder: &T) -> TypeField {\n+    ast::TypeField {\n+        ident: folder.fold_ident(f.ident),\n+        mt: fold_mt(&f.mt, folder),\n+        span: folder.new_span(f.span),\n+    }\n+}\n+\n+fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &T)\n+                               -> Option<OptVec<TyParamBound>> {\n+    do b.map |bounds| {\n+        do bounds.map |bound| {\n+            fold_ty_param_bound(bound, folder)\n+        }\n+    }\n+}\n+\n+fn fold_variant_arg_<T:ast_fold>(va: &variant_arg, folder: &T)\n+                                 -> variant_arg {\n+    ast::variant_arg {\n+        ty: folder.fold_ty(&va.ty),\n+        id: folder.new_id(va.id)\n+    }\n+}\n+\n+pub fn noop_fold_block<T:ast_fold>(b: &Block, folder: &T) -> Block {\n+    let view_items = b.view_items.map(|x| folder.fold_view_item(x));\n+    let mut stmts = ~[];\n+    for stmt in b.stmts.iter() {\n+        match folder.fold_stmt(*stmt) {\n+            None => {}\n+            Some(stmt) => stmts.push(stmt)\n+        }\n+    }\n+    ast::Block {\n+        view_items: view_items,\n+        stmts: stmts,\n+        expr: b.expr.map(|x| folder.fold_expr(*x)),\n+        id: folder.new_id(b.id),\n+        rules: b.rules,\n+        span: folder.new_span(b.span),\n+    }\n+}\n+\n+pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &T) -> item_ {\n     match *i {\n         item_static(ref t, m, e) => {\n-            item_static(fld.fold_ty(t), m, fld.fold_expr(e))\n+            item_static(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n         item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             item_fn(\n-                fold_fn_decl(decl, fld),\n+                fold_fn_decl(decl, folder),\n                 purity,\n                 abi,\n-                fold_generics(generics, fld),\n-                fld.fold_block(body)\n+                fold_generics(generics, folder),\n+                folder.fold_block(body)\n             )\n         }\n-        item_mod(ref m) => {\n-            item_mod(fld.fold_mod(m))\n-        }\n+        item_mod(ref m) => item_mod(folder.fold_mod(m)),\n         item_foreign_mod(ref nm) => {\n-            item_foreign_mod(fld.fold_foreign_mod(nm))\n+            item_foreign_mod(folder.fold_foreign_mod(nm))\n         }\n         item_ty(ref t, ref generics) => {\n-            item_ty(fld.fold_ty(t), fold_generics(generics, fld))\n+            item_ty(folder.fold_ty(t),\n+                    fold_generics(generics, folder))\n         }\n         item_enum(ref enum_definition, ref generics) => {\n             item_enum(\n                 ast::enum_def {\n                     variants: do enum_definition.variants.map |x| {\n-                        fld.fold_variant(x)\n+                        folder.fold_variant(x)\n                     },\n                 },\n-                fold_generics(generics, fld))\n+                fold_generics(generics, folder))\n         }\n         item_struct(ref struct_def, ref generics) => {\n-            let struct_def = fold_struct_def(*struct_def, fld);\n-            item_struct(struct_def, fold_generics(generics, fld))\n+            let struct_def = fold_struct_def(*struct_def, folder);\n+            item_struct(struct_def, fold_generics(generics, folder))\n         }\n         item_impl(ref generics, ref ifce, ref ty, ref methods) => {\n-            item_impl(\n-                fold_generics(generics, fld),\n-                ifce.map(|p| fld.fold_trait_ref(p)),\n-                fld.fold_ty(ty),\n-                methods.map(|x| fld.fold_method(*x))\n+            item_impl(fold_generics(generics, folder),\n+                      ifce.map(|p| fold_trait_ref(p, folder)),\n+                      folder.fold_ty(ty),\n+                      methods.map(|x| folder.fold_method(*x))\n             )\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n             let methods = do methods.map |method| {\n                 match *method {\n-                    required(ref m) => required(fld.fold_type_method(m)),\n-                    provided(method) => provided(fld.fold_method(method))\n+                    required(ref m) => required(folder.fold_type_method(m)),\n+                    provided(method) => provided(folder.fold_method(method))\n                 }\n             };\n-            item_trait(\n-                fold_generics(generics, fld),\n-                traits.map(|p| fld.fold_trait_ref(p)),\n-                methods\n-            )\n-        }\n-        item_mac(ref m) => {\n-            item_mac(fld.fold_mac(m))\n+            item_trait(fold_generics(generics, folder),\n+                       traits.map(|p| fold_trait_ref(p, folder)),\n+                       methods)\n         }\n+        item_mac(ref m) => item_mac(folder.fold_mac(m)),\n     }\n }\n \n-fn fold_struct_def(struct_def: @ast::struct_def, fld: @ast_fold)\n-                -> @ast::struct_def {\n-    @ast::struct_def {\n-        fields: struct_def.fields.map(|f| fold_struct_field(*f, fld)),\n-        ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(*cid)),\n-    }\n-}\n-\n-fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n-    @Spanned {\n-        node: ast::struct_field_ {\n-            kind: f.node.kind,\n-            id: fld.new_id(f.node.id),\n-            ty: fld.fold_ty(&f.node.ty),\n-            attrs: fld.fold_attributes(f.node.attrs),\n-        },\n-        span: fld.new_span(f.span),\n-    }\n-}\n-\n-fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n-    @ast::method {\n+pub fn noop_fold_type_method<T:ast_fold>(m: &TypeMethod, fld: &T)\n+                                         -> TypeMethod {\n+    TypeMethod {\n         ident: fld.fold_ident(m.ident),\n-        attrs: fld.fold_attributes(m.attrs),\n-        generics: fold_generics(&m.generics, fld),\n-        explicit_self: m.explicit_self,\n+        attrs: m.attrs.map(|a| fold_attribute_(*a, fld)),\n         purity: m.purity,\n         decl: fold_fn_decl(&m.decl, fld),\n-        body: fld.fold_block(&m.body),\n+        generics: fold_generics(&m.generics, fld),\n+        explicit_self: m.explicit_self,\n         id: fld.new_id(m.id),\n         span: fld.new_span(m.span),\n-        self_id: fld.new_id(m.self_id),\n-        vis: m.vis,\n-    }\n-}\n-\n-\n-pub fn noop_fold_block(b: &Block, fld: @ast_fold) -> Block {\n-    let view_items = b.view_items.map(|x| fld.fold_view_item(x));\n-    let mut stmts = ~[];\n-    for stmt in b.stmts.iter() {\n-        match fld.fold_stmt(*stmt) {\n-            None => {}\n-            Some(stmt) => stmts.push(stmt)\n-        }\n-    }\n-    ast::Block {\n-        view_items: view_items,\n-        stmts: stmts,\n-        expr: b.expr.map(|x| fld.fold_expr(*x)),\n-        id: fld.new_id(b.id),\n-        rules: b.rules,\n-        span: b.span,\n     }\n }\n \n-fn noop_fold_stmt(s: &Stmt_, fld: @ast_fold) -> Option<Stmt_> {\n-    match *s {\n-        StmtDecl(d, nid) => {\n-            match fld.fold_decl(d) {\n-                Some(d) => Some(StmtDecl(d, fld.new_id(nid))),\n-                None => None,\n-            }\n-        }\n-        StmtExpr(e, nid) => {\n-            Some(StmtExpr(fld.fold_expr(e), fld.new_id(nid)))\n-        }\n-        StmtSemi(e, nid) => {\n-            Some(StmtSemi(fld.fold_expr(e), fld.new_id(nid)))\n-        }\n-        StmtMac(ref mac, semi) => Some(StmtMac(fld.fold_mac(mac), semi))\n+pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &T) -> _mod {\n+    ast::_mod {\n+        view_items: m.view_items\n+                     .iter()\n+                     .map(|x| folder.fold_view_item(x)).collect(),\n+        items: m.items.iter().filter_map(|x| folder.fold_item(*x)).collect(),\n     }\n }\n \n-fn noop_fold_arm(a: &Arm, fld: @ast_fold) -> Arm {\n-    Arm {\n-        pats: a.pats.map(|x| fld.fold_pat(*x)),\n-        guard: a.guard.map_move(|x| fld.fold_expr(x)),\n-        body: fld.fold_block(&a.body),\n-    }\n-}\n+pub fn noop_fold_crate<T:ast_fold>(c: &Crate, folder: &T) -> Crate {\n+    let fold_meta_item = |x| fold_meta_item_(x, folder);\n+    let fold_attribute = |x| fold_attribute_(x, folder);\n \n-pub fn noop_fold_pat(p: &Pat_, fld: @ast_fold) -> Pat_ {\n-    match *p {\n-        PatWild => PatWild,\n-        PatIdent(binding_mode, ref pth, ref sub) => {\n-            PatIdent(\n-                binding_mode,\n-                fld.fold_path(pth),\n-                sub.map_move(|x| fld.fold_pat(x))\n-            )\n-        }\n-        PatLit(e) => PatLit(fld.fold_expr(e)),\n-        PatEnum(ref pth, ref pats) => {\n-            PatEnum(\n-                fld.fold_path(pth),\n-                pats.map(|pats| pats.map(|x| fld.fold_pat(*x)))\n-            )\n-        }\n-        PatStruct(ref pth, ref fields, etc) => {\n-            let pth_ = fld.fold_path(pth);\n-            let fs = do fields.map |f| {\n-                ast::FieldPat {\n-                    ident: f.ident,\n-                    pat: fld.fold_pat(f.pat)\n-                }\n-            };\n-            PatStruct(pth_, fs, etc)\n-        }\n-        PatTup(ref elts) => PatTup(elts.map(|x| fld.fold_pat(*x))),\n-        PatBox(inner) => PatBox(fld.fold_pat(inner)),\n-        PatUniq(inner) => PatUniq(fld.fold_pat(inner)),\n-        PatRegion(inner) => PatRegion(fld.fold_pat(inner)),\n-        PatRange(e1, e2) => {\n-            PatRange(fld.fold_expr(e1), fld.fold_expr(e2))\n-        },\n-        PatVec(ref before, ref slice, ref after) => {\n-            PatVec(\n-                before.map(|x| fld.fold_pat(*x)),\n-                slice.map_move(|x| fld.fold_pat(x)),\n-                after.map(|x| fld.fold_pat(*x))\n-            )\n-        }\n+    Crate {\n+        module: folder.fold_mod(&c.module),\n+        attrs: c.attrs.map(|x| fold_attribute(*x)),\n+        config: c.config.map(|x| fold_meta_item(*x)),\n+        span: folder.new_span(c.span),\n     }\n }\n \n-fn noop_fold_decl(d: &Decl_, fld: @ast_fold) -> Option<Decl_> {\n-    match *d {\n-        DeclLocal(ref l) => Some(DeclLocal(fld.fold_local(*l))),\n-        DeclItem(it) => {\n-            match fld.fold_item(it) {\n-                Some(it_folded) => Some(DeclItem(it_folded)),\n-                None => None,\n-            }\n-        }\n-    }\n-}\n+pub fn noop_fold_item<T:ast_fold>(i: @ast::item, folder: &T)\n+                                  -> Option<@ast::item> {\n+    let fold_attribute = |x| fold_attribute_(x, folder);\n \n-// lift a function in ast-thingy X fold -> ast-thingy to a function\n-// in (ast-thingy X span X fold) -> (ast-thingy X span). Basically,\n-// carries the span around.\n-// It seems strange to me that the call to new_fold doesn't happen\n-// here but instead in the impl down below.... probably just an\n-// accident?\n-pub fn wrap<T>(f: @fn(&T, @ast_fold) -> T)\n-            -> @fn(&T, Span, @ast_fold) -> (T, Span) {\n-    let result: @fn(&T, Span, @ast_fold) -> (T, Span) = |x, s, fld| {\n-        (f(x, fld), s)\n-    };\n-    result\n+    Some(@ast::item {\n+        ident: folder.fold_ident(i.ident),\n+        attrs: i.attrs.map(|e| fold_attribute(*e)),\n+        id: folder.new_id(i.id),\n+        node: folder.fold_item_underscore(&i.node),\n+        vis: i.vis,\n+        span: folder.new_span(i.span)\n+    })\n }\n \n-pub fn noop_fold_expr(e: &Expr_, fld: @ast_fold) -> Expr_ {\n-    fn fold_field_(field: Field, fld: @ast_fold) -> Field {\n-        ast::Field {\n-            ident: fld.fold_ident(field.ident),\n-            expr: fld.fold_expr(field.expr),\n-            span: fld.new_span(field.span),\n-        }\n-    }\n-    let fold_field = |x| fold_field_(x, fld);\n+pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n+    let fold_field = |x| fold_field_(x, folder);\n \n-    match *e {\n+    let node = match e.node {\n         ExprVstore(e, v) => {\n-            ExprVstore(fld.fold_expr(e), v)\n+            ExprVstore(folder.fold_expr(e), v)\n         }\n         ExprVec(ref exprs, mutt) => {\n-            ExprVec(fld.map_exprs(|x| fld.fold_expr(x), *exprs), mutt)\n+            ExprVec(folder.map_exprs(|x| folder.fold_expr(x), *exprs), mutt)\n         }\n         ExprRepeat(expr, count, mutt) => {\n-            ExprRepeat(fld.fold_expr(expr), fld.fold_expr(count), mutt)\n+            ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count), mutt)\n         }\n-        ExprTup(ref elts) => ExprTup(elts.map(|x| fld.fold_expr(*x))),\n+        ExprTup(ref elts) => ExprTup(elts.map(|x| folder.fold_expr(*x))),\n         ExprCall(f, ref args, blk) => {\n-            ExprCall(\n-                fld.fold_expr(f),\n-                fld.map_exprs(|x| fld.fold_expr(x), *args),\n-                blk\n-            )\n+            ExprCall(folder.fold_expr(f),\n+                     folder.map_exprs(|x| folder.fold_expr(x), *args),\n+                     blk)\n         }\n         ExprMethodCall(callee_id, f, i, ref tps, ref args, blk) => {\n             ExprMethodCall(\n-                fld.new_id(callee_id),\n-                fld.fold_expr(f),\n-                fld.fold_ident(i),\n-                tps.map(|x| fld.fold_ty(x)),\n-                fld.map_exprs(|x| fld.fold_expr(x), *args),\n+                folder.new_id(callee_id),\n+                folder.fold_expr(f),\n+                folder.fold_ident(i),\n+                tps.map(|x| folder.fold_ty(x)),\n+                folder.map_exprs(|x| folder.fold_expr(x), *args),\n                 blk\n             )\n         }\n         ExprBinary(callee_id, binop, lhs, rhs) => {\n-            ExprBinary(\n-                fld.new_id(callee_id),\n-                binop,\n-                fld.fold_expr(lhs),\n-                fld.fold_expr(rhs)\n-            )\n+            ExprBinary(folder.new_id(callee_id),\n+                       binop,\n+                       folder.fold_expr(lhs),\n+                       folder.fold_expr(rhs))\n         }\n         ExprUnary(callee_id, binop, ohs) => {\n-            ExprUnary(\n-                fld.new_id(callee_id),\n-                binop,\n-                fld.fold_expr(ohs)\n-            )\n+            ExprUnary(folder.new_id(callee_id), binop, folder.fold_expr(ohs))\n         }\n-        ExprDoBody(f) => ExprDoBody(fld.fold_expr(f)),\n-        ExprLit(_) => (*e).clone(),\n+        ExprDoBody(f) => ExprDoBody(folder.fold_expr(f)),\n+        ExprLit(_) => e.node.clone(),\n         ExprCast(expr, ref ty) => {\n-            ExprCast(fld.fold_expr(expr), fld.fold_ty(ty))\n+            ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n         }\n-        ExprAddrOf(m, ohs) => ExprAddrOf(m, fld.fold_expr(ohs)),\n+        ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n         ExprIf(cond, ref tr, fl) => {\n-            ExprIf(\n-                fld.fold_expr(cond),\n-                fld.fold_block(tr),\n-                fl.map_move(|x| fld.fold_expr(x))\n-            )\n+            ExprIf(folder.fold_expr(cond),\n+                   folder.fold_block(tr),\n+                   fl.map_move(|x| folder.fold_expr(x)))\n         }\n         ExprWhile(cond, ref body) => {\n-            ExprWhile(fld.fold_expr(cond), fld.fold_block(body))\n+            ExprWhile(folder.fold_expr(cond), folder.fold_block(body))\n         }\n-        ExprForLoop(pat, iter, ref body, opt_ident) => {\n-            ExprForLoop(fld.fold_pat(pat),\n-                        fld.fold_expr(iter),\n-                        fld.fold_block(body),\n-                        opt_ident.map_move(|x| fld.fold_ident(x)))\n+        ExprForLoop(pat, iter, ref body, ref maybe_ident) => {\n+            ExprForLoop(folder.fold_pat(pat),\n+                        folder.fold_expr(iter),\n+                        folder.fold_block(body),\n+                        maybe_ident.map_move(|i| folder.fold_ident(i)))\n         }\n         ExprLoop(ref body, opt_ident) => {\n-            ExprLoop(\n-                fld.fold_block(body),\n-                opt_ident.map_move(|x| fld.fold_ident(x))\n-            )\n+            ExprLoop(folder.fold_block(body),\n+                     opt_ident.map_move(|x| folder.fold_ident(x)))\n         }\n         ExprMatch(expr, ref arms) => {\n-            ExprMatch(\n-                fld.fold_expr(expr),\n-                arms.map(|x| fld.fold_arm(x))\n-            )\n+            ExprMatch(folder.fold_expr(expr),\n+                      arms.map(|x| folder.fold_arm(x)))\n         }\n         ExprFnBlock(ref decl, ref body) => {\n             ExprFnBlock(\n-                fold_fn_decl(decl, fld),\n-                fld.fold_block(body)\n+                fold_fn_decl(decl, folder),\n+                folder.fold_block(body)\n             )\n         }\n-        ExprBlock(ref blk) => ExprBlock(fld.fold_block(blk)),\n+        ExprBlock(ref blk) => ExprBlock(folder.fold_block(blk)),\n         ExprAssign(el, er) => {\n-            ExprAssign(fld.fold_expr(el), fld.fold_expr(er))\n+            ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n         }\n         ExprAssignOp(callee_id, op, el, er) => {\n-            ExprAssignOp(\n-                fld.new_id(callee_id),\n-                op,\n-                fld.fold_expr(el),\n-                fld.fold_expr(er)\n-            )\n+            ExprAssignOp(folder.new_id(callee_id),\n+                         op,\n+                         folder.fold_expr(el),\n+                         folder.fold_expr(er))\n         }\n         ExprField(el, id, ref tys) => {\n-            ExprField(\n-                fld.fold_expr(el), fld.fold_ident(id),\n-                tys.map(|x| fld.fold_ty(x))\n-            )\n+            ExprField(folder.fold_expr(el), folder.fold_ident(id),\n+                      tys.map(|x| folder.fold_ty(x)))\n         }\n         ExprIndex(callee_id, el, er) => {\n-            ExprIndex(\n-                fld.new_id(callee_id),\n-                fld.fold_expr(el),\n-                fld.fold_expr(er)\n-            )\n+            ExprIndex(folder.new_id(callee_id),\n+                      folder.fold_expr(el),\n+                      folder.fold_expr(er))\n         }\n-        ExprPath(ref pth) => ExprPath(fld.fold_path(pth)),\n+        ExprPath(ref pth) => ExprPath(folder.fold_path(pth)),\n         ExprSelf => ExprSelf,\n-        ExprBreak(ref opt_ident) => {\n-            // FIXME #6993: add fold_name to fold.... then cut out the\n-            // bogus Name->Ident->Name conversion.\n-            ExprBreak(opt_ident.map_move(|x| {\n-                // FIXME #9129: Assigning the new ident to a temporary to work around codegen bug\n-                let newx = Ident::new(x);\n-                fld.fold_ident(newx).name\n-            }))\n-        }\n-        ExprAgain(ref opt_ident) => {\n-            // FIXME #6993: add fold_name to fold....\n-            ExprAgain(opt_ident.map_move(|x| {\n-                // FIXME #9129: Assigning the new ident to a temporary to work around codegen bug\n-                let newx = Ident::new(x);\n-                fld.fold_ident(newx).name\n-            }))\n-        }\n+        ExprLogLevel => ExprLogLevel,\n+        ExprBreak(opt_ident) => ExprBreak(opt_ident),\n+        ExprAgain(opt_ident) => ExprAgain(opt_ident),\n         ExprRet(ref e) => {\n-            ExprRet(e.map_move(|x| fld.fold_expr(x)))\n+            ExprRet(e.map_move(|x| folder.fold_expr(x)))\n         }\n-        ExprLogLevel => ExprLogLevel,\n         ExprInlineAsm(ref a) => {\n             ExprInlineAsm(inline_asm {\n-                inputs: a.inputs.map(|&(c, input)| (c, fld.fold_expr(input))),\n-                outputs: a.outputs.map(|&(c, out)| (c, fld.fold_expr(out))),\n+                inputs: a.inputs.map(|&(c, input)| (c, folder.fold_expr(input))),\n+                outputs: a.outputs.map(|&(c, out)| (c, folder.fold_expr(out))),\n                 .. (*a).clone()\n             })\n         }\n-        ExprMac(ref mac) => ExprMac(fld.fold_mac(mac)),\n+        ExprMac(ref mac) => ExprMac(folder.fold_mac(mac)),\n         ExprStruct(ref path, ref fields, maybe_expr) => {\n-            ExprStruct(\n-                fld.fold_path(path),\n-                fields.map(|x| fold_field(*x)),\n-                maybe_expr.map_move(|x| fld.fold_expr(x))\n-            )\n+            ExprStruct(folder.fold_path(path),\n+                       fields.map(|x| fold_field(*x)),\n+                       maybe_expr.map_move(|x| folder.fold_expr(x)))\n         },\n-        ExprParen(ex) => ExprParen(fld.fold_expr(ex))\n-    }\n-}\n-\n-pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n-    fn fold_mt(mt: &mt, fld: @ast_fold) -> mt {\n-        mt {\n-            ty: ~fld.fold_ty(mt.ty),\n-            mutbl: mt.mutbl,\n-        }\n-    }\n-    fn fold_field(f: TypeField, fld: @ast_fold) -> TypeField {\n-        ast::TypeField {\n-            ident: fld.fold_ident(f.ident),\n-            mt: fold_mt(&f.mt, fld),\n-            span: fld.new_span(f.span),\n-        }\n-    }\n-    fn fold_opt_bounds(b: &Option<OptVec<TyParamBound>>, fld: @ast_fold)\n-                        -> Option<OptVec<TyParamBound>> {\n-        do b.map |bounds| {\n-            do bounds.map |bound| { fld.fold_ty_param_bound(bound) }\n-        }\n-    }\n-    match *t {\n-        ty_nil | ty_bot | ty_infer => (*t).clone(),\n-        ty_box(ref mt) => ty_box(fold_mt(mt, fld)),\n-        ty_uniq(ref mt) => ty_uniq(fold_mt(mt, fld)),\n-        ty_vec(ref mt) => ty_vec(fold_mt(mt, fld)),\n-        ty_ptr(ref mt) => ty_ptr(fold_mt(mt, fld)),\n-        ty_rptr(region, ref mt) => ty_rptr(region, fold_mt(mt, fld)),\n-        ty_closure(ref f) => {\n-            ty_closure(@TyClosure {\n-                sigil: f.sigil,\n-                purity: f.purity,\n-                region: f.region,\n-                onceness: f.onceness,\n-                bounds: fold_opt_bounds(&f.bounds, fld),\n-                decl: fold_fn_decl(&f.decl, fld),\n-                lifetimes: fld.fold_lifetimes(&f.lifetimes)\n-            })\n-        }\n-        ty_bare_fn(ref f) => {\n-            ty_bare_fn(@TyBareFn {\n-                lifetimes: fld.fold_lifetimes(&f.lifetimes),\n-                purity: f.purity,\n-                abis: f.abis,\n-                decl: fold_fn_decl(&f.decl, fld)\n-            })\n-        }\n-        ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(ty))),\n-        ty_path(ref path, ref bounds, id) =>\n-            ty_path(fld.fold_path(path), fold_opt_bounds(bounds, fld), fld.new_id(id)),\n-        ty_fixed_length_vec(ref mt, e) => {\n-            ty_fixed_length_vec(\n-                fold_mt(mt, fld),\n-                fld.fold_expr(e)\n-            )\n-        }\n-        ty_typeof(e) => ty_typeof(fld.fold_expr(e)),\n-        ty_mac(ref mac) => ty_mac(fld.fold_mac(mac))\n-    }\n-}\n-\n-// ...nor do modules\n-pub fn noop_fold_mod(m: &_mod, fld: @ast_fold) -> _mod {\n-    ast::_mod {\n-        view_items: m.view_items.iter().map(|x| fld.fold_view_item(x)).collect(),\n-        items: m.items.iter().filter_map(|x| fld.fold_item(*x)).collect(),\n-    }\n-}\n-\n-fn noop_fold_foreign_mod(nm: &foreign_mod, fld: @ast_fold) -> foreign_mod {\n-    ast::foreign_mod {\n-        sort: nm.sort,\n-        abis: nm.abis,\n-        view_items: nm.view_items.iter().map(|x| fld.fold_view_item(x)).collect(),\n-        items: nm.items.iter().map(|x| fld.fold_foreign_item(*x)).collect(),\n-    }\n-}\n-\n-fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n-    let kind = match v.kind {\n-        tuple_variant_kind(ref variant_args) => {\n-            tuple_variant_kind(variant_args.map(|x| fld.fold_variant_arg(x)))\n-        }\n-        struct_variant_kind(ref struct_def) => {\n-            struct_variant_kind(@ast::struct_def {\n-                fields: struct_def.fields.iter()\n-                    .map(|f| fld.fold_struct_field(*f)).collect(),\n-                ctor_id: struct_def.ctor_id.map(|c| fld.new_id(*c))\n-            })\n-        }\n+        ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n     };\n \n-    let attrs = fld.fold_attributes(v.attrs);\n-\n-    let de = match v.disr_expr {\n-      Some(e) => Some(fld.fold_expr(e)),\n-      None => None\n-    };\n-    ast::variant_ {\n-        name: v.name,\n-        attrs: attrs,\n-        kind: kind,\n-        id: fld.new_id(v.id),\n-        disr_expr: de,\n-        vis: v.vis,\n-    }\n-}\n-\n-fn noop_fold_ident(i: Ident, _fld: @ast_fold) -> Ident {\n-    i\n-}\n-\n-fn noop_fold_path(p: &Path, fld: @ast_fold) -> Path {\n-    ast::Path {\n-        span: fld.new_span(p.span),\n-        global: p.global,\n-        segments: p.segments.map(|segment| ast::PathSegment {\n-            identifier: fld.fold_ident(segment.identifier),\n-            lifetime: segment.lifetime,\n-            types: segment.types.map(|typ| fld.fold_ty(typ)),\n-        })\n-    }\n-}\n-\n-fn noop_fold_local(l: @Local, fld: @ast_fold) -> @Local {\n-    @Local {\n-        is_mutbl: l.is_mutbl,\n-        ty: fld.fold_ty(&l.ty),\n-        pat: fld.fold_pat(l.pat),\n-        init: l.init.map_move(|e| fld.fold_expr(e)),\n-        id: fld.new_id(l.id),\n-        span: fld.new_span(l.span),\n+    @Expr {\n+        id: folder.new_id(e.id),\n+        node: node,\n+        span: folder.new_span(e.span),\n     }\n }\n \n-// the default macro traversal. visit the path\n-// using fold_path, and the tts using fold_tts,\n-// and the span using new_span\n-fn noop_fold_mac(m: &mac_, fld: @ast_fold) -> mac_ {\n-    match *m {\n-        mac_invoc_tt(ref p,ref tts,ctxt) =>\n-        mac_invoc_tt(fld.fold_path(p),\n-                     fold_tts(*tts,fld),\n-                     ctxt)\n-    }\n-}\n-\n-\n-/* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n-   value */\n-fn noop_map_exprs(f: @fn(@Expr) -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n-    es.map(|x| f(*x))\n-}\n-\n-fn noop_id(i: NodeId) -> NodeId { return i; }\n-\n-fn noop_span(sp: Span) -> Span { return sp; }\n-\n-pub fn default_ast_fold() -> ast_fold_fns {\n-    @AstFoldFns {\n-        fold_crate: noop_fold_crate,\n-        fold_view_item: noop_fold_view_item,\n-        fold_foreign_item: noop_fold_foreign_item,\n-        fold_item: noop_fold_item,\n-        fold_struct_field: noop_fold_struct_field,\n-        fold_item_underscore: noop_fold_item_underscore,\n-        fold_type_method: noop_fold_type_method,\n-        fold_method: noop_fold_method,\n-        fold_block: noop_fold_block,\n-        fold_stmt: |x, s, fld| (noop_fold_stmt(x, fld), s),\n-        fold_arm: noop_fold_arm,\n-        fold_pat: wrap(noop_fold_pat),\n-        fold_decl: |x, s, fld| (noop_fold_decl(x, fld), s),\n-        fold_expr: wrap(noop_fold_expr),\n-        fold_ty: wrap(noop_fold_ty),\n-        fold_mod: noop_fold_mod,\n-        fold_foreign_mod: noop_fold_foreign_mod,\n-        fold_variant: wrap(noop_fold_variant),\n-        fold_ident: noop_fold_ident,\n-        fold_path: noop_fold_path,\n-        fold_local: noop_fold_local,\n-        fold_mac: wrap(noop_fold_mac),\n-        map_exprs: noop_map_exprs,\n-        new_id: noop_id,\n-        new_span: noop_span,\n-    }\n-}\n-\n-impl ast_fold for AstFoldFns {\n-    /* naturally, a macro to write these would be nice */\n-    fn fold_crate(@self, c: &Crate) -> Crate {\n-        (self.fold_crate)(c, self as @ast_fold)\n-    }\n-    fn fold_view_item(@self, x: &view_item) -> view_item {\n-        ast::view_item {\n-            node: (self.fold_view_item)(&x.node, self as @ast_fold),\n-            attrs: self.fold_attributes(x.attrs),\n-            vis: x.vis,\n-            span: (self.new_span)(x.span),\n-        }\n-    }\n-    fn fold_foreign_item(@self, x: @foreign_item) -> @foreign_item {\n-        (self.fold_foreign_item)(x, self as @ast_fold)\n-    }\n-    fn fold_item(@self, i: @item) -> Option<@item> {\n-        (self.fold_item)(i, self as @ast_fold)\n-    }\n-    fn fold_struct_field(@self, sf: @struct_field) -> @struct_field {\n-        @Spanned {\n-            node: ast::struct_field_ {\n-                kind: sf.node.kind,\n-                id: (self.new_id)(sf.node.id),\n-                ty: self.fold_ty(&sf.node.ty),\n-                attrs: self.fold_attributes(sf.node.attrs),\n-            },\n-            span: (self.new_span)(sf.span),\n-        }\n-    }\n-    fn fold_item_underscore(@self, i: &item_) -> item_ {\n-        (self.fold_item_underscore)(i, self as @ast_fold)\n-    }\n-    fn fold_type_method(@self, m: &TypeMethod) -> TypeMethod {\n-        (self.fold_type_method)(m, self as @ast_fold)\n-    }\n-    fn fold_method(@self, x: @method) -> @method {\n-        (self.fold_method)(x, self as @ast_fold)\n-    }\n-    fn fold_block(@self, x: &Block) -> Block {\n-        (self.fold_block)(x, self as @ast_fold)\n-    }\n-    fn fold_stmt(@self, x: &Stmt) -> Option<@Stmt> {\n-        let (n_opt, s) = (self.fold_stmt)(&x.node, x.span, self as @ast_fold);\n-        match n_opt {\n-            Some(n) => Some(@Spanned { node: n, span: (self.new_span)(s) }),\n-            None => None,\n-        }\n-    }\n-    fn fold_arm(@self, x: &Arm) -> Arm {\n-        (self.fold_arm)(x, self as @ast_fold)\n-    }\n-    fn fold_pat(@self, x: @Pat) -> @Pat {\n-        let (n, s) =  (self.fold_pat)(&x.node, x.span, self as @ast_fold);\n-        @Pat {\n-            id: (self.new_id)(x.id),\n-            node: n,\n-            span: (self.new_span)(s),\n-        }\n-    }\n-    fn fold_decl(@self, x: @Decl) -> Option<@Decl> {\n-        let (n_opt, s) = (self.fold_decl)(&x.node, x.span, self as @ast_fold);\n-        match n_opt {\n-            Some(n) => Some(@Spanned { node: n, span: (self.new_span)(s) }),\n-            None => None,\n+pub fn noop_fold_stmt<T:ast_fold>(s: &Stmt, folder: &T) -> Option<@Stmt> {\n+    let node = match s.node {\n+        StmtDecl(d, nid) => {\n+            match folder.fold_decl(d) {\n+                Some(d) => Some(StmtDecl(d, folder.new_id(nid))),\n+                None => None,\n+            }\n         }\n-    }\n-    fn fold_expr(@self, x: @Expr) -> @Expr {\n-        let (n, s) = (self.fold_expr)(&x.node, x.span, self as @ast_fold);\n-        @Expr {\n-            id: (self.new_id)(x.id),\n-            node: n,\n-            span: (self.new_span)(s),\n+        StmtExpr(e, nid) => {\n+            Some(StmtExpr(folder.fold_expr(e), folder.new_id(nid)))\n         }\n-    }\n-    fn fold_ty(@self, x: &Ty) -> Ty {\n-        let (n, s) = (self.fold_ty)(&x.node, x.span, self as @ast_fold);\n-        Ty {\n-            id: (self.new_id)(x.id),\n-            node: n,\n-            span: (self.new_span)(s),\n+        StmtSemi(e, nid) => {\n+            Some(StmtSemi(folder.fold_expr(e), folder.new_id(nid)))\n         }\n-    }\n-    fn fold_mod(@self, x: &_mod) -> _mod {\n-        (self.fold_mod)(x, self as @ast_fold)\n-    }\n-    fn fold_foreign_mod(@self, x: &foreign_mod) -> foreign_mod {\n-        (self.fold_foreign_mod)(x, self as @ast_fold)\n-    }\n-    fn fold_variant(@self, x: &variant) -> variant {\n-        let (n, s) = (self.fold_variant)(&x.node, x.span, self as @ast_fold);\n-        Spanned { node: n, span: (self.new_span)(s) }\n-    }\n-    fn fold_ident(@self, x: Ident) -> Ident {\n-        (self.fold_ident)(x, self as @ast_fold)\n-    }\n-    fn fold_path(@self, x: &Path) -> Path {\n-        (self.fold_path)(x, self as @ast_fold)\n-    }\n-    fn fold_local(@self, x: @Local) -> @Local {\n-        (self.fold_local)(x, self as @ast_fold)\n-    }\n-    fn fold_mac(@self, x: &mac) -> mac {\n-        let (n, s) = (self.fold_mac)(&x.node, x.span, self as @ast_fold);\n-        Spanned { node: n, span: (self.new_span)(s) }\n-    }\n-    fn map_exprs(@self,\n-                 f: @fn(@Expr) -> @Expr,\n-                 e: &[@Expr])\n-              -> ~[@Expr] {\n-        (self.map_exprs)(f, e)\n-    }\n-    fn new_id(@self, node_id: ast::NodeId) -> NodeId {\n-        (self.new_id)(node_id)\n-    }\n-    fn new_span(@self, span: Span) -> Span {\n-        (self.new_span)(span)\n-    }\n-}\n+        StmtMac(ref mac, semi) => Some(StmtMac(folder.fold_mac(mac), semi))\n+    };\n \n-// brson agrees with me that this function's existence is probably\n-// not a good or useful thing.\n-pub fn make_fold(afp: ast_fold_fns) -> @ast_fold {\n-    afp as @ast_fold\n+    node.map_move(|node| @Spanned {\n+        node: node,\n+        span: folder.new_span(s.span),\n+    })\n }\n \n #[cfg(test)]\n@@ -1048,16 +870,23 @@ mod test {\n     use print::pprust;\n     use super::*;\n \n+    struct IdentFolder {\n+        f: @fn(ast::ident)->ast::ident,\n+    }\n+\n+    impl ast_fold for IdentFolder {\n+        fn fold_ident(@self, i: ident) -> ident {\n+            (self.f)(i)\n+        }\n+    }\n+\n     // taken from expand\n     // given a function from idents to idents, produce\n     // an ast_fold that applies that function:\n-    pub fn fun_to_ident_folder(f: @fn(ast::Ident)->ast::Ident) -> @ast_fold{\n-        let afp = default_ast_fold();\n-        let f_pre = @AstFoldFns{\n-            fold_ident : |id, _| f(id),\n-            .. *afp\n-        };\n-        make_fold(f_pre)\n+    pub fn fun_to_ident_folder(f: @fn(ast::ident)->ast::ident) -> @ast_fold {\n+        @IdentFolder {\n+            f: f,\n+        } as @ast_fold\n     }\n \n     // this version doesn't care about getting comments or docstrings in.\n@@ -1120,3 +949,4 @@ mod test {\n                      ~\"fn zz(){let zz=13 as zz;}\");\n     }\n }\n+"}, {"sha": "b6976b2c35545b9c7f84f308044cd9cc0a643f7d", "filename": "src/test/compile-fail/dead-code-ret.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e5de06135fa9a857931191101d61a4abe149c96/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5de06135fa9a857931191101d61a4abe149c96/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs?ref=3e5de06135fa9a857931191101d61a4abe149c96", "patch": "@@ -1,3 +1,8 @@\n+// xfail-test\n+\n+// xfail'd because the lint pass doesn't know to ignore standard library\n+// stuff.\n+\n // -*- rust -*-\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at"}, {"sha": "c39c258c701f9001aef7428f841938fda7289479", "filename": "src/test/compile-fail/issue-897-2.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e5de06135fa9a857931191101d61a4abe149c96/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e5de06135fa9a857931191101d61a4abe149c96/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs?ref=3e5de06135fa9a857931191101d61a4abe149c96", "patch": "@@ -1,3 +1,7 @@\n+// xfail-test\n+// xfail'd because the lint pass doesn't know to ignore standard library\n+// stuff.\n+\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}]}