{"sha": "400cb9aa41815f874d7d29a545e6e6f8539459de", "node_id": "C_kwDOAAsO6NoAKDQwMGNiOWFhNDE4MTVmODc0ZDdkMjlhNTQ1ZTZlNmY4NTM5NDU5ZGU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-07-26T18:37:25Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-01-27T19:00:26Z"}, "message": "Separate witness type computation from the generator transform.", "tree": {"sha": "a44e23089b43a953305ad0931729b74a3bca69b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a44e23089b43a953305ad0931729b74a3bca69b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/400cb9aa41815f874d7d29a545e6e6f8539459de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/400cb9aa41815f874d7d29a545e6e6f8539459de", "html_url": "https://github.com/rust-lang/rust/commit/400cb9aa41815f874d7d29a545e6e6f8539459de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/400cb9aa41815f874d7d29a545e6e6f8539459de/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2387ad484b35c77941f8ad5687ddac55493606c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2387ad484b35c77941f8ad5687ddac55493606c", "html_url": "https://github.com/rust-lang/rust/commit/e2387ad484b35c77941f8ad5687ddac55493606c"}], "stats": {"total": 335, "additions": 304, "deletions": 31}, "files": [{"sha": "9b1401f4a44dfdf922120faf9bd9f165c902d3c9", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=400cb9aa41815f874d7d29a545e6e6f8539459de", "patch": "@@ -202,6 +202,7 @@ provide! { tcx, def_id, other, cdata,\n     thir_abstract_const => { table }\n     optimized_mir => { table }\n     mir_for_ctfe => { table }\n+    mir_generator_witnesses => { table }\n     promoted_mir => { table }\n     def_span => { table }\n     def_ident_span => { table }"}, {"sha": "a72089338ee32b1aab683bd005aa625ca5951b39", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=400cb9aa41815f874d7d29a545e6e6f8539459de", "patch": "@@ -1414,6 +1414,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n             if encode_opt {\n                 record!(self.tables.optimized_mir[def_id.to_def_id()] <- tcx.optimized_mir(def_id));\n+\n+                if let DefKind::Generator = self.tcx.def_kind(def_id) {\n+                    record!(self.tables.mir_generator_witnesses[def_id.to_def_id()] <- tcx.mir_generator_witnesses(def_id));\n+                }\n             }\n             if encode_const {\n                 record!(self.tables.mir_for_ctfe[def_id.to_def_id()] <- tcx.mir_for_ctfe(def_id));"}, {"sha": "37af9e64e9a3da5002ee527d5b6f655d05366506", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=400cb9aa41815f874d7d29a545e6e6f8539459de", "patch": "@@ -376,6 +376,7 @@ define_tables! {\n     object_lifetime_default: Table<DefIndex, LazyValue<ObjectLifetimeDefault>>,\n     optimized_mir: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n+    mir_generator_witnesses: Table<DefIndex, LazyValue<mir::GeneratorLayout<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,\n     // FIXME(compiler-errors): Why isn't this a LazyArray?\n     thir_abstract_const: Table<DefIndex, LazyValue<ty::Const<'static>>>,"}, {"sha": "3f5c28743394b9f666ec583c04cf41ec0c4904c3", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=400cb9aa41815f874d7d29a545e6e6f8539459de", "patch": "@@ -471,6 +471,13 @@ rustc_queries! {\n         }\n     }\n \n+    query mir_generator_witnesses(key: DefId) -> mir::GeneratorLayout<'tcx> {\n+        arena_cache\n+        desc { |tcx| \"generator witness types for `{}`\", tcx.def_path_str(key) }\n+        cache_on_disk_if { key.is_local() }\n+        separate_provide_extern\n+    }\n+\n     /// MIR after our optimization passes have run. This is MIR that is ready\n     /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n     query optimized_mir(key: DefId) -> &'tcx mir::Body<'tcx> {"}, {"sha": "84edb5f2a4288fd4cfa12327c9504877866dd6f6", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=400cb9aa41815f874d7d29a545e6e6f8539459de", "patch": "@@ -117,6 +117,7 @@ macro_rules! parameterized_over_tcx {\n parameterized_over_tcx! {\n     crate::middle::exported_symbols::ExportedSymbol,\n     crate::mir::Body,\n+    crate::mir::GeneratorLayout,\n     ty::Ty,\n     ty::FnSig,\n     ty::GenericPredicates,"}, {"sha": "2a2fe791d8c5907df24cd84260b2cb4fa2acb288", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=400cb9aa41815f874d7d29a545e6e6f8539459de", "patch": "@@ -1747,8 +1747,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 };\n                 let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).ty;\n                 let fake_borrow_ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, fake_borrow_deref_ty);\n-                let fake_borrow_temp =\n-                    self.local_decls.push(LocalDecl::new(fake_borrow_ty, temp_span));\n+                let mut fake_borrow_temp = LocalDecl::new(fake_borrow_ty, temp_span);\n+                fake_borrow_temp.internal = self.local_decls[matched_place.local].internal;\n+                let fake_borrow_temp = self.local_decls.push(fake_borrow_temp);\n \n                 (matched_place, fake_borrow_temp)\n             })"}, {"sha": "25f270b18869623d66361e4ccc433172f7f02b91", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 282, "deletions": 28, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=400cb9aa41815f874d7d29a545e6e6f8539459de", "patch": "@@ -54,7 +54,8 @@ use crate::deref_separator::deref_finder;\n use crate::simplify;\n use crate::util::expand_aggregate;\n use crate::MirPass;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::pluralize;\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::GeneratorKind;\n@@ -70,6 +71,9 @@ use rustc_mir_dataflow::impls::{\n };\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::{self, Analysis};\n+use rustc_span::def_id::DefId;\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::PanicStrategy;\n use std::{iter, ops};\n@@ -854,7 +858,7 @@ fn sanitize_witness<'tcx>(\n     body: &Body<'tcx>,\n     witness: Ty<'tcx>,\n     upvars: Vec<Ty<'tcx>>,\n-    saved_locals: &GeneratorSavedLocals,\n+    layout: &GeneratorLayout<'tcx>,\n ) {\n     let did = body.source.def_id();\n     let param_env = tcx.param_env(did);\n@@ -873,31 +877,35 @@ fn sanitize_witness<'tcx>(\n         }\n     };\n \n-    for (local, decl) in body.local_decls.iter_enumerated() {\n-        // Ignore locals which are internal or not saved between yields.\n-        if !saved_locals.contains(local) || decl.internal {\n+    let mut mismatches = Vec::new();\n+    for fty in &layout.field_tys {\n+        if fty.is_static_ptr {\n             continue;\n         }\n-        let decl_ty = tcx.normalize_erasing_regions(param_env, decl.ty);\n+        let decl_ty = tcx.normalize_erasing_regions(param_env, fty.ty);\n \n         // Sanity check that typeck knows about the type of locals which are\n         // live across a suspension point\n         if !allowed.contains(&decl_ty) && !allowed_upvars.contains(&decl_ty) {\n-            span_bug!(\n-                body.span,\n-                \"Broken MIR: generator contains type {} in MIR, \\\n-                       but typeck only knows about {} and {:?}\",\n-                decl_ty,\n-                allowed,\n-                allowed_upvars\n-            );\n+            mismatches.push(decl_ty);\n         }\n     }\n+\n+    if !mismatches.is_empty() {\n+        span_bug!(\n+            body.span,\n+            \"Broken MIR: generator contains type {:?} in MIR, \\\n+                       but typeck only knows about {} and {:?}\",\n+            mismatches,\n+            allowed,\n+            allowed_upvars\n+        );\n+    }\n }\n \n fn compute_layout<'tcx>(\n     liveness: LivenessInfo,\n-    body: &mut Body<'tcx>,\n+    body: &Body<'tcx>,\n ) -> (\n     FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n     GeneratorLayout<'tcx>,\n@@ -920,9 +928,7 @@ fn compute_layout<'tcx>(\n         let decl = GeneratorSavedTy {\n             ty: decl.ty,\n             source_info: decl.source_info,\n-            is_static_ptr: decl.internal\n-                && decl.ty.is_unsafe_ptr()\n-                && matches!(decl.local_info.as_deref(), Some(LocalInfo::StaticRef { .. })),\n+            is_static_ptr: decl.internal,\n         };\n         tys.push(decl);\n         debug!(\"generator saved local {:?} => {:?}\", saved_local, local);\n@@ -1360,6 +1366,52 @@ fn create_cases<'tcx>(\n         .collect()\n }\n \n+#[instrument(level = \"debug\", skip(tcx), ret)]\n+pub(crate) fn mir_generator_witnesses<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+) -> GeneratorLayout<'tcx> {\n+    let def_id = def_id.expect_local();\n+\n+    let (body, _) = tcx.mir_promoted(ty::WithOptConstParam::unknown(def_id));\n+    let body = body.borrow();\n+    let body = &*body;\n+\n+    // The first argument is the generator type passed by value\n+    let gen_ty = body.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty;\n+\n+    // Get the interior types and substs which typeck computed\n+    let (upvars, interior, movable) = match *gen_ty.kind() {\n+        ty::Generator(_, substs, movability) => {\n+            let substs = substs.as_generator();\n+            (\n+                substs.upvar_tys().collect::<Vec<_>>(),\n+                substs.witness(),\n+                movability == hir::Movability::Movable,\n+            )\n+        }\n+        _ => span_bug!(body.span, \"unexpected generator type {}\", gen_ty),\n+    };\n+\n+    // When first entering the generator, move the resume argument into its new local.\n+    let always_live_locals = always_storage_live_locals(&body);\n+\n+    let liveness_info = locals_live_across_suspend_points(tcx, body, &always_live_locals, movable);\n+\n+    // Extract locals which are live across suspension point into `layout`\n+    // `remap` gives a mapping from local indices onto generator struct indices\n+    // `storage_liveness` tells us which locals have live storage at suspension points\n+    let (_, generator_layout, _) = compute_layout(liveness_info, body);\n+\n+    if tcx.sess.opts.unstable_opts.drop_tracking_mir {\n+        check_suspend_tys(tcx, &generator_layout, &body);\n+    } else {\n+        sanitize_witness(tcx, body, interior, upvars, &generator_layout);\n+    }\n+\n+    generator_layout\n+}\n+\n impl<'tcx> MirPass<'tcx> for StateTransform {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let Some(yield_ty) = body.yield_ty() else {\n@@ -1372,16 +1424,11 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         // The first argument is the generator type passed by value\n         let gen_ty = body.local_decls.raw[1].ty;\n \n-        // Get the interior types and substs which typeck computed\n-        let (upvars, interior, discr_ty, movable) = match *gen_ty.kind() {\n+        // Get the discriminant type and substs which typeck computed\n+        let (discr_ty, movable) = match *gen_ty.kind() {\n             ty::Generator(_, substs, movability) => {\n                 let substs = substs.as_generator();\n-                (\n-                    substs.upvar_tys().collect(),\n-                    substs.witness(),\n-                    substs.discr_ty(tcx),\n-                    movability == hir::Movability::Movable,\n-                )\n+                (substs.discr_ty(tcx), movability == hir::Movability::Movable)\n             }\n             _ => {\n                 tcx.sess\n@@ -1443,8 +1490,6 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         let liveness_info =\n             locals_live_across_suspend_points(tcx, body, &always_live_locals, movable);\n \n-        sanitize_witness(tcx, body, interior, upvars, &liveness_info.saved_locals);\n-\n         if tcx.sess.opts.unstable_opts.validate_mir {\n             let mut vis = EnsureGeneratorFieldAssignmentsNeverAlias {\n                 assigned_local: None,\n@@ -1640,3 +1685,212 @@ impl<'tcx> Visitor<'tcx> for EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n         }\n     }\n }\n+\n+fn check_suspend_tys<'tcx>(tcx: TyCtxt<'tcx>, layout: &GeneratorLayout<'tcx>, body: &Body<'tcx>) {\n+    let mut linted_tys = FxHashSet::default();\n+\n+    // We want a user-facing param-env.\n+    let param_env = tcx.param_env(body.source.def_id());\n+\n+    for (variant, yield_source_info) in\n+        layout.variant_fields.iter().zip(&layout.variant_source_info)\n+    {\n+        debug!(?variant);\n+        for &local in variant {\n+            let decl = &layout.field_tys[local];\n+            debug!(?decl);\n+\n+            if !decl.is_static_ptr && linted_tys.insert(decl.ty) {\n+                let Some(hir_id) = decl.source_info.scope.lint_root(&body.source_scopes) else { continue };\n+\n+                check_must_not_suspend_ty(\n+                    tcx,\n+                    decl.ty,\n+                    hir_id,\n+                    param_env,\n+                    SuspendCheckData {\n+                        source_span: decl.source_info.span,\n+                        yield_span: yield_source_info.span,\n+                        plural_len: 1,\n+                        ..Default::default()\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Default)]\n+struct SuspendCheckData<'a> {\n+    source_span: Span,\n+    yield_span: Span,\n+    descr_pre: &'a str,\n+    descr_post: &'a str,\n+    plural_len: usize,\n+}\n+\n+// Returns whether it emitted a diagnostic or not\n+// Note that this fn and the proceeding one are based on the code\n+// for creating must_use diagnostics\n+//\n+// Note that this technique was chosen over things like a `Suspend` marker trait\n+// as it is simpler and has precedent in the compiler\n+fn check_must_not_suspend_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    hir_id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    data: SuspendCheckData<'_>,\n+) -> bool {\n+    if ty.is_unit() {\n+        return false;\n+    }\n+\n+    let plural_suffix = pluralize!(data.plural_len);\n+\n+    debug!(\"Checking must_not_suspend for {}\", ty);\n+\n+    match *ty.kind() {\n+        ty::Adt(..) if ty.is_box() => {\n+            let boxed_ty = ty.boxed_ty();\n+            let descr_pre = &format!(\"{}boxed \", data.descr_pre);\n+            check_must_not_suspend_ty(\n+                tcx,\n+                boxed_ty,\n+                hir_id,\n+                param_env,\n+                SuspendCheckData { descr_pre, ..data },\n+            )\n+        }\n+        ty::Adt(def, _) => check_must_not_suspend_def(tcx, def.did(), hir_id, data),\n+        // FIXME: support adding the attribute to TAITs\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n+            let mut has_emitted = false;\n+            for &(predicate, _) in tcx.explicit_item_bounds(def) {\n+                // We only look at the `DefId`, so it is safe to skip the binder here.\n+                if let ty::PredicateKind::Clause(ty::Clause::Trait(ref poly_trait_predicate)) =\n+                    predicate.kind().skip_binder()\n+                {\n+                    let def_id = poly_trait_predicate.trait_ref.def_id;\n+                    let descr_pre = &format!(\"{}implementer{} of \", data.descr_pre, plural_suffix);\n+                    if check_must_not_suspend_def(\n+                        tcx,\n+                        def_id,\n+                        hir_id,\n+                        SuspendCheckData { descr_pre, ..data },\n+                    ) {\n+                        has_emitted = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            has_emitted\n+        }\n+        ty::Dynamic(binder, _, _) => {\n+            let mut has_emitted = false;\n+            for predicate in binder.iter() {\n+                if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n+                    let def_id = trait_ref.def_id;\n+                    let descr_post = &format!(\" trait object{}{}\", plural_suffix, data.descr_post);\n+                    if check_must_not_suspend_def(\n+                        tcx,\n+                        def_id,\n+                        hir_id,\n+                        SuspendCheckData { descr_post, ..data },\n+                    ) {\n+                        has_emitted = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            has_emitted\n+        }\n+        ty::Tuple(fields) => {\n+            let mut has_emitted = false;\n+            for (i, ty) in fields.iter().enumerate() {\n+                let descr_post = &format!(\" in tuple element {i}\");\n+                if check_must_not_suspend_ty(\n+                    tcx,\n+                    ty,\n+                    hir_id,\n+                    param_env,\n+                    SuspendCheckData { descr_post, ..data },\n+                ) {\n+                    has_emitted = true;\n+                }\n+            }\n+            has_emitted\n+        }\n+        ty::Array(ty, len) => {\n+            let descr_pre = &format!(\"{}array{} of \", data.descr_pre, plural_suffix);\n+            check_must_not_suspend_ty(\n+                tcx,\n+                ty,\n+                hir_id,\n+                param_env,\n+                SuspendCheckData {\n+                    descr_pre,\n+                    plural_len: len.try_eval_usize(tcx, param_env).unwrap_or(0) as usize + 1,\n+                    ..data\n+                },\n+            )\n+        }\n+        // If drop tracking is enabled, we want to look through references, since the referrent\n+        // may not be considered live across the await point.\n+        ty::Ref(_region, ty, _mutability) => {\n+            let descr_pre = &format!(\"{}reference{} to \", data.descr_pre, plural_suffix);\n+            check_must_not_suspend_ty(\n+                tcx,\n+                ty,\n+                hir_id,\n+                param_env,\n+                SuspendCheckData { descr_pre, ..data },\n+            )\n+        }\n+        _ => false,\n+    }\n+}\n+\n+fn check_must_not_suspend_def(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+    hir_id: hir::HirId,\n+    data: SuspendCheckData<'_>,\n+) -> bool {\n+    if let Some(attr) = tcx.get_attr(def_id, sym::must_not_suspend) {\n+        let msg = format!(\n+            \"{}`{}`{} held across a suspend point, but should not be\",\n+            data.descr_pre,\n+            tcx.def_path_str(def_id),\n+            data.descr_post,\n+        );\n+        tcx.struct_span_lint_hir(\n+            rustc_session::lint::builtin::MUST_NOT_SUSPEND,\n+            hir_id,\n+            data.source_span,\n+            msg,\n+            |lint| {\n+                // add span pointing to the offending yield/await\n+                lint.span_label(data.yield_span, \"the value is held across this suspend point\");\n+\n+                // Add optional reason note\n+                if let Some(note) = attr.value_str() {\n+                    // FIXME(guswynn): consider formatting this better\n+                    lint.span_note(data.source_span, note.as_str());\n+                }\n+\n+                // Add some quick suggestions on what to do\n+                // FIXME: can `drop` work as a suggestion here as well?\n+                lint.span_help(\n+                    data.source_span,\n+                    \"consider using a block (`{ ... }`) \\\n+                    to shrink the value's scope, ending before the suspend point\",\n+                )\n+            },\n+        );\n+\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "fe3d5b1cce4589470872382c17aa82a06d77af5f", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=400cb9aa41815f874d7d29a545e6e6f8539459de", "patch": "@@ -123,6 +123,7 @@ pub fn provide(providers: &mut Providers) {\n         mir_drops_elaborated_and_const_checked,\n         mir_for_ctfe,\n         mir_for_ctfe_of_const_arg,\n+        mir_generator_witnesses: generator::mir_generator_witnesses,\n         optimized_mir,\n         is_mir_available,\n         is_ctfe_mir_available: |tcx, did| is_mir_available(tcx, did),\n@@ -425,6 +426,9 @@ fn mir_drops_elaborated_and_const_checked(\n         return tcx.mir_drops_elaborated_and_const_checked(def);\n     }\n \n+    if tcx.generator_kind(def.did).is_some() {\n+        tcx.ensure().mir_generator_witnesses(def.did);\n+    }\n     let mir_borrowck = tcx.mir_borrowck_opt_const_arg(def);\n \n     let is_fn_like = tcx.def_kind(def.did).is_fn_like();"}, {"sha": "e7bb30553736c492533962e8f576f1101a43e87b", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400cb9aa41815f874d7d29a545e6e6f8539459de/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=400cb9aa41815f874d7d29a545e6e6f8539459de", "patch": "@@ -170,7 +170,7 @@ pub enum TyKind<I: Interner> {\n     ///\n     /// This variant is only using when `drop_tracking_mir` is set.\n     /// This contains the `DefId` and the `SubstRef` of the generator.\n-    /// The actual witness types are computed on MIR by the `mir_generator_info` query.\n+    /// The actual witness types are computed on MIR by the `mir_generator_witnesses` query.\n     ///\n     /// Looking at the following example, the witness for this generator\n     /// may end up as something like `for<'a> [Vec<i32>, &'a Vec<i32>]`:"}]}