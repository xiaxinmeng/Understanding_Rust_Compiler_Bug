{"sha": "34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0Yjk1YTNjNmEyYTU2ZDc2YmJkOGFlMTlmMzE4YzAzYTJlNTA0MWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-15T04:09:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-15T04:09:37Z"}, "message": "Auto merge of #32206 - alexcrichton:fix-windows-rustbuild, r=brson\n\nFix Windows rustbuild\n\nThese commits fix the rustbuild Windows bots, namely:\n\n* The 32-bit build of LLVM was failing because libraries weren't being linked. This was in turn caused by the build script for `rustc_llvm` erroneously detecting that it was cross compiling when it actually wasn't.\n* Tools of the build were compiled against the wrong libraries, so running them would fail on Windows as rpath didn't exist and `PATH` was wrong.\n* Some linkchecker fixes for Windows paths had to be applied as well.", "tree": {"sha": "06f09daf58ca14918105191684d3e4939afd0950", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06f09daf58ca14918105191684d3e4939afd0950"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "html_url": "https://github.com/rust-lang/rust/commit/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ca75619dc80f71f356cab0cdd11cc959e4c24db", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ca75619dc80f71f356cab0cdd11cc959e4c24db", "html_url": "https://github.com/rust-lang/rust/commit/9ca75619dc80f71f356cab0cdd11cc959e4c24db"}, {"sha": "158b854fb73dab7680f9554c2bbde2f821d2630e", "url": "https://api.github.com/repos/rust-lang/rust/commits/158b854fb73dab7680f9554c2bbde2f821d2630e", "html_url": "https://github.com/rust-lang/rust/commit/158b854fb73dab7680f9554c2bbde2f821d2630e"}], "stats": {"total": 310, "additions": 143, "deletions": 167}, "files": [{"sha": "a50b09bcdef130080839c560f604b8a1e7d6dc8b", "filename": "src/bootstrap/build/check.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Fbootstrap%2Fbuild%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Fbootstrap%2Fbuild%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcheck.rs?ref=34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "patch": "@@ -8,14 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::process::Command;\n-\n use build::{Build, Compiler};\n \n pub fn linkcheck(build: &Build, stage: u32, host: &str) {\n     println!(\"Linkcheck stage{} ({})\", stage, host);\n     let compiler = Compiler::new(stage, host);\n-    let linkchecker = build.tool(&compiler, \"linkchecker\");\n-    build.run(Command::new(&linkchecker)\n-                     .arg(build.out.join(host).join(\"doc\")));\n+    build.run(build.tool_cmd(&compiler, \"linkchecker\")\n+                   .arg(build.out.join(host).join(\"doc\")));\n }"}, {"sha": "95555aa3796889143df1ef07f87ecec4172064a2", "filename": "src/bootstrap/build/compile.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcompile.rs?ref=34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "patch": "@@ -23,26 +23,23 @@ use build::{Build, Compiler, Mode};\n /// This will build the standard library for a particular stage of the build\n /// using the `compiler` targeting the `target` architecture. The artifacts\n /// created will also be linked into the sysroot directory.\n-pub fn std<'a>(build: &'a Build, stage: u32, target: &str,\n-               compiler: &Compiler<'a>) {\n-    let host = compiler.host;\n-    println!(\"Building stage{} std artifacts ({} -> {})\", stage,\n-             host, target);\n+pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n+    println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n+             compiler.host, target);\n \n     // Move compiler-rt into place as it'll be required by the compiler when\n     // building the standard library to link the dylib of libstd\n-    let libdir = build.sysroot_libdir(stage, &host, target);\n+    let libdir = build.sysroot_libdir(compiler, target);\n     let _ = fs::remove_dir_all(&libdir);\n     t!(fs::create_dir_all(&libdir));\n     t!(fs::hard_link(&build.compiler_rt_built.borrow()[target],\n                      libdir.join(staticlib(\"compiler-rt\", target))));\n \n     build_startup_objects(build, target, &libdir);\n \n-    let out_dir = build.cargo_out(stage, &host, Mode::Libstd, target);\n+    let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n     build.clear_if_dirty(&out_dir, &build.compiler_path(compiler));\n-    let mut cargo = build.cargo(stage, compiler, Mode::Libstd, Some(target),\n-                                \"build\");\n+    let mut cargo = build.cargo(compiler, Mode::Libstd, target, \"build\");\n     cargo.arg(\"--features\").arg(build.std_features())\n          .arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"));\n@@ -59,20 +56,20 @@ pub fn std<'a>(build: &'a Build, stage: u32, target: &str,\n     }\n \n     build.run(&mut cargo);\n-    std_link(build, stage, target, compiler, host);\n+    std_link(build, target, compiler, compiler.host);\n }\n \n /// Link all libstd rlibs/dylibs into the sysroot location.\n ///\n /// Links those artifacts generated in the given `stage` for `target` produced\n /// by `compiler` into `host`'s sysroot.\n pub fn std_link(build: &Build,\n-                stage: u32,\n                 target: &str,\n                 compiler: &Compiler,\n                 host: &str) {\n-    let libdir = build.sysroot_libdir(stage, host, target);\n-    let out_dir = build.cargo_out(stage, compiler.host, Mode::Libstd, target);\n+    let target_compiler = Compiler::new(compiler.stage, host);\n+    let libdir = build.sysroot_libdir(&target_compiler, target);\n+    let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n \n     // If we're linking one compiler host's output into another, then we weren't\n     // called from the `std` method above. In that case we clean out what's\n@@ -85,7 +82,8 @@ pub fn std_link(build: &Build,\n     }\n     add_to_sysroot(&out_dir, &libdir);\n \n-    if target.contains(\"musl\") && (target.contains(\"x86_64\") || target.contains(\"i686\")) {\n+    if target.contains(\"musl\") &&\n+       (target.contains(\"x86_64\") || target.contains(\"i686\")) {\n         copy_third_party_objects(build, target, &libdir);\n     }\n }\n@@ -130,17 +128,14 @@ fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n /// This will build the compiler for a particular stage of the build using\n /// the `compiler` targeting the `target` architecture. The artifacts\n /// created will also be linked into the sysroot directory.\n-pub fn rustc<'a>(build: &'a Build, stage: u32, target: &str,\n-                 compiler: &Compiler<'a>) {\n-    let host = compiler.host;\n-    println!(\"Building stage{} compiler artifacts ({} -> {})\", stage,\n-             host, target);\n+pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n+    println!(\"Building stage{} compiler artifacts ({} -> {})\",\n+             compiler.stage, compiler.host, target);\n \n-    let out_dir = build.cargo_out(stage, &host, Mode::Librustc, target);\n-    build.clear_if_dirty(&out_dir, &libstd_shim(build, stage, &host, target));\n+    let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n+    build.clear_if_dirty(&out_dir, &libstd_shim(build, compiler, target));\n \n-    let mut cargo = build.cargo(stage, compiler, Mode::Librustc, Some(target),\n-                                \"build\");\n+    let mut cargo = build.cargo(compiler, Mode::Librustc, target, \"build\");\n     cargo.arg(\"--features\").arg(build.rustc_features())\n          .arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/Cargo.toml\"));\n@@ -184,27 +179,27 @@ pub fn rustc<'a>(build: &'a Build, stage: u32, target: &str,\n     }\n     build.run(&mut cargo);\n \n-    rustc_link(build, stage, target, compiler, compiler.host);\n+    rustc_link(build, target, compiler, compiler.host);\n }\n \n /// Link all librustc rlibs/dylibs into the sysroot location.\n ///\n /// Links those artifacts generated in the given `stage` for `target` produced\n /// by `compiler` into `host`'s sysroot.\n pub fn rustc_link(build: &Build,\n-                  stage: u32,\n                   target: &str,\n                   compiler: &Compiler,\n                   host: &str) {\n-    let libdir = build.sysroot_libdir(stage, host, target);\n-    let out_dir = build.cargo_out(stage, compiler.host, Mode::Librustc, target);\n+    let target_compiler = Compiler::new(compiler.stage, host);\n+    let libdir = build.sysroot_libdir(&target_compiler, target);\n+    let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n     add_to_sysroot(&out_dir, &libdir);\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-fn libstd_shim(build: &Build, stage: u32, host: &str, target: &str) -> PathBuf {\n-    build.cargo_out(stage, host, Mode::Libstd, target).join(\"libstd_shim.rlib\")\n+fn libstd_shim(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Libstd, target).join(\"libstd_shim.rlib\")\n }\n \n fn compiler_file(compiler: &Path, file: &str) -> String {\n@@ -219,25 +214,29 @@ fn compiler_file(compiler: &Path, file: &str) -> String {\n /// compiler.\n pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n     assert!(stage > 0, \"the stage0 compiler isn't assembled, it's downloaded\");\n+    // The compiler that we're assembling\n+    let target_compiler = Compiler::new(stage, host);\n+\n+    // The compiler that compiled the compiler we're assembling\n+    let build_compiler = Compiler::new(stage - 1, &build.config.build);\n \n     // Clear out old files\n-    let sysroot = build.sysroot(stage, host);\n+    let sysroot = build.sysroot(&target_compiler);\n     let _ = fs::remove_dir_all(&sysroot);\n     t!(fs::create_dir_all(&sysroot));\n \n     // Link in all dylibs to the libdir\n     let sysroot_libdir = sysroot.join(libdir(host));\n     t!(fs::create_dir_all(&sysroot_libdir));\n-    let src_libdir = build.sysroot_libdir(stage - 1, &build.config.build, host);\n+    let src_libdir = build.sysroot_libdir(&build_compiler, host);\n     for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n         let filename = f.file_name().into_string().unwrap();\n         if is_dylib(&filename) {\n             t!(fs::hard_link(&f.path(), sysroot_libdir.join(&filename)));\n         }\n     }\n \n-    let out_dir = build.cargo_out(stage - 1, &build.config.build,\n-                                  Mode::Librustc, host);\n+    let out_dir = build.cargo_out(&build_compiler, Mode::Librustc, host);\n \n     // Link the compiler binary itself into place\n     let rustc = out_dir.join(exe(\"rustc\", host));\n@@ -315,7 +314,7 @@ pub fn tool(build: &Build, stage: u32, host: &str, tool: &str) {\n     // let out_dir = build.cargo_out(stage, &host, Mode::Librustc, target);\n     // build.clear_if_dirty(&out_dir, &libstd_shim(build, stage, &host, target));\n \n-    let mut cargo = build.cargo(stage, &compiler, Mode::Tool, None, \"build\");\n+    let mut cargo = build.cargo(&compiler, Mode::Tool, host, \"build\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(format!(\"src/tools/{}/Cargo.toml\", tool)));\n     build.run(&mut cargo);"}, {"sha": "d8b02dce222cd0312eb3f9d1469cf2cf3d6344f0", "filename": "src/bootstrap/build/doc.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Fbootstrap%2Fbuild%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Fbootstrap%2Fbuild%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fdoc.rs?ref=34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "patch": "@@ -81,6 +81,7 @@ pub fn standalone(build: &Build, stage: u32, host: &str, out: &Path) {\n         }\n \n         let mut cmd = Command::new(&rustdoc);\n+        build.add_rustc_lib_path(&compiler, &mut cmd);\n         cmd.arg(\"--html-after-content\").arg(&footer)\n            .arg(\"--html-before-content\").arg(&version_info)\n            .arg(\"--html-in-header\").arg(&favicon)\n@@ -107,14 +108,13 @@ pub fn standalone(build: &Build, stage: u32, host: &str, out: &Path) {\n pub fn std(build: &Build, stage: u32, host: &str, out: &Path) {\n     println!(\"Documenting stage{} std ({})\", stage, host);\n     let compiler = Compiler::new(stage, host);\n-    let out_dir = build.stage_out(stage, host, Mode::Libstd)\n+    let out_dir = build.stage_out(&compiler, Mode::Libstd)\n                        .join(host).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n \n     build.clear_if_dirty(&out_dir, &rustdoc);\n \n-    let mut cargo = build.cargo(stage, &compiler, Mode::Libstd, Some(host),\n-                                \"doc\");\n+    let mut cargo = build.cargo(&compiler, Mode::Libstd, host, \"doc\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"))\n          .arg(\"--features\").arg(build.std_features());\n@@ -125,14 +125,13 @@ pub fn std(build: &Build, stage: u32, host: &str, out: &Path) {\n pub fn rustc(build: &Build, stage: u32, host: &str, out: &Path) {\n     println!(\"Documenting stage{} compiler ({})\", stage, host);\n     let compiler = Compiler::new(stage, host);\n-    let out_dir = build.stage_out(stage, host, Mode::Librustc)\n+    let out_dir = build.stage_out(&compiler, Mode::Librustc)\n                        .join(host).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n     if !up_to_date(&rustdoc, &out_dir.join(\"rustc/index.html\")) {\n         t!(fs::remove_dir_all(&out_dir));\n     }\n-    let mut cargo = build.cargo(stage, &compiler, Mode::Librustc, Some(host),\n-                                \"doc\");\n+    let mut cargo = build.cargo(&compiler, Mode::Librustc, host, \"doc\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/Cargo.toml\"))\n          .arg(\"--features\").arg(build.rustc_features());\n@@ -143,7 +142,7 @@ pub fn rustc(build: &Build, stage: u32, host: &str, out: &Path) {\n pub fn error_index(build: &Build, stage: u32, host: &str, out: &Path) {\n     println!(\"Documenting stage{} error index ({})\", stage, host);\n     let compiler = Compiler::new(stage, host);\n-    let mut index = Command::new(build.tool(&compiler, \"error_index_generator\"));\n+    let mut index = build.tool_cmd(&compiler, \"error_index_generator\");\n     index.arg(\"html\");\n     index.arg(out.join(\"error-index.html\"));\n "}, {"sha": "39bd74c78ff2a9dfb85f82fbc34bd1bec9961e4a", "filename": "src/bootstrap/build/mod.rs", "status": "modified", "additions": 52, "deletions": 71, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Fbootstrap%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Fbootstrap%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fmod.rs?ref=34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "patch": "@@ -152,19 +152,17 @@ impl Build {\n                 CompilerRt { _dummy } => {\n                     native::compiler_rt(self, target.target);\n                 }\n-                Libstd { stage, compiler } => {\n-                    compile::std(self, stage, target.target, &compiler);\n+                Libstd { compiler } => {\n+                    compile::std(self, target.target, &compiler);\n                 }\n-                Librustc { stage, compiler } => {\n-                    compile::rustc(self, stage, target.target, &compiler);\n+                Librustc { compiler } => {\n+                    compile::rustc(self, target.target, &compiler);\n                 }\n-                LibstdLink { stage, compiler, host } => {\n-                    compile::std_link(self, stage, target.target,\n-                                      &compiler, host);\n+                LibstdLink { compiler, host } => {\n+                    compile::std_link(self, target.target, &compiler, host);\n                 }\n-                LibrustcLink { stage, compiler, host } => {\n-                    compile::rustc_link(self, stage, target.target,\n-                                        &compiler, host);\n+                LibrustcLink { compiler, host } => {\n+                    compile::rustc_link(self, target.target, &compiler, host);\n                 }\n                 Rustc { stage: 0 } => {\n                     // nothing to do...\n@@ -261,58 +259,52 @@ impl Build {\n     /// This will create a `Command` that represents a pending execution of\n     /// Cargo for the specified stage, whether or not the standard library is\n     /// being built, and using the specified compiler targeting `target`.\n-    // FIXME: aren't stage/compiler duplicated?\n     fn cargo(&self,\n-             stage: u32,\n              compiler: &Compiler,\n              mode: Mode,\n-             target: Option<&str>,\n+             target: &str,\n              cmd: &str) -> Command {\n         let mut cargo = Command::new(&self.cargo);\n-        let host = compiler.host;\n-        let out_dir = self.stage_out(stage, host, mode);\n+        let out_dir = self.stage_out(compiler, mode);\n         cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n              .arg(cmd)\n-             .arg(\"-j\").arg(self.jobs().to_string());\n+             .arg(\"-j\").arg(self.jobs().to_string())\n+             .arg(\"--target\").arg(target);\n \n         // Customize the compiler we're running. Specify the compiler to cargo\n         // as our shim and then pass it some various options used to configure\n         // how the actual compiler itself is called.\n         cargo.env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n              .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n-             .env(\"RUSTC_STAGE\", self.stage_arg(stage, compiler).to_string())\n+             .env(\"RUSTC_STAGE\", compiler.stage.to_string())\n              .env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n              .env(\"RUSTC_CODEGEN_UNITS\",\n                   self.config.rust_codegen_units.to_string())\n              .env(\"RUSTC_DEBUG_ASSERTIONS\",\n                   self.config.rust_debug_assertions.to_string())\n              .env(\"RUSTC_SNAPSHOT\", &self.rustc)\n-             .env(\"RUSTC_SYSROOT\", self.sysroot(stage, host))\n+             .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n              .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir())\n              .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n              .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n-             .env(\"RUSTDOC_REAL\", self.rustdoc(compiler));\n-\n-        if let Some(target) = target {\n-             cargo.env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n-             cargo.arg(\"--target\").arg(target);\n-\n-            // Specify some various options for build scripts used throughout\n-            // the build.\n-            //\n-            // FIXME: the guard against msvc shouldn't need to be here\n-            if !target.contains(\"msvc\") {\n-                cargo.env(format!(\"CC_{}\", target), self.cc(target))\n-                     .env(format!(\"AR_{}\", target), self.ar(target))\n-                     .env(format!(\"CFLAGS_{}\", target), self.cflags(target));\n-            }\n-\n-            // Environment variables *required* needed throughout the build\n-            //\n-            // FIXME: should update code to not require this env vars\n-            cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n+             .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n+             .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n+\n+        // Specify some various options for build scripts used throughout\n+        // the build.\n+        //\n+        // FIXME: the guard against msvc shouldn't need to be here\n+        if !target.contains(\"msvc\") {\n+            cargo.env(format!(\"CC_{}\", target), self.cc(target))\n+                 .env(format!(\"AR_{}\", target), self.ar(target))\n+                 .env(format!(\"CFLAGS_{}\", target), self.cflags(target));\n         }\n \n+        // Environment variables *required* needed throughout the build\n+        //\n+        // FIXME: should update code to not require this env vars\n+        cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n+\n         if self.config.verbose || self.flags.verbose {\n             cargo.arg(\"-v\");\n         }\n@@ -328,50 +320,37 @@ impl Build {\n         if compiler.is_snapshot(self) {\n             self.rustc.clone()\n         } else {\n-            self.sysroot(compiler.stage, compiler.host).join(\"bin\")\n-                .join(exe(\"rustc\", compiler.host))\n+            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", compiler.host))\n         }\n     }\n \n     /// Get the specified tool built by the specified compiler\n     fn tool(&self, compiler: &Compiler, tool: &str) -> PathBuf {\n-        self.stage_out(compiler.stage, compiler.host, Mode::Tool)\n-            .join(self.cargo_dir())\n+        self.cargo_out(compiler, Mode::Tool, compiler.host)\n             .join(exe(tool, compiler.host))\n     }\n \n     /// Get the `rustdoc` executable next to the specified compiler\n     fn rustdoc(&self, compiler: &Compiler) -> PathBuf {\n-        let root = if compiler.is_snapshot(self) {\n-            let mut rustdoc = self.rustc.clone();\n-            rustdoc.pop();\n-            rustdoc\n-        } else {\n-            let (stage, host) = (compiler.stage, compiler.host);\n-            self.cargo_out(stage - 1, host, Mode::Librustc, host)\n-        };\n-        root.join(exe(\"rustdoc\", compiler.host))\n+        let mut rustdoc = self.compiler_path(compiler);\n+        rustdoc.pop();\n+        rustdoc.push(exe(\"rustdoc\", compiler.host));\n+        return rustdoc\n     }\n \n     /// Get a `Command` which is ready to run `tool` in `stage` built for\n     /// `host`.\n-    #[allow(dead_code)] // this will be used soon\n     fn tool_cmd(&self, compiler: &Compiler, tool: &str) -> Command {\n         let mut cmd = Command::new(self.tool(&compiler, tool));\n         let host = compiler.host;\n-        let stage = compiler.stage;\n         let paths = vec![\n-            self.cargo_out(stage, host, Mode::Libstd, host).join(\"deps\"),\n-            self.cargo_out(stage, host, Mode::Librustc, host).join(\"deps\"),\n+            self.cargo_out(compiler, Mode::Libstd, host).join(\"deps\"),\n+            self.cargo_out(compiler, Mode::Librustc, host).join(\"deps\"),\n         ];\n         add_lib_path(paths, &mut cmd);\n         return cmd\n     }\n \n-    fn stage_arg(&self, stage: u32, compiler: &Compiler) -> u32 {\n-        if stage == 0 && compiler.host != self.config.build {1} else {stage}\n-    }\n-\n     /// Get the space-separated set of activated features for the standard\n     /// library.\n     fn std_features(&self) -> String {\n@@ -400,37 +379,40 @@ impl Build {\n         if self.config.rust_optimize {\"release\"} else {\"debug\"}\n     }\n \n-    fn sysroot(&self, stage: u32, host: &str) -> PathBuf {\n-        if stage == 0 {\n-            self.stage_out(stage, host, Mode::Librustc)\n+    fn sysroot(&self, compiler: &Compiler) -> PathBuf {\n+        if compiler.stage == 0 {\n+            self.out.join(compiler.host).join(\"stage0-sysroot\")\n         } else {\n-            self.out.join(host).join(format!(\"stage{}\", stage))\n+            self.out.join(compiler.host).join(format!(\"stage{}\", compiler.stage))\n         }\n     }\n \n-    fn sysroot_libdir(&self, stage: u32, host: &str, target: &str) -> PathBuf {\n-        self.sysroot(stage, host).join(\"lib\").join(\"rustlib\")\n+    fn sysroot_libdir(&self, compiler: &Compiler, target: &str) -> PathBuf {\n+        self.sysroot(compiler).join(\"lib\").join(\"rustlib\")\n             .join(target).join(\"lib\")\n     }\n \n     /// Returns the root directory for all output generated in a particular\n     /// stage when running with a particular host compiler.\n     ///\n     /// The mode indicates what the root directory is for.\n-    fn stage_out(&self, stage: u32, host: &str, mode: Mode) -> PathBuf {\n+    fn stage_out(&self, compiler: &Compiler, mode: Mode) -> PathBuf {\n         let suffix = match mode {\n             Mode::Libstd => \"-std\",\n             _ => \"-rustc\",\n         };\n-        self.out.join(host).join(format!(\"stage{}{}\", stage, suffix))\n+        self.out.join(compiler.host)\n+                .join(format!(\"stage{}{}\", compiler.stage, suffix))\n     }\n \n     /// Returns the root output directory for all Cargo output in a given stage,\n     /// running a particular comipler, wehther or not we're building the\n     /// standard library, and targeting the specified architecture.\n-    fn cargo_out(&self, stage: u32, host: &str, mode: Mode,\n+    fn cargo_out(&self,\n+                 compiler: &Compiler,\n+                 mode: Mode,\n                  target: &str) -> PathBuf {\n-        self.stage_out(stage, host, mode).join(target).join(self.cargo_dir())\n+        self.stage_out(compiler, mode).join(target).join(self.cargo_dir())\n     }\n \n     /// Root output directory for LLVM compiled for `target`\n@@ -456,8 +438,7 @@ impl Build {\n         if compiler.is_snapshot(self) {\n             self.rustc_snapshot_libdir()\n         } else {\n-            self.sysroot(compiler.stage, compiler.host)\n-                .join(libdir(compiler.host))\n+            self.sysroot(compiler).join(libdir(compiler.host))\n         }\n     }\n "}, {"sha": "dfac074e3cd75ea1cab2cf34e6e8780a86fc72f1", "filename": "src/bootstrap/build/step.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Fbootstrap%2Fbuild%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Fbootstrap%2Fbuild%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fstep.rs?ref=34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "patch": "@@ -29,18 +29,16 @@ macro_rules! targets {\n             // and one for the compiler itself. These are parameterized over the\n             // stage output they're going to be placed in along with the\n             // compiler which is producing the copy of libstd or librustc\n-            (libstd, Libstd { stage: u32, compiler: Compiler<'a> }),\n-            (librustc, Librustc { stage: u32, compiler: Compiler<'a> }),\n+            (libstd, Libstd { compiler: Compiler<'a> }),\n+            (librustc, Librustc { compiler: Compiler<'a> }),\n \n             // Links the standard library/librustc produced by the compiler\n             // provided into the host's directory also provided.\n             (libstd_link, LibstdLink {\n-                stage: u32,\n                 compiler: Compiler<'a>,\n                 host: &'a str\n             }),\n             (librustc_link, LibrustcLink {\n-                stage: u32,\n                 compiler: Compiler<'a>,\n                 host: &'a str\n             }),\n@@ -144,10 +142,9 @@ fn top_level(build: &Build) -> Vec<Step> {\n             }\n             let host = t.target(host);\n             if host.target == build.config.build {\n-                targets.push(host.librustc(stage, host.compiler(stage)));\n+                targets.push(host.librustc(host.compiler(stage)));\n             } else {\n-                targets.push(host.librustc_link(stage, t.compiler(stage),\n-                                                host.target));\n+                targets.push(host.librustc_link(t.compiler(stage), host.target));\n             }\n             for target in build.config.target.iter() {\n                 if !build.flags.target.contains(target) {\n@@ -156,11 +153,10 @@ fn top_level(build: &Build) -> Vec<Step> {\n \n                 if host.target == build.config.build {\n                     targets.push(host.target(target)\n-                                     .libstd(stage, host.compiler(stage)));\n+                                     .libstd(host.compiler(stage)));\n                 } else {\n                     targets.push(host.target(target)\n-                                     .libstd_link(stage, t.compiler(stage),\n-                                                  host.target));\n+                                     .libstd_link(t.compiler(stage), host.target));\n                 }\n             }\n         }\n@@ -238,29 +234,29 @@ impl<'a> Step<'a> {\n             }\n             Source::Rustc { stage } => {\n                 let compiler = Compiler::new(stage - 1, &build.config.build);\n-                vec![self.librustc(stage - 1, compiler)]\n+                vec![self.librustc(compiler)]\n             }\n-            Source::Librustc { stage, compiler } => {\n-                vec![self.libstd(stage, compiler), self.llvm(())]\n+            Source::Librustc { compiler } => {\n+                vec![self.libstd(compiler), self.llvm(())]\n             }\n-            Source::Libstd { stage: _, compiler } => {\n+            Source::Libstd { compiler } => {\n                 vec![self.compiler_rt(()),\n                      self.rustc(compiler.stage).target(compiler.host)]\n             }\n-            Source::LibrustcLink { stage, compiler, host } => {\n-                vec![self.librustc(stage, compiler),\n-                     self.libstd_link(stage, compiler, host)]\n+            Source::LibrustcLink { compiler, host } => {\n+                vec![self.librustc(compiler),\n+                     self.libstd_link(compiler, host)]\n             }\n-            Source::LibstdLink { stage, compiler, host } => {\n-                vec![self.libstd(stage, compiler),\n-                     self.target(host).rustc(stage)]\n+            Source::LibstdLink { compiler, host } => {\n+                vec![self.libstd(compiler),\n+                     self.target(host).rustc(compiler.stage)]\n             }\n             Source::CompilerRt { _dummy } => {\n                 vec![self.llvm(()).target(&build.config.build)]\n             }\n             Source::Llvm { _dummy } => Vec::new(),\n             Source::DocStd { stage } => {\n-                vec![self.libstd(stage, self.compiler(stage))]\n+                vec![self.libstd(self.compiler(stage))]\n             }\n             Source::DocBook { stage } |\n             Source::DocNomicon { stage } |\n@@ -290,11 +286,11 @@ impl<'a> Step<'a> {\n             }\n \n             Source::ToolLinkchecker { stage } => {\n-                vec![self.libstd(stage, self.compiler(stage))]\n+                vec![self.libstd(self.compiler(stage))]\n             }\n             Source::ToolErrorIndex { stage } |\n             Source::ToolRustbook { stage } => {\n-                vec![self.librustc(stage, self.compiler(stage))]\n+                vec![self.librustc(self.compiler(stage))]\n             }\n         }\n     }"}, {"sha": "dcfb518ba793815527411421cafe914845875474", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "patch": "@@ -47,14 +47,20 @@ fn main() {\n     // the host platform. This only really works if the host LLVM and target\n     // LLVM are compiled the same way, but for us that's typically the case.\n     //\n-    // We detect this cross compiling situation by asking llvm-config what it's\n-    // host-target is. If that's not the TARGET, then we're cross compiling.\n-    // This generally just means that we can't trust all the output of\n-    // llvm-config becaues it might be targeted for the host rather than the\n-    // target.\n+    // We *want* detect this cross compiling situation by asking llvm-config\n+    // what it's host-target is. If that's not the TARGET, then we're cross\n+    // compiling. Unfortunately `llvm-config` seems either be buggy, or we're\n+    // misconfiguring it, because the `i686-pc-windows-gnu` build of LLVM will\n+    // report itself with a `--host-target` of `x86_64-pc-windows-gnu`. This\n+    // tricks us into thinking we're doing a cross build when we aren't, so\n+    // havoc ensues.\n+    //\n+    // In any case, if we're cross compiling, this generally just means that we\n+    // can't trust all the output of llvm-config becaues it might be targeted\n+    // for the host rather than the target. As a result a bunch of blocks below\n+    // are gated on `if !is_crossed`\n     let target = env::var(\"TARGET\").unwrap();\n-    let host = output(Command::new(&llvm_config).arg(\"--host-target\"));\n-    let host = host.trim();\n+    let host = env::var(\"HOST\").unwrap();\n     let is_crossed = target != host;\n \n     let optional_components = [\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\","}, {"sha": "778380d935c8d31fc08f2afe087c37cf7cd50398", "filename": "src/nightlies.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Fnightlies.txt", "raw_url": "https://github.com/rust-lang/rust/raw/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Fnightlies.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnightlies.txt?ref=34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "patch": "@@ -1,2 +1,2 @@\n rustc: 2016-02-17\n-cargo: 2016-01-21\n+cargo: 2016-03-11"}, {"sha": "0e7537a9cbd04b37b53c226cd4c2d7830084f13d", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "patch": "@@ -349,7 +349,6 @@ name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n  \"getopts 0.0.0\",\n- \"serialize 0.0.0\",\n  \"term 0.0.0\",\n ]\n "}, {"sha": "19037a2c4d7f2b5076085ac0e7d4a17a31ea2131", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=34b95a3c6a2a56d76bbd8ae19f318c03a2e5041d", "patch": "@@ -76,29 +76,28 @@ fn check(root: &Path, file: &Path, base: &Url, errors: &mut bool) {\n \n     // Unfortunately we're not 100% full of valid links today to we need a few\n     // whitelists to get this past `make check` today.\n-    if let Some(path) = pretty_file.to_str() {\n-        // FIXME(#32129)\n-        if path == \"std/string/struct.String.html\" {\n-            return\n-        }\n-        // FIXME(#32130)\n-        if path.contains(\"btree_set/struct.BTreeSet.html\") ||\n-           path == \"collections/struct.BTreeSet.html\" {\n-            return\n-        }\n-        // FIXME(#31948)\n-        if path.contains(\"ParseFloatError\") {\n-            return\n-        }\n+    // FIXME(#32129)\n+    if file.ends_with(\"std/string/struct.String.html\") {\n+        return\n+    }\n+    // FIXME(#32130)\n+    if file.ends_with(\"btree_set/struct.BTreeSet.html\") ||\n+       file.ends_with(\"collections/struct.BTreeSet.html\") {\n+        return\n+    }\n+\n+    if file.ends_with(\"std/sys/ext/index.html\") {\n+        return\n+    }\n \n-        // currently\n-        if path == \"std/sys/ext/index.html\" {\n+    if let Some(file) = file.to_str() {\n+        // FIXME(#31948)\n+        if file.contains(\"ParseFloatError\") {\n             return\n         }\n-\n         // weird reexports, but this module is on its way out, so chalk it up to\n         // \"rustdoc weirdness\" and move on from there\n-        if path.contains(\"scoped_tls\") {\n+        if file.contains(\"scoped_tls\") {\n             return\n         }\n     }"}]}