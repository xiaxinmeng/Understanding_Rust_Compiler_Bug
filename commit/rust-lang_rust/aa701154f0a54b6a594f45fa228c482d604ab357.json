{"sha": "aa701154f0a54b6a594f45fa228c482d604ab357", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNzAxMTU0ZjBhNTRiNmE1OTRmNDVmYTIyOGM0ODJkNjA0YWIzNTc=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-10-10T19:56:17Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-10-18T15:48:18Z"}, "message": "Extend closure special-casing for generators.\n\nThis commit extends existing special-casing of closures to highlight the\nuse of variables within generators that are causing the generator to\nborrow them.", "tree": {"sha": "531ffb017a95ae97e4ac39bc952f520a3cd939a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/531ffb017a95ae97e4ac39bc952f520a3cd939a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa701154f0a54b6a594f45fa228c482d604ab357", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlvIq0IACgkQAXYLT59T\n8VQ7jw/+JwN17AjzxUA2G+iqNqRTUuRUxPjsvK4HsfRVFHUd8Jg6bTA5eQWyYM/X\nh7yVK0Rhsja8MJB6Eps02Ke4h/BSFO6jSry1Ug9PGBMeXgBm50NLxiX+SMew2Pxp\n1Xn2hlADK8GzCXqzDHBwfieUFfdWf86pqJDS6sVSb5gEAcYrQ51vfv+i7o2cQcbo\nKkkTJTDpVYlsPBuBZCJy8AHkdv5OUQjC9XEcknIbXYXYrgIP/x008FS6noUR0P7s\n2/vvx3YW9H4eaEmdJv+LVNJX1CC3Hm8+U6qCBauwn+Sgow49A4suNnjSNHqunKP2\nw85M+w7zR/Gs6CsKt6u1ID4cwCqxYF8ldZCVsGjG2bQXIDOYtbB8S6EccX5aYEZH\n+2Qo7mZjO2W+D49Phsqq0PSENA9F4274DtM8GHOunJYlXWl0WrmrDgFN4/P4XhOU\nydzwC7xzwz9ZIGzZTXuEUfw0Fq+xmDS30675v4lxSSTH42+mdUvpG1pu2w1BEtYZ\nPH+oV2NfOgJq3W8JCpm7L+W/35DXmLuNXSctfp4umLuKra2ftfuFrIJUIqXMCP9Z\njF7gQXR4Pbb9BUEVWgL8QhE8bKoSfBYXh5CTD9eEwrprn0endTU2JUJ9Qgk2OXjA\njpl3htvHj/O6TPf1GdqxOB5qm6T9O8/pFLPcaDog/OhmuJTns1Q=\n=7MwB\n-----END PGP SIGNATURE-----", "payload": "tree 531ffb017a95ae97e4ac39bc952f520a3cd939a5\nparent 121320d5236b255049ef178669b5a279389cd1e5\nauthor David Wood <david@davidtw.co> 1539201377 +0200\ncommitter David Wood <david@davidtw.co> 1539877698 +0200\n\nExtend closure special-casing for generators.\n\nThis commit extends existing special-casing of closures to highlight the\nuse of variables within generators that are causing the generator to\nborrow them.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa701154f0a54b6a594f45fa228c482d604ab357", "html_url": "https://github.com/rust-lang/rust/commit/aa701154f0a54b6a594f45fa228c482d604ab357", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa701154f0a54b6a594f45fa228c482d604ab357/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "121320d5236b255049ef178669b5a279389cd1e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/121320d5236b255049ef178669b5a279389cd1e5", "html_url": "https://github.com/rust-lang/rust/commit/121320d5236b255049ef178669b5a279389cd1e5"}], "stats": {"total": 383, "additions": 228, "deletions": 155}, "files": [{"sha": "d9b64527700fccf3b232d7df8c401131d9bbd69b", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=aa701154f0a54b6a594f45fa228c482d604ab357", "patch": "@@ -609,12 +609,12 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         new_loan.span, &nl, old_loan.span, previous_end_span, Origin::Ast),\n                 (ty::UniqueImmBorrow, _) =>\n                     self.bccx.cannot_uniquely_borrow_by_one_closure(\n-                        new_loan.span, &nl, &new_loan_msg,\n+                        new_loan.span, \"closure\", &nl, &new_loan_msg,\n                         old_loan.span, &ol_pronoun, &old_loan_msg, previous_end_span, Origin::Ast),\n                 (_, ty::UniqueImmBorrow) => {\n                     let new_loan_str = &new_loan.kind.to_user_str();\n                     self.bccx.cannot_reborrow_already_uniquely_borrowed(\n-                        new_loan.span, &nl, &new_loan_msg, new_loan_str,\n+                        new_loan.span, \"closure\", &nl, &new_loan_msg, new_loan_str,\n                         old_loan.span, &old_loan_msg, previous_end_span, Origin::Ast)\n                 }\n                 (..) =>"}, {"sha": "99077ce8b09be04572c5669b4a5455096717d1c6", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 177, "deletions": 101, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=aa701154f0a54b6a594f45fa228c482d604ab357", "patch": "@@ -103,7 +103,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             use_spans.var_span_label(\n                 &mut err,\n-                format!(\"{} occurs due to use in closure\", desired_action.as_noun()),\n+                format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n             );\n \n             err.buffer(&mut self.errors_buffer);\n@@ -161,13 +161,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     );\n                 } else {\n                     err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n-                    move_spans.var_span_label(&mut err, \"variable moved due to use in closure\");\n+                    move_spans.var_span_label(\n+                        &mut err,\n+                        format!(\"variable moved due to use{}\", move_spans.describe()),\n+                    );\n                 };\n             }\n \n             use_spans.var_span_label(\n                 &mut err,\n-                format!(\"{} occurs due to use in closure\", desired_action.as_noun()),\n+                format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n             );\n \n             if !is_loop_move {\n@@ -226,9 +229,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn report_move_out_while_borrowed(\n         &mut self,\n         context: Context,\n-        (place, _span): (&Place<'tcx>, Span),\n+        (place, span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n+        debug!(\n+            \"report_move_out_while_borrowed: context={:?} place={:?} span={:?} borrow={:?}\",\n+            context, place, span, borrow\n+        );\n         let tcx = self.infcx.tcx;\n         let value_msg = match self.describe_place(place) {\n             Some(name) => format!(\"`{}`\", name),\n@@ -253,9 +260,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n         err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n \n-        borrow_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n+        borrow_spans.var_span_label(\n+            &mut err,\n+            format!(\"borrow occurs due to use{}\", borrow_spans.describe())\n+        );\n \n-        move_spans.var_span_label(&mut err, \"move occurs due to use in closure\");\n+        move_spans.var_span_label(\n+            &mut err,\n+            format!(\"move occurs due to use{}\", move_spans.describe())\n+        );\n \n         self.explain_why_borrow_contains_point(context, borrow, None)\n             .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\");\n@@ -291,7 +304,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let place = &borrow.borrowed_place;\n             let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n \n-            format!(\"borrow occurs due to use of `{}` in closure\", desc_place)\n+            format!(\"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe())\n         });\n \n         self.explain_why_borrow_contains_point(context, borrow, None)\n@@ -312,6 +325,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let borrow_spans = self.borrow_spans(span, context.loc);\n         let span = borrow_spans.args_or_use();\n \n+        let container_name = if issued_spans.for_generator() || borrow_spans.for_generator() {\n+            \"generator\"\n+        } else {\n+            \"closure\"\n+        };\n+\n         let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n         let tcx = self.infcx.tcx;\n \n@@ -392,7 +411,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n                 borrow_spans.var_span_label(\n                     &mut err,\n-                    format!(\"borrow occurs due to use of `{}` in closure\", desc_place),\n+                    format!(\n+                        \"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe()\n+                    ),\n                 );\n                 err.buffer(&mut self.errors_buffer);\n \n@@ -403,6 +424,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 first_borrow_desc = \"first \";\n                 tcx.cannot_uniquely_borrow_by_one_closure(\n                     span,\n+                    container_name,\n                     &desc_place,\n                     \"\",\n                     issued_span,\n@@ -417,6 +439,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 first_borrow_desc = \"first \";\n                 tcx.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n+                    container_name,\n                     &desc_place,\n                     \"\",\n                     lft,\n@@ -431,6 +454,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 first_borrow_desc = \"first \";\n                 tcx.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n+                    container_name,\n                     &desc_place,\n                     \"\",\n                     lft,\n@@ -456,24 +480,26 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if issued_spans == borrow_spans {\n             borrow_spans.var_span_label(\n                 &mut err,\n-                format!(\"borrows occur due to use of `{}` in closure\", desc_place),\n+                format!(\"borrows occur due to use of `{}`{}\", desc_place, borrow_spans.describe()),\n             );\n         } else {\n             let borrow_place = &issued_borrow.borrowed_place;\n             let borrow_place_desc = self.describe_place(borrow_place).unwrap_or(\"_\".to_owned());\n             issued_spans.var_span_label(\n                 &mut err,\n                 format!(\n-                    \"first borrow occurs due to use of `{}` in closure\",\n-                    borrow_place_desc\n+                    \"first borrow occurs due to use of `{}`{}\",\n+                    borrow_place_desc,\n+                    issued_spans.describe(),\n                 ),\n             );\n \n             borrow_spans.var_span_label(\n                 &mut err,\n                 format!(\n-                    \"second borrow occurs due to use of `{}` in closure\",\n-                    desc_place\n+                    \"second borrow occurs due to use of `{}`{}\",\n+                    desc_place,\n+                    borrow_spans.describe(),\n                 ),\n             );\n         }\n@@ -643,7 +669,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 format!(\"`{}` dropped here while still borrowed\", name),\n             );\n \n-            borrow_spans.args_span_label(&mut err, \"value captured here\");\n+            let within = if borrow_spans.for_generator() {\n+                \" by generator\"\n+            } else {\n+                \"\"\n+            };\n+\n+            borrow_spans.args_span_label(\n+                &mut err,\n+                format!(\"value captured here{}\", within),\n+            );\n \n             explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\");\n         }\n@@ -774,7 +809,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n         explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\");\n \n-        borrow_spans.args_span_label(&mut err, \"value captured here\");\n+        let within = if borrow_spans.for_generator() {\n+            \" by generator\"\n+        } else {\n+            \"\"\n+        };\n+\n+        borrow_spans.args_span_label(\n+            &mut err,\n+            format!(\"value captured here{}\", within),\n+        );\n \n         err\n     }\n@@ -906,7 +950,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             )\n         };\n \n-        loan_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n+        loan_spans.var_span_label(\n+            &mut err,\n+            format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n+        );\n \n         self.explain_why_borrow_contains_point(context, loan, None)\n             .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\");\n@@ -1805,6 +1852,8 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n pub(super) enum UseSpans {\n     // The access is caused by capturing a variable for a closure.\n     ClosureUse {\n+        // This is true if the captured variable was from a generator.\n+        is_generator: bool,\n         // The span of the args of the closure, including the `move` keyword if\n         // it's present.\n         args_span: Span,\n@@ -1845,10 +1894,31 @@ impl UseSpans {\n         }\n     }\n \n-    pub(super) fn for_closure(self) -> bool {\n-        match self {\n-            UseSpans::ClosureUse { .. } => true,\n-            UseSpans::OtherUse(_) => false,\n+    /// Return `false` if this place is not used in a closure.\n+    fn for_closure(&self) -> bool {\n+        match *self {\n+            UseSpans::ClosureUse { is_generator, .. } => !is_generator,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Return `false` if this place is not used in a generator.\n+    fn for_generator(&self) -> bool {\n+        match *self {\n+            UseSpans::ClosureUse { is_generator, .. } => is_generator,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Describe the span associated with a use of a place.\n+    fn describe(&self) -> String {\n+        match *self {\n+            UseSpans::ClosureUse { is_generator, .. } => if is_generator {\n+                \" in generator\".to_string()\n+            } else {\n+                \" in closure\".to_string()\n+            },\n+            _ => \"\".to_string(),\n         }\n     }\n \n@@ -1871,53 +1941,37 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         location: Location,\n     ) -> UseSpans {\n         use self::UseSpans::*;\n-        use rustc::hir::ExprKind::Closure;\n-        use rustc::mir::AggregateKind;\n \n-        let stmt = match self.mir[location.block]\n-            .statements\n-            .get(location.statement_index)\n-        {\n+        let stmt = match self.mir[location.block].statements.get(location.statement_index) {\n             Some(stmt) => stmt,\n             None => return OtherUse(self.mir.source_info(location).span),\n         };\n \n-        if let StatementKind::Assign(_, box Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n-            if let AggregateKind::Closure(def_id, _) = **kind {\n-                debug!(\"find_closure_move_span: found closure {:?}\", places);\n+        debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n+        if let  StatementKind::Assign(\n+            _,\n+            box Rvalue::Aggregate(ref kind, ref places)\n+        ) = stmt.kind {\n+            let (def_id, is_generator) = match kind {\n+                box AggregateKind::Closure(def_id, _) => (def_id, false),\n+                box AggregateKind::Generator(def_id, _, _) => (def_id, true),\n+                _ => return OtherUse(stmt.source_info.span),\n+            };\n \n-                if let Some(node_id) = self.infcx.tcx.hir.as_local_node_id(def_id) {\n-                    if let Closure(_, _, _, args_span, _) =\n-                        self.infcx.tcx.hir.expect_expr(node_id).node\n-                    {\n-                        if let Some(var_span) = self.infcx.tcx.with_freevars(node_id, |freevars| {\n-                            for (v, place) in freevars.iter().zip(places) {\n-                                match place {\n-                                    Operand::Copy(place) | Operand::Move(place)\n-                                        if moved_place == place =>\n-                                    {\n-                                        debug!(\n-                                            \"find_closure_move_span: found captured local {:?}\",\n-                                            place\n-                                        );\n-                                        return Some(v.span);\n-                                    }\n-                                    _ => {}\n-                                }\n-                            }\n-                            None\n-                        }) {\n-                            return ClosureUse {\n-                                args_span,\n-                                var_span,\n-                            };\n-                        }\n-                    }\n-                }\n+            debug!(\n+                \"move_spans: def_id={:?} is_generator={:?} places={:?}\",\n+                def_id, is_generator, places\n+            );\n+            if let Some((args_span, var_span)) = self.closure_span(*def_id, moved_place, places) {\n+                return ClosureUse {\n+                    is_generator,\n+                    args_span,\n+                    var_span,\n+                };\n             }\n         }\n \n-        return OtherUse(stmt.source_info.span);\n+        OtherUse(stmt.source_info.span)\n     }\n \n     /// Finds the span of arguments of a closure (within `maybe_closure_span`)\n@@ -1926,9 +1980,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// and originating from `maybe_closure_span`.\n     pub(super) fn borrow_spans(&self, use_span: Span, location: Location) -> UseSpans {\n         use self::UseSpans::*;\n-        use rustc::hir::ExprKind::Closure;\n+        debug!(\"borrow_spans: use_span={:?} location={:?}\", use_span, location);\n \n-        let local = match self.mir[location.block]\n+        let target = match self.mir[location.block]\n             .statements\n             .get(location.statement_index)\n         {\n@@ -1939,54 +1993,35 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => return OtherUse(use_span),\n         };\n \n-        if self.mir.local_kind(local) != LocalKind::Temp {\n+        if self.mir.local_kind(target) != LocalKind::Temp {\n             // operands are always temporaries.\n             return OtherUse(use_span);\n         }\n \n         for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n-            if let StatementKind::Assign(_, box Rvalue::Aggregate(ref kind, ref places)) = stmt.kind\n-            {\n-                if let AggregateKind::Closure(def_id, _) = **kind {\n-                    debug!(\"find_closure_borrow_span: found closure {:?}\", places);\n-\n-                    return if let Some(node_id) = self.infcx.tcx.hir.as_local_node_id(def_id) {\n-                        let args_span = if let Closure(_, _, _, span, _) =\n-                            self.infcx.tcx.hir.expect_expr(node_id).node\n-                        {\n-                            span\n-                        } else {\n-                            return OtherUse(use_span);\n-                        };\n+            if let StatementKind::Assign(\n+                _, box Rvalue::Aggregate(ref kind, ref places)\n+            ) = stmt.kind {\n+                let (def_id, is_generator) = match kind {\n+                    box AggregateKind::Closure(def_id, _) => (def_id, false),\n+                    box AggregateKind::Generator(def_id, _, _) => (def_id, true),\n+                    _ => continue,\n+                };\n \n-                        self.infcx\n-                            .tcx\n-                            .with_freevars(node_id, |freevars| {\n-                                for (v, place) in freevars.iter().zip(places) {\n-                                    match *place {\n-                                        Operand::Copy(Place::Local(l))\n-                                        | Operand::Move(Place::Local(l)) if local == l =>\n-                                        {\n-                                            debug!(\n-                                                \"find_closure_borrow_span: found captured local \\\n-                                                 {:?}\",\n-                                                l\n-                                            );\n-                                            return Some(v.span);\n-                                        }\n-                                        _ => {}\n-                                    }\n-                                }\n-                                None\n-                            })\n-                            .map(|var_span| ClosureUse {\n-                                args_span,\n-                                var_span,\n-                            })\n-                            .unwrap_or(OtherUse(use_span))\n-                    } else {\n-                        OtherUse(use_span)\n+                debug!(\n+                    \"borrow_spans: def_id={:?} is_generator={:?} places={:?}\",\n+                    def_id, is_generator, places\n+                );\n+                if let Some((args_span, var_span)) = self.closure_span(\n+                    *def_id, &Place::Local(target), places\n+                ) {\n+                    return ClosureUse {\n+                        is_generator,\n+                        args_span,\n+                        var_span,\n                     };\n+                } else {\n+                    return OtherUse(use_span);\n                 }\n             }\n \n@@ -1998,6 +2033,47 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         OtherUse(use_span)\n     }\n \n+    /// Finds the span of a captured variable within a closure or generator.\n+    fn closure_span(\n+        &self,\n+        def_id: DefId,\n+        target_place: &Place<'tcx>,\n+        places: &Vec<Operand<'tcx>>,\n+    ) -> Option<(Span, Span)> {\n+        debug!(\n+            \"closure_span: def_id={:?} target_place={:?} places={:?}\",\n+            def_id, target_place, places\n+        );\n+        let node_id = self.infcx.tcx.hir.as_local_node_id(def_id)?;\n+        let expr = &self.infcx.tcx.hir.expect_expr(node_id).node;\n+        debug!(\"closure_span: node_id={:?} expr={:?}\", node_id, expr);\n+        if let hir::ExprKind::Closure(\n+            .., args_span, _\n+        ) = expr {\n+            let var_span = self.infcx.tcx.with_freevars(\n+                node_id,\n+                |freevars| {\n+                    for (v, place) in freevars.iter().zip(places) {\n+                        match place {\n+                            Operand::Copy(place) |\n+                            Operand::Move(place) if target_place == place => {\n+                                debug!(\"closure_span: found captured local {:?}\", place);\n+                                return Some(v.span);\n+                            },\n+                            _ => {}\n+                        }\n+                    }\n+\n+                    None\n+                },\n+            )?;\n+\n+            Some((*args_span, var_span))\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Helper to retrieve span(s) of given borrow from the current MIR\n     /// representation\n     pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData) -> UseSpans {"}, {"sha": "d5c655a3de472dd035f8851dd3ec439e6a6d8e3e", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=aa701154f0a54b6a594f45fa228c482d604ab357", "patch": "@@ -221,6 +221,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n     fn cannot_uniquely_borrow_by_one_closure(\n         self,\n         new_loan_span: Span,\n+        container_name: &str,\n         desc_new: &str,\n         opt_via: &str,\n         old_loan_span: Span,\n@@ -241,7 +242,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         );\n         err.span_label(\n             new_loan_span,\n-            format!(\"closure construction occurs here{}\", opt_via),\n+            format!(\"{} construction occurs here{}\", container_name, opt_via),\n         );\n         err.span_label(old_loan_span, format!(\"borrow occurs here{}\", old_opt_via));\n         if let Some(previous_end_span) = previous_end_span {\n@@ -253,6 +254,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n     fn cannot_reborrow_already_uniquely_borrowed(\n         self,\n         new_loan_span: Span,\n+        container_name: &str,\n         desc_new: &str,\n         opt_via: &str,\n         kind_new: &str,\n@@ -275,7 +277,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err.span_label(new_loan_span, format!(\"borrow occurs here{}\", opt_via));\n         err.span_label(\n             old_loan_span,\n-            format!(\"closure construction occurs here{}\", old_opt_via),\n+            format!(\"{} construction occurs here{}\", container_name, old_opt_via),\n         );\n         if let Some(previous_end_span) = previous_end_span {\n             err.span_label(previous_end_span, \"borrow from closure ends here\");"}, {"sha": "52b5c9d891bb3459ff4568993fd4493be187d864", "filename": "src/test/ui/generator/borrowing.nll.stderr", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.nll.stderr?ref=aa701154f0a54b6a594f45fa228c482d604ab357", "patch": "@@ -1,10 +1,11 @@\n error[E0597]: `a` does not live long enough\n-  --> $DIR/borrowing.rs:18:18\n+  --> $DIR/borrowing.rs:18:29\n    |\n LL |         unsafe { (|| yield &a).resume() }\n-   |                  ^^^^^^^^^^^^^\n-   |                  |\n-   |                  borrowed value does not live long enough\n+   |                  -----------^-\n+   |                  ||         |\n+   |                  ||         borrowed value does not live long enough\n+   |                  |value captured here by generator\n    |                  a temporary with access to the borrow is created here ...\n LL |         //~^ ERROR: `a` does not live long enough\n LL |     };\n@@ -15,18 +16,18 @@ LL |     };\n    = note: The temporary is part of an expression at the end of a block. Consider forcing this temporary to be dropped sooner, before the block's local variables are dropped. For example, you could save the expression's value in a new local variable `x` and then make `x` be the expression at the end of the block.\n \n error[E0597]: `a` does not live long enough\n-  --> $DIR/borrowing.rs:24:9\n+  --> $DIR/borrowing.rs:25:20\n    |\n-LL |       let _b = {\n-   |           -- borrow later stored here\n-LL |           let a = 3;\n-LL | /         || {\n-LL | |             yield &a\n-LL | |             //~^ ERROR: `a` does not live long enough\n-LL | |         }\n-   | |_________^ borrowed value does not live long enough\n-LL |       };\n-   |       - `a` dropped here while still borrowed\n+LL |     let _b = {\n+   |         -- borrow later stored here\n+LL |         let a = 3;\n+LL |         || {\n+   |         -- value captured here by generator\n+LL |             yield &a\n+   |                    ^ borrowed value does not live long enough\n+...\n+LL |     };\n+   |     - `a` dropped here while still borrowed\n \n error: aborting due to 2 previous errors\n "}, {"sha": "078aaf6176ab82c0756b9e13fd29fa58c45f5b07", "filename": "src/test/ui/generator/dropck.nll.stderr", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr?ref=aa701154f0a54b6a594f45fa228c482d604ab357", "patch": "@@ -13,21 +13,19 @@ LL | }\n    = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `ref_` does not live long enough\n-  --> $DIR/dropck.rs:22:11\n+  --> $DIR/dropck.rs:24:18\n    |\n-LL |       gen = || {\n-   |  ___________^\n-LL | |         // but the generator can use it to drop a `Ref<'a, i32>`.\n-LL | |         let _d = ref_.take(); //~ ERROR `ref_` does not live long enough\n-LL | |         yield;\n-LL | |     };\n-   | |_____^ borrowed value does not live long enough\n+LL |     gen = || {\n+   |           -- value captured here by generator\n+LL |         // but the generator can use it to drop a `Ref<'a, i32>`.\n+LL |         let _d = ref_.take(); //~ ERROR `ref_` does not live long enough\n+   |                  ^^^^ borrowed value does not live long enough\n ...\n-LL |   }\n-   |   -\n-   |   |\n-   |   `ref_` dropped here while still borrowed\n-   |   borrow might be used here, when `gen` is dropped and runs the destructor for generator\n+LL | }\n+   | -\n+   | |\n+   | `ref_` dropped here while still borrowed\n+   | borrow might be used here, when `gen` is dropped and runs the destructor for generator\n    |\n    = note: values in a scope are dropped in the opposite order they are defined\n "}, {"sha": "2f0a05898444c836d7ac550cf3e7e56080a5b900", "filename": "src/test/ui/generator/yield-while-iterating.nll.stderr", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.nll.stderr?ref=aa701154f0a54b6a594f45fa228c482d604ab357", "patch": "@@ -9,17 +9,15 @@ LL |             yield();\n error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n   --> $DIR/yield-while-iterating.rs:67:20\n    |\n-LL |       let mut b = || {\n-   |  _________________-\n-LL | |         for p in &mut x {\n-LL | |             yield p;\n-LL | |         }\n-LL | |     };\n-   | |_____- mutable borrow occurs here\n-LL |       println!(\"{}\", x[0]); //~ ERROR\n-   |                      ^ immutable borrow occurs here\n-LL |       b.resume();\n-   |       - mutable borrow later used here\n+LL |     let mut b = || {\n+   |                 -- mutable borrow occurs here\n+LL |         for p in &mut x {\n+   |                       - first borrow occurs due to use of `x` in generator\n+...\n+LL |     println!(\"{}\", x[0]); //~ ERROR\n+   |                    ^ immutable borrow occurs here\n+LL |     b.resume();\n+   |     - mutable borrow later used here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8dabb3c2505b637d863f0c3a549ebc5b4bb38aca", "filename": "src/test/ui/generator/yield-while-ref-reborrowed.nll.stderr", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa701154f0a54b6a594f45fa228c482d604ab357/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.nll.stderr?ref=aa701154f0a54b6a594f45fa228c482d604ab357", "patch": "@@ -1,17 +1,15 @@\n error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n   --> $DIR/yield-while-ref-reborrowed.rs:45:20\n    |\n-LL |       let mut b = || {\n-   |  _________________-\n-LL | |         let a = &mut *x;\n-LL | |         yield();\n-LL | |         println!(\"{}\", a);\n-LL | |     };\n-   | |_____- closure construction occurs here\n-LL |       println!(\"{}\", x); //~ ERROR\n-   |                      ^ borrow occurs here\n-LL |       b.resume();\n-   |       - first borrow later used here\n+LL |     let mut b = || {\n+   |                 -- generator construction occurs here\n+LL |         let a = &mut *x;\n+   |                       - first borrow occurs due to use of `x` in generator\n+...\n+LL |     println!(\"{}\", x); //~ ERROR\n+   |                    ^ borrow occurs here\n+LL |     b.resume();\n+   |     - first borrow later used here\n \n error: aborting due to previous error\n "}]}