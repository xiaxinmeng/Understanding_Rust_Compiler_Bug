{"sha": "625c518eec5779f0e8db5826ea4cf06e7c039dd9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNWM1MThlZWM1Nzc5ZjBlOGRiNTgyNmVhNGNmMDZlN2MwMzlkZDk=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-02T04:43:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T22:35:50Z"}, "message": "whitespace cleanup after rebase", "tree": {"sha": "d04e5aca56e722859e4338ba8ef89021f9aae3d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d04e5aca56e722859e4338ba8ef89021f9aae3d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/625c518eec5779f0e8db5826ea4cf06e7c039dd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/625c518eec5779f0e8db5826ea4cf06e7c039dd9", "html_url": "https://github.com/rust-lang/rust/commit/625c518eec5779f0e8db5826ea4cf06e7c039dd9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/625c518eec5779f0e8db5826ea4cf06e7c039dd9/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b712e5e1321b804220d7eef71894fa5f8151b7ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/b712e5e1321b804220d7eef71894fa5f8151b7ef", "html_url": "https://github.com/rust-lang/rust/commit/b712e5e1321b804220d7eef71894fa5f8151b7ef"}], "stats": {"total": 261, "additions": 127, "deletions": 134}, "files": [{"sha": "c13b43a660d4bab0fbc4cda6da7cd7a064a8628b", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 127, "deletions": 134, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/625c518eec5779f0e8db5826ea4cf06e7c039dd9/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/625c518eec5779f0e8db5826ea4cf06e7c039dd9/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=625c518eec5779f0e8db5826ea4cf06e7c039dd9", "patch": "@@ -9,18 +9,18 @@\n \n // crust fn pointers\n typedef void (*crust_async_op_cb)(uv_loop_t* loop, void* data,\n-                                  uv_async_t* op_handle);\n+        uv_async_t* op_handle);\n typedef void (*crust_simple_cb)(uint8_t* id_buf, void* loop_data);\n typedef void (*crust_close_cb)(uint8_t* id_buf, void* handle,\n-                                                          void* data);\n+        void* data);\n \n // data types\n #define RUST_UV_HANDLE_LEN 16\n \n struct handle_data {\n-        uint8_t id_buf[RUST_UV_HANDLE_LEN];\n-        crust_simple_cb cb;\n-        crust_close_cb close_cb;\n+    uint8_t id_buf[RUST_UV_HANDLE_LEN];\n+    crust_simple_cb cb;\n+    crust_close_cb close_cb;\n };\n \n // helpers\n@@ -37,52 +37,52 @@ current_kernel_free(void* ptr) {\n \n static handle_data*\n new_handle_data_from(uint8_t* buf, crust_simple_cb cb) {\n-        handle_data* data = (handle_data*)current_kernel_malloc(\n-                sizeof(handle_data),\n-                \"handle_data\");\n-        memcpy(data->id_buf, buf, RUST_UV_HANDLE_LEN);\n-        data->cb = cb;\n-        return data;\n+    handle_data* data = (handle_data*)current_kernel_malloc(\n+            sizeof(handle_data),\n+            \"handle_data\");\n+    memcpy(data->id_buf, buf, RUST_UV_HANDLE_LEN);\n+    data->cb = cb;\n+    return data;\n }\n \n // libuv callback impls\n static void\n native_crust_async_op_cb(uv_async_t* handle, int status) {\n     crust_async_op_cb cb = (crust_async_op_cb)handle->data;\n-        void* loop_data = handle->loop->data;\n-        cb(handle->loop, loop_data, handle);\n+    void* loop_data = handle->loop->data;\n+    cb(handle->loop, loop_data, handle);\n }\n \n static void\n native_async_cb(uv_async_t* handle, int status) {\n-        handle_data* handle_d = (handle_data*)handle->data;\n-        void* loop_data = handle->loop->data;\n-        handle_d->cb(handle_d->id_buf, loop_data);\n+    handle_data* handle_d = (handle_data*)handle->data;\n+    void* loop_data = handle->loop->data;\n+    handle_d->cb(handle_d->id_buf, loop_data);\n }\n \n static void\n native_timer_cb(uv_timer_t* handle, int status) {\n-        handle_data* handle_d = (handle_data*)handle->data;\n-        void* loop_data = handle->loop->data;\n-        handle_d->cb(handle_d->id_buf, loop_data);\n+    handle_data* handle_d = (handle_data*)handle->data;\n+    void* loop_data = handle->loop->data;\n+    handle_d->cb(handle_d->id_buf, loop_data);\n }\n \n static void\n native_close_cb(uv_handle_t* handle) {\n-        handle_data* data = (handle_data*)handle->data;\n-        data->close_cb(data->id_buf, handle, handle->loop->data);\n+    handle_data* data = (handle_data*)handle->data;\n+    data->close_cb(data->id_buf, handle, handle->loop->data);\n }\n \n static void\n native_close_op_cb(uv_handle_t* op_handle) {\n-  current_kernel_free(op_handle);\n-  // uv_run() should return after this..\n+    current_kernel_free(op_handle);\n+    // uv_run() should return after this..\n }\n \n // native fns bound in rust\n extern \"C\" void\n rust_uv_free(void* ptr) {\n-  current_kernel_free(ptr);\n+    current_kernel_free(ptr);\n }\n extern \"C\" void*\n rust_uv_loop_new() {\n@@ -117,49 +117,49 @@ rust_uv_loop_set_data(uv_loop_t* loop, void* data) {\n \n extern \"C\" void*\n rust_uv_bind_op_cb(uv_loop_t* loop, crust_async_op_cb cb) {\n-        uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n-                sizeof(uv_async_t),\n-                \"uv_async_t\");\n-        uv_async_init(loop, async, native_crust_async_op_cb);\n-        async->data = (void*)cb;\n-        // decrement the ref count, so that our async bind\n-        // doesn't count towards keeping the loop alive\n-        //uv_unref(loop);\n-        return async;\n+    uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n+            sizeof(uv_async_t),\n+            \"uv_async_t\");\n+    uv_async_init(loop, async, native_crust_async_op_cb);\n+    async->data = (void*)cb;\n+    // decrement the ref count, so that our async bind\n+    // doesn't count towards keeping the loop alive\n+    //uv_unref(loop);\n+    return async;\n }\n \n extern \"C\" void\n rust_uv_stop_op_cb(uv_handle_t* op_handle) {\n-  uv_close(op_handle, native_close_op_cb);\n+    uv_close(op_handle, native_close_op_cb);\n }\n \n extern \"C\" void\n rust_uv_run(uv_loop_t* loop) {\n-        uv_run(loop);\n+    uv_run(loop);\n }\n \n extern \"C\" void\n rust_uv_close(uv_handle_t* handle, uv_close_cb cb) {\n-\tuv_close(handle, cb);\n+    uv_close(handle, cb);\n }\n \n extern \"C\" void\n rust_uv_hilvl_close(uv_handle_t* handle, crust_close_cb cb) {\n-\thandle_data* data = (handle_data*)handle->data;\n-\tdata->close_cb = cb;\n-\tuv_close(handle, native_close_cb);\n+    handle_data* data = (handle_data*)handle->data;\n+    data->close_cb = cb;\n+    uv_close(handle, native_close_cb);\n }\n \n extern \"C\" void\n rust_uv_hilvl_close_async(uv_async_t* handle) {\n-  current_kernel_free(handle->data);\n-  current_kernel_free(handle);\n+    current_kernel_free(handle->data);\n+    current_kernel_free(handle);\n }\n \n extern \"C\" void\n rust_uv_hilvl_close_timer(uv_async_t* handle) {\n-  current_kernel_free(handle->data);\n-  current_kernel_free(handle);\n+    current_kernel_free(handle->data);\n+    current_kernel_free(handle);\n }\n \n extern \"C\" void\n@@ -169,233 +169,226 @@ rust_uv_async_send(uv_async_t* handle) {\n \n extern \"C\" int\n rust_uv_async_init(uv_loop_t* loop_handle,\n-\t\t\t\t   uv_async_t* async_handle,\n-\t\t\t\t   uv_async_cb cb) {\n-\treturn uv_async_init(loop_handle, async_handle, cb);\n+        uv_async_t* async_handle,\n+        uv_async_cb cb) {\n+    return uv_async_init(loop_handle, async_handle, cb);\n }\n \n extern \"C\" void*\n rust_uv_hilvl_async_init(uv_loop_t* loop, crust_simple_cb cb,\n-\t\t\t\t\t\t uint8_t* buf) {\n-\tuv_async_t* async = (uv_async_t*)current_kernel_malloc(\n-\t\tsizeof(uv_async_t),\n-\t\t\"uv_async_t\");\n-\tuv_async_init(loop, async, native_async_cb);\n-\thandle_data* data = new_handle_data_from(buf, cb);\n-\tasync->data = data;\n+        uint8_t* buf) {\n+    uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n+            sizeof(uv_async_t),\n+            \"uv_async_t\");\n+    uv_async_init(loop, async, native_async_cb);\n+    handle_data* data = new_handle_data_from(buf, cb);\n+    async->data = data;\n \n-        return async;\n+    return async;\n }\n \n extern \"C\" void*\n rust_uv_timer_init(uv_loop_t* loop, crust_simple_cb cb,\n-                                                 uint8_t* buf) {\n-        uv_timer_t* new_timer = (uv_timer_t*)current_kernel_malloc(\n-                sizeof(uv_timer_t),\n-                \"uv_timer_t\");\n-        uv_timer_init(loop, new_timer);\n-        handle_data* data = new_handle_data_from(buf, cb);\n-        new_timer->data = data;\n+        uint8_t* buf) {\n+    uv_timer_t* new_timer = (uv_timer_t*)current_kernel_malloc(\n+            sizeof(uv_timer_t),\n+            \"uv_timer_t\");\n+    uv_timer_init(loop, new_timer);\n+    handle_data* data = new_handle_data_from(buf, cb);\n+    new_timer->data = data;\n \n-        return new_timer;\n+    return new_timer;\n }\n \n extern \"C\" void\n rust_uv_timer_start(uv_timer_t* the_timer, uint32_t timeout,\n-                                                  uint32_t repeat) {\n-        uv_timer_start(the_timer, native_timer_cb, timeout, repeat);\n+        uint32_t repeat) {\n+    uv_timer_start(the_timer, native_timer_cb, timeout, repeat);\n }\n \n extern \"C\" void\n rust_uv_timer_stop(uv_timer_t* the_timer) {\n-\tuv_timer_stop(the_timer); \n+    uv_timer_stop(the_timer);\n }\n \n extern \"C\" int\n rust_uv_tcp_init(uv_loop_t* loop, uv_tcp_t* handle) {\n-\treturn uv_tcp_init(loop, handle);\n+    return uv_tcp_init(loop, handle);\n }\n \n extern \"C\" int\n rust_uv_tcp_connect(uv_connect_t* connect_ptr,\n-\t\t\t\t\tuv_tcp_t* tcp_ptr,\n-\t\t\t\t\tuv_connect_cb cb,\n-\t\t\t\t\tsockaddr_in* addr_ptr) {\n-\tprintf(\"inside rust_uv_tcp_connect\\n\");\n-\t// FIXME ref #2064\n-\tsockaddr_in addr = *addr_ptr;\n-\tprintf(\"before tcp_connect .. port: %d\\n\", addr.sin_port);\n-\tprintf(\"before tcp_connect.. tcp stream: %lu cb ptr: %lu\\n\",\n-\t\t   (unsigned long int)tcp_ptr, (unsigned long int)cb);\n-\tint result = uv_tcp_connect(connect_ptr, tcp_ptr, addr, cb);\n-\tprintf (\"leaving rust_uv_tcp_connect.. and result: %d\\n\",\n-\t\t\tresult);\n-\treturn result;\n+        uv_tcp_t* tcp_ptr,\n+        uv_connect_cb cb,\n+        sockaddr_in* addr_ptr) {\n+    printf(\"inside rust_uv_tcp_connect\\n\");\n+    // FIXME ref #2064\n+    sockaddr_in addr = *addr_ptr;\n+    printf(\"before tcp_connect .. port: %d\\n\", addr.sin_port);\n+    printf(\"before tcp_connect.. tcp stream: %lu cb ptr: %lu\\n\",\n+            (unsigned long int)tcp_ptr, (unsigned long int)cb);\n+    int result = uv_tcp_connect(connect_ptr, tcp_ptr, addr, cb);\n+    printf (\"leaving rust_uv_tcp_connect.. and result: %d\\n\",\n+            result);\n+    return result;\n }\n \n extern \"C\" int\n rust_uv_tcp_bind(uv_tcp_t* tcp_server, sockaddr_in* addr_ptr) {\n-\t// FIXME ref #2064\n-\tsockaddr_in addr = *addr_ptr;\n-\tprintf(\"before uv_tcp_bind .. tcp_server: %lu port: %d\\n\",\n-\t\t   (unsigned long int)tcp_server, addr.sin_port);\n-\treturn uv_tcp_bind(tcp_server, addr);\n+    // FIXME ref #2064\n+    sockaddr_in addr = *addr_ptr;\n+    printf(\"before uv_tcp_bind .. tcp_server: %lu port: %d\\n\",\n+            (unsigned long int)tcp_server, addr.sin_port);\n+    return uv_tcp_bind(tcp_server, addr);\n }\n \n extern \"C\" int\n rust_uv_listen(uv_stream_t* stream, int backlog,\n-\t\t\t\t   uv_connection_cb cb) {\n-\treturn uv_listen(stream, backlog, cb);\n+        uv_connection_cb cb) {\n+    return uv_listen(stream, backlog, cb);\n }\n \n extern \"C\" int\n rust_uv_accept(uv_stream_t* server, uv_stream_t* client) {\n-\treturn uv_accept(server, client);\n+    return uv_accept(server, client);\n }\n \n extern \"C\" size_t\n rust_uv_helper_uv_tcp_t_size() {\n-\treturn sizeof(uv_tcp_t);\n+    return sizeof(uv_tcp_t);\n }\n extern \"C\" size_t\n rust_uv_helper_uv_connect_t_size() {\n-\treturn sizeof(uv_connect_t);\n+    return sizeof(uv_connect_t);\n }\n extern \"C\" size_t\n rust_uv_helper_uv_buf_t_size() {\n-\treturn sizeof(uv_buf_t);\n+    return sizeof(uv_buf_t);\n }\n extern \"C\" size_t\n rust_uv_helper_uv_write_t_size() {\n-\treturn sizeof(uv_write_t);\n+    return sizeof(uv_write_t);\n }\n extern \"C\" size_t\n rust_uv_helper_uv_err_t_size() {\n-\treturn sizeof(uv_err_t);\n+    return sizeof(uv_err_t);\n }\n extern \"C\" size_t\n rust_uv_helper_sockaddr_in_size() {\n-\treturn sizeof(sockaddr_in);\n+    return sizeof(sockaddr_in);\n }\n extern \"C\" size_t\n rust_uv_helper_uv_async_t_size() {\n-\treturn sizeof(uv_async_t);\n+    return sizeof(uv_async_t);\n }\n \n extern \"C\" uv_stream_t*\n rust_uv_get_stream_handle_from_connect_req(uv_connect_t* connect) {\n-\treturn connect->handle;\n+    return connect->handle;\n }\n extern \"C\" uv_stream_t*\n rust_uv_get_stream_handle_from_write_req(uv_write_t* write_req) {\n-\treturn write_req->handle;\n+    return write_req->handle;\n }\n \n extern \"C\" uv_buf_t\n current_kernel_malloc_alloc_cb(uv_handle_t* handle,\n-\t\t\t\t\t\t\t   size_t suggested_size) {\n-\tchar* base_ptr = (char*)current_kernel_malloc(sizeof(char)\n-\t\t\t\t\t\t\t\t\t\t\t  * suggested_size,\n-\t\t\t\t\t\t\t\t\t\t   \"uv_buf_t_base_val\");\n-\treturn uv_buf_init(base_ptr, suggested_size);\n+        size_t suggested_size) {\n+    char* base_ptr = (char*)current_kernel_malloc(sizeof(char)\n+            * suggested_size,\n+            \"uv_buf_t_base_val\");\n+    return uv_buf_init(base_ptr, suggested_size);\n }\n \n extern \"C\" uv_buf_t\n rust_uv_buf_init(char* base, size_t len) {\n-\treturn uv_buf_init(base, len);\n+    return uv_buf_init(base, len);\n }\n \n extern \"C\" uv_loop_t*\n rust_uv_get_loop_for_uv_handle(uv_handle_t* handle) {\n-\treturn handle->loop;\n+    return handle->loop;\n }\n \n extern \"C\" void*\n rust_uv_get_data_for_uv_handle(uv_handle_t* handle) {\n-\treturn handle->data;\n+    return handle->data;\n }\n \n extern \"C\" void\n rust_uv_set_data_for_uv_handle(uv_handle_t* handle,\n-\t\t\t\t\t\t\t   void* data) {\n-\thandle->data = data;\n+        void* data) {\n+    handle->data = data;\n }\n \n extern \"C\" void*\n rust_uv_get_data_for_req(uv_req_t* req) {\n-\treturn req->data;\n+    return req->data;\n }\n \n extern \"C\" void\n rust_uv_set_data_for_req(uv_req_t* req, void* data) {\n-\treq->data = data;\n+    req->data = data;\n }\n \n extern \"C\" char*\n rust_uv_get_base_from_buf(uv_buf_t buf) {\n-\treturn buf.base;\n+    return buf.base;\n }\n \n extern \"C\" size_t\n rust_uv_get_len_from_buf(uv_buf_t buf) {\n-\treturn buf.len;\n+    return buf.len;\n }\n \n extern \"C\" uv_err_t\n rust_uv_last_error(uv_loop_t* loop) {\n-\treturn uv_last_error(loop);\n+    return uv_last_error(loop);\n }\n \n extern \"C\" const char*\n rust_uv_strerror(uv_err_t* err_ptr) {\n-\tuv_err_t err = *err_ptr;\n-\treturn uv_strerror(err);\n+    uv_err_t err = *err_ptr;\n+    return uv_strerror(err);\n }\n \n extern \"C\" const char*\n rust_uv_err_name(uv_err_t* err_ptr) {\n-\tuv_err_t err = *err_ptr;\n-\treturn uv_err_name(err);\n+    uv_err_t err = *err_ptr;\n+    return uv_err_name(err);\n }\n \n extern \"C\" int\n rust_uv_write(uv_write_t* req, uv_stream_t* handle,\n-\t\t\t  uv_buf_t* bufs, int buf_cnt,\n-\t\t\t  uv_write_cb cb) {\n-\treturn uv_write(req, handle, bufs, buf_cnt, cb);\n+        uv_buf_t* bufs, int buf_cnt,\n+        uv_write_cb cb) {\n+    return uv_write(req, handle, bufs, buf_cnt, cb);\n }\n extern \"C\" int\n rust_uv_read_start(uv_stream_t* stream, uv_alloc_cb on_alloc,\n-\t\t\t\t   uv_read_cb on_read) {\n+        uv_read_cb on_read) {\n     return uv_read_start(stream, on_alloc, on_read);\n }\n \n extern \"C\" int\n rust_uv_read_stop(uv_stream_t* stream) {\n-  return uv_read_stop(stream);\n+    return uv_read_stop(stream);\n }\n \n extern \"C\" char*\n rust_uv_malloc_buf_base_of(size_t suggested_size) {\n-\treturn (char*) current_kernel_malloc(sizeof(char)*suggested_size,\n-\t\t\t\t\t\t\t\t\t   \"uv_buf_t base\");\n+    return (char*) current_kernel_malloc(sizeof(char)*suggested_size,\n+            \"uv_buf_t base\");\n }\n extern \"C\" void\n rust_uv_free_base_of_buf(uv_buf_t buf) {\n-\tcurrent_kernel_free(buf.base);\n+    current_kernel_free(buf.base);\n }\n \n extern \"C\" struct sockaddr_in\n rust_uv_ip4_addr(const char* ip, int port) {\n-\tprintf(\"before creating addr_ptr.. ip %s port %d\\n\", ip, port);\n-\tstruct sockaddr_in addr = uv_ip4_addr(ip, port);\n-\tprintf(\"after creating .. port: %d\\n\", addr.sin_port);\n-\treturn addr;\n-}\n-\n-extern \"C\" bool\n-rust_uv_ip4_test_verify_port_val(struct sockaddr_in addr,\n-\t\t\t\t\t\t\t\t unsigned int expected) {\n-\tprintf(\"inside c++ ip4_test .. port: %u\\n\", addr.sin_port);\n-\treturn addr.sin_port == expected;\n+    printf(\"before creating addr_ptr.. ip %s port %d\\n\", ip, port);\n+    struct sockaddr_in addr = uv_ip4_addr(ip, port);\n+    printf(\"after creating .. port: %d\\n\", addr.sin_port);\n+    return addr;\n }"}]}