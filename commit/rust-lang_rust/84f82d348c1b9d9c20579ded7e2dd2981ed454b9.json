{"sha": "84f82d348c1b9d9c20579ded7e2dd2981ed454b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ZjgyZDM0OGMxYjlkOWMyMDU3OWRlZDdlMmRkMjk4MWVkNDU0Yjk=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-12-17T00:14:21Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-03-31T14:15:56Z"}, "message": "Revert explicit lifetimes", "tree": {"sha": "4b0f0ef13da4931571095c842b853ba83b67c731", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b0f0ef13da4931571095c842b853ba83b67c731"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84f82d348c1b9d9c20579ded7e2dd2981ed454b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84f82d348c1b9d9c20579ded7e2dd2981ed454b9", "html_url": "https://github.com/rust-lang/rust/commit/84f82d348c1b9d9c20579ded7e2dd2981ed454b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84f82d348c1b9d9c20579ded7e2dd2981ed454b9/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30187c81f65aa29a53ad7c24fe3b4c7bff947094", "url": "https://api.github.com/repos/rust-lang/rust/commits/30187c81f65aa29a53ad7c24fe3b4c7bff947094", "html_url": "https://github.com/rust-lang/rust/commit/30187c81f65aa29a53ad7c24fe3b4c7bff947094"}], "stats": {"total": 328, "additions": 160, "deletions": 168}, "files": [{"sha": "03af81ae02a6d1962c88674035dcac1aa162b2a0", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84f82d348c1b9d9c20579ded7e2dd2981ed454b9/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f82d348c1b9d9c20579ded7e2dd2981ed454b9/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=84f82d348c1b9d9c20579ded7e2dd2981ed454b9", "patch": "@@ -314,12 +314,12 @@ pub struct GenericArgs<'hir> {\n     pub parenthesized: bool,\n }\n \n-impl<'tcx> GenericArgs<'tcx> {\n+impl GenericArgs<'_> {\n     pub const fn none() -> Self {\n         Self { args: &[], bindings: &[], parenthesized: false }\n     }\n \n-    pub fn inputs(&self) -> &[Ty<'tcx>] {\n+    pub fn inputs(&self) -> &[Ty<'_>] {\n         if self.parenthesized {\n             for arg in self.args {\n                 match arg {"}, {"sha": "4d33a1e69612f7a926920a4bed93d96a6cac562c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 152, "deletions": 160, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/84f82d348c1b9d9c20579ded7e2dd2981ed454b9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f82d348c1b9d9c20579ded7e2dd2981ed454b9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=84f82d348c1b9d9c20579ded7e2dd2981ed454b9", "patch": "@@ -48,42 +48,42 @@ crate use self::types::Type::*;\n crate use self::types::Visibility::{Inherited, Public};\n crate use self::types::*;\n \n-crate trait Clean<'tcx, T> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> T;\n+crate trait Clean<T> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> T;\n }\n \n-impl<'tcx, T: Clean<'tcx, U>, U> Clean<'tcx, Vec<U>> for [T] {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Vec<U> {\n+impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n-impl<'tcx, T: Clean<'tcx, U>, U, V: Idx> Clean<'tcx, IndexVec<V, U>> for IndexVec<V, T> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> IndexVec<V, U> {\n+impl<T: Clean<U>, U, V: Idx> Clean<IndexVec<V, U>> for IndexVec<V, T> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> IndexVec<V, U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n-impl<'tcx, T: Clean<'tcx, U>, U> Clean<'tcx, U> for &T {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> U {\n+impl<T: Clean<U>, U> Clean<U> for &T {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> U {\n         (**self).clean(cx)\n     }\n }\n \n-impl<'tcx, T: Clean<'tcx, U>, U> Clean<'tcx, U> for Rc<T> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> U {\n+impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> U {\n         (**self).clean(cx)\n     }\n }\n \n-impl<'tcx, T: Clean<'tcx, U>, U> Clean<'tcx, Option<U>> for Option<T> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<U> {\n+impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Option<U> {\n         self.as_ref().map(|v| v.clean(cx))\n     }\n }\n \n-impl<'tcx> Clean<'tcx, ExternalCrate> for CrateNum {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> ExternalCrate {\n+impl Clean<ExternalCrate> for CrateNum {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> ExternalCrate {\n         let tcx = cx.tcx;\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         let krate_span = tcx.def_span(root);\n@@ -204,8 +204,8 @@ impl<'tcx> Clean<'tcx, ExternalCrate> for CrateNum {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Item> for doctree::Module<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n+impl Clean<Item> for doctree::Module<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let mut items: Vec<Item> = vec![];\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n@@ -237,14 +237,14 @@ impl<'tcx> Clean<'tcx, Item> for doctree::Module<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Attributes> for [ast::Attribute] {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Attributes {\n+impl Clean<Attributes> for [ast::Attribute] {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Attributes {\n         Attributes::from_ast(cx.sess().diagnostic(), self, None)\n     }\n }\n \n-impl<'tcx> Clean<'tcx, GenericBound> for hir::GenericBound<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericBound {\n+impl Clean<GenericBound> for hir::GenericBound<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n         match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n             hir::GenericBound::LangItemTrait(lang_item, span, _, generic_args) => {\n@@ -270,8 +270,8 @@ impl<'tcx> Clean<'tcx, GenericBound> for hir::GenericBound<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Type> for (ty::TraitRef<'tcx>, &[TypeBinding]) {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n+impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         let (trait_ref, bounds) = *self;\n         inline::record_extern_fqn(cx, trait_ref.def_id, TypeKind::Trait);\n         let path = external_path(\n@@ -289,17 +289,17 @@ impl<'tcx> Clean<'tcx, Type> for (ty::TraitRef<'tcx>, &[TypeBinding]) {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, GenericBound> for ty::TraitRef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericBound {\n+impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n         GenericBound::TraitBound(\n             PolyTrait { trait_: (*self, &[][..]).clean(cx), generic_params: vec![] },\n             hir::TraitBoundModifier::None,\n         )\n     }\n }\n \n-impl<'tcx> Clean<'tcx, GenericBound> for (ty::PolyTraitRef<'tcx>, &[TypeBinding]) {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericBound {\n+impl Clean<GenericBound> for (ty::PolyTraitRef<'_>, &[TypeBinding]) {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n         let (poly_trait_ref, bounds) = *self;\n         let poly_trait_ref = poly_trait_ref.lift_to_tcx(cx.tcx).unwrap();\n \n@@ -326,14 +326,14 @@ impl<'tcx> Clean<'tcx, GenericBound> for (ty::PolyTraitRef<'tcx>, &[TypeBinding]\n     }\n }\n \n-impl<'tcx> Clean<'tcx, GenericBound> for ty::PolyTraitRef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericBound {\n+impl<'tcx> Clean<GenericBound> for ty::PolyTraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n         (*self, &[][..]).clean(cx)\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Option<Vec<GenericBound>>> for InternalSubsts<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<Vec<GenericBound>> {\n+impl<'tcx> Clean<Option<Vec<GenericBound>>> for InternalSubsts<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Option<Vec<GenericBound>> {\n         let mut v = Vec::new();\n         v.extend(self.regions().filter_map(|r| r.clean(cx)).map(GenericBound::Outlives));\n         v.extend(self.types().map(|t| {\n@@ -346,8 +346,8 @@ impl<'tcx> Clean<'tcx, Option<Vec<GenericBound>>> for InternalSubsts<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Lifetime> for hir::Lifetime {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Lifetime {\n+impl Clean<Lifetime> for hir::Lifetime {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Lifetime {\n         let def = cx.tcx.named_region(self.hir_id);\n         match def {\n             Some(\n@@ -365,8 +365,8 @@ impl<'tcx> Clean<'tcx, Lifetime> for hir::Lifetime {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Lifetime> for hir::GenericParam<'tcx> {\n-    fn clean(&self, _: &mut DocContext<'tcx>) -> Lifetime {\n+impl Clean<Lifetime> for hir::GenericParam<'_> {\n+    fn clean(&self, _: &mut DocContext<'_>) -> Lifetime {\n         match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n                 if !self.bounds.is_empty() {\n@@ -389,8 +389,8 @@ impl<'tcx> Clean<'tcx, Lifetime> for hir::GenericParam<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Constant> for hir::ConstArg {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n+impl Clean<Constant> for hir::ConstArg {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n         Constant {\n             type_: cx\n                 .tcx\n@@ -401,14 +401,14 @@ impl<'tcx> Clean<'tcx, Constant> for hir::ConstArg {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Lifetime> for ty::GenericParamDef {\n-    fn clean(&self, _cx: &mut DocContext<'tcx>) -> Lifetime {\n+impl Clean<Lifetime> for ty::GenericParamDef {\n+    fn clean(&self, _cx: &mut DocContext<'_>) -> Lifetime {\n         Lifetime(self.name)\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Option<Lifetime>> for ty::RegionKind {\n-    fn clean(&self, _cx: &mut DocContext<'tcx>) -> Option<Lifetime> {\n+impl Clean<Option<Lifetime>> for ty::RegionKind {\n+    fn clean(&self, _cx: &mut DocContext<'_>) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n             ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name) }) => {\n@@ -429,8 +429,8 @@ impl<'tcx> Clean<'tcx, Option<Lifetime>> for ty::RegionKind {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, WherePredicate> for hir::WherePredicate<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> WherePredicate {\n+impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n         match *self {\n             hir::WherePredicate::BoundPredicate(ref wbp) => WherePredicate::BoundPredicate {\n                 ty: wbp.bounded_ty.clean(cx),\n@@ -449,8 +449,8 @@ impl<'tcx> Clean<'tcx, WherePredicate> for hir::WherePredicate<'tcx> {\n     }\n }\n \n-impl<'a> Clean<'a, Option<WherePredicate>> for ty::Predicate<'a> {\n-    fn clean(&self, cx: &mut DocContext<'a>) -> Option<WherePredicate> {\n+impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n         let bound_predicate = self.kind();\n         match bound_predicate.skip_binder() {\n             ty::PredicateKind::Trait(pred, _) => Some(bound_predicate.rebind(pred).clean(cx)),\n@@ -469,8 +469,8 @@ impl<'a> Clean<'a, Option<WherePredicate>> for ty::Predicate<'a> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, WherePredicate> for ty::PolyTraitPredicate<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> WherePredicate {\n+impl<'a> Clean<WherePredicate> for ty::PolyTraitPredicate<'a> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n         let poly_trait_ref = self.map_bound(|pred| pred.trait_ref);\n         WherePredicate::BoundPredicate {\n             ty: poly_trait_ref.skip_binder().self_ty().clean(cx),\n@@ -479,10 +479,10 @@ impl<'tcx> Clean<'tcx, WherePredicate> for ty::PolyTraitPredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n+impl<'tcx> Clean<Option<WherePredicate>>\n     for ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(a, b) = self;\n \n         if let (ty::ReEmpty(_), ty::ReEmpty(_)) = (a, b) {\n@@ -496,10 +496,8 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n-    for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>\n-{\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n+impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ty, lt) = self;\n \n         if let ty::ReEmpty(_) = lt {\n@@ -513,15 +511,15 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n     }\n }\n \n-impl<'tcx> Clean<'tcx, WherePredicate> for ty::ProjectionPredicate<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> WherePredicate {\n+impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n         let ty::ProjectionPredicate { projection_ty, ty } = self;\n         WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: ty.clean(cx) }\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Type> for ty::ProjectionTy<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n+impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         let lifted = self.lift_to_tcx(cx.tcx).unwrap();\n         let trait_ = match lifted.trait_ref(cx.tcx).clean(cx) {\n             GenericBound::TraitBound(t, _) => t.trait_,\n@@ -535,8 +533,8 @@ impl<'tcx> Clean<'tcx, Type> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, GenericParamDef> for ty::GenericParamDef {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericParamDef {\n+impl Clean<GenericParamDef> for ty::GenericParamDef {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             ty::GenericParamDefKind::Lifetime => (self.name, GenericParamDefKind::Lifetime),\n             ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n@@ -565,8 +563,8 @@ impl<'tcx> Clean<'tcx, GenericParamDef> for ty::GenericParamDef {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, GenericParamDef> for hir::GenericParam<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericParamDef {\n+impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n                 let name = if !self.bounds.is_empty() {\n@@ -608,8 +606,8 @@ impl<'tcx> Clean<'tcx, GenericParamDef> for hir::GenericParam<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Generics> for hir::Generics<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Generics {\n+impl Clean<Generics> for hir::Generics<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Generics {\n         // Synthetic type-parameters are inserted after normal ones.\n         // In order for normal parameters to be able to refer to synthetic ones,\n         // scans them first.\n@@ -688,8 +686,8 @@ impl<'tcx> Clean<'tcx, Generics> for hir::Generics<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Clean<'tcx, Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx>) {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Generics {\n+impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx>) {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Generics {\n         use self::WherePredicate as WP;\n         use std::collections::BTreeMap;\n \n@@ -853,13 +851,13 @@ impl<'a, 'tcx> Clean<'tcx, Generics> for (&'a ty::Generics, ty::GenericPredicate\n     }\n }\n \n-fn clean_fn_or_proc_macro<'a, 'tcx>(\n-    item: &hir::Item<'tcx>,\n-    sig: &'a hir::FnSig<'tcx>,\n-    generics: &'a hir::Generics<'tcx>,\n+fn clean_fn_or_proc_macro(\n+    item: &hir::Item<'_>,\n+    sig: &'a hir::FnSig<'a>,\n+    generics: &'a hir::Generics<'a>,\n     body_id: hir::BodyId,\n     name: &mut Symbol,\n-    cx: &mut DocContext<'tcx>,\n+    cx: &mut DocContext<'_>,\n ) -> ItemKind {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n     let macro_kind = attrs.iter().find_map(|a| {\n@@ -913,18 +911,16 @@ fn clean_fn_or_proc_macro<'a, 'tcx>(\n     }\n }\n \n-impl<'a, 'tcx> Clean<'tcx, Function>\n-    for (&'a hir::FnSig<'tcx>, &'a hir::Generics<'tcx>, hir::BodyId)\n-{\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Function {\n+impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId) {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Function {\n         let (generics, decl) =\n             enter_impl_trait(cx, |cx| (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx)));\n         Function { decl, generics, header: self.0.header }\n     }\n }\n \n-impl<'a, 'tcx> Clean<'tcx, Arguments> for (&'a [hir::Ty<'tcx>], &'a [Ident]) {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Arguments {\n+impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [Ident]) {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Arguments {\n         Arguments {\n             values: self\n                 .0\n@@ -942,8 +938,8 @@ impl<'a, 'tcx> Clean<'tcx, Arguments> for (&'a [hir::Ty<'tcx>], &'a [Ident]) {\n     }\n }\n \n-impl<'a, 'tcx> Clean<'tcx, Arguments> for (&'a [hir::Ty<'tcx>], hir::BodyId) {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Arguments {\n+impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], hir::BodyId) {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Arguments {\n         let body = cx.tcx.hir().body(self.1);\n \n         Arguments {\n@@ -952,30 +948,30 @@ impl<'a, 'tcx> Clean<'tcx, Arguments> for (&'a [hir::Ty<'tcx>], hir::BodyId) {\n                 .iter()\n                 .enumerate()\n                 .map(|(i, ty)| Argument {\n-                    name: Symbol::intern(&rustc_hir_pretty::param_to_string(&body.params[i])),\n+                    name: name_from_pat(&body.params[i].pat),\n                     type_: ty.clean(cx),\n                 })\n                 .collect(),\n         }\n     }\n }\n \n-impl<'a, 'tcx, A: Copy> Clean<'tcx, FnDecl> for (&'a hir::FnDecl<'tcx>, A)\n+impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl<'a>, A)\n where\n-    (&'a [hir::Ty<'a>], A): Clean<'tcx, Arguments>,\n+    (&'a [hir::Ty<'a>], A): Clean<Arguments>,\n {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> FnDecl {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> FnDecl {\n         FnDecl {\n-            inputs: (&self.0.inputs[..], self.1).clean(cx),\n+            inputs: (self.0.inputs, self.1).clean(cx),\n             output: self.0.output.clean(cx),\n             c_variadic: self.0.c_variadic,\n             attrs: Attributes::default(),\n         }\n     }\n }\n \n-impl<'tcx> Clean<'tcx, FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> FnDecl {\n+impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if did.is_local() { &[] } else { cx.tcx.fn_arg_names(did) }.iter();\n \n@@ -998,16 +994,16 @@ impl<'tcx> Clean<'tcx, FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, FnRetTy> for hir::FnRetTy<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> FnRetTy {\n+impl Clean<FnRetTy> for hir::FnRetTy<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> FnRetTy {\n         match *self {\n             Self::Return(ref typ) => Return(typ.clean(cx)),\n             Self::DefaultReturn(..) => DefaultReturn,\n         }\n     }\n }\n \n-impl Clean<'_, bool> for hir::IsAuto {\n+impl Clean<bool> for hir::IsAuto {\n     fn clean(&self, _: &mut DocContext<'_>) -> bool {\n         match *self {\n             hir::IsAuto::Yes => true,\n@@ -1016,30 +1012,30 @@ impl Clean<'_, bool> for hir::IsAuto {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Type> for hir::TraitRef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n+impl Clean<Type> for hir::TraitRef<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         let path = self.path.clean(cx);\n         resolve_type(cx, path, self.hir_ref_id)\n     }\n }\n \n-impl<'tcx> Clean<'tcx, PolyTrait> for hir::PolyTraitRef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> PolyTrait {\n+impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n             generic_params: self.bound_generic_params.clean(cx),\n         }\n     }\n }\n \n-impl<'tcx> Clean<'tcx, TypeKind> for hir::def::DefKind {\n-    fn clean(&self, _: &mut DocContext<'tcx>) -> TypeKind {\n+impl Clean<TypeKind> for hir::def::DefKind {\n+    fn clean(&self, _: &mut DocContext<'_>) -> TypeKind {\n         (*self).into()\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n+impl Clean<Item> for hir::TraitItem<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n@@ -1079,8 +1075,8 @@ impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n+impl Clean<Item> for hir::ImplItem<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n@@ -1128,8 +1124,8 @@ impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n+impl Clean<Item> for ty::AssocItem {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let tcx = cx.tcx;\n         let kind = match self.kind {\n             ty::AssocKind::Const => {\n@@ -1280,7 +1276,7 @@ impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n     }\n }\n \n-fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type {\n+fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n     use rustc_hir::GenericParamCount;\n     let hir::Ty { hir_id, span, ref kind } = *hir_ty;\n     let qpath = match kind {\n@@ -1432,8 +1428,8 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Type> for hir::Ty<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n+impl Clean<Type> for hir::Ty<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         use rustc_hir::*;\n \n         match self.kind {\n@@ -1535,8 +1531,8 @@ fn normalize(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Type> for Ty<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n+impl<'tcx> Clean<Type> for Ty<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         debug!(\"cleaning type: {:?}\", self);\n         let ty = normalize(cx, self).unwrap_or(self);\n         match *ty.kind() {\n@@ -1743,8 +1739,8 @@ impl<'tcx> Clean<'tcx, Type> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Constant> for ty::Const<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n+impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n         // FIXME: instead of storing the stringified expression, store `self` directly instead.\n         Constant {\n             type_: self.ty.clean(cx),\n@@ -1753,8 +1749,8 @@ impl<'tcx> Clean<'tcx, Constant> for ty::Const<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Item> for hir::FieldDef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n+impl Clean<Item> for hir::FieldDef<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let what_rustc_thinks = Item::from_hir_id_and_parts(\n             self.hir_id,\n             Some(self.ident.name),\n@@ -1766,8 +1762,8 @@ impl<'tcx> Clean<'tcx, Item> for hir::FieldDef<'tcx> {\n     }\n }\n \n-impl Clean<'tcx, Item> for ty::FieldDef {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n+impl Clean<Item> for ty::FieldDef {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let what_rustc_thinks = Item::from_def_id_and_parts(\n             self.did,\n             Some(self.ident.name),\n@@ -1779,8 +1775,8 @@ impl Clean<'tcx, Item> for ty::FieldDef {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Visibility> for hir::Visibility<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Visibility {\n+impl Clean<Visibility> for hir::Visibility<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Visibility {\n         match self.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Inherited => Visibility::Inherited,\n@@ -1797,8 +1793,8 @@ impl<'tcx> Clean<'tcx, Visibility> for hir::Visibility<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Visibility> for ty::Visibility {\n-    fn clean(&self, _cx: &mut DocContext<'tcx>) -> Visibility {\n+impl Clean<Visibility> for ty::Visibility {\n+    fn clean(&self, _cx: &mut DocContext<'_>) -> Visibility {\n         match *self {\n             ty::Visibility::Public => Visibility::Public,\n             // NOTE: this is not quite right: `ty` uses `Invisible` to mean 'private',\n@@ -1812,8 +1808,8 @@ impl<'tcx> Clean<'tcx, Visibility> for ty::Visibility {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, VariantStruct> for rustc_hir::VariantData<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> VariantStruct {\n+impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> VariantStruct {\n         VariantStruct {\n             struct_type: CtorKind::from_hir(self),\n             fields: self.fields().iter().map(|x| x.clean(cx)).collect(),\n@@ -1822,8 +1818,8 @@ impl<'tcx> Clean<'tcx, VariantStruct> for rustc_hir::VariantData<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Item> for ty::VariantDef {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n+impl Clean<Item> for ty::VariantDef {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => Variant::CLike,\n             CtorKind::Fn => Variant::Tuple(\n@@ -1853,8 +1849,8 @@ impl<'tcx> Clean<'tcx, Item> for ty::VariantDef {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Variant> for hir::VariantData<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Variant {\n+impl Clean<Variant> for hir::VariantData<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Variant {\n         match self {\n             hir::VariantData::Struct(..) => Variant::Struct(self.clean(cx)),\n             hir::VariantData::Tuple(..) => {\n@@ -1865,14 +1861,14 @@ impl<'tcx> Clean<'tcx, Variant> for hir::VariantData<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Span> for rustc_span::Span {\n-    fn clean(&self, _cx: &mut DocContext<'tcx>) -> Span {\n+impl Clean<Span> for rustc_span::Span {\n+    fn clean(&self, _cx: &mut DocContext<'_>) -> Span {\n         Span::from_rustc_span(*self)\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Path> for hir::Path<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Path {\n+impl Clean<Path> for hir::Path<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n         Path {\n             global: self.is_global(),\n             res: self.res,\n@@ -1881,8 +1877,8 @@ impl<'tcx> Clean<'tcx, Path> for hir::Path<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericArgs {\n+impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericArgs {\n         if self.parenthesized {\n             let output = self.bindings[0].ty().clean(cx);\n             GenericArgs::Parenthesized {\n@@ -1909,37 +1905,37 @@ impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, PathSegment> for hir::PathSegment<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> PathSegment {\n+impl Clean<PathSegment> for hir::PathSegment<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> PathSegment {\n         PathSegment { name: self.ident.name, args: self.args().clean(cx) }\n     }\n }\n \n-impl<'tcx> Clean<'tcx, String> for Ident {\n+impl Clean<String> for Ident {\n     #[inline]\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> String {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> String {\n         self.name.clean(cx)\n     }\n }\n \n-impl<'tcx> Clean<'tcx, String> for Symbol {\n+impl Clean<String> for Symbol {\n     #[inline]\n-    fn clean(&self, _: &mut DocContext<'tcx>) -> String {\n+    fn clean(&self, _: &mut DocContext<'_>) -> String {\n         self.to_string()\n     }\n }\n \n-impl<'tcx> Clean<'tcx, BareFunctionDecl> for hir::BareFnTy<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> BareFunctionDecl {\n+impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n             (self.generic_params.clean(cx), (&*self.decl, self.param_names).clean(cx))\n         });\n         BareFunctionDecl { unsafety: self.unsafety, abi: self.abi, decl, generic_params }\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Vec<Item>> for (&hir::Item<'tcx>, Option<Symbol>) {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Vec<Item> {\n+impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<Item> {\n         use hir::ItemKind;\n \n         let (item, renamed) = self;\n@@ -2022,8 +2018,8 @@ impl<'tcx> Clean<'tcx, Vec<Item>> for (&hir::Item<'tcx>, Option<Symbol>) {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Item> for hir::Variant<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n+impl Clean<Item> for hir::Variant<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let kind = VariantItem(self.data.clean(cx));\n         let what_rustc_thinks =\n             Item::from_hir_id_and_parts(self.id, Some(self.ident.name), kind, cx);\n@@ -2032,9 +2028,9 @@ impl<'tcx> Clean<'tcx, Item> for hir::Variant<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, bool> for ty::ImplPolarity {\n+impl Clean<bool> for ty::ImplPolarity {\n     /// Returns whether the impl has negative polarity.\n-    fn clean(&self, _: &mut DocContext<'tcx>) -> bool {\n+    fn clean(&self, _: &mut DocContext<'_>) -> bool {\n         match self {\n             &ty::ImplPolarity::Positive |\n             // FIXME: do we want to do something else here?\n@@ -2044,11 +2040,7 @@ impl<'tcx> Clean<'tcx, bool> for ty::ImplPolarity {\n     }\n }\n \n-fn clean_impl<'tcx>(\n-    impl_: &hir::Impl<'tcx>,\n-    hir_id: hir::HirId,\n-    cx: &mut DocContext<'tcx>,\n-) -> Vec<Item> {\n+fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>) -> Vec<Item> {\n     let tcx = cx.tcx;\n     let mut ret = Vec::new();\n     let trait_ = impl_.of_trait.clean(cx);\n@@ -2093,11 +2085,11 @@ fn clean_impl<'tcx>(\n     ret\n }\n \n-fn clean_extern_crate<'tcx>(\n-    krate: &hir::Item<'tcx>,\n+fn clean_extern_crate(\n+    krate: &hir::Item<'_>,\n     name: Symbol,\n     orig_name: Option<Symbol>,\n-    cx: &mut DocContext<'tcx>,\n+    cx: &mut DocContext<'_>,\n ) -> Vec<Item> {\n     // this is the ID of the `extern crate` statement\n     let cnum = cx.tcx.extern_mod_stmt_cnum(krate.def_id).unwrap_or(LOCAL_CRATE);\n@@ -2140,12 +2132,12 @@ fn clean_extern_crate<'tcx>(\n     }]\n }\n \n-fn clean_use_statement<'tcx>(\n-    import: &hir::Item<'tcx>,\n+fn clean_use_statement(\n+    import: &hir::Item<'_>,\n     name: Symbol,\n-    path: &hir::Path<'tcx>,\n+    path: &hir::Path<'_>,\n     kind: hir::UseKind,\n-    cx: &mut DocContext<'tcx>,\n+    cx: &mut DocContext<'_>,\n ) -> Vec<Item> {\n     // We need this comparison because some imports (for std types for example)\n     // are \"inserted\" as well but directly by the compiler and they should not be\n@@ -2235,8 +2227,8 @@ fn clean_use_statement<'tcx>(\n     vec![Item::from_def_id_and_parts(import.def_id.to_def_id(), None, ImportItem(inner), cx)]\n }\n \n-impl<'tcx> Clean<'tcx, Item> for (&hir::ForeignItem<'tcx>, Option<Symbol>) {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n+impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let (item, renamed) = self;\n         cx.with_param_env(item.def_id.to_def_id(), |cx| {\n             let kind = match item.kind {\n@@ -2272,8 +2264,8 @@ impl<'tcx> Clean<'tcx, Item> for (&hir::ForeignItem<'tcx>, Option<Symbol>) {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Item> for (&hir::MacroDef<'tcx>, Option<Symbol>) {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n+impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let (item, renamed) = self;\n         let name = renamed.unwrap_or(item.ident.name);\n         let tts = item.ast.body.inner_tokens().trees().collect::<Vec<_>>();\n@@ -2321,14 +2313,14 @@ impl<'tcx> Clean<'tcx, Item> for (&hir::MacroDef<'tcx>, Option<Symbol>) {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, TypeBinding> for hir::TypeBinding<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> TypeBinding {\n+impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> TypeBinding {\n         TypeBinding { name: self.ident.name, kind: self.kind.clean(cx) }\n     }\n }\n \n-impl<'tcx> Clean<'tcx, TypeBindingKind> for hir::TypeBindingKind<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> TypeBindingKind {\n+impl Clean<TypeBindingKind> for hir::TypeBindingKind<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> TypeBindingKind {\n         match *self {\n             hir::TypeBindingKind::Equality { ref ty } => {\n                 TypeBindingKind::Equality { ty: ty.clean(cx) }"}, {"sha": "32bac53e8f51b78f89da360452a4f61a53c7b0cb", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84f82d348c1b9d9c20579ded7e2dd2981ed454b9/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f82d348c1b9d9c20579ded7e2dd2981ed454b9/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=84f82d348c1b9d9c20579ded7e2dd2981ed454b9", "patch": "@@ -84,12 +84,12 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n     }\n }\n \n-fn external_generic_args<'tcx>(\n-    cx: &mut DocContext<'tcx>,\n+fn external_generic_args(\n+    cx: &mut DocContext<'_>,\n     trait_did: Option<DefId>,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n-    substs: SubstsRef<'tcx>,\n+    substs: SubstsRef<'_>,\n ) -> GenericArgs {\n     let mut skip_self = has_self;\n     let mut ty_kind = None;\n@@ -136,13 +136,13 @@ fn external_generic_args<'tcx>(\n \n // trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n // from Fn<(A, B,), C> to Fn(A, B) -> C\n-pub(super) fn external_path<'tcx>(\n-    cx: &mut DocContext<'tcx>,\n+pub(super) fn external_path(\n+    cx: &mut DocContext<'_>,\n     name: Symbol,\n     trait_did: Option<DefId>,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n-    substs: SubstsRef<'tcx>,\n+    substs: SubstsRef<'_>,\n ) -> Path {\n     Path {\n         global: false,"}]}