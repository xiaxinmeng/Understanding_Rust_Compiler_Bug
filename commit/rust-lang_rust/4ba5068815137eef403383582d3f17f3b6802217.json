{"sha": "4ba5068815137eef403383582d3f17f3b6802217", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYTUwNjg4MTUxMzdlZWY0MDMzODM1ODJkM2YxN2YzYjY4MDIyMTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-14T00:26:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-14T00:26:50Z"}, "message": "Auto merge of #77135 - Aaron1011:pretty-ignore-paren, r=petrochenkov\n\nRefactor AST pretty-printing to allow skipping insertion of extra parens\n\nFixes #75734\nMakes progress towards #43081\nUnblocks PR #76130\n\nWhen pretty-printing an AST node, we may insert additional parenthesis\nto ensure that precedence is properly preserved in code we output.\nHowever, the proc macro implementation relies on comparing a\npretty-printed AST node to the captured `TokenStream`. Inserting extra\nparenthesis changes the structure of the reparsed `TokenStream`, making\nthe comparison fail.\n\nThis PR refactors the AST pretty-printing code to allow skipping the\ninsertion of additional parenthesis. Several freestanding methods are\nmoved to trait methods on `PrintState`, which keep track of an internal\n`insert_extra_parens` flag. This flag is normally `true`, but we expose\na public method which allows pretty-printing a nonterminal with\n`insert_extra_parens = false`.\n\nTo avoid changing the public interface of `rustc_ast_pretty`, the\nfreestanding `_to_string` methods are changed to delegate to a\nnewly-crated `State`. The main pretty-printing code is moved to a new\n`state` module to ensure that it does not accidentally call any of these\npublic helper functions (instead, the internal functions with the same\nname should be used).", "tree": {"sha": "1d8b7619774abe52c162e43db1c8d02226a2e37f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d8b7619774abe52c162e43db1c8d02226a2e37f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ba5068815137eef403383582d3f17f3b6802217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ba5068815137eef403383582d3f17f3b6802217", "html_url": "https://github.com/rust-lang/rust/commit/4ba5068815137eef403383582d3f17f3b6802217", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ba5068815137eef403383582d3f17f3b6802217/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f243a2ad904705a1e340a08639dca105605b4175", "url": "https://api.github.com/repos/rust-lang/rust/commits/f243a2ad904705a1e340a08639dca105605b4175", "html_url": "https://github.com/rust-lang/rust/commit/f243a2ad904705a1e340a08639dca105605b4175"}, {"sha": "9a6ea386472acb7e1e1dd24370ef9d60d07463f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a6ea386472acb7e1e1dd24370ef9d60d07463f5", "html_url": "https://github.com/rust-lang/rust/commit/9a6ea386472acb7e1e1dd24370ef9d60d07463f5"}], "stats": {"total": 830, "additions": 633, "deletions": 197}, "files": [{"sha": "9635750fb40bc5185c1f7248dfcf87a3eaea5fa1", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -810,25 +810,36 @@ impl Nonterminal {\n             if let ExpnKind::Macro(_, macro_name) = orig_span.ctxt().outer_expn_data().kind {\n                 let filename = source_map.span_to_filename(orig_span);\n                 if let FileName::Real(RealFileName::Named(path)) = filename {\n-                    let matches_prefix = |prefix| {\n-                        // Check for a path that ends with 'prefix*/src/lib.rs'\n+                    let matches_prefix = |prefix, filename| {\n+                        // Check for a path that ends with 'prefix*/src/<filename>'\n                         let mut iter = path.components().rev();\n-                        iter.next().and_then(|p| p.as_os_str().to_str()) == Some(\"lib.rs\")\n+                        iter.next().and_then(|p| p.as_os_str().to_str()) == Some(filename)\n                             && iter.next().and_then(|p| p.as_os_str().to_str()) == Some(\"src\")\n                             && iter\n                                 .next()\n                                 .and_then(|p| p.as_os_str().to_str())\n                                 .map_or(false, |p| p.starts_with(prefix))\n                     };\n \n-                    if (macro_name == sym::impl_macros && matches_prefix(\"time-macros-impl\"))\n-                        || (macro_name == sym::arrays && matches_prefix(\"js-sys\"))\n+                    if (macro_name == sym::impl_macros\n+                        && matches_prefix(\"time-macros-impl\", \"lib.rs\"))\n+                        || (macro_name == sym::arrays && matches_prefix(\"js-sys\", \"lib.rs\"))\n                     {\n                         let snippet = source_map.span_to_snippet(orig_span);\n                         if snippet.as_deref() == Ok(\"$name\") {\n                             return Some((*ident, *is_raw));\n                         }\n                     }\n+\n+                    if macro_name == sym::tuple_from_req\n+                        && (matches_prefix(\"actix-web\", \"extract.rs\")\n+                            || matches_prefix(\"actori-web\", \"extract.rs\"))\n+                    {\n+                        let snippet = source_map.span_to_snippet(orig_span);\n+                        if snippet.as_deref() == Ok(\"$T\") {\n+                            return Some((*ident, *is_raw));\n+                        }\n+                    }\n                 }\n             }\n         }"}, {"sha": "b34ea41ab558a1767962d73861d88b14418c58de", "filename": "compiler/rustc_ast_pretty/src/pprust/mod.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -0,0 +1,104 @@\n+#[cfg(test)]\n+mod tests;\n+\n+pub mod state;\n+pub use state::{print_crate, AnnNode, Comments, PpAnn, PrintState, State};\n+\n+use rustc_ast as ast;\n+use rustc_ast::token::{Nonterminal, Token, TokenKind};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+\n+pub fn nonterminal_to_string_no_extra_parens(nt: &Nonterminal) -> String {\n+    let state = State::without_insert_extra_parens();\n+    state.nonterminal_to_string(nt)\n+}\n+\n+pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n+    State::new().nonterminal_to_string(nt)\n+}\n+\n+/// Print the token kind precisely, without converting `$crate` into its respective crate name.\n+pub fn token_kind_to_string(tok: &TokenKind) -> String {\n+    State::new().token_kind_to_string(tok)\n+}\n+\n+/// Print the token precisely, without converting `$crate` into its respective crate name.\n+pub fn token_to_string(token: &Token) -> String {\n+    State::new().token_to_string(token)\n+}\n+\n+pub fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n+    State::new().token_to_string_ext(token, convert_dollar_crate)\n+}\n+\n+pub fn ty_to_string(ty: &ast::Ty) -> String {\n+    State::new().ty_to_string(ty)\n+}\n+\n+pub fn bounds_to_string(bounds: &[ast::GenericBound]) -> String {\n+    State::new().bounds_to_string(bounds)\n+}\n+\n+pub fn pat_to_string(pat: &ast::Pat) -> String {\n+    State::new().pat_to_string(pat)\n+}\n+\n+pub fn expr_to_string(e: &ast::Expr) -> String {\n+    State::new().expr_to_string(e)\n+}\n+\n+pub fn tt_to_string(tt: &TokenTree) -> String {\n+    State::new().tt_to_string(tt)\n+}\n+\n+pub fn tts_to_string(tokens: &TokenStream) -> String {\n+    State::new().tts_to_string(tokens)\n+}\n+\n+pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n+    State::new().stmt_to_string(stmt)\n+}\n+\n+pub fn item_to_string(i: &ast::Item) -> String {\n+    State::new().item_to_string(i)\n+}\n+\n+pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n+    State::new().generic_params_to_string(generic_params)\n+}\n+\n+pub fn path_to_string(p: &ast::Path) -> String {\n+    State::new().path_to_string(p)\n+}\n+\n+pub fn path_segment_to_string(p: &ast::PathSegment) -> String {\n+    State::new().path_segment_to_string(p)\n+}\n+\n+pub fn vis_to_string(v: &ast::Visibility) -> String {\n+    State::new().vis_to_string(v)\n+}\n+\n+pub fn block_to_string(blk: &ast::Block) -> String {\n+    State::new().block_to_string(blk)\n+}\n+\n+pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n+    State::new().meta_list_item_to_string(li)\n+}\n+\n+pub fn attr_item_to_string(ai: &ast::AttrItem) -> String {\n+    State::new().attr_item_to_string(ai)\n+}\n+\n+pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n+    State::new().attribute_to_string(attr)\n+}\n+\n+pub fn param_to_string(arg: &ast::Param) -> String {\n+    State::new().param_to_string(arg)\n+}\n+\n+pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n+    State::new().to_string(f)\n+}"}, {"sha": "9aa066370bb5b1bc38371dd69dad1304569c5eea", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "renamed", "additions": 220, "deletions": 183, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -20,9 +20,6 @@ use rustc_span::{BytePos, FileName, Span};\n \n use std::borrow::Cow;\n \n-#[cfg(test)]\n-mod tests;\n-\n pub enum MacHeader<'a> {\n     Path(&'a ast::Path),\n     Keyword(&'static str),\n@@ -91,6 +88,13 @@ pub struct State<'a> {\n     comments: Option<Comments<'a>>,\n     ann: &'a (dyn PpAnn + 'a),\n     is_expanded: bool,\n+    // If `true`, additional parenthesis (separate from `ExprKind::Paren`)\n+    // are inserted to ensure that proper precedence is preserved\n+    // in the pretty-printed output.\n+    //\n+    // This is usually `true`, except when performing the pretty-print/reparse\n+    // check in `nt_to_tokenstream`\n+    insert_extra_parens: bool,\n }\n \n crate const INDENT_UNIT: usize = 4;\n@@ -112,6 +116,7 @@ pub fn print_crate<'a>(\n         comments: Some(Comments::new(sm, filename, input)),\n         ann,\n         is_expanded,\n+        insert_extra_parens: true,\n     };\n \n     if is_expanded && has_injected_crate {\n@@ -142,13 +147,6 @@ pub fn print_crate<'a>(\n     s.s.eof()\n }\n \n-pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n-    let mut printer =\n-        State { s: pp::mk_printer(), comments: None, ann: &NoAnn, is_expanded: false };\n-    f(&mut printer);\n-    printer.s.eof()\n-}\n-\n // This makes printed token streams look slightly nicer,\n // and also addresses some specific regressions described in #63896 and #73345.\n fn tt_prepend_space(tt: &TokenTree, prev: &TokenTree) -> bool {\n@@ -231,173 +229,8 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n     out\n }\n \n-/// Print the token kind precisely, without converting `$crate` into its respective crate name.\n-pub fn token_kind_to_string(tok: &TokenKind) -> String {\n-    token_kind_to_string_ext(tok, None)\n-}\n-\n-fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>) -> String {\n-    match *tok {\n-        token::Eq => \"=\".to_string(),\n-        token::Lt => \"<\".to_string(),\n-        token::Le => \"<=\".to_string(),\n-        token::EqEq => \"==\".to_string(),\n-        token::Ne => \"!=\".to_string(),\n-        token::Ge => \">=\".to_string(),\n-        token::Gt => \">\".to_string(),\n-        token::Not => \"!\".to_string(),\n-        token::Tilde => \"~\".to_string(),\n-        token::OrOr => \"||\".to_string(),\n-        token::AndAnd => \"&&\".to_string(),\n-        token::BinOp(op) => binop_to_string(op).to_string(),\n-        token::BinOpEq(op) => format!(\"{}=\", binop_to_string(op)),\n-\n-        /* Structural symbols */\n-        token::At => \"@\".to_string(),\n-        token::Dot => \".\".to_string(),\n-        token::DotDot => \"..\".to_string(),\n-        token::DotDotDot => \"...\".to_string(),\n-        token::DotDotEq => \"..=\".to_string(),\n-        token::Comma => \",\".to_string(),\n-        token::Semi => \";\".to_string(),\n-        token::Colon => \":\".to_string(),\n-        token::ModSep => \"::\".to_string(),\n-        token::RArrow => \"->\".to_string(),\n-        token::LArrow => \"<-\".to_string(),\n-        token::FatArrow => \"=>\".to_string(),\n-        token::OpenDelim(token::Paren) => \"(\".to_string(),\n-        token::CloseDelim(token::Paren) => \")\".to_string(),\n-        token::OpenDelim(token::Bracket) => \"[\".to_string(),\n-        token::CloseDelim(token::Bracket) => \"]\".to_string(),\n-        token::OpenDelim(token::Brace) => \"{\".to_string(),\n-        token::CloseDelim(token::Brace) => \"}\".to_string(),\n-        token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim) => \"\".to_string(),\n-        token::Pound => \"#\".to_string(),\n-        token::Dollar => \"$\".to_string(),\n-        token::Question => \"?\".to_string(),\n-        token::SingleQuote => \"'\".to_string(),\n-\n-        /* Literals */\n-        token::Literal(lit) => literal_to_string(lit),\n-\n-        /* Name components */\n-        token::Ident(s, is_raw) => IdentPrinter::new(s, is_raw, convert_dollar_crate).to_string(),\n-        token::Lifetime(s) => s.to_string(),\n-\n-        /* Other */\n-        token::DocComment(comment_kind, attr_style, data) => {\n-            doc_comment_to_string(comment_kind, attr_style, data)\n-        }\n-        token::Eof => \"<eof>\".to_string(),\n-\n-        token::Interpolated(ref nt) => nonterminal_to_string(nt),\n-    }\n-}\n-\n-/// Print the token precisely, without converting `$crate` into its respective crate name.\n-pub fn token_to_string(token: &Token) -> String {\n-    token_to_string_ext(token, false)\n-}\n-\n-fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n-    let convert_dollar_crate = convert_dollar_crate.then_some(token.span);\n-    token_kind_to_string_ext(&token.kind, convert_dollar_crate)\n-}\n-\n-pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n-    match *nt {\n-        token::NtExpr(ref e) => expr_to_string(e),\n-        token::NtMeta(ref e) => attr_item_to_string(e),\n-        token::NtTy(ref e) => ty_to_string(e),\n-        token::NtPath(ref e) => path_to_string(e),\n-        token::NtItem(ref e) => item_to_string(e),\n-        token::NtBlock(ref e) => block_to_string(e),\n-        token::NtStmt(ref e) => stmt_to_string(e),\n-        token::NtPat(ref e) => pat_to_string(e),\n-        token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n-        token::NtLifetime(e) => e.to_string(),\n-        token::NtLiteral(ref e) => expr_to_string(e),\n-        token::NtTT(ref tree) => tt_to_string(tree),\n-        token::NtVis(ref e) => vis_to_string(e),\n-    }\n-}\n-\n-pub fn ty_to_string(ty: &ast::Ty) -> String {\n-    to_string(|s| s.print_type(ty))\n-}\n-\n-pub fn bounds_to_string(bounds: &[ast::GenericBound]) -> String {\n-    to_string(|s| s.print_type_bounds(\"\", bounds))\n-}\n-\n-pub fn pat_to_string(pat: &ast::Pat) -> String {\n-    to_string(|s| s.print_pat(pat))\n-}\n-\n-pub fn expr_to_string(e: &ast::Expr) -> String {\n-    to_string(|s| s.print_expr(e))\n-}\n-\n-pub fn tt_to_string(tt: &TokenTree) -> String {\n-    to_string(|s| s.print_tt(tt, false))\n-}\n-\n-pub fn tts_to_string(tokens: &TokenStream) -> String {\n-    to_string(|s| s.print_tts(tokens, false))\n-}\n-\n-pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n-    to_string(|s| s.print_stmt(stmt))\n-}\n-\n-pub fn item_to_string(i: &ast::Item) -> String {\n-    to_string(|s| s.print_item(i))\n-}\n-\n-pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n-    to_string(|s| s.print_generic_params(generic_params))\n-}\n-\n-pub fn path_to_string(p: &ast::Path) -> String {\n-    to_string(|s| s.print_path(p, false, 0))\n-}\n-\n-pub fn path_segment_to_string(p: &ast::PathSegment) -> String {\n-    to_string(|s| s.print_path_segment(p, false))\n-}\n-\n-pub fn vis_to_string(v: &ast::Visibility) -> String {\n-    to_string(|s| s.print_visibility(v))\n-}\n-\n-fn block_to_string(blk: &ast::Block) -> String {\n-    to_string(|s| {\n-        // Containing cbox, will be closed by `print_block` at `}`.\n-        s.cbox(INDENT_UNIT);\n-        // Head-ibox, will be closed by `print_block` after `{`.\n-        s.ibox(0);\n-        s.print_block(blk)\n-    })\n-}\n-\n-pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n-    to_string(|s| s.print_meta_list_item(li))\n-}\n-\n-fn attr_item_to_string(ai: &ast::AttrItem) -> String {\n-    to_string(|s| s.print_attr_item(ai, ai.path.span))\n-}\n-\n-pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n-    to_string(|s| s.print_attribute(attr))\n-}\n-\n-pub fn param_to_string(arg: &ast::Param) -> String {\n-    to_string(|s| s.print_param(arg, false))\n-}\n-\n fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n-    format!(\"{}{}\", to_string(|s| s.print_visibility(vis)), s)\n+    format!(\"{}{}\", State::new().to_string(|s| s.print_visibility(vis)), s)\n }\n \n impl std::ops::Deref for State<'_> {\n@@ -414,6 +247,7 @@ impl std::ops::DerefMut for State<'_> {\n }\n \n pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::DerefMut {\n+    fn insert_extra_parens(&self) -> bool;\n     fn comments(&mut self) -> &mut Option<Comments<'a>>;\n     fn print_ident(&mut self, ident: Ident);\n     fn print_generic_args(&mut self, args: &ast::GenericArgs, colons_before_params: bool);\n@@ -679,7 +513,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_tt(&mut self, tt: &TokenTree, convert_dollar_crate: bool) {\n         match tt {\n             TokenTree::Token(token) => {\n-                self.word(token_to_string_ext(&token, convert_dollar_crate));\n+                let token_str = self.token_to_string_ext(&token, convert_dollar_crate);\n+                self.word(token_str);\n                 if let token::DocComment(..) = token.kind {\n                     self.hardbreak()\n                 }\n@@ -745,14 +580,20 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     self.space();\n                 }\n             }\n-            _ => self.word(token_kind_to_string(&token::OpenDelim(delim))),\n+            _ => {\n+                let token_str = self.token_kind_to_string(&token::OpenDelim(delim));\n+                self.word(token_str)\n+            }\n         }\n         self.ibox(0);\n         self.print_tts(tts, convert_dollar_crate);\n         self.end();\n         match delim {\n             DelimToken::Brace => self.bclose(span),\n-            _ => self.word(token_kind_to_string(&token::CloseDelim(delim))),\n+            _ => {\n+                let token_str = self.token_kind_to_string(&token::CloseDelim(delim));\n+                self.word(token_str)\n+            }\n         }\n     }\n \n@@ -818,9 +659,190 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             }\n         }\n     }\n+\n+    fn nonterminal_to_string(&self, nt: &Nonterminal) -> String {\n+        match *nt {\n+            token::NtExpr(ref e) => self.expr_to_string(e),\n+            token::NtMeta(ref e) => self.attr_item_to_string(e),\n+            token::NtTy(ref e) => self.ty_to_string(e),\n+            token::NtPath(ref e) => self.path_to_string(e),\n+            token::NtItem(ref e) => self.item_to_string(e),\n+            token::NtBlock(ref e) => self.block_to_string(e),\n+            token::NtStmt(ref e) => self.stmt_to_string(e),\n+            token::NtPat(ref e) => self.pat_to_string(e),\n+            token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n+            token::NtLifetime(e) => e.to_string(),\n+            token::NtLiteral(ref e) => self.expr_to_string(e),\n+            token::NtTT(ref tree) => self.tt_to_string(tree),\n+            token::NtVis(ref e) => self.vis_to_string(e),\n+        }\n+    }\n+\n+    /// Print the token kind precisely, without converting `$crate` into its respective crate name.\n+    fn token_kind_to_string(&self, tok: &TokenKind) -> String {\n+        self.token_kind_to_string_ext(tok, None)\n+    }\n+\n+    fn token_kind_to_string_ext(\n+        &self,\n+        tok: &TokenKind,\n+        convert_dollar_crate: Option<Span>,\n+    ) -> String {\n+        match *tok {\n+            token::Eq => \"=\".to_string(),\n+            token::Lt => \"<\".to_string(),\n+            token::Le => \"<=\".to_string(),\n+            token::EqEq => \"==\".to_string(),\n+            token::Ne => \"!=\".to_string(),\n+            token::Ge => \">=\".to_string(),\n+            token::Gt => \">\".to_string(),\n+            token::Not => \"!\".to_string(),\n+            token::Tilde => \"~\".to_string(),\n+            token::OrOr => \"||\".to_string(),\n+            token::AndAnd => \"&&\".to_string(),\n+            token::BinOp(op) => binop_to_string(op).to_string(),\n+            token::BinOpEq(op) => format!(\"{}=\", binop_to_string(op)),\n+\n+            /* Structural symbols */\n+            token::At => \"@\".to_string(),\n+            token::Dot => \".\".to_string(),\n+            token::DotDot => \"..\".to_string(),\n+            token::DotDotDot => \"...\".to_string(),\n+            token::DotDotEq => \"..=\".to_string(),\n+            token::Comma => \",\".to_string(),\n+            token::Semi => \";\".to_string(),\n+            token::Colon => \":\".to_string(),\n+            token::ModSep => \"::\".to_string(),\n+            token::RArrow => \"->\".to_string(),\n+            token::LArrow => \"<-\".to_string(),\n+            token::FatArrow => \"=>\".to_string(),\n+            token::OpenDelim(token::Paren) => \"(\".to_string(),\n+            token::CloseDelim(token::Paren) => \")\".to_string(),\n+            token::OpenDelim(token::Bracket) => \"[\".to_string(),\n+            token::CloseDelim(token::Bracket) => \"]\".to_string(),\n+            token::OpenDelim(token::Brace) => \"{\".to_string(),\n+            token::CloseDelim(token::Brace) => \"}\".to_string(),\n+            token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim) => \"\".to_string(),\n+            token::Pound => \"#\".to_string(),\n+            token::Dollar => \"$\".to_string(),\n+            token::Question => \"?\".to_string(),\n+            token::SingleQuote => \"'\".to_string(),\n+\n+            /* Literals */\n+            token::Literal(lit) => literal_to_string(lit),\n+\n+            /* Name components */\n+            token::Ident(s, is_raw) => {\n+                IdentPrinter::new(s, is_raw, convert_dollar_crate).to_string()\n+            }\n+            token::Lifetime(s) => s.to_string(),\n+\n+            /* Other */\n+            token::DocComment(comment_kind, attr_style, data) => {\n+                doc_comment_to_string(comment_kind, attr_style, data)\n+            }\n+            token::Eof => \"<eof>\".to_string(),\n+\n+            token::Interpolated(ref nt) => self.nonterminal_to_string(nt),\n+        }\n+    }\n+\n+    /// Print the token precisely, without converting `$crate` into its respective crate name.\n+    fn token_to_string(&self, token: &Token) -> String {\n+        self.token_to_string_ext(token, false)\n+    }\n+\n+    fn token_to_string_ext(&self, token: &Token, convert_dollar_crate: bool) -> String {\n+        let convert_dollar_crate = convert_dollar_crate.then_some(token.span);\n+        self.token_kind_to_string_ext(&token.kind, convert_dollar_crate)\n+    }\n+\n+    fn ty_to_string(&self, ty: &ast::Ty) -> String {\n+        self.to_string(|s| s.print_type(ty))\n+    }\n+\n+    fn bounds_to_string(&self, bounds: &[ast::GenericBound]) -> String {\n+        self.to_string(|s| s.print_type_bounds(\"\", bounds))\n+    }\n+\n+    fn pat_to_string(&self, pat: &ast::Pat) -> String {\n+        self.to_string(|s| s.print_pat(pat))\n+    }\n+\n+    fn expr_to_string(&self, e: &ast::Expr) -> String {\n+        self.to_string(|s| s.print_expr(e))\n+    }\n+\n+    fn tt_to_string(&self, tt: &TokenTree) -> String {\n+        self.to_string(|s| s.print_tt(tt, false))\n+    }\n+\n+    fn tts_to_string(&self, tokens: &TokenStream) -> String {\n+        self.to_string(|s| s.print_tts(tokens, false))\n+    }\n+\n+    fn stmt_to_string(&self, stmt: &ast::Stmt) -> String {\n+        self.to_string(|s| s.print_stmt(stmt))\n+    }\n+\n+    fn item_to_string(&self, i: &ast::Item) -> String {\n+        self.to_string(|s| s.print_item(i))\n+    }\n+\n+    fn generic_params_to_string(&self, generic_params: &[ast::GenericParam]) -> String {\n+        self.to_string(|s| s.print_generic_params(generic_params))\n+    }\n+\n+    fn path_to_string(&self, p: &ast::Path) -> String {\n+        self.to_string(|s| s.print_path(p, false, 0))\n+    }\n+\n+    fn path_segment_to_string(&self, p: &ast::PathSegment) -> String {\n+        self.to_string(|s| s.print_path_segment(p, false))\n+    }\n+\n+    fn vis_to_string(&self, v: &ast::Visibility) -> String {\n+        self.to_string(|s| s.print_visibility(v))\n+    }\n+\n+    fn block_to_string(&self, blk: &ast::Block) -> String {\n+        self.to_string(|s| {\n+            // Containing cbox, will be closed by `print_block` at `}`.\n+            s.cbox(INDENT_UNIT);\n+            // Head-ibox, will be closed by `print_block` after `{`.\n+            s.ibox(0);\n+            s.print_block(blk)\n+        })\n+    }\n+\n+    fn meta_list_item_to_string(&self, li: &ast::NestedMetaItem) -> String {\n+        self.to_string(|s| s.print_meta_list_item(li))\n+    }\n+\n+    fn attr_item_to_string(&self, ai: &ast::AttrItem) -> String {\n+        self.to_string(|s| s.print_attr_item(ai, ai.path.span))\n+    }\n+\n+    fn attribute_to_string(&self, attr: &ast::Attribute) -> String {\n+        self.to_string(|s| s.print_attribute(attr))\n+    }\n+\n+    fn param_to_string(&self, arg: &ast::Param) -> String {\n+        self.to_string(|s| s.print_param(arg, false))\n+    }\n+\n+    fn to_string(&self, f: impl FnOnce(&mut State<'_>)) -> String {\n+        let mut printer = State::new();\n+        printer.insert_extra_parens = self.insert_extra_parens();\n+        f(&mut printer);\n+        printer.s.eof()\n+    }\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n+    fn insert_extra_parens(&self) -> bool {\n+        self.insert_extra_parens\n+    }\n     fn comments(&mut self) -> &mut Option<Comments<'a>> {\n         &mut self.comments\n     }\n@@ -856,6 +878,20 @@ impl<'a> PrintState<'a> for State<'a> {\n }\n \n impl<'a> State<'a> {\n+    pub fn new() -> State<'a> {\n+        State {\n+            s: pp::mk_printer(),\n+            comments: None,\n+            ann: &NoAnn,\n+            is_expanded: false,\n+            insert_extra_parens: true,\n+        }\n+    }\n+\n+    pub(super) fn without_insert_extra_parens() -> State<'a> {\n+        State { insert_extra_parens: false, ..State::new() }\n+    }\n+\n     // Synthesizes a comment that was not textually present in the original source\n     // file.\n     pub fn synth_comment(&mut self, text: String) {\n@@ -1139,7 +1175,7 @@ impl<'a> State<'a> {\n                 self.print_fn_full(sig, item.ident, gen, &item.vis, def, body, &item.attrs);\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n-                self.head(to_string(|s| {\n+                self.head(self.to_string(|s| {\n                     s.print_visibility(&item.vis);\n                     s.print_unsafety(_mod.unsafety);\n                     s.word(\"mod\");\n@@ -1158,7 +1194,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {\n-                self.head(to_string(|s| {\n+                self.head(self.to_string(|s| {\n                     s.print_unsafety(nmod.unsafety);\n                     s.word(\"extern\");\n                 }));\n@@ -1366,7 +1402,7 @@ impl<'a> State<'a> {\n                 ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\"),\n             },\n             ast::VisibilityKind::Restricted { ref path, .. } => {\n-                let path = to_string(|s| s.print_path(path, false, 0));\n+                let path = self.to_string(|s| s.print_path(path, false, 0));\n                 if path == \"self\" || path == \"super\" {\n                     self.word_nbsp(format!(\"pub({})\", path))\n                 } else {\n@@ -1658,7 +1694,8 @@ impl<'a> State<'a> {\n     }\n \n     /// Prints `expr` or `(expr)` when `needs_par` holds.\n-    fn print_expr_cond_paren(&mut self, expr: &ast::Expr, needs_par: bool) {\n+    fn print_expr_cond_paren(&mut self, expr: &ast::Expr, mut needs_par: bool) {\n+        needs_par &= self.insert_extra_parens;\n         if needs_par {\n             self.popen();\n         }", "previous_filename": "compiler/rustc_ast_pretty/src/pprust.rs"}, {"sha": "72011f04d9a77309a40d10b8b916656dc9f80272", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -141,6 +141,9 @@ impl std::ops::DerefMut for State<'_> {\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n+    fn insert_extra_parens(&self) -> bool {\n+        true\n+    }\n     fn comments(&mut self) -> &mut Option<Comments<'a>> {\n         &mut self.comments\n     }"}, {"sha": "cceaa08daa4a18d2d0993909b443881e5077da92", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 69, "deletions": 9, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -7,7 +7,7 @@\n #![feature(or_patterns)]\n \n use rustc_ast as ast;\n-use rustc_ast::token::{self, Nonterminal, Token, TokenKind};\n+use rustc_ast::token::{self, DelimToken, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n@@ -297,7 +297,11 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     };\n \n     // FIXME(#43081): Avoid this pretty-print + reparse hack\n-    let source = pprust::nonterminal_to_string(nt);\n+    // Pretty-print the AST struct without inserting any parenthesis\n+    // beyond those explicitly written by the user (e.g. `ExpnKind::Paren`).\n+    // The resulting stream may have incorrect precedence, but it's only\n+    // ever used for a comparison against the capture tokenstream.\n+    let source = pprust::nonterminal_to_string_no_extra_parens(nt);\n     let filename = FileName::macro_expansion_source_code(&source);\n     let reparsed_tokens = parse_stream_from_source_str(filename, source, sess, Some(span));\n \n@@ -325,15 +329,43 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     // modifications, including adding/removing typically non-semantic\n     // tokens such as extra braces and commas, don't happen.\n     if let Some(tokens) = tokens {\n-        if tokenstream_probably_equal_for_proc_macro(&tokens, &reparsed_tokens, sess) {\n+        // Compare with a non-relaxed delim match to start.\n+        if tokenstream_probably_equal_for_proc_macro(&tokens, &reparsed_tokens, sess, false) {\n             return tokens;\n         }\n+\n+        // The check failed. This time, we pretty-print the AST struct with parenthesis\n+        // inserted to preserve precedence. This may cause `None`-delimiters in the captured\n+        // token stream to match up with inserted parenthesis in the reparsed stream.\n+        let source_with_parens = pprust::nonterminal_to_string(nt);\n+        let filename_with_parens = FileName::macro_expansion_source_code(&source_with_parens);\n+        let reparsed_tokens_with_parens = parse_stream_from_source_str(\n+            filename_with_parens,\n+            source_with_parens,\n+            sess,\n+            Some(span),\n+        );\n+\n+        // Compare with a relaxed delim match - we want inserted parenthesis in the\n+        // reparsed stream to match `None`-delimiters in the original stream.\n+        if tokenstream_probably_equal_for_proc_macro(\n+            &tokens,\n+            &reparsed_tokens_with_parens,\n+            sess,\n+            true,\n+        ) {\n+            return tokens;\n+        }\n+\n         info!(\n             \"cached tokens found, but they're not \\\"probably equal\\\", \\\n                 going with stringified version\"\n         );\n-        info!(\"cached tokens: {:?}\", tokens);\n-        info!(\"reparsed tokens: {:?}\", reparsed_tokens);\n+        info!(\"cached   tokens: {}\", pprust::tts_to_string(&tokens));\n+        info!(\"reparsed tokens: {}\", pprust::tts_to_string(&reparsed_tokens_with_parens));\n+\n+        info!(\"cached   tokens debug: {:?}\", tokens);\n+        info!(\"reparsed tokens debug: {:?}\", reparsed_tokens_with_parens);\n     }\n     reparsed_tokens\n }\n@@ -347,6 +379,7 @@ pub fn tokenstream_probably_equal_for_proc_macro(\n     tokens: &TokenStream,\n     reparsed_tokens: &TokenStream,\n     sess: &ParseSess,\n+    relaxed_delim_match: bool,\n ) -> bool {\n     // When checking for `probably_eq`, we ignore certain tokens that aren't\n     // preserved in the AST. Because they are not preserved, the pretty\n@@ -472,7 +505,9 @@ pub fn tokenstream_probably_equal_for_proc_macro(\n     let tokens = tokens.trees().flat_map(|t| expand_token(t, sess));\n     let reparsed_tokens = reparsed_tokens.trees().flat_map(|t| expand_token(t, sess));\n \n-    tokens.eq_by(reparsed_tokens, |t, rt| tokentree_probably_equal_for_proc_macro(&t, &rt, sess))\n+    tokens.eq_by(reparsed_tokens, |t, rt| {\n+        tokentree_probably_equal_for_proc_macro(&t, &rt, sess, relaxed_delim_match)\n+    })\n }\n \n // See comments in `Nonterminal::to_tokenstream` for why we care about\n@@ -484,6 +519,7 @@ pub fn tokentree_probably_equal_for_proc_macro(\n     token: &TokenTree,\n     reparsed_token: &TokenTree,\n     sess: &ParseSess,\n+    relaxed_delim_match: bool,\n ) -> bool {\n     match (token, reparsed_token) {\n         (TokenTree::Token(token), TokenTree::Token(reparsed_token)) => {\n@@ -492,9 +528,33 @@ pub fn tokentree_probably_equal_for_proc_macro(\n         (\n             TokenTree::Delimited(_, delim, tokens),\n             TokenTree::Delimited(_, reparsed_delim, reparsed_tokens),\n-        ) => {\n-            delim == reparsed_delim\n-                && tokenstream_probably_equal_for_proc_macro(tokens, reparsed_tokens, sess)\n+        ) if delim == reparsed_delim => tokenstream_probably_equal_for_proc_macro(\n+            tokens,\n+            reparsed_tokens,\n+            sess,\n+            relaxed_delim_match,\n+        ),\n+        (TokenTree::Delimited(_, DelimToken::NoDelim, tokens), reparsed_token) => {\n+            if relaxed_delim_match {\n+                if let TokenTree::Delimited(_, DelimToken::Paren, reparsed_tokens) = reparsed_token\n+                {\n+                    if tokenstream_probably_equal_for_proc_macro(\n+                        tokens,\n+                        reparsed_tokens,\n+                        sess,\n+                        relaxed_delim_match,\n+                    ) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            tokens.len() == 1\n+                && tokentree_probably_equal_for_proc_macro(\n+                    &tokens.trees().next().unwrap(),\n+                    reparsed_token,\n+                    sess,\n+                    relaxed_delim_match,\n+                )\n         }\n         _ => false,\n     }"}, {"sha": "28fef65da070aa095da5ebc36f586c20f02dc47c", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -1114,6 +1114,7 @@ symbols! {\n         try_trait,\n         tt,\n         tuple,\n+        tuple_from_req,\n         tuple_indexing,\n         two_phase,\n         ty,"}, {"sha": "2d4f6010012df08ba599f39c4b1ce04973386cc8", "filename": "src/test/ui/proc-macro/group-compat-hack/actix-web-2.0.0/src/extract.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Factix-web-2.0.0%2Fsrc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Factix-web-2.0.0%2Fsrc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Factix-web-2.0.0%2Fsrc%2Fextract.rs?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -0,0 +1,7 @@\n+// ignore-test this is not a test\n+\n+macro_rules! tuple_from_req {\n+    ($T:ident) => {\n+        #[my_macro] struct Three($T);\n+    }\n+}"}, {"sha": "2d4f6010012df08ba599f39c4b1ce04973386cc8", "filename": "src/test/ui/proc-macro/group-compat-hack/actix-web/src/extract.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Factix-web%2Fsrc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Factix-web%2Fsrc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Factix-web%2Fsrc%2Fextract.rs?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -0,0 +1,7 @@\n+// ignore-test this is not a test\n+\n+macro_rules! tuple_from_req {\n+    ($T:ident) => {\n+        #[my_macro] struct Three($T);\n+    }\n+}"}, {"sha": "9ec6aba63f35fee0d89eced1e2e6ac86fc72579d", "filename": "src/test/ui/proc-macro/group-compat-hack/actori-web-2.0.0/src/extract.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Factori-web-2.0.0%2Fsrc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Factori-web-2.0.0%2Fsrc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Factori-web-2.0.0%2Fsrc%2Fextract.rs?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -0,0 +1,7 @@\n+// ignore-test this is not a test\n+\n+macro_rules! tuple_from_req {\n+    ($T:ident) => {\n+        #[my_macro] struct Four($T);\n+    }\n+}"}, {"sha": "9ec6aba63f35fee0d89eced1e2e6ac86fc72579d", "filename": "src/test/ui/proc-macro/group-compat-hack/actori-web/src/extract.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Factori-web%2Fsrc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Factori-web%2Fsrc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Factori-web%2Fsrc%2Fextract.rs?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -0,0 +1,7 @@\n+// ignore-test this is not a test\n+\n+macro_rules! tuple_from_req {\n+    ($T:ident) => {\n+        #[my_macro] struct Four($T);\n+    }\n+}"}, {"sha": "652fabf34ac3d9b1012c8e9329a2e5298bf8ab95", "filename": "src/test/ui/proc-macro/group-compat-hack/group-compat-hack.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.rs?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -45,5 +45,33 @@ mod with_version {\n     other!(Foo);\n }\n \n+mod actix_web_test {\n+    include!(\"actix-web/src/extract.rs\");\n+\n+    struct Foo;\n+    tuple_from_req!(Foo);\n+}\n+\n+mod actix_web_version_test {\n+    include!(\"actix-web-2.0.0/src/extract.rs\");\n+\n+    struct Foo;\n+    tuple_from_req!(Foo);\n+}\n+\n+mod actori_web_test {\n+    include!(\"actori-web/src/extract.rs\");\n+\n+    struct Foo;\n+    tuple_from_req!(Foo);\n+}\n+\n+mod actori_web_version_test {\n+    include!(\"actori-web-2.0.0/src/extract.rs\");\n+\n+    struct Foo;\n+    tuple_from_req!(Foo);\n+}\n+\n \n fn main() {}"}, {"sha": "c6b18ab674baacb55cca44b20d6f7c7395cd3a0c", "filename": "src/test/ui/proc-macro/group-compat-hack/group-compat-hack.stdout", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.stdout?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -4,3 +4,7 @@ Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/gro\n Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/time-macros-impl-0.1.0/src/lib.rs:5:21: 5:27 (#20) }, Ident { ident: \"One\", span: $DIR/time-macros-impl-0.1.0/src/lib.rs:5:28: 5:31 (#20) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:43:18: 43:21 (#0) }], span: $DIR/time-macros-impl-0.1.0/src/lib.rs:5:31: 5:38 (#20) }, Punct { ch: ';', spacing: Alone, span: $DIR/time-macros-impl-0.1.0/src/lib.rs:5:38: 5:39 (#20) }]\n Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/js-sys-0.3.17/src/lib.rs:5:21: 5:27 (#24) }, Ident { ident: \"Two\", span: $DIR/js-sys-0.3.17/src/lib.rs:5:28: 5:31 (#24) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:44:13: 44:16 (#0) }], span: $DIR/js-sys-0.3.17/src/lib.rs:5:31: 5:38 (#24) }, Punct { ch: ';', spacing: Alone, span: $DIR/js-sys-0.3.17/src/lib.rs:5:38: 5:39 (#24) }]\n Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/group-compat-hack.rs:38:25: 38:31 (#28) }, Ident { ident: \"Three\", span: $DIR/group-compat-hack.rs:38:32: 38:37 (#28) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: None, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:45:12: 45:15 (#0) }], span: $DIR/group-compat-hack.rs:38:38: 38:43 (#28) }], span: $DIR/group-compat-hack.rs:38:37: 38:44 (#28) }, Punct { ch: ';', spacing: Alone, span: $DIR/group-compat-hack.rs:38:44: 38:45 (#28) }]\n+Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/actix-web/src/extract.rs:5:21: 5:27 (#33) }, Ident { ident: \"Three\", span: $DIR/actix-web/src/extract.rs:5:28: 5:33 (#33) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:52:21: 52:24 (#0) }], span: $DIR/actix-web/src/extract.rs:5:33: 5:37 (#33) }, Punct { ch: ';', spacing: Alone, span: $DIR/actix-web/src/extract.rs:5:37: 5:38 (#33) }]\n+Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/actix-web-2.0.0/src/extract.rs:5:21: 5:27 (#38) }, Ident { ident: \"Three\", span: $DIR/actix-web-2.0.0/src/extract.rs:5:28: 5:33 (#38) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:59:21: 59:24 (#0) }], span: $DIR/actix-web-2.0.0/src/extract.rs:5:33: 5:37 (#38) }, Punct { ch: ';', spacing: Alone, span: $DIR/actix-web-2.0.0/src/extract.rs:5:37: 5:38 (#38) }]\n+Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/actori-web/src/extract.rs:5:21: 5:27 (#43) }, Ident { ident: \"Four\", span: $DIR/actori-web/src/extract.rs:5:28: 5:32 (#43) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:66:21: 66:24 (#0) }], span: $DIR/actori-web/src/extract.rs:5:32: 5:36 (#43) }, Punct { ch: ';', spacing: Alone, span: $DIR/actori-web/src/extract.rs:5:36: 5:37 (#43) }]\n+Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/actori-web-2.0.0/src/extract.rs:5:21: 5:27 (#48) }, Ident { ident: \"Four\", span: $DIR/actori-web-2.0.0/src/extract.rs:5:28: 5:32 (#48) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:73:21: 73:24 (#0) }], span: $DIR/actori-web-2.0.0/src/extract.rs:5:32: 5:36 (#48) }, Punct { ch: ';', spacing: Alone, span: $DIR/actori-web-2.0.0/src/extract.rs:5:36: 5:37 (#48) }]"}, {"sha": "faa93787d1385416cbc392d9302525b0b936db53", "filename": "src/test/ui/proc-macro/issue-75734-pp-paren.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75734-pp-paren.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75734-pp-paren.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75734-pp-paren.rs?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -0,0 +1,26 @@\n+// Regression test for issue #75734\n+// Ensures that we don't lose tokens when pretty-printing would\n+// normally insert extra parentheses.\n+\n+// check-pass\n+// aux-build:test-macros.rs\n+// compile-flags: -Z span-debug\n+\n+#![no_std] // Don't load unnecessary hygiene information from std\n+extern crate std;\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+macro_rules! mul_2 {\n+    ($val:expr) => {\n+        print_bang!($val * 2);\n+    };\n+}\n+\n+\n+#[print_attr]\n+fn main() {\n+    &|_: u8| {};\n+    mul_2!(1 + 1);\n+}"}, {"sha": "b33b85f1705f571defc259bafbc636bf87436fab", "filename": "src/test/ui/proc-macro/issue-75734-pp-paren.stdout", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75734-pp-paren.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75734-pp-paren.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-75734-pp-paren.stdout?ref=4ba5068815137eef403383582d3f17f3b6802217", "patch": "@@ -0,0 +1,134 @@\n+PRINT-ATTR INPUT (DISPLAY): fn main() { & | _ : u8 | { } ; mul_2 ! (1 + 1) ; }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Ident {\n+        ident: \"fn\",\n+        span: $DIR/issue-75734-pp-paren.rs:23:1: 23:3 (#0),\n+    },\n+    Ident {\n+        ident: \"main\",\n+        span: $DIR/issue-75734-pp-paren.rs:23:4: 23:8 (#0),\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [],\n+        span: $DIR/issue-75734-pp-paren.rs:23:8: 23:10 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [\n+            Punct {\n+                ch: '&',\n+                spacing: Joint,\n+                span: $DIR/issue-75734-pp-paren.rs:24:5: 24:6 (#0),\n+            },\n+            Punct {\n+                ch: '|',\n+                spacing: Alone,\n+                span: $DIR/issue-75734-pp-paren.rs:24:6: 24:7 (#0),\n+            },\n+            Ident {\n+                ident: \"_\",\n+                span: $DIR/issue-75734-pp-paren.rs:24:7: 24:8 (#0),\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Alone,\n+                span: $DIR/issue-75734-pp-paren.rs:24:8: 24:9 (#0),\n+            },\n+            Ident {\n+                ident: \"u8\",\n+                span: $DIR/issue-75734-pp-paren.rs:24:10: 24:12 (#0),\n+            },\n+            Punct {\n+                ch: '|',\n+                spacing: Alone,\n+                span: $DIR/issue-75734-pp-paren.rs:24:12: 24:13 (#0),\n+            },\n+            Group {\n+                delimiter: Brace,\n+                stream: TokenStream [],\n+                span: $DIR/issue-75734-pp-paren.rs:24:14: 24:16 (#0),\n+            },\n+            Punct {\n+                ch: ';',\n+                spacing: Alone,\n+                span: $DIR/issue-75734-pp-paren.rs:24:16: 24:17 (#0),\n+            },\n+            Ident {\n+                ident: \"mul_2\",\n+                span: $DIR/issue-75734-pp-paren.rs:25:5: 25:10 (#0),\n+            },\n+            Punct {\n+                ch: '!',\n+                spacing: Alone,\n+                span: $DIR/issue-75734-pp-paren.rs:25:10: 25:11 (#0),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [\n+                    Literal {\n+                        kind: Integer,\n+                        symbol: \"1\",\n+                        suffix: None,\n+                        span: $DIR/issue-75734-pp-paren.rs:25:12: 25:13 (#0),\n+                    },\n+                    Punct {\n+                        ch: '+',\n+                        spacing: Alone,\n+                        span: $DIR/issue-75734-pp-paren.rs:25:14: 25:15 (#0),\n+                    },\n+                    Literal {\n+                        kind: Integer,\n+                        symbol: \"1\",\n+                        suffix: None,\n+                        span: $DIR/issue-75734-pp-paren.rs:25:16: 25:17 (#0),\n+                    },\n+                ],\n+                span: $DIR/issue-75734-pp-paren.rs:25:11: 25:18 (#0),\n+            },\n+            Punct {\n+                ch: ';',\n+                spacing: Alone,\n+                span: $DIR/issue-75734-pp-paren.rs:25:18: 25:19 (#0),\n+            },\n+        ],\n+        span: $DIR/issue-75734-pp-paren.rs:23:11: 26:2 (#0),\n+    },\n+]\n+PRINT-BANG INPUT (DISPLAY): 1 + 1 * 2\n+PRINT-BANG INPUT (DEBUG): TokenStream [\n+    Group {\n+        delimiter: None,\n+        stream: TokenStream [\n+            Literal {\n+                kind: Integer,\n+                symbol: \"1\",\n+                suffix: None,\n+                span: $DIR/issue-75734-pp-paren.rs:25:12: 25:13 (#0),\n+            },\n+            Punct {\n+                ch: '+',\n+                spacing: Alone,\n+                span: $DIR/issue-75734-pp-paren.rs:25:14: 25:15 (#0),\n+            },\n+            Literal {\n+                kind: Integer,\n+                symbol: \"1\",\n+                suffix: None,\n+                span: $DIR/issue-75734-pp-paren.rs:25:16: 25:17 (#0),\n+            },\n+        ],\n+        span: $DIR/issue-75734-pp-paren.rs:17:21: 17:25 (#7),\n+    },\n+    Punct {\n+        ch: '*',\n+        spacing: Alone,\n+        span: $DIR/issue-75734-pp-paren.rs:17:26: 17:27 (#7),\n+    },\n+    Literal {\n+        kind: Integer,\n+        symbol: \"2\",\n+        suffix: None,\n+        span: $DIR/issue-75734-pp-paren.rs:17:28: 17:29 (#7),\n+    },\n+]"}]}