{"sha": "bf809768ee8ff3ea4ef434721ff82b09a4df261a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmODA5NzY4ZWU4ZmYzZWE0ZWY0MzQ3MjFmZjgyYjA5YTRkZjI2MWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-10T23:32:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-10T23:32:18Z"}, "message": "auto merge of #8444 : erickt/rust/rollup, r=cmr\n\nThis merges these PR together:\r\n\r\n#8430: r=thestinger \r\n#8370: r=thestinger\r\n#8386: r=bstrie\r\n#8388: r=thestinger\r\n#8390: r=graydon\r\n#8394: r=graydon\r\n#8402: r=thestinger\r\n#8403: r=catamorphism", "tree": {"sha": "f7492e25ff06c4eeb3d1e480f641344b306c4247", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7492e25ff06c4eeb3d1e480f641344b306c4247"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf809768ee8ff3ea4ef434721ff82b09a4df261a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf809768ee8ff3ea4ef434721ff82b09a4df261a", "html_url": "https://github.com/rust-lang/rust/commit/bf809768ee8ff3ea4ef434721ff82b09a4df261a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf809768ee8ff3ea4ef434721ff82b09a4df261a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b9e1ce75a3e1416f2db80d30f65879fd902183f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b9e1ce75a3e1416f2db80d30f65879fd902183f", "html_url": "https://github.com/rust-lang/rust/commit/8b9e1ce75a3e1416f2db80d30f65879fd902183f"}, {"sha": "20953bb1fbfafc3839e739f38ddf7d495eb1fe8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b", "html_url": "https://github.com/rust-lang/rust/commit/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b"}], "stats": {"total": 765, "additions": 594, "deletions": 171}, "files": [{"sha": "f4264b0d5afc36d21b4ea116f6a607a9ad933fda", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -1305,7 +1305,7 @@ match crayons[0] {\n A vector can be destructured using pattern matching:\n \n ~~~~\n-let numbers: [int, ..3] = [1, 2, 3];\n+let numbers: &[int] = &[1, 2, 3];\n let score = match numbers {\n     [] => 0,\n     [a] => a * 10,\n@@ -2195,7 +2195,7 @@ use std::float::consts::pi;\n # impl Shape for CircleStruct { fn area(&self) -> float { pi * square(self.radius) } }\n \n let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f};\n-let mycircle: Circle = concrete as @Circle;\n+let mycircle: @Circle = concrete as @Circle;\n let nonsense = mycircle.radius() * mycircle.area();\n ~~~\n "}, {"sha": "ecb223f896c37f668901c0a9c228f9451626c742", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -29,6 +29,11 @@\n \n     table))\n \n+(defcustom rust-indent-offset default-tab-width\n+  \"*Indent Rust code by this number of spaces.\n+\n+The initializer is `DEFAULT-TAB-WIDTH'.\")\n+\n (defun rust-paren-level () (nth 0 (syntax-ppss)))\n (defun rust-in-str-or-cmnt () (nth 8 (syntax-ppss)))\n (defun rust-rewind-past-str-cmnt () (goto-char (nth 8 (syntax-ppss))))\n@@ -49,10 +54,10 @@\n            (let ((level (rust-paren-level)))\n              (cond\n               ;; A function return type is 1 level indented\n-              ((looking-at \"->\") (* default-tab-width (+ level 1)))\n+              ((looking-at \"->\") (* rust-indent-offset (+ level 1)))\n \n               ;; A closing brace is 1 level unindended\n-              ((looking-at \"}\") (* default-tab-width (- level 1)))\n+              ((looking-at \"}\") (* rust-indent-offset (- level 1)))\n \n               ;; If we're in any other token-tree / sexp, then:\n               ;;  - [ or ( means line up with the opening token\n@@ -70,18 +75,18 @@\n                      (goto-char pt)\n                      (back-to-indentation)\n                      (if (looking-at \"\\\\<else\\\\>\")\n-                         (* default-tab-width (+ 1 level))\n+                         (* rust-indent-offset (+ 1 level))\n                        (progn\n                          (goto-char pt)\n                          (beginning-of-line)\n                          (rust-rewind-irrelevant)\n                          (end-of-line)\n                          (if (looking-back \"[{};,]\")\n-                             (* default-tab-width level)\n+                             (* rust-indent-offset level)\n                            (back-to-indentation)\n                            (if (looking-at \"#\")\n-                               (* default-tab-width level)\n-                             (* default-tab-width (+ 1 level))))))))))\n+                               (* rust-indent-offset level)\n+                             (* rust-indent-offset (+ 1 level))))))))))\n \n               ;; Otherwise we're in a column-zero definition\n               (t 0))))))"}, {"sha": "37f45142a1107f189c9eb5f897018ab255164ac0", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -255,6 +255,9 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                 }\n                 not_useful\n               }\n+              ty::ty_evec(_, ty::vstore_fixed(n)) => {\n+                is_useful_specialized(cx, m, v, vec(n), n, left_ty)\n+              }\n               ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n                 let max_len = do m.rev_iter().fold(0) |max_len, r| {\n                   match r[0].node {\n@@ -409,6 +412,29 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n         else if true_found { Some(val(const_bool(false))) }\n         else { Some(val(const_bool(true))) }\n       }\n+      ty::ty_evec(_, ty::vstore_fixed(n)) => {\n+        let mut missing = true;\n+        let mut wrong = false;\n+        for r in m.iter() {\n+          match r[0].node {\n+            pat_vec(ref before, ref slice, ref after) => {\n+              let count = before.len() + after.len();\n+              if (count < n && slice.is_none()) || count > n {\n+                wrong = true;\n+              }\n+              if count == n || (count < n && slice.is_some()) {\n+                missing = false;\n+              }\n+            }\n+            _ => {}\n+          }\n+        }\n+        match (wrong, missing) {\n+          (true, _) => Some(vec(n)), // should be compile-time error\n+          (_, true) => Some(vec(n)),\n+          _         => None\n+        }\n+      }\n       ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n \n         // Find the lengths and slices of all vector patterns."}, {"sha": "a4b88870b97390deb3140287e71cf3542563af34", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -403,6 +403,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     // Ditto\n                     match ty::get(ty::type_autoderef(tcx, ty::expr_ty(tcx,\n                                                           base))).sty {\n+                        ty_enum(id, _) |\n                         ty_struct(id, _)\n                         if id.crate != LOCAL_CRATE ||\n                            !privileged_items.iter().any(|x| x == &(id.node)) => {"}, {"sha": "c98d859337c3e4a2bf116a3c951b137030595cda", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 165, "deletions": 50, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -145,6 +145,51 @@\n  * - `store_non_ref_bindings()`\n  * - `insert_lllocals()`\n  *\n+ *\n+ * ## Notes on vector pattern matching.\n+ *\n+ * Vector pattern matching is surprisingly tricky. The problem is that\n+ * the structure of the vector isn't fully known, and slice matches\n+ * can be done on subparts of it.\n+ *\n+ * The way that vector pattern matches are dealt with, then, is as\n+ * follows. First, we make the actual condition associated with a\n+ * vector pattern simply a vector length comparison. So the pattern\n+ * [1, .. x] gets the condition \"vec len >= 1\", and the pattern\n+ * [.. x] gets the condition \"vec len >= 0\". The problem here is that\n+ * having the condition \"vec len >= 1\" hold clearly does not mean that\n+ * only a pattern that has exactly that condition will match. This\n+ * means that it may well be the case that a condition holds, but none\n+ * of the patterns matching that condition match; to deal with this,\n+ * when doing vector length matches, we have match failures proceed to\n+ * the next condition to check.\n+ *\n+ * There are a couple more subtleties to deal with. While the \"actual\"\n+ * condition associated with vector length tests is simply a test on\n+ * the vector length, the actual vec_len Opt entry contains more\n+ * information used to restrict which matches are associated with it.\n+ * So that all matches in a submatch are matching against the same\n+ * values from inside the vector, they are split up by how many\n+ * elements they match at the front and at the back of the vector. In\n+ * order to make sure that arms are properly checked in order, even\n+ * with the overmatching conditions, each vec_len Opt entry is\n+ * associated with a range of matches.\n+ * Consider the following:\n+ *\n+ *   match &[1, 2, 3] {\n+ *       [1, 1, .. _] => 0,\n+ *       [1, 2, 2, .. _] => 1,\n+ *       [1, 2, 3, .. _] => 2,\n+ *       [1, 2, .. _] => 3,\n+ *       _ => 4\n+ *   }\n+ * The proper arm to match is arm 2, but arms 0 and 3 both have the\n+ * condition \"len >= 2\". If arm 3 was lumped in with arm 0, then the\n+ * wrong branch would be taken. Instead, vec_len Opts are associated\n+ * with a contiguous range of matches that have the same \"shape\".\n+ * This is sort of ugly and requires a bunch of special handling of\n+ * vec_len options.\n+ *\n  */\n \n \n@@ -189,14 +234,19 @@ enum Lit {\n     ConstLit(ast::def_id),              // the def ID of the constant\n }\n \n+#[deriving(Eq)]\n+pub enum VecLenOpt {\n+    vec_len_eq,\n+    vec_len_ge(/* length of prefix */uint)\n+}\n+\n // An option identifying a branch (either a literal, a enum variant or a\n // range)\n enum Opt {\n     lit(Lit),\n     var(/* disr val */ uint, @adt::Repr),\n     range(@ast::expr, @ast::expr),\n-    vec_len_eq(uint),\n-    vec_len_ge(uint, /* slice */uint)\n+    vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n \n fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n@@ -247,9 +297,9 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n             }\n         }\n         (&var(a, _), &var(b, _)) => a == b,\n-            (&vec_len_eq(a), &vec_len_eq(b)) => a == b,\n-            (&vec_len_ge(a, _), &vec_len_ge(b, _)) => a == b,\n-            _ => false\n+        (&vec_len(a1, a2, _), &vec_len(b1, b2, _)) =>\n+            a1 == b1 && a2 == b2,\n+        _ => false\n     }\n }\n \n@@ -283,10 +333,10 @@ fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n             return range_result(rslt(bcx, consts::const_expr(ccx, l1)),\n                                 rslt(bcx, consts::const_expr(ccx, l2)));\n         }\n-        vec_len_eq(n) => {\n+        vec_len(n, vec_len_eq, _) => {\n             return single_result(rslt(bcx, C_int(ccx, n as int)));\n         }\n-        vec_len_ge(n, _) => {\n+        vec_len(n, vec_len_ge(_), _) => {\n             return lower_bound(rslt(bcx, C_int(ccx, n as int)));\n         }\n     }\n@@ -471,10 +521,11 @@ fn enter_match<'r>(bcx: @mut Block,\n }\n \n fn enter_default<'r>(bcx: @mut Block,\n-                         dm: DefMap,\n-                         m: &[Match<'r>],\n-                         col: uint,\n-                         val: ValueRef)\n+                     dm: DefMap,\n+                     m: &[Match<'r>],\n+                     col: uint,\n+                     val: ValueRef,\n+                     chk: Option<mk_fail>)\n                       -> ~[Match<'r>] {\n     debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n@@ -483,13 +534,36 @@ fn enter_default<'r>(bcx: @mut Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    // Collect all of the matches that can match against anything.\n+    let matches = do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n           ast::pat_wild | ast::pat_tup(_) => Some(~[]),\n           ast::pat_ident(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n           _ => None\n         }\n-    }\n+    };\n+\n+    // Ok, now, this is pretty subtle. A \"default\" match is a match\n+    // that needs to be considered if none of the actual checks on the\n+    // value being considered succeed. The subtlety lies in that sometimes\n+    // identifier/wildcard matches are *not* default matches. Consider:\n+    // \"match x { _ if something => foo, true => bar, false => baz }\".\n+    // There is a wildcard match, but it is *not* a default case. The boolean\n+    // case on the value being considered is exhaustive. If the case is\n+    // exhaustive, then there are no defaults.\n+    //\n+    // We detect whether the case is exhaustive in the following\n+    // somewhat kludgy way: if the last wildcard/binding match has a\n+    // guard, then by non-redundancy, we know that there aren't any\n+    // non guarded matches, and thus by exhaustiveness, we know that\n+    // we don't need any default cases. If the check *isn't* nonexhaustive\n+    // (because chk is Some), then we need the defaults anyways.\n+    let is_exhaustive = match matches.last_opt() {\n+        Some(m) if m.data.arm.guard.is_some() && chk.is_none() => true,\n+        _ => false\n+    };\n+\n+    if is_exhaustive { ~[] } else { matches }\n }\n \n // <pcwalton> nmatsakis: what does enter_opt do?\n@@ -523,17 +597,19 @@ fn enter_opt<'r>(bcx: @mut Block,\n                      variant_size: uint,\n                      val: ValueRef)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_opt(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug!(\"enter_opt(bcx=%s, m=%s, opt=%?, col=%u, val=%s)\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n+           *opt,\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n     let tcx = bcx.tcx();\n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let mut i = 0;\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n-        match p.node {\n+        let answer = match p.node {\n             ast::pat_enum(*) |\n             ast::pat_ident(_, _, None) if pat_is_const(tcx.def_map, p) => {\n                 let const_def = tcx.def_map.get_copy(&p.id);\n@@ -599,32 +675,53 @@ fn enter_opt<'r>(bcx: @mut Block,\n                 }\n             }\n             ast::pat_vec(ref before, slice, ref after) => {\n+                let (lo, hi) = match *opt {\n+                    vec_len(_, _, (lo, hi)) => (lo, hi),\n+                    _ => tcx.sess.span_bug(p.span,\n+                                           \"vec pattern but not vec opt\")\n+                };\n+\n                 match slice {\n-                    Some(slice) => {\n+                    Some(slice) if i >= lo && i <= hi => {\n                         let n = before.len() + after.len();\n-                        let i = before.len();\n-                        if opt_eq(tcx, &vec_len_ge(n, i), opt) {\n+                        let this_opt = vec_len(n, vec_len_ge(before.len()),\n+                                               (lo, hi));\n+                        if opt_eq(tcx, &this_opt, opt) {\n                             Some(vec::append_one((*before).clone(), slice) +\n                                     *after)\n                         } else {\n                             None\n                         }\n                     }\n-                    None => {\n+                    None if i >= lo && i <= hi => {\n                         let n = before.len();\n-                        if opt_eq(tcx, &vec_len_eq(n), opt) {\n+                        if opt_eq(tcx, &vec_len(n, vec_len_eq, (lo,hi)), opt) {\n                             Some((*before).clone())\n                         } else {\n                             None\n                         }\n                     }\n+                    _ => None\n                 }\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                Some(vec::from_elem(variant_size, dummy))\n+                // In most cases, a binding/wildcard match be\n+                // considered to match against any Opt. However, when\n+                // doing vector pattern matching, submatches are\n+                // considered even if the eventual match might be from\n+                // a different submatch. Thus, when a submatch fails\n+                // when doing a vector match, we proceed to the next\n+                // submatch. Thus, including a default match would\n+                // cause the default match to fire spuriously.\n+                match *opt {\n+                    vec_len(*) => None,\n+                    _ => Some(vec::from_elem(variant_size, dummy))\n+                }\n             }\n-        }\n+        };\n+        i += 1;\n+        answer\n     }\n }\n \n@@ -805,9 +902,25 @@ fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n+    // Vector comparisions are special in that since the actual\n+    // conditions over-match, we need to be careful about them. This\n+    // means that in order to properly handle things in order, we need\n+    // to not always merge conditions.\n+    fn add_veclen_to_set(set: &mut ~[Opt], i: uint,\n+                         len: uint, vlo: VecLenOpt) {\n+        match set.last_opt() {\n+            // If the last condition in the list matches the one we want\n+            // to add, then extend its range. Otherwise, make a new\n+            // vec_len with a range just covering the new entry.\n+            Some(&vec_len(len2, vlo2, (start, end)))\n+                 if len == len2 && vlo == vlo2 =>\n+                 set[set.len() - 1] = vec_len(len, vlo, (start, end+1)),\n+            _ => set.push(vec_len(len, vlo, (i, i)))\n+        }\n+    }\n \n     let mut found = ~[];\n-    for br in m.iter() {\n+    for (i, br) in m.iter().enumerate() {\n         let cur = br.pats[col];\n         match cur.node {\n             ast::pat_lit(l) => {\n@@ -852,12 +965,12 @@ fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n                 add_to_set(ccx.tcx, &mut found, range(l1, l2));\n             }\n             ast::pat_vec(ref before, slice, ref after) => {\n-                let opt = match slice {\n-                    None => vec_len_eq(before.len()),\n-                    Some(_) => vec_len_ge(before.len() + after.len(),\n-                                          before.len())\n+                let (len, vec_opt) = match slice {\n+                    None => (before.len(), vec_len_eq),\n+                    Some(_) => (before.len() + after.len(),\n+                                vec_len_ge(before.len()))\n                 };\n-                add_to_set(ccx.tcx, &mut found, opt);\n+                add_veclen_to_set(&mut found, i, len, vec_opt);\n             }\n             _ => {}\n         }\n@@ -1075,13 +1188,13 @@ fn pick_col(m: &[Match]) -> uint {\n     }\n     let mut scores = vec::from_elem(m[0].pats.len(), 0u);\n     for br in m.iter() {\n-        let mut i = 0u;\n-        for p in br.pats.iter() { scores[i] += score(*p); i += 1u; }\n+        for (i, p) in br.pats.iter().enumerate() {\n+            scores[i] += score(*p);\n+        }\n     }\n     let mut max_score = 0u;\n     let mut best_col = 0u;\n-    let mut i = 0u;\n-    for score in scores.iter() {\n+    for (i, score) in scores.iter().enumerate() {\n         let score = *score;\n \n         // Irrefutable columns always go first, they'd only be duplicated in\n@@ -1090,7 +1203,6 @@ fn pick_col(m: &[Match]) -> uint {\n         // If no irrefutable ones are found, we pick the one with the biggest\n         // branching factor.\n         if score > max_score { max_score = score; best_col = i; }\n-        i += 1u;\n     }\n     return best_col;\n }\n@@ -1460,7 +1572,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                 test_val = Load(bcx, val);\n                 kind = compare;\n             },\n-            vec_len_eq(*) | vec_len_ge(*) => {\n+            vec_len(*) => {\n                 let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n                 let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n                 let (_, len) = tvec::get_base_and_len(\n@@ -1487,16 +1599,19 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n         C_int(ccx, 0) // Placeholder for when not using a switch\n     };\n \n-    let defaults = enter_default(else_cx, dm, m, col, val);\n+    let defaults = enter_default(else_cx, dm, m, col, val, chk);\n     let exhaustive = chk.is_none() && defaults.len() == 0u;\n     let len = opts.len();\n-    let mut i = 0u;\n \n     // Compile subtrees for each option\n-    for opt in opts.iter() {\n-        i += 1u;\n+    for (i, opt) in opts.iter().enumerate() {\n+        // In some cases in vector pattern matching, we need to override\n+        // the failure case so that instead of failing, it proceeds to\n+        // try more matching. branch_chk, then, is the proper failure case\n+        // for the current conditional branch.\n+        let mut branch_chk = chk;\n         let mut opt_cx = else_cx;\n-        if !exhaustive || i < len {\n+        if !exhaustive || i+1 < len {\n             opt_cx = sub_block(bcx, \"match_case\");\n             match kind {\n               single => Br(bcx, opt_cx.llbb),\n@@ -1586,6 +1701,10 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                       }\n                   };\n                   bcx = sub_block(after_cx, \"compare_vec_len_next\");\n+\n+                  // If none of these subcases match, move on to the\n+                  // next condition.\n+                  branch_chk = Some::<mk_fail>(|| bcx.llbb);\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               _ => ()\n@@ -1604,17 +1723,13 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                 unpacked = argvals;\n                 opt_cx = new_bcx;\n             }\n-            vec_len_eq(n) | vec_len_ge(n, _) => {\n-                let n = match *opt {\n-                    vec_len_ge(*) => n + 1u,\n-                    _ => n\n-                };\n-                let slice = match *opt {\n-                    vec_len_ge(_, i) => Some(i),\n-                    _ => None\n+            vec_len(n, vt, _) => {\n+                let (n, slice) = match vt {\n+                    vec_len_ge(i) => (n + 1u, Some(i)),\n+                    vec_len_eq => (n, None)\n                 };\n-                let args = extract_vec_elems(opt_cx, pat_span, pat_id, n, slice,\n-                                             val, test_val);\n+                let args = extract_vec_elems(opt_cx, pat_span, pat_id, n,\n+                                             slice, val, test_val);\n                 size = args.vals.len();\n                 unpacked = args.vals.clone();\n                 opt_cx = args.bcx;\n@@ -1623,7 +1738,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n         }\n         let opt_ms = enter_opt(opt_cx, m, opt, col, size, val);\n         let opt_vals = vec::append(unpacked, vals_left);\n-        compile_submatch(opt_cx, opt_ms, opt_vals, chk);\n+        compile_submatch(opt_cx, opt_ms, opt_vals, branch_chk);\n     }\n \n     // Compile the fall-through case, if any"}, {"sha": "da1fb9abaeeb6aa0b9d158c3073d5bc9e8e758dc", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -156,6 +156,53 @@ impl<T> TrieMap<T> {\n             remaining_max: self.length\n         }\n     }\n+\n+    // If `upper` is true then returns upper_bound else returns lower_bound.\n+    #[inline]\n+    fn bound_iter<'a>(&'a self, key: uint, upper: bool) -> TrieMapIterator<'a, T> {\n+        let mut node: &'a TrieNode<T> = &self.root;\n+        let mut idx = 0;\n+        let mut it = TrieMapIterator {\n+            stack: ~[],\n+            remaining_min: 0,\n+            remaining_max: self.length\n+        };\n+        loop {\n+            let children = &node.children;\n+            let child_id = chunk(key, idx);\n+            match children[child_id] {\n+                Internal(ref n) => {\n+                    node = &**n;\n+                    it.stack.push(children.slice_from(child_id + 1).iter());\n+                }\n+                External(stored, _) => {\n+                    if stored < key || (upper && stored == key) {\n+                        it.stack.push(children.slice_from(child_id + 1).iter());\n+                    } else {\n+                        it.stack.push(children.slice_from(child_id).iter());\n+                    }\n+                    return it;\n+                }\n+                Nothing => {\n+                    it.stack.push(children.slice_from(child_id + 1).iter());\n+                    return it\n+                }\n+            }\n+            idx += 1;\n+        }\n+    }\n+\n+    /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n+    /// If all keys in the map are less than `key` an empty iterator is returned.\n+    pub fn lower_bound_iter<'a>(&'a self, key: uint) -> TrieMapIterator<'a, T> {\n+        self.bound_iter(key, false)\n+    }\n+\n+    /// Get an iterator pointing to the first key-value pair whose key is greater than `key`.\n+    /// If all keys in the map are not greater than `key` an empty iterator is returned.\n+    pub fn upper_bound_iter<'a>(&'a self, key: uint) -> TrieMapIterator<'a, T> {\n+        self.bound_iter(key, true)\n+    }\n }\n \n impl<T, Iter: Iterator<(uint, T)>> FromIterator<(uint, T), Iter> for TrieMap<T> {\n@@ -233,6 +280,18 @@ impl TrieSet {\n     pub fn iter<'a>(&'a self) -> TrieSetIterator<'a> {\n         TrieSetIterator{iter: self.map.iter()}\n     }\n+\n+    /// Get an iterator pointing to the first value that is not less than `val`.\n+    /// If all values in the set are less than `val` an empty iterator is returned.\n+    pub fn lower_bound_iter<'a>(&'a self, val: uint) -> TrieSetIterator<'a> {\n+        TrieSetIterator{iter: self.map.lower_bound_iter(val)}\n+    }\n+\n+    /// Get an iterator pointing to the first value that key is greater than `val`.\n+    /// If all values in the set are not greater than `val` an empty iterator is returned.\n+    pub fn upper_bound_iter<'a>(&'a self, val: uint) -> TrieSetIterator<'a> {\n+        TrieSetIterator{iter: self.map.upper_bound_iter(val)}\n+    }\n }\n \n impl<Iter: Iterator<uint>> FromIterator<uint, Iter> for TrieSet {\n@@ -645,6 +704,49 @@ mod test_map {\n         }\n         assert_eq!(i, last - first);\n     }\n+\n+    #[test]\n+    fn test_bound_iter() {\n+        let empty_map : TrieMap<uint> = TrieMap::new();\n+        assert_eq!(empty_map.lower_bound_iter(0).next(), None);\n+        assert_eq!(empty_map.upper_bound_iter(0).next(), None);\n+\n+        let last = 999u;\n+        let step = 3u;\n+        let value = 42u;\n+\n+        let mut map : TrieMap<uint> = TrieMap::new();\n+        do uint::range_step(0u, last, step as int) |x| {\n+            assert!(x % step == 0);\n+            map.insert(x, value);\n+            true\n+        };\n+\n+        for i in range(0u, last - step) {\n+            let mut lb = map.lower_bound_iter(i);\n+            let mut ub = map.upper_bound_iter(i);\n+            let next_key = i - i % step + step;\n+            let next_pair = (next_key, &value);\n+            if (i % step == 0) {\n+                assert_eq!(lb.next(), Some((i, &value)));\n+            } else {\n+                assert_eq!(lb.next(), Some(next_pair));\n+            }\n+            assert_eq!(ub.next(), Some(next_pair));\n+        }\n+\n+        let mut lb = map.lower_bound_iter(last - step);\n+        assert_eq!(lb.next(), Some((last - step, &value)));\n+        let mut ub = map.upper_bound_iter(last - step);\n+        assert_eq!(ub.next(), None);\n+\n+        for i in range(last - step + 1, last) {\n+            let mut lb = map.lower_bound_iter(i);\n+            assert_eq!(lb.next(), None);\n+            let mut ub = map.upper_bound_iter(i);\n+            assert_eq!(ub.next(), None);\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "dfaffa0c2759dd3fc2e52329f1c5b4dfe61a45f3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -421,12 +421,12 @@ pub enum MapChain<K,V> {\n // get the map from an env frame\n impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     // Constructor. I don't think we need a zero-arg one.\n-    fn new(init: ~HashMap<K,@V>) -> @mut MapChain<K,V> {\n+    pub fn new(init: ~HashMap<K,@V>) -> @mut MapChain<K,V> {\n         @mut BaseMapChain(init)\n     }\n \n     // add a new frame to the environment (functionally)\n-    fn push_frame (@mut self) -> @mut MapChain<K,V> {\n+    pub fn push_frame (@mut self) -> @mut MapChain<K,V> {\n         @mut ConsMapChain(~HashMap::new() ,self)\n     }\n \n@@ -436,7 +436,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n \n     // ugh: can't get this to compile with mut because of the\n     // lack of flow sensitivity.\n-    fn get_map<'a>(&'a self) -> &'a HashMap<K,@V> {\n+    pub fn get_map<'a>(&'a self) -> &'a HashMap<K,@V> {\n         match *self {\n             BaseMapChain (~ref map) => map,\n             ConsMapChain (~ref map,_) => map\n@@ -446,7 +446,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n // traits just don't work anywhere...?\n //impl Map<Name,SyntaxExtension> for MapChain {\n \n-    fn contains_key (&self, key: &K) -> bool {\n+    pub fn contains_key (&self, key: &K) -> bool {\n         match *self {\n             BaseMapChain (ref map) => map.contains_key(key),\n             ConsMapChain (ref map,ref rest) =>\n@@ -457,17 +457,17 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     // should each_key and each_value operate on shadowed\n     // names? I think not.\n     // delaying implementing this....\n-    fn each_key (&self, _f: &fn (&K)->bool) {\n+    pub fn each_key (&self, _f: &fn (&K)->bool) {\n         fail!(\"unimplemented 2013-02-15T10:01\");\n     }\n \n-    fn each_value (&self, _f: &fn (&V) -> bool) {\n+    pub fn each_value (&self, _f: &fn (&V) -> bool) {\n         fail!(\"unimplemented 2013-02-15T10:02\");\n     }\n \n     // Returns a copy of the value that the name maps to.\n     // Goes down the chain 'til it finds one (or bottom out).\n-    fn find (&self, key: &K) -> Option<@V> {\n+    pub fn find (&self, key: &K) -> Option<@V> {\n         match self.get_map().find (key) {\n             Some(ref v) => Some(**v),\n             None => match *self {\n@@ -477,7 +477,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n         }\n     }\n \n-    fn find_in_topmost_frame(&self, key: &K) -> Option<@V> {\n+    pub fn find_in_topmost_frame(&self, key: &K) -> Option<@V> {\n         let map = match *self {\n             BaseMapChain(ref map) => map,\n             ConsMapChain(ref map,_) => map\n@@ -487,7 +487,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     }\n \n     // insert the binding into the top-level map\n-    fn insert (&mut self, key: K, ext: @V) -> bool {\n+    pub fn insert (&mut self, key: K, ext: @V) -> bool {\n         // can't abstract over get_map because of flow sensitivity...\n         match *self {\n             BaseMapChain (~ref mut map) => map.insert(key, ext),\n@@ -499,7 +499,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     // ... there are definitely some opportunities for abstraction\n     // here that I'm ignoring. (e.g., manufacturing a predicate on\n     // the maps in the chain, and using an abstract \"find\".\n-    fn insert_into_frame(&mut self, key: K, ext: @V, n: K, pred: &fn(&@V)->bool) {\n+    pub fn insert_into_frame(&mut self, key: K, ext: @V, n: K, pred: &fn(&@V)->bool) {\n         match *self {\n             BaseMapChain (~ref mut map) => {\n                 if satisfies_pred(map,&n,pred) {"}, {"sha": "918949113ad0c3237ba134fa404a2edc19bb2387", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -17,6 +17,7 @@ use codemap;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n use parse::parser::Parser;\n+use parse::attr::parser_attr;\n use parse::token::{Token, EOF, to_str, nonterminal, get_ident_interner, ident_to_str};\n use parse::token;\n \n@@ -430,6 +431,7 @@ pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n                      + token::to_str(get_ident_interner(), p.token))\n       },\n       \"path\" => token::nt_path(p.parse_path_with_tps(false)),\n+      \"attr\" => token::nt_attr(@p.parse_attribute(false)),\n       \"tt\" => {\n         *p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n         let res = token::nt_tt(@p.parse_token_tree());"}, {"sha": "3a10206b513f8920d7adbc84a2310cb9f91b423c", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -36,7 +36,7 @@ pub fn from<T>(t: ~[T]) -> OptVec<T> {\n }\n \n impl<T> OptVec<T> {\n-    fn push(&mut self, t: T) {\n+    pub fn push(&mut self, t: T) {\n         match *self {\n             Vec(ref mut v) => {\n                 v.push(t);\n@@ -50,52 +50,52 @@ impl<T> OptVec<T> {\n         *self = Vec(~[t]);\n     }\n \n-    fn map<U>(&self, op: &fn(&T) -> U) -> OptVec<U> {\n+    pub fn map<U>(&self, op: &fn(&T) -> U) -> OptVec<U> {\n         match *self {\n             Empty => Empty,\n             Vec(ref v) => Vec(v.map(op))\n         }\n     }\n \n-    fn map_move<U>(self, op: &fn(T) -> U) -> OptVec<U> {\n+    pub fn map_move<U>(self, op: &fn(T) -> U) -> OptVec<U> {\n         match self {\n             Empty => Empty,\n             Vec(v) => Vec(v.move_iter().map(op).collect())\n         }\n     }\n \n-    fn get<'a>(&'a self, i: uint) -> &'a T {\n+    pub fn get<'a>(&'a self, i: uint) -> &'a T {\n         match *self {\n             Empty => fail!(\"Invalid index %u\", i),\n             Vec(ref v) => &v[i]\n         }\n     }\n \n-    fn is_empty(&self) -> bool {\n+    pub fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n \n-    fn len(&self) -> uint {\n+    pub fn len(&self) -> uint {\n         match *self {\n             Empty => 0,\n             Vec(ref v) => v.len()\n         }\n     }\n \n     #[inline]\n-    fn iter<'r>(&'r self) -> OptVecIterator<'r, T> {\n+    pub fn iter<'r>(&'r self) -> OptVecIterator<'r, T> {\n         match *self {\n             Empty => OptVecIterator{iter: None},\n             Vec(ref v) => OptVecIterator{iter: Some(v.iter())}\n         }\n     }\n \n     #[inline]\n-    fn map_to_vec<B>(&self, op: &fn(&T) -> B) -> ~[B] {\n+    pub fn map_to_vec<B>(&self, op: &fn(&T) -> B) -> ~[B] {\n         self.iter().map(op).collect()\n     }\n \n-    fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {\n+    pub fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {\n         let mut index = 0;\n         self.map_to_vec(|a| {\n             let i = index;\n@@ -113,7 +113,7 @@ pub fn take_vec<T>(v: OptVec<T>) -> ~[T] {\n }\n \n impl<T:Clone> OptVec<T> {\n-    fn prepend(&self, t: T) -> OptVec<T> {\n+    pub fn prepend(&self, t: T) -> OptVec<T> {\n         let mut v0 = ~[t];\n         match *self {\n             Empty => {}\n@@ -124,7 +124,7 @@ impl<T:Clone> OptVec<T> {\n }\n \n impl<A:Eq> Eq for OptVec<A> {\n-    fn eq(&self, other: &OptVec<A>) -> bool {\n+    pub fn eq(&self, other: &OptVec<A>) -> bool {\n         // Note: cannot use #[deriving(Eq)] here because\n         // (Empty, Vec(~[])) ought to be equal.\n         match (self, other) {\n@@ -135,7 +135,7 @@ impl<A:Eq> Eq for OptVec<A> {\n         }\n     }\n \n-    fn ne(&self, other: &OptVec<A>) -> bool {\n+    pub fn ne(&self, other: &OptVec<A>) -> bool {\n         !self.eq(other)\n     }\n }"}, {"sha": "f2489d80e1e69fe83681f1ea2be16c8af8a450a8", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 74, "deletions": 57, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -9,21 +9,17 @@\n // except according to those terms.\n \n use ast;\n-use codemap::spanned;\n+use codemap::{spanned, mk_sp};\n use codemap::BytePos;\n use parse::common::*; //resolve bug?\n use parse::token;\n use parse::parser::Parser;\n+use parse::token::INTERPOLATED;\n \n // a parser that can parse attributes.\n pub trait parser_attr {\n     fn parse_outer_attributes(&self) -> ~[ast::Attribute];\n-    fn parse_attribute(&self, style: ast::AttrStyle) -> ast::Attribute;\n-    fn parse_attribute_naked(\n-        &self,\n-        style: ast::AttrStyle,\n-        lo: BytePos\n-    ) -> ast::Attribute;\n+    fn parse_attribute(&self, permit_inner: bool) -> ast::Attribute;\n     fn parse_inner_attrs_and_next(&self) ->\n         (~[ast::Attribute], ~[ast::Attribute]);\n     fn parse_meta_item(&self) -> @ast::MetaItem;\n@@ -37,12 +33,17 @@ impl parser_attr for Parser {\n     fn parse_outer_attributes(&self) -> ~[ast::Attribute] {\n         let mut attrs: ~[ast::Attribute] = ~[];\n         loop {\n+            debug!(\"parse_outer_attributes: self.token=%?\",\n+                   self.token);\n             match *self.token {\n+              token::INTERPOLATED(token::nt_attr(*)) => {\n+                attrs.push(self.parse_attribute(false));\n+              }\n               token::POUND => {\n                 if self.look_ahead(1, |t| *t != token::LBRACKET) {\n                     break;\n                 }\n-                attrs.push(self.parse_attribute(ast::AttrOuter));\n+                attrs.push(self.parse_attribute(false));\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n@@ -62,23 +63,49 @@ impl parser_attr for Parser {\n         return attrs;\n     }\n \n-    // matches attribute = # attribute_naked\n-    fn parse_attribute(&self, style: ast::AttrStyle) -> ast::Attribute {\n-        let lo = self.span.lo;\n-        self.expect(&token::POUND);\n-        return self.parse_attribute_naked(style, lo);\n+    // matches attribute = # [ meta_item ]\n+    //\n+    // if permit_inner is true, then a trailing `;` indicates an inner\n+    // attribute\n+    fn parse_attribute(&self, permit_inner: bool) -> ast::Attribute {\n+        debug!(\"parse_attributes: permit_inner=%? self.token=%?\",\n+               permit_inner, self.token);\n+        let (span, value) = match *self.token {\n+            INTERPOLATED(token::nt_attr(attr)) => {\n+                assert!(attr.node.style == ast::AttrOuter);\n+                self.bump();\n+                (attr.span, attr.node.value)\n+            }\n+            token::POUND => {\n+                let lo = self.span.lo;\n+                self.bump();\n+                self.expect(&token::LBRACKET);\n+                let meta_item = self.parse_meta_item();\n+                self.expect(&token::RBRACKET);\n+                let hi = self.span.hi;\n+                (mk_sp(lo, hi), meta_item)\n+            }\n+            _ => {\n+                self.fatal(fmt!(\"expected `#` but found `%s`\",\n+                                self.this_token_to_str()));\n+            }\n+        };\n+        let style = if permit_inner && *self.token == token::SEMI {\n+            self.bump();\n+            ast::AttrInner\n+        } else {\n+            ast::AttrOuter\n+        };\n+        return spanned {\n+            span: span,\n+            node: ast::Attribute_ {\n+                style: style,\n+                value: value,\n+                is_sugared_doc: false\n+            }\n+        };\n     }\n \n-    // matches attribute_naked = [ meta_item ]\n-    fn parse_attribute_naked(&self, style: ast::AttrStyle, lo: BytePos) ->\n-        ast::Attribute {\n-        self.expect(&token::LBRACKET);\n-        let meta_item = self.parse_meta_item();\n-        self.expect(&token::RBRACKET);\n-        let hi = self.span.hi;\n-        return spanned(lo, hi, ast::Attribute_ { style: style,\n-                                                 value: meta_item, is_sugared_doc: false }); }\n-\n     // Parse attributes that appear after the opening of an item, each\n     // terminated by a semicolon. In addition to a vector of inner attributes,\n     // this function also returns a vector that may contain the first outer\n@@ -89,47 +116,37 @@ impl parser_attr for Parser {\n     // matches inner_attrs* outer_attr?\n     // you can make the 'next' field an Option, but the result is going to be\n     // more useful as a vector.\n-    fn parse_inner_attrs_and_next(&self) ->\n-        (~[ast::Attribute], ~[ast::Attribute]) {\n+    fn parse_inner_attrs_and_next(&self)\n+                                  -> (~[ast::Attribute], ~[ast::Attribute]) {\n         let mut inner_attrs: ~[ast::Attribute] = ~[];\n         let mut next_outer_attrs: ~[ast::Attribute] = ~[];\n         loop {\n-            match *self.token {\n-              token::POUND => {\n-                if self.look_ahead(1, |t| *t != token::LBRACKET) {\n-                    // This is an extension\n-                    break;\n+            let attr = match *self.token {\n+                token::INTERPOLATED(token::nt_attr(*)) => {\n+                    self.parse_attribute(true)\n+                }\n+                token::POUND => {\n+                    if self.look_ahead(1, |t| *t != token::LBRACKET) {\n+                        // This is an extension\n+                        break;\n+                    }\n+                    self.parse_attribute(true)\n                 }\n-                let attr = self.parse_attribute(ast::AttrInner);\n-                if *self.token == token::SEMI {\n+                token::DOC_COMMENT(s) => {\n                     self.bump();\n-                    inner_attrs.push(attr);\n-                } else {\n-                    // It's not really an inner attribute\n-                    let outer_attr =\n-                        spanned(attr.span.lo, attr.span.hi,\n-                            ast::Attribute_ { style: ast::AttrOuter,\n-                                              value: attr.node.value,\n-                                              is_sugared_doc: false });\n-                    next_outer_attrs.push(outer_attr);\n-                    break;\n+                    ::attr::mk_sugared_doc_attr(self.id_to_str(s),\n+                                                self.span.lo,\n+                                                self.span.hi)\n                 }\n-              }\n-              token::DOC_COMMENT(s) => {\n-                let attr = ::attr::mk_sugared_doc_attr(\n-                    self.id_to_str(s),\n-                    self.span.lo,\n-                    self.span.hi\n-                );\n-                self.bump();\n-                if attr.node.style == ast::AttrInner {\n-                  inner_attrs.push(attr);\n-                } else {\n-                  next_outer_attrs.push(attr);\n-                  break;\n+                _ => {\n+                    break;\n                 }\n-              }\n-              _ => break\n+            };\n+            if attr.node.style == ast::AttrInner {\n+                inner_attrs.push(attr);\n+            } else {\n+                next_outer_attrs.push(attr);\n+                break;\n             }\n         }\n         (inner_attrs, next_outer_attrs)"}, {"sha": "bde568b2610c2c5bd69288a0792f0d2bb4bb1f56", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -129,7 +129,11 @@ impl reader for StringReader {\n \n impl reader for TtReader {\n     fn is_eof(@mut self) -> bool { self.cur_tok == token::EOF }\n-    fn next_token(@mut self) -> TokenAndSpan { tt_next_token(self) }\n+    fn next_token(@mut self) -> TokenAndSpan {\n+        let r = tt_next_token(self);\n+        debug!(\"TtReader: r=%?\", r);\n+        return r;\n+    }\n     fn fatal(@mut self, m: ~str) -> ! {\n         self.sp_diag.span_fatal(self.cur_span, m);\n     }"}, {"sha": "77c50a779c03fcd11edb0f82882e804e807f7c66", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[macro_escape];\n+\n use abi;\n use abi::AbiSet;\n use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil};\n@@ -4460,7 +4462,17 @@ impl Parser {\n                                attrs: ~[Attribute],\n                                macros_allowed: bool)\n                                -> item_or_view_item {\n-        maybe_whole!(iovi self, nt_item);\n+        match *self.token {\n+            INTERPOLATED(token::nt_item(item)) => {\n+                self.bump();\n+                let new_attrs = vec::append(attrs, item.attrs);\n+                return iovi_item(@ast::item {\n+                        attrs: new_attrs,\n+                        ..(*item).clone()});\n+            }\n+            _ => {}\n+        }\n+\n         let lo = self.span.lo;\n \n         let visibility = self.parse_non_priv_visibility();"}, {"sha": "c554f111bf9a0d2997257d4021ba019b0651c48f", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -105,6 +105,7 @@ pub enum nonterminal {\n     nt_expr(@ast::expr),\n     nt_ty(   ast::Ty),\n     nt_ident(ast::ident, bool),\n+    nt_attr(@ast::Attribute),   // #[foo]\n     nt_path( ast::Path),\n     nt_tt(  @ast::token_tree), //needs @ed to break a circularity\n     nt_matchers(~[ast::matcher])\n@@ -205,13 +206,15 @@ pub fn to_str(input: @ident_interner, t: &Token) -> ~str {\n       INTERPOLATED(ref nt) => {\n         match nt {\n             &nt_expr(e) => ::print::pprust::expr_to_str(e, input),\n+            &nt_attr(e) => ::print::pprust::attribute_to_str(e, input),\n             _ => {\n                 ~\"an interpolated \" +\n                     match (*nt) {\n                       nt_item(*) => ~\"item\",\n                       nt_block(*) => ~\"block\",\n                       nt_stmt(*) => ~\"statement\",\n                       nt_pat(*) => ~\"pattern\",\n+                      nt_attr(*) => fail!(\"should have been handled\"),\n                       nt_expr(*) => fail!(\"should have been handled above\"),\n                       nt_ty(*) => ~\"type\",\n                       nt_ident(*) => ~\"identifier\","}, {"sha": "8290f62bada26aed8db31e617f91a21765dcebbb", "filename": "src/test/auxiliary/xc_private_method_lib.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fauxiliary%2Fxc_private_method_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fauxiliary%2Fxc_private_method_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxc_private_method_lib.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -1,9 +1,33 @@\n #[crate_type=\"lib\"];\n \n-pub struct Foo {\n+pub struct Struct {\n     x: int\n }\n \n-impl Foo {\n-    fn new() -> Foo { Foo { x: 1 } }\n+impl Struct {\n+    fn static_meth_struct() -> Struct {\n+        Struct { x: 1 }\n+    }\n+\n+    fn meth_struct(&self) -> int {\n+        self.x\n+    }\n+}\n+\n+pub enum Enum {\n+    Variant1(int),\n+    Variant2(int)\n+}\n+\n+impl Enum {\n+    fn static_meth_enum() -> Enum {\n+        Variant2(10)\n+    }\n+\n+    fn meth_enum(&self) -> int {\n+        match *self {\n+            Variant1(x) |\n+            Variant2(x) => x\n+        }\n+    }\n }"}, {"sha": "0f67d8a6d0c4bbcd8977cbd510db72ce2c4b0b1d", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -6,7 +6,7 @@ struct Foo {\n }\n \n pub fn main() {\n-    let x = [\n+    let x = ~[\n         Foo { string: ~\"foo\" },\n         Foo { string: ~\"bar\" },\n         Foo { string: ~\"baz\" }"}, {"sha": "ca20d68e4cdcbde130e1e448ab4ef9cec03edeab", "filename": "src/test/compile-fail/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -1,5 +1,5 @@\n fn a() -> &[int] {\n-    let vec = [1, 2, 3, 4];\n+    let vec = ~[1, 2, 3, 4];\n     let tail = match vec {\n         [_, ..tail] => tail, //~ ERROR does not live long enough\n         _ => fail!(\"a\")\n@@ -8,7 +8,7 @@ fn a() -> &[int] {\n }\n \n fn b() -> &[int] {\n-    let vec = [1, 2, 3, 4];\n+    let vec = ~[1, 2, 3, 4];\n     let init = match vec {\n         [..init, _] => init, //~ ERROR does not live long enough\n         _ => fail!(\"b\")\n@@ -17,7 +17,7 @@ fn b() -> &[int] {\n }\n \n fn c() -> &[int] {\n-    let vec = [1, 2, 3, 4];\n+    let vec = ~[1, 2, 3, 4];\n     let slice = match vec {\n         [_, ..slice, _] => slice, //~ ERROR does not live long enough\n         _ => fail!(\"c\")"}, {"sha": "02ba1b9d2fffb634f41b8336a5aedfc7bbccfe71", "filename": "src/test/compile-fail/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -1,24 +1,24 @@\n fn a() {\n-    let mut vec = [~1, ~2, ~3];\n+    let mut vec = ~[~1, ~2, ~3];\n     match vec {\n         [~ref _a] => {\n-            vec[0] = ~4; //~ ERROR cannot assign to `vec[]` because it is borrowed\n+            vec[0] = ~4; //~ ERROR cannot assign to `(*vec)[]` because it is borrowed\n         }\n         _ => fail!(\"foo\")\n     }\n }\n \n fn b() {\n-    let mut vec = [~1, ~2, ~3];\n+    let mut vec = ~[~1, ~2, ~3];\n     match vec {\n         [.._b] => {\n-            vec[0] = ~4; //~ ERROR cannot assign to `vec[]` because it is borrowed\n+            vec[0] = ~4; //~ ERROR cannot assign to `(*vec)[]` because it is borrowed\n         }\n     }\n }\n \n fn c() {\n-    let mut vec = [~1, ~2, ~3];\n+    let mut vec = ~[~1, ~2, ~3];\n     match vec {\n         [_a, .._b] => {\n             //~^ ERROR cannot move out\n@@ -35,7 +35,7 @@ fn c() {\n }\n \n fn d() {\n-    let mut vec = [~1, ~2, ~3];\n+    let mut vec = ~[~1, ~2, ~3];\n     match vec {\n         [.._a, _b] => {\n             //~^ ERROR cannot move out\n@@ -46,7 +46,7 @@ fn d() {\n }\n \n fn e() {\n-    let mut vec = [~1, ~2, ~3];\n+    let mut vec = ~[~1, ~2, ~3];\n     match vec {\n         [_a, _b, _c] => {}\n         _ => {}"}, {"sha": "87511c34172cd16f05203bc8e99df819c27844bd", "filename": "src/test/compile-fail/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -1,5 +1,5 @@\n fn a() -> &int {\n-    let vec = [1, 2, 3, 4];\n+    let vec = ~[1, 2, 3, 4];\n     let tail = match vec {\n         [_a, ..tail] => &tail[0], //~ ERROR borrowed value does not live long enough\n         _ => fail!(\"foo\")"}, {"sha": "95000f4aa229ddbe8e133929c21d5d3f721ec5f8", "filename": "src/test/compile-fail/macro-inner-attributes.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -0,0 +1,21 @@\n+macro_rules! test ( ($nm:ident,\n+                     $a:attr,\n+                     $i:item) => (mod $nm { $a; $i }); )\n+\n+test!(a,\n+      #[cfg(qux)],\n+      pub fn bar() { })\n+\n+test!(b,\n+      #[cfg(not(qux))],\n+      pub fn bar() { })\n+\n+#[qux]\n+fn main() {\n+    a::bar();\n+    //~^ ERROR use of undeclared module `a`\n+    //~^^ ERROR unresolved name\n+    //~^^^ ERROR unresolved name `a::bar`\n+    b::bar();\n+}\n+"}, {"sha": "23c3e80cd3b2b7f5dac908484732cc4b58990001", "filename": "src/test/compile-fail/macro-outer-attributes.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -0,0 +1,19 @@\n+macro_rules! test ( ($nm:ident,\n+                     $a:attr,\n+                     $i:item) => (mod $nm { $a $i }); )\n+\n+test!(a,\n+      #[cfg(qux)],\n+      pub fn bar() { })\n+\n+test!(b,\n+      #[cfg(not(qux))],\n+      pub fn bar() { })\n+\n+// test1!(#[bar])\n+#[qux]\n+fn main() {\n+    a::bar(); //~ ERROR unresolved name `a::bar`\n+    b::bar();\n+}\n+"}, {"sha": "b3e139805a0d90fc9771d5237a9953a118d5bf26", "filename": "src/test/compile-fail/match-vec-fixed.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fmatch-vec-fixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fmatch-vec-fixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-fixed.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -0,0 +1,16 @@\n+fn a() {\n+    let v = [1, 2, 3];\n+    match v {\n+        [_, _, _] => {}\n+        [_, _, _] => {} //~ ERROR unreachable pattern\n+    }\n+    match v {\n+        [_, 1, _] => {}\n+        [_, 1, _] => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+}\n+\n+fn main() {\n+    a();\n+}"}, {"sha": "b557242af44c12ab592f58c11e3d914e16e81573", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -6,13 +6,13 @@ fn main() {\n         _ => ()\n     }\n \n-    match [~\"foo\", ~\"bar\", ~\"baz\"] {\n+    match ~[~\"foo\", ~\"bar\", ~\"baz\"] {\n         [a, _, _, .._] => { println(a); }\n         [~\"foo\", ~\"bar\", ~\"baz\", ~\"foo\", ~\"bar\"] => { } //~ ERROR unreachable pattern\n         _ => { }\n     }\n \n-    match ['a', 'b', 'c'] {\n+    match ~['a', 'b', 'c'] {\n         ['a', 'b', 'c', .._tail] => {}\n         ['a', 'b', 'c'] => {} //~ ERROR unreachable pattern\n         _ => {}"}, {"sha": "8314755af3b3d7195303d6aa1d34248bf0df6e79", "filename": "src/test/compile-fail/xc-private-method.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -4,5 +4,13 @@\n extern mod xc_private_method_lib;\n \n fn main() {\n-    let _ = xc_private_method_lib::Foo::new();  //~ ERROR function `new` is private\n+    // normal method on struct\n+    let _ = xc_private_method_lib::Struct{ x: 10 }.meth_struct();  //~ ERROR method `meth_struct` is private\n+    // static method on struct\n+    let _ = xc_private_method_lib::Struct::static_meth_struct();  //~ ERROR function `static_meth_struct` is private\n+\n+    // normal method on enum\n+    let _ = xc_private_method_lib::Variant1(20).meth_enum();  //~ ERROR method `meth_enum` is private\n+    // static method on enum\n+    let _ = xc_private_method_lib::Enum::static_meth_enum();  //~ ERROR function `static_meth_enum` is private\n }"}, {"sha": "206dc383cb3d50cd488db1203b6645d33f99771e", "filename": "src/test/run-pass/issue-3121.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Frun-pass%2Fissue-3121.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Frun-pass%2Fissue-3121.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3121.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n enum side { mayo, catsup, vinegar }\n enum order { hamburger, fries(side), shake }\n enum meal { to_go(order), for_here(order) }"}, {"sha": "13a8e324d43062adf5efff02efbba031ff772b86", "filename": "src/test/run-pass/vec-matching-autoslice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -1,22 +1,22 @@\n pub fn main() {\n     let x = @[1, 2, 3];\n     match x {\n-        [2, .._] => ::std::util::unreachable(),\n+        [2, .._] => fail!(),\n         [1, ..tail] => {\n             assert_eq!(tail, [2, 3]);\n         }\n-        [_] => ::std::util::unreachable(),\n-        [] => ::std::util::unreachable()\n+        [_] => fail!(),\n+        [] => fail!()\n     }\n \n     let y = (~[(1, true), (2, false)], 0.5);\n     match y {\n-        ([_, _, _], 0.5) => ::std::util::unreachable(),\n+        ([_, _, _], 0.5) => fail!(),\n         ([(1, a), (b, false), ..tail], _) => {\n             assert_eq!(a, true);\n             assert_eq!(b, 2);\n             assert!(tail.is_empty());\n         }\n-        ([..tail], _) => ::std::util::unreachable()\n+        ([..tail], _) => fail!()\n     }\n }"}, {"sha": "234311dec33159cb2cd450a678f23f91fed8705d", "filename": "src/test/run-pass/vec-matching-fixed.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Frun-pass%2Fvec-matching-fixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Frun-pass%2Fvec-matching-fixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-fixed.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -0,0 +1,28 @@\n+fn a() {\n+    let x = [1, 2, 3];\n+    match x {\n+        [1, 2, 4] => ::std::util::unreachable(),\n+        [0, 2, 3, .._] => ::std::util::unreachable(),\n+        [0, .._, 3] => ::std::util::unreachable(),\n+        [0, .._] => ::std::util::unreachable(),\n+        [1, 2, 3] => (),\n+        [_, _, _] => ::std::util::unreachable(),\n+    }\n+    match x {\n+        [.._] => (),\n+    }\n+    match x {\n+        [_, _, _, .._] => (),\n+    }\n+    match x {\n+        [a, b, c] => {\n+            assert_eq!(1, a);\n+            assert_eq!(2, b);\n+            assert_eq!(3, c);\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    a();\n+}"}, {"sha": "c09fb8d6bc7ef896ab44ad695bbc52f1dac7182a", "filename": "src/test/run-pass/vec-matching.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -1,19 +1,19 @@\n fn a() {\n-    let x = [1];\n+    let x = ~[1];\n     match x {\n-        [_, _, _, _, _, .._] => ::std::util::unreachable(),\n-        [.._, _, _, _, _] => ::std::util::unreachable(),\n-        [_, .._, _, _] => ::std::util::unreachable(),\n-        [_, _] => ::std::util::unreachable(),\n+        [_, _, _, _, _, .._] => fail!(),\n+        [.._, _, _, _, _] => fail!(),\n+        [_, .._, _, _] => fail!(),\n+        [_, _] => fail!(),\n         [a] => {\n             assert_eq!(a, 1);\n         }\n-        [] => ::std::util::unreachable()\n+        [] => fail!()\n     }\n }\n \n fn b() {\n-    let x = [1, 2, 3];\n+    let x = ~[1, 2, 3];\n     match x {\n         [a, b, ..c] => {\n             assert_eq!(a, 1);\n@@ -48,7 +48,28 @@ fn b() {\n     }\n }\n \n+fn c() {\n+    let x = [1];\n+    match x {\n+        [2, .. _] => fail!(),\n+        [.. _] => ()\n+    }\n+}\n+\n+fn d() {\n+    let x = [1, 2, 3];\n+    let branch = match x {\n+        [1, 1, .. _] => 0,\n+        [1, 2, 3, .. _] => 1,\n+        [1, 2, .. _] => 2,\n+        _ => 3\n+    };\n+    assert_eq!(branch, 1);\n+}\n+\n pub fn main() {\n     a();\n     b();\n+    c();\n+    d();\n }"}, {"sha": "6a60308f2e70f0efec1e088a98cf925ddc411bb9", "filename": "src/test/run-pass/vec-tail-matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf809768ee8ff3ea4ef434721ff82b09a4df261a/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs?ref=bf809768ee8ff3ea4ef434721ff82b09a4df261a", "patch": "@@ -3,7 +3,7 @@ struct Foo {\n }\n \n pub fn main() {\n-    let x = [\n+    let x = ~[\n         Foo { string: ~\"foo\" },\n         Foo { string: ~\"bar\" },\n         Foo { string: ~\"baz\" }"}]}