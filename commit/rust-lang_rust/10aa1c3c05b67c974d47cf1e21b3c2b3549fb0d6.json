{"sha": "10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYWExYzNjMDViNjdjOTc0ZDQ3Y2YxZTIxYjNjMmIzNTQ5ZmIwZDY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-17T21:19:25Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-19T18:56:52Z"}, "message": "test: Add fannkuch-redux and fasta-redux shootout benchmarks", "tree": {"sha": "ba3a69ba4fd8d0089fd8573fa3116c8545e6c108", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba3a69ba4fd8d0089fd8573fa3116c8545e6c108"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6", "html_url": "https://github.com/rust-lang/rust/commit/10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9738c2a45c03034f937a0b2ce7a690f64e7662eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9738c2a45c03034f937a0b2ce7a690f64e7662eb", "html_url": "https://github.com/rust-lang/rust/commit/9738c2a45c03034f937a0b2ce7a690f64e7662eb"}], "stats": {"total": 404, "additions": 322, "deletions": 82}, "files": [{"sha": "8934b6cab67c81ffb02294b20155b143a7fc0b9b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6", "patch": "@@ -12,8 +12,9 @@\n \n #[warn(non_camel_case_types)];\n \n-use container::{Container, Mutable};\n+use cast::transmute;\n use cast;\n+use container::{Container, Mutable};\n use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use iter::BaseIter;\n@@ -2137,6 +2138,7 @@ pub trait ImmutableCopyableVector<T> {\n     fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n     fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T>;\n     fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n+    unsafe fn unsafe_get(&self, elem: uint) -> T;\n }\n \n /// Extension methods for vectors\n@@ -2173,6 +2175,13 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n     fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n         partitioned(*self, f)\n     }\n+\n+    /// Returns the element at the given index, without doing bounds checking.\n+    #[inline(always)]\n+    unsafe fn unsafe_get(&self, elem: uint) -> T {\n+        let (ptr, _): (*T, uint) = transmute(*self);\n+        *ptr.offset(elem)\n+    }\n }\n \n pub trait OwnedVector<T> {\n@@ -2313,6 +2322,19 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n     }\n }\n \n+pub trait MutableVector<T> {\n+    unsafe fn unsafe_set(&self, elem: uint, val: T);\n+}\n+\n+impl<'self,T> MutableVector<T> for &'self mut [T] {\n+    #[inline(always)]\n+    unsafe fn unsafe_set(&self, elem: uint, val: T) {\n+        let pair_ptr: &(*mut T, uint) = transmute(self);\n+        let (ptr, _) = *pair_ptr;\n+        *ptr.offset(elem) = val;\n+    }\n+}\n+\n /**\n * Constructs a vector from an unsafe pointer to a buffer\n *"}, {"sha": "21f38245ca3593eabc53c347bf962fa82ecf9344", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6", "patch": "@@ -0,0 +1,95 @@\n+use core::from_str::FromStr;\n+use core::i32::range;\n+use core::vec::MutableVector;\n+\n+fn max(a: i32, b: i32) -> i32 {\n+    if a > b {\n+        a\n+    } else {\n+        b\n+    }\n+}\n+\n+#[inline(never)]\n+fn fannkuch_redux(n: i32) -> i32 {\n+    let mut perm = vec::from_elem(n as uint, 0i32);\n+    let mut perm1 = vec::from_fn(n as uint, |i| i as i32);\n+    let mut count = vec::from_elem(n as uint, 0i32);\n+    let mut max_flips_count = 0i32, perm_count = 0i32, checksum = 0i32;\n+\n+    let mut r = n;\n+    loop {\n+        unsafe {\n+            while r != 1 {\n+                count.unsafe_set((r-1) as uint, r);\n+                r -= 1;\n+            }\n+\n+            // XXX: Need each2_mut.\n+            for vec::eachi_mut(perm) |i, perm_i| {\n+                *perm_i = perm1.unsafe_get(i);\n+            }\n+\n+            let mut flips_count: i32 = 0;\n+            let mut k: i32;\n+            loop {\n+                k = perm.unsafe_get(0);\n+                if k == 0 {\n+                    break;\n+                }\n+\n+                let k2 = (k+1) >> 1;\n+                for range(0, k2) |i| {\n+                    let (perm_i, perm_k_i) = {\n+                        (perm.unsafe_get(i as uint),\n+                            perm.unsafe_get((k-i) as uint))\n+                    };\n+                    perm.unsafe_set(i as uint, perm_k_i);\n+                    perm.unsafe_set((k-i) as uint, perm_i);\n+                }\n+                flips_count += 1;\n+            }\n+\n+            max_flips_count = max(max_flips_count, flips_count);\n+            checksum += if perm_count % 2 == 0 {\n+                flips_count\n+            } else {\n+                -flips_count\n+            };\n+\n+            // Use incremental change to generate another permutation.\n+            loop {\n+                if r == n {\n+                    println(checksum.to_str());\n+                    return max_flips_count;\n+                }\n+\n+                let perm0 = perm1[0];\n+                let mut i: i32 = 0;\n+                while i < r {\n+                    let j = i + 1;\n+                    let perm1_j = { perm1.unsafe_get(j as uint) };\n+                    perm1.unsafe_set(i as uint, perm1_j);\n+                    i = j;\n+                }\n+                perm1.unsafe_set(r as uint, perm0);\n+\n+                let count_r = { count.unsafe_get(r as uint) };\n+                count.unsafe_set(r as uint, count_r - 1);\n+                if count.unsafe_get(r as uint) > 0 {\n+                    break;\n+                }\n+                r += 1;\n+            }\n+\n+            perm_count += 1;\n+        }\n+    }\n+}\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    let n: i32 = FromStr::from_str(os::args()[1]).get();\n+    println(fmt!(\"Pfannkuchen(%d) = %d\", n as int, fannkuch_redux(n) as int));\n+}\n+"}, {"sha": "675151cf6c9da8759b03f93db742375b73b9839c", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=9738c2a45c03034f937a0b2ce7a690f64e7662eb", "patch": "@@ -1,81 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Based on Isaac Gouy's fannkuchredux.csharp\n-extern mod std;\n-\n-fn fannkuch(n: int) -> int {\n-    fn perm1init(i: uint) -> int { return i as int; }\n-\n-    let mut perm = vec::from_elem(n as uint, 0);\n-    let mut perm1 = vec::from_fn(n as uint, |i| perm1init(i));\n-    let mut count = vec::from_elem(n as uint, 0);\n-    let mut f = 0;\n-    let mut i = 0;\n-    let mut k = 0;\n-    let mut r = 0;\n-    let mut flips = 0;\n-    let mut nperm = 0;\n-    let mut checksum = 0;\n-    r = n;\n-    while r > 0 {\n-        i = 0;\n-        while r != 1 { count[r - 1] = r; r -= 1; }\n-        while i < n { perm[i] = perm1[i]; i += 1; }\n-        // Count flips and update max and checksum\n-\n-        f = 0;\n-        k = perm[0];\n-        while k != 0 {\n-            i = 0;\n-            while 2 * i < k {\n-                let t = perm[i];\n-                perm[i] = perm[k - i];\n-                perm[k - i] = t;\n-                i += 1;\n-            }\n-            k = perm[0];\n-            f += 1;\n-        }\n-        if f > flips { flips = f; }\n-        if nperm & 0x1 == 0 { checksum += f; } else { checksum -= f; }\n-        // Use incremental change to generate another permutation\n-\n-        let mut go = true;\n-        while go {\n-            if r == n {\n-                io::println(fmt!(\"%d\", checksum));\n-                return flips;\n-            }\n-            let p0 = perm1[0];\n-            i = 0;\n-            while i < r { let j = i + 1; perm1[i] = perm1[j]; i = j; }\n-            perm1[r] = p0;\n-            count[r] -= 1;\n-            if count[r] > 0 { go = false; } else { r += 1; }\n-        }\n-        nperm += 1;\n-    }\n-    return flips;\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n-        ~[~\"\", ~\"10\"]\n-    } else if args.len() <= 1u {\n-        ~[~\"\", ~\"8\"]\n-    } else {\n-        args\n-    };\n-\n-    let n = int::from_str(args[1]).get();\n-    io::println(fmt!(\"Pfannkuchen(%d) = %d\", n, fannkuch(n)));\n-}"}, {"sha": "5cb04fcd27a8f1ded9843ec1a90534ce68d41977", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=10aa1c3c05b67c974d47cf1e21b3c2b3549fb0d6", "patch": "@@ -0,0 +1,204 @@\n+use core::cast::transmute;\n+use core::from_str::FromStr;\n+use core::libc::{FILE, STDOUT_FILENO, c_int, fdopen, fputc, fputs, fwrite};\n+use core::uint::{min, range};\n+use core::vec::bytes::copy_memory;\n+\n+static LINE_LEN: uint = 60;\n+static LOOKUP_SIZE: uint = 4 * 1024;\n+static LOOKUP_SCALE: f32 = (LOOKUP_SIZE - 1) as f32;\n+\n+// Random number generator constants\n+static IM: u32 = 139968;\n+static IA: u32 = 3877;\n+static IC: u32 = 29573;\n+\n+static ALU: &'static str = \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG\\\n+                            GGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGA\\\n+                            GACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAA\\\n+                            AATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAAT\\\n+                            CCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAAC\\\n+                            CCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTG\\\n+                            CACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n+\n+static NULL_AMINO_ACID: AminoAcid = AminoAcid { c: ' ' as u8, p: 0.0 };\n+\n+static MESSAGE_1: &'static str = \">ONE Homo sapiens alu\\n\";\n+static MESSAGE_2: &'static str = \">TWO IUB ambiguity codes\\n\";\n+static MESSAGE_3: &'static str = \">THREE Homo sapiens frequency\\n\";\n+\n+static IUB: [AminoAcid, ..15] = [\n+    AminoAcid { c: 'a' as u8, p: 0.27 },\n+    AminoAcid { c: 'c' as u8, p: 0.12 },\n+    AminoAcid { c: 'g' as u8, p: 0.12 },\n+    AminoAcid { c: 't' as u8, p: 0.27 },\n+    AminoAcid { c: 'B' as u8, p: 0.02 },\n+    AminoAcid { c: 'D' as u8, p: 0.02 },\n+    AminoAcid { c: 'H' as u8, p: 0.02 },\n+    AminoAcid { c: 'K' as u8, p: 0.02 },\n+    AminoAcid { c: 'M' as u8, p: 0.02 },\n+    AminoAcid { c: 'N' as u8, p: 0.02 },\n+    AminoAcid { c: 'R' as u8, p: 0.02 },\n+    AminoAcid { c: 'S' as u8, p: 0.02 },\n+    AminoAcid { c: 'V' as u8, p: 0.02 },\n+    AminoAcid { c: 'W' as u8, p: 0.02 },\n+    AminoAcid { c: 'Y' as u8, p: 0.02 },\n+];\n+\n+static HOMO_SAPIENS: [AminoAcid, ..4] = [\n+    AminoAcid { c: 'a' as u8, p: 0.3029549426680 },\n+    AminoAcid { c: 'c' as u8, p: 0.1979883004921 },\n+    AminoAcid { c: 'g' as u8, p: 0.1975473066391 },\n+    AminoAcid { c: 't' as u8, p: 0.3015094502008 },\n+];\n+\n+// XXX: Use map().\n+fn sum_and_scale(a: &'static [AminoAcid]) -> ~[AminoAcid] {\n+    let mut result = ~[];\n+    let mut p = 0f32;\n+    for a.each |a_i| {\n+        let mut a_i = *a_i;\n+        p += a_i.p;\n+        a_i.p = p * LOOKUP_SCALE;\n+        result.push(a_i);\n+    }\n+    result[result.len() - 1].p = LOOKUP_SCALE;\n+    result\n+}\n+\n+struct AminoAcid {\n+    c: u8,\n+    p: f32,\n+}\n+\n+struct RepeatFasta {\n+    alu: &'static str,\n+    stdout: *FILE,\n+}\n+\n+impl RepeatFasta {\n+    fn new(stdout: *FILE, alu: &'static str) -> RepeatFasta {\n+        RepeatFasta {\n+            alu: alu,\n+            stdout: stdout,\n+        }\n+    }\n+\n+    fn make(&mut self, n: uint) {\n+        unsafe {\n+            let stdout = self.stdout;\n+            let alu_len = self.alu.len();\n+            let mut buf = vec::from_elem(alu_len + LINE_LEN, 0u8);\n+            let alu: &[u8] = str::byte_slice_no_callback(self.alu);\n+\n+            copy_memory(buf, alu, alu_len);\n+            copy_memory(vec::mut_slice(buf, alu_len, buf.len()),\n+                        alu,\n+                        LINE_LEN);\n+\n+            let mut pos = 0, bytes, n = n;\n+            while n > 0 {\n+                bytes = min(LINE_LEN, n);\n+                fwrite(transmute(&buf[pos]), bytes as u64, 1, stdout);\n+                fputc('\\n' as c_int, stdout);\n+                pos += bytes;\n+                if pos > alu_len {\n+                    pos -= alu_len;\n+                }\n+                n -= bytes;\n+            }\n+        }\n+    }\n+}\n+\n+struct RandomFasta {\n+    seed: u32,\n+    stdout: *FILE,\n+    lookup: [AminoAcid, ..LOOKUP_SIZE],\n+}\n+\n+impl RandomFasta {\n+    fn new(stdout: *FILE, a: &[AminoAcid]) -> RandomFasta {\n+        RandomFasta {\n+            seed: 42,\n+            stdout: stdout,\n+            lookup: RandomFasta::make_lookup(a),\n+        }\n+    }\n+\n+    fn make_lookup(a: &[AminoAcid]) -> [AminoAcid, ..LOOKUP_SIZE] {\n+        let mut lookup = [ NULL_AMINO_ACID, ..LOOKUP_SIZE ];\n+        let mut j = 0;\n+        for vec::eachi_mut(lookup) |i, slot| {\n+            while a[j].p < (i as f32) {\n+                j += 1;\n+            }\n+            *slot = a[j];\n+        }\n+        lookup\n+    }\n+\n+    fn rng(&mut self, max: f32) -> f32 {\n+        self.seed = (self.seed * IA + IC) % IM;\n+        max * (self.seed as f32) / (IM as f32)\n+    }\n+\n+    fn nextc(&mut self) -> u8 {\n+        let r = self.rng(1.0);\n+        for self.lookup.each |a| {\n+            if a.p >= r {\n+                return a.c;\n+            }\n+        }\n+        0\n+    }\n+\n+    fn make(&mut self, n: uint) {\n+        unsafe {\n+            let lines = n / LINE_LEN, chars_left = n % LINE_LEN;\n+            let mut buf = [0, ..LINE_LEN + 1];\n+\n+            for lines.times {\n+                for range(0, LINE_LEN) |i| {\n+                    buf[i] = self.nextc();\n+                }\n+                buf[LINE_LEN] = '\\n' as u8;\n+                fwrite(transmute(&buf[0]),\n+                       LINE_LEN as u64 + 1,\n+                       1,\n+                       self.stdout);\n+            }\n+            for range(0, chars_left) |i| {\n+                buf[i] = self.nextc();\n+            }\n+            fwrite(transmute(&buf[0]), chars_left as u64, 1, self.stdout);\n+        }\n+    }\n+}\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    let n: uint = FromStr::from_str(os::args()[1]).get();\n+\n+    unsafe {\n+        let mode = \"w\";\n+        let stdout = fdopen(STDOUT_FILENO as c_int, transmute(&mode[0]));\n+\n+        fputs(transmute(&MESSAGE_1[0]), stdout);\n+        let mut repeat = RepeatFasta::new(stdout, ALU);\n+        repeat.make(n * 2);\n+\n+        fputs(transmute(&MESSAGE_2[0]), stdout);\n+        let iub = sum_and_scale(IUB);\n+        let mut random = RandomFasta::new(stdout, iub);\n+        random.make(n * 3);\n+\n+        fputs(transmute(&MESSAGE_3[0]), stdout);\n+        let homo_sapiens = sum_and_scale(HOMO_SAPIENS);\n+        random.lookup = RandomFasta::make_lookup(homo_sapiens);\n+        random.make(n * 5);\n+\n+        fputc('\\n' as c_int, stdout);\n+    }\n+}\n+"}]}