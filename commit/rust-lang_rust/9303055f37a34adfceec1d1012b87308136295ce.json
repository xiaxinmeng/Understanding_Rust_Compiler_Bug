{"sha": "9303055f37a34adfceec1d1012b87308136295ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzMDMwNTVmMzdhMzRhZGZjZWVjMWQxMDEyYjg3MzA4MTM2Mjk1Y2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-19T01:01:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-19T01:01:30Z"}, "message": "Auto merge of #29903 - nikomatsakis:incr-comp-ool-items, r=mw,nrc\n\nThis PR moves items into a separate map stored in the krate, rather than storing them inline in the HIR. The HIR visitor is also modified to skip visiting nested items by default. The goal here is to ensure that if you get access to the HIR for one item, you don't automatically get access to a bunch of other items, for better dependency tracking.\n\nr? @nrc\ncc @eddyb", "tree": {"sha": "6d130e6f61911d1f342b404907e40eb9efa19464", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d130e6f61911d1f342b404907e40eb9efa19464"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9303055f37a34adfceec1d1012b87308136295ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9303055f37a34adfceec1d1012b87308136295ce", "html_url": "https://github.com/rust-lang/rust/commit/9303055f37a34adfceec1d1012b87308136295ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9303055f37a34adfceec1d1012b87308136295ce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2978af09d35c931fafe479ac7648436448982444", "url": "https://api.github.com/repos/rust-lang/rust/commits/2978af09d35c931fafe479ac7648436448982444", "html_url": "https://github.com/rust-lang/rust/commit/2978af09d35c931fafe479ac7648436448982444"}, {"sha": "7926fa1ee9947c5b46e02a58f22172c78fcae2cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7926fa1ee9947c5b46e02a58f22172c78fcae2cd", "html_url": "https://github.com/rust-lang/rust/commit/7926fa1ee9947c5b46e02a58f22172c78fcae2cd"}], "stats": {"total": 2667, "additions": 1396, "deletions": 1271}, "files": [{"sha": "0e24a4446fbe942f49385561552edcfad608cd2b", "filename": "src/librustc/front/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -29,7 +29,7 @@ use rustc_front::hir::{Block, FnDecl};\n use syntax::ast::{Name, NodeId};\n use rustc_front::hir as ast;\n use syntax::codemap::Span;\n-use rustc_front::visit::FnKind;\n+use rustc_front::intravisit::FnKind;\n \n /// An FnLikeNode is a Node that is like a fn, in that it has a decl\n /// and a body (as well as a NodeId, a span, etc)."}, {"sha": "e98e88c9abf249aebd2b4cb286139857cf225bee", "filename": "src/librustc/front/map/collector.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -13,7 +13,7 @@ use super::MapEntry::*;\n \n use rustc_front::hir::*;\n use rustc_front::util;\n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::{self, Visitor};\n use middle::def_id::{CRATE_DEF_INDEX, DefIndex};\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n@@ -22,14 +22,16 @@ use syntax::codemap::Span;\n /// A Visitor that walks over an AST and collects Node's into an AST\n /// Map.\n pub struct NodeCollector<'ast> {\n+    pub krate: &'ast Crate,\n     pub map: Vec<MapEntry<'ast>>,\n     pub definitions: Definitions,\n     pub parent_node: NodeId,\n }\n \n impl<'ast> NodeCollector<'ast> {\n-    pub fn root() -> NodeCollector<'ast> {\n+    pub fn root(krate: &'ast Crate) -> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n+            krate: krate,\n             map: vec![],\n             definitions: Definitions::new(),\n             parent_node: CRATE_NODE_ID,\n@@ -44,13 +46,15 @@ impl<'ast> NodeCollector<'ast> {\n         collector\n     }\n \n-    pub fn extend(parent: &'ast InlinedParent,\n+    pub fn extend(krate: &'ast Crate,\n+                  parent: &'ast InlinedParent,\n                   parent_node: NodeId,\n                   parent_def_path: DefPath,\n                   map: Vec<MapEntry<'ast>>,\n                   definitions: Definitions)\n                   -> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n+            krate: krate,\n             map: map,\n             parent_node: parent_node,\n             definitions: definitions,\n@@ -107,6 +111,13 @@ impl<'ast> NodeCollector<'ast> {\n }\n \n impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n+    /// Because we want to track parent items and so forth, enable\n+    /// deep walking so that we walk nested items in the context of\n+    /// their outer items.\n+    fn visit_nested_item(&mut self, item: ItemId) {\n+        self.visit_item(self.krate.item(item.id))\n+    }\n+\n     fn visit_item(&mut self, i: &'ast Item) {\n         // Pick the def data. This need not be unique, but the more\n         // information we encapsulate into\n@@ -173,7 +184,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             }\n             _ => {}\n         }\n-        visit::walk_item(self, i);\n+        intravisit::walk_item(self, i);\n         self.parent_node = parent_node;\n     }\n \n@@ -184,7 +195,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n         let parent_node = self.parent_node;\n         self.parent_node = foreign_item.id;\n-        visit::walk_foreign_item(self, foreign_item);\n+        intravisit::walk_foreign_item(self, foreign_item);\n         self.parent_node = parent_node;\n     }\n \n@@ -195,7 +206,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                             DefPathData::TypeParam(ty_param.name));\n         }\n \n-        visit::walk_generics(self, generics);\n+        intravisit::walk_generics(self, generics);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n@@ -217,7 +228,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             _ => { }\n         }\n \n-        visit::walk_trait_item(self, ti);\n+        intravisit::walk_trait_item(self, ti);\n \n         self.parent_node = parent_node;\n     }\n@@ -240,7 +251,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             _ => { }\n         }\n \n-        visit::walk_impl_item(self, ii);\n+        intravisit::walk_impl_item(self, ii);\n \n         self.parent_node = parent_node;\n     }\n@@ -259,7 +270,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n         let parent_node = self.parent_node;\n         self.parent_node = pat.id;\n-        visit::walk_pat(self, pat);\n+        intravisit::walk_pat(self, pat);\n         self.parent_node = parent_node;\n     }\n \n@@ -273,7 +284,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n         let parent_node = self.parent_node;\n         self.parent_node = expr.id;\n-        visit::walk_expr(self, expr);\n+        intravisit::walk_expr(self, expr);\n         self.parent_node = parent_node;\n     }\n \n@@ -282,21 +293,21 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.insert(id, NodeStmt(stmt));\n         let parent_node = self.parent_node;\n         self.parent_node = id;\n-        visit::walk_stmt(self, stmt);\n+        intravisit::walk_stmt(self, stmt);\n         self.parent_node = parent_node;\n     }\n \n-    fn visit_fn(&mut self, fk: visit::FnKind<'ast>, fd: &'ast FnDecl,\n+    fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n                 b: &'ast Block, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);\n-        visit::walk_fn(self, fk, fd, b, s);\n+        intravisit::walk_fn(self, fk, fd, b, s);\n     }\n \n     fn visit_block(&mut self, block: &'ast Block) {\n         self.insert(block.id, NodeBlock(block));\n         let parent_node = self.parent_node;\n         self.parent_node = block.id;\n-        visit::walk_block(self, block);\n+        intravisit::walk_block(self, block);\n         self.parent_node = parent_node;\n     }\n "}, {"sha": "6ee6b07059751e6876d4da20e3ba154c655ffd6e", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -25,7 +25,7 @@ use syntax::parse::token;\n \n use rustc_front::hir::*;\n use rustc_front::fold::Folder;\n-use rustc_front::visit;\n+use rustc_front::intravisit;\n use rustc_front::print::pprust;\n \n use arena::TypedArena;\n@@ -809,9 +809,11 @@ impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n }\n \n pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n-    let mut collector = NodeCollector::root();\n-    visit::walk_crate(&mut collector, &forest.krate);\n-    let NodeCollector { map, definitions, .. } = collector;\n+    let (map, definitions) = {\n+        let mut collector = NodeCollector::root(&forest.krate);\n+        intravisit::walk_crate(&mut collector, &forest.krate);\n+        (collector.map, collector.definitions)\n+    };\n \n     if log_enabled!(::log::DEBUG) {\n         // This only makes sense for ordered stores; note the\n@@ -847,7 +849,7 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                                           -> &'ast InlinedItem {\n     let mut fld = IdAndSpanUpdater { fold_ops: fold_ops };\n     let ii = match ii {\n-        II::Item(i) => II::Item(fld.fold_item(i)),\n+        II::Item(i) => II::Item(i.map(|i| fld.fold_item(i))),\n         II::TraitItem(d, ti) => {\n             II::TraitItem(fld.fold_ops.new_def_id(d),\n                           fld.fold_trait_item(ti))\n@@ -867,6 +869,7 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n     let mut collector =\n         NodeCollector::extend(\n+            map.krate(),\n             ii_parent,\n             ii_parent_id,\n             def_path,"}, {"sha": "798f4866d346c8edac3b82bff5c3e49f5b38f22e", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -44,7 +44,7 @@ use syntax::parse::token::InternedString;\n use syntax::ast;\n use rustc_front::hir;\n use rustc_front::util;\n-use rustc_front::visit as hir_visit;\n+use rustc_front::intravisit as hir_visit;\n use syntax::visit as ast_visit;\n use syntax::diagnostic;\n \n@@ -555,7 +555,6 @@ impl<'a> EarlyContext<'a> {\n     {\n         let mut v = ast_util::IdVisitor {\n             operation: self,\n-            pass_through_items: false,\n             visited_outermost: false,\n         };\n         f(&mut v);\n@@ -583,11 +582,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     fn visit_ids<F>(&mut self, f: F)\n         where F: FnOnce(&mut util::IdVisitor<LateContext>)\n     {\n-        let mut v = util::IdVisitor {\n-            operation: self,\n-            pass_through_items: false,\n-            visited_outermost: false,\n-        };\n+        let mut v = util::IdVisitor::new(self);\n         f(&mut v);\n     }\n }\n@@ -611,10 +606,12 @@ impl<'a, 'tcx> LintContext for LateContext<'a, 'tcx> {\n     }\n \n     fn enter_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        debug!(\"late context: enter_attrs({:?})\", attrs);\n         run_lints!(self, enter_lint_attrs, late_passes, attrs);\n     }\n \n     fn exit_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        debug!(\"late context: exit_attrs({:?})\", attrs);\n         run_lints!(self, exit_lint_attrs, late_passes, attrs);\n     }\n }\n@@ -638,15 +635,24 @@ impl<'a> LintContext for EarlyContext<'a> {\n     }\n \n     fn enter_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        debug!(\"early context: exit_attrs({:?})\", attrs);\n         run_lints!(self, enter_lint_attrs, early_passes, attrs);\n     }\n \n     fn exit_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        debug!(\"early context: exit_attrs({:?})\", attrs);\n         run_lints!(self, exit_lint_attrs, early_passes, attrs);\n     }\n }\n \n impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n+    /// Because lints are scoped lexically, we want to walk nested\n+    /// items in the context of the outer item, so enable\n+    /// deep-walking.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, it: &hir::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, late_passes, it);\n@@ -952,6 +958,7 @@ impl<'a, 'tcx> IdVisitingOperation for LateContext<'a, 'tcx> {\n         match self.sess().lints.borrow_mut().remove(&id) {\n             None => {}\n             Some(lints) => {\n+                debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);\n                 for (lint_id, span, msg) in lints {\n                     self.span_lint(lint_id.lint, span, &msg[..])\n                 }\n@@ -1008,16 +1015,14 @@ impl LateLintPass for GatherNodeLevels {\n ///\n /// Consumes the `lint_store` field of the `Session`.\n pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &hir::Crate,\n                    exported_items: &ExportedItems) {\n-\n+    let krate = tcx.map.krate();\n     let mut cx = LateContext::new(tcx, krate, exported_items);\n \n     // Visit the whole crate.\n     cx.with_lint_attrs(&krate.attrs, |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n-            v.visited_outermost = true;\n             hir_visit::walk_crate(v, krate);\n         });\n "}, {"sha": "23be6117f190f51376c31aee808d994756fd9c93", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -34,7 +34,7 @@ pub use self::LintSource::*;\n use std::hash;\n use std::ascii::AsciiExt;\n use syntax::codemap::Span;\n-use rustc_front::visit::FnKind;\n+use rustc_front::intravisit::FnKind;\n use syntax::visit as ast_visit;\n use syntax::ast;\n use rustc_front::hir;\n@@ -218,7 +218,7 @@ pub type EarlyLintPassObject = Box<EarlyLintPass + 'static>;\n pub type LateLintPassObject = Box<LateLintPass + 'static>;\n \n /// Identifies a lint known to the compiler.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n pub struct LintId {\n     // Identity is based on pointer equality of this field.\n     lint: &'static Lint,"}, {"sha": "9c2aa584aabcebdfd257d321e368bd80248b7c85", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -37,7 +37,7 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n use syntax::util::small_vector::SmallVector;\n-use rustc_front::visit;\n+use rustc_front::intravisit::Visitor;\n use rustc_front::hir;\n use log;\n \n@@ -53,10 +53,9 @@ pub struct CrateReader<'a> {\n     foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n }\n \n-impl<'a, 'b, 'v> visit::Visitor<'v> for LocalCrateReader<'a, 'b> {\n-    fn visit_item(&mut self, a: &hir::Item) {\n+impl<'a, 'b, 'hir> Visitor<'hir> for LocalCrateReader<'a, 'b> {\n+    fn visit_item(&mut self, a: &'hir hir::Item) {\n         self.process_item(a);\n-        visit::walk_item(self, a);\n     }\n }\n \n@@ -716,7 +715,7 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n     // etc.\n     pub fn read_crates(&mut self, krate: &hir::Crate) {\n         self.process_crate(krate);\n-        visit::walk_crate(self, krate);\n+        krate.visit_all_items(self);\n         self.creader.inject_allocator_crate();\n \n         if log_enabled!(log::INFO) {"}, {"sha": "e543d8708b5714de9ba8934c5d7ea2b0c8202197", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -46,8 +46,8 @@ use syntax;\n use rbml::writer::Encoder;\n \n use rustc_front::hir;\n-use rustc_front::visit::Visitor;\n-use rustc_front::visit;\n+use rustc_front::intravisit::Visitor;\n+use rustc_front::intravisit;\n use front::map::{LinkedPath, PathElem, PathElems};\n use front::map as ast_map;\n \n@@ -431,11 +431,12 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n-    for item in &md.items {\n+    for item_id in &md.item_ids {\n         rbml_w.wr_tagged_u64(tag_mod_child,\n-                             def_to_u64(ecx.tcx.map.local_def_id(item.id)));\n+                             def_to_u64(ecx.tcx.map.local_def_id(item_id.id)));\n \n-        each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n+        let item = ecx.tcx.map.expect_item(item_id.id);\n+        each_auxiliary_node_id(item, |auxiliary_node_id| {\n             rbml_w.wr_tagged_u64(tag_mod_child,\n                                  def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n             true\n@@ -1468,25 +1469,26 @@ struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n     index: &'a mut CrateIndex<'tcx>,\n }\n \n-impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n-    fn visit_expr(&mut self, ex: &hir::Expr) {\n-        visit::walk_expr(self, ex);\n+impl<'a, 'b, 'c, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n+        intravisit::walk_expr(self, ex);\n         my_visit_expr(ex, self.rbml_w_for_visit_item, self.ecx, self.index);\n     }\n-    fn visit_item(&mut self, i: &hir::Item) {\n-        visit::walk_item(self, i);\n+    fn visit_item(&mut self, i: &'tcx hir::Item) {\n+        intravisit::walk_item(self, i);\n         my_visit_item(i, self.rbml_w_for_visit_item, self.ecx, self.index);\n     }\n-    fn visit_foreign_item(&mut self, ni: &hir::ForeignItem) {\n-        visit::walk_foreign_item(self, ni);\n+    fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n+        intravisit::walk_foreign_item(self, ni);\n         my_visit_foreign_item(ni, self.rbml_w_for_visit_item, self.ecx, self.index);\n     }\n }\n \n fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                   rbml_w: &mut Encoder,\n-                                   krate: &hir::Crate)\n+                                   rbml_w: &mut Encoder)\n                                    -> CrateIndex<'tcx> {\n+    let krate = ecx.tcx.map.krate();\n+\n     let mut index = CrateIndex {\n         items: IndexData::new(ecx.tcx.map.num_local_def_ids()),\n         xrefs: FnvHashMap()\n@@ -1503,11 +1505,11 @@ fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                         syntax::parse::token::intern(&ecx.link_meta.crate_name),\n                         hir::Public);\n \n-    visit::walk_crate(&mut EncodeVisitor {\n+    krate.visit_all_items(&mut EncodeVisitor {\n         index: &mut index,\n         ecx: ecx,\n         rbml_w_for_visit_item: &mut *rbml_w,\n-    }, krate);\n+    });\n \n     rbml_w.end_tag();\n     index\n@@ -1735,7 +1737,7 @@ fn encode_struct_field_attrs(ecx: &EncodeContext,\n     }\n \n     rbml_w.start_tag(tag_struct_fields);\n-    visit::walk_crate(&mut StructFieldVisitor { ecx: ecx, rbml_w: rbml_w }, krate);\n+    krate.visit_all_items(&mut StructFieldVisitor { ecx: ecx, rbml_w: rbml_w });\n     rbml_w.end_tag();\n }\n \n@@ -1756,7 +1758,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n                     .push(impl_id);\n             }\n         }\n-        visit::walk_item(self, item);\n     }\n }\n \n@@ -1768,7 +1769,7 @@ fn encode_impls<'a>(ecx: &'a EncodeContext,\n         tcx: ecx.tcx,\n         impls: FnvHashMap()\n     };\n-    visit::walk_crate(&mut visitor, krate);\n+    krate.visit_all_items(&mut visitor);\n \n     rbml_w.start_tag(tag_impls);\n     for (trait_, trait_impls) in visitor.impls {\n@@ -1787,11 +1788,12 @@ fn encode_misc_info(ecx: &EncodeContext,\n                     rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n-    for item in &krate.module.items {\n+    for item_id in &krate.module.item_ids {\n         rbml_w.wr_tagged_u64(tag_mod_child,\n-                             def_to_u64(ecx.tcx.map.local_def_id(item.id)));\n+                             def_to_u64(ecx.tcx.map.local_def_id(item_id.id)));\n \n-        each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n+        let item = ecx.tcx.map.expect_item(item_id.id);\n+        each_auxiliary_node_id(item, |auxiliary_node_id| {\n             rbml_w.wr_tagged_u64(tag_mod_child,\n                                  def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n             true\n@@ -2022,7 +2024,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n     // Encode and index the items.\n     rbml_w.start_tag(tag_items);\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    let index = encode_info_for_items(&ecx, &mut rbml_w, krate);\n+    let index = encode_info_for_items(&ecx, &mut rbml_w);\n     stats.item_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n     rbml_w.end_tag();\n "}, {"sha": "e621a4166d719ae0d6385d46b97eac09d253505d", "filename": "src/librustc/metadata/inline.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmetadata%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmetadata%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Finline.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -13,7 +13,7 @@ use rustc_front::hir;\n use rustc_front::util::IdVisitor;\n use syntax::ast_util::{IdRange, IdRangeComputingVisitor, IdVisitingOperation};\n use syntax::ptr::P;\n-use rustc_front::visit::Visitor;\n+use rustc_front::intravisit::Visitor;\n use self::InlinedItem::*;\n \n /// The data we save and restore about an inlined item or method.  This is not\n@@ -48,11 +48,7 @@ impl InlinedItem {\n     }\n \n     pub fn visit_ids<O: IdVisitingOperation>(&self, operation: &mut O) {\n-        let mut id_visitor = IdVisitor {\n-            operation: operation,\n-            pass_through_items: true,\n-            visited_outermost: false,\n-        };\n+        let mut id_visitor = IdVisitor::new(operation);\n         self.visit(&mut id_visitor);\n     }\n "}, {"sha": "752fdc2347411ee2eba5d844442a7e742bb33adb", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -389,7 +389,7 @@ fn simplify_ast(ii: InlinedItemRef) -> InlinedItem {\n     match ii {\n         // HACK we're not dropping items.\n         InlinedItemRef::Item(i) => {\n-            InlinedItem::Item(fold::noop_fold_item(P(i.clone()), &mut fld))\n+            InlinedItem::Item(P(fold::noop_fold_item(i.clone(), &mut fld)))\n         }\n         InlinedItemRef::TraitItem(d, ti) => {\n             InlinedItem::TraitItem(d, fold::noop_fold_trait_item(P(ti.clone()), &mut fld))\n@@ -1393,13 +1393,13 @@ fn mk_ctxt() -> parse::ParseSess {\n }\n \n #[cfg(test)]\n-fn roundtrip(in_item: P<hir::Item>) {\n+fn roundtrip(in_item: hir::Item) {\n     let mut wr = Cursor::new(Vec::new());\n-    encode_item_ast(&mut Encoder::new(&mut wr), &*in_item);\n+    encode_item_ast(&mut Encoder::new(&mut wr), &in_item);\n     let rbml_doc = rbml::Doc::new(wr.get_ref());\n     let out_item = decode_item_ast(rbml_doc);\n \n-    assert!(*in_item == out_item);\n+    assert!(in_item == out_item);\n }\n \n #[test]\n@@ -1449,11 +1449,11 @@ fn test_simplification() {\n     let hir_item = lower_item(&lcx, &item);\n     let item_in = InlinedItemRef::Item(&hir_item);\n     let item_out = simplify_ast(item_in);\n-    let item_exp = InlinedItem::Item(lower_item(&lcx, &quote_item!(&cx,\n+    let item_exp = InlinedItem::Item(P(lower_item(&lcx, &quote_item!(&cx,\n         fn new_int_alist<B>() -> alist<isize, B> {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n-    ).unwrap()));\n+    ).unwrap())));\n     match (item_out, item_exp) {\n       (InlinedItem::Item(item_out), InlinedItem::Item(item_exp)) => {\n         assert!(pprust::item_to_string(&*item_out) =="}, {"sha": "e29cc04e65a1b3caf83165047a7588fcfc4d9906", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -41,7 +41,7 @@ use rustc_front::hir;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::feature_gate::UnstableFeatures;\n-use rustc_front::visit::{self, FnKind, Visitor};\n+use rustc_front::intravisit::{self, FnKind, Visitor};\n \n use std::collections::hash_map::Entry;\n use std::cmp::Ordering;\n@@ -81,7 +81,7 @@ bitflags! {\n     }\n }\n \n-#[derive(Copy, Clone, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n enum Mode {\n     Const,\n     ConstFn,\n@@ -190,7 +190,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n         let qualif = self.with_mode(mode, |this| {\n             this.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, b));\n-            visit::walk_fn(this, fk, fd, b, s);\n+            intravisit::walk_fn(this, fk, fd, b, s);\n             this.qualif\n         });\n \n@@ -308,6 +308,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &hir::Item) {\n         debug!(\"visit_item(item={})\", self.tcx.map.node_to_string(i.id));\n+        assert_eq!(self.mode, Mode::Var);\n         match i.node {\n             hir::ItemStatic(_, hir::MutImmutable, ref expr) => {\n                 self.check_static_type(&**expr);\n@@ -328,7 +329,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 }\n             }\n             _ => {\n-                self.with_mode(Mode::Var, |v| visit::walk_item(v, i));\n+                intravisit::walk_item(self, i);\n             }\n         }\n     }\n@@ -339,10 +340,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 if let Some(ref expr) = *default {\n                     self.global_expr(Mode::Const, &*expr);\n                 } else {\n-                    visit::walk_trait_item(self, t);\n+                    intravisit::walk_trait_item(self, t);\n                 }\n             }\n-            _ => self.with_mode(Mode::Var, |v| visit::walk_trait_item(v, t)),\n+            _ => self.with_mode(Mode::Var, |v| intravisit::walk_trait_item(v, t)),\n         }\n     }\n \n@@ -351,7 +352,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n             hir::ImplItemKind::Const(_, ref expr) => {\n                 self.global_expr(Mode::Const, &*expr);\n             }\n-            _ => self.with_mode(Mode::Var, |v| visit::walk_impl_item(v, i)),\n+            _ => self.with_mode(Mode::Var, |v| intravisit::walk_impl_item(v, i)),\n         }\n     }\n \n@@ -386,7 +387,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            _ => visit::walk_pat(self, p)\n+            _ => intravisit::walk_pat(self, p)\n         }\n     }\n \n@@ -412,7 +413,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                            tail expressions\", self.msg());\n             }\n         }\n-        visit::walk_block(self, block);\n+        intravisit::walk_block(self, block);\n     }\n \n     fn visit_expr(&mut self, ex: &hir::Expr) {\n@@ -464,11 +465,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 if let Some(mutbl) = borrow {\n                     self.record_borrow(discr.id, mutbl);\n                 }\n-                visit::walk_expr(self, ex);\n+                intravisit::walk_expr(self, ex);\n             }\n             // Division by zero and overflow checking.\n             hir::ExprBinary(op, _, _) => {\n-                visit::walk_expr(self, ex);\n+                intravisit::walk_expr(self, ex);\n                 let div_or_rem = op.node == hir::BiDiv || op.node == hir::BiRem;\n                 match node_ty.sty {\n                     ty::TyUint(_) | ty::TyInt(_) if div_or_rem => {\n@@ -487,7 +488,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                     _ => {}\n                 }\n             }\n-            _ => visit::walk_expr(self, ex)\n+            _ => intravisit::walk_expr(self, ex)\n         }\n \n         // Handle borrows on (or inside the autorefs of) this expression.\n@@ -837,12 +838,12 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n-    visit::walk_crate(&mut CheckCrateVisitor {\n+    tcx.map.krate().visit_all_items(&mut CheckCrateVisitor {\n         tcx: tcx,\n         mode: Mode::Var,\n         qualif: ConstQualif::NOT_CONST,\n         rvalue_borrows: NodeMap()\n-    }, tcx.map.krate());\n+    });\n \n     tcx.sess.abort_if_errors();\n }"}, {"sha": "22e9df63d0185e6b8df6da11220bde4293ce4bfa", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -12,8 +12,7 @@ use self::Context::*;\n use session::Session;\n \n use syntax::codemap::Span;\n-use rustc_front::visit::Visitor;\n-use rustc_front::visit;\n+use rustc_front::intravisit::{self, Visitor};\n use rustc_front::hir;\n \n #[derive(Clone, Copy, PartialEq)]\n@@ -28,12 +27,12 @@ struct CheckLoopVisitor<'a> {\n }\n \n pub fn check_crate(sess: &Session, krate: &hir::Crate) {\n-    visit::walk_crate(&mut CheckLoopVisitor { sess: sess, cx: Normal }, krate)\n+    krate.visit_all_items(&mut CheckLoopVisitor { sess: sess, cx: Normal });\n }\n \n impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n     fn visit_item(&mut self, i: &hir::Item) {\n-        self.with_context(Normal, |v| visit::walk_item(v, i));\n+        self.with_context(Normal, |v| intravisit::walk_item(v, i));\n     }\n \n     fn visit_expr(&mut self, e: &hir::Expr) {\n@@ -50,7 +49,7 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n             }\n             hir::ExprBreak(_) => self.require_loop(\"break\", e.span),\n             hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),\n-            _ => visit::walk_expr(self, e)\n+            _ => intravisit::walk_expr(self, e)\n         }\n     }\n }"}, {"sha": "3e6cf07d86f0b055415be50e5c3f4f3a39ea73c2", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -33,7 +33,7 @@ use std::iter::{FromIterator, IntoIterator, repeat};\n \n use rustc_front::hir;\n use rustc_front::hir::Pat;\n-use rustc_front::visit::{self, Visitor, FnKind};\n+use rustc_front::intravisit::{self, Visitor, FnKind};\n use rustc_front::util as front_util;\n use rustc_back::slice;\n \n@@ -155,15 +155,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n-    visit::walk_crate(&mut MatchCheckCtxt {\n+    tcx.map.krate().visit_all_items(&mut MatchCheckCtxt {\n         tcx: tcx,\n         param_env: tcx.empty_parameter_environment(),\n-    }, tcx.map.krate());\n+    });\n     tcx.sess.abort_if_errors();\n }\n \n fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n-    visit::walk_expr(cx, ex);\n+    intravisit::walk_expr(cx, ex);\n     match ex.node {\n         hir::ExprMatch(ref scrut, ref arms, source) => {\n             for arm in arms {\n@@ -485,11 +485,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                 renaming_map: renaming_map,\n             };\n \n-            let mut id_visitor = front_util::IdVisitor {\n-                operation: &mut renaming_recorder,\n-                pass_through_items: true,\n-                visited_outermost: false,\n-            };\n+            let mut id_visitor = front_util::IdVisitor::new(&mut renaming_recorder);\n \n             id_visitor.visit_expr(const_expr);\n         }\n@@ -990,7 +986,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n }\n \n fn check_local(cx: &mut MatchCheckCtxt, loc: &hir::Local) {\n-    visit::walk_local(cx, loc);\n+    intravisit::walk_local(cx, loc);\n \n     let pat = StaticInliner::new(cx.tcx, None).fold_pat(loc.pat.clone());\n     check_irrefutable(cx, &pat, false);\n@@ -1011,7 +1007,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n         _ => cx.param_env = ParameterEnvironment::for_item(cx.tcx, fn_id),\n     }\n \n-    visit::walk_fn(cx, kind, decl, body, sp);\n+    intravisit::walk_fn(cx, kind, decl, body, sp);\n \n     for input in &decl.inputs {\n         check_irrefutable(cx, &input.pat, true);\n@@ -1191,10 +1187,10 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n             hir::PatIdent(_, _, Some(_)) => {\n                 let bindings_were_allowed = self.bindings_allowed;\n                 self.bindings_allowed = false;\n-                visit::walk_pat(self, pat);\n+                intravisit::walk_pat(self, pat);\n                 self.bindings_allowed = bindings_were_allowed;\n             }\n-            _ => visit::walk_pat(self, pat),\n+            _ => intravisit::walk_pat(self, pat),\n         }\n     }\n }"}, {"sha": "35adeae3e617ce4966ff461208d0553ccc8bbde7", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -20,21 +20,21 @@ use middle::ty;\n use syntax::ast;\n use rustc_front::hir;\n use syntax::codemap::Span;\n-use rustc_front::visit;\n+use rustc_front::intravisit;\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    krate: &hir::Crate) {\n     let mut rvcx = RvalueContext { tcx: tcx };\n-    visit::walk_crate(&mut rvcx, krate);\n+    krate.visit_all_items(&mut rvcx);\n }\n \n struct RvalueContext<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n }\n \n-impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n-                fk: visit::FnKind<'v>,\n+                fk: intravisit::FnKind<'v>,\n                 fd: &'v hir::FnDecl,\n                 b: &'v hir::Block,\n                 s: Span,\n@@ -50,7 +50,7 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n             euv.walk_fn(fd, b);\n         }\n-        visit::walk_fn(self, fk, fd, b, s)\n+        intravisit::walk_fn(self, fk, fd, b, s)\n     }\n }\n "}, {"sha": "85a3117196acf909c3d0ac7849234053ecdc601a", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -19,8 +19,7 @@ use util::nodemap::NodeMap;\n use syntax::{ast};\n use syntax::codemap::Span;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use rustc_front::visit::Visitor;\n-use rustc_front::visit;\n+use rustc_front::intravisit::{self, Visitor};\n use rustc_front::hir;\n \n use std::cell::RefCell;\n@@ -60,7 +59,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n             }\n             _ => {}\n         }\n-        visit::walk_item(self, it)\n+        intravisit::walk_item(self, it)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n@@ -74,7 +73,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n             }\n             _ => {}\n         }\n-        visit::walk_trait_item(self, ti)\n+        intravisit::walk_trait_item(self, ti)\n     }\n \n     fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n@@ -86,7 +85,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n             }\n             _ => {}\n         }\n-        visit::walk_impl_item(self, ii)\n+        intravisit::walk_impl_item(self, ii)\n     }\n }\n \n@@ -100,7 +99,7 @@ pub fn check_crate<'ast>(sess: &Session,\n         ast_map: ast_map,\n         discriminant_map: RefCell::new(NodeMap()),\n     };\n-    visit::walk_crate(&mut visitor, krate);\n+    krate.visit_all_items(&mut visitor);\n     sess.abort_if_errors();\n }\n \n@@ -197,13 +196,13 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n \n impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_item(&mut self, it: &'ast hir::Item) {\n-        self.with_item_id_pushed(it.id, |v| visit::walk_item(v, it));\n+        self.with_item_id_pushed(it.id, |v| intravisit::walk_item(v, it));\n     }\n \n     fn visit_enum_def(&mut self, enum_definition: &'ast hir::EnumDef,\n                       generics: &'ast hir::Generics, item_id: ast::NodeId, _: Span) {\n         self.populate_enum_discriminants(enum_definition);\n-        visit::walk_enum_def(self, enum_definition, generics, item_id);\n+        intravisit::walk_enum_def(self, enum_definition, generics, item_id);\n     }\n \n     fn visit_variant(&mut self, variant: &'ast hir::Variant,\n@@ -222,16 +221,16 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n         // If `maybe_expr` is `None`, that's because no discriminant is\n         // specified that affects this variant. Thus, no risk of recursion.\n         if let Some(expr) = maybe_expr {\n-            self.with_item_id_pushed(expr.id, |v| visit::walk_expr(v, expr));\n+            self.with_item_id_pushed(expr.id, |v| intravisit::walk_expr(v, expr));\n         }\n     }\n \n     fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n-        self.with_item_id_pushed(ti.id, |v| visit::walk_trait_item(v, ti));\n+        self.with_item_id_pushed(ti.id, |v| intravisit::walk_trait_item(v, ti));\n     }\n \n     fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n-        self.with_item_id_pushed(ii.id, |v| visit::walk_impl_item(v, ii));\n+        self.with_item_id_pushed(ii.id, |v| intravisit::walk_impl_item(v, ii));\n     }\n \n     fn visit_expr(&mut self, e: &'ast hir::Expr) {\n@@ -285,6 +284,6 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n             },\n             _ => ()\n         }\n-        visit::walk_expr(self, e);\n+        intravisit::walk_expr(self, e);\n     }\n }"}, {"sha": "039c62a904c9b59ffca3fe4c9340c4dd3e197fb5", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -29,7 +29,7 @@ use util::nodemap::NodeMap;\n use syntax::{ast, abi};\n use rustc_front::hir::Expr;\n use rustc_front::hir;\n-use rustc_front::visit::FnKind;\n+use rustc_front::intravisit::FnKind;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;"}, {"sha": "9abab6e04e0251eb977f13ac8a4922d7e94dd7b8", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -27,7 +27,7 @@ use syntax::print::pp;\n use syntax::print::pprust::PrintState;\n use util::nodemap::NodeMap;\n use rustc_front::hir;\n-use rustc_front::visit;\n+use rustc_front::intravisit;\n use rustc_front::print::pprust;\n \n \n@@ -194,11 +194,11 @@ fn build_nodeid_to_index(decl: Option<&hir::FnDecl>,\n             index: &'a mut NodeMap<Vec<CFGIndex>>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n-        visit::walk_fn_decl(&mut formals, decl);\n-        impl<'a, 'v> visit::Visitor<'v> for Formals<'a> {\n+        intravisit::walk_fn_decl(&mut formals, decl);\n+        impl<'a, 'v> intravisit::Visitor<'v> for Formals<'a> {\n             fn visit_pat(&mut self, p: &hir::Pat) {\n                 self.index.entry(p.id).or_insert(vec![]).push(self.entry);\n-                visit::walk_pat(self, p)\n+                intravisit::walk_pat(self, p)\n             }\n         }\n     }\n@@ -533,7 +533,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n \n     fn pretty_print_to<'b>(&self, wr: Box<io::Write + 'b>,\n                            blk: &hir::Block) -> io::Result<()> {\n-        let mut ps = pprust::rust_printer_annotated(wr, self);\n+        let mut ps = pprust::rust_printer_annotated(wr, self, None);\n         try!(ps.cbox(pprust::indent_unit));\n         try!(ps.ibox(0));\n         try!(ps.print_block(blk));"}, {"sha": "6dfddce9bfed89cb4bb5a8fec963c0dab58786f1", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -14,7 +14,7 @@\n \n use front::map as ast_map;\n use rustc_front::hir;\n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::{self, Visitor};\n \n use middle::{def, pat_util, privacy, ty};\n use middle::def_id::{DefId};\n@@ -182,29 +182,29 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                                 .contains(&attr::ReprExtern)\n                         });\n \n-                        visit::walk_item(self, &*item);\n+                        intravisit::walk_item(self, &*item);\n                     }\n                     hir::ItemEnum(..) => {\n                         self.inherited_pub_visibility = item.vis == hir::Public;\n-                        visit::walk_item(self, &*item);\n+                        intravisit::walk_item(self, &*item);\n                     }\n                     hir::ItemFn(..)\n                     | hir::ItemTy(..)\n                     | hir::ItemStatic(..)\n                     | hir::ItemConst(..) => {\n-                        visit::walk_item(self, &*item);\n+                        intravisit::walk_item(self, &*item);\n                     }\n                     _ => ()\n                 }\n             }\n             ast_map::NodeTraitItem(trait_item) => {\n-                visit::walk_trait_item(self, trait_item);\n+                intravisit::walk_trait_item(self, trait_item);\n             }\n             ast_map::NodeImplItem(impl_item) => {\n-                visit::walk_impl_item(self, impl_item);\n+                intravisit::walk_impl_item(self, impl_item);\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n-                visit::walk_foreign_item(self, &*foreign_item);\n+                intravisit::walk_foreign_item(self, &*foreign_item);\n             }\n             _ => ()\n         }\n@@ -227,7 +227,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         });\n         self.live_symbols.extend(live_fields.map(|f| f.node.id));\n \n-        visit::walk_struct_def(self, def);\n+        intravisit::walk_struct_def(self, def);\n     }\n \n     fn visit_expr(&mut self, expr: &hir::Expr) {\n@@ -244,7 +244,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n             _ => ()\n         }\n \n-        visit::walk_expr(self, expr);\n+        intravisit::walk_expr(self, expr);\n     }\n \n     fn visit_arm(&mut self, arm: &hir::Arm) {\n@@ -257,10 +257,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n             // can't be reached unless the variant is constructed elsewhere.\n             let len = self.ignore_variant_stack.len();\n             self.ignore_variant_stack.push_all(&*variants);\n-            visit::walk_arm(self, arm);\n+            intravisit::walk_arm(self, arm);\n             self.ignore_variant_stack.truncate(len);\n         } else {\n-            visit::walk_arm(self, arm);\n+            intravisit::walk_arm(self, arm);\n         }\n     }\n \n@@ -278,23 +278,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         }\n \n         self.ignore_non_const_paths = true;\n-        visit::walk_pat(self, pat);\n+        intravisit::walk_pat(self, pat);\n         self.ignore_non_const_paths = false;\n     }\n \n     fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n         self.lookup_and_handle_definition(&id);\n-        visit::walk_path(self, path);\n+        intravisit::walk_path(self, path);\n     }\n \n     fn visit_path_list_item(&mut self, path: &hir::Path, item: &hir::PathListItem) {\n         self.lookup_and_handle_definition(&item.node.id());\n-        visit::walk_path_list_item(self, path, item);\n-    }\n-\n-    fn visit_item(&mut self, _: &hir::Item) {\n-        // Do not recurse into items. These items will be added to the\n-        // worklist and recursed into manually if necessary.\n+        intravisit::walk_path_list_item(self, path, item);\n     }\n }\n \n@@ -371,7 +366,6 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             }\n             _ => ()\n         }\n-        visit::walk_item(self, item);\n     }\n }\n \n@@ -408,7 +402,7 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n     let mut life_seeder = LifeSeeder {\n         worklist: worklist\n     };\n-    visit::walk_crate(&mut life_seeder, krate);\n+    krate.visit_all_items(&mut life_seeder);\n \n     return life_seeder.worklist;\n }\n@@ -530,6 +524,14 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n+    /// Walk nested items in place so that we don't report dead-code\n+    /// on inner functions when the outer function is already getting\n+    /// an error. We could do this also by checking the parents, but\n+    /// this is how the code is setup and it seems harmless enough.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         if self.should_warn_about_item(item) {\n             self.warn_dead_code(\n@@ -540,7 +542,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n             );\n         } else {\n             // Only continue if we didn't warn\n-            visit::walk_item(self, item);\n+            intravisit::walk_item(self, item);\n         }\n     }\n \n@@ -549,15 +551,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n             self.warn_dead_code(variant.node.data.id(), variant.span,\n                                 variant.node.name, \"variant\");\n         } else {\n-            visit::walk_variant(self, variant, g, id);\n+            intravisit::walk_variant(self, variant, g, id);\n         }\n     }\n \n     fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n         if !self.symbol_is_live(fi.id, None) {\n             self.warn_dead_code(fi.id, fi.span, fi.name, fi.node.descriptive_variant());\n         }\n-        visit::walk_foreign_item(self, fi);\n+        intravisit::walk_foreign_item(self, fi);\n     }\n \n     fn visit_struct_field(&mut self, field: &hir::StructField) {\n@@ -566,7 +568,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n                                 field.node.name().unwrap(), \"struct field\");\n         }\n \n-        visit::walk_struct_field(self, field);\n+        intravisit::walk_struct_field(self, field);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n@@ -576,14 +578,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"associated const\");\n                 }\n-                visit::walk_expr(self, expr)\n+                intravisit::walk_expr(self, expr)\n             }\n             hir::ImplItemKind::Method(_, ref body) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"method\");\n                 }\n-                visit::walk_block(self, body)\n+                intravisit::walk_block(self, body)\n             }\n             hir::ImplItemKind::Type(..) => {}\n         }\n@@ -593,10 +595,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         match trait_item.node {\n             hir::ConstTraitItem(_, Some(ref expr)) => {\n-                visit::walk_expr(self, expr)\n+                intravisit::walk_expr(self, expr)\n             }\n             hir::MethodTraitItem(_, Some(ref body)) => {\n-                visit::walk_block(self, body)\n+                intravisit::walk_block(self, body)\n             }\n             hir::ConstTraitItem(_, None) |\n             hir::MethodTraitItem(_, None) |\n@@ -612,5 +614,5 @@ pub fn check_crate(tcx: &ty::ctxt,\n     let live_symbols = find_live(tcx, exported_items,\n                                  reachable_symbols, krate);\n     let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };\n-    visit::walk_crate(&mut visitor, krate);\n+    intravisit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "822faae772611f82c1a3b56385e4cf78f9f6e038", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -19,8 +19,8 @@ use middle::ty::MethodCall;\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc_front::hir;\n-use rustc_front::visit;\n-use rustc_front::visit::{FnKind, Visitor};\n+use rustc_front::intravisit;\n+use rustc_front::intravisit::{FnKind, Visitor};\n \n #[derive(Copy, Clone)]\n struct UnsafeContext {\n@@ -94,7 +94,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             self.unsafe_context = UnsafeContext::new(SafeContext)\n         }\n \n-        visit::walk_fn(self, fn_kind, fn_decl, block, span);\n+        intravisit::walk_fn(self, fn_kind, fn_decl, block, span);\n \n         self.unsafe_context = old_unsafe_context\n     }\n@@ -133,7 +133,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             hir::DefaultBlock | hir::PushUnstableBlock | hir:: PopUnstableBlock => {}\n         }\n \n-        visit::walk_block(self, block);\n+        intravisit::walk_block(self, block);\n \n         self.unsafe_context = old_unsafe_context\n     }\n@@ -177,7 +177,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_expr(self, expr);\n+        intravisit::walk_expr(self, expr);\n     }\n }\n \n@@ -187,5 +187,5 @@ pub fn check_crate(tcx: &ty::ctxt) {\n         unsafe_context: UnsafeContext::new(SafeContext),\n     };\n \n-    visit::walk_crate(&mut visitor, tcx.map.krate());\n+    tcx.map.krate().visit_all_items(&mut visitor);\n }"}, {"sha": "ecf16aaed836a699c72457bb2781a120fce1e7d1", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -10,20 +10,19 @@\n \n \n use front::map as ast_map;\n+use middle::def_id::{CRATE_DEF_INDEX};\n use session::{config, Session};\n use syntax::ast::NodeId;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::entry::EntryPointType;\n use rustc_front::hir::{Item, ItemFn};\n-use rustc_front::visit;\n-use rustc_front::visit::Visitor;\n+use rustc_front::intravisit::Visitor;\n \n-struct EntryContext<'a> {\n+struct EntryContext<'a, 'tcx: 'a> {\n     session: &'a Session,\n \n-    // The current depth in the ast\n-    depth: usize,\n+    map: &'a ast_map::Map<'tcx>,\n \n     // The top-level function called 'main'\n     main_fn: Option<(NodeId, Span)>,\n@@ -39,11 +38,12 @@ struct EntryContext<'a> {\n     non_main_fns: Vec<(NodeId, Span)> ,\n }\n \n-impl<'a, 'v> Visitor<'v> for EntryContext<'a> {\n-    fn visit_item(&mut self, item: &Item) {\n-        self.depth += 1;\n-        find_item(item, self);\n-        self.depth -= 1;\n+impl<'a, 'tcx> Visitor<'tcx> for EntryContext<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx Item) {\n+        let def_id = self.map.local_def_id(item.id);\n+        let def_key = self.map.def_key(def_id);\n+        let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n+        find_item(item, self, at_root);\n     }\n }\n \n@@ -64,29 +64,29 @@ pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n \n     let mut ctxt = EntryContext {\n         session: session,\n-        depth: 0,\n+        map: ast_map,\n         main_fn: None,\n         attr_main_fn: None,\n         start_fn: None,\n         non_main_fns: Vec::new(),\n     };\n \n-    visit::walk_crate(&mut ctxt, ast_map.krate());\n+    ast_map.krate().visit_all_items(&mut ctxt);\n \n     configure_main(&mut ctxt);\n }\n \n // Beware, this is duplicated in libsyntax/entry.rs, make sure to keep\n // them in sync.\n-fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n+fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n     match item.node {\n         ItemFn(..) => {\n             if attr::contains_name(&item.attrs, \"start\") {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n             } else if item.name.as_str() == \"main\" {\n-                if depth == 1 {\n+                if at_root {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed\n                 } else {\n@@ -101,8 +101,8 @@ fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n }\n \n \n-fn find_item(item: &Item, ctxt: &mut EntryContext) {\n-    match entry_point_type(item, ctxt.depth) {\n+fn find_item(item: &Item, ctxt: &mut EntryContext, at_root: bool) {\n+    match entry_point_type(item, at_root) {\n         EntryPointType::MainNamed => {\n             if ctxt.main_fn.is_none() {\n                 ctxt.main_fn = Some((item.id, item.span));\n@@ -132,8 +132,6 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n         },\n         EntryPointType::None => ()\n     }\n-\n-    visit::walk_item(ctxt, item);\n }\n \n fn configure_main(this: &mut EntryContext) {"}, {"sha": "11a28c0b5ea9a00db035e79f2c95ed63e8c08087", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -19,7 +19,7 @@ use std::fmt;\n use syntax::abi::RustIntrinsic;\n use syntax::ast;\n use syntax::codemap::Span;\n-use rustc_front::visit::{self, Visitor, FnKind};\n+use rustc_front::intravisit::{self, Visitor, FnKind};\n use rustc_front::hir;\n \n pub fn check_crate(tcx: &ctxt) {\n@@ -29,7 +29,7 @@ pub fn check_crate(tcx: &ctxt) {\n         dummy_sized_ty: tcx.types.isize,\n         dummy_unsized_ty: tcx.mk_slice(tcx.types.isize),\n     };\n-    visit::walk_crate(&mut visitor, tcx.map.krate());\n+    tcx.map.krate().visit_all_items(&mut visitor);\n }\n \n struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n@@ -222,11 +222,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n                 let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n                 self.param_envs.push(param_env);\n-                visit::walk_fn(self, fk, fd, b, s);\n+                intravisit::walk_fn(self, fk, fd, b, s);\n                 self.param_envs.pop();\n             }\n             FnKind::Closure(..) => {\n-                visit::walk_fn(self, fk, fd, b, s);\n+                intravisit::walk_fn(self, fk, fd, b, s);\n             }\n         }\n \n@@ -255,7 +255,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n             }\n         }\n \n-        visit::walk_expr(self, expr);\n+        intravisit::walk_expr(self, expr);\n     }\n }\n "}, {"sha": "a37f62e52b819e789ad9f6751756f1f7e209400d", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -33,8 +33,7 @@ use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n-use rustc_front::visit::Visitor;\n-use rustc_front::visit;\n+use rustc_front::intravisit::Visitor;\n use rustc_front::hir;\n \n use std::iter::Enumerate;\n@@ -164,8 +163,6 @@ impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n                 self.collect_item(item_index, self.ast_map.local_def_id(item.id), item.span)\n             }\n         }\n-\n-        visit::walk_item(self, item);\n     }\n }\n \n@@ -202,7 +199,7 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     }\n \n     pub fn collect_local_language_items(&mut self, krate: &hir::Crate) {\n-        visit::walk_crate(self, krate);\n+        krate.visit_all_items(self);\n     }\n \n     pub fn collect_external_language_items(&mut self) {"}, {"sha": "9b18b79d261558cef460286a84c85c31116c2201", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -127,7 +127,7 @@ use syntax::ptr::P;\n use rustc_front::hir::Expr;\n use rustc_front::hir;\n use rustc_front::print::pprust::{expr_to_string, block_to_string};\n-use rustc_front::visit::{self, Visitor, FnKind};\n+use rustc_front::intravisit::{self, Visitor, FnKind};\n \n /// For use with `propagate_through_loop`.\n enum LoopKind<'a> {\n@@ -192,7 +192,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n-    visit::walk_crate(&mut IrMaps::new(tcx), tcx.map.krate());\n+    tcx.map.krate().visit_all_items(&mut IrMaps::new(tcx));\n     tcx.sess.abort_if_errors();\n }\n \n@@ -390,7 +390,7 @@ fn visit_fn(ir: &mut IrMaps,\n \n     // gather up the various local variables, significant expressions,\n     // and so forth:\n-    visit::walk_fn(&mut fn_maps, fk, decl, body, sp);\n+    intravisit::walk_fn(&mut fn_maps, fk, decl, body, sp);\n \n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or panic\n@@ -423,7 +423,7 @@ fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n           name: name\n         }));\n     });\n-    visit::walk_local(ir, local);\n+    intravisit::walk_local(ir, local);\n }\n \n fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n@@ -439,7 +439,7 @@ fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n             }));\n         })\n     }\n-    visit::walk_arm(ir, arm);\n+    intravisit::walk_arm(ir, arm);\n }\n \n fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n@@ -451,7 +451,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         if let DefLocal(..) = def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n-        visit::walk_expr(ir, expr);\n+        intravisit::walk_expr(ir, expr);\n       }\n       hir::ExprClosure(..) => {\n         // Interesting control flow (for loops can contain labeled\n@@ -474,17 +474,17 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         });\n         ir.set_captures(expr.id, call_caps);\n \n-        visit::walk_expr(ir, expr);\n+        intravisit::walk_expr(ir, expr);\n       }\n \n       // live nodes required for interesting control flow:\n       hir::ExprIf(..) | hir::ExprMatch(..) | hir::ExprWhile(..) | hir::ExprLoop(..) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::walk_expr(ir, expr);\n+        intravisit::walk_expr(ir, expr);\n       }\n       hir::ExprBinary(op, _, _) if ::rustc_front::util::lazy_binop(op.node) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::walk_expr(ir, expr);\n+        intravisit::walk_expr(ir, expr);\n       }\n \n       // otherwise, live nodes are not required:\n@@ -497,7 +497,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n       hir::ExprInlineAsm(..) | hir::ExprBox(..) |\n       hir::ExprRange(..) => {\n-          visit::walk_expr(ir, expr);\n+          intravisit::walk_expr(ir, expr);\n       }\n     }\n }\n@@ -1383,7 +1383,7 @@ fn check_local(this: &mut Liveness, local: &hir::Local) {\n         }\n     }\n \n-    visit::walk_local(this, local);\n+    intravisit::walk_local(this, local);\n }\n \n fn check_arm(this: &mut Liveness, arm: &hir::Arm) {\n@@ -1393,21 +1393,21 @@ fn check_arm(this: &mut Liveness, arm: &hir::Arm) {\n     this.arm_pats_bindings(arm.pats.first().map(|p| &**p), |this, ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n-    visit::walk_arm(this, arm);\n+    intravisit::walk_arm(this, arm);\n }\n \n fn check_expr(this: &mut Liveness, expr: &Expr) {\n     match expr.node {\n       hir::ExprAssign(ref l, _) => {\n         this.check_lvalue(&**l);\n \n-        visit::walk_expr(this, expr);\n+        intravisit::walk_expr(this, expr);\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n         this.check_lvalue(&**l);\n \n-        visit::walk_expr(this, expr);\n+        intravisit::walk_expr(this, expr);\n       }\n \n       hir::ExprInlineAsm(ref ia) => {\n@@ -1421,7 +1421,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n           this.visit_expr(&**out);\n         }\n \n-        visit::walk_expr(this, expr);\n+        intravisit::walk_expr(this, expr);\n       }\n \n       // no correctness conditions related to liveness\n@@ -1435,7 +1435,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n       hir::ExprClosure(..) | hir::ExprPath(..) | hir::ExprBox(..) |\n       hir::ExprRange(..) => {\n-        visit::walk_expr(this, expr);\n+        intravisit::walk_expr(this, expr);\n       }\n     }\n }\n@@ -1532,7 +1532,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             _ => {\n                 // For other kinds of lvalues, no checks are required,\n                 // and any embedded expressions are actually rvalues\n-                visit::walk_expr(self, expr);\n+                intravisit::walk_expr(self, expr);\n             }\n         }\n     }"}, {"sha": "86237a2321a722550b6e6aa9e18c5b9480d7e85f", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -28,8 +28,8 @@ use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n use rustc_front::hir;\n-use rustc_front::visit::Visitor;\n-use rustc_front::visit;\n+use rustc_front::intravisit::Visitor;\n+use rustc_front::intravisit;\n \n // Returns true if the given set of generics implies that the item it's\n // associated with must be inlined.\n@@ -87,9 +87,7 @@ struct ReachableContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n-\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n-\n         match expr.node {\n             hir::ExprPath(..) => {\n                 let def = match self.tcx.def_map.borrow().get(&expr.id) {\n@@ -138,12 +136,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_expr(self, expr)\n-    }\n-\n-    fn visit_item(&mut self, _item: &hir::Item) {\n-        // Do not recurse into items. These items will be added to the worklist\n-        // and recursed into manually if necessary.\n+        intravisit::walk_expr(self, expr)\n     }\n }\n \n@@ -260,7 +253,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match item.node {\n                     hir::ItemFn(_, _, _, _, _, ref search_block) => {\n                         if item_might_be_inlined(&*item) {\n-                            visit::walk_block(self, &**search_block)\n+                            intravisit::walk_block(self, &**search_block)\n                         }\n                     }\n \n@@ -292,7 +285,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         self.visit_expr(&*expr);\n                     }\n                     hir::MethodTraitItem(_, Some(ref body)) => {\n-                        visit::walk_block(self, body);\n+                        intravisit::walk_block(self, body);\n                     }\n                     hir::TypeTraitItem(..) => {}\n                 }\n@@ -305,7 +298,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Method(ref sig, ref body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n-                            visit::walk_block(self, body)\n+                            intravisit::walk_block(self, body)\n                         }\n                     }\n                     hir::ImplItemKind::Type(_) => {}\n@@ -350,8 +343,6 @@ impl<'a, 'v> Visitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n                 }\n             }\n         }\n-\n-        visit::walk_item(self, item);\n     }\n }\n \n@@ -381,8 +372,7 @@ pub fn find_reachable(tcx: &ty::ctxt,\n             exported_items: exported_items,\n             worklist: &mut reachable_context.worklist,\n         };\n-\n-        visit::walk_crate(&mut collect_private_impl_items, tcx.map.krate());\n+        tcx.map.krate().visit_all_items(&mut collect_private_impl_items);\n     }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch."}, {"sha": "45b8ac4a16dae9469f12893dd89952e523ad484f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -30,7 +30,7 @@ use syntax::codemap::{self, Span};\n use syntax::ast::{self, NodeId};\n \n use rustc_front::hir;\n-use rustc_front::visit::{self, Visitor, FnKind};\n+use rustc_front::intravisit::{self, Visitor, FnKind};\n use rustc_front::hir::{Block, Item, FnDecl, Arm, Pat, Stmt, Expr, Local};\n use rustc_front::util::stmt_id;\n \n@@ -696,7 +696,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &hir::Block) {\n \n     {\n         // This block should be kept approximately in sync with\n-        // `visit::walk_block`. (We manually walk the block, rather\n+        // `intravisit::walk_block`. (We manually walk the block, rather\n         // than call `walk_block`, in order to maintain precise\n         // index information.)\n \n@@ -735,7 +735,7 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &hir::Arm) {\n         visitor.terminating_scopes.insert(expr.id);\n     }\n \n-    visit::walk_arm(visitor, arm);\n+    intravisit::walk_arm(visitor, arm);\n }\n \n fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n@@ -750,7 +750,7 @@ fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n         _ => { }\n     }\n \n-    visit::walk_pat(visitor, pat);\n+    intravisit::walk_pat(visitor, pat);\n }\n \n fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &hir::Stmt) {\n@@ -767,7 +767,7 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &hir::Stmt) {\n \n     let prev_parent = visitor.cx.parent;\n     visitor.cx.parent = stmt_extent;\n-    visit::walk_stmt(visitor, stmt);\n+    intravisit::walk_stmt(visitor, stmt);\n     visitor.cx.parent = prev_parent;\n }\n \n@@ -844,7 +844,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &hir::Expr) {\n         }\n     }\n \n-    visit::walk_expr(visitor, expr);\n+    intravisit::walk_expr(visitor, expr);\n     visitor.cx = prev_cx;\n }\n \n@@ -935,7 +935,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n         None => { }\n     }\n \n-    visit::walk_local(visitor, local);\n+    intravisit::walk_local(visitor, local);\n \n     /// True if `pat` match the `P&` nonterminal:\n     ///\n@@ -1080,7 +1080,7 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &hir::Item) {\n         var_parent: ROOT_CODE_EXTENT,\n         parent: ROOT_CODE_EXTENT\n     };\n-    visit::walk_item(visitor, item);\n+    intravisit::walk_item(visitor, item);\n     visitor.create_item_scope_if_needed(item.id);\n     visitor.cx = prev_cx;\n     visitor.terminating_scopes = prev_ts;\n@@ -1119,8 +1119,8 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n         var_parent: fn_decl_scope,\n     };\n \n-    visit::walk_fn_decl(visitor, decl);\n-    visit::walk_fn_kind(visitor, kind);\n+    intravisit::walk_fn_decl(visitor, decl);\n+    intravisit::walk_fn_kind(visitor, kind);\n \n     // The body of the every fn is a root scope.\n     visitor.cx = Context {\n@@ -1181,12 +1181,12 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n     }\n \n     fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n-        visit::walk_impl_item(self, ii);\n+        intravisit::walk_impl_item(self, ii);\n         self.create_item_scope_if_needed(ii.id);\n     }\n \n     fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n-        visit::walk_trait_item(self, ti);\n+        intravisit::walk_trait_item(self, ti);\n         self.create_item_scope_if_needed(ti.id);\n     }\n \n@@ -1237,7 +1237,7 @@ pub fn resolve_crate(sess: &Session, krate: &hir::Crate) -> RegionMaps {\n             },\n             terminating_scopes: NodeSet()\n         };\n-        visit::walk_crate(&mut visitor, krate);\n+        krate.visit_all_items(&mut visitor);\n     }\n     return maps;\n }"}, {"sha": "1452cf2cd7667ee5e7b3ef34cc81ba7ce516ed43", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -32,7 +32,7 @@ use util::nodemap::NodeMap;\n \n use rustc_front::hir;\n use rustc_front::print::pprust::lifetime_to_string;\n-use rustc_front::visit::{self, Visitor, FnKind};\n+use rustc_front::intravisit::{self, Visitor, FnKind};\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum DefRegion {\n@@ -95,30 +95,28 @@ static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n pub fn krate(sess: &Session, krate: &hir::Crate, def_map: &DefMap) -> NamedRegionMap {\n     let mut named_region_map = NodeMap();\n-    visit::walk_crate(&mut LifetimeContext {\n+    krate.visit_all_items(&mut LifetimeContext {\n         sess: sess,\n         named_region_map: &mut named_region_map,\n         scope: &ROOT_SCOPE,\n         def_map: def_map,\n         trait_ref_hack: false,\n         labels_in_fn: vec![],\n-    }, krate);\n+    });\n     sess.abort_if_errors();\n     named_region_map\n }\n \n impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        // Items save/restore the set of labels. This way inner items\n-        // can freely reuse names, be they loop labels or lifetimes.\n-        let saved = replace(&mut self.labels_in_fn, vec![]);\n+        assert!(self.labels_in_fn.is_empty());\n \n         // Items always introduce a new root scope\n         self.with(RootScope, |_, this| {\n             match item.node {\n                 hir::ItemFn(..) => {\n                     // Fn lifetimes get added in visit_fn below:\n-                    visit::walk_item(this, item);\n+                    intravisit::walk_item(this, item);\n                 }\n                 hir::ItemExternCrate(_) |\n                 hir::ItemUse(_) |\n@@ -128,7 +126,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 hir::ItemStatic(..) |\n                 hir::ItemConst(..) => {\n                     // These sorts of items have no lifetime parameters at all.\n-                    visit::walk_item(this, item);\n+                    intravisit::walk_item(this, item);\n                 }\n                 hir::ItemTy(_, ref generics) |\n                 hir::ItemEnum(_, ref generics) |\n@@ -140,14 +138,14 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                     let early_scope = EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE);\n                     this.with(early_scope, |old_scope, this| {\n                         this.check_lifetime_defs(old_scope, lifetimes);\n-                        visit::walk_item(this, item);\n+                        intravisit::walk_item(this, item);\n                     });\n                 }\n             }\n         });\n \n-        // Done traversing the item; restore saved set of labels.\n-        replace(&mut self.labels_in_fn, saved);\n+        // Done traversing the item; remove any labels it created\n+        self.labels_in_fn.truncate(0);\n     }\n \n     fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n@@ -160,11 +158,11 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             match item.node {\n                 hir::ForeignItemFn(_, ref generics) => {\n                     this.visit_early_late(subst::FnSpace, generics, |this| {\n-                        visit::walk_foreign_item(this, item);\n+                        intravisit::walk_foreign_item(this, item);\n                     })\n                 }\n                 hir::ForeignItemStatic(..) => {\n-                    visit::walk_foreign_item(this, item);\n+                    intravisit::walk_foreign_item(this, item);\n                 }\n             }\n         });\n@@ -199,7 +197,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                     // a bare fn has no bounds, so everything\n                     // contained within is scoped within its binder.\n                     this.check_lifetime_defs(old_scope, &c.lifetimes);\n-                    visit::walk_ty(this, ty);\n+                    intravisit::walk_ty(this, ty);\n                 });\n             }\n             hir::TyPath(None, ref path) => {\n@@ -212,12 +210,12 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                         });\n                     }\n                     _ => {\n-                        visit::walk_ty(self, ty);\n+                        intravisit::walk_ty(self, ty);\n                     }\n                 }\n             }\n             _ => {\n-                visit::walk_ty(self, ty)\n+                intravisit::walk_ty(self, ty)\n             }\n         }\n     }\n@@ -230,9 +228,9 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n             self.visit_early_late(\n                 subst::FnSpace, &sig.generics,\n-                |this| visit::walk_trait_item(this, trait_item))\n+                |this| intravisit::walk_trait_item(this, trait_item))\n         } else {\n-            visit::walk_trait_item(self, trait_item);\n+            intravisit::walk_trait_item(self, trait_item);\n         }\n \n         replace(&mut self.labels_in_fn, saved);\n@@ -241,7 +239,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_block(&mut self, b: &hir::Block) {\n         self.with(BlockScope(region::DestructionScopeData::new(b.id),\n                              self.scope),\n-                  |_, this| visit::walk_block(this, b));\n+                  |_, this| intravisit::walk_block(this, b));\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n@@ -317,7 +315,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 for lifetime in &trait_ref.bound_lifetimes {\n                     this.visit_lifetime_def(lifetime);\n                 }\n-                visit::walk_path(this, &trait_ref.trait_ref.path)\n+                intravisit::walk_path(this, &trait_ref.trait_ref.path)\n             })\n         } else {\n             self.visit_trait_ref(&trait_ref.trait_ref)\n@@ -417,7 +415,7 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n \n                 self.labels_in_fn.push((label, ex.span));\n             }\n-            visit::walk_expr(self, ex)\n+            intravisit::walk_expr(self, ex)\n         }\n \n         fn visit_item(&mut self, _: &hir::Item) {\n@@ -463,7 +461,7 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n }\n \n impl<'a> LifetimeContext<'a> {\n-    // This is just like visit::walk_fn, except that it extracts the\n+    // This is just like intravisit::walk_fn, except that it extracts the\n     // labels of the function body and swaps them in before visiting\n     // the function body itself.\n     fn walk_fn<'b>(&mut self,\n@@ -473,16 +471,16 @@ impl<'a> LifetimeContext<'a> {\n                    _span: Span) {\n         match fk {\n             FnKind::ItemFn(_, generics, _, _, _, _) => {\n-                visit::walk_fn_decl(self, fd);\n+                intravisit::walk_fn_decl(self, fd);\n                 self.visit_generics(generics);\n             }\n             FnKind::Method(_, sig, _) => {\n-                visit::walk_fn_decl(self, fd);\n+                intravisit::walk_fn_decl(self, fd);\n                 self.visit_generics(&sig.generics);\n                 self.visit_explicit_self(&sig.explicit_self);\n             }\n             FnKind::Closure(..) => {\n-                visit::walk_fn_decl(self, fd);\n+                intravisit::walk_fn_decl(self, fd);\n             }\n         }\n "}, {"sha": "2ba66807d4ecc5b7e9079cb883bd59778de83346", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -31,7 +31,7 @@ use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n \n use rustc_front::hir;\n use rustc_front::hir::{Block, Crate, Item, Generics, StructField, Variant};\n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::{self, Visitor};\n \n use std::mem::replace;\n use std::cmp::Ordering;\n@@ -174,6 +174,13 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n+    /// Because stability levels are scoped lexically, we want to walk\n+    /// nested items in the context of the outer item, so enable\n+    /// deep-walking.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, i: &Item) {\n         let orig_in_trait_impl = self.in_trait_impl;\n         let orig_in_enum = self.in_enum;\n@@ -203,15 +210,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n         }\n \n         self.annotate(i.id, &i.attrs, i.span, kind, |v| {\n-            visit::walk_item(v, i)\n+            intravisit::walk_item(v, i)\n         });\n         self.in_trait_impl = orig_in_trait_impl;\n         self.in_enum = orig_in_enum;\n     }\n \n     fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n         self.annotate(ti.id, &ti.attrs, ti.span, AnnotationKind::Required, |v| {\n-            visit::walk_trait_item(v, ti);\n+            intravisit::walk_trait_item(v, ti);\n         });\n     }\n \n@@ -222,13 +229,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n             AnnotationKind::Required\n         };\n         self.annotate(ii.id, &ii.attrs, ii.span, kind, |v| {\n-            visit::walk_impl_item(v, ii);\n+            intravisit::walk_impl_item(v, ii);\n         });\n     }\n \n     fn visit_variant(&mut self, var: &Variant, g: &'v Generics, item_id: NodeId) {\n         self.annotate(var.node.data.id(), &var.node.attrs, var.span, AnnotationKind::Required, |v| {\n-            visit::walk_variant(v, var, g, item_id);\n+            intravisit::walk_variant(v, var, g, item_id);\n         })\n     }\n \n@@ -240,13 +247,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n             AnnotationKind::Required\n         };\n         self.annotate(s.node.id, &s.node.attrs, s.span, kind, |v| {\n-            visit::walk_struct_field(v, s);\n+            intravisit::walk_struct_field(v, s);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n         self.annotate(i.id, &i.attrs, i.span, AnnotationKind::Required, |v| {\n-            visit::walk_foreign_item(v, i);\n+            intravisit::walk_foreign_item(v, i);\n         });\n     }\n \n@@ -259,7 +266,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n \n impl<'tcx> Index<'tcx> {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, tcx: &ty::ctxt<'tcx>, krate: &Crate, export_map: &PublicItems) {\n+    pub fn build(&mut self, tcx: &ty::ctxt<'tcx>, krate: &'tcx Crate, export_map: &PublicItems) {\n         let mut annotator = Annotator {\n             tcx: tcx,\n             index: self,\n@@ -269,7 +276,7 @@ impl<'tcx> Index<'tcx> {\n             in_enum: false,\n         };\n         annotator.annotate(ast::CRATE_NODE_ID, &krate.attrs, krate.span, AnnotationKind::Required,\n-                           |v| visit::walk_crate(v, krate));\n+                           |v| intravisit::walk_crate(v, krate));\n     }\n \n     pub fn new(krate: &Crate) -> Index {\n@@ -308,9 +315,7 @@ pub fn check_unstable_api_usage(tcx: &ty::ctxt)\n         used_features: FnvHashMap(),\n         in_skip_block: 0,\n     };\n-\n-    let krate = tcx.map.krate();\n-    visit::walk_crate(&mut checker, krate);\n+    intravisit::walk_crate(&mut checker, tcx.map.krate());\n \n     let used_features = checker.used_features;\n     return used_features;\n@@ -379,6 +384,13 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n+    /// Because stability levels are scoped lexically, we want to walk\n+    /// nested items in the context of the outer item, so enable\n+    /// deep-walking.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n@@ -387,31 +399,31 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n \n         check_item(self.tcx, item, true,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n     }\n \n     fn visit_expr(&mut self, ex: &hir::Expr) {\n         check_expr(self.tcx, ex,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n-        visit::walk_expr(self, ex);\n+        intravisit::walk_expr(self, ex);\n     }\n \n     fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n         check_path(self.tcx, path, id,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n-        visit::walk_path(self, path)\n+        intravisit::walk_path(self, path)\n     }\n \n     fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n         check_path_list_item(self.tcx, item,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n-        visit::walk_path_list_item(self, prefix, item)\n+        intravisit::walk_path_list_item(self, prefix, item)\n     }\n \n     fn visit_pat(&mut self, pat: &hir::Pat) {\n         check_pat(self.tcx, pat,\n                   &mut |id, sp, stab| self.check(id, sp, stab));\n-        visit::walk_pat(self, pat)\n+        intravisit::walk_pat(self, pat)\n     }\n \n     fn visit_block(&mut self, b: &hir::Block) {\n@@ -425,7 +437,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n             }\n             _ => {}\n         }\n-        visit::walk_block(self, b);\n+        intravisit::walk_block(self, b);\n         self.in_skip_block = old_skip_count;\n     }\n }"}, {"sha": "ee999c91097e71d5f42dfe55a2940add7f17d48b", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -18,8 +18,8 @@ use middle::lang_items;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n-use rustc_front::visit::Visitor;\n-use rustc_front::visit;\n+use rustc_front::intravisit::Visitor;\n+use rustc_front::intravisit;\n use rustc_front::hir;\n \n use std::collections::HashSet;\n@@ -50,7 +50,7 @@ pub fn check_crate(krate: &hir::Crate,\n \n     {\n         let mut cx = Context { sess: sess, items: items };\n-        visit::walk_crate(&mut cx, krate);\n+        krate.visit_all_items(&mut cx);\n     }\n     verify(sess, items);\n }\n@@ -114,7 +114,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n             None => {}\n             Some(lang_item) => self.register(&lang_item, i.span),\n         }\n-        visit::walk_foreign_item(self, i)\n+        intravisit::walk_foreign_item(self, i)\n     }\n }\n "}, {"sha": "00f58c6af91554d8e63e6b1234e40be39413db70", "filename": "src/librustc/plugin/build.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fplugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Fplugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fbuild.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -14,8 +14,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::diagnostic;\n-use rustc_front::visit;\n-use rustc_front::visit::Visitor;\n+use rustc_front::intravisit::Visitor;\n use rustc_front::hir;\n \n struct RegistrarFinder {\n@@ -30,8 +29,6 @@ impl<'v> Visitor<'v> for RegistrarFinder {\n                 self.registrars.push((item.id, item.span));\n             }\n         }\n-\n-        visit::walk_item(self, item);\n     }\n }\n \n@@ -40,7 +37,7 @@ pub fn find_plugin_registrar(diagnostic: &diagnostic::SpanHandler,\n                              krate: &hir::Crate)\n                              -> Option<ast::NodeId> {\n     let mut finder = RegistrarFinder { registrars: Vec::new() };\n-    visit::walk_crate(&mut finder, krate);\n+    krate.visit_all_items(&mut finder);\n \n     match finder.registrars.len() {\n         0 => None,"}, {"sha": "c6f58ef28802befe850fc85618111325008f6e24", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -21,8 +21,8 @@ use std::path::Path;\n use std::time::Duration;\n \n use rustc_front::hir;\n-use rustc_front::visit;\n-use rustc_front::visit::Visitor;\n+use rustc_front::intravisit;\n+use rustc_front::intravisit::Visitor;\n \n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n@@ -169,7 +169,7 @@ impl<'v, P> Visitor<'v> for LoopQueryVisitor<P> where P: FnMut(&hir::Expr_) -> b\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n           hir::ExprLoop(..) | hir::ExprWhile(..) => {}\n-          _ => visit::walk_expr(self, e)\n+          _ => intravisit::walk_expr(self, e)\n         }\n     }\n }\n@@ -181,7 +181,7 @@ pub fn loop_query<P>(b: &hir::Block, p: P) -> bool where P: FnMut(&hir::Expr_) -\n         p: p,\n         flag: false,\n     };\n-    visit::walk_block(&mut v, b);\n+    intravisit::walk_block(&mut v, b);\n     return v.flag;\n }\n \n@@ -193,7 +193,7 @@ struct BlockQueryVisitor<P> where P: FnMut(&hir::Expr) -> bool {\n impl<'v, P> Visitor<'v> for BlockQueryVisitor<P> where P: FnMut(&hir::Expr) -> bool {\n     fn visit_expr(&mut self, e: &hir::Expr) {\n         self.flag |= (self.p)(e);\n-        visit::walk_expr(self, e)\n+        intravisit::walk_expr(self, e)\n     }\n }\n \n@@ -204,7 +204,7 @@ pub fn block_query<P>(b: &hir::Block, p: P) -> bool where P: FnMut(&hir::Expr) -\n         p: p,\n         flag: false,\n     };\n-    visit::walk_block(&mut v, &*b);\n+    intravisit::walk_block(&mut v, &*b);\n     return v.flag;\n }\n "}, {"sha": "a5df0b94b337400334ac91578659f89d157e794c", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -49,7 +49,7 @@\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n use rustc_front::hir;\n-use rustc_front::visit;\n+use rustc_front::intravisit as visit;\n \n #[derive(Clone, PartialEq, Debug)]\n pub struct Svh {\n@@ -83,7 +83,7 @@ impl Svh {\n         }\n \n         {\n-            let mut visit = svh_visitor::make(&mut state);\n+            let mut visit = svh_visitor::make(&mut state, krate);\n             visit::walk_crate(&mut visit, krate);\n         }\n \n@@ -134,19 +134,20 @@ mod svh_visitor {\n     use syntax::ast::{self, Name, NodeId};\n     use syntax::codemap::Span;\n     use syntax::parse::token;\n-    use rustc_front::visit;\n-    use rustc_front::visit::{Visitor, FnKind};\n+    use rustc_front::intravisit as visit;\n+    use rustc_front::intravisit::{Visitor, FnKind};\n     use rustc_front::hir::*;\n     use rustc_front::hir;\n \n     use std::hash::{Hash, SipHasher};\n \n     pub struct StrictVersionHashVisitor<'a> {\n+        pub krate: &'a Crate,\n         pub st: &'a mut SipHasher,\n     }\n \n-    pub fn make<'a>(st: &'a mut SipHasher) -> StrictVersionHashVisitor<'a> {\n-        StrictVersionHashVisitor { st: st }\n+    pub fn make<'a>(st: &'a mut SipHasher, krate: &'a Crate) -> StrictVersionHashVisitor<'a> {\n+        StrictVersionHashVisitor { st: st, krate: krate }\n     }\n \n     // To off-load the bulk of the hash-computation on #[derive(Hash)],\n@@ -300,15 +301,19 @@ mod svh_visitor {\n         }\n     }\n \n-    impl<'a, 'v> Visitor<'v> for StrictVersionHashVisitor<'a> {\n-        fn visit_variant_data(&mut self, s: &VariantData, name: Name,\n-                            g: &Generics, _: NodeId, _: Span) {\n+    impl<'a> Visitor<'a> for StrictVersionHashVisitor<'a> {\n+        fn visit_nested_item(&mut self, item: ItemId) {\n+            self.visit_item(self.krate.item(item.id))\n+        }\n+\n+        fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n+                              g: &'a Generics, _: NodeId, _: Span) {\n             SawStructDef(name.as_str()).hash(self.st);\n             visit::walk_generics(self, g);\n             visit::walk_struct_def(self, s)\n         }\n \n-        fn visit_variant(&mut self, v: &Variant, g: &Generics, item_id: NodeId) {\n+        fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n             SawVariant.hash(self.st);\n             // walk_variant does not call walk_generics, so do it here.\n             visit::walk_generics(self, g);\n@@ -333,11 +338,11 @@ mod svh_visitor {\n             SawIdent(name.as_str()).hash(self.st);\n         }\n \n-        fn visit_lifetime(&mut self, l: &Lifetime) {\n+        fn visit_lifetime(&mut self, l: &'a Lifetime) {\n             SawLifetime(l.name.as_str()).hash(self.st);\n         }\n \n-        fn visit_lifetime_def(&mut self, l: &LifetimeDef) {\n+        fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n             SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n         }\n \n@@ -346,88 +351,88 @@ mod svh_visitor {\n         // monomorphization and cross-crate inlining generally implies\n         // that a change to a crate body will require downstream\n         // crates to be recompiled.\n-        fn visit_expr(&mut self, ex: &Expr) {\n+        fn visit_expr(&mut self, ex: &'a Expr) {\n             SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n         }\n \n-        fn visit_stmt(&mut self, s: &Stmt) {\n+        fn visit_stmt(&mut self, s: &'a Stmt) {\n             SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n         }\n \n-        fn visit_foreign_item(&mut self, i: &ForeignItem) {\n+        fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n             // FIXME (#14132) ideally we would incorporate privacy (or\n             // perhaps reachability) somewhere here, so foreign items\n             // that do not leak into downstream crates would not be\n             // part of the ABI.\n             SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n         }\n \n-        fn visit_item(&mut self, i: &Item) {\n+        fn visit_item(&mut self, i: &'a Item) {\n             // FIXME (#14132) ideally would incorporate reachability\n             // analysis somewhere here, so items that never leak into\n             // downstream crates (e.g. via monomorphisation or\n             // inlining) would not be part of the ABI.\n             SawItem.hash(self.st); visit::walk_item(self, i)\n         }\n \n-        fn visit_mod(&mut self, m: &Mod, _s: Span, _n: NodeId) {\n+        fn visit_mod(&mut self, m: &'a Mod, _s: Span, _n: NodeId) {\n             SawMod.hash(self.st); visit::walk_mod(self, m)\n         }\n \n-        fn visit_decl(&mut self, d: &Decl) {\n+        fn visit_decl(&mut self, d: &'a Decl) {\n             SawDecl.hash(self.st); visit::walk_decl(self, d)\n         }\n \n-        fn visit_ty(&mut self, t: &Ty) {\n+        fn visit_ty(&mut self, t: &'a Ty) {\n             SawTy.hash(self.st); visit::walk_ty(self, t)\n         }\n \n-        fn visit_generics(&mut self, g: &Generics) {\n+        fn visit_generics(&mut self, g: &'a Generics) {\n             SawGenerics.hash(self.st); visit::walk_generics(self, g)\n         }\n \n-        fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                    b: &'v Block, s: Span, _: NodeId) {\n+        fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n+                    b: &'a Block, s: Span, _: NodeId) {\n             SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s)\n         }\n \n-        fn visit_trait_item(&mut self, ti: &TraitItem) {\n+        fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n             SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n         }\n \n-        fn visit_impl_item(&mut self, ii: &ImplItem) {\n+        fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n             SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n         }\n \n-        fn visit_struct_field(&mut self, s: &StructField) {\n+        fn visit_struct_field(&mut self, s: &'a StructField) {\n             SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n         }\n \n-        fn visit_explicit_self(&mut self, es: &ExplicitSelf) {\n+        fn visit_explicit_self(&mut self, es: &'a ExplicitSelf) {\n             SawExplicitSelf.hash(self.st); visit::walk_explicit_self(self, es)\n         }\n \n-        fn visit_path(&mut self, path: &Path, _: ast::NodeId) {\n+        fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n             SawPath.hash(self.st); visit::walk_path(self, path)\n         }\n \n-        fn visit_path_list_item(&mut self, prefix: &Path, item: &'v PathListItem) {\n+        fn visit_path_list_item(&mut self, prefix: &'a Path, item: &'a PathListItem) {\n             SawPath.hash(self.st); visit::walk_path_list_item(self, prefix, item)\n         }\n \n-        fn visit_block(&mut self, b: &Block) {\n+        fn visit_block(&mut self, b: &'a Block) {\n             SawBlock.hash(self.st); visit::walk_block(self, b)\n         }\n \n-        fn visit_pat(&mut self, p: &Pat) {\n+        fn visit_pat(&mut self, p: &'a Pat) {\n             SawPat.hash(self.st); visit::walk_pat(self, p)\n         }\n \n-        fn visit_local(&mut self, l: &Local) {\n+        fn visit_local(&mut self, l: &'a Local) {\n             SawLocal.hash(self.st); visit::walk_local(self, l)\n         }\n \n-        fn visit_arm(&mut self, a: &Arm) {\n+        fn visit_arm(&mut self, a: &'a Arm) {\n             SawArm.hash(self.st); visit::walk_arm(self, a)\n         }\n     }"}, {"sha": "083cc972ccad2f71e676e3393d1eb30ccd97cf71", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -30,8 +30,8 @@ use syntax::codemap::Span;\n use syntax::ast::NodeId;\n use rustc_front::hir;\n use rustc_front::hir::{Expr, FnDecl, Block, Pat};\n-use rustc_front::visit;\n-use rustc_front::visit::Visitor;\n+use rustc_front::intravisit;\n+use rustc_front::intravisit::Visitor;\n \n mod lifetime;\n mod restrictions;\n@@ -533,7 +533,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n             }\n         }\n \n-        visit::walk_expr(self, ex);\n+        intravisit::walk_expr(self, ex);\n     }\n }\n "}, {"sha": "a9a7b34df12c43fbaec00dd9ee67c9d1ff5c7a82", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -43,8 +43,8 @@ use syntax::codemap::Span;\n \n use rustc_front::hir;\n use rustc_front::hir::{FnDecl, Block};\n-use rustc_front::visit;\n-use rustc_front::visit::{Visitor, FnKind};\n+use rustc_front::intravisit;\n+use rustc_front::intravisit::{Visitor, FnKind};\n use rustc_front::util as hir_util;\n \n pub mod check_loans;\n@@ -85,14 +85,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n         if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n             gather_loans::gather_loans_in_static_initializer(self, &*expr);\n         }\n-        visit::walk_trait_item(self, ti);\n+        intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n             gather_loans::gather_loans_in_static_initializer(self, &*expr);\n         }\n-        visit::walk_impl_item(self, ii);\n+        intravisit::walk_impl_item(self, ii);\n     }\n }\n \n@@ -108,7 +108,7 @@ pub fn check_crate(tcx: &ty::ctxt) {\n         }\n     };\n \n-    visit::walk_crate(&mut bccx, tcx.map.krate());\n+    tcx.map.krate().visit_all_items(&mut bccx);\n \n     if tcx.sess.borrowck_stats() {\n         println!(\"--- borrowck stats ---\");\n@@ -142,7 +142,7 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &hir::Item) {\n         _ => { }\n     }\n \n-    visit::walk_item(this, item);\n+    intravisit::walk_item(this, item);\n }\n \n /// Collection of conclusions determined via borrow checker analyses.\n@@ -181,7 +181,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                              decl,\n                              body);\n \n-    visit::walk_fn(this, fk, decl, body, sp);\n+    intravisit::walk_fn(this, fk, decl, body, sp);\n }\n \n fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,"}, {"sha": "f8ac2759e854d4ceb420739a80396e35009b8e5a", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -827,7 +827,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n                                    time(time_passes,\n                                         \"lint checking\",\n-                                        || lint::check_crate(tcx, krate, &exported_items));\n+                                        || lint::check_crate(tcx, &exported_items));\n \n                                    // The above three passes generate errors w/o aborting\n                                    tcx.sess.abort_if_errors();"}, {"sha": "8815d574725526f7da86429764c06d57944f50e5", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -777,7 +777,8 @@ pub fn pretty_print_input(sess: Session,\n                                                       &mut rdr,\n                                                       box out,\n                                                       annotation.pp_ann(),\n-                                                      true);\n+                                                      true,\n+                                                      Some(ast_map.krate()));\n                 for node_id in uii.all_matching_node_ids(ast_map) {\n                     let node = ast_map.get(node_id);\n                     try!(pp_state.print_node(&node));"}, {"sha": "e33f5df4d3da42905db9baf522aa389ca1d8bf09", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -189,9 +189,10 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                       names: &[String])\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n-            for item in &m.items {\n+            for item in &m.item_ids {\n+                let item = this.infcx.tcx.map.expect_item(item.id);\n                 if item.name.to_string() == names[idx] {\n-                    return search(this, &**item, idx + 1, names);\n+                    return search(this, item, idx + 1, names);\n                 }\n             }\n             return None;"}, {"sha": "7ec4e1ba33121d99f67fa8de3b78c1c8397ba6b9", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 54, "deletions": 32, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -77,10 +77,14 @@ pub trait Folder : Sized {\n         noop_fold_foreign_item(ni, self)\n     }\n \n-    fn fold_item(&mut self, i: P<Item>) -> P<Item> {\n+    fn fold_item(&mut self, i: Item) -> Item {\n         noop_fold_item(i, self)\n     }\n \n+    fn fold_item_id(&mut self, i: ItemId) -> ItemId {\n+        noop_fold_item_id(i, self)\n+    }\n+\n     fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n         noop_fold_struct_field(sf, self)\n     }\n@@ -271,10 +275,16 @@ pub trait Folder : Sized {\n         noop_fold_where_predicate(where_predicate, self)\n     }\n \n+    /// called for the `id` on each declaration\n     fn new_id(&mut self, i: NodeId) -> NodeId {\n         i\n     }\n \n+    /// called for ids that are references (e.g., ItemDef)\n+    fn map_id(&mut self, i: NodeId) -> NodeId {\n+        i\n+    }\n+\n     fn new_span(&mut self, sp: Span) -> Span {\n         sp\n     }\n@@ -342,7 +352,7 @@ pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> P<Decl> {\n                 span: fld.new_span(span),\n             },\n             DeclItem(it) => Spanned {\n-                node: DeclItem(fld.fold_item(it)),\n+                node: DeclItem(fld.fold_item_id(it)),\n                 span: fld.new_span(span),\n             },\n         }\n@@ -879,66 +889,78 @@ pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T) -> P<ImplI\n     })\n }\n \n-pub fn noop_fold_mod<T: Folder>(Mod { inner, items }: Mod, folder: &mut T) -> Mod {\n+pub fn noop_fold_mod<T: Folder>(Mod { inner, item_ids }: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n-        items: items.into_iter().map(|x| folder.fold_item(x)).collect(),\n+        item_ids: item_ids.into_iter().map(|x| folder.fold_item_id(x)).collect(),\n     }\n }\n \n-pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span, exported_macros }: Crate,\n+pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span,\n+                                          exported_macros, items }: Crate,\n                                   folder: &mut T)\n                                   -> Crate {\n     let config = folder.fold_meta_items(config);\n \n-    let crate_mod = folder.fold_item(P(hir::Item {\n+    let crate_mod = folder.fold_item(hir::Item {\n         name: token::special_idents::invalid.name,\n         attrs: attrs,\n         id: DUMMY_NODE_ID,\n         vis: hir::Public,\n         span: span,\n         node: hir::ItemMod(module),\n-    }));\n+    });\n \n-    let (module, attrs, span) =\n-        crate_mod.and_then(|hir::Item { attrs, span, node, .. }| {\n+    let (module, attrs, span) = match crate_mod {\n+        hir::Item { attrs, span, node, .. } => {\n             match node {\n                 hir::ItemMod(m) => (m, attrs, span),\n                 _ => panic!(\"fold converted a module to not a module\"),\n             }\n-        });\n+        }\n+    };\n+\n+    let items = items.into_iter()\n+                     .map(|(id, item)| (id, folder.fold_item(item)))\n+                     .collect();\n \n     Crate {\n         module: module,\n         attrs: attrs,\n         config: config,\n         span: span,\n         exported_macros: exported_macros,\n+        items: items,\n     }\n }\n \n-pub fn noop_fold_item<T: Folder>(item: P<Item>, folder: &mut T) -> P<Item> {\n-    item.map(|Item { id, name, attrs, node, vis, span }| {\n-        let id = folder.new_id(id);\n-        let node = folder.fold_item_underscore(node);\n-        // FIXME: we should update the impl_pretty_name, but it uses pretty printing.\n-        // let ident = match node {\n-        //     // The node may have changed, recompute the \"pretty\" impl name.\n-        //     ItemImpl(_, _, _, ref maybe_trait, ref ty, _) => {\n-        //         impl_pretty_name(maybe_trait, Some(&**ty))\n-        //     }\n-        //     _ => ident\n-        // };\n-\n-        Item {\n-            id: id,\n-            name: folder.fold_name(name),\n-            attrs: fold_attrs(attrs, folder),\n-            node: node,\n-            vis: vis,\n-            span: folder.new_span(span),\n-        }\n-    })\n+pub fn noop_fold_item_id<T: Folder>(i: ItemId, folder: &mut T) -> ItemId {\n+    let id = folder.map_id(i.id);\n+    ItemId { id: id }\n+}\n+\n+// fold one item into one item\n+pub fn noop_fold_item<T: Folder>(item: Item, folder: &mut T) -> Item {\n+    let Item { id, name, attrs, node, vis, span } = item;\n+    let id = folder.new_id(id);\n+    let node = folder.fold_item_underscore(node);\n+    // FIXME: we should update the impl_pretty_name, but it uses pretty printing.\n+    // let ident = match node {\n+    //     // The node may have changed, recompute the \"pretty\" impl name.\n+    //     ItemImpl(_, _, _, ref maybe_trait, ref ty, _) => {\n+    //         impl_pretty_name(maybe_trait, Some(&**ty))\n+    //     }\n+    //     _ => ident\n+    // };\n+\n+    Item {\n+        id: id,\n+        name: folder.fold_name(name),\n+        attrs: fold_attrs(attrs, folder),\n+        node: node,\n+        vis: vis,\n+        span: folder.new_span(span),\n+    }\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) -> P<ForeignItem> {"}, {"sha": "95d73daa632b15eaea6752a8f7d6c2d48ddde8bb", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -35,6 +35,8 @@ pub use self::ViewPath_::*;\n pub use self::Visibility::*;\n pub use self::PathParameters::*;\n \n+use intravisit::Visitor;\n+use std::collections::BTreeMap;\n use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, Ident, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n@@ -320,13 +322,41 @@ pub struct WhereEqPredicate {\n     pub ty: P<Ty>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n     pub config: CrateConfig,\n     pub span: Span,\n     pub exported_macros: Vec<MacroDef>,\n+\n+    // NB: We use a BTreeMap here so that `visit_all_items` iterates\n+    // over the ids in increasing order. In principle it should not\n+    // matter what order we visit things in, but in *practice* it\n+    // does, because it can affect the order in which errors are\n+    // detected, which in turn can make compile-fail tests yield\n+    // slightly different results.\n+    pub items: BTreeMap<NodeId, Item>,\n+}\n+\n+impl Crate {\n+    pub fn item(&self, id: NodeId) -> &Item {\n+        &self.items[&id]\n+    }\n+\n+    /// Visits all items in the crate in some determinstic (but\n+    /// unspecified) order. If you just need to process every item,\n+    /// but don't care about nesting, this method is the best choice.\n+    ///\n+    /// If you do care about nesting -- usually because your algorithm\n+    /// follows lexical scoping rules -- then you want a different\n+    /// approach. You should override `visit_nested_item` in your\n+    /// visitor and then call `intravisit::walk_crate` instead.\n+    pub fn visit_all_items<'hir, V:Visitor<'hir>>(&'hir self, visitor: &mut V) {\n+        for (_, item) in &self.items {\n+            visitor.visit_item(item);\n+        }\n+    }\n }\n \n /// A macro definition, in this crate or imported from another.\n@@ -537,7 +567,7 @@ pub enum Decl_ {\n     /// A local (let) binding:\n     DeclLocal(P<Local>),\n     /// An item binding:\n-    DeclItem(P<Item>),\n+    DeclItem(ItemId),\n }\n \n /// represents one arm of a 'match'\n@@ -992,7 +1022,7 @@ pub struct Mod {\n     /// For `mod foo;`, the inner span ranges from the first token\n     /// to the last token in the external file.\n     pub inner: Span,\n-    pub items: Vec<P<Item>>,\n+    pub item_ids: Vec<ItemId>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1205,7 +1235,13 @@ impl VariantData {\n     }\n }\n \n-\n+// The bodies for items are stored \"out of line\", in a separate\n+// hashmap in the `Crate`. Here we just record the node-id of the item\n+// so it can fetched later.\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ItemId {\n+    pub id: NodeId,\n+}\n \n //  FIXME (#3300): Should allow items to be anonymous. Right now\n //  we just use dummy names for anon items."}, {"sha": "3a43feb8ba74bc1899e8fce343f999af39055004", "filename": "src/librustc_front/intravisit.rs", "status": "renamed", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fintravisit.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -13,15 +13,17 @@\n //! call `visit::walk_*` to apply the default traversal algorithm, or prevent\n //! deeper traversal by doing nothing.\n //!\n-//! Note: it is an important invariant that the default visitor walks the body\n-//! of a function in \"execution order\" (more concretely, reverse post-order\n-//! with respect to the CFG implied by the AST), meaning that if AST node A may\n-//! execute before AST node B, then A is visited first.  The borrow checker in\n-//! particular relies on this property.\n+//! When visiting the HIR, the contents of nested items are NOT visited\n+//! by default. This is different from the AST visitor, which does a deep walk.\n+//! Hence this module is called `intravisit`; see the method `visit_nested_item`\n+//! for more details.\n //!\n-//! Note: walking an AST before macro expansion is probably a bad idea. For\n-//! instance, a walker looking for item names in a module will miss all of\n-//! those that are created by the expansion of a macro.\n+//! Note: it is an important invariant that the default visitor walks\n+//! the body of a function in \"execution order\" (more concretely,\n+//! reverse post-order with respect to the CFG implied by the AST),\n+//! meaning that if AST node A may execute before AST node B, then A\n+//! is visited first.  The borrow checker in particular relies on this\n+//! property.\n \n use syntax::abi::Abi;\n use syntax::ast::{Ident, NodeId, CRATE_NODE_ID, Name, Attribute};\n@@ -45,11 +47,39 @@ pub enum FnKind<'a> {\n /// the substructure of the input via the corresponding `walk` method;\n /// e.g. the `visit_mod` method by default calls `visit::walk_mod`.\n ///\n+/// Note that this visitor does NOT visit nested items by default\n+/// (this is why the module is called `intravisit`, to distinguish it\n+/// from the AST's `visit` module, which acts differently). If you\n+/// simply want to visit all items in the crate in some order, you\n+/// should call `Crate::visit_all_items`. Otherwise, see the comment\n+/// on `visit_nested_item` for details on how to visit nested items.\n+///\n /// If you want to ensure that your code handles every variant\n /// explicitly, you need to override each method.  (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n pub trait Visitor<'v> : Sized {\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Nested items.\n+\n+    /// Invoked when a nested item is encountered. By default, does\n+    /// nothing. If you want a deep walk, you need to override to\n+    /// fetch the item contents. But most of the time, it is easier\n+    /// (and better) to invoke `Crate::visit_all_items`, which visits\n+    /// all items in the crate in some order (but doesn't respect\n+    /// nesting).\n+    #[allow(unused_variables)]\n+    fn visit_nested_item(&mut self, id: ItemId) {\n+    }\n+\n+    /// Visit the top-level item and (optionally) nested items. See\n+    /// `visit_nested_item` for details.\n+    fn visit_item(&mut self, i: &'v Item) {\n+        walk_item(self, i)\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n@@ -62,9 +92,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_foreign_item(&mut self, i: &'v ForeignItem) {\n         walk_foreign_item(self, i)\n     }\n-    fn visit_item(&mut self, i: &'v Item) {\n-        walk_item(self, i)\n-    }\n     fn visit_local(&mut self, l: &'v Local) {\n         walk_local(self, l)\n     }\n@@ -180,6 +207,7 @@ pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, ident: Ident)\n     visitor.visit_name(span, ident.name);\n }\n \n+/// Walks the contents of a crate. See also `Crate::visit_all_items`.\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n     walk_list!(visitor, visit_attribute, &krate.attrs);\n@@ -193,7 +221,9 @@ pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroD\n }\n \n pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n-    walk_list!(visitor, visit_item, &module.items);\n+    for &item_id in &module.item_ids {\n+        visitor.visit_nested_item(item_id);\n+    }\n }\n \n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n@@ -658,7 +688,7 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n     match declaration.node {\n         DeclLocal(ref local) => visitor.visit_local(local),\n-        DeclItem(ref item) => visitor.visit_item(item),\n+        DeclItem(item) => visitor.visit_nested_item(item),\n     }\n }\n ", "previous_filename": "src/librustc_front/visit.rs"}, {"sha": "bafda3086fd89854b0b7d54f79d01ed4c8e38b68", "filename": "src/librustc_front/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flib.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -51,7 +51,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n pub mod hir;\n pub mod lowering;\n pub mod fold;\n-pub mod visit;\n+pub mod intravisit;\n pub mod util;\n \n pub mod print {"}, {"sha": "b984f23c4c02a8541bd63f8dad750fc597a6a1ed", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 525, "deletions": 501, "changes": 1026, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -63,14 +63,15 @@\n \n use hir;\n \n+use std::collections::BTreeMap;\n use std::collections::HashMap;\n-\n use syntax::ast::*;\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned, Span};\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{self, str_to_ident};\n use syntax::std_inject;\n+use syntax::visit::{self, Visitor};\n \n use std::cell::{Cell, RefCell};\n \n@@ -138,17 +139,17 @@ impl<'a, 'hir> LoweringContext<'a> {\n     }\n }\n \n-pub fn lower_view_path(_lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::ViewPath> {\n+pub fn lower_view_path(lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::ViewPath> {\n     P(Spanned {\n         node: match view_path.node {\n             ViewPathSimple(ident, ref path) => {\n-                hir::ViewPathSimple(ident.name, lower_path(_lctx, path))\n+                hir::ViewPathSimple(ident.name, lower_path(lctx, path))\n             }\n             ViewPathGlob(ref path) => {\n-                hir::ViewPathGlob(lower_path(_lctx, path))\n+                hir::ViewPathGlob(lower_path(lctx, path))\n             }\n             ViewPathList(ref path, ref path_list_idents) => {\n-                hir::ViewPathList(lower_path(_lctx, path),\n+                hir::ViewPathList(lower_path(lctx, path),\n                                   path_list_idents.iter()\n                                                   .map(|path_list_ident| {\n                                                       Spanned {\n@@ -175,177 +176,177 @@ pub fn lower_view_path(_lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::\n     })\n }\n \n-pub fn lower_arm(_lctx: &LoweringContext, arm: &Arm) -> hir::Arm {\n+pub fn lower_arm(lctx: &LoweringContext, arm: &Arm) -> hir::Arm {\n     hir::Arm {\n         attrs: arm.attrs.clone(),\n-        pats: arm.pats.iter().map(|x| lower_pat(_lctx, x)).collect(),\n-        guard: arm.guard.as_ref().map(|ref x| lower_expr(_lctx, x)),\n-        body: lower_expr(_lctx, &arm.body),\n+        pats: arm.pats.iter().map(|x| lower_pat(lctx, x)).collect(),\n+        guard: arm.guard.as_ref().map(|ref x| lower_expr(lctx, x)),\n+        body: lower_expr(lctx, &arm.body),\n     }\n }\n \n-pub fn lower_decl(_lctx: &LoweringContext, d: &Decl) -> P<hir::Decl> {\n+pub fn lower_decl(lctx: &LoweringContext, d: &Decl) -> P<hir::Decl> {\n     match d.node {\n         DeclLocal(ref l) => P(Spanned {\n-            node: hir::DeclLocal(lower_local(_lctx, l)),\n+            node: hir::DeclLocal(lower_local(lctx, l)),\n             span: d.span,\n         }),\n         DeclItem(ref it) => P(Spanned {\n-            node: hir::DeclItem(lower_item(_lctx, it)),\n+            node: hir::DeclItem(lower_item_id(lctx, it)),\n             span: d.span,\n         }),\n     }\n }\n \n-pub fn lower_ty_binding(_lctx: &LoweringContext, b: &TypeBinding) -> P<hir::TypeBinding> {\n+pub fn lower_ty_binding(lctx: &LoweringContext, b: &TypeBinding) -> P<hir::TypeBinding> {\n     P(hir::TypeBinding {\n         id: b.id,\n         name: b.ident.name,\n-        ty: lower_ty(_lctx, &b.ty),\n+        ty: lower_ty(lctx, &b.ty),\n         span: b.span,\n     })\n }\n \n-pub fn lower_ty(_lctx: &LoweringContext, t: &Ty) -> P<hir::Ty> {\n+pub fn lower_ty(lctx: &LoweringContext, t: &Ty) -> P<hir::Ty> {\n     P(hir::Ty {\n         id: t.id,\n         node: match t.node {\n             TyInfer => hir::TyInfer,\n-            TyVec(ref ty) => hir::TyVec(lower_ty(_lctx, ty)),\n-            TyPtr(ref mt) => hir::TyPtr(lower_mt(_lctx, mt)),\n+            TyVec(ref ty) => hir::TyVec(lower_ty(lctx, ty)),\n+            TyPtr(ref mt) => hir::TyPtr(lower_mt(lctx, mt)),\n             TyRptr(ref region, ref mt) => {\n-                hir::TyRptr(lower_opt_lifetime(_lctx, region), lower_mt(_lctx, mt))\n+                hir::TyRptr(lower_opt_lifetime(lctx, region), lower_mt(lctx, mt))\n             }\n             TyBareFn(ref f) => {\n                 hir::TyBareFn(P(hir::BareFnTy {\n-                    lifetimes: lower_lifetime_defs(_lctx, &f.lifetimes),\n-                    unsafety: lower_unsafety(_lctx, f.unsafety),\n+                    lifetimes: lower_lifetime_defs(lctx, &f.lifetimes),\n+                    unsafety: lower_unsafety(lctx, f.unsafety),\n                     abi: f.abi,\n-                    decl: lower_fn_decl(_lctx, &f.decl),\n+                    decl: lower_fn_decl(lctx, &f.decl),\n                 }))\n             }\n-            TyTup(ref tys) => hir::TyTup(tys.iter().map(|ty| lower_ty(_lctx, ty)).collect()),\n+            TyTup(ref tys) => hir::TyTup(tys.iter().map(|ty| lower_ty(lctx, ty)).collect()),\n             TyParen(ref ty) => {\n-                return lower_ty(_lctx, ty);\n+                return lower_ty(lctx, ty);\n             }\n             TyPath(ref qself, ref path) => {\n                 let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n                     hir::QSelf {\n-                        ty: lower_ty(_lctx, ty),\n+                        ty: lower_ty(lctx, ty),\n                         position: position,\n                     }\n                 });\n-                hir::TyPath(qself, lower_path(_lctx, path))\n+                hir::TyPath(qself, lower_path(lctx, path))\n             }\n             TyObjectSum(ref ty, ref bounds) => {\n-                hir::TyObjectSum(lower_ty(_lctx, ty), lower_bounds(_lctx, bounds))\n+                hir::TyObjectSum(lower_ty(lctx, ty), lower_bounds(lctx, bounds))\n             }\n             TyFixedLengthVec(ref ty, ref e) => {\n-                hir::TyFixedLengthVec(lower_ty(_lctx, ty), lower_expr(_lctx, e))\n+                hir::TyFixedLengthVec(lower_ty(lctx, ty), lower_expr(lctx, e))\n             }\n             TyTypeof(ref expr) => {\n-                hir::TyTypeof(lower_expr(_lctx, expr))\n+                hir::TyTypeof(lower_expr(lctx, expr))\n             }\n             TyPolyTraitRef(ref bounds) => {\n-                hir::TyPolyTraitRef(bounds.iter().map(|b| lower_ty_param_bound(_lctx, b)).collect())\n+                hir::TyPolyTraitRef(bounds.iter().map(|b| lower_ty_param_bound(lctx, b)).collect())\n             }\n             TyMac(_) => panic!(\"TyMac should have been expanded by now.\"),\n         },\n         span: t.span,\n     })\n }\n \n-pub fn lower_foreign_mod(_lctx: &LoweringContext, fm: &ForeignMod) -> hir::ForeignMod {\n+pub fn lower_foreign_mod(lctx: &LoweringContext, fm: &ForeignMod) -> hir::ForeignMod {\n     hir::ForeignMod {\n         abi: fm.abi,\n-        items: fm.items.iter().map(|x| lower_foreign_item(_lctx, x)).collect(),\n+        items: fm.items.iter().map(|x| lower_foreign_item(lctx, x)).collect(),\n     }\n }\n \n-pub fn lower_variant(_lctx: &LoweringContext, v: &Variant) -> P<hir::Variant> {\n+pub fn lower_variant(lctx: &LoweringContext, v: &Variant) -> P<hir::Variant> {\n     P(Spanned {\n         node: hir::Variant_ {\n             name: v.node.name.name,\n             attrs: v.node.attrs.clone(),\n-            data: lower_variant_data(_lctx, &v.node.data),\n-            disr_expr: v.node.disr_expr.as_ref().map(|e| lower_expr(_lctx, e)),\n+            data: lower_variant_data(lctx, &v.node.data),\n+            disr_expr: v.node.disr_expr.as_ref().map(|e| lower_expr(lctx, e)),\n         },\n         span: v.span,\n     })\n }\n \n-pub fn lower_path(_lctx: &LoweringContext, p: &Path) -> hir::Path {\n+pub fn lower_path(lctx: &LoweringContext, p: &Path) -> hir::Path {\n     hir::Path {\n         global: p.global,\n         segments: p.segments\n                    .iter()\n                    .map(|&PathSegment { identifier, ref parameters }| {\n                        hir::PathSegment {\n                            identifier: identifier,\n-                           parameters: lower_path_parameters(_lctx, parameters),\n+                           parameters: lower_path_parameters(lctx, parameters),\n                        }\n                    })\n                    .collect(),\n         span: p.span,\n     }\n }\n \n-pub fn lower_path_parameters(_lctx: &LoweringContext,\n+pub fn lower_path_parameters(lctx: &LoweringContext,\n                              path_parameters: &PathParameters)\n                              -> hir::PathParameters {\n     match *path_parameters {\n         AngleBracketedParameters(ref data) =>\n-            hir::AngleBracketedParameters(lower_angle_bracketed_parameter_data(_lctx, data)),\n+            hir::AngleBracketedParameters(lower_angle_bracketed_parameter_data(lctx, data)),\n         ParenthesizedParameters(ref data) =>\n-            hir::ParenthesizedParameters(lower_parenthesized_parameter_data(_lctx, data)),\n+            hir::ParenthesizedParameters(lower_parenthesized_parameter_data(lctx, data)),\n     }\n }\n \n-pub fn lower_angle_bracketed_parameter_data(_lctx: &LoweringContext,\n+pub fn lower_angle_bracketed_parameter_data(lctx: &LoweringContext,\n                                             data: &AngleBracketedParameterData)\n                                             -> hir::AngleBracketedParameterData {\n     let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings } = data;\n     hir::AngleBracketedParameterData {\n-        lifetimes: lower_lifetimes(_lctx, lifetimes),\n-        types: types.iter().map(|ty| lower_ty(_lctx, ty)).collect(),\n-        bindings: bindings.iter().map(|b| lower_ty_binding(_lctx, b)).collect(),\n+        lifetimes: lower_lifetimes(lctx, lifetimes),\n+        types: types.iter().map(|ty| lower_ty(lctx, ty)).collect(),\n+        bindings: bindings.iter().map(|b| lower_ty_binding(lctx, b)).collect(),\n     }\n }\n \n-pub fn lower_parenthesized_parameter_data(_lctx: &LoweringContext,\n+pub fn lower_parenthesized_parameter_data(lctx: &LoweringContext,\n                                           data: &ParenthesizedParameterData)\n                                           -> hir::ParenthesizedParameterData {\n     let &ParenthesizedParameterData { ref inputs, ref output, span } = data;\n     hir::ParenthesizedParameterData {\n-        inputs: inputs.iter().map(|ty| lower_ty(_lctx, ty)).collect(),\n-        output: output.as_ref().map(|ty| lower_ty(_lctx, ty)),\n+        inputs: inputs.iter().map(|ty| lower_ty(lctx, ty)).collect(),\n+        output: output.as_ref().map(|ty| lower_ty(lctx, ty)),\n         span: span,\n     }\n }\n \n-pub fn lower_local(_lctx: &LoweringContext, l: &Local) -> P<hir::Local> {\n+pub fn lower_local(lctx: &LoweringContext, l: &Local) -> P<hir::Local> {\n     P(hir::Local {\n         id: l.id,\n-        ty: l.ty.as_ref().map(|t| lower_ty(_lctx, t)),\n-        pat: lower_pat(_lctx, &l.pat),\n-        init: l.init.as_ref().map(|e| lower_expr(_lctx, e)),\n+        ty: l.ty.as_ref().map(|t| lower_ty(lctx, t)),\n+        pat: lower_pat(lctx, &l.pat),\n+        init: l.init.as_ref().map(|e| lower_expr(lctx, e)),\n         span: l.span,\n     })\n }\n \n-pub fn lower_explicit_self_underscore(_lctx: &LoweringContext,\n+pub fn lower_explicit_self_underscore(lctx: &LoweringContext,\n                                       es: &ExplicitSelf_)\n                                       -> hir::ExplicitSelf_ {\n     match *es {\n         SelfStatic => hir::SelfStatic,\n         SelfValue(v) => hir::SelfValue(v.name),\n         SelfRegion(ref lifetime, m, ident) => {\n-            hir::SelfRegion(lower_opt_lifetime(_lctx, lifetime),\n-                            lower_mutability(_lctx, m),\n+            hir::SelfRegion(lower_opt_lifetime(lctx, lifetime),\n+                            lower_mutability(lctx, m),\n                             ident.name)\n         }\n         SelfExplicit(ref typ, ident) => {\n-            hir::SelfExplicit(lower_ty(_lctx, typ), ident.name)\n+            hir::SelfExplicit(lower_ty(lctx, typ), ident.name)\n         }\n     }\n }\n@@ -357,59 +358,59 @@ pub fn lower_mutability(_lctx: &LoweringContext, m: Mutability) -> hir::Mutabili\n     }\n }\n \n-pub fn lower_explicit_self(_lctx: &LoweringContext, s: &ExplicitSelf) -> hir::ExplicitSelf {\n+pub fn lower_explicit_self(lctx: &LoweringContext, s: &ExplicitSelf) -> hir::ExplicitSelf {\n     Spanned {\n-        node: lower_explicit_self_underscore(_lctx, &s.node),\n+        node: lower_explicit_self_underscore(lctx, &s.node),\n         span: s.span,\n     }\n }\n \n-pub fn lower_arg(_lctx: &LoweringContext, arg: &Arg) -> hir::Arg {\n+pub fn lower_arg(lctx: &LoweringContext, arg: &Arg) -> hir::Arg {\n     hir::Arg {\n         id: arg.id,\n-        pat: lower_pat(_lctx, &arg.pat),\n-        ty: lower_ty(_lctx, &arg.ty),\n+        pat: lower_pat(lctx, &arg.pat),\n+        ty: lower_ty(lctx, &arg.ty),\n     }\n }\n \n-pub fn lower_fn_decl(_lctx: &LoweringContext, decl: &FnDecl) -> P<hir::FnDecl> {\n+pub fn lower_fn_decl(lctx: &LoweringContext, decl: &FnDecl) -> P<hir::FnDecl> {\n     P(hir::FnDecl {\n-        inputs: decl.inputs.iter().map(|x| lower_arg(_lctx, x)).collect(),\n+        inputs: decl.inputs.iter().map(|x| lower_arg(lctx, x)).collect(),\n         output: match decl.output {\n-            Return(ref ty) => hir::Return(lower_ty(_lctx, ty)),\n+            Return(ref ty) => hir::Return(lower_ty(lctx, ty)),\n             DefaultReturn(span) => hir::DefaultReturn(span),\n             NoReturn(span) => hir::NoReturn(span),\n         },\n         variadic: decl.variadic,\n     })\n }\n \n-pub fn lower_ty_param_bound(_lctx: &LoweringContext, tpb: &TyParamBound) -> hir::TyParamBound {\n+pub fn lower_ty_param_bound(lctx: &LoweringContext, tpb: &TyParamBound) -> hir::TyParamBound {\n     match *tpb {\n         TraitTyParamBound(ref ty, modifier) => {\n-            hir::TraitTyParamBound(lower_poly_trait_ref(_lctx, ty),\n-                                   lower_trait_bound_modifier(_lctx, modifier))\n+            hir::TraitTyParamBound(lower_poly_trait_ref(lctx, ty),\n+                                   lower_trait_bound_modifier(lctx, modifier))\n         }\n         RegionTyParamBound(ref lifetime) => {\n-            hir::RegionTyParamBound(lower_lifetime(_lctx, lifetime))\n+            hir::RegionTyParamBound(lower_lifetime(lctx, lifetime))\n         }\n     }\n }\n \n-pub fn lower_ty_param(_lctx: &LoweringContext, tp: &TyParam) -> hir::TyParam {\n+pub fn lower_ty_param(lctx: &LoweringContext, tp: &TyParam) -> hir::TyParam {\n     hir::TyParam {\n         id: tp.id,\n         name: tp.ident.name,\n-        bounds: lower_bounds(_lctx, &tp.bounds),\n-        default: tp.default.as_ref().map(|x| lower_ty(_lctx, x)),\n+        bounds: lower_bounds(lctx, &tp.bounds),\n+        default: tp.default.as_ref().map(|x| lower_ty(lctx, x)),\n         span: tp.span,\n     }\n }\n \n-pub fn lower_ty_params(_lctx: &LoweringContext,\n+pub fn lower_ty_params(lctx: &LoweringContext,\n                        tps: &OwnedSlice<TyParam>)\n                        -> OwnedSlice<hir::TyParam> {\n-    tps.iter().map(|tp| lower_ty_param(_lctx, tp)).collect()\n+    tps.iter().map(|tp| lower_ty_param(lctx, tp)).collect()\n }\n \n pub fn lower_lifetime(_lctx: &LoweringContext, l: &Lifetime) -> hir::Lifetime {\n@@ -420,48 +421,48 @@ pub fn lower_lifetime(_lctx: &LoweringContext, l: &Lifetime) -> hir::Lifetime {\n     }\n }\n \n-pub fn lower_lifetime_def(_lctx: &LoweringContext, l: &LifetimeDef) -> hir::LifetimeDef {\n+pub fn lower_lifetime_def(lctx: &LoweringContext, l: &LifetimeDef) -> hir::LifetimeDef {\n     hir::LifetimeDef {\n-        lifetime: lower_lifetime(_lctx, &l.lifetime),\n-        bounds: lower_lifetimes(_lctx, &l.bounds),\n+        lifetime: lower_lifetime(lctx, &l.lifetime),\n+        bounds: lower_lifetimes(lctx, &l.bounds),\n     }\n }\n \n-pub fn lower_lifetimes(_lctx: &LoweringContext, lts: &Vec<Lifetime>) -> Vec<hir::Lifetime> {\n-    lts.iter().map(|l| lower_lifetime(_lctx, l)).collect()\n+pub fn lower_lifetimes(lctx: &LoweringContext, lts: &Vec<Lifetime>) -> Vec<hir::Lifetime> {\n+    lts.iter().map(|l| lower_lifetime(lctx, l)).collect()\n }\n \n-pub fn lower_lifetime_defs(_lctx: &LoweringContext,\n+pub fn lower_lifetime_defs(lctx: &LoweringContext,\n                            lts: &Vec<LifetimeDef>)\n                            -> Vec<hir::LifetimeDef> {\n-    lts.iter().map(|l| lower_lifetime_def(_lctx, l)).collect()\n+    lts.iter().map(|l| lower_lifetime_def(lctx, l)).collect()\n }\n \n-pub fn lower_opt_lifetime(_lctx: &LoweringContext,\n+pub fn lower_opt_lifetime(lctx: &LoweringContext,\n                           o_lt: &Option<Lifetime>)\n                           -> Option<hir::Lifetime> {\n-    o_lt.as_ref().map(|lt| lower_lifetime(_lctx, lt))\n+    o_lt.as_ref().map(|lt| lower_lifetime(lctx, lt))\n }\n \n-pub fn lower_generics(_lctx: &LoweringContext, g: &Generics) -> hir::Generics {\n+pub fn lower_generics(lctx: &LoweringContext, g: &Generics) -> hir::Generics {\n     hir::Generics {\n-        ty_params: lower_ty_params(_lctx, &g.ty_params),\n-        lifetimes: lower_lifetime_defs(_lctx, &g.lifetimes),\n-        where_clause: lower_where_clause(_lctx, &g.where_clause),\n+        ty_params: lower_ty_params(lctx, &g.ty_params),\n+        lifetimes: lower_lifetime_defs(lctx, &g.lifetimes),\n+        where_clause: lower_where_clause(lctx, &g.where_clause),\n     }\n }\n \n-pub fn lower_where_clause(_lctx: &LoweringContext, wc: &WhereClause) -> hir::WhereClause {\n+pub fn lower_where_clause(lctx: &LoweringContext, wc: &WhereClause) -> hir::WhereClause {\n     hir::WhereClause {\n         id: wc.id,\n         predicates: wc.predicates\n                       .iter()\n-                      .map(|predicate| lower_where_predicate(_lctx, predicate))\n+                      .map(|predicate| lower_where_predicate(lctx, predicate))\n                       .collect(),\n     }\n }\n \n-pub fn lower_where_predicate(_lctx: &LoweringContext,\n+pub fn lower_where_predicate(lctx: &LoweringContext,\n                              pred: &WherePredicate)\n                              -> hir::WherePredicate {\n     match *pred {\n@@ -470,9 +471,9 @@ pub fn lower_where_predicate(_lctx: &LoweringContext,\n                                                             ref bounds,\n                                                             span}) => {\n             hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                bound_lifetimes: lower_lifetime_defs(_lctx, bound_lifetimes),\n-                bounded_ty: lower_ty(_lctx, bounded_ty),\n-                bounds: bounds.iter().map(|x| lower_ty_param_bound(_lctx, x)).collect(),\n+                bound_lifetimes: lower_lifetime_defs(lctx, bound_lifetimes),\n+                bounded_ty: lower_ty(lctx, bounded_ty),\n+                bounds: bounds.iter().map(|x| lower_ty_param_bound(lctx, x)).collect(),\n                 span: span,\n             })\n         }\n@@ -481,8 +482,8 @@ pub fn lower_where_predicate(_lctx: &LoweringContext,\n                                                               span}) => {\n             hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                 span: span,\n-                lifetime: lower_lifetime(_lctx, lifetime),\n-                bounds: bounds.iter().map(|bound| lower_lifetime(_lctx, bound)).collect(),\n+                lifetime: lower_lifetime(lctx, lifetime),\n+                bounds: bounds.iter().map(|bound| lower_lifetime(lctx, bound)).collect(),\n             })\n         }\n         WherePredicate::EqPredicate(WhereEqPredicate{ id,\n@@ -491,219 +492,238 @@ pub fn lower_where_predicate(_lctx: &LoweringContext,\n                                                       span}) => {\n             hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                 id: id,\n-                path: lower_path(_lctx, path),\n-                ty: lower_ty(_lctx, ty),\n+                path: lower_path(lctx, path),\n+                ty: lower_ty(lctx, ty),\n                 span: span,\n             })\n         }\n     }\n }\n \n-pub fn lower_variant_data(_lctx: &LoweringContext, vdata: &VariantData) -> hir::VariantData {\n+pub fn lower_variant_data(lctx: &LoweringContext, vdata: &VariantData) -> hir::VariantData {\n     match *vdata {\n         VariantData::Struct(ref fields, id) => {\n             hir::VariantData::Struct(fields.iter()\n-                                           .map(|f| lower_struct_field(_lctx, f))\n+                                           .map(|f| lower_struct_field(lctx, f))\n                                            .collect(),\n                                      id)\n         }\n         VariantData::Tuple(ref fields, id) => {\n             hir::VariantData::Tuple(fields.iter()\n-                                          .map(|f| lower_struct_field(_lctx, f))\n+                                          .map(|f| lower_struct_field(lctx, f))\n                                           .collect(),\n                                     id)\n         }\n         VariantData::Unit(id) => hir::VariantData::Unit(id),\n     }\n }\n \n-pub fn lower_trait_ref(_lctx: &LoweringContext, p: &TraitRef) -> hir::TraitRef {\n+pub fn lower_trait_ref(lctx: &LoweringContext, p: &TraitRef) -> hir::TraitRef {\n     hir::TraitRef {\n-        path: lower_path(_lctx, &p.path),\n+        path: lower_path(lctx, &p.path),\n         ref_id: p.ref_id,\n     }\n }\n \n-pub fn lower_poly_trait_ref(_lctx: &LoweringContext, p: &PolyTraitRef) -> hir::PolyTraitRef {\n+pub fn lower_poly_trait_ref(lctx: &LoweringContext, p: &PolyTraitRef) -> hir::PolyTraitRef {\n     hir::PolyTraitRef {\n-        bound_lifetimes: lower_lifetime_defs(_lctx, &p.bound_lifetimes),\n-        trait_ref: lower_trait_ref(_lctx, &p.trait_ref),\n+        bound_lifetimes: lower_lifetime_defs(lctx, &p.bound_lifetimes),\n+        trait_ref: lower_trait_ref(lctx, &p.trait_ref),\n         span: p.span,\n     }\n }\n \n-pub fn lower_struct_field(_lctx: &LoweringContext, f: &StructField) -> hir::StructField {\n+pub fn lower_struct_field(lctx: &LoweringContext, f: &StructField) -> hir::StructField {\n     Spanned {\n         node: hir::StructField_ {\n             id: f.node.id,\n-            kind: lower_struct_field_kind(_lctx, &f.node.kind),\n-            ty: lower_ty(_lctx, &f.node.ty),\n+            kind: lower_struct_field_kind(lctx, &f.node.kind),\n+            ty: lower_ty(lctx, &f.node.ty),\n             attrs: f.node.attrs.clone(),\n         },\n         span: f.span,\n     }\n }\n \n-pub fn lower_field(_lctx: &LoweringContext, f: &Field) -> hir::Field {\n+pub fn lower_field(lctx: &LoweringContext, f: &Field) -> hir::Field {\n     hir::Field {\n         name: respan(f.ident.span, f.ident.node.name),\n-        expr: lower_expr(_lctx, &f.expr),\n+        expr: lower_expr(lctx, &f.expr),\n         span: f.span,\n     }\n }\n \n-pub fn lower_mt(_lctx: &LoweringContext, mt: &MutTy) -> hir::MutTy {\n+pub fn lower_mt(lctx: &LoweringContext, mt: &MutTy) -> hir::MutTy {\n     hir::MutTy {\n-        ty: lower_ty(_lctx, &mt.ty),\n-        mutbl: lower_mutability(_lctx, mt.mutbl),\n+        ty: lower_ty(lctx, &mt.ty),\n+        mutbl: lower_mutability(lctx, mt.mutbl),\n     }\n }\n \n-pub fn lower_opt_bounds(_lctx: &LoweringContext,\n+pub fn lower_opt_bounds(lctx: &LoweringContext,\n                         b: &Option<OwnedSlice<TyParamBound>>)\n                         -> Option<OwnedSlice<hir::TyParamBound>> {\n-    b.as_ref().map(|ref bounds| lower_bounds(_lctx, bounds))\n+    b.as_ref().map(|ref bounds| lower_bounds(lctx, bounds))\n }\n \n-fn lower_bounds(_lctx: &LoweringContext, bounds: &TyParamBounds) -> hir::TyParamBounds {\n-    bounds.iter().map(|bound| lower_ty_param_bound(_lctx, bound)).collect()\n+fn lower_bounds(lctx: &LoweringContext, bounds: &TyParamBounds) -> hir::TyParamBounds {\n+    bounds.iter().map(|bound| lower_ty_param_bound(lctx, bound)).collect()\n }\n \n-pub fn lower_block(_lctx: &LoweringContext, b: &Block) -> P<hir::Block> {\n+pub fn lower_block(lctx: &LoweringContext, b: &Block) -> P<hir::Block> {\n     P(hir::Block {\n         id: b.id,\n-        stmts: b.stmts.iter().map(|s| lower_stmt(_lctx, s)).collect(),\n-        expr: b.expr.as_ref().map(|ref x| lower_expr(_lctx, x)),\n-        rules: lower_block_check_mode(_lctx, &b.rules),\n+        stmts: b.stmts.iter().map(|s| lower_stmt(lctx, s)).collect(),\n+        expr: b.expr.as_ref().map(|ref x| lower_expr(lctx, x)),\n+        rules: lower_block_check_mode(lctx, &b.rules),\n         span: b.span,\n     })\n }\n \n-pub fn lower_item_underscore(_lctx: &LoweringContext, i: &Item_) -> hir::Item_ {\n+pub fn lower_item_underscore(lctx: &LoweringContext, i: &Item_) -> hir::Item_ {\n     match *i {\n         ItemExternCrate(string) => hir::ItemExternCrate(string),\n         ItemUse(ref view_path) => {\n-            hir::ItemUse(lower_view_path(_lctx, view_path))\n+            hir::ItemUse(lower_view_path(lctx, view_path))\n         }\n         ItemStatic(ref t, m, ref e) => {\n-            hir::ItemStatic(lower_ty(_lctx, t),\n-                            lower_mutability(_lctx, m),\n-                            lower_expr(_lctx, e))\n+            hir::ItemStatic(lower_ty(lctx, t),\n+                            lower_mutability(lctx, m),\n+                            lower_expr(lctx, e))\n         }\n         ItemConst(ref t, ref e) => {\n-            hir::ItemConst(lower_ty(_lctx, t), lower_expr(_lctx, e))\n+            hir::ItemConst(lower_ty(lctx, t), lower_expr(lctx, e))\n         }\n         ItemFn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n-            hir::ItemFn(lower_fn_decl(_lctx, decl),\n-                        lower_unsafety(_lctx, unsafety),\n-                        lower_constness(_lctx, constness),\n+            hir::ItemFn(lower_fn_decl(lctx, decl),\n+                        lower_unsafety(lctx, unsafety),\n+                        lower_constness(lctx, constness),\n                         abi,\n-                        lower_generics(_lctx, generics),\n-                        lower_block(_lctx, body))\n+                        lower_generics(lctx, generics),\n+                        lower_block(lctx, body))\n         }\n-        ItemMod(ref m) => hir::ItemMod(lower_mod(_lctx, m)),\n-        ItemForeignMod(ref nm) => hir::ItemForeignMod(lower_foreign_mod(_lctx, nm)),\n+        ItemMod(ref m) => hir::ItemMod(lower_mod(lctx, m)),\n+        ItemForeignMod(ref nm) => hir::ItemForeignMod(lower_foreign_mod(lctx, nm)),\n         ItemTy(ref t, ref generics) => {\n-            hir::ItemTy(lower_ty(_lctx, t), lower_generics(_lctx, generics))\n+            hir::ItemTy(lower_ty(lctx, t), lower_generics(lctx, generics))\n         }\n         ItemEnum(ref enum_definition, ref generics) => {\n             hir::ItemEnum(hir::EnumDef {\n                               variants: enum_definition.variants\n                                                        .iter()\n-                                                       .map(|x| lower_variant(_lctx, x))\n+                                                       .map(|x| lower_variant(lctx, x))\n                                                        .collect(),\n                           },\n-                          lower_generics(_lctx, generics))\n+                          lower_generics(lctx, generics))\n         }\n         ItemStruct(ref struct_def, ref generics) => {\n-            let struct_def = lower_variant_data(_lctx, struct_def);\n-            hir::ItemStruct(struct_def, lower_generics(_lctx, generics))\n+            let struct_def = lower_variant_data(lctx, struct_def);\n+            hir::ItemStruct(struct_def, lower_generics(lctx, generics))\n         }\n         ItemDefaultImpl(unsafety, ref trait_ref) => {\n-            hir::ItemDefaultImpl(lower_unsafety(_lctx, unsafety),\n-                                 lower_trait_ref(_lctx, trait_ref))\n+            hir::ItemDefaultImpl(lower_unsafety(lctx, unsafety),\n+                                 lower_trait_ref(lctx, trait_ref))\n         }\n         ItemImpl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n             let new_impl_items = impl_items.iter()\n-                                           .map(|item| lower_impl_item(_lctx, item))\n+                                           .map(|item| lower_impl_item(lctx, item))\n                                            .collect();\n-            let ifce = ifce.as_ref().map(|trait_ref| lower_trait_ref(_lctx, trait_ref));\n-            hir::ItemImpl(lower_unsafety(_lctx, unsafety),\n-                          lower_impl_polarity(_lctx, polarity),\n-                          lower_generics(_lctx, generics),\n+            let ifce = ifce.as_ref().map(|trait_ref| lower_trait_ref(lctx, trait_ref));\n+            hir::ItemImpl(lower_unsafety(lctx, unsafety),\n+                          lower_impl_polarity(lctx, polarity),\n+                          lower_generics(lctx, generics),\n                           ifce,\n-                          lower_ty(_lctx, ty),\n+                          lower_ty(lctx, ty),\n                           new_impl_items)\n         }\n         ItemTrait(unsafety, ref generics, ref bounds, ref items) => {\n-            let bounds = lower_bounds(_lctx, bounds);\n-            let items = items.iter().map(|item| lower_trait_item(_lctx, item)).collect();\n-            hir::ItemTrait(lower_unsafety(_lctx, unsafety),\n-                           lower_generics(_lctx, generics),\n+            let bounds = lower_bounds(lctx, bounds);\n+            let items = items.iter().map(|item| lower_trait_item(lctx, item)).collect();\n+            hir::ItemTrait(lower_unsafety(lctx, unsafety),\n+                           lower_generics(lctx, generics),\n                            bounds,\n                            items)\n         }\n         ItemMac(_) => panic!(\"Shouldn't still be around\"),\n     }\n }\n \n-pub fn lower_trait_item(_lctx: &LoweringContext, i: &TraitItem) -> P<hir::TraitItem> {\n+pub fn lower_trait_item(lctx: &LoweringContext, i: &TraitItem) -> P<hir::TraitItem> {\n     P(hir::TraitItem {\n         id: i.id,\n         name: i.ident.name,\n         attrs: i.attrs.clone(),\n         node: match i.node {\n             ConstTraitItem(ref ty, ref default) => {\n-                hir::ConstTraitItem(lower_ty(_lctx, ty),\n-                                    default.as_ref().map(|x| lower_expr(_lctx, x)))\n+                hir::ConstTraitItem(lower_ty(lctx, ty),\n+                                    default.as_ref().map(|x| lower_expr(lctx, x)))\n             }\n             MethodTraitItem(ref sig, ref body) => {\n-                hir::MethodTraitItem(lower_method_sig(_lctx, sig),\n-                                     body.as_ref().map(|x| lower_block(_lctx, x)))\n+                hir::MethodTraitItem(lower_method_sig(lctx, sig),\n+                                     body.as_ref().map(|x| lower_block(lctx, x)))\n             }\n             TypeTraitItem(ref bounds, ref default) => {\n-                hir::TypeTraitItem(lower_bounds(_lctx, bounds),\n-                                   default.as_ref().map(|x| lower_ty(_lctx, x)))\n+                hir::TypeTraitItem(lower_bounds(lctx, bounds),\n+                                   default.as_ref().map(|x| lower_ty(lctx, x)))\n             }\n         },\n         span: i.span,\n     })\n }\n \n-pub fn lower_impl_item(_lctx: &LoweringContext, i: &ImplItem) -> P<hir::ImplItem> {\n+pub fn lower_impl_item(lctx: &LoweringContext, i: &ImplItem) -> P<hir::ImplItem> {\n     P(hir::ImplItem {\n         id: i.id,\n         name: i.ident.name,\n         attrs: i.attrs.clone(),\n-        vis: lower_visibility(_lctx, i.vis),\n+        vis: lower_visibility(lctx, i.vis),\n         node: match i.node {\n             ImplItemKind::Const(ref ty, ref expr) => {\n-                hir::ImplItemKind::Const(lower_ty(_lctx, ty), lower_expr(_lctx, expr))\n+                hir::ImplItemKind::Const(lower_ty(lctx, ty), lower_expr(lctx, expr))\n             }\n             ImplItemKind::Method(ref sig, ref body) => {\n-                hir::ImplItemKind::Method(lower_method_sig(_lctx, sig), lower_block(_lctx, body))\n+                hir::ImplItemKind::Method(lower_method_sig(lctx, sig), lower_block(lctx, body))\n             }\n-            ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(lower_ty(_lctx, ty)),\n+            ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(lower_ty(lctx, ty)),\n             ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n         },\n         span: i.span,\n     })\n }\n \n-pub fn lower_mod(_lctx: &LoweringContext, m: &Mod) -> hir::Mod {\n+pub fn lower_mod(lctx: &LoweringContext, m: &Mod) -> hir::Mod {\n     hir::Mod {\n         inner: m.inner,\n-        items: m.items.iter().map(|x| lower_item(_lctx, x)).collect(),\n+        item_ids: m.items.iter().map(|x| lower_item_id(lctx, x)).collect(),\n     }\n }\n \n-pub fn lower_crate(_lctx: &LoweringContext, c: &Crate) -> hir::Crate {\n+struct ItemLowerer<'lcx, 'interner: 'lcx> {\n+    items: BTreeMap<NodeId, hir::Item>,\n+    lctx: &'lcx LoweringContext<'interner>,\n+}\n+\n+impl<'lcx, 'interner> Visitor<'lcx> for ItemLowerer<'lcx, 'interner> {\n+    fn visit_item(&mut self, item: &'lcx Item) {\n+        self.items.insert(item.id, lower_item(self.lctx, item));\n+        visit::walk_item(self, item);\n+    }\n+}\n+\n+pub fn lower_crate(lctx: &LoweringContext, c: &Crate) -> hir::Crate {\n+    let items = {\n+        let mut item_lowerer = ItemLowerer { items: BTreeMap::new(), lctx: lctx };\n+        visit::walk_crate(&mut item_lowerer, c);\n+        item_lowerer.items\n+    };\n+\n     hir::Crate {\n-        module: lower_mod(_lctx, &c.module),\n+        module: lower_mod(lctx, &c.module),\n         attrs: c.attrs.clone(),\n         config: c.config.clone(),\n         span: c.span,\n-        exported_macros: c.exported_macros.iter().map(|m| lower_macro_def(_lctx, m)).collect(),\n+        exported_macros: c.exported_macros.iter().map(|m| lower_macro_def(lctx, m)).collect(),\n+        items: items,\n     }\n }\n \n@@ -721,51 +741,49 @@ pub fn lower_macro_def(_lctx: &LoweringContext, m: &MacroDef) -> hir::MacroDef {\n     }\n }\n \n-// fold one item into possibly many items\n-pub fn lower_item(_lctx: &LoweringContext, i: &Item) -> P<hir::Item> {\n-    P(lower_item_simple(_lctx, i))\n+pub fn lower_item_id(_lctx: &LoweringContext, i: &Item) -> hir::ItemId {\n+    hir::ItemId { id: i.id }\n }\n \n-// fold one item into exactly one item\n-pub fn lower_item_simple(_lctx: &LoweringContext, i: &Item) -> hir::Item {\n-    let node = lower_item_underscore(_lctx, &i.node);\n+pub fn lower_item(lctx: &LoweringContext, i: &Item) -> hir::Item {\n+    let node = lower_item_underscore(lctx, &i.node);\n \n     hir::Item {\n         id: i.id,\n         name: i.ident.name,\n         attrs: i.attrs.clone(),\n         node: node,\n-        vis: lower_visibility(_lctx, i.vis),\n+        vis: lower_visibility(lctx, i.vis),\n         span: i.span,\n     }\n }\n \n-pub fn lower_foreign_item(_lctx: &LoweringContext, i: &ForeignItem) -> P<hir::ForeignItem> {\n+pub fn lower_foreign_item(lctx: &LoweringContext, i: &ForeignItem) -> P<hir::ForeignItem> {\n     P(hir::ForeignItem {\n         id: i.id,\n         name: i.ident.name,\n         attrs: i.attrs.clone(),\n         node: match i.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n-                hir::ForeignItemFn(lower_fn_decl(_lctx, fdec), lower_generics(_lctx, generics))\n+                hir::ForeignItemFn(lower_fn_decl(lctx, fdec), lower_generics(lctx, generics))\n             }\n             ForeignItemStatic(ref t, m) => {\n-                hir::ForeignItemStatic(lower_ty(_lctx, t), m)\n+                hir::ForeignItemStatic(lower_ty(lctx, t), m)\n             }\n         },\n-        vis: lower_visibility(_lctx, i.vis),\n+        vis: lower_visibility(lctx, i.vis),\n         span: i.span,\n     })\n }\n \n-pub fn lower_method_sig(_lctx: &LoweringContext, sig: &MethodSig) -> hir::MethodSig {\n+pub fn lower_method_sig(lctx: &LoweringContext, sig: &MethodSig) -> hir::MethodSig {\n     hir::MethodSig {\n-        generics: lower_generics(_lctx, &sig.generics),\n+        generics: lower_generics(lctx, &sig.generics),\n         abi: sig.abi,\n-        explicit_self: lower_explicit_self(_lctx, &sig.explicit_self),\n-        unsafety: lower_unsafety(_lctx, sig.unsafety),\n-        constness: lower_constness(_lctx, sig.constness),\n-        decl: lower_fn_decl(_lctx, &sig.decl),\n+        explicit_self: lower_explicit_self(lctx, &sig.explicit_self),\n+        unsafety: lower_unsafety(lctx, sig.unsafety),\n+        constness: lower_constness(lctx, sig.constness),\n+        decl: lower_fn_decl(lctx, &sig.decl),\n     }\n }\n \n@@ -817,77 +835,74 @@ pub fn lower_binop(_lctx: &LoweringContext, b: BinOp) -> hir::BinOp {\n     }\n }\n \n-pub fn lower_pat(_lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n+pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n     P(hir::Pat {\n         id: p.id,\n         node: match p.node {\n             PatWild => hir::PatWild,\n             PatIdent(ref binding_mode, pth1, ref sub) => {\n-                hir::PatIdent(lower_binding_mode(_lctx, binding_mode),\n+                hir::PatIdent(lower_binding_mode(lctx, binding_mode),\n                               pth1,\n-                              sub.as_ref().map(|x| lower_pat(_lctx, x)))\n+                              sub.as_ref().map(|x| lower_pat(lctx, x)))\n             }\n-            PatLit(ref e) => hir::PatLit(lower_expr(_lctx, e)),\n+            PatLit(ref e) => hir::PatLit(lower_expr(lctx, e)),\n             PatEnum(ref pth, ref pats) => {\n-                hir::PatEnum(lower_path(_lctx, pth),\n+                hir::PatEnum(lower_path(lctx, pth),\n                              pats.as_ref()\n-                                 .map(|pats| pats.iter().map(|x| lower_pat(_lctx, x)).collect()))\n+                                 .map(|pats| pats.iter().map(|x| lower_pat(lctx, x)).collect()))\n             }\n             PatQPath(ref qself, ref pth) => {\n                 let qself = hir::QSelf {\n-                    ty: lower_ty(_lctx, &qself.ty),\n+                    ty: lower_ty(lctx, &qself.ty),\n                     position: qself.position,\n                 };\n-                hir::PatQPath(qself, lower_path(_lctx, pth))\n+                hir::PatQPath(qself, lower_path(lctx, pth))\n             }\n             PatStruct(ref pth, ref fields, etc) => {\n-                let pth = lower_path(_lctx, pth);\n+                let pth = lower_path(lctx, pth);\n                 let fs = fields.iter()\n                                .map(|f| {\n                                    Spanned {\n                                        span: f.span,\n                                        node: hir::FieldPat {\n                                            name: f.node.ident.name,\n-                                           pat: lower_pat(_lctx, &f.node.pat),\n+                                           pat: lower_pat(lctx, &f.node.pat),\n                                            is_shorthand: f.node.is_shorthand,\n                                        },\n                                    }\n                                })\n                                .collect();\n                 hir::PatStruct(pth, fs, etc)\n             }\n-            PatTup(ref elts) => hir::PatTup(elts.iter().map(|x| lower_pat(_lctx, x)).collect()),\n-            PatBox(ref inner) => hir::PatBox(lower_pat(_lctx, inner)),\n+            PatTup(ref elts) => hir::PatTup(elts.iter().map(|x| lower_pat(lctx, x)).collect()),\n+            PatBox(ref inner) => hir::PatBox(lower_pat(lctx, inner)),\n             PatRegion(ref inner, mutbl) => {\n-                hir::PatRegion(lower_pat(_lctx, inner), lower_mutability(_lctx, mutbl))\n+                hir::PatRegion(lower_pat(lctx, inner), lower_mutability(lctx, mutbl))\n             }\n             PatRange(ref e1, ref e2) => {\n-                hir::PatRange(lower_expr(_lctx, e1), lower_expr(_lctx, e2))\n+                hir::PatRange(lower_expr(lctx, e1), lower_expr(lctx, e2))\n             }\n             PatVec(ref before, ref slice, ref after) => {\n-                hir::PatVec(before.iter().map(|x| lower_pat(_lctx, x)).collect(),\n-                            slice.as_ref().map(|x| lower_pat(_lctx, x)),\n-                            after.iter().map(|x| lower_pat(_lctx, x)).collect())\n+                hir::PatVec(before.iter().map(|x| lower_pat(lctx, x)).collect(),\n+                            slice.as_ref().map(|x| lower_pat(lctx, x)),\n+                            after.iter().map(|x| lower_pat(lctx, x)).collect())\n             }\n             PatMac(_) => panic!(\"Shouldn't exist here\"),\n         },\n         span: p.span,\n     })\n }\n \n-// RAII utility for setting and unsetting the cached id.\n-struct CachedIdSetter<'a> {\n-    reset: bool,\n-    lctx: &'a LoweringContext<'a>,\n-}\n-\n-impl<'a> CachedIdSetter<'a> {\n-    fn new(lctx: &'a LoweringContext, expr_id: NodeId) -> CachedIdSetter<'a> {\n-        // Only reset the id if it was previously 0, i.e., was not cached.\n-        // If it was cached, we are in a nested node, but our id count will\n-        // still count towards the parent's count.\n-        let reset_cached_id = lctx.cached_id.get() == 0;\n+// Utility fn for setting and unsetting the cached id.\n+fn cache_ids<'a, OP, R>(lctx: &LoweringContext, expr_id: NodeId, op: OP) -> R\n+    where OP: FnOnce(&LoweringContext) -> R\n+{\n+    // Only reset the id if it was previously 0, i.e., was not cached.\n+    // If it was cached, we are in a nested node, but our id count will\n+    // still count towards the parent's count.\n+    let reset_cached_id = lctx.cached_id.get() == 0;\n \n+    {\n         let id_cache: &mut HashMap<_, _> = &mut lctx.id_cache.borrow_mut();\n \n         if id_cache.contains_key(&expr_id) {\n@@ -907,21 +922,16 @@ impl<'a> CachedIdSetter<'a> {\n             id_cache.insert(expr_id, next_id);\n             lctx.gensym_key.set(next_id);\n         }\n-\n-        CachedIdSetter {\n-            reset: reset_cached_id,\n-            lctx: lctx,\n-        }\n     }\n-}\n \n-impl<'a> Drop for CachedIdSetter<'a> {\n-    fn drop(&mut self) {\n-        if self.reset {\n-            self.lctx.cached_id.set(0);\n-            self.lctx.gensym_key.set(0);\n-        }\n+    let result = op(lctx);\n+\n+    if reset_cached_id {\n+        lctx.cached_id.set(0);\n+        lctx.gensym_key.set(0);\n     }\n+\n+    result\n }\n \n pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n@@ -959,147 +969,162 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                 //     InPlace::finalize(place)\n                 // })\n-                let _old_cached = CachedIdSetter::new(lctx, e.id);\n+                return cache_ids(lctx, e.id, |lctx| {\n+                    let placer_expr = lower_expr(lctx, placer);\n+                    let value_expr = lower_expr(lctx, value_expr);\n+\n+                    let placer_ident = lctx.str_to_ident(\"placer\");\n+                    let place_ident = lctx.str_to_ident(\"place\");\n+                    let p_ptr_ident = lctx.str_to_ident(\"p_ptr\");\n+\n+                    let make_place = [\"ops\", \"Placer\", \"make_place\"];\n+                    let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n+                    let move_val_init = [\"intrinsics\", \"move_val_init\"];\n+                    let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n+\n+                    let make_call = |lctx: &LoweringContext, p, args| {\n+                        let path = core_path(lctx, e.span, p);\n+                        let path = expr_path(lctx, path);\n+                        expr_call(lctx, e.span, path, args)\n+                    };\n \n-                let placer_expr = lower_expr(lctx, placer);\n-                let value_expr = lower_expr(lctx, value_expr);\n+                    let mk_stmt_let = |lctx: &LoweringContext, bind, expr| {\n+                        stmt_let(lctx, e.span, false, bind, expr)\n+                    };\n \n-                let placer_ident = lctx.str_to_ident(\"placer\");\n-                let agent_ident = lctx.str_to_ident(\"place\");\n-                let p_ptr_ident = lctx.str_to_ident(\"p_ptr\");\n+                    let mk_stmt_let_mut = |lctx: &LoweringContext, bind, expr| {\n+                        stmt_let(lctx, e.span, true, bind, expr)\n+                    };\n \n-                let make_place = [\"ops\", \"Placer\", \"make_place\"];\n-                let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n-                let move_val_init = [\"intrinsics\", \"move_val_init\"];\n-                let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n+                    // let placer = <placer_expr> ;\n+                    let s1 = {\n+                        let placer_expr = signal_block_expr(lctx,\n+                                                            vec![],\n+                                                            placer_expr,\n+                                                            e.span,\n+                                                            hir::PopUnstableBlock);\n+                        mk_stmt_let(lctx, placer_ident, placer_expr)\n+                    };\n \n-                let make_call = |lctx, p, args| {\n-                    let path = core_path(lctx, e.span, p);\n-                    let path = expr_path(lctx, path);\n-                    expr_call(lctx, e.span, path, args)\n-                };\n+                    // let mut place = Placer::make_place(placer);\n+                    let s2 = {\n+                        let placer = expr_ident(lctx, e.span, placer_ident);\n+                        let call = make_call(lctx, &make_place, vec![placer]);\n+                        mk_stmt_let_mut(lctx, place_ident, call)\n+                    };\n \n-                let mk_stmt_let = |lctx, bind, expr| stmt_let(lctx, e.span, false, bind, expr);\n-                let mk_stmt_let_mut = |lctx, bind, expr| stmt_let(lctx, e.span, true, bind, expr);\n-\n-                // let placer = <placer_expr> ;\n-                let s1 = mk_stmt_let(lctx,\n-                                     placer_ident,\n-                                     signal_block_expr(lctx,\n-                                                       vec![],\n-                                                       placer_expr,\n-                                                       e.span,\n-                                                       hir::PopUnstableBlock));\n-\n-                // let mut place = Placer::make_place(placer);\n-                let s2 = {\n-                    let call = make_call(lctx,\n-                                         &make_place,\n-                                         vec![expr_ident(lctx, e.span, placer_ident)]);\n-                    mk_stmt_let_mut(lctx, agent_ident, call)\n-                };\n+                    // let p_ptr = Place::pointer(&mut place);\n+                    let s3 = {\n+                        let agent = expr_ident(lctx, e.span, place_ident);\n+                        let args = vec![expr_mut_addr_of(lctx, e.span, agent)];\n+                        let call = make_call(lctx, &place_pointer, args);\n+                        mk_stmt_let(lctx, p_ptr_ident, call)\n+                    };\n \n-                // let p_ptr = Place::pointer(&mut place);\n-                let s3 = {\n-                    let args = vec![expr_mut_addr_of(lctx,\n-                                                     e.span,\n-                                                     expr_ident(lctx, e.span, agent_ident))];\n-                    let call = make_call(lctx, &place_pointer, args);\n-                    mk_stmt_let(lctx, p_ptr_ident, call)\n-                };\n+                    // pop_unsafe!(EXPR));\n+                    let pop_unsafe_expr = {\n+                        let value_expr = signal_block_expr(lctx,\n+                                                           vec![],\n+                                                           value_expr,\n+                                                           e.span,\n+                                                           hir::PopUnstableBlock);\n+                        signal_block_expr(lctx,\n+                                          vec![],\n+                                          value_expr,\n+                                          e.span,\n+                                          hir::PopUnsafeBlock(hir::CompilerGenerated))\n+                    };\n \n-                // pop_unsafe!(EXPR));\n-                let pop_unsafe_expr =\n-                    signal_block_expr(lctx,\n-                                      vec![],\n-                                      signal_block_expr(lctx,\n-                                                        vec![],\n-                                                        value_expr,\n-                                                        e.span,\n-                                                        hir::PopUnstableBlock),\n-                                      e.span,\n-                                      hir::PopUnsafeBlock(hir::CompilerGenerated));\n+                    // push_unsafe!({\n+                    //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n+                    //     InPlace::finalize(place)\n+                    // })\n+                    let expr = {\n+                        let ptr = expr_ident(lctx, e.span, p_ptr_ident);\n+                        let call_move_val_init =\n+                            hir::StmtSemi(\n+                                make_call(lctx, &move_val_init, vec![ptr, pop_unsafe_expr]),\n+                                lctx.next_id());\n+                        let call_move_val_init = respan(e.span, call_move_val_init);\n+\n+                        let place = expr_ident(lctx, e.span, place_ident);\n+                        let call = make_call(lctx, &inplace_finalize, vec![place]);\n+                        signal_block_expr(lctx,\n+                                          vec![P(call_move_val_init)],\n+                                          call,\n+                                          e.span,\n+                                          hir::PushUnsafeBlock(hir::CompilerGenerated))\n+                    };\n \n-                // push_unsafe!({\n-                //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n-                //     InPlace::finalize(place)\n-                // })\n-                let expr = {\n-                    let call_move_val_init =\n-                        hir::StmtSemi(make_call(lctx,\n-                                                &move_val_init,\n-                                                vec![expr_ident(lctx, e.span, p_ptr_ident),\n-                                                     pop_unsafe_expr]),\n-                                      lctx.next_id());\n-                    let call_move_val_init = respan(e.span, call_move_val_init);\n-\n-                    let call = make_call(lctx,\n-                                         &inplace_finalize,\n-                                         vec![expr_ident(lctx, e.span, agent_ident)]);\n                     signal_block_expr(lctx,\n-                                      vec![P(call_move_val_init)],\n-                                      call,\n+                                      vec![s1, s2, s3],\n+                                      expr,\n                                       e.span,\n-                                      hir::PushUnsafeBlock(hir::CompilerGenerated))\n-                };\n-\n-                return signal_block_expr(lctx,\n-                                         vec![s1, s2, s3],\n-                                         expr,\n-                                         e.span,\n-                                         hir::PushUnstableBlock);\n+                                      hir::PushUnstableBlock)\n+                });\n             }\n \n             ExprVec(ref exprs) => {\n                 hir::ExprVec(exprs.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n             ExprRepeat(ref expr, ref count) => {\n-                hir::ExprRepeat(lower_expr(lctx, expr), lower_expr(lctx, count))\n+                let expr = lower_expr(lctx, expr);\n+                let count = lower_expr(lctx, count);\n+                hir::ExprRepeat(expr, count)\n             }\n             ExprTup(ref elts) => {\n                 hir::ExprTup(elts.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n             ExprCall(ref f, ref args) => {\n-                hir::ExprCall(lower_expr(lctx, f),\n-                              args.iter().map(|x| lower_expr(lctx, x)).collect())\n+                let f = lower_expr(lctx, f);\n+                hir::ExprCall(f, args.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n             ExprMethodCall(i, ref tps, ref args) => {\n-                hir::ExprMethodCall(respan(i.span, i.node.name),\n-                                    tps.iter().map(|x| lower_ty(lctx, x)).collect(),\n-                                    args.iter().map(|x| lower_expr(lctx, x)).collect())\n+                let tps = tps.iter().map(|x| lower_ty(lctx, x)).collect();\n+                let args = args.iter().map(|x| lower_expr(lctx, x)).collect();\n+                hir::ExprMethodCall(respan(i.span, i.node.name), tps, args)\n             }\n             ExprBinary(binop, ref lhs, ref rhs) => {\n-                hir::ExprBinary(lower_binop(lctx, binop),\n-                                lower_expr(lctx, lhs),\n-                                lower_expr(lctx, rhs))\n+                let binop = lower_binop(lctx, binop);\n+                let lhs = lower_expr(lctx, lhs);\n+                let rhs = lower_expr(lctx, rhs);\n+                hir::ExprBinary(binop, lhs, rhs)\n             }\n             ExprUnary(op, ref ohs) => {\n-                hir::ExprUnary(lower_unop(lctx, op), lower_expr(lctx, ohs))\n+                let op = lower_unop(lctx, op);\n+                let ohs = lower_expr(lctx, ohs);\n+                hir::ExprUnary(op, ohs)\n             }\n             ExprLit(ref l) => hir::ExprLit(P((**l).clone())),\n             ExprCast(ref expr, ref ty) => {\n-                hir::ExprCast(lower_expr(lctx, expr), lower_ty(lctx, ty))\n+                let expr = lower_expr(lctx, expr);\n+                hir::ExprCast(expr, lower_ty(lctx, ty))\n             }\n             ExprAddrOf(m, ref ohs) => {\n-                hir::ExprAddrOf(lower_mutability(lctx, m), lower_expr(lctx, ohs))\n+                let m = lower_mutability(lctx, m);\n+                let ohs = lower_expr(lctx, ohs);\n+                hir::ExprAddrOf(m, ohs)\n             }\n             // More complicated than you might expect because the else branch\n             // might be `if let`.\n             ExprIf(ref cond, ref blk, ref else_opt) => {\n                 let else_opt = else_opt.as_ref().map(|els| {\n                     match els.node {\n                         ExprIfLet(..) => {\n-                            let _old_cached = CachedIdSetter::new(lctx, e.id);\n-                            // wrap the if-let expr in a block\n-                            let span = els.span;\n-                            let blk = P(hir::Block {\n-                                stmts: vec![],\n-                                expr: Some(lower_expr(lctx, els)),\n-                                id: lctx.next_id(),\n-                                rules: hir::DefaultBlock,\n-                                span: span,\n-                            });\n-                            expr_block(lctx, blk)\n+                            cache_ids(lctx, e.id, |lctx| {\n+                                // wrap the if-let expr in a block\n+                                let span = els.span;\n+                                let els = lower_expr(lctx, els);\n+                                let id = lctx.next_id();\n+                                let blk = P(hir::Block {\n+                                    stmts: vec![],\n+                                    expr: Some(els),\n+                                    id: id,\n+                                    rules: hir::DefaultBlock,\n+                                    span: span,\n+                                });\n+                                expr_block(lctx, blk)\n+                            })\n                         }\n                         _ => lower_expr(lctx, els),\n                     }\n@@ -1204,76 +1229,79 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     _ => [<else_opt> | ()]\n                 //   }\n \n-                let _old_cached = CachedIdSetter::new(lctx, e.id);\n-\n-                // `<pat> => <body>`\n-                let pat_arm = {\n-                    let body_expr = expr_block(lctx, lower_block(lctx, body));\n-                    arm(vec![lower_pat(lctx, pat)], body_expr)\n-                };\n+                return cache_ids(lctx, e.id, |lctx| {\n+                    // `<pat> => <body>`\n+                    let pat_arm = {\n+                        let body = lower_block(lctx, body);\n+                        let body_expr = expr_block(lctx, body);\n+                        arm(vec![lower_pat(lctx, pat)], body_expr)\n+                    };\n \n-                // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n-                let mut else_opt = else_opt.as_ref().map(|e| lower_expr(lctx, e));\n-                let else_if_arms = {\n-                    let mut arms = vec![];\n-                    loop {\n-                        let else_opt_continue = else_opt.and_then(|els| {\n-                            els.and_then(|els| {\n-                                match els.node {\n-                                    // else if\n-                                    hir::ExprIf(cond, then, else_opt) => {\n-                                        let pat_under = pat_wild(lctx, e.span);\n-                                        arms.push(hir::Arm {\n-                                            attrs: vec![],\n-                                            pats: vec![pat_under],\n-                                            guard: Some(cond),\n-                                            body: expr_block(lctx, then),\n-                                        });\n-                                        else_opt.map(|else_opt| (else_opt, true))\n+                    // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n+                    let mut else_opt = else_opt.as_ref().map(|e| lower_expr(lctx, e));\n+                    let else_if_arms = {\n+                        let mut arms = vec![];\n+                        loop {\n+                            let else_opt_continue = else_opt.and_then(|els| {\n+                                els.and_then(|els| {\n+                                    match els.node {\n+                                        // else if\n+                                        hir::ExprIf(cond, then, else_opt) => {\n+                                            let pat_under = pat_wild(lctx, e.span);\n+                                            arms.push(hir::Arm {\n+                                                attrs: vec![],\n+                                                pats: vec![pat_under],\n+                                                guard: Some(cond),\n+                                                body: expr_block(lctx, then),\n+                                            });\n+                                            else_opt.map(|else_opt| (else_opt, true))\n+                                        }\n+                                        _ => Some((P(els), false)),\n                                     }\n-                                    _ => Some((P(els), false)),\n+                                })\n+                            });\n+                            match else_opt_continue {\n+                                Some((e, true)) => {\n+                                    else_opt = Some(e);\n+                                }\n+                                Some((e, false)) => {\n+                                    else_opt = Some(e);\n+                                    break;\n+                                }\n+                                None => {\n+                                    else_opt = None;\n+                                    break;\n                                 }\n-                            })\n-                        });\n-                        match else_opt_continue {\n-                            Some((e, true)) => {\n-                                else_opt = Some(e);\n-                            }\n-                            Some((e, false)) => {\n-                                else_opt = Some(e);\n-                                break;\n-                            }\n-                            None => {\n-                                else_opt = None;\n-                                break;\n                             }\n                         }\n-                    }\n-                    arms\n-                };\n+                        arms\n+                    };\n \n-                let contains_else_clause = else_opt.is_some();\n+                    let contains_else_clause = else_opt.is_some();\n \n-                // `_ => [<else_opt> | ()]`\n-                let else_arm = {\n-                    let pat_under = pat_wild(lctx, e.span);\n-                    let else_expr = else_opt.unwrap_or_else(|| expr_tuple(lctx, e.span, vec![]));\n-                    arm(vec![pat_under], else_expr)\n-                };\n+                    // `_ => [<else_opt> | ()]`\n+                    let else_arm = {\n+                        let pat_under = pat_wild(lctx, e.span);\n+                        let else_expr =\n+                            else_opt.unwrap_or_else(\n+                                || expr_tuple(lctx, e.span, vec![]));\n+                        arm(vec![pat_under], else_expr)\n+                    };\n \n-                let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n-                arms.push(pat_arm);\n-                arms.extend(else_if_arms);\n-                arms.push(else_arm);\n+                    let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n+                    arms.push(pat_arm);\n+                    arms.extend(else_if_arms);\n+                    arms.push(else_arm);\n \n-                let match_expr = expr(lctx,\n-                                      e.span,\n-                                      hir::ExprMatch(lower_expr(lctx, sub_expr),\n-                                                     arms,\n-                                                     hir::MatchSource::IfLetDesugar {\n-                                                         contains_else_clause: contains_else_clause,\n-                                                     }));\n-                return match_expr;\n+                    let sub_expr = lower_expr(lctx, sub_expr);\n+                    expr(lctx,\n+                         e.span,\n+                         hir::ExprMatch(sub_expr,\n+                                        arms,\n+                                        hir::MatchSource::IfLetDesugar {\n+                                            contains_else_clause: contains_else_clause,\n+                                        }))\n+                });\n             }\n \n             // Desugar ExprWhileLet\n@@ -1288,32 +1316,34 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     }\n                 //   }\n \n-                let _old_cached = CachedIdSetter::new(lctx, e.id);\n-\n-                // `<pat> => <body>`\n-                let pat_arm = {\n-                    let body_expr = expr_block(lctx, lower_block(lctx, body));\n-                    arm(vec![lower_pat(lctx, pat)], body_expr)\n-                };\n-\n-                // `_ => break`\n-                let break_arm = {\n-                    let pat_under = pat_wild(lctx, e.span);\n-                    let break_expr = expr_break(lctx, e.span);\n-                    arm(vec![pat_under], break_expr)\n-                };\n+                return cache_ids(lctx, e.id, |lctx| {\n+                    // `<pat> => <body>`\n+                    let pat_arm = {\n+                        let body = lower_block(lctx, body);\n+                        let body_expr = expr_block(lctx, body);\n+                        arm(vec![lower_pat(lctx, pat)], body_expr)\n+                    };\n \n-                // `match <sub_expr> { ... }`\n-                let arms = vec![pat_arm, break_arm];\n-                let match_expr = expr(lctx,\n-                                      e.span,\n-                                      hir::ExprMatch(lower_expr(lctx, sub_expr),\n-                                                     arms,\n-                                                     hir::MatchSource::WhileLetDesugar));\n+                    // `_ => break`\n+                    let break_arm = {\n+                        let pat_under = pat_wild(lctx, e.span);\n+                        let break_expr = expr_break(lctx, e.span);\n+                        arm(vec![pat_under], break_expr)\n+                    };\n \n-                // `[opt_ident]: loop { ... }`\n-                let loop_block = block_expr(lctx, match_expr);\n-                return expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n+                    // `match <sub_expr> { ... }`\n+                    let arms = vec![pat_arm, break_arm];\n+                    let sub_expr = lower_expr(lctx, sub_expr);\n+                    let match_expr = expr(lctx,\n+                                          e.span,\n+                                          hir::ExprMatch(sub_expr,\n+                                                         arms,\n+                                                         hir::MatchSource::WhileLetDesugar));\n+\n+                    // `[opt_ident]: loop { ... }`\n+                    let loop_block = block_expr(lctx, match_expr);\n+                    expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident))\n+                });\n             }\n \n             // Desugar ExprForLoop\n@@ -1335,97 +1365,90 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     result\n                 //   }\n \n-                let _old_cached = CachedIdSetter::new(lctx, e.id);\n-\n-                // expand <head>\n-                let head = lower_expr(lctx, head);\n+                return cache_ids(lctx, e.id, |lctx| {\n+                    // expand <head>\n+                    let head = lower_expr(lctx, head);\n \n-                let iter = lctx.str_to_ident(\"iter\");\n+                    let iter = lctx.str_to_ident(\"iter\");\n \n-                // `::std::option::Option::Some(<pat>) => <body>`\n-                let pat_arm = {\n-                    let body_block = lower_block(lctx, body);\n-                    let body_span = body_block.span;\n-                    let body_expr = P(hir::Expr {\n-                        id: lctx.next_id(),\n-                        node: hir::ExprBlock(body_block),\n-                        span: body_span,\n-                    });\n-                    let pat = lower_pat(lctx, pat);\n-                    let some_pat = pat_some(lctx, e.span, pat);\n-\n-                    arm(vec![some_pat], body_expr)\n-                };\n+                    // `::std::option::Option::Some(<pat>) => <body>`\n+                    let pat_arm = {\n+                        let body_block = lower_block(lctx, body);\n+                        let body_span = body_block.span;\n+                        let body_expr = P(hir::Expr {\n+                            id: lctx.next_id(),\n+                            node: hir::ExprBlock(body_block),\n+                            span: body_span,\n+                        });\n+                        let pat = lower_pat(lctx, pat);\n+                        let some_pat = pat_some(lctx, e.span, pat);\n \n-                // `::std::option::Option::None => break`\n-                let break_arm = {\n-                    let break_expr = expr_break(lctx, e.span);\n+                        arm(vec![some_pat], body_expr)\n+                    };\n \n-                    arm(vec![pat_none(lctx, e.span)], break_expr)\n-                };\n+                    // `::std::option::Option::None => break`\n+                    let break_arm = {\n+                        let break_expr = expr_break(lctx, e.span);\n \n-                // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n-                let match_expr = {\n-                    let next_path = {\n-                        let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n+                        arm(vec![pat_none(lctx, e.span)], break_expr)\n+                    };\n \n-                        path_global(e.span, strs)\n+                    // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+                    let match_expr = {\n+                        let next_path = {\n+                            let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n+\n+                            path_global(e.span, strs)\n+                        };\n+                        let iter = expr_ident(lctx, e.span, iter);\n+                        let ref_mut_iter = expr_mut_addr_of(lctx, e.span, iter);\n+                        let next_path = expr_path(lctx, next_path);\n+                        let next_expr = expr_call(lctx, e.span, next_path, vec![ref_mut_iter]);\n+                        let arms = vec![pat_arm, break_arm];\n+\n+                        expr(lctx,\n+                             e.span,\n+                             hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar))\n                     };\n-                    let ref_mut_iter = expr_mut_addr_of(lctx,\n-                                                        e.span,\n-                                                        expr_ident(lctx, e.span, iter));\n-                    let next_expr = expr_call(lctx,\n-                                              e.span,\n-                                              expr_path(lctx, next_path),\n-                                              vec![ref_mut_iter]);\n-                    let arms = vec![pat_arm, break_arm];\n \n-                    expr(lctx,\n-                         e.span,\n-                         hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar))\n-                };\n+                    // `[opt_ident]: loop { ... }`\n+                    let loop_block = block_expr(lctx, match_expr);\n+                    let loop_expr = expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n+\n+                    // `mut iter => { ... }`\n+                    let iter_arm = {\n+                        let iter_pat = pat_ident_binding_mode(lctx,\n+                                                              e.span,\n+                                                              iter,\n+                                                              hir::BindByValue(hir::MutMutable));\n+                        arm(vec![iter_pat], loop_expr)\n+                    };\n \n-                // `[opt_ident]: loop { ... }`\n-                let loop_block = block_expr(lctx, match_expr);\n-                let loop_expr = expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n-\n-                // `mut iter => { ... }`\n-                let iter_arm = {\n-                    let iter_pat = pat_ident_binding_mode(lctx,\n-                                                          e.span,\n-                                                          iter,\n-                                                          hir::BindByValue(hir::MutMutable));\n-                    arm(vec![iter_pat], loop_expr)\n-                };\n+                    // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+                    let into_iter_expr = {\n+                        let into_iter_path = {\n+                            let strs = std_path(lctx, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n \n-                // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n-                let into_iter_expr = {\n-                    let into_iter_path = {\n-                        let strs = std_path(lctx, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n+                            path_global(e.span, strs)\n+                        };\n \n-                        path_global(e.span, strs)\n+                        let into_iter = expr_path(lctx, into_iter_path);\n+                        expr_call(lctx, e.span, into_iter, vec![head])\n                     };\n \n-                    expr_call(lctx, e.span, expr_path(lctx, into_iter_path), vec![head])\n-                };\n-\n-                let match_expr = expr_match(lctx,\n-                                            e.span,\n-                                            into_iter_expr,\n-                                            vec![iter_arm],\n-                                            hir::MatchSource::ForLoopDesugar);\n-\n-                // `{ let result = ...; result }`\n-                let result_ident = lctx.str_to_ident(\"result\");\n-                return expr_block(lctx,\n-                                  block_all(lctx,\n-                                            e.span,\n-                                            vec![stmt_let(lctx,\n-                                                          e.span,\n-                                                          false,\n-                                                          result_ident,\n-                                                          match_expr)],\n-                                            Some(expr_ident(lctx, e.span, result_ident))));\n+                    let match_expr = expr_match(lctx,\n+                                                e.span,\n+                                                into_iter_expr,\n+                                                vec![iter_arm],\n+                                                hir::MatchSource::ForLoopDesugar);\n+\n+                    // `{ let result = ...; result }`\n+                    let result_ident = lctx.str_to_ident(\"result\");\n+                    let let_stmt = stmt_let(lctx, e.span, false, result_ident, match_expr);\n+                    let result = expr_ident(lctx, e.span, result_ident);\n+                    let block = block_all(lctx, e.span, vec![let_stmt], Some(result));\n+                    expr_block(lctx, block)\n+                });\n             }\n \n             ExprMac(_) => panic!(\"Shouldn't exist here\"),\n@@ -1434,23 +1457,23 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n     })\n }\n \n-pub fn lower_stmt(_lctx: &LoweringContext, s: &Stmt) -> P<hir::Stmt> {\n+pub fn lower_stmt(lctx: &LoweringContext, s: &Stmt) -> P<hir::Stmt> {\n     match s.node {\n         StmtDecl(ref d, id) => {\n             P(Spanned {\n-                node: hir::StmtDecl(lower_decl(_lctx, d), id),\n+                node: hir::StmtDecl(lower_decl(lctx, d), id),\n                 span: s.span,\n             })\n         }\n         StmtExpr(ref e, id) => {\n             P(Spanned {\n-                node: hir::StmtExpr(lower_expr(_lctx, e), id),\n+                node: hir::StmtExpr(lower_expr(lctx, e), id),\n                 span: s.span,\n             })\n         }\n         StmtSemi(ref e, id) => {\n             P(Spanned {\n-                node: hir::StmtSemi(lower_expr(_lctx, e), id),\n+                node: hir::StmtSemi(lower_expr(lctx, e), id),\n                 span: s.span,\n             })\n         }\n@@ -1472,26 +1495,26 @@ pub fn lower_visibility(_lctx: &LoweringContext, v: Visibility) -> hir::Visibili\n     }\n }\n \n-pub fn lower_block_check_mode(_lctx: &LoweringContext, b: &BlockCheckMode) -> hir::BlockCheckMode {\n+pub fn lower_block_check_mode(lctx: &LoweringContext, b: &BlockCheckMode) -> hir::BlockCheckMode {\n     match *b {\n         DefaultBlock => hir::DefaultBlock,\n-        UnsafeBlock(u) => hir::UnsafeBlock(lower_unsafe_source(_lctx, u)),\n+        UnsafeBlock(u) => hir::UnsafeBlock(lower_unsafe_source(lctx, u)),\n     }\n }\n \n-pub fn lower_binding_mode(_lctx: &LoweringContext, b: &BindingMode) -> hir::BindingMode {\n+pub fn lower_binding_mode(lctx: &LoweringContext, b: &BindingMode) -> hir::BindingMode {\n     match *b {\n-        BindByRef(m) => hir::BindByRef(lower_mutability(_lctx, m)),\n-        BindByValue(m) => hir::BindByValue(lower_mutability(_lctx, m)),\n+        BindByRef(m) => hir::BindByRef(lower_mutability(lctx, m)),\n+        BindByValue(m) => hir::BindByValue(lower_mutability(lctx, m)),\n     }\n }\n \n-pub fn lower_struct_field_kind(_lctx: &LoweringContext,\n+pub fn lower_struct_field_kind(lctx: &LoweringContext,\n                                s: &StructFieldKind)\n                                -> hir::StructFieldKind {\n     match *s {\n-        NamedField(ident, vis) => hir::NamedField(ident.name, lower_visibility(_lctx, vis)),\n-        UnnamedField(vis) => hir::UnnamedField(lower_visibility(_lctx, vis)),\n+        NamedField(ident, vis) => hir::NamedField(ident.name, lower_visibility(lctx, vis)),\n+        UnnamedField(vis) => hir::UnnamedField(lower_visibility(lctx, vis)),\n     }\n }\n \n@@ -1734,11 +1757,12 @@ fn signal_block_expr(lctx: &LoweringContext,\n                      span: Span,\n                      rule: hir::BlockCheckMode)\n                      -> P<hir::Expr> {\n+    let id = lctx.next_id();\n     expr_block(lctx,\n                P(hir::Block {\n                    rules: rule,\n                    span: span,\n-                   id: lctx.next_id(),\n+                   id: id,\n                    stmts: stmts,\n                    expr: Some(expr),\n                }))"}, {"sha": "e059a4ed5f69dd7148c2b41234671f9bd109b0f9", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -25,7 +25,7 @@ use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n \n use hir;\n-use hir::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n+use hir::{Crate, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n \n use std::io::{self, Write, Read};\n \n@@ -54,6 +54,7 @@ impl PpAnn for NoAnn {}\n \n \n pub struct State<'a> {\n+    krate: Option<&'a Crate>,\n     pub s: pp::Printer<'a>,\n     cm: Option<&'a CodeMap>,\n     comments: Option<Vec<comments::Comment>>,\n@@ -85,13 +86,17 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n }\n \n-pub fn rust_printer<'a>(writer: Box<Write + 'a>) -> State<'a> {\n+pub fn rust_printer<'a>(writer: Box<Write + 'a>, krate: Option<&'a Crate>) -> State<'a> {\n     static NO_ANN: NoAnn = NoAnn;\n-    rust_printer_annotated(writer, &NO_ANN)\n+    rust_printer_annotated(writer, &NO_ANN, krate)\n }\n \n-pub fn rust_printer_annotated<'a>(writer: Box<Write + 'a>, ann: &'a PpAnn) -> State<'a> {\n+pub fn rust_printer_annotated<'a>(writer: Box<Write + 'a>,\n+                                  ann: &'a PpAnn,\n+                                  krate: Option<&'a Crate>)\n+                                  -> State<'a> {\n     State {\n+        krate: krate,\n         s: pp::mk_printer(writer, default_columns),\n         cm: None,\n         comments: None,\n@@ -124,7 +129,8 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        ann: &'a PpAnn,\n                        is_expanded: bool)\n                        -> io::Result<()> {\n-    let mut s = State::new_from_input(cm, span_diagnostic, filename, input, out, ann, is_expanded);\n+    let mut s = State::new_from_input(cm, span_diagnostic, filename, input,\n+                                      out, ann, is_expanded, Some(krate));\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n@@ -141,7 +147,8 @@ impl<'a> State<'a> {\n                           input: &mut Read,\n                           out: Box<Write + 'a>,\n                           ann: &'a PpAnn,\n-                          is_expanded: bool)\n+                          is_expanded: bool,\n+                          krate: Option<&'a Crate>)\n                           -> State<'a> {\n         let (cmnts, lits) = comments::gather_comments_and_literals(span_diagnostic,\n                                                                    filename,\n@@ -158,16 +165,19 @@ impl<'a> State<'a> {\n                        None\n                    } else {\n                        Some(lits)\n-                   })\n+                   },\n+                   krate)\n     }\n \n     pub fn new(cm: &'a CodeMap,\n                out: Box<Write + 'a>,\n                ann: &'a PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n-               literals: Option<Vec<comments::Literal>>)\n+               literals: Option<Vec<comments::Literal>>,\n+               krate: Option<&'a Crate>)\n                -> State<'a> {\n         State {\n+            krate: krate,\n             s: pp::mk_printer(out, default_columns),\n             cm: Some(cm),\n             comments: comments.clone(),\n@@ -187,7 +197,7 @@ pub fn to_string<F>(f: F) -> String\n {\n     let mut wr = Vec::new();\n     {\n-        let mut printer = rust_printer(Box::new(&mut wr));\n+        let mut printer = rust_printer(Box::new(&mut wr), None);\n         f(&mut printer).unwrap();\n         eof(&mut printer.s).unwrap();\n     }\n@@ -451,8 +461,8 @@ impl<'a> State<'a> {\n \n     pub fn print_mod(&mut self, _mod: &hir::Mod, attrs: &[ast::Attribute]) -> io::Result<()> {\n         try!(self.print_inner_attributes(attrs));\n-        for item in &_mod.items {\n-            try!(self.print_item(&**item));\n+        for item_id in &_mod.item_ids {\n+            try!(self.print_item_id(item_id));\n         }\n         Ok(())\n     }\n@@ -620,6 +630,16 @@ impl<'a> State<'a> {\n         word(&mut self.s, \";\")\n     }\n \n+    pub fn print_item_id(&mut self, item_id: &hir::ItemId) -> io::Result<()> {\n+        if let Some(krate) = self.krate {\n+            // skip nested items if krate context was not provided\n+            let item = &krate.items[&item_id.id];\n+            self.print_item(item)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &hir::Item) -> io::Result<()> {\n         try!(self.hardbreak_if_not_bol());\n@@ -1566,7 +1586,9 @@ impl<'a> State<'a> {\n                 }\n                 self.end()\n             }\n-            hir::DeclItem(ref item) => self.print_item(&**item),\n+            hir::DeclItem(ref item) => {\n+                self.print_item_id(item)\n+            }\n         }\n     }\n "}, {"sha": "97b25dafb6decddf74c0b7d494652a7edc29ee82", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 44, "deletions": 50, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -10,7 +10,7 @@\n \n use hir;\n use hir::*;\n-use visit::{self, Visitor, FnKind};\n+use intravisit::{self, Visitor, FnKind};\n use syntax::ast_util;\n use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID};\n use syntax::codemap::Span;\n@@ -145,12 +145,26 @@ pub fn unop_to_string(op: UnOp) -> &'static str {\n }\n \n pub struct IdVisitor<'a, O: 'a> {\n-    pub operation: &'a mut O,\n-    pub pass_through_items: bool,\n-    pub visited_outermost: bool,\n+    operation: &'a mut O,\n+\n+    // In general, the id visitor visits the contents of an item, but\n+    // not including nested trait/impl items, nor other nested items.\n+    // The base visitor itself always skips nested items, but not\n+    // trait/impl items. This means in particular that if you start by\n+    // visiting a trait or an impl, you should not visit the\n+    // trait/impl items respectively.  This is handled by setting\n+    // `skip_members` to true when `visit_item` is on the stack. This\n+    // way, if the user begins by calling `visit_trait_item`, we will\n+    // visit the trait item, but if they begin with `visit_item`, we\n+    // won't visit the (nested) trait items.\n+    skip_members: bool,\n }\n \n impl<'a, O: ast_util::IdVisitingOperation> IdVisitor<'a, O> {\n+    pub fn new(operation: &'a mut O) -> IdVisitor<'a, O> {\n+        IdVisitor { operation: operation, skip_members: false }\n+    }\n+\n     fn visit_generics_helper(&mut self, generics: &Generics) {\n         for type_parameter in generics.ty_params.iter() {\n             self.operation.visit_id(type_parameter.id)\n@@ -164,22 +178,17 @@ impl<'a, O: ast_util::IdVisitingOperation> IdVisitor<'a, O> {\n impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n     fn visit_mod(&mut self, module: &Mod, _: Span, node_id: NodeId) {\n         self.operation.visit_id(node_id);\n-        visit::walk_mod(self, module)\n+        intravisit::walk_mod(self, module)\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         self.operation.visit_id(foreign_item.id);\n-        visit::walk_foreign_item(self, foreign_item)\n+        intravisit::walk_foreign_item(self, foreign_item)\n     }\n \n     fn visit_item(&mut self, item: &Item) {\n-        if !self.pass_through_items {\n-            if self.visited_outermost {\n-                return;\n-            } else {\n-                self.visited_outermost = true\n-            }\n-        }\n+        assert!(!self.skip_members);\n+        self.skip_members = true;\n \n         self.operation.visit_id(item.id);\n         match item.node {\n@@ -196,45 +205,44 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n             }\n             _ => {}\n         }\n+        intravisit::walk_item(self, item);\n \n-        visit::walk_item(self, item);\n-\n-        self.visited_outermost = false\n+        self.skip_members = false;\n     }\n \n     fn visit_local(&mut self, local: &Local) {\n         self.operation.visit_id(local.id);\n-        visit::walk_local(self, local)\n+        intravisit::walk_local(self, local)\n     }\n \n     fn visit_block(&mut self, block: &Block) {\n         self.operation.visit_id(block.id);\n-        visit::walk_block(self, block)\n+        intravisit::walk_block(self, block)\n     }\n \n     fn visit_stmt(&mut self, statement: &Stmt) {\n         self.operation.visit_id(stmt_id(statement));\n-        visit::walk_stmt(self, statement)\n+        intravisit::walk_stmt(self, statement)\n     }\n \n     fn visit_pat(&mut self, pattern: &Pat) {\n         self.operation.visit_id(pattern.id);\n-        visit::walk_pat(self, pattern)\n+        intravisit::walk_pat(self, pattern)\n     }\n \n     fn visit_expr(&mut self, expression: &Expr) {\n         self.operation.visit_id(expression.id);\n-        visit::walk_expr(self, expression)\n+        intravisit::walk_expr(self, expression)\n     }\n \n     fn visit_ty(&mut self, typ: &Ty) {\n         self.operation.visit_id(typ.id);\n-        visit::walk_ty(self, typ)\n+        intravisit::walk_ty(self, typ)\n     }\n \n     fn visit_generics(&mut self, generics: &Generics) {\n         self.visit_generics_helper(generics);\n-        visit::walk_generics(self, generics)\n+        intravisit::walk_generics(self, generics)\n     }\n \n     fn visit_fn(&mut self,\n@@ -243,14 +251,6 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n                 block: &'v Block,\n                 span: Span,\n                 node_id: NodeId) {\n-        if !self.pass_through_items {\n-            match function_kind {\n-                FnKind::Method(..) if self.visited_outermost => return,\n-                FnKind::Method(..) => self.visited_outermost = true,\n-                _ => {}\n-            }\n-        }\n-\n         self.operation.visit_id(node_id);\n \n         match function_kind {\n@@ -267,18 +267,12 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n             self.operation.visit_id(argument.id)\n         }\n \n-        visit::walk_fn(self, function_kind, function_declaration, block, span);\n-\n-        if !self.pass_through_items {\n-            if let FnKind::Method(..) = function_kind {\n-                self.visited_outermost = false;\n-            }\n-        }\n+        intravisit::walk_fn(self, function_kind, function_declaration, block, span);\n     }\n \n     fn visit_struct_field(&mut self, struct_field: &StructField) {\n         self.operation.visit_id(struct_field.node.id);\n-        visit::walk_struct_field(self, struct_field)\n+        intravisit::walk_struct_field(self, struct_field)\n     }\n \n     fn visit_variant_data(&mut self,\n@@ -288,17 +282,21 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n                           _: NodeId,\n                           _: Span) {\n         self.operation.visit_id(struct_def.id());\n-        visit::walk_struct_def(self, struct_def);\n+        intravisit::walk_struct_def(self, struct_def);\n     }\n \n     fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n-        self.operation.visit_id(ti.id);\n-        visit::walk_trait_item(self, ti);\n+        if !self.skip_members {\n+            self.operation.visit_id(ti.id);\n+            intravisit::walk_trait_item(self, ti);\n+        }\n     }\n \n     fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n-        self.operation.visit_id(ii.id);\n-        visit::walk_impl_item(self, ii);\n+        if !self.skip_members {\n+            self.operation.visit_id(ii.id);\n+            intravisit::walk_impl_item(self, ii);\n+        }\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n@@ -311,7 +309,7 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n \n     fn visit_trait_ref(&mut self, trait_ref: &TraitRef) {\n         self.operation.visit_id(trait_ref.ref_id);\n-        visit::walk_trait_ref(self, trait_ref);\n+        intravisit::walk_trait_ref(self, trait_ref);\n     }\n }\n \n@@ -323,11 +321,7 @@ pub fn compute_id_range_for_fn_body(fk: FnKind,\n                                     id: NodeId)\n                                     -> ast_util::IdRange {\n     let mut visitor = ast_util::IdRangeComputingVisitor { result: ast_util::IdRange::max() };\n-    let mut id_visitor = IdVisitor {\n-        operation: &mut visitor,\n-        pass_through_items: false,\n-        visited_outermost: false,\n-    };\n+    let mut id_visitor = IdVisitor::new(&mut visitor);\n     id_visitor.visit_fn(fk, decl, body, sp, id);\n     id_visitor.operation.result\n }"}, {"sha": "2146dc8e9b94bcd204018d3a076ee1b1b4c61aac", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -18,7 +18,7 @@ use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n \n use rustc_front::hir;\n-use rustc_front::visit::FnKind;\n+use rustc_front::intravisit::FnKind;\n \n #[derive(PartialEq)]\n pub enum MethodLateContext {"}, {"sha": "d24c336dd3fbd0a2910abd06c734c71896c4293a", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -46,7 +46,7 @@ use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n \n use rustc_front::hir;\n-use rustc_front::visit::FnKind;\n+use rustc_front::intravisit::FnKind;\n \n use bad_style::{MethodLateContext, method_context};\n "}, {"sha": "a1d029025b2fa8c09680dc4ca93f8e7c7462ff77", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -28,7 +28,7 @@ use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n \n use rustc_front::hir;\n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::{self, Visitor};\n use rustc_front::util::is_shift_binop;\n \n declare_lint! {\n@@ -626,7 +626,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n                     \"found Rust tuple type in foreign module; \\\n                      consider using a struct instead`\")\n             }\n-            _ => visit::walk_ty(self, ty)\n+            _ => intravisit::walk_ty(self, ty)\n         }\n     }\n }"}, {"sha": "c6494dc81f93942d3972cefadeb7add1061850bb", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -27,7 +27,7 @@ use syntax::ptr::P;\n \n use rustc_back::slice;\n use rustc_front::hir;\n-use rustc_front::visit::FnKind;\n+use rustc_front::intravisit::FnKind;\n \n declare_lint! {\n     pub UNUSED_MUT,"}, {"sha": "34ef7c3487f73935aad49da6eb3bc88edb074b23", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -33,7 +33,7 @@ use self::rustc::middle::ty::{self, Ty};\n use self::rustc::util::common::ErrorReported;\n use self::rustc::util::nodemap::NodeMap;\n use self::rustc_front::hir;\n-use self::rustc_front::visit;\n+use self::rustc_front::intravisit::{self, Visitor};\n use self::syntax::ast;\n use self::syntax::attr::AttrMetaMethods;\n use self::syntax::codemap::Span;\n@@ -47,7 +47,7 @@ pub fn build_mir_for_crate<'tcx>(tcx: &ty::ctxt<'tcx>) -> MirMap<'tcx> {\n             tcx: tcx,\n             map: &mut map,\n         };\n-        visit::walk_crate(&mut dump, tcx.map.krate());\n+        tcx.map.krate().visit_all_items(&mut dump);\n     }\n     map\n }\n@@ -79,32 +79,32 @@ impl<'a, 'tcx> OuterDump<'a, 'tcx> {\n }\n \n \n-impl<'a, 'tcx> visit::Visitor<'tcx> for OuterDump<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for OuterDump<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.visit_mir(&item.attrs, |c| visit::walk_item(c, item));\n-        visit::walk_item(self, item);\n+        self.visit_mir(&item.attrs, |c| intravisit::walk_item(c, item));\n+        intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n             hir::MethodTraitItem(_, Some(_)) => {\n-                self.visit_mir(&trait_item.attrs, |c| visit::walk_trait_item(c, trait_item));\n+                self.visit_mir(&trait_item.attrs, |c| intravisit::walk_trait_item(c, trait_item));\n             }\n             hir::MethodTraitItem(_, None) |\n             hir::ConstTraitItem(..) |\n             hir::TypeTraitItem(..) => {}\n         }\n-        visit::walk_trait_item(self, trait_item);\n+        intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n             hir::ImplItemKind::Method(..) => {\n-                self.visit_mir(&impl_item.attrs, |c| visit::walk_impl_item(c, impl_item));\n+                self.visit_mir(&impl_item.attrs, |c| intravisit::walk_impl_item(c, impl_item));\n             }\n             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Type(..) => {}\n         }\n-        visit::walk_impl_item(self, impl_item);\n+        intravisit::walk_impl_item(self, impl_item);\n     }\n }\n \n@@ -117,27 +117,23 @@ struct InnerDump<'a, 'm, 'tcx: 'a + 'm> {\n     attr: Option<&'a ast::Attribute>,\n }\n \n-impl<'a, 'm, 'tcx> visit::Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n-    fn visit_item(&mut self, _: &'tcx hir::Item) {\n-        // ignore nested items; they need their own graphviz annotation\n-    }\n-\n+impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n     fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) {\n-        // ignore nested items; they need their own graphviz annotation\n+        // ignore methods; the outer dump will call us for them independently\n     }\n \n     fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) {\n-        // ignore nested items; they need their own graphviz annotation\n+        // ignore methods; the outer dump will call us for them independently\n     }\n \n     fn visit_fn(&mut self,\n-                fk: visit::FnKind<'tcx>,\n+                fk: intravisit::FnKind<'tcx>,\n                 decl: &'tcx hir::FnDecl,\n                 body: &'tcx hir::Block,\n                 span: Span,\n                 id: ast::NodeId) {\n         let (prefix, implicit_arg_tys) = match fk {\n-            visit::FnKind::Closure =>\n+            intravisit::FnKind::Closure =>\n                 (format!(\"{}-\", id), vec![closure_self_ty(&self.tcx, id, body.id)]),\n             _ =>\n                 (format!(\"\"), vec![]),\n@@ -188,7 +184,7 @@ impl<'a, 'm, 'tcx> visit::Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n             Err(ErrorReported) => {}\n         }\n \n-        visit::walk_fn(self, fk, decl, body, span);\n+        intravisit::walk_fn(self, fk, decl, body, span);\n     }\n }\n "}, {"sha": "d11880ecca19b0884837fa1141e865012224e9b7", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 68, "deletions": 38, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -35,7 +35,7 @@ use self::FieldName::*;\n use std::mem::replace;\n \n use rustc_front::hir;\n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::{self, Visitor};\n \n use rustc::middle::def;\n use rustc::middle::def_id::DefId;\n@@ -63,12 +63,18 @@ type CheckResult = Option<(Span, String, Option<(Span, String)>)>;\n /// The parent visitor, used to determine what's the parent of what (node-wise)\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct ParentVisitor {\n+struct ParentVisitor<'a, 'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     parents: NodeMap<ast::NodeId>,\n     curparent: ast::NodeId,\n }\n \n-impl<'v> Visitor<'v> for ParentVisitor {\n+impl<'a, 'tcx, 'v> Visitor<'v> for ParentVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n     fn visit_item(&mut self, item: &hir::Item) {\n         self.parents.insert(item.id, self.curparent);\n \n@@ -99,24 +105,24 @@ impl<'v> Visitor<'v> for ParentVisitor {\n \n             _ => {}\n         }\n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n         self.curparent = prev;\n     }\n \n     fn visit_foreign_item(&mut self, a: &hir::ForeignItem) {\n         self.parents.insert(a.id, self.curparent);\n-        visit::walk_foreign_item(self, a);\n+        intravisit::walk_foreign_item(self, a);\n     }\n \n-    fn visit_fn(&mut self, a: visit::FnKind<'v>, b: &'v hir::FnDecl,\n+    fn visit_fn(&mut self, a: intravisit::FnKind<'v>, b: &'v hir::FnDecl,\n                 c: &'v hir::Block, d: Span, id: ast::NodeId) {\n         // We already took care of some trait methods above, otherwise things\n         // like impl methods and pub trait methods are parented to the\n         // containing module, not the containing trait.\n         if !self.parents.contains_key(&id) {\n             self.parents.insert(id, self.curparent);\n         }\n-        visit::walk_fn(self, a, b, c, d);\n+        intravisit::walk_fn(self, a, b, c, d);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n@@ -125,7 +131,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n         if !self.parents.contains_key(&ii.id) {\n             self.parents.insert(ii.id, self.curparent);\n         }\n-        visit::walk_impl_item(self, ii);\n+        intravisit::walk_impl_item(self, ii);\n     }\n \n     fn visit_variant_data(&mut self, s: &hir::VariantData, _: ast::Name,\n@@ -141,7 +147,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n         for field in s.fields() {\n             self.parents.insert(field.node.id, self.curparent);\n         }\n-        visit::walk_struct_def(self, s)\n+        intravisit::walk_struct_def(self, s)\n     }\n }\n \n@@ -216,6 +222,11 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n     fn visit_item(&mut self, item: &hir::Item) {\n         let orig_all_public = self.prev_public;\n         let orig_all_exported = self.prev_exported;\n@@ -362,7 +373,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n \n         self.prev_public = orig_all_public;\n         self.prev_exported = orig_all_exported;\n@@ -375,7 +386,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // Blocks can have exported and public items, for example impls, but they always\n         // start as non-public and non-exported regardless of publicity of a function,\n         // constant, type, field, etc. in which this block resides\n-        visit::walk_block(self, b);\n+        intravisit::walk_block(self, b);\n \n         self.prev_public = orig_all_public;\n         self.prev_exported = orig_all_exported;\n@@ -392,7 +403,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n         }\n-        visit::walk_mod(self, m)\n+        intravisit::walk_mod(self, m)\n     }\n \n     fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {\n@@ -895,9 +906,15 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         let orig_curitem = replace(&mut self.curitem, item.id);\n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n         self.curitem = orig_curitem;\n     }\n \n@@ -958,7 +975,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_expr(self, expr);\n+        intravisit::walk_expr(self, expr);\n     }\n \n     fn visit_pat(&mut self, pattern: &hir::Pat) {\n@@ -1004,19 +1021,19 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_pat(self, pattern);\n+        intravisit::walk_pat(self, pattern);\n     }\n \n     fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n         self.in_foreign = true;\n-        visit::walk_foreign_item(self, fi);\n+        intravisit::walk_foreign_item(self, fi);\n         self.in_foreign = false;\n     }\n \n     fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n         if !path.segments.is_empty() {\n             self.check_path(path.span, id, path.segments.last().unwrap().identifier.name);\n-            visit::walk_path(self, path);\n+            intravisit::walk_path(self, path);\n         }\n     }\n \n@@ -1029,7 +1046,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             self.tcx.sess.bug(\"`self` import in an import list with empty prefix\");\n         };\n         self.check_path(item.span, item.node.id(), name);\n-        visit::walk_path_list_item(self, prefix, item);\n+        intravisit::walk_path_list_item(self, prefix, item);\n     }\n }\n \n@@ -1043,6 +1060,12 @@ struct SanePrivacyVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         self.check_sane_privacy(item);\n         if self.in_block {\n@@ -1054,13 +1077,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n         // Modules turn privacy back on, otherwise we inherit\n         self.in_block = if let hir::ItemMod(..) = item.node { false } else { orig_in_block };\n \n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n         self.in_block = orig_in_block;\n     }\n \n     fn visit_block(&mut self, b: &'v hir::Block) {\n         let orig_in_block = replace(&mut self.in_block, true);\n-        visit::walk_block(self, b);\n+        intravisit::walk_block(self, b);\n         self.in_block = orig_in_block;\n     }\n }\n@@ -1220,14 +1243,20 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 't\n             }\n         }\n         self.at_outer_type = false;\n-        visit::walk_ty(self, ty)\n+        intravisit::walk_ty(self, ty)\n     }\n \n     // don't want to recurse into [, .. expr]\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         match item.node {\n             // contents of a private mod can be reexported, so we need\n@@ -1313,7 +1342,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                         not_private_trait &&\n                         trait_or_some_public_method {\n \n-                    visit::walk_generics(self, g);\n+                    intravisit::walk_generics(self, g);\n \n                     match *trait_ref {\n                         None => {\n@@ -1328,10 +1357,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                     hir::ImplItemKind::Method(..)\n                                         if self.item_is_public(&impl_item.id, impl_item.vis) =>\n                                     {\n-                                        visit::walk_impl_item(self, impl_item)\n+                                        intravisit::walk_impl_item(self, impl_item)\n                                     }\n                                     hir::ImplItemKind::Type(..) => {\n-                                        visit::walk_impl_item(self, impl_item)\n+                                        intravisit::walk_impl_item(self, impl_item)\n                                     }\n                                     _ => {}\n                                 }\n@@ -1351,7 +1380,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                             //\n                             // Those in 2. are warned via walk_generics and this\n                             // call here.\n-                            visit::walk_path(self, &tr.path);\n+                            intravisit::walk_path(self, &tr.path);\n \n                             // Those in 3. are warned with this call.\n                             for impl_item in impl_items {\n@@ -1370,21 +1399,21 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                             hir::ImplItemKind::Const(..) => {\n                                 if self.item_is_public(&impl_item.id, impl_item.vis) {\n                                     found_pub_static = true;\n-                                    visit::walk_impl_item(self, impl_item);\n+                                    intravisit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n                             hir::ImplItemKind::Method(ref sig, _) => {\n                                 if sig.explicit_self.node == hir::SelfStatic &&\n                                       self.item_is_public(&impl_item.id, impl_item.vis) {\n                                     found_pub_static = true;\n-                                    visit::walk_impl_item(self, impl_item);\n+                                    intravisit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n                             _ => {}\n                         }\n                     }\n                     if found_pub_static {\n-                        visit::walk_generics(self, g)\n+                        intravisit::walk_generics(self, g)\n                     }\n                 }\n                 return\n@@ -1407,7 +1436,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n         // public signatures, i.e. things that we're interested in for\n         // this visitor.\n         debug!(\"VisiblePrivateTypesVisitor entering item {:?}\", item);\n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n     }\n \n     fn visit_generics(&mut self, generics: &hir::Generics) {\n@@ -1433,7 +1462,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n         if self.exported_items.contains(&item.id) {\n-            visit::walk_foreign_item(self, item)\n+            intravisit::walk_foreign_item(self, item)\n         }\n     }\n \n@@ -1446,13 +1475,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                           \"private type in exported type signature\");\n             }\n         }\n-        visit::walk_ty(self, t)\n+        intravisit::walk_ty(self, t)\n     }\n \n     fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n         if self.exported_items.contains(&v.node.data.id()) {\n             self.in_variant = true;\n-            visit::walk_variant(self, v, g, item_id);\n+            intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n         }\n     }\n@@ -1462,7 +1491,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::NamedField(_, vis) | hir::UnnamedField(vis) => vis\n         };\n         if vis == hir::Public || self.in_variant {\n-            visit::walk_struct_field(self, s);\n+            intravisit::walk_struct_field(self, s);\n         }\n     }\n \n@@ -1489,14 +1518,15 @@ pub fn check_crate(tcx: &ty::ctxt,\n         tcx: tcx,\n         in_block: false,\n     };\n-    visit::walk_crate(&mut visitor, krate);\n+    intravisit::walk_crate(&mut visitor, krate);\n \n     // Figure out who everyone's parent is\n     let mut visitor = ParentVisitor {\n+        tcx: tcx,\n         parents: NodeMap(),\n         curparent: ast::DUMMY_NODE_ID,\n     };\n-    visit::walk_crate(&mut visitor, krate);\n+    intravisit::walk_crate(&mut visitor, krate);\n \n     // Use the parent map to check the privacy of everything\n     let mut visitor = PrivacyVisitor {\n@@ -1506,7 +1536,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         parents: visitor.parents,\n         external_exports: external_exports,\n     };\n-    visit::walk_crate(&mut visitor, krate);\n+    intravisit::walk_crate(&mut visitor, krate);\n \n     tcx.sess.abort_if_errors();\n \n@@ -1524,7 +1554,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n     visitor.public_items.insert(ast::CRATE_NODE_ID);\n     loop {\n         let before = (visitor.exported_items.len(), visitor.public_items.len());\n-        visit::walk_crate(&mut visitor, krate);\n+        intravisit::walk_crate(&mut visitor, krate);\n         let after = (visitor.exported_items.len(), visitor.public_items.len());\n         if after == before {\n             break\n@@ -1540,7 +1570,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n             public_items: &public_items,\n             in_variant: false,\n         };\n-        visit::walk_crate(&mut visitor, krate);\n+        intravisit::walk_crate(&mut visitor, krate);\n     }\n     return (exported_items, public_items);\n }"}, {"sha": "4ea120724a7cad63d8bec12f02bc87053f17a0b4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -52,7 +52,7 @@ use rustc_front::hir::StmtDecl;\n use rustc_front::hir::UnnamedField;\n use rustc_front::hir::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use rustc_front::hir::Visibility;\n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::{self, Visitor};\n \n use std::mem::replace;\n use std::ops::{Deref, DerefMut};\n@@ -111,7 +111,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             builder: self,\n             parent: parent,\n         };\n-        visit::walk_crate(&mut visitor, krate);\n+        intravisit::walk_crate(&mut visitor, krate);\n     }\n \n     /// Adds a new child item to the module definition of the parent node and\n@@ -1051,10 +1051,14 @@ struct BuildReducedGraphVisitor<'a, 'b: 'a, 'tcx: 'b> {\n }\n \n impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.builder.resolver.ast_map.expect_item(item.id))\n+    }\n+\n     fn visit_item(&mut self, item: &Item) {\n         let p = self.builder.build_reduced_graph_for_item(item, &self.parent);\n         let old_parent = replace(&mut self.parent, p);\n-        visit::walk_item(self, item);\n+        intravisit::walk_item(self, item);\n         self.parent = old_parent;\n     }\n \n@@ -1065,7 +1069,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     fn visit_block(&mut self, block: &Block) {\n         let np = self.builder.build_reduced_graph_for_block(block, &self.parent);\n         let old_parent = replace(&mut self.parent, np);\n-        visit::walk_block(self, block);\n+        intravisit::walk_block(self, block);\n         self.parent = old_parent;\n     }\n }"}, {"sha": "439caf20b6b9cb9f8cc45bcdad50e556971344e7", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -29,7 +29,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n \n use rustc_front::hir;\n use rustc_front::hir::{ViewPathGlob, ViewPathList, ViewPathSimple};\n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::Visitor;\n \n struct UnusedImportCheckVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     resolver: &'a mut Resolver<'b, 'tcx>,\n@@ -118,7 +118,6 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n         if item.vis == hir::Public || item.span == DUMMY_SP {\n-            visit::walk_item(self, item);\n             return;\n         }\n \n@@ -158,12 +157,10 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n             }\n             _ => {}\n         }\n-\n-        visit::walk_item(self, item);\n     }\n }\n \n pub fn check_crate(resolver: &mut Resolver, krate: &hir::Crate) {\n     let mut visitor = UnusedImportCheckVisitor { resolver: resolver };\n-    visit::walk_crate(&mut visitor, krate);\n+    krate.visit_all_items(&mut visitor);\n }"}, {"sha": "8776ee2d83141a4a5a778f9d8e1e621e35ac1d93", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -76,7 +76,7 @@ use syntax::parse::token::{self, special_names, special_idents};\n use syntax::ptr::P;\n use syntax::codemap::{self, Span, Pos};\n \n-use rustc_front::visit::{self, FnKind, Visitor};\n+use rustc_front::intravisit::{self, FnKind, Visitor};\n use rustc_front::hir;\n use rustc_front::hir::{Arm, BindByRef, BindByValue, BindingMode, Block};\n use rustc_front::hir::Crate;\n@@ -541,6 +541,9 @@ enum NameDefinition {\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.ast_map.expect_item(item.id))\n+    }\n     fn visit_item(&mut self, item: &Item) {\n         execute_callback!(hir_map::Node::NodeItem(item), self);\n         self.resolve_item(item);\n@@ -573,7 +576,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                 // error already reported\n             }\n         }\n-        visit::walk_poly_trait_ref(self, tref, m);\n+        intravisit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_variant(&mut self,\n                      variant: &hir::Variant,\n@@ -583,11 +586,11 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n         if let Some(ref dis_expr) = variant.node.disr_expr {\n             // resolve the discriminator expr as a constant\n             self.with_constant_rib(|this| {\n-                this.visit_expr(&**dis_expr);\n+                this.visit_expr(dis_expr);\n             });\n         }\n \n-        // `visit::walk_variant` without the discriminant expression.\n+        // `intravisit::walk_variant` without the discriminant expression.\n         self.visit_variant_data(&variant.node.data,\n                                 variant.node.name,\n                                 generics,\n@@ -603,7 +606,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n             ForeignItemStatic(..) => NoTypeParameters,\n         };\n         self.with_type_parameter_rib(type_parameters, |this| {\n-            visit::walk_foreign_item(this, foreign_item);\n+            intravisit::walk_foreign_item(this, foreign_item);\n         });\n     }\n     fn visit_fn(&mut self,\n@@ -2047,7 +2050,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn resolve_crate(&mut self, krate: &hir::Crate) {\n         debug!(\"(resolving crate) starting\");\n \n-        visit::walk_crate(self, krate);\n+        intravisit::walk_crate(self, krate);\n     }\n \n     fn check_if_primitive_type_name(&self, name: Name, span: Span) {\n@@ -2071,11 +2074,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.check_if_primitive_type_name(name, item.span);\n \n                 self.with_type_parameter_rib(HasTypeParameters(generics, TypeSpace, ItemRibKind),\n-                                             |this| visit::walk_item(this, item));\n+                                             |this| intravisit::walk_item(this, item));\n             }\n             ItemFn(_, _, _, _, ref generics, _) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics, FnSpace, ItemRibKind),\n-                                             |this| visit::walk_item(this, item));\n+                                             |this| intravisit::walk_item(this, item));\n             }\n \n             ItemDefaultImpl(_, ref trait_ref) => {\n@@ -2110,10 +2113,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     // expression in a provided default.\n                                     if default.is_some() {\n                                         this.with_constant_rib(|this| {\n-                                            visit::walk_trait_item(this, trait_item)\n+                                            intravisit::walk_trait_item(this, trait_item)\n                                         });\n                                     } else {\n-                                        visit::walk_trait_item(this, trait_item)\n+                                        intravisit::walk_trait_item(this, trait_item)\n                                     }\n                                 }\n                                 hir::MethodTraitItem(ref sig, _) => {\n@@ -2122,14 +2125,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                           FnSpace,\n                                                           MethodRibKind);\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n-                                        visit::walk_trait_item(this, trait_item)\n+                                        intravisit::walk_trait_item(this, trait_item)\n                                     });\n                                 }\n                                 hir::TypeTraitItem(..) => {\n                                     this.check_if_primitive_type_name(trait_item.name,\n                                                                       trait_item.span);\n                                     this.with_type_parameter_rib(NoTypeParameters, |this| {\n-                                        visit::walk_trait_item(this, trait_item)\n+                                        intravisit::walk_trait_item(this, trait_item)\n                                     });\n                                 }\n                             };\n@@ -2140,13 +2143,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             ItemMod(_) | ItemForeignMod(_) => {\n                 self.with_scope(Some(name), |this| {\n-                    visit::walk_item(this, item);\n+                    intravisit::walk_item(this, item);\n                 });\n             }\n \n             ItemConst(..) | ItemStatic(..) => {\n                 self.with_constant_rib(|this| {\n-                    visit::walk_item(this, item);\n+                    intravisit::walk_item(this, item);\n                 });\n             }\n \n@@ -2283,10 +2286,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             debug!(\"(resolving function) recorded argument\");\n         }\n-        visit::walk_fn_ret_ty(self, &declaration.output);\n+        intravisit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body.\n-        self.visit_block(&*block);\n+        self.visit_block(block);\n \n         debug!(\"(resolving function) leaving function\");\n \n@@ -2347,7 +2350,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n         }\n-        visit::walk_generics(self, generics);\n+        intravisit::walk_generics(self, generics);\n     }\n \n     fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n@@ -2374,7 +2377,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 new_val = Some((path_res.base_def.def_id(), trait_ref.clone()));\n                 new_id = Some(path_res.base_def.def_id());\n             }\n-            visit::walk_trait_ref(self, trait_ref);\n+            intravisit::walk_trait_ref(self, trait_ref);\n         }\n         let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n         let result = f(self, new_id);\n@@ -2427,7 +2430,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n                                     this.with_constant_rib(|this| {\n-                                        visit::walk_impl_item(this, impl_item);\n+                                        intravisit::walk_impl_item(this, impl_item);\n                                     });\n                                 }\n                                 hir::ImplItemKind::Method(ref sig, _) => {\n@@ -2444,7 +2447,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                           FnSpace,\n                                                           MethodRibKind);\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n-                                        visit::walk_impl_item(this, impl_item);\n+                                        intravisit::walk_impl_item(this, impl_item);\n                                     });\n                                 }\n                                 hir::ImplItemKind::Type(ref ty) => {\n@@ -2583,7 +2586,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut found_non_item = false;\n         for statement in &block.stmts {\n             if let hir::StmtDecl(ref declaration, _) = statement.node {\n-                if let hir::DeclItem(ref i) = declaration.node {\n+                if let hir::DeclItem(i) = declaration.node {\n+                    let i = self.ast_map.expect_item(i.id);\n                     match i.node {\n                         ItemExternCrate(_) | ItemUse(_) if found_non_item => {\n                             span_err!(self.session,\n@@ -2602,7 +2606,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Descend into the block.\n-        visit::walk_block(self, block);\n+        intravisit::walk_block(self, block);\n \n         // Move back up.\n         if !self.resolved {\n@@ -2623,7 +2627,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // `<T>::a::b::c` is resolved by typeck alone.\n                     TypecheckRequired => {\n                         // Resolve embedded types.\n-                        visit::walk_ty(self, ty);\n+                        intravisit::walk_ty(self, ty);\n                         return;\n                     }\n                     ResolveAttempt(resolution) => resolution,\n@@ -2674,7 +2678,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             _ => {}\n         }\n         // Resolve embedded types.\n-        visit::walk_ty(self, ty);\n+        intravisit::walk_ty(self, ty);\n     }\n \n     fn resolve_pattern(&mut self,\n@@ -2862,7 +2866,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 &path.segments.last().unwrap().identifier.name.as_str())\n                         );\n                     }\n-                    visit::walk_path(self, path);\n+                    intravisit::walk_path(self, path);\n                 }\n \n                 PatQPath(ref qself, ref path) => {\n@@ -2883,7 +2887,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                  .name;\n                             let traits = self.get_traits_containing_item(const_name);\n                             self.trait_map.insert(pattern.id, traits);\n-                            visit::walk_pat(self, pattern);\n+                            intravisit::walk_pat(self, pattern);\n                             return true;\n                         }\n                         ResolveAttempt(resolution) => resolution,\n@@ -2915,7 +2919,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                                       .name\n                                                                                       .as_str()));\n                     }\n-                    visit::walk_pat(self, pattern);\n+                    intravisit::walk_pat(self, pattern);\n                 }\n \n                 PatStruct(ref path, _, _) => {\n@@ -2933,11 +2937,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    visit::walk_path(self, path);\n+                    intravisit::walk_path(self, path);\n                 }\n \n                 PatLit(_) | PatRange(..) => {\n-                    visit::walk_pat(self, pattern);\n+                    intravisit::walk_pat(self, pattern);\n                 }\n \n                 _ => {\n@@ -3665,7 +3669,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let method_name = path.segments.last().unwrap().identifier.name;\n                         let traits = self.get_traits_containing_item(method_name);\n                         self.trait_map.insert(expr.id, traits);\n-                        visit::walk_expr(self, expr);\n+                        intravisit::walk_expr(self, expr);\n                         return;\n                     }\n                     ResolveAttempt(resolution) => resolution,\n@@ -3777,7 +3781,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n \n-                visit::walk_expr(self, expr);\n+                intravisit::walk_expr(self, expr);\n             }\n \n             ExprStruct(ref path, _, _) => {\n@@ -3797,7 +3801,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n \n-                visit::walk_expr(self, expr);\n+                intravisit::walk_expr(self, expr);\n             }\n \n             ExprLoop(_, Some(label)) | ExprWhile(_, _, Some(label)) => {\n@@ -3810,7 +3814,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         rib.bindings.insert(renamed, def_like);\n                     }\n \n-                    visit::walk_expr(this, expr);\n+                    intravisit::walk_expr(this, expr);\n                 })\n             }\n \n@@ -3838,7 +3842,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             _ => {\n-                visit::walk_expr(self, expr);\n+                intravisit::walk_expr(self, expr);\n             }\n         }\n     }"}, {"sha": "cd443647ad19382983b849a33cddfd1a2f46f75d", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 61, "deletions": 50, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -100,8 +100,7 @@ use syntax::parse::token::InternedString;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use rustc_front;\n-use rustc_front::visit::Visitor;\n-use rustc_front::visit;\n+use rustc_front::intravisit::{self, Visitor};\n use rustc_front::hir;\n use syntax::ast;\n \n@@ -1300,7 +1299,7 @@ impl<'v> Visitor<'v> for FindNestedReturn {\n             hir::ExprRet(..) => {\n                 self.found = true;\n             }\n-            _ => visit::walk_expr(self, e)\n+            _ => intravisit::walk_expr(self, e)\n         }\n     }\n }\n@@ -1369,7 +1368,7 @@ fn has_nested_returns(tcx: &ty::ctxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bo\n             Some(hir_map::NodeExpr(ex)) => {\n                 if let hir::ExprRet(Some(ref ret_expr)) = ex.node {\n                     let mut visitor = FindNestedReturn::new();\n-                    visit::walk_expr(&mut visitor, &**ret_expr);\n+                    intravisit::walk_expr(&mut visitor, &**ret_expr);\n                     if visitor.found {\n                         return true;\n                     }\n@@ -2143,16 +2142,6 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span,\n     }\n }\n \n-pub struct TransItemVisitor<'a, 'tcx: 'a> {\n-    pub ccx: &'a CrateContext<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for TransItemVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &hir::Item) {\n-        trans_item(self.ccx, i);\n-    }\n-}\n-\n pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n     // applicable to variable declarations and may not really make sense for\n@@ -2302,11 +2291,6 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                 }\n             }\n         }\n-\n-        // Be sure to travel more than just one layer deep to catch nested\n-        // items in blocks and such.\n-        let mut v = TransItemVisitor{ ccx: ccx };\n-        v.visit_block(&**body);\n       }\n       hir::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n         meth::trans_impl(ccx,\n@@ -2315,8 +2299,9 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                          generics,\n                          item.id);\n       }\n-      hir::ItemMod(ref m) => {\n-        trans_mod(&ccx.rotate(), m);\n+      hir::ItemMod(_) => {\n+          // modules have no equivalent at runtime, they just affect\n+          // the mangled names of things contained within\n       }\n       hir::ItemEnum(ref enum_definition, ref gens) => {\n         if gens.ty_params.is_empty() {\n@@ -2325,16 +2310,9 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n             enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n         }\n       }\n-      hir::ItemConst(_, ref expr) => {\n-          // Recurse on the expression to catch items in blocks\n-          let mut v = TransItemVisitor{ ccx: ccx };\n-          v.visit_expr(&**expr);\n+      hir::ItemConst(..) => {\n       }\n       hir::ItemStatic(_, m, ref expr) => {\n-          // Recurse on the expression to catch items in blocks\n-          let mut v = TransItemVisitor{ ccx: ccx };\n-          v.visit_expr(&**expr);\n-\n           let g = match consts::trans_static(ccx, m, expr, item.id, &item.attrs) {\n               Ok(g) => g,\n               Err(err) => ccx.tcx().sess.span_fatal(expr.span, &err.description()),\n@@ -2346,30 +2324,11 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n         foreign::trans_foreign_mod(ccx, foreign_mod);\n       }\n       hir::ItemTrait(..) => {\n-        // Inside of this trait definition, we won't be actually translating any\n-        // functions, but the trait still needs to be walked. Otherwise default\n-        // methods with items will not get translated and will cause ICE's when\n-        // metadata time comes around.\n-        let mut v = TransItemVisitor{ ccx: ccx };\n-        visit::walk_item(&mut v, item);\n       }\n       _ => {/* fall through */ }\n     }\n }\n \n-// Translate a module. Doing this amounts to translating the items in the\n-// module; there ends up being no artifact (aside from linkage names) of\n-// separate modules in the compiled program.  That's because modules exist\n-// only as a convenience for humans working with the code, to organize names\n-// and control visibility.\n-pub fn trans_mod(ccx: &CrateContext, m: &hir::Mod) {\n-    let _icx = push_ctxt(\"trans_mod\");\n-    for item in &m.items {\n-        trans_item(ccx, &**item);\n-    }\n-}\n-\n-\n // only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n pub fn register_fn_llvmty(ccx: &CrateContext,\n                           sp: Span,\n@@ -2994,10 +2953,12 @@ pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // First, verify intrinsics.\n         intrinsic::check_intrinsics(&ccx);\n \n-        // Next, translate the module.\n+        // Next, translate all items. See `TransModVisitor` for\n+        // details on why we walk in this particular way.\n         {\n             let _icx = push_ctxt(\"text\");\n-            trans_mod(&ccx, &krate.module);\n+            intravisit::walk_mod(&mut TransItemsWithinModVisitor { ccx: &ccx }, &krate.module);\n+            krate.visit_all_items(&mut TransModVisitor { ccx: &ccx });\n         }\n     }\n \n@@ -3100,3 +3061,53 @@ pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         no_builtins: no_builtins,\n     }\n }\n+\n+/// We visit all the items in the krate and translate them.  We do\n+/// this in two walks. The first walk just finds module items. It then\n+/// walks the full contents of those module items and translates all\n+/// the items within. Note that this entire process is O(n). The\n+/// reason for this two phased walk is that each module is\n+/// (potentially) placed into a distinct codegen-unit. This walk also\n+/// ensures that the immediate contents of each module is processed\n+/// entirely before we proceed to find more modules, helping to ensure\n+/// an equitable distribution amongst codegen-units.\n+pub struct TransModVisitor<'a, 'tcx: 'a> {\n+    pub ccx: &'a CrateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for TransModVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &hir::Item) {\n+        match i.node {\n+            hir::ItemMod(_) => {\n+                let item_ccx = self.ccx.rotate();\n+                intravisit::walk_item(&mut TransItemsWithinModVisitor { ccx: &item_ccx }, i);\n+            }\n+            _ => { }\n+        }\n+    }\n+}\n+\n+/// Translates all the items within a given module. Expects owner to\n+/// invoke `walk_item` on a module item. Ignores nested modules.\n+pub struct TransItemsWithinModVisitor<'a, 'tcx: 'a> {\n+    pub ccx: &'a CrateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for TransItemsWithinModVisitor<'a, 'tcx> {\n+    fn visit_nested_item(&mut self, item_id: hir::ItemId) {\n+        self.visit_item(self.ccx.tcx().map.expect_item(item_id.id));\n+    }\n+\n+    fn visit_item(&mut self, i: &hir::Item) {\n+        match i.node {\n+            hir::ItemMod(..) => {\n+                // skip modules, they will be uncovered by the TransModVisitor\n+            }\n+            _ => {\n+                trans_item(self.ccx, i);\n+                intravisit::walk_item(self, i);\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "8449d63015ef71447203d29e673a1311cd227826", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -43,7 +43,6 @@ use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n use syntax::ptr::P;\n \n-use rustc_front::visit;\n use rustc_front::hir;\n \n // drop_glue pointer, size, align.\n@@ -63,21 +62,12 @@ pub fn trans_impl(ccx: &CrateContext,\n \n     debug!(\"trans_impl(name={}, id={})\", name, id);\n \n-    let mut v = TransItemVisitor { ccx: ccx };\n-\n     // Both here and below with generic methods, be sure to recurse and look for\n     // items that we need to translate.\n     if !generics.ty_params.is_empty() {\n-        for impl_item in impl_items {\n-            match impl_item.node {\n-                hir::ImplItemKind::Method(..) => {\n-                    visit::walk_impl_item(&mut v, impl_item);\n-                }\n-                _ => {}\n-            }\n-        }\n         return;\n     }\n+\n     for impl_item in impl_items {\n         match impl_item.node {\n             hir::ImplItemKind::Method(ref sig, ref body) => {\n@@ -94,7 +84,6 @@ pub fn trans_impl(ccx: &CrateContext,\n                                        if is_origin { OriginalTranslation } else { InlinedCopy });\n                     }\n                 }\n-                visit::walk_impl_item(&mut v, impl_item);\n             }\n             _ => {}\n         }"}, {"sha": "69770cd33b3528dd6b2c3b6f2e507d508df1aa79", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -386,7 +386,7 @@ impl Ord for TraitInfo {\n /// Retrieve all traits in this crate and any dependent crates.\n pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n     if ccx.all_traits.borrow().is_none() {\n-        use rustc_front::visit;\n+        use rustc_front::intravisit;\n \n         let mut traits = vec![];\n \n@@ -397,7 +397,7 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n             map: &'a hir_map::Map<'tcx>,\n             traits: &'a mut AllTraitsVec,\n         }\n-        impl<'v, 'a, 'tcx> visit::Visitor<'v> for Visitor<'a, 'tcx> {\n+        impl<'v, 'a, 'tcx> intravisit::Visitor<'v> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'v hir::Item) {\n                 match i.node {\n                     hir::ItemTrait(..) => {\n@@ -406,13 +406,12 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n                     }\n                     _ => {}\n                 }\n-                visit::walk_item(self, i)\n             }\n         }\n-        visit::walk_crate(&mut Visitor {\n+        ccx.tcx.map.krate().visit_all_items(&mut Visitor {\n             map: &ccx.tcx.map,\n             traits: &mut traits\n-        }, ccx.tcx.map.krate());\n+        });\n \n         // Cross-crate:\n         let mut external_mods = FnvHashSet();"}, {"sha": "a635c1b047da3474d38928820c8bf08bf2c0c1cc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -124,7 +124,7 @@ use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{self, InternedString};\n use syntax::ptr::P;\n \n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::{self, Visitor};\n use rustc_front::hir;\n use rustc_front::hir::Visibility;\n use rustc_front::hir::{Item, ItemImpl};\n@@ -363,30 +363,24 @@ struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         check_item_type(self.ccx, i);\n-        visit::walk_item(self, i);\n+        intravisit::walk_item(self, i);\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         match t.node {\n             hir::TyFixedLengthVec(_, ref expr) => {\n                 check_const_in_type(self.ccx, &**expr, self.ccx.tcx.types.usize);\n             }\n-            hir::TyBareFn(ref function_declaration) => {\n-                visit::walk_fn_decl_nopat(self, &function_declaration.decl);\n-                walk_list!(self, visit_lifetime_def, &function_declaration.lifetimes);\n-                return\n-            }\n             _ => {}\n         }\n \n-        visit::walk_ty(self, t);\n+        intravisit::walk_ty(self, t);\n     }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         check_item_body(self.ccx, i);\n-        visit::walk_item(self, i);\n     }\n }\n \n@@ -398,7 +392,7 @@ pub fn check_wf_old(ccx: &CrateCtxt) {\n     // comes, we run the new code and issue warnings.\n     let krate = ccx.tcx.map.krate();\n     let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n-    visit::walk_crate(&mut visit, krate);\n+    krate.visit_all_items(&mut visit);\n \n     // If types are not well-formed, it leads to all manner of errors\n     // downstream, so stop reporting errors at this point.\n@@ -408,7 +402,7 @@ pub fn check_wf_old(ccx: &CrateCtxt) {\n pub fn check_wf_new(ccx: &CrateCtxt) {\n     let krate = ccx.tcx.map.krate();\n     let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n-    visit::walk_crate(&mut visit, krate);\n+    krate.visit_all_items(&mut visit);\n \n     // If types are not well-formed, it leads to all manner of errors\n     // downstream, so stop reporting errors at this point.\n@@ -418,14 +412,14 @@ pub fn check_wf_new(ccx: &CrateCtxt) {\n pub fn check_item_types(ccx: &CrateCtxt) {\n     let krate = ccx.tcx.map.krate();\n     let mut visit = CheckItemTypesVisitor { ccx: ccx };\n-    visit::walk_crate(&mut visit, krate);\n+    krate.visit_all_items(&mut visit);\n     ccx.tcx.sess.abort_if_errors();\n }\n \n pub fn check_item_bodies(ccx: &CrateCtxt) {\n     let krate = ccx.tcx.map.krate();\n     let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n-    visit::walk_crate(&mut visit, krate);\n+    krate.visit_all_items(&mut visit);\n \n     ccx.tcx.sess.abort_if_errors();\n }\n@@ -523,7 +517,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                local.pat,\n                self.fcx.infcx().ty_to_string(\n                    self.fcx.inh.locals.borrow().get(&local.id).unwrap().clone()));\n-        visit::walk_local(self, local);\n+        intravisit::walk_local(self, local);\n     }\n \n     // Add pattern bindings.\n@@ -542,14 +536,14 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                        var_ty);\n             }\n         }\n-        visit::walk_pat(self, p);\n+        intravisit::walk_pat(self, p);\n     }\n \n     fn visit_block(&mut self, b: &'tcx hir::Block) {\n         // non-obvious: the `blk` variable maps to region lb, so\n         // we have to keep this up-to-date.  This\n         // is... unfortunate.  It'd be nice to not need this.\n-        visit::walk_block(self, b);\n+        intravisit::walk_block(self, b);\n     }\n \n     // Since an expr occurs as part of the type fixed size arrays we\n@@ -561,18 +555,16 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                 check_expr_with_hint(self.fcx, &**count_expr, self.fcx.tcx().types.usize);\n             }\n             hir::TyBareFn(ref function_declaration) => {\n-                visit::walk_fn_decl_nopat(self, &function_declaration.decl);\n+                intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n                 walk_list!(self, visit_lifetime_def, &function_declaration.lifetimes);\n             }\n-            _ => visit::walk_ty(self, t)\n+            _ => intravisit::walk_ty(self, t)\n         }\n     }\n \n-    // Don't descend into fns and items\n-    fn visit_fn(&mut self, _: visit::FnKind<'tcx>, _: &'tcx hir::FnDecl,\n+    // Don't descend into the bodies of nested closures\n+    fn visit_fn(&mut self, _: intravisit::FnKind<'tcx>, _: &'tcx hir::FnDecl,\n                 _: &'tcx hir::Block, _: Span, _: ast::NodeId) { }\n-    fn visit_item(&mut self, _: &hir::Item) { }\n-\n }\n \n /// Helper used by check_bare_fn and check_expr_fn. Does the grungy work of checking a function"}, {"sha": "095dded777022544288671633cb4c5578803e009", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -102,8 +102,7 @@ use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n-use rustc_front::visit;\n-use rustc_front::visit::Visitor;\n+use rustc_front::intravisit::{self, Visitor};\n use rustc_front::hir;\n use rustc_front::util as hir_util;\n \n@@ -496,13 +495,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Rcx<'a, 'tcx> {\n     // hierarchy, and in particular the relationships between free\n     // regions, until regionck, as described in #3238.\n \n-    fn visit_fn(&mut self, _fk: visit::FnKind<'v>, fd: &'v hir::FnDecl,\n+    fn visit_fn(&mut self, _fk: intravisit::FnKind<'v>, fd: &'v hir::FnDecl,\n                 b: &'v hir::Block, span: Span, id: ast::NodeId) {\n         self.visit_fn_body(id, fd, b, span)\n     }\n \n-    fn visit_item(&mut self, i: &hir::Item) { visit_item(self, i); }\n-\n     fn visit_expr(&mut self, ex: &hir::Expr) { visit_expr(self, ex); }\n \n     //visit_pat: visit_pat, // (..) see above\n@@ -514,12 +511,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Rcx<'a, 'tcx> {\n     fn visit_block(&mut self, b: &hir::Block) { visit_block(self, b); }\n }\n \n-fn visit_item(_rcx: &mut Rcx, _item: &hir::Item) {\n-    // Ignore items\n-}\n-\n fn visit_block(rcx: &mut Rcx, b: &hir::Block) {\n-    visit::walk_block(rcx, b);\n+    intravisit::walk_block(rcx, b);\n }\n \n fn visit_arm(rcx: &mut Rcx, arm: &hir::Arm) {\n@@ -528,14 +521,14 @@ fn visit_arm(rcx: &mut Rcx, arm: &hir::Arm) {\n         constrain_bindings_in_pat(&**p, rcx);\n     }\n \n-    visit::walk_arm(rcx, arm);\n+    intravisit::walk_arm(rcx, arm);\n }\n \n fn visit_local(rcx: &mut Rcx, l: &hir::Local) {\n     // see above\n     constrain_bindings_in_pat(&*l.pat, rcx);\n     link_local(rcx, l);\n-    visit::walk_local(rcx, l);\n+    intravisit::walk_local(rcx, l);\n }\n \n fn constrain_bindings_in_pat(pat: &hir::Pat, rcx: &mut Rcx) {\n@@ -700,14 +693,14 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n                                args.iter().map(|e| &**e), false);\n             }\n \n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprMethodCall(_, _, ref args) => {\n             constrain_call(rcx, expr, Some(&*args[0]),\n                            args[1..].iter().map(|e| &**e), false);\n \n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n@@ -716,14 +709,14 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n                                Some(&**rhs).into_iter(), false);\n             }\n \n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprIndex(ref lhs, ref rhs) if has_method_map => {\n             constrain_call(rcx, expr, Some(&**lhs),\n                            Some(&**rhs).into_iter(), true);\n \n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) if has_method_map => {\n@@ -736,7 +729,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             constrain_call(rcx, expr, Some(&**lhs),\n                            Some(&**rhs).into_iter(), implicitly_ref_args);\n \n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprBinary(_, ref lhs, ref rhs) => {\n@@ -750,7 +743,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n                                   ty,\n                                   expr_region);\n             }\n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprUnary(op, ref lhs) if has_method_map => {\n@@ -760,7 +753,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             constrain_call(rcx, expr, Some(&**lhs),\n                            None::<hir::Expr>.iter(), implicitly_ref_args);\n \n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprUnary(hir::UnDeref, ref base) => {\n@@ -781,23 +774,23 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n                     rcx, expr.span, expr_region, *r_ptr);\n             }\n \n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprIndex(ref vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n             let vec_type = rcx.resolve_expr_type_adjusted(&**vec_expr);\n             constrain_index(rcx, expr, vec_type);\n \n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprCast(ref source, _) => {\n             // Determine if we are casting `source` to a trait\n             // instance.  If so, we have to be sure that the type of\n             // the source obeys the trait's region bound.\n             constrain_cast(rcx, expr, &**source);\n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprAddrOf(m, ref base) => {\n@@ -812,13 +805,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             // FIXME(#6268) nested method calls requires that this rule change\n             let ty0 = rcx.resolve_node_type(expr.id);\n             type_must_outlive(rcx, infer::AddrOf(expr.span), ty0, expr_region);\n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprMatch(ref discr, ref arms, _) => {\n             link_match(rcx, &**discr, &arms[..]);\n \n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprClosure(_, _, ref body) => {\n@@ -827,7 +820,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n \n         hir::ExprLoop(ref body, _) => {\n             let repeating_scope = rcx.set_repeating_scope(body.id);\n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n@@ -842,7 +835,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         }\n \n         _ => {\n-            visit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(rcx, expr);\n         }\n     }\n }\n@@ -897,7 +890,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                        expr: &hir::Expr,\n                        body: &hir::Block) {\n     let repeating_scope = rcx.set_repeating_scope(body.id);\n-    visit::walk_expr(rcx, expr);\n+    intravisit::walk_expr(rcx, expr);\n     rcx.set_repeating_scope(repeating_scope);\n }\n "}, {"sha": "0b77935771e44b0cb8c81dcfac19b05e3cea9c1d", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -52,7 +52,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc_front::hir;\n-use rustc_front::visit::{self, Visitor};\n+use rustc_front::intravisit::{self, Visitor};\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n@@ -105,11 +105,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx> {\n             _ => { }\n         }\n \n-        visit::walk_expr(self, expr);\n+        intravisit::walk_expr(self, expr);\n     }\n-\n-    // Skip all items; they aren't in the same context.\n-    fn visit_item(&mut self, _: &'v hir::Item) { }\n }\n \n impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n@@ -510,18 +507,15 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'tcx> {\n     fn visit_fn(&mut self,\n-                fn_kind: visit::FnKind<'v>,\n+                fn_kind: intravisit::FnKind<'v>,\n                 decl: &'v hir::FnDecl,\n                 body: &'v hir::Block,\n                 span: Span,\n                 id: ast::NodeId)\n     {\n-        visit::walk_fn(self, fn_kind, decl, body, span);\n+        intravisit::walk_fn(self, fn_kind, decl, body, span);\n         self.analyze_closure(id, span, decl, body);\n     }\n-\n-    // Skip all items; they aren't in the same context.\n-    fn visit_item(&mut self, _: &'v hir::Item) { }\n }\n \n impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {"}, {"sha": "3daf5003b97e01955d69d7fa3ccbf8257e2f3556", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -24,7 +24,7 @@ use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::special_idents;\n \n-use rustc_front::visit::{self, Visitor, FnKind};\n+use rustc_front::intravisit::{self, Visitor, FnKind};\n use rustc_front::hir;\n \n pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n@@ -423,7 +423,7 @@ fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     fn visit_item(&mut self, i: &hir::Item) {\n         self.check_item_well_formed(i);\n-        visit::walk_item(self, i);\n+        intravisit::walk_item(self, i);\n     }\n \n     fn visit_fn(&mut self,\n@@ -440,7 +440,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n             }\n         }\n-        visit::walk_fn(self, fk, fd, b, span)\n+        intravisit::walk_fn(self, fk, fd, b, span)\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'v hir::TraitItem) {\n@@ -460,7 +460,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n         }\n \n-        visit::walk_trait_item(self, trait_item)\n+        intravisit::walk_trait_item(self, trait_item)\n     }\n }\n "}, {"sha": "bfbf8fff4f5376917bd33728249217b61c3638dc", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -25,8 +25,7 @@ use syntax::ast;\n use syntax::codemap::{Span};\n use syntax::parse::token::{special_idents};\n use syntax::ptr::P;\n-use rustc_front::visit;\n-use rustc_front::visit::Visitor;\n+use rustc_front::intravisit::{self, Visitor};\n use rustc_front::hir;\n \n pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n@@ -492,19 +491,19 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     fn visit_item(&mut self, i: &hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n         self.check_item_well_formed(i);\n-        visit::walk_item(self, i);\n+        intravisit::walk_item(self, i);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'v hir::TraitItem) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n         self.check_trait_or_impl_item(trait_item.id, trait_item.span);\n-        visit::walk_trait_item(self, trait_item)\n+        intravisit::walk_trait_item(self, trait_item)\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'v hir::ImplItem) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n         self.check_trait_or_impl_item(impl_item.id, impl_item.span);\n-        visit::walk_impl_item(self, impl_item)\n+        intravisit::walk_impl_item(self, impl_item)\n     }\n }\n "}, {"sha": "984f227cebe79bc61adc4612bf7f8080f8877be9", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -29,8 +29,7 @@ use std::cell::Cell;\n use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n use rustc_front::print::pprust::pat_to_string;\n-use rustc_front::visit;\n-use rustc_front::visit::Visitor;\n+use rustc_front::intravisit::{self, Visitor};\n use rustc_front::util as hir_util;\n use rustc_front::hir;\n \n@@ -153,17 +152,13 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n // traffic in node-ids or update tables in the type context etc.\n \n impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n-    fn visit_item(&mut self, _: &hir::Item) {\n-        // Ignore items\n-    }\n-\n     fn visit_stmt(&mut self, s: &hir::Stmt) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n \n         self.visit_node_id(ResolvingExpr(s.span), hir_util::stmt_id(s));\n-        visit::walk_stmt(self, s);\n+        intravisit::walk_stmt(self, s);\n     }\n \n     fn visit_expr(&mut self, e: &hir::Expr) {\n@@ -183,7 +178,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n             }\n         }\n \n-        visit::walk_expr(self, e);\n+        intravisit::walk_expr(self, e);\n     }\n \n     fn visit_block(&mut self, b: &hir::Block) {\n@@ -192,7 +187,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n         }\n \n         self.visit_node_id(ResolvingExpr(b.span), b.id);\n-        visit::walk_block(self, b);\n+        intravisit::walk_block(self, b);\n     }\n \n     fn visit_pat(&mut self, p: &hir::Pat) {\n@@ -207,7 +202,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n                p.id,\n                self.tcx().node_id_to_type(p.id));\n \n-        visit::walk_pat(self, p);\n+        intravisit::walk_pat(self, p);\n     }\n \n     fn visit_local(&mut self, l: &hir::Local) {\n@@ -218,7 +213,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n         write_ty_to_tcx(self.tcx(), l.id, var_ty);\n-        visit::walk_local(self, l);\n+        intravisit::walk_local(self, l);\n     }\n \n     fn visit_ty(&mut self, t: &hir::Ty) {\n@@ -228,10 +223,10 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n                 write_ty_to_tcx(self.tcx(), count_expr.id, self.tcx().types.usize);\n             }\n             hir::TyBareFn(ref function_declaration) => {\n-                visit::walk_fn_decl_nopat(self, &function_declaration.decl);\n+                intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n                 walk_list!(self, visit_lifetime_def, &function_declaration.lifetimes);\n             }\n-            _ => visit::walk_ty(self, t)\n+            _ => intravisit::walk_ty(self, t)\n         }\n     }\n }"}, {"sha": "b3614210eefb61ddaa8ba9a8e802ef6e391d85f8", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -41,7 +41,7 @@ use syntax::parse::token;\n use util::nodemap::{DefIdMap, FnvHashMap};\n use rustc::front::map as hir_map;\n use rustc::front::map::NodeItem;\n-use rustc_front::visit;\n+use rustc_front::intravisit;\n use rustc_front::hir::{Item, ItemImpl,Crate};\n use rustc_front::hir;\n \n@@ -96,13 +96,11 @@ struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n     cc: &'a CoherenceChecker<'a, 'tcx>\n }\n \n-impl<'a, 'tcx, 'v> visit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         if let ItemImpl(..) = item.node {\n             self.cc.check_implementation(item)\n         }\n-\n-        visit::walk_item(self, item);\n     }\n }\n \n@@ -111,8 +109,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        let mut visitor = CoherenceCheckVisitor { cc: self };\n-        visit::walk_crate(&mut visitor, krate);\n+        krate.visit_all_items(&mut CoherenceCheckVisitor { cc: self });\n \n         // Copy over the inherent impls we gathered up during the walk into\n         // the tcx."}, {"sha": "8eeafb9b432a84534d48eb30f401a1dce6ac81ad", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -17,13 +17,13 @@ use middle::traits;\n use middle::ty;\n use syntax::ast;\n use syntax::codemap::Span;\n-use rustc_front::visit;\n+use rustc_front::intravisit;\n use rustc_front::hir;\n use rustc_front::hir::{Item, ItemImpl};\n \n pub fn check(tcx: &ty::ctxt) {\n     let mut orphan = OrphanChecker { tcx: tcx };\n-    visit::walk_crate(&mut orphan, tcx.map.krate());\n+    tcx.map.krate().visit_all_items(&mut orphan);\n }\n \n struct OrphanChecker<'cx, 'tcx:'cx> {\n@@ -354,9 +354,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         self.check_item(item);\n-        visit::walk_item(self, item);\n     }\n }"}, {"sha": "e91702e64ba9f82cfcaa4d59a1b9f8d073b90400", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -19,7 +19,7 @@ use middle::infer::{self, new_infer_ctxt};\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc_front::hir;\n-use rustc_front::visit;\n+use rustc_front::intravisit;\n use util::nodemap::DefIdMap;\n \n pub fn check(tcx: &ty::ctxt) {\n@@ -28,7 +28,7 @@ pub fn check(tcx: &ty::ctxt) {\n \n     // this secondary walk specifically checks for some other cases,\n     // like defaulted traits, for which additional overlap rules exist\n-    visit::walk_crate(&mut overlap, tcx.map.krate());\n+    tcx.map.krate().visit_all_items(&mut overlap);\n }\n \n struct OverlapChecker<'cx, 'tcx:'cx> {\n@@ -169,7 +169,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n }\n \n \n-impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemDefaultImpl(_, _) => {\n@@ -226,6 +226,5 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n             _ => {\n             }\n         }\n-        visit::walk_item(self, item);\n     }\n }"}, {"sha": "40b38ad88394bcbadf28e915918ba341ffe3156a", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -12,13 +12,13 @@\n //! crate or pertains to a type defined in this crate.\n \n use middle::ty;\n-use rustc_front::visit;\n+use rustc_front::intravisit;\n use rustc_front::hir;\n use rustc_front::hir::{Item, ItemImpl};\n \n pub fn check(tcx: &ty::ctxt) {\n     let mut orphan = UnsafetyChecker { tcx: tcx };\n-    visit::walk_crate(&mut orphan, tcx.map.krate());\n+    tcx.map.krate().visit_all_items(&mut orphan);\n }\n \n struct UnsafetyChecker<'cx, 'tcx:'cx> {\n@@ -76,7 +76,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemDefaultImpl(unsafety, _) => {\n@@ -87,7 +87,5 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n             }\n             _ => { }\n         }\n-\n-        visit::walk_item(self, item);\n     }\n }"}, {"sha": "efda06d8cf6190cf9857747141486f577cbea326", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -98,7 +98,7 @@ use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n use syntax::ptr::P;\n use rustc_front::hir;\n-use rustc_front::visit;\n+use rustc_front::intravisit;\n use rustc_front::print::pprust;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -108,10 +108,10 @@ pub fn collect_item_types(tcx: &ty::ctxt) {\n     let ccx = &CrateCtxt { tcx: tcx, stack: RefCell::new(Vec::new()) };\n \n     let mut visitor = CollectTraitDefVisitor{ ccx: ccx };\n-    visit::walk_crate(&mut visitor, ccx.tcx.map.krate());\n+    ccx.tcx.map.krate().visit_all_items(&mut visitor);\n \n     let mut visitor = CollectItemTypesVisitor{ ccx: ccx };\n-    visit::walk_crate(&mut visitor, ccx.tcx.map.krate());\n+    ccx.tcx.map.krate().visit_all_items(&mut visitor);\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -157,7 +157,7 @@ struct CollectTraitDefVisitor<'a, 'tcx: 'a> {\n     ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n-impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectTraitDefVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectTraitDefVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &hir::Item) {\n         match i.node {\n             hir::ItemTrait(..) => {\n@@ -166,8 +166,6 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectTraitDefVisitor<'a, 'tcx> {\n             }\n             _ => { }\n         }\n-\n-        visit::walk_item(self, i);\n     }\n }\n \n@@ -178,14 +176,14 @@ struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n     ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n-impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &hir::Item) {\n         convert_item(self.ccx, i);\n-        visit::walk_item(self, i);\n+        intravisit::walk_item(self, i);\n     }\n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n         convert_foreign_item(self.ccx, i);\n-        visit::walk_foreign_item(self, i);\n+        intravisit::walk_foreign_item(self, i);\n     }\n }\n "}, {"sha": "c9035bdff719d51e5f027601b3ae295d82e41274", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -276,8 +276,7 @@ use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n use rustc_front::hir;\n-use rustc_front::visit;\n-use rustc_front::visit::Visitor;\n+use rustc_front::intravisit::Visitor;\n use util::nodemap::NodeMap;\n \n pub fn infer_variance(tcx: &ty::ctxt) {\n@@ -383,7 +382,7 @@ fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n         })\n     };\n \n-    visit::walk_crate(&mut terms_cx, krate);\n+    krate.visit_all_items(&mut terms_cx);\n \n     terms_cx\n }\n@@ -531,7 +530,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n                 // constrained to be invariant. See `visit_item` in\n                 // the impl for `ConstraintContext` below.\n                 self.add_inferreds_for_item(item.id, true, generics);\n-                visit::walk_item(self, item);\n             }\n \n             hir::ItemExternCrate(_) |\n@@ -544,7 +542,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n             hir::ItemMod(..) |\n             hir::ItemForeignMod(..) |\n             hir::ItemTy(..) => {\n-                visit::walk_item(self, item);\n             }\n         }\n     }\n@@ -591,7 +588,7 @@ fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n         bivariant: bivariant,\n         constraints: Vec::new(),\n     };\n-    visit::walk_crate(&mut constraint_cx, krate);\n+    krate.visit_all_items(&mut constraint_cx);\n     constraint_cx\n }\n \n@@ -637,8 +634,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemDefaultImpl(..) => {\n             }\n         }\n-\n-        visit::walk_item(self, item);\n     }\n }\n "}, {"sha": "36ef110fba07a6ad975e266e3ca9fc3d02d3bd56", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -157,8 +157,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.vis = vis;\n         om.stab = self.stability(id);\n         om.id = id;\n-        for i in &m.items {\n-            self.visit_item(&**i, None, &mut om);\n+        for i in &m.item_ids {\n+            let item = self.cx.map.expect_item(i.id);\n+            self.visit_item(item, None, &mut om);\n         }\n         om\n     }\n@@ -224,8 +225,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     let prev = mem::replace(&mut self.inlining_from_glob, true);\n                     match it.node {\n                         hir::ItemMod(ref m) => {\n-                            for i in &m.items {\n-                                self.visit_item(&**i, None, om);\n+                            for i in &m.item_ids {\n+                                let i = self.cx.map.expect_item(i.id);\n+                                self.visit_item(i, None, om);\n                             }\n                         }\n                         hir::ItemEnum(..) => {}"}, {"sha": "44334762d90225c50e6fa19ba577082587be0429", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -289,7 +289,6 @@ pub trait IdVisitingOperation {\n \n pub struct IdVisitor<'a, O:'a> {\n     pub operation: &'a mut O,\n-    pub pass_through_items: bool,\n     pub visited_outermost: bool,\n }\n \n@@ -319,12 +318,10 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n     }\n \n     fn visit_item(&mut self, item: &Item) {\n-        if !self.pass_through_items {\n-            if self.visited_outermost {\n-                return\n-            } else {\n-                self.visited_outermost = true\n-            }\n+        if self.visited_outermost {\n+            return\n+        } else {\n+            self.visited_outermost = true\n         }\n \n         self.operation.visit_id(item.id);\n@@ -390,12 +387,10 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n                 block: &'v Block,\n                 span: Span,\n                 node_id: NodeId) {\n-        if !self.pass_through_items {\n-            match function_kind {\n-                FnKind::Method(..) if self.visited_outermost => return,\n-                FnKind::Method(..) => self.visited_outermost = true,\n-                _ => {}\n-            }\n+        match function_kind {\n+            FnKind::Method(..) if self.visited_outermost => return,\n+            FnKind::Method(..) => self.visited_outermost = true,\n+            _ => {}\n         }\n \n         self.operation.visit_id(node_id);\n@@ -420,10 +415,8 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n                        block,\n                        span);\n \n-        if !self.pass_through_items {\n-            if let FnKind::Method(..) = function_kind {\n-                self.visited_outermost = false;\n-            }\n+        if let FnKind::Method(..) = function_kind {\n+            self.visited_outermost = false;\n         }\n     }\n \n@@ -497,7 +490,6 @@ pub fn compute_id_range_for_fn_body(fk: FnKind,\n     let mut visitor = IdRangeComputingVisitor::new();\n     let mut id_visitor = IdVisitor {\n         operation: &mut visitor,\n-        pass_through_items: false,\n         visited_outermost: false,\n     };\n     id_visitor.visit_fn(fk, decl, body, sp, id);"}, {"sha": "e8c17ca0b362b8b584cc3b6072df4e430b82f89e", "filename": "src/test/compile-fail/issue-22638.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Ftest%2Fcompile-fail%2Fissue-22638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Ftest%2Fcompile-fail%2Fissue-22638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22638.rs?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -10,6 +10,8 @@\n \n #![allow(unused)]\n \n+#![recursion_limit = \"32\"]\n+\n #[derive(Clone)]\n struct A (B);\n "}, {"sha": "8ea4256133296078443a02625472f40dbb61aae5", "filename": "src/test/run-make/graphviz-flowgraph/f18.dot-expected.dot", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -1,14 +1,14 @@\n digraph block {\n     N0[label=\"entry\"];\n     N1[label=\"exit\"];\n-    N2[label=\"stmt fn inner(x: isize) -> isize { x + x }\"];\n+    N2[label=\"stmt \"];\n     N3[label=\"expr inner\"];\n     N4[label=\"expr inner\"];\n     N5[label=\"expr 18\"];\n     N6[label=\"expr inner(18)\"];\n     N7[label=\"expr inner(inner(18))\"];\n     N8[label=\"stmt inner(inner(18));\"];\n-    N9[label=\"block {\\l    fn inner(x: isize) -> isize { x + x }\\l    inner(inner(18));\\l}\\l\"];\n+    N9[label=\"block { inner(inner(18)); }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;"}, {"sha": "bc0ca08d4225782ec001d23757b8a6fcdf92b1ab", "filename": "src/test/run-make/graphviz-flowgraph/f19.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9303055f37a34adfceec1d1012b87308136295ce/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/9303055f37a34adfceec1d1012b87308136295ce/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot?ref=9303055f37a34adfceec1d1012b87308136295ce", "patch": "@@ -1,8 +1,8 @@\n digraph block {\n     N0[label=\"entry\"];\n     N1[label=\"exit\"];\n-    N2[label=\"stmt struct S19 {\\l    x: isize,\\l}\\l\"];\n-    N3[label=\"stmt impl S19 {\\l    fn inner(self) -> S19 { S19{x: self.x + self.x,} }\\l}\\l\"];\n+    N2[label=\"stmt \"];\n+    N3[label=\"stmt \"];\n     N4[label=\"expr 19\"];\n     N5[label=\"expr S19{x: 19,}\"];\n     N6[label=\"local s\"];\n@@ -11,7 +11,7 @@ digraph block {\n     N9[label=\"expr s.inner()\"];\n     N10[label=\"expr s.inner().inner()\"];\n     N11[label=\"stmt s.inner().inner();\"];\n-    N12[label=\"block {\\l    struct S19 {\\l        x: isize,\\l    }\\l    impl S19 {\\l        fn inner(self) -> S19 { S19{x: self.x + self.x,} }\\l    }\\l    let s = S19{x: 19,};\\l    s.inner().inner();\\l}\\l\"];\n+    N12[label=\"block { let s = S19{x: 19,}; s.inner().inner(); }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;"}]}