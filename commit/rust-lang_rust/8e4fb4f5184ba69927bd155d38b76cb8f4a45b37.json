{"sha": "8e4fb4f5184ba69927bd155d38b76cb8f4a45b37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNGZiNGY1MTg0YmE2OTkyN2JkMTU1ZDM4Yjc2Y2I4ZjRhNDViMzc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-09T17:09:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-09T17:09:13Z"}, "message": "Merge #9804\n\n9804: Generate method from call r=matklad a=mahdi-frms\n\nNeeds a bit of refactoring. Tests also should be added.\n\nCo-authored-by: mahdi-frms <mahdif1380@outlook.com>", "tree": {"sha": "334ada9bbbbe3099a05e5651ae9b76fb3cfbbdb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/334ada9bbbbe3099a05e5651ae9b76fb3cfbbdb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e4fb4f5184ba69927bd155d38b76cb8f4a45b37", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhEWE5CRBK7hj4Ov3rIwAAEmkIAFxJ/olEkm1BnIIxSP5EU1zL\nBmlqBRnrlVN0PDRjY5RMm9i/FpKGkOKc/jiIQ610k6+8+9D3gANo3tJJfFAB/DgB\nadf8aNPNbz08eqJeQV1UasiL0dbMu3t6+aHd5/RgsnJKT3QPpT15ExOu+2AYcbar\nqyQUDIS5y35utJZoxfOcQFNtQmy0ASixVF0l8ZsiwI7VKECt/I30jfw16MEzCTfK\nnE5c0KqfUUhdQFrsGcHAMoKz81y6NnyPTEjUukaYg7V4GaYl/63MaIbZMLYTyIiL\nnG7QAxnw3kXLu6aFphTh114diJJBgPTItDDld+lgO2k0NporLKJSjuYip9SgPYI=\n=RjcL\n-----END PGP SIGNATURE-----\n", "payload": "tree 334ada9bbbbe3099a05e5651ae9b76fb3cfbbdb8\nparent 63427afb69c57ce085cfda7e3a26189967c44632\nparent 05a789c09dbe886c82eaece6b2af134de6d277de\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628528953 +0000\ncommitter GitHub <noreply@github.com> 1628528953 +0000\n\nMerge #9804\n\n9804: Generate method from call r=matklad a=mahdi-frms\n\nNeeds a bit of refactoring. Tests also should be added.\n\nCo-authored-by: mahdi-frms <mahdif1380@outlook.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e4fb4f5184ba69927bd155d38b76cb8f4a45b37", "html_url": "https://github.com/rust-lang/rust/commit/8e4fb4f5184ba69927bd155d38b76cb8f4a45b37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e4fb4f5184ba69927bd155d38b76cb8f4a45b37/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63427afb69c57ce085cfda7e3a26189967c44632", "url": "https://api.github.com/repos/rust-lang/rust/commits/63427afb69c57ce085cfda7e3a26189967c44632", "html_url": "https://github.com/rust-lang/rust/commit/63427afb69c57ce085cfda7e3a26189967c44632"}, {"sha": "05a789c09dbe886c82eaece6b2af134de6d277de", "url": "https://api.github.com/repos/rust-lang/rust/commits/05a789c09dbe886c82eaece6b2af134de6d277de", "html_url": "https://github.com/rust-lang/rust/commit/05a789c09dbe886c82eaece6b2af134de6d277de"}], "stats": {"total": 351, "additions": 341, "deletions": 10}, "files": [{"sha": "cb281d5dcb3ab07e6d1aa179ce5f2659d9a1a027", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 337, "deletions": 10, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/8e4fb4f5184ba69927bd155d38b76cb8f4a45b37/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4fb4f5184ba69927bd155d38b76cb8f4a45b37/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=8e4fb4f5184ba69927bd155d38b76cb8f4a45b37", "patch": "@@ -1,4 +1,4 @@\n-use hir::{HirDisplay, TypeInfo};\n+use hir::{HasSource, HirDisplay, InFile, Module, TypeInfo};\n use ide_db::{base_db::FileId, helpers::SnippetCap};\n use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::to_lower_snake_case;\n@@ -13,7 +13,7 @@ use syntax::{\n \n use crate::{\n     utils::useless_type_special_case,\n-    utils::{render_snippet, Cursor},\n+    utils::{find_struct_impl, render_snippet, Cursor},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n \n@@ -43,6 +43,31 @@ use crate::{\n //\n // ```\n pub(crate) fn generate_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    gen_fn(acc, ctx).or_else(|| gen_method(acc, ctx))\n+}\n+\n+enum FuncExpr {\n+    Func(ast::CallExpr),\n+    Method(ast::MethodCallExpr),\n+}\n+\n+impl FuncExpr {\n+    fn arg_list(&self) -> Option<ast::ArgList> {\n+        match self {\n+            FuncExpr::Func(fn_call) => fn_call.arg_list(),\n+            FuncExpr::Method(m_call) => m_call.arg_list(),\n+        }\n+    }\n+\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            FuncExpr::Func(fn_call) => fn_call.syntax(),\n+            FuncExpr::Method(m_call) => m_call.syntax(),\n+        }\n+    }\n+}\n+\n+fn gen_fn(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n \n@@ -79,6 +104,69 @@ pub(crate) fn generate_function(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     )\n }\n \n+fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n+    let fn_name: ast::NameRef = ast::NameRef::cast(\n+        call.syntax().children().find(|child| child.kind() == SyntaxKind::NAME_REF)?,\n+    )?;\n+    let ty = ctx.sema.type_of_expr(&call.receiver()?)?.original().strip_references().as_adt()?;\n+\n+    let current_module =\n+        ctx.sema.scope(ctx.find_node_at_offset::<ast::MethodCallExpr>()?.syntax()).module()?;\n+    let target_module = ty.module(ctx.sema.db);\n+\n+    if current_module.krate() != target_module.krate() {\n+        return None;\n+    }\n+\n+    let (impl_, file) = match ty {\n+        hir::Adt::Struct(strukt) => get_impl(strukt.source(ctx.sema.db)?.syntax(), &fn_name, ctx),\n+        hir::Adt::Enum(en) => get_impl(en.source(ctx.sema.db)?.syntax(), &fn_name, ctx),\n+        hir::Adt::Union(union) => get_impl(union.source(ctx.sema.db)?.syntax(), &fn_name, ctx),\n+    }?;\n+\n+    let function_builder = FunctionBuilder::from_method_call(\n+        ctx,\n+        &call,\n+        &fn_name,\n+        &impl_,\n+        file,\n+        target_module,\n+        current_module,\n+    )?;\n+    let target = call.syntax().text_range();\n+\n+    acc.add(\n+        AssistId(\"generate_function\", AssistKind::Generate),\n+        format!(\"Generate `{}` function\", function_builder.fn_name),\n+        target,\n+        |builder| {\n+            let function_template = function_builder.render();\n+            builder.edit_file(function_template.file);\n+            let mut new_fn = function_template.to_string(ctx.config.snippet_cap);\n+            if impl_.is_none() {\n+                new_fn = format!(\"\\nimpl {} {{\\n{}\\n}}\", ty.name(ctx.sema.db), new_fn,);\n+            }\n+            match ctx.config.snippet_cap {\n+                Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n+                None => builder.insert(function_template.insert_offset, new_fn),\n+            }\n+        },\n+    )\n+}\n+\n+fn get_impl(\n+    adt: InFile<&SyntaxNode>,\n+    fn_name: &ast::NameRef,\n+    ctx: &AssistContext,\n+) -> Option<(Option<ast::Impl>, FileId)> {\n+    let file = adt.file_id.original_file(ctx.sema.db);\n+    let adt = adt.value;\n+    let adt = ast::Adt::cast(adt.clone())?;\n+    let r = find_struct_impl(ctx, &adt, fn_name.text().as_str())?;\n+    Some((r, file))\n+}\n+\n struct FunctionTemplate {\n     insert_offset: TextSize,\n     leading_ws: String,\n@@ -130,12 +218,12 @@ impl FunctionBuilder {\n                 file = in_file;\n                 target\n             }\n-            None => next_space_for_fn_after_call_site(call)?,\n+            None => next_space_for_fn_after_call_site(FuncExpr::Func(call.clone()))?,\n         };\n         let needs_pub = target_module.is_some();\n         let target_module = target_module.or_else(|| ctx.sema.scope(target.syntax()).module())?;\n         let fn_name = fn_name(path)?;\n-        let (type_params, params) = fn_args(ctx, target_module, call)?;\n+        let (type_params, params) = fn_args(ctx, target_module, FuncExpr::Func(call.clone()))?;\n \n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n@@ -181,6 +269,79 @@ impl FunctionBuilder {\n         })\n     }\n \n+    fn from_method_call(\n+        ctx: &AssistContext,\n+        call: &ast::MethodCallExpr,\n+        name: &ast::NameRef,\n+        impl_: &Option<ast::Impl>,\n+        file: FileId,\n+        target_module: Module,\n+        current_module: Module,\n+    ) -> Option<Self> {\n+        // let mut file = ctx.frange.file_id;\n+        // let target_module = ctx.sema.scope(call.syntax()).module()?;\n+        let target = match impl_ {\n+            Some(impl_) => next_space_for_fn_in_impl(&impl_)?,\n+            None => {\n+                next_space_for_fn_in_module(\n+                    ctx.sema.db,\n+                    &target_module.definition_source(ctx.sema.db),\n+                )?\n+                .1\n+            }\n+        };\n+        let needs_pub = !module_is_descendant(&current_module, &target_module, ctx);\n+\n+        let fn_name = make::name(&name.text());\n+        let (type_params, params) = fn_args(ctx, target_module, FuncExpr::Method(call.clone()))?;\n+\n+        let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n+        let is_async = await_expr.is_some();\n+\n+        // should_render_snippet intends to express a rough level of confidence about\n+        // the correctness of the return type.\n+        //\n+        // If we are able to infer some return type, and that return type is not unit, we\n+        // don't want to render the snippet. The assumption here is in this situation the\n+        // return type is just as likely to be correct as any other part of the generated\n+        // function.\n+        //\n+        // In the case where the return type is inferred as unit it is likely that the\n+        // user does in fact intend for this generated function to return some non unit\n+        // type, but that the current state of their code doesn't allow that return type\n+        // to be accurately inferred.\n+        let (ret_ty, should_render_snippet) = {\n+            match ctx\n+                .sema\n+                .type_of_expr(&ast::Expr::MethodCallExpr(call.clone()))\n+                .map(TypeInfo::original)\n+            {\n+                Some(ty) if ty.is_unknown() || ty.is_unit() => (make::ty_unit(), true),\n+                Some(ty) => {\n+                    let rendered = ty.display_source_code(ctx.db(), target_module.into());\n+                    match rendered {\n+                        Ok(rendered) => (make::ty(&rendered), false),\n+                        Err(_) => (make::ty_unit(), true),\n+                    }\n+                }\n+                None => (make::ty_unit(), true),\n+            }\n+        };\n+        let ret_type = make::ret_type(ret_ty);\n+\n+        Some(Self {\n+            target,\n+            fn_name,\n+            type_params,\n+            params,\n+            ret_type,\n+            should_render_snippet,\n+            file,\n+            needs_pub,\n+            is_async,\n+        })\n+    }\n+\n     fn render(self) -> FunctionTemplate {\n         let placeholder_expr = make::ext::expr_todo();\n         let fn_body = make::block_expr(vec![], Some(placeholder_expr));\n@@ -249,7 +410,7 @@ fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n fn fn_args(\n     ctx: &AssistContext,\n     target_module: hir::Module,\n-    call: &ast::CallExpr,\n+    call: FuncExpr,\n ) -> Option<(Option<ast::GenericParamList>, ast::ParamList)> {\n     let mut arg_names = Vec::new();\n     let mut arg_types = Vec::new();\n@@ -277,7 +438,17 @@ fn fn_args(\n     let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| {\n         make::param(make::ext::simple_ident_pat(make::name(&name)).into(), make::ty(&ty))\n     });\n-    Some((None, make::param_list(None, params)))\n+\n+    Some((\n+        None,\n+        make::param_list(\n+            match call {\n+                FuncExpr::Func(_) => None,\n+                FuncExpr::Method(_) => Some(make::self_param()),\n+            },\n+            params,\n+        ),\n+    ))\n }\n \n /// Makes duplicate argument names unique by appending incrementing numbers.\n@@ -348,7 +519,7 @@ fn fn_arg_type(\n /// directly after the current block\n /// We want to write the generated function directly after\n /// fns, impls or macro calls, but inside mods\n-fn next_space_for_fn_after_call_site(expr: &ast::CallExpr) -> Option<GeneratedFunctionTarget> {\n+fn next_space_for_fn_after_call_site(expr: FuncExpr) -> Option<GeneratedFunctionTarget> {\n     let mut ancestors = expr.syntax().ancestors().peekable();\n     let mut last_ancestor: Option<SyntaxNode> = None;\n     while let Some(next_ancestor) = ancestors.next() {\n@@ -401,6 +572,26 @@ fn next_space_for_fn_in_module(\n     Some((file, assist_item))\n }\n \n+fn next_space_for_fn_in_impl(impl_: &ast::Impl) -> Option<GeneratedFunctionTarget> {\n+    if let Some(last_item) = impl_.assoc_item_list().and_then(|it| it.assoc_items().last()) {\n+        Some(GeneratedFunctionTarget::BehindItem(last_item.syntax().clone()))\n+    } else {\n+        Some(GeneratedFunctionTarget::InEmptyItemList(impl_.assoc_item_list()?.syntax().clone()))\n+    }\n+}\n+\n+fn module_is_descendant(module: &hir::Module, ans: &hir::Module, ctx: &AssistContext) -> bool {\n+    if module == ans {\n+        return true;\n+    }\n+    for c in ans.children(ctx.sema.db) {\n+        if module_is_descendant(module, &c, ctx) {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -1164,8 +1355,7 @@ fn bar(baz: ()) {}\n \n     #[test]\n     fn create_method_with_no_args() {\n-        // FIXME: This is wrong, this should just work.\n-        check_assist_not_applicable(\n+        check_assist(\n             generate_function,\n             r#\"\n struct Foo;\n@@ -1174,7 +1364,19 @@ impl Foo {\n         self.bar()$0;\n     }\n }\n-        \"#,\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {\n+        self.bar();\n+    }\n+\n+    fn bar(&self) ${0:-> ()} {\n+        todo!()\n+    }\n+}\n+\"#,\n         )\n     }\n \n@@ -1195,6 +1397,131 @@ fn foo() {\n async fn bar(arg: i32) ${0:-> ()} {\n     todo!()\n }\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_method() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+fn foo() {S.bar$0();}\n+\",\n+            r\"\n+struct S;\n+fn foo() {S.bar();}\n+impl S {\n+\n+\n+fn bar(&self) ${0:-> ()} {\n+    todo!()\n+}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_method_within_an_impl() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+fn foo() {S.bar$0();}\n+impl S {}\n+\n+\",\n+            r\"\n+struct S;\n+fn foo() {S.bar();}\n+impl S {\n+    fn bar(&self) ${0:-> ()} {\n+        todo!()\n+    }\n+}\n+\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_method_from_different_module() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+mod s {\n+    pub struct S;\n+}\n+fn foo() {s::S.bar$0();}\n+\",\n+            r\"\n+mod s {\n+    pub struct S;\n+impl S {\n+\n+\n+    pub(crate) fn bar(&self) ${0:-> ()} {\n+        todo!()\n+    }\n+}\n+}\n+fn foo() {s::S.bar();}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_method_from_descendant_module() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+mod s {\n+    fn foo() {\n+        super::S.bar$0();\n+    }\n+}\n+\n+\",\n+            r\"\n+struct S;\n+mod s {\n+    fn foo() {\n+        super::S.bar();\n+    }\n+}\n+impl S {\n+\n+\n+fn bar(&self) ${0:-> ()} {\n+    todo!()\n+}\n+}\n+\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_method_with_cursor_anywhere_on_call_expresion() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+fn foo() {$0S.bar();}\n+\",\n+            r\"\n+struct S;\n+fn foo() {S.bar();}\n+impl S {\n+\n+\n+fn bar(&self) ${0:-> ()} {\n+    todo!()\n+}\n+}\n \",\n         )\n     }"}, {"sha": "ec90be35a6ee92b78f0b91db60ccb1a104b4531e", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e4fb4f5184ba69927bd155d38b76cb8f4a45b37/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4fb4f5184ba69927bd155d38b76cb8f4a45b37/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=8e4fb4f5184ba69927bd155d38b76cb8f4a45b37", "patch": "@@ -531,6 +531,10 @@ pub fn param(pat: ast::Pat, ty: ast::Type) -> ast::Param {\n     ast_from_text(&format!(\"fn f({}: {}) {{ }}\", pat, ty))\n }\n \n+pub fn self_param() -> ast::SelfParam {\n+    ast_from_text(&format!(\"fn f(&self) {{ }}\"))\n+}\n+\n pub fn ret_type(ty: ast::Type) -> ast::RetType {\n     ast_from_text(&format!(\"fn f() -> {} {{ }}\", ty))\n }"}]}