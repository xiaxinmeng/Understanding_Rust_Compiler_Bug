{"sha": "3015987f279b414eea37d719c8e35ed2d8d7704a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMTU5ODdmMjc5YjQxNGVlYTM3ZDcxOWM4ZTM1ZWQyZDhkNzcwNGE=", "commit": {"author": {"name": "Lachezar Lechev", "email": "elpiel93@gmail.com", "date": "2018-08-20T12:03:13Z"}, "committer": {"name": "Lachezar Lechev", "email": "elpiel93@gmail.com", "date": "2018-08-20T12:03:13Z"}, "message": "#3016 [WIP] Implement feedback and suggestions", "tree": {"sha": "6679bbcedac0b70ec6a9ba97fc7414e4c8f7db54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6679bbcedac0b70ec6a9ba97fc7414e4c8f7db54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3015987f279b414eea37d719c8e35ed2d8d7704a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3015987f279b414eea37d719c8e35ed2d8d7704a", "html_url": "https://github.com/rust-lang/rust/commit/3015987f279b414eea37d719c8e35ed2d8d7704a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3015987f279b414eea37d719c8e35ed2d8d7704a/comments", "author": {"login": "elpiel", "id": 8925621, "node_id": "MDQ6VXNlcjg5MjU2MjE=", "avatar_url": "https://avatars.githubusercontent.com/u/8925621?v=4", "gravatar_id": "", "url": "https://api.github.com/users/elpiel", "html_url": "https://github.com/elpiel", "followers_url": "https://api.github.com/users/elpiel/followers", "following_url": "https://api.github.com/users/elpiel/following{/other_user}", "gists_url": "https://api.github.com/users/elpiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/elpiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/elpiel/subscriptions", "organizations_url": "https://api.github.com/users/elpiel/orgs", "repos_url": "https://api.github.com/users/elpiel/repos", "events_url": "https://api.github.com/users/elpiel/events{/privacy}", "received_events_url": "https://api.github.com/users/elpiel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "elpiel", "id": 8925621, "node_id": "MDQ6VXNlcjg5MjU2MjE=", "avatar_url": "https://avatars.githubusercontent.com/u/8925621?v=4", "gravatar_id": "", "url": "https://api.github.com/users/elpiel", "html_url": "https://github.com/elpiel", "followers_url": "https://api.github.com/users/elpiel/followers", "following_url": "https://api.github.com/users/elpiel/following{/other_user}", "gists_url": "https://api.github.com/users/elpiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/elpiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/elpiel/subscriptions", "organizations_url": "https://api.github.com/users/elpiel/orgs", "repos_url": "https://api.github.com/users/elpiel/repos", "events_url": "https://api.github.com/users/elpiel/events{/privacy}", "received_events_url": "https://api.github.com/users/elpiel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cb94630fb6220240730e2bed8d82f80a107696d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb94630fb6220240730e2bed8d82f80a107696d", "html_url": "https://github.com/rust-lang/rust/commit/6cb94630fb6220240730e2bed8d82f80a107696d"}], "stats": {"total": 41, "additions": 27, "deletions": 14}, "files": [{"sha": "3c912756d2d706f038fd83a28641c02d545bf62d", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3015987f279b414eea37d719c8e35ed2d8d7704a/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3015987f279b414eea37d719c8e35ed2d8d7704a/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=3015987f279b414eea37d719c8e35ed2d8d7704a", "patch": "@@ -3,7 +3,7 @@ use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n use syntax::tokenstream::{ThinTokenStream, TokenStream};\n use syntax::parse::{token, parser};\n-use crate::utils::{span_lint, span_lint_and_sugg};\n+use crate::utils::{span_lint, span_lint_and_sugg, snippet};\n \n /// **What it does:** This lint warns when you use `println!(\"\")` to\n /// print a newline.\n@@ -212,13 +212,15 @@ impl EarlyLintPass for Pass {\n             let check_tts = check_tts(cx, &mac.node.tts, true);\n             if let Some(fmtstr) = check_tts.0 {\n                 if fmtstr == \"\" {\n+                    let suggestion = check_tts.1.map_or(\"v\", |expr| snippet(cx, expr.span, \"v\").into_owned().as_str());\n+\n                     span_lint_and_sugg(\n                         cx,\n                         WRITELN_EMPTY_STRING,\n                         mac.span,\n-                        format!(\"using `writeln!({}, \\\"\\\")`\", check_tts.1).as_str(),\n+                        format!(\"using writeln!({}, \\\"\\\")\", suggestion).as_str(),\n                         \"replace it with\",\n-                        format!(\"using `writeln!({})`\", check_tts.1),\n+                        format!(\"writeln!({})\", \"v\"),\n                     );\n                 }\n             }\n@@ -235,15 +237,23 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n         false,\n         false,\n     );\n-    // skip the initial write target\n-    let expr: Option<Expr> = match parser.parse_expr().map_err(|mut err| err.cancel()).ok() {\n-        Some(p) => Some(p.into_vec().0),\n-        None => None,\n-    };\n-    // might be `writeln!(foo)`\n-    parser.expect(&token::Comma).map_err(|mut err| err.cancel()).ok()?;\n+    let mut expr: Option<Expr> = None;\n+    if is_write {\n+        // skip the initial write target\n+        expr = match parser.parse_expr().map_err(|mut err| err.cancel()).ok() {\n+            Some(p) => Some(p.and_then(|expr| expr)),\n+            None => return (None, None),\n+        };\n+        // might be `writeln!(foo)`\n+        if let None = parser.expect(&token::Comma).map_err(|mut err| err.cancel()).ok() {\n+            return (None, expr);\n+        }\n+    }\n \n-    let fmtstr = parser.parse_str().map_err(|mut err| err.cancel()).ok()?.0.to_string();\n+    let fmtstr = match parser.parse_str().map_err(|mut err| err.cancel()).ok() {\n+        Some(token) => token.0.to_string(),\n+        None => return (None, expr),\n+    };\n     use fmt_macros::*;\n     let tmp = fmtstr.clone();\n     let mut args = vec![];\n@@ -271,7 +281,10 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n             assert!(parser.eat(&token::Eof));\n             return (Some(fmtstr), expr);\n         }\n-        let expr = parser.parse_expr().map_err(|mut err| err.cancel()).ok()?;\n+        let token_expr = match parser.parse_expr().map_err(|mut err| err.cancel()).ok() {\n+            Some(expr) => expr,\n+            None => return (Some(fmtstr), None),\n+        };\n         const SIMPLE: FormatSpec<'_> = FormatSpec {\n             fill: None,\n             align: AlignUnknown,\n@@ -280,7 +293,7 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n             width: CountImplied,\n             ty: \"\",\n         };\n-        match &expr.node {\n+        match &token_expr.node {\n             ExprKind::Lit(_) => {\n                 let mut all_simple = true;\n                 let mut seen = false;\n@@ -296,7 +309,7 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n                     }\n                 }\n                 if all_simple && seen {\n-                    span_lint(cx, lint, expr.span, \"literal with an empty format string\");\n+                    span_lint(cx, lint, token_expr.span, \"literal with an empty format string\");\n                 }\n                 idx += 1;\n             },"}]}