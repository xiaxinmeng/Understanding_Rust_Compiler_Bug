{"sha": "a1b823886c072dfda3e3fdd34e5661beaf57d6d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYjgyMzg4NmMwNzJkZmRhM2UzZmRkMzRlNTY2MWJlYWY1N2Q2ZDc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-22T17:50:12Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-22T17:59:06Z"}, "message": "give some context in error messages", "tree": {"sha": "b3bcdd561a4b68ed3d6611d8fb68c696a717db4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3bcdd561a4b68ed3d6611d8fb68c696a717db4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1b823886c072dfda3e3fdd34e5661beaf57d6d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1b823886c072dfda3e3fdd34e5661beaf57d6d7", "html_url": "https://github.com/rust-lang/rust/commit/a1b823886c072dfda3e3fdd34e5661beaf57d6d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1b823886c072dfda3e3fdd34e5661beaf57d6d7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7d2266414565647374f8e25c03854adde09aab2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7d2266414565647374f8e25c03854adde09aab2", "html_url": "https://github.com/rust-lang/rust/commit/d7d2266414565647374f8e25c03854adde09aab2"}], "stats": {"total": 89, "additions": 54, "deletions": 35}, "files": [{"sha": "ee4084f42daf0cca0987a5b91dee37e6f46c8592", "filename": "src/diagnostics.rs", "status": "modified", "additions": 54, "deletions": 35, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a1b823886c072dfda3e3fdd34e5661beaf57d6d7/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1b823886c072dfda3e3fdd34e5661beaf57d6d7/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=a1b823886c072dfda3e3fdd34e5661beaf57d6d7", "patch": "@@ -1,6 +1,7 @@\n-use rustc_mir::interpret::InterpErrorInfo;\n use std::cell::RefCell;\n \n+use rustc_span::DUMMY_SP;\n+\n use crate::*;\n \n /// Miri specific diagnostics\n@@ -14,62 +15,80 @@ pub fn report_diagnostic<'tcx, 'mir>(\n     ecx: &InterpCx<'mir, 'tcx, Evaluator<'tcx>>,\n     mut e: InterpErrorInfo<'tcx>,\n ) -> Option<i64> {\n-    // Special treatment for some error kinds\n+    use InterpError::*;\n+    let title = match e.kind {\n+        Unsupported(_) => \"unsupported operation\",\n+        UndefinedBehavior(_) => \"Undefined Behavior\",\n+        InvalidProgram(_) => bug!(\"This error should be impossible in Miri: {}\", e),\n+        ResourceExhaustion(_) => \"resource exhaustion\",\n+        MachineStop(_) => \"program stopped\",\n+    };\n     let msg = match e.kind {\n-        InterpError::MachineStop(ref info) => {\n+        MachineStop(ref info) => {\n             let info = info.downcast_ref::<TerminationInfo>().expect(\"invalid MachineStop payload\");\n             match info {\n                 TerminationInfo::Exit(code) => return Some(*code),\n                 TerminationInfo::Abort(None) => format!(\"the evaluated program aborted execution\"),\n                 TerminationInfo::Abort(Some(msg)) => format!(\"the evaluated program aborted execution: {}\", msg),\n             }\n         }\n-        err_unsup!(NoMirFor(..)) => format!(\n-            \"{}. Did you set `MIRI_SYSROOT` to a Miri-enabled sysroot? You can prepare one with `cargo miri setup`.\",\n-            e\n-        ),\n-        InterpError::InvalidProgram(_) => bug!(\"This error should be impossible in Miri: {}\", e),\n         _ => e.to_string(),\n     };\n+    let help = match e.kind {\n+        Unsupported(UnsupportedOpInfo::NoMirFor(..)) =>\n+            Some(\"set `MIRI_SYSROOT` to a Miri sysroot, which you can prepare with `cargo miri setup`\"),\n+        Unsupported(_) =>\n+            Some(\"this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\"),\n+        UndefinedBehavior(UndefinedBehaviorInfo::UbExperimental(_)) =>\n+            Some(\"this indicates a potential bug in the program: it violated *experimental* rules, and caused Undefined Behavior\"),\n+        UndefinedBehavior(_) =>\n+            Some(\"this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\"),\n+        _ => None,\n+    };\n     e.print_backtrace();\n-    report_msg(ecx, msg, true)\n+    report_msg(ecx, &format!(\"{}: {}\", title, msg), msg, help, true)\n }\n \n /// Report an error or note (depending on the `error` argument) at the current frame's current statement.\n /// Also emits a full stacktrace of the interpreter stack.\n pub fn report_msg<'tcx, 'mir>(\n     ecx: &InterpCx<'mir, 'tcx, Evaluator<'tcx>>,\n-    msg: String,\n+    title: &str,\n+    span_msg: String,\n+    help: Option<&str>,\n     error: bool,\n ) -> Option<i64> {\n-    if let Some(frame) = ecx.stack().last() {\n-        let span = frame.current_source_info().unwrap().span;\n-\n-        let mut err = if error {\n-            let msg = format!(\"Miri evaluation error: {}\", msg);\n-            ecx.tcx.sess.struct_span_err(span, msg.as_str())\n+    let span = if let Some(frame) = ecx.stack().last() {\n+        frame.current_source_info().unwrap().span\n+    } else {\n+        DUMMY_SP\n+    };\n+    let mut err = if error {\n+        ecx.tcx.sess.struct_span_err(span, title)\n+    } else {\n+        ecx.tcx.sess.diagnostic().span_note_diag(span, title)\n+    };\n+    err.span_label(span, span_msg);\n+    if let Some(help) = help {\n+        err.help(help);\n+    }\n+    // Add backtrace\n+    let frames = ecx.generate_stacktrace(None);\n+    // We iterate with indices because we need to look at the next frame (the caller).\n+    for idx in 0..frames.len() {\n+        let frame_info = &frames[idx];\n+        let call_site_is_local = frames\n+            .get(idx + 1)\n+            .map_or(false, |caller_info| caller_info.instance.def_id().is_local());\n+        if call_site_is_local {\n+            err.span_note(frame_info.call_site, &frame_info.to_string());\n         } else {\n-            ecx.tcx.sess.diagnostic().span_note_diag(span, msg.as_str())\n-        };\n-        let frames = ecx.generate_stacktrace(None);\n-        err.span_label(span, msg);\n-        // We iterate with indices because we need to look at the next frame (the caller).\n-        for idx in 0..frames.len() {\n-            let frame_info = &frames[idx];\n-            let call_site_is_local = frames\n-                .get(idx + 1)\n-                .map_or(false, |caller_info| caller_info.instance.def_id().is_local());\n-            if call_site_is_local {\n-                err.span_note(frame_info.call_site, &frame_info.to_string());\n-            } else {\n-                err.note(&frame_info.to_string());\n-            }\n+            err.note(&frame_info.to_string());\n         }\n-        err.emit();\n-    } else {\n-        ecx.tcx.sess.err(&msg);\n     }\n \n+    err.emit();\n+\n     for (i, frame) in ecx.stack().iter().enumerate() {\n         trace!(\"-------------------\");\n         trace!(\"Frame {}\", i);\n@@ -106,7 +125,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     CreatedAlloc(AllocId(id)) =>\n                         format!(\"created allocation with id {}\", id),\n                 };\n-                report_msg(this, msg, false);\n+                report_msg(this, \"tracking was triggered\", msg, None, false);\n             }\n         });\n     }"}]}