{"sha": "3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiOTNkNzFmZDIwMGQ1ZjJmMzlmMWM0YTdhNGIwOWNiMTlmZjY0YmU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-27T22:21:49Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-03-01T18:53:16Z"}, "message": "Handle type annotations in promoted MIR correctly\n\nType annotations are shared between the MIR of a function and the\npromoted constants for that function, so keep them in the type checker\nwhen we check the promoted MIR.", "tree": {"sha": "6d14e6d62da9300b9379c80f15e88c883e820de5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d14e6d62da9300b9379c80f15e88c883e820de5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be", "html_url": "https://github.com/rust-lang/rust/commit/3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "848c25207208d3ad71e6d4fd3719cc7dc725bdf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/848c25207208d3ad71e6d4fd3719cc7dc725bdf4", "html_url": "https://github.com/rust-lang/rust/commit/848c25207208d3ad71e6d4fd3719cc7dc725bdf4"}], "stats": {"total": 61, "additions": 46, "deletions": 15}, "files": [{"sha": "9fa3bf5524739ef17d97ba6a7782b2f56cbd2d45", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be", "patch": "@@ -39,7 +39,8 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, SubstsRef, UnpackedKind, UserSubsts};\n use rustc::ty::{\n     self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind, UserType,\n-    CanonicalUserTypeAnnotation, UserTypeAnnotationIndex,\n+    CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n+    UserTypeAnnotationIndex,\n };\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -283,7 +284,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 location.to_locations(),\n                 ConstraintCategory::Boring,\n             ) {\n-                let annotation = &self.mir.user_type_annotations[annotation_index];\n+                let annotation = &self.cx.user_type_annotations[annotation_index];\n                 span_mirbug!(\n                     self,\n                     constant,\n@@ -550,8 +551,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         // checker on the promoted MIR, then transfer the constraints back to\n         // the main MIR, changing the locations to the provided location.\n \n-        let main_mir = mem::replace(&mut self.mir, promoted_mir);\n-        self.cx.mir = promoted_mir;\n+        let parent_mir = mem::replace(&mut self.mir, promoted_mir);\n \n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n@@ -573,8 +573,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             self.cx.typeck_mir(promoted_mir);\n         }\n \n-        self.mir = main_mir;\n-        self.cx.mir = main_mir;\n+        self.mir = parent_mir;\n         // Merge the outlives constraints back in, at the given location.\n         if let Some(ref mut base_bcx) = self.cx.borrowck_context {\n             mem::swap(base_bcx.all_facts, all_facts);\n@@ -818,7 +817,9 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n     last_span: Span,\n-    mir: &'a Mir<'tcx>,\n+    /// User type annotations are shared between the main MIR and the MIR of\n+    /// all of the promoted items.\n+    user_type_annotations: &'a CanonicalUserTypeAnnotations<'tcx>,\n     mir_def_id: DefId,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n@@ -973,8 +974,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let mut checker = Self {\n             infcx,\n             last_span: DUMMY_SP,\n-            mir,\n             mir_def_id,\n+            user_type_annotations: &mir.user_type_annotations,\n             param_env,\n             region_bound_pairs,\n             implicit_region_bound,\n@@ -990,9 +991,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn check_user_type_annotations(&mut self) {\n         debug!(\n             \"check_user_type_annotations: user_type_annotations={:?}\",\n-             self.mir.user_type_annotations\n+             self.user_type_annotations\n         );\n-        for user_annotation in &self.mir.user_type_annotations {\n+        for user_annotation in self.user_type_annotations {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n             let (annotation, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n                 span, user_ty\n@@ -1175,7 +1176,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             a, v, user_ty, locations,\n         );\n \n-        let annotated_type = self.mir.user_type_annotations[user_ty.base].inferred_ty;\n+        let annotated_type = self.user_type_annotations[user_ty.base].inferred_ty;\n         let mut curr_projected_ty = PlaceTy::from_ty(annotated_type);\n \n         let tcx = self.infcx.tcx;\n@@ -1361,7 +1362,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         location.to_locations(),\n                         ConstraintCategory::Boring,\n                     ) {\n-                        let annotation = &mir.user_type_annotations[annotation_index];\n+                        let annotation = &self.user_type_annotations[annotation_index];\n                         span_mirbug!(\n                             self,\n                             stmt,\n@@ -1420,7 +1421,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     Locations::All(stmt.source_info.span),\n                     ConstraintCategory::TypeAnnotation,\n                 ) {\n-                    let annotation = &mir.user_type_annotations[projection.base];\n+                    let annotation = &self.user_type_annotations[projection.base];\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -2078,7 +2079,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n \n             Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n-                self.add_reborrow_constraint(location, region, borrowed_place);\n+                self.add_reborrow_constraint(mir, location, region, borrowed_place);\n             }\n \n             // FIXME: These other cases have to be implemented in future PRs\n@@ -2177,6 +2178,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     /// - `borrowed_place`: the place `P` being borrowed\n     fn add_reborrow_constraint(\n         &mut self,\n+        mir: &Mir<'tcx>,\n         location: Location,\n         borrow_region: ty::Region<'tcx>,\n         borrowed_place: &Place<'tcx>,\n@@ -2226,7 +2228,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             match *elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n+                    let base_ty = base.ty(mir, tcx).to_ty(tcx);\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {"}, {"sha": "fa2d2fb81183dc32ae7f3e322e2e8a70bd4c175e", "filename": "src/test/ui/nll/user-annotations/promoted-annotation.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpromoted-annotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpromoted-annotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpromoted-annotation.rs?ref=3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be", "patch": "@@ -0,0 +1,12 @@\n+// Test that type annotations are checked in promoted constants correctly.\n+\n+#![feature(nll)]\n+\n+fn foo<'a>() {\n+    let x = 0;\n+    let f = &drop::<&'a i32>;\n+    f(&x);\n+    //~^ ERROR `x` does not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "144af1e0ec120c8ee50828b895fcfbaada3d1519", "filename": "src/test/ui/nll/user-annotations/promoted-annotation.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpromoted-annotation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpromoted-annotation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpromoted-annotation.stderr?ref=3b93d71fd200d5f2f39f1c4a7a4b09cb19ff64be", "patch": "@@ -0,0 +1,17 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/promoted-annotation.rs:8:7\n+   |\n+LL | fn foo<'a>() {\n+   |        -- lifetime `'a` defined here\n+LL |     let x = 0;\n+LL |     let f = &drop::<&'a i32>;\n+   |             ---------------- assignment requires that `x` is borrowed for `'a`\n+LL |     f(&x);\n+   |       ^^ borrowed value does not live long enough\n+LL |     //~^ ERROR `x` does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}]}