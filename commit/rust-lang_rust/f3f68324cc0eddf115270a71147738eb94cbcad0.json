{"sha": "f3f68324cc0eddf115270a71147738eb94cbcad0", "node_id": "C_kwDOAAsO6NoAKGYzZjY4MzI0Y2MwZWRkZjExNTI3MGE3MTE0NzczOGViOTRjYmNhZDA", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-03-23T08:41:31Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-05-20T09:27:06Z"}, "message": "move unique param check into `rustc_middle`", "tree": {"sha": "bc477bde0a6f2c4d2567090240ac4152828fc213", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc477bde0a6f2c4d2567090240ac4152828fc213"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3f68324cc0eddf115270a71147738eb94cbcad0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f68324cc0eddf115270a71147738eb94cbcad0", "html_url": "https://github.com/rust-lang/rust/commit/f3f68324cc0eddf115270a71147738eb94cbcad0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3f68324cc0eddf115270a71147738eb94cbcad0/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52cc7795245347500ddf6dc959cf58a7abe2d935", "url": "https://api.github.com/repos/rust-lang/rust/commits/52cc7795245347500ddf6dc959cf58a7abe2d935", "html_url": "https://github.com/rust-lang/rust/commit/52cc7795245347500ddf6dc959cf58a7abe2d935"}], "stats": {"total": 177, "additions": 93, "deletions": 84}, "files": [{"sha": "bf066f65aeb12c164ef8dcae638845bb86c21033", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 87, "deletions": 32, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/f3f68324cc0eddf115270a71147738eb94cbcad0/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f68324cc0eddf115270a71147738eb94cbcad0/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=f3f68324cc0eddf115270a71147738eb94cbcad0", "patch": "@@ -5,10 +5,7 @@ use crate::ty::fold::{FallibleTypeFolder, TypeFolder};\n use crate::ty::layout::IntegerExt;\n use crate::ty::query::TyCtxtAt;\n use crate::ty::subst::{GenericArgKind, Subst, SubstsRef};\n-use crate::ty::{\n-    self, DebruijnIndex, DefIdTree, EarlyBinder, List, ReEarlyBound, Ty, TyCtxt, TyKind::*,\n-    TypeFoldable,\n-};\n+use crate::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::Float as _;\n use rustc_ast as ast;\n use rustc_attr::{self as attr, SignedInt, UnsignedInt};\n@@ -18,6 +15,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_index::bit_set::GrowableBitSet;\n use rustc_macros::HashStable;\n use rustc_span::{sym, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, TargetDataLayout};\n@@ -32,6 +30,12 @@ pub struct Discr<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum NotUniqueParam<'tcx> {\n+    DuplicateParam(ty::GenericArg<'tcx>),\n+    NotParam(ty::GenericArg<'tcx>),\n+}\n+\n impl<'tcx> fmt::Display for Discr<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self.ty.kind() {\n@@ -49,8 +53,8 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n \n fn int_size_and_signed<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> (Size, bool) {\n     let (int, signed) = match *ty.kind() {\n-        Int(ity) => (Integer::from_int_ty(&tcx, ity), true),\n-        Uint(uty) => (Integer::from_uint_ty(&tcx, uty), false),\n+        ty::Int(ity) => (Integer::from_int_ty(&tcx, ity), true),\n+        ty::Uint(uty) => (Integer::from_uint_ty(&tcx, uty), false),\n         _ => bug!(\"non integer discriminant\"),\n     };\n     (int.size(), signed)\n@@ -176,7 +180,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let ty::Adt(def, substs) = *ty.kind() {\n             for field in def.all_fields() {\n                 let field_ty = field.ty(self, substs);\n-                if let Error(_) = field_ty.kind() {\n+                if let ty::Error(_) = field_ty.kind() {\n                     return true;\n                 }\n             }\n@@ -311,7 +315,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let (mut a, mut b) = (source, target);\n         loop {\n             match (&a.kind(), &b.kind()) {\n-                (&Adt(a_def, a_substs), &Adt(b_def, b_substs))\n+                (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n                     if a_def == b_def && a_def.is_struct() =>\n                 {\n                     if let Some(f) = a_def.non_enum_variant().fields.last() {\n@@ -321,7 +325,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         break;\n                     }\n                 }\n-                (&Tuple(a_tys), &Tuple(b_tys)) if a_tys.len() == b_tys.len() => {\n+                (&ty::Tuple(a_tys), &ty::Tuple(b_tys)) if a_tys.len() == b_tys.len() => {\n                     if let Some(&a_last) = a_tys.last() {\n                         a = a_last;\n                         b = *b_tys.last().unwrap();\n@@ -427,7 +431,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             .filter(|&(_, k)| {\n                 match k.unpack() {\n                     GenericArgKind::Lifetime(region) => match region.kind() {\n-                        ReEarlyBound(ref ebr) => {\n+                        ty::ReEarlyBound(ref ebr) => {\n                             !impl_generics.region_param(ebr, self).pure_wrt_drop\n                         }\n                         // Error: not a region param\n@@ -453,6 +457,49 @@ impl<'tcx> TyCtxt<'tcx> {\n         result\n     }\n \n+    /// Checks whether each generic argument is simply a unique generic parameter.\n+    pub fn uses_unique_generic_params(\n+        self,\n+        substs: SubstsRef<'tcx>,\n+        ignore_regions: bool,\n+    ) -> Result<(), NotUniqueParam<'tcx>> {\n+        let mut seen = GrowableBitSet::default();\n+        for arg in substs {\n+            match arg.unpack() {\n+                GenericArgKind::Lifetime(lt) => {\n+                    if !ignore_regions {\n+                        match lt.kind() {\n+                            ty::ReEarlyBound(p) => {\n+                                if !seen.insert(p.index) {\n+                                    return Err(NotUniqueParam::DuplicateParam(lt.into()));\n+                                }\n+                            }\n+                            _ => return Err(NotUniqueParam::NotParam(lt.into())),\n+                        }\n+                    }\n+                }\n+                GenericArgKind::Type(t) => match t.kind() {\n+                    ty::Param(p) => {\n+                        if !seen.insert(p.index) {\n+                            return Err(NotUniqueParam::DuplicateParam(t.into()));\n+                        }\n+                    }\n+                    _ => return Err(NotUniqueParam::NotParam(t.into())),\n+                },\n+                GenericArgKind::Const(c) => match c.val() {\n+                    ty::ConstKind::Param(p) => {\n+                        if !seen.insert(p.index) {\n+                            return Err(NotUniqueParam::DuplicateParam(c.into()));\n+                        }\n+                    }\n+                    _ => return Err(NotUniqueParam::NotParam(c.into())),\n+                },\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     /// Returns `true` if `def_id` refers to a closure (e.g., `|x| x * 2`). Note\n     /// that closures have a `DefId`, but the closure *expression* also\n     /// has a `HirId` that is located within the context where the\n@@ -594,30 +641,33 @@ impl<'tcx> TyCtxt<'tcx> {\n         if visitor.found_recursion { Err(expanded_type) } else { Ok(expanded_type) }\n     }\n \n-    pub fn bound_type_of(self, def_id: DefId) -> EarlyBinder<Ty<'tcx>> {\n-        EarlyBinder(self.type_of(def_id))\n+    pub fn bound_type_of(self, def_id: DefId) -> ty::EarlyBinder<Ty<'tcx>> {\n+        ty::EarlyBinder(self.type_of(def_id))\n     }\n \n-    pub fn bound_fn_sig(self, def_id: DefId) -> EarlyBinder<ty::PolyFnSig<'tcx>> {\n-        EarlyBinder(self.fn_sig(def_id))\n+    pub fn bound_fn_sig(self, def_id: DefId) -> ty::EarlyBinder<ty::PolyFnSig<'tcx>> {\n+        ty::EarlyBinder(self.fn_sig(def_id))\n     }\n \n-    pub fn bound_impl_trait_ref(self, def_id: DefId) -> Option<EarlyBinder<ty::TraitRef<'tcx>>> {\n-        self.impl_trait_ref(def_id).map(|i| EarlyBinder(i))\n+    pub fn bound_impl_trait_ref(\n+        self,\n+        def_id: DefId,\n+    ) -> Option<ty::EarlyBinder<ty::TraitRef<'tcx>>> {\n+        self.impl_trait_ref(def_id).map(|i| ty::EarlyBinder(i))\n     }\n \n     pub fn bound_explicit_item_bounds(\n         self,\n         def_id: DefId,\n-    ) -> EarlyBinder<&'tcx [(ty::Predicate<'tcx>, rustc_span::Span)]> {\n-        EarlyBinder(self.explicit_item_bounds(def_id))\n+    ) -> ty::EarlyBinder<&'tcx [(ty::Predicate<'tcx>, rustc_span::Span)]> {\n+        ty::EarlyBinder(self.explicit_item_bounds(def_id))\n     }\n \n     pub fn bound_item_bounds(\n         self,\n         def_id: DefId,\n-    ) -> EarlyBinder<&'tcx ty::List<ty::Predicate<'tcx>>> {\n-        EarlyBinder(self.item_bounds(def_id))\n+    ) -> ty::EarlyBinder<&'tcx ty::List<ty::Predicate<'tcx>>> {\n+        ty::EarlyBinder(self.item_bounds(def_id))\n     }\n }\n \n@@ -930,35 +980,40 @@ impl<'tcx> Ty<'tcx> {\n     pub fn is_structural_eq_shallow(self, tcx: TyCtxt<'tcx>) -> bool {\n         match self.kind() {\n             // Look for an impl of both `PartialStructuralEq` and `StructuralEq`.\n-            Adt(..) => tcx.has_structural_eq_impls(self),\n+            ty::Adt(..) => tcx.has_structural_eq_impls(self),\n \n             // Primitive types that satisfy `Eq`.\n-            Bool | Char | Int(_) | Uint(_) | Str | Never => true,\n+            ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Str | ty::Never => true,\n \n             // Composite types that satisfy `Eq` when all of their fields do.\n             //\n             // Because this function is \"shallow\", we return `true` for these composites regardless\n             // of the type(s) contained within.\n-            Ref(..) | Array(..) | Slice(_) | Tuple(..) => true,\n+            ty::Ref(..) | ty::Array(..) | ty::Slice(_) | ty::Tuple(..) => true,\n \n             // Raw pointers use bitwise comparison.\n-            RawPtr(_) | FnPtr(_) => true,\n+            ty::RawPtr(_) | ty::FnPtr(_) => true,\n \n             // Floating point numbers are not `Eq`.\n-            Float(_) => false,\n+            ty::Float(_) => false,\n \n             // Conservatively return `false` for all others...\n \n             // Anonymous function types\n-            FnDef(..) | Closure(..) | Dynamic(..) | Generator(..) => false,\n+            ty::FnDef(..) | ty::Closure(..) | ty::Dynamic(..) | ty::Generator(..) => false,\n \n             // Generic or inferred types\n             //\n             // FIXME(ecstaticmorse): Maybe we should `bug` here? This should probably only be\n             // called for known, fully-monomorphized types.\n-            Projection(_) | Opaque(..) | Param(_) | Bound(..) | Placeholder(_) | Infer(_) => false,\n+            ty::Projection(_)\n+            | ty::Opaque(..)\n+            | ty::Param(_)\n+            | ty::Bound(..)\n+            | ty::Placeholder(_)\n+            | ty::Infer(_) => false,\n \n-            Foreign(_) | GeneratorWitness(..) | Error(_) => false,\n+            ty::Foreign(_) | ty::GeneratorWitness(..) | ty::Error(_) => false,\n         }\n     }\n \n@@ -974,13 +1029,13 @@ impl<'tcx> Ty<'tcx> {\n     /// - `&'a *const &'b u8 -> *const &'b u8`\n     pub fn peel_refs(self) -> Ty<'tcx> {\n         let mut ty = self;\n-        while let Ref(_, inner_ty, _) = ty.kind() {\n+        while let ty::Ref(_, inner_ty, _) = ty.kind() {\n             ty = *inner_ty;\n         }\n         ty\n     }\n \n-    pub fn outer_exclusive_binder(self) -> DebruijnIndex {\n+    pub fn outer_exclusive_binder(self) -> ty::DebruijnIndex {\n         self.0.outer_exclusive_binder\n     }\n }\n@@ -1177,8 +1232,8 @@ pub struct AlwaysRequiresDrop;\n /// with their underlying types.\n pub fn normalize_opaque_types<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    val: &'tcx List<ty::Predicate<'tcx>>,\n-) -> &'tcx List<ty::Predicate<'tcx>> {\n+    val: &'tcx ty::List<ty::Predicate<'tcx>>,\n+) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n     let mut visitor = OpaqueTypeExpander {\n         seen_opaque_tys: FxHashSet::default(),\n         expanded_cache: FxHashMap::default(),"}, {"sha": "ad8a84d536fed8c5d983fee3171205a29d7b12c3", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 6, "deletions": 52, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f3f68324cc0eddf115270a71147738eb94cbcad0/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f68324cc0eddf115270a71147738eb94cbcad0/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=f3f68324cc0eddf115270a71147738eb94cbcad0", "patch": "@@ -5,10 +5,9 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n-use rustc_index::bit_set::GrowableBitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n+use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, ImplPolarity, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_session::lint;\n use rustc_span::def_id::{DefId, LocalDefId};\n@@ -325,51 +324,6 @@ fn emit_orphan_check_error<'tcx>(\n     })\n }\n \n-#[derive(Default)]\n-struct AreUniqueParamsVisitor {\n-    seen: GrowableBitSet<u32>,\n-}\n-\n-#[derive(Copy, Clone)]\n-enum NotUniqueParam<'tcx> {\n-    DuplicateParam(GenericArg<'tcx>),\n-    NotParam(GenericArg<'tcx>),\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for AreUniqueParamsVisitor {\n-    type BreakTy = NotUniqueParam<'tcx>;\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match t.kind() {\n-            ty::Param(p) => {\n-                if self.seen.insert(p.index) {\n-                    ControlFlow::CONTINUE\n-                } else {\n-                    ControlFlow::Break(NotUniqueParam::DuplicateParam(t.into()))\n-                }\n-            }\n-            _ => ControlFlow::Break(NotUniqueParam::NotParam(t.into())),\n-        }\n-    }\n-    fn visit_region(&mut self, _: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        // We don't drop candidates during candidate assembly because of region\n-        // constraints, so the behavior for impls only constrained by regions\n-        // will not change.\n-        ControlFlow::CONTINUE\n-    }\n-    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match c.val() {\n-            ty::ConstKind::Param(p) => {\n-                if self.seen.insert(p.index) {\n-                    ControlFlow::CONTINUE\n-                } else {\n-                    ControlFlow::Break(NotUniqueParam::DuplicateParam(c.into()))\n-                }\n-            }\n-            _ => ControlFlow::Break(NotUniqueParam::NotParam(c.into())),\n-        }\n-    }\n-}\n-\n /// Lint impls of auto traits if they are likely to have\n /// unsound or surprising effects on auto impls.\n fn lint_auto_trait_impls(tcx: TyCtxt<'_>, trait_def_id: DefId, impls: &[LocalDefId]) {\n@@ -400,9 +354,9 @@ fn lint_auto_trait_impls(tcx: TyCtxt<'_>, trait_def_id: DefId, impls: &[LocalDef\n         // Impls which completely cover a given root type are fine as they\n         // disable auto impls entirely. So only lint if the substs\n         // are not a permutation of the identity substs.\n-        match substs.visit_with(&mut AreUniqueParamsVisitor::default()) {\n-            ControlFlow::Continue(()) => {} // ok\n-            ControlFlow::Break(arg) => {\n+        match tcx.uses_unique_generic_params(substs, true) {\n+            Ok(()) => {} // ok\n+            Err(arg) => {\n                 // Ideally:\n                 //\n                 // - compute the requirements for the auto impl candidate\n@@ -444,10 +398,10 @@ fn lint_auto_trait_impls(tcx: TyCtxt<'_>, trait_def_id: DefId, impls: &[LocalDef\n                     ),\n                 );\n                 match arg {\n-                    NotUniqueParam::DuplicateParam(arg) => {\n+                    ty::util::NotUniqueParam::DuplicateParam(arg) => {\n                         err.note(&format!(\"`{}` is mentioned multiple times\", arg));\n                     }\n-                    NotUniqueParam::NotParam(arg) => {\n+                    ty::util::NotUniqueParam::NotParam(arg) => {\n                         err.note(&format!(\"`{}` is not a generic parameter\", arg));\n                     }\n                 }"}]}