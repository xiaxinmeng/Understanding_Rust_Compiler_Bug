{"sha": "5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkOWY5NmFiMjc1YWY5NjRiNmM2MThmNmEzYmMzY2QxNjNiMzRkMjM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-04-04T12:40:35Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-05-30T17:47:00Z"}, "message": "Make resolutions a query.", "tree": {"sha": "c131a2c2d4e9afef59dca5c0f10431bff4a064a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c131a2c2d4e9afef59dca5c0f10431bff4a064a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "html_url": "https://github.com/rust-lang/rust/commit/5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "139f7ad637115f8013b6b38a5b591c0ffd3d0ad9", "url": "https://api.github.com/repos/rust-lang/rust/commits/139f7ad637115f8013b6b38a5b591c0ffd3d0ad9", "html_url": "https://github.com/rust-lang/rust/commit/139f7ad637115f8013b6b38a5b591c0ffd3d0ad9"}], "stats": {"total": 221, "additions": 120, "deletions": 101}, "files": [{"sha": "d5275c399455e7adb900384a61fd49455e23c012", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -25,7 +25,7 @@ use tracing::debug;\n /// Internally the `DefPathTable` holds a tree of `DefKey`s, where each `DefKey`\n /// stores the `DefIndex` of its parent.\n /// There is one `DefPathTable` for each crate.\n-#[derive(Clone, Default)]\n+#[derive(Clone, Default, Debug)]\n pub struct DefPathTable {\n     index_to_key: IndexVec<DefIndex, DefKey>,\n     def_path_hashes: IndexVec<DefIndex, DefPathHash>,\n@@ -107,7 +107,7 @@ impl DefPathTable {\n /// The definition table containing node definitions.\n /// It holds the `DefPathTable` for `LocalDefId`s/`DefPath`s.\n /// It also stores mappings to convert `LocalDefId`s to/from `HirId`s.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct Definitions {\n     table: DefPathTable,\n "}, {"sha": "e336dc114b736c1e00873616e44778bceba3c44b", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -51,6 +51,12 @@ pub struct CStore {\n     unused_externs: Vec<Symbol>,\n }\n \n+impl std::fmt::Debug for CStore {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"CStore\").finish_non_exhaustive()\n+    }\n+}\n+\n pub struct CrateLoader<'a> {\n     // Immutable configuration.\n     sess: &'a Session,"}, {"sha": "8476929eaeced2b1d230e5e6f6d964e2e7d2a088", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -285,7 +285,7 @@ pub type DepNode = rustc_query_system::dep_graph::DepNode<DepKind>;\n // required that their size stay the same, but we don't want to change\n // it inadvertently. This assert just ensures we're aware of any change.\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-static_assert_size!(DepNode, 17);\n+static_assert_size!(DepNode, 18);\n \n #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n static_assert_size!(DepNode, 24);"}, {"sha": "7e13d42459dc7cc207d641332144d853b4539b9b", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -156,19 +156,22 @@ impl<'hir> Map<'hir> {\n \n     #[inline]\n     pub fn definitions(&self) -> &'hir Definitions {\n-        &self.tcx.definitions\n+        // Accessing the definitions is ok, since all its contents are tracked by the query system.\n+        &self.tcx.untracked_resolutions.definitions\n     }\n \n     pub fn def_key(&self, def_id: LocalDefId) -> DefKey {\n-        self.tcx.definitions.def_key(def_id)\n+        // Accessing the definitions is ok, since all its contents are tracked by the query system.\n+        self.tcx.untracked_resolutions.definitions.def_key(def_id)\n     }\n \n     pub fn def_path_from_hir_id(&self, id: HirId) -> Option<DefPath> {\n         self.opt_local_def_id(id).map(|def_id| self.def_path(def_id))\n     }\n \n     pub fn def_path(&self, def_id: LocalDefId) -> DefPath {\n-        self.tcx.definitions.def_path(def_id)\n+        // Accessing the definitions is ok, since all its contents are tracked by the query system.\n+        self.tcx.untracked_resolutions.definitions.def_path(def_id)\n     }\n \n     #[inline]\n@@ -184,16 +187,19 @@ impl<'hir> Map<'hir> {\n \n     #[inline]\n     pub fn opt_local_def_id(&self, hir_id: HirId) -> Option<LocalDefId> {\n-        self.tcx.definitions.opt_hir_id_to_local_def_id(hir_id)\n+        // Accessing the definitions is ok, since all its contents are tracked by the query system.\n+        self.tcx.untracked_resolutions.definitions.opt_hir_id_to_local_def_id(hir_id)\n     }\n \n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n-        self.tcx.definitions.local_def_id_to_hir_id(def_id)\n+        // Accessing the definitions is ok, since all its contents are tracked by the query system.\n+        self.tcx.untracked_resolutions.definitions.local_def_id_to_hir_id(def_id)\n     }\n \n     pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n-        self.tcx.definitions.iter_local_def_id()\n+        // Accessing the definitions is ok, since all its contents are tracked by the query system.\n+        self.tcx.untracked_resolutions.definitions.iter_local_def_id()\n     }\n \n     pub fn opt_def_kind(&self, local_def_id: LocalDefId) -> Option<DefKind> {\n@@ -932,9 +938,15 @@ impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx IndexedHir<'tcx> {\n     let _prof_timer = tcx.sess.prof.generic_activity(\"build_hir_map\");\n \n+    // We can access untracked state since we are an eval_always query.\n     let hcx = tcx.create_stable_hashing_context();\n-    let mut collector =\n-        NodeCollector::root(tcx.sess, &**tcx.arena, tcx.untracked_crate, &tcx.definitions, hcx);\n+    let mut collector = NodeCollector::root(\n+        tcx.sess,\n+        &**tcx.arena,\n+        tcx.untracked_crate,\n+        &tcx.untracked_resolutions.definitions,\n+        hcx,\n+    );\n     intravisit::walk_crate(&mut collector, tcx.untracked_crate);\n \n     let map = collector.finalize_and_compute_crate_hash();\n@@ -944,14 +956,15 @@ pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx IndexedHir<'tc\n pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n+    // We can access untracked state since we are an eval_always query.\n     let mut hcx = tcx.create_stable_hashing_context();\n \n     let mut hir_body_nodes: Vec<_> = tcx\n         .index_hir(())\n         .map\n         .iter_enumerated()\n         .filter_map(|(def_id, hod)| {\n-            let def_path_hash = tcx.definitions.def_path_hash(def_id);\n+            let def_path_hash = tcx.untracked_resolutions.definitions.def_path_hash(def_id);\n             let mut hasher = StableHasher::new();\n             hod.with_bodies.as_ref()?.hash_stable(&mut hcx, &mut hasher);\n             AttributeMap { map: &tcx.untracked_crate.attrs, prefix: def_id }\n@@ -968,7 +981,7 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n         },\n     );\n \n-    let upstream_crates = upstream_crates(&*tcx.cstore);\n+    let upstream_crates = upstream_crates(&*tcx.untracked_resolutions.cstore);\n \n     // We hash the final, remapped names of all local source files so we\n     // don't have to include the path prefix remapping commandline args."}, {"sha": "d01e3f784f594bd4a9ea3e38672e278c0674a99c", "filename": "compiler/rustc_middle/src/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -182,7 +182,7 @@ pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n /// that it's *not* tracked for dependency information throughout compilation\n /// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n /// during resolve)\n-pub trait CrateStore {\n+pub trait CrateStore: std::fmt::Debug {\n     fn as_any(&self) -> &dyn Any;\n \n     // resolve"}, {"sha": "b67496b09f2ef2df4e27543f91cd9c392af1c284", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -14,6 +14,12 @@ rustc_queries! {\n         desc { \"trigger a delay span bug\" }\n     }\n \n+    query resolutions(_: ()) -> &'tcx ty::ResolverOutputs {\n+        eval_always\n+        no_hash\n+        desc { \"get the resolver outputs\" }\n+    }\n+\n     /// Represents crate as a whole (as distinct from the top-level crate module).\n     /// If you call `hir_crate` (e.g., indirectly by calling `tcx.hir().krate()`),\n     /// we will have to assume that any change means that you need to be recompiled.\n@@ -1133,7 +1139,6 @@ rustc_queries! {\n \n     query module_exports(def_id: LocalDefId) -> Option<&'tcx [Export<LocalDefId>]> {\n         desc { |tcx| \"looking up items exported by `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n-        eval_always\n     }\n \n     query impl_defaultness(def_id: DefId) -> hir::Defaultness {\n@@ -1327,7 +1332,6 @@ rustc_queries! {\n     }\n \n     query visibility(def_id: DefId) -> ty::Visibility {\n-        eval_always\n         desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n     }\n \n@@ -1352,8 +1356,6 @@ rustc_queries! {\n         desc { |tcx| \"collecting child items of `{}`\", tcx.def_path_str(def_id) }\n     }\n     query extern_mod_stmt_cnum(def_id: LocalDefId) -> Option<CrateNum> {\n-        // This depends on untracked global state (`tcx.extern_crate_map`)\n-        eval_always\n         desc { |tcx| \"computing crate imported by `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n \n@@ -1420,16 +1422,12 @@ rustc_queries! {\n         eval_always\n     }\n     query maybe_unused_trait_import(def_id: LocalDefId) -> bool {\n-        eval_always\n         desc { |tcx| \"maybe_unused_trait_import for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n     query maybe_unused_extern_crates(_: ()) -> &'tcx [(LocalDefId, Span)] {\n-        eval_always\n         desc { \"looking up all possibly unused extern crates\" }\n     }\n-    query names_imported_by_glob_use(def_id: LocalDefId)\n-        -> &'tcx FxHashSet<Symbol> {\n-        eval_always\n+    query names_imported_by_glob_use(def_id: LocalDefId) -> &'tcx FxHashSet<Symbol> {\n         desc { |tcx| \"names_imported_by_glob_use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n \n@@ -1439,7 +1437,6 @@ rustc_queries! {\n         desc { \"calculating the stability index for the local crate\" }\n     }\n     query all_crate_nums(_: ()) -> &'tcx [CrateNum] {\n-        eval_always\n         desc { \"fetching all foreign CrateNum instances\" }\n     }\n "}, {"sha": "4ebe5c02966eebcecbf1bcc0d63cef7aa0858b0e", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 52, "deletions": 59, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -2,13 +2,12 @@\n \n use crate::arena::Arena;\n use crate::dep_graph::DepGraph;\n-use crate::hir::exports::ExportMap;\n use crate::hir::place::Place as HirPlace;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n use crate::middle;\n-use crate::middle::cstore::{CrateStoreDyn, EncodedMetadata};\n+use crate::middle::cstore::EncodedMetadata;\n use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath, ObjectLifetimeDefault};\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n@@ -21,9 +20,9 @@ use crate::ty::TyKind::*;\n use crate::ty::{\n     self, AdtDef, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig, Const, ConstVid,\n     DefIdTree, ExistentialPredicate, FloatTy, FloatVar, FloatVid, GenericParamDefKind, InferConst,\n-    InferTy, IntTy, IntVar, IntVid, List, MainDefinition, ParamConst, ParamTy, PolyFnSig,\n-    Predicate, PredicateInner, PredicateKind, ProjectionTy, Region, RegionKind, ReprOptions,\n-    TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut, UintTy, Visibility,\n+    InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate,\n+    PredicateInner, PredicateKind, ProjectionTy, Region, RegionKind, ReprOptions,\n+    TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut, UintTy,\n };\n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -38,7 +37,6 @@ use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::definitions::Definitions;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n@@ -937,8 +935,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     interners: CtxtInterners<'tcx>,\n \n-    pub(crate) cstore: Box<CrateStoreDyn>,\n-\n     pub sess: &'tcx Session,\n \n     /// This only ever stores a `LintStore` but we don't want a dependency on that type here.\n@@ -960,17 +956,10 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common consts, pre-interned for your convenience.\n     pub consts: CommonConsts<'tcx>,\n \n-    /// Visibilities produced by resolver.\n-    pub visibilities: FxHashMap<LocalDefId, Visibility>,\n-\n-    /// Resolutions of `extern crate` items produced by resolver.\n-    extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n-\n-    /// Export map produced by name resolution.\n-    export_map: ExportMap<LocalDefId>,\n+    /// Output of the resolver.\n+    pub(crate) untracked_resolutions: ty::ResolverOutputs,\n \n     pub(crate) untracked_crate: &'tcx hir::Crate<'tcx>,\n-    pub(crate) definitions: Definitions,\n \n     /// This provides access to the incremental compilation on-disk cache for query results.\n     /// Do not access this directly. It is only meant to be used by\n@@ -981,15 +970,6 @@ pub struct GlobalCtxt<'tcx> {\n     pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n     pub query_caches: query::QueryCaches<'tcx>,\n \n-    maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n-    maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n-    /// A map of glob use to a set of names it actually imports. Currently only\n-    /// used in save-analysis.\n-    pub(crate) glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,\n-    /// Extern prelude entries. The value is `true` if the entry was introduced\n-    /// via `extern crate` item and not `--extern` option or compiler built-in.\n-    pub extern_prelude: FxHashMap<Symbol, bool>,\n-\n     // Internal caches for metadata decoding. No need to track deps on this.\n     pub ty_rcache: Lock<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n     pub pred_rcache: Lock<FxHashMap<ty::CReaderCacheKey, Predicate<'tcx>>>,\n@@ -1022,8 +1002,6 @@ pub struct GlobalCtxt<'tcx> {\n     layout_interner: ShardedHashMap<&'tcx Layout, ()>,\n \n     output_filenames: Arc<OutputFilenames>,\n-\n-    pub main_def: Option<MainDefinition>,\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -1144,28 +1122,19 @@ impl<'tcx> TyCtxt<'tcx> {\n         let common_types = CommonTypes::new(&interners);\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n-        let cstore = resolutions.cstore;\n \n         GlobalCtxt {\n             sess: s,\n             lint_store,\n-            cstore,\n             arena,\n             interners,\n             dep_graph,\n+            untracked_resolutions: resolutions,\n             prof: s.prof.clone(),\n             types: common_types,\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n-            visibilities: resolutions.visibilities,\n-            extern_crate_map: resolutions.extern_crate_map,\n-            export_map: resolutions.export_map,\n-            maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n-            maybe_unused_extern_crates: resolutions.maybe_unused_extern_crates,\n-            glob_map: resolutions.glob_map,\n-            extern_prelude: resolutions.extern_prelude,\n             untracked_crate: krate,\n-            definitions: resolutions.definitions,\n             on_disk_cache,\n             queries,\n             query_caches: query::QueryCaches::default(),\n@@ -1180,7 +1149,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             const_stability_interner: Default::default(),\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n             output_filenames: Arc::new(output_filenames.clone()),\n-            main_def: resolutions.main_def,\n         }\n     }\n \n@@ -1240,15 +1208,20 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn allocator_kind(self) -> Option<AllocatorKind> {\n-        self.cstore.allocator_kind()\n+        self.untracked_resolutions.cstore.allocator_kind()\n     }\n \n     pub fn features(self) -> &'tcx rustc_feature::Features {\n         self.features_query(())\n     }\n \n     pub fn def_key(self, id: DefId) -> rustc_hir::definitions::DefKey {\n-        if let Some(id) = id.as_local() { self.hir().def_key(id) } else { self.cstore.def_key(id) }\n+        // Accessing the definitions is ok, since all its contents are tracked by the query system.\n+        if let Some(id) = id.as_local() {\n+            self.hir().def_key(id)\n+        } else {\n+            self.untracked_resolutions.cstore.def_key(id)\n+        }\n     }\n \n     /// Converts a `DefId` into its fully expanded `DefPath` (every\n@@ -1257,25 +1230,31 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Note that if `id` is not local to this crate, the result will\n     ///  be a non-local `DefPath`.\n     pub fn def_path(self, id: DefId) -> rustc_hir::definitions::DefPath {\n+        // Accessing the definitions is ok, since all its contents are tracked by the query system.\n         if let Some(id) = id.as_local() {\n             self.hir().def_path(id)\n         } else {\n-            self.cstore.def_path(id)\n+            self.untracked_resolutions.cstore.def_path(id)\n         }\n     }\n \n     /// Returns whether or not the crate with CrateNum 'cnum'\n     /// is marked as a private dependency\n     pub fn is_private_dep(self, cnum: CrateNum) -> bool {\n-        if cnum == LOCAL_CRATE { false } else { self.cstore.crate_is_private_dep_untracked(cnum) }\n+        if cnum == LOCAL_CRATE {\n+            false\n+        } else {\n+            self.untracked_resolutions.cstore.crate_is_private_dep_untracked(cnum)\n+        }\n     }\n \n     #[inline]\n     pub fn def_path_hash(self, def_id: DefId) -> rustc_hir::definitions::DefPathHash {\n+        // Accessing the definitions is ok, since all its contents are tracked by the query system.\n         if let Some(def_id) = def_id.as_local() {\n-            self.definitions.def_path_hash(def_id)\n+            self.untracked_resolutions.definitions.def_path_hash(def_id)\n         } else {\n-            self.cstore.def_path_hash(def_id)\n+            self.untracked_resolutions.cstore.def_path_hash(def_id)\n         }\n     }\n \n@@ -1287,9 +1266,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         let (crate_name, stable_crate_id) = if def_id.is_local() {\n             (self.crate_name, self.sess.local_stable_crate_id())\n         } else {\n+            let cstore = &self.untracked_resolutions.cstore;\n             (\n-                self.cstore.crate_name_untracked(def_id.krate),\n-                self.def_path_hash(def_id.krate.as_def_id()).stable_crate_id(),\n+                cstore.crate_name_untracked(def_id.krate),\n+                cstore.stable_crate_id_untracked(def_id.krate),\n             )\n         };\n \n@@ -1304,32 +1284,39 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn metadata_encoding_version(self) -> Vec<u8> {\n-        self.cstore.metadata_encoding_version().to_vec()\n+        self.untracked_resolutions.cstore.metadata_encoding_version().to_vec()\n     }\n \n     pub fn encode_metadata(self) -> EncodedMetadata {\n         let _prof_timer = self.prof.verbose_generic_activity(\"generate_crate_metadata\");\n-        self.cstore.encode_metadata(self)\n+        self.untracked_resolutions.cstore.encode_metadata(self)\n     }\n \n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n     pub fn cstore_as_any(self) -> &'tcx dyn Any {\n-        self.cstore.as_any()\n+        self.untracked_resolutions.cstore.as_any()\n     }\n \n     #[inline(always)]\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n         let krate = self.gcx.untracked_crate;\n+        let resolutions = &self.gcx.untracked_resolutions;\n \n-        StableHashingContext::new(self.sess, krate, &self.definitions, &*self.cstore)\n+        StableHashingContext::new(self.sess, krate, &resolutions.definitions, &*resolutions.cstore)\n     }\n \n     #[inline(always)]\n     pub fn create_no_span_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n         let krate = self.gcx.untracked_crate;\n+        let resolutions = &self.gcx.untracked_resolutions;\n \n-        StableHashingContext::ignore_spans(self.sess, krate, &self.definitions, &*self.cstore)\n+        StableHashingContext::ignore_spans(\n+            self.sess,\n+            krate,\n+            &resolutions.definitions,\n+            &*resolutions.cstore,\n+        )\n     }\n \n     pub fn serialize_query_result_cache(self, encoder: &mut FileEncoder) -> FileEncodeResult {\n@@ -2783,15 +2770,19 @@ fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     providers.in_scope_traits_map = |tcx, id| tcx.hir_crate(()).trait_map.get(&id);\n-    providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).map(|v| &v[..]);\n+    providers.resolutions = |tcx, ()| &tcx.untracked_resolutions;\n+    providers.module_exports = |tcx, id| tcx.resolutions(()).export_map.get(&id).map(|v| &v[..]);\n     providers.crate_name = |tcx, id| {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.crate_name\n     };\n-    providers.maybe_unused_trait_import = |tcx, id| tcx.maybe_unused_trait_imports.contains(&id);\n-    providers.maybe_unused_extern_crates = |tcx, ()| &tcx.maybe_unused_extern_crates[..];\n-    providers.names_imported_by_glob_use =\n-        |tcx, id| tcx.arena.alloc(tcx.glob_map.get(&id).cloned().unwrap_or_default());\n+    providers.maybe_unused_trait_import =\n+        |tcx, id| tcx.resolutions(()).maybe_unused_trait_imports.contains(&id);\n+    providers.maybe_unused_extern_crates =\n+        |tcx, ()| &tcx.resolutions(()).maybe_unused_extern_crates[..];\n+    providers.names_imported_by_glob_use = |tcx, id| {\n+        tcx.arena.alloc(tcx.resolutions(()).glob_map.get(&id).cloned().unwrap_or_default())\n+    };\n \n     providers.lookup_stability = |tcx, id| {\n         let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n@@ -2805,8 +2796,10 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n         tcx.stability().local_deprecation_entry(id)\n     };\n-    providers.extern_mod_stmt_cnum = |tcx, id| tcx.extern_crate_map.get(&id).cloned();\n-    providers.all_crate_nums = |tcx, ()| tcx.arena.alloc_slice(&tcx.cstore.crates_untracked());\n+    providers.extern_mod_stmt_cnum =\n+        |tcx, id| tcx.resolutions(()).extern_crate_map.get(&id).cloned();\n+    providers.all_crate_nums =\n+        |tcx, ()| tcx.arena.alloc_slice(&tcx.resolutions(()).cstore.crates_untracked());\n     providers.output_filenames = |tcx, ()| tcx.output_filenames.clone();\n     providers.features_query = |tcx, ()| tcx.sess.features_untracked();\n     providers.is_panic_runtime = |tcx, cnum| {"}, {"sha": "85983edb24c033a0899a8890e29a20e374975f90", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -112,6 +112,7 @@ mod sty;\n \n // Data types\n \n+#[derive(Debug)]\n pub struct ResolverOutputs {\n     pub definitions: rustc_hir::definitions::Definitions,\n     pub cstore: Box<CrateStoreDyn>,\n@@ -127,7 +128,7 @@ pub struct ResolverOutputs {\n     pub main_def: Option<MainDefinition>,\n }\n \n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n pub struct MainDefinition {\n     pub res: Res<ast::NodeId>,\n     pub is_import: bool,"}, {"sha": "674182686d5b391583662aee1298aa9b7b5c0316", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -2313,7 +2313,7 @@ fn trimmed_def_paths(tcx: TyCtxt<'_>, (): ()) -> FxHashMap<DefId, Symbol> {\n     let unique_symbols_rev: &mut FxHashMap<(Namespace, Symbol), Option<DefId>> =\n         &mut FxHashMap::default();\n \n-    for symbol_set in tcx.glob_map.values() {\n+    for symbol_set in tcx.resolutions(()).glob_map.values() {\n         for symbol in symbol_set {\n             unique_symbols_rev.insert((Namespace::TypeNS, *symbol), None);\n             unique_symbols_rev.insert((Namespace::ValueNS, *symbol), None);"}, {"sha": "f0edf818d48a982434f608f324b732ec01169432", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -641,7 +641,11 @@ impl<'sess> OnDiskCache<'sess> {\n                 debug_assert_ne!(krate, LOCAL_CRATE);\n                 // Try to find a definition in the current session, using the previous `DefIndex`\n                 // as an initial guess.\n-                let opt_def_id = tcx.cstore.def_path_hash_to_def_id(krate, raw_def_id.index, hash);\n+                let opt_def_id = tcx.untracked_resolutions.cstore.def_path_hash_to_def_id(\n+                    krate,\n+                    raw_def_id.index,\n+                    hash,\n+                );\n                 debug!(\"def_path_to_def_id({:?}): opt_def_id = {:?}\", hash, opt_def_id);\n                 e.insert(opt_def_id);\n                 opt_def_id"}, {"sha": "781a5fe4783415338864bb6fa99396d5e5510e3b", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -147,19 +147,22 @@ fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(De\n         Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Start))\n     } else if let Some((hir_id, _)) = visitor.attr_main_fn {\n         Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Main))\n-    } else if let Some(def_id) = tcx.main_def.and_then(|main_def| main_def.opt_fn_def_id()) {\n-        if tcx.main_def.unwrap().is_import && !tcx.features().imported_main {\n-            let span = tcx.main_def.unwrap().span;\n-            feature_err(\n-                &tcx.sess.parse_sess,\n-                sym::imported_main,\n-                span,\n-                \"using an imported function as entry point `main` is experimental\",\n-            )\n-            .emit();\n-        }\n-        Some((def_id, EntryFnType::Main))\n     } else {\n+        if let Some(main_def) = tcx.resolutions(()).main_def {\n+            if let Some(def_id) = main_def.opt_fn_def_id() {\n+                if main_def.is_import && !tcx.features().imported_main {\n+                    let span = main_def.span;\n+                    feature_err(\n+                        &tcx.sess.parse_sess,\n+                        sym::imported_main,\n+                        span,\n+                        \"using an imported function as entry point `main` is experimental\",\n+                    )\n+                    .emit();\n+                }\n+                return Some((def_id, EntryFnType::Main));\n+            }\n+        }\n         no_main_err(tcx, visitor);\n         None\n     }\n@@ -209,7 +212,7 @@ fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) {\n         err.note(&note);\n     }\n \n-    if let Some(main_def) = tcx.main_def {\n+    if let Some(main_def) = tcx.resolutions(()).main_def {\n         if main_def.opt_fn_def_id().is_none() {\n             // There is something at `crate::main`, but it is not a function definition.\n             err.span_label(main_def.span, &format!(\"non-function item at `crate::main` is found\"));"}, {"sha": "54ad9182354f673ba656813cfa70e84e560043ae", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -2030,7 +2030,7 @@ pub fn provide(providers: &mut Providers) {\n \n fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility {\n     let def_id = def_id.expect_local();\n-    match tcx.visibilities.get(&def_id) {\n+    match tcx.resolutions(()).visibilities.get(&def_id) {\n         Some(vis) => *vis,\n         None => {\n             let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);"}, {"sha": "7e5cc771b3199a20ee75774b7f6f53a2858f916d", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9f96ab275af964b6c618f6a3bc3cd163b34d23/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=5d9f96ab275af964b6c618f6a3bc3cd163b34d23", "patch": "@@ -116,6 +116,8 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n         crates_to_lint: &mut crates_to_lint,\n     });\n \n+    let extern_prelude = &tcx.resolutions(()).extern_prelude;\n+\n     for extern_crate in &crates_to_lint {\n         let def_id = extern_crate.def_id.expect_local();\n         let id = tcx.hir().local_def_id_to_hir_id(def_id);\n@@ -155,7 +157,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n         // If the extern crate isn't in the extern prelude,\n         // there is no way it can be written as an `use`.\n         let orig_name = extern_crate.orig_name.unwrap_or(item.ident.name);\n-        if !tcx.extern_prelude.get(&orig_name).map_or(false, |from_item| !from_item) {\n+        if !extern_prelude.get(&orig_name).map_or(false, |from_item| !from_item) {\n             continue;\n         }\n "}]}