{"sha": "e0e18cc2a78334b148b8dd4a75bb3a2c2a307556", "node_id": "C_kwDOAAsO6NoAKGUwZTE4Y2MyYTc4MzM0YjE0OGI4ZGQ0YTc1YmIzYTJjMmEzMDc1NTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T07:47:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T07:47:53Z"}, "message": "Auto merge of #13151 - ChayimFriedman2:replace-turbofish-other-type, r=Veykril\n\nUse correct type in \"Replace turbofish with type\"\n\nAnd support `?` and `.await` expressions.\n\nFixes #13148.\n\nThe assist can still show up even if the turbofish's type is not used at all, e.g.:\n```rust\nfn foo<T>() {}\nlet v = foo::<i32>();\n```", "tree": {"sha": "81ee1c62f78f94be3c078b883764ed01ddc3ff7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81ee1c62f78f94be3c078b883764ed01ddc3ff7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0e18cc2a78334b148b8dd4a75bb3a2c2a307556", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0e18cc2a78334b148b8dd4a75bb3a2c2a307556", "html_url": "https://github.com/rust-lang/rust/commit/e0e18cc2a78334b148b8dd4a75bb3a2c2a307556", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0e18cc2a78334b148b8dd4a75bb3a2c2a307556/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "989b09d20cafc2b1eb9198e25701b9e2234d8ba0", "url": "https://api.github.com/repos/rust-lang/rust/commits/989b09d20cafc2b1eb9198e25701b9e2234d8ba0", "html_url": "https://github.com/rust-lang/rust/commit/989b09d20cafc2b1eb9198e25701b9e2234d8ba0"}, {"sha": "bcdacfe50182089772f6e454ecb0904392dfcc21", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcdacfe50182089772f6e454ecb0904392dfcc21", "html_url": "https://github.com/rust-lang/rust/commit/bcdacfe50182089772f6e454ecb0904392dfcc21"}], "stats": {"total": 160, "additions": 141, "deletions": 19}, "files": [{"sha": "521447c26dfbed01d20ac10592fd127a286f16ec", "filename": "crates/ide-assists/src/handlers/replace_turbofish_with_explicit_type.rs", "status": "modified", "additions": 141, "deletions": 19, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/e0e18cc2a78334b148b8dd4a75bb3a2c2a307556/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e18cc2a78334b148b8dd4a75bb3a2c2a307556/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs?ref=e0e18cc2a78334b148b8dd4a75bb3a2c2a307556", "patch": "@@ -1,5 +1,6 @@\n+use hir::HirDisplay;\n use syntax::{\n-    ast::{Expr, GenericArg},\n+    ast::{Expr, GenericArg, GenericArgList},\n     ast::{LetStmt, Type::InferType},\n     AstNode, TextRange,\n };\n@@ -34,21 +35,7 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n \n     let initializer = let_stmt.initializer()?;\n \n-    let generic_args = match &initializer {\n-        Expr::MethodCallExpr(ce) => ce.generic_arg_list()?,\n-        Expr::CallExpr(ce) => {\n-            if let Expr::PathExpr(pe) = ce.expr()? {\n-                pe.path()?.segment()?.generic_arg_list()?\n-            } else {\n-                cov_mark::hit!(not_applicable_if_non_path_function_call);\n-                return None;\n-            }\n-        }\n-        _ => {\n-            cov_mark::hit!(not_applicable_if_non_function_call_initializer);\n-            return None;\n-        }\n-    };\n+    let generic_args = generic_arg_list(&initializer)?;\n \n     // Find range of ::<_>\n     let colon2 = generic_args.coloncolon_token()?;\n@@ -65,7 +52,16 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n \n     // An improvement would be to check that this is correctly part of the return value of the\n     // function call, or sub in the actual return type.\n-    let turbofish_type = &turbofish_args[0];\n+    let returned_type = match ctx.sema.type_of_expr(&initializer) {\n+        Some(returned_type) if !returned_type.original.contains_unknown() => {\n+            let module = ctx.sema.scope(let_stmt.syntax())?.module();\n+            returned_type.original.display_source_code(ctx.db(), module.into()).ok()?\n+        }\n+        _ => {\n+            cov_mark::hit!(fallback_to_turbofish_type_if_type_info_not_available);\n+            turbofish_args[0].to_string()\n+        }\n+    };\n \n     let initializer_start = initializer.syntax().text_range().start();\n     if ctx.offset() > turbofish_range.end() || ctx.offset() < initializer_start {\n@@ -83,7 +79,7 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n             \"Replace turbofish with explicit type\",\n             TextRange::new(initializer_start, turbofish_range.end()),\n             |builder| {\n-                builder.insert(ident_range.end(), format!(\": {}\", turbofish_type));\n+                builder.insert(ident_range.end(), format!(\": {}\", returned_type));\n                 builder.delete(turbofish_range);\n             },\n         );\n@@ -98,7 +94,7 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n             \"Replace `_` with turbofish type\",\n             turbofish_range,\n             |builder| {\n-                builder.replace(underscore_range, turbofish_type.to_string());\n+                builder.replace(underscore_range, returned_type);\n                 builder.delete(turbofish_range);\n             },\n         );\n@@ -107,6 +103,26 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n     None\n }\n \n+fn generic_arg_list(expr: &Expr) -> Option<GenericArgList> {\n+    match expr {\n+        Expr::MethodCallExpr(expr) => expr.generic_arg_list(),\n+        Expr::CallExpr(expr) => {\n+            if let Expr::PathExpr(pe) = expr.expr()? {\n+                pe.path()?.segment()?.generic_arg_list()\n+            } else {\n+                cov_mark::hit!(not_applicable_if_non_path_function_call);\n+                return None;\n+            }\n+        }\n+        Expr::AwaitExpr(expr) => generic_arg_list(&expr.expr()?),\n+        Expr::TryExpr(expr) => generic_arg_list(&expr.expr()?),\n+        _ => {\n+            cov_mark::hit!(not_applicable_if_non_function_call_initializer);\n+            None\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -115,6 +131,7 @@ mod tests {\n \n     #[test]\n     fn replaces_turbofish_for_vec_string() {\n+        cov_mark::check!(fallback_to_turbofish_type_if_type_info_not_available);\n         check_assist(\n             replace_turbofish_with_explicit_type,\n             r#\"\n@@ -135,6 +152,7 @@ fn main() {\n     #[test]\n     fn replaces_method_calls() {\n         // foo.make() is a method call which uses a different expr in the let initializer\n+        cov_mark::check!(fallback_to_turbofish_type_if_type_info_not_available);\n         check_assist(\n             replace_turbofish_with_explicit_type,\n             r#\"\n@@ -237,6 +255,110 @@ fn make<T>() -> T {}\n fn main() {\n     let a = make$0::<Vec<String>, i32>();\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replaces_turbofish_for_known_type() {\n+        check_assist(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    let a = make$0::<i32>();\n+}\n+\"#,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    let a: i32 = make();\n+}\n+\"#,\n+        );\n+        check_assist(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+//- minicore: option\n+fn make<T>() -> T {}\n+fn main() {\n+    let a = make$0::<Option<bool>>();\n+}\n+\"#,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    let a: Option<bool> = make();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replaces_turbofish_not_same_type() {\n+        check_assist(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+//- minicore: option\n+fn make<T>() -> Option<T> {}\n+fn main() {\n+    let a = make$0::<u128>();\n+}\n+\"#,\n+            r#\"\n+fn make<T>() -> Option<T> {}\n+fn main() {\n+    let a: Option<u128> = make();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replaces_turbofish_for_type_with_defaulted_generic_param() {\n+        check_assist(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+struct HasDefault<T, U = i32>(T, U);\n+fn make<T>() -> HasDefault<T> {}\n+fn main() {\n+    let a = make$0::<bool>();\n+}\n+\"#,\n+            r#\"\n+struct HasDefault<T, U = i32>(T, U);\n+fn make<T>() -> HasDefault<T> {}\n+fn main() {\n+    let a: HasDefault<bool> = make();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replaces_turbofish_try_await() {\n+        check_assist(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+//- minicore: option, future\n+struct Fut<T>(T);\n+impl<T> core::future::Future for Fut<T> {\n+    type Output = Option<T>;\n+}\n+fn make<T>() -> Fut<T> {}\n+fn main() {\n+    let a = make$0::<bool>().await?;\n+}\n+\"#,\n+            r#\"\n+struct Fut<T>(T);\n+impl<T> core::future::Future for Fut<T> {\n+    type Output = Option<T>;\n+}\n+fn make<T>() -> Fut<T> {}\n+fn main() {\n+    let a: bool = make().await?;\n+}\n \"#,\n         );\n     }"}]}