{"sha": "86d4601827812b4b069e44feec1b1ea64cd34f4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZDQ2MDE4Mjc4MTJiNGIwNjllNDRmZWVjMWIxZWE2NGNkMzRmNGU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-04T21:31:49Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-06T00:17:06Z"}, "message": "More work on typestate. Sketched out code for computing and checking prestates and poststates. Still a long ways away.", "tree": {"sha": "a229baa502c546ad71243fef12337b094c07ff5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a229baa502c546ad71243fef12337b094c07ff5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86d4601827812b4b069e44feec1b1ea64cd34f4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86d4601827812b4b069e44feec1b1ea64cd34f4e", "html_url": "https://github.com/rust-lang/rust/commit/86d4601827812b4b069e44feec1b1ea64cd34f4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86d4601827812b4b069e44feec1b1ea64cd34f4e/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fc8de196977a0e5bb4f733f7aaeb1162e880eaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fc8de196977a0e5bb4f733f7aaeb1162e880eaa", "html_url": "https://github.com/rust-lang/rust/commit/4fc8de196977a0e5bb4f733f7aaeb1162e880eaa"}], "stats": {"total": 588, "additions": 508, "deletions": 80}, "files": [{"sha": "ab0262f1753363b8c1fd3b599001d5e2d126a547", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/86d4601827812b4b069e44feec1b1ea64cd34f4e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d4601827812b4b069e44feec1b1ea64cd34f4e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=86d4601827812b4b069e44feec1b1ea64cd34f4e", "patch": "@@ -23,6 +23,7 @@ import middle.ty.ty_to_str;\n import middle.ty.type_is_integral;\n import middle.ty.type_is_scalar;\n import middle.ty.ty_params_opt_and_ty;\n+import middle.ty.ty_nil;\n \n import std._str;\n import std._uint;\n@@ -62,6 +63,12 @@ fn triv_ann(@ty.t t) -> ann {\n     ret ast.ann_type(t, none[vec[@ty.t]], none[@ts_ann]);\n }\n \n+// Used to fill in the annotation for things that have uninteresting\n+// types\n+fn boring_ann() -> ann {\n+    ret triv_ann(plain_ty(ty_nil));\n+}\n+\n // Replaces parameter types inside a type with type variables.\n fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n     state obj ty_generalizer(@crate_ctxt cx,\n@@ -1361,7 +1368,7 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                                  ann_to_type(ann), adk);\n             e_1 = ast.expr_ext(p, args, body, expanded, triv_ann(t));\n         }\n-        /* FIXME: this should probably check the type annotations */\n+        /* FIXME: should this check the type annotations? */\n         case (ast.expr_fail(_))  { e_1 = e.node; } \n         case (ast.expr_log(_,_)) { e_1 = e.node; } \n         case (ast.expr_break(_)) { e_1 = e.node; }\n@@ -1771,16 +1778,19 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                      ann));\n         }\n \n-        case (ast.expr_fail(_)) { // ??? ignoring ann\n-            ret expr;\n+        case (ast.expr_fail(_)) {\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_fail(boring_ann()));\n         }\n \n         case (ast.expr_break(_)) {\n-            ret expr;\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_break(boring_ann()));\n         }\n \n         case (ast.expr_cont(_)) {\n-            ret expr;\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_cont(boring_ann()));\n         }\n \n         case (ast.expr_ret(?expr_opt, _)) {\n@@ -1792,14 +1802,16 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                          + \"returning non-nil\");\n                     }\n \n-                    ret expr;\n+                    ret @fold.respan[ast.expr_]\n+                        (expr.span,\n+                         ast.expr_ret(none[@ast.expr], boring_ann()));\n                 }\n \n                 case (some[@ast.expr](?e)) {\n                     auto expr_0 = check_expr(fcx, e);\n                     auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n                     ret @fold.respan[ast.expr_]\n-                        (expr.span, ast.expr_ret(some(expr_1), ann_none));\n+                        (expr.span, ast.expr_ret(some(expr_1), boring_ann()));\n                 }\n             }\n         }\n@@ -1813,14 +1825,16 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                          + \"putting non-nil\");\n                     }\n \n-                    ret expr;\n+                    ret @fold.respan[ast.expr_]\n+                        (expr.span, ast.expr_put(none[@ast.expr],\n+                                                 boring_ann()));\n                 }\n \n                 case (some[@ast.expr](?e)) {\n                     auto expr_0 = check_expr(fcx, e);\n                     auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n                     ret @fold.respan[ast.expr_]\n-                        (expr.span, ast.expr_put(some(expr_1), ann_none));\n+                        (expr.span, ast.expr_put(some(expr_1), boring_ann()));\n                 }\n             }\n         }\n@@ -1831,20 +1845,21 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto expr_0 = check_expr(fcx, e);\n             auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_be(expr_1, ann_none));\n+                                        ast.expr_be(expr_1,\n+                                                    boring_ann()));\n         }\n \n         case (ast.expr_log(?e,_)) {\n             auto expr_t = check_expr(fcx, e);\n             ret @fold.respan[ast.expr_]\n-                (expr.span, ast.expr_log(expr_t, ann_none));\n+                (expr.span, ast.expr_log(expr_t, boring_ann()));\n         }\n \n         case (ast.expr_check_expr(?e, _)) {\n             auto expr_t = check_expr(fcx, e);\n             demand(fcx, expr.span, plain_ty(ty.ty_bool), expr_ty(expr_t));\n             ret @fold.respan[ast.expr_]\n-                (expr.span, ast.expr_check_expr(expr_t, ann_none));\n+                (expr.span, ast.expr_check_expr(expr_t, boring_ann()));\n         }\n \n         case (ast.expr_assign(?lhs, ?rhs, _)) {"}, {"sha": "295c4f1bfebc160abe56dd72081b20e0f100372b", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 455, "deletions": 63, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/86d4601827812b4b069e44feec1b1ea64cd34f4e/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d4601827812b4b069e44feec1b1ea64cd34f4e/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=86d4601827812b4b069e44feec1b1ea64cd34f4e", "patch": "@@ -20,6 +20,8 @@ import front.ast.expr;\n import front.ast.expr_call;\n import front.ast.expr_path;\n import front.ast.expr_log;\n+import front.ast.expr_block;\n+import front.ast.expr_lit;\n import front.ast.path;\n import front.ast.crate_directive;\n import front.ast.fn_decl;\n@@ -42,6 +44,12 @@ import front.ast.ann_none;\n import front.ast.ann_type;\n import front.ast._obj;\n import front.ast._mod;\n+import front.ast.crate;\n+import front.ast.module;\n+import front.ast.mod_index_entry;\n+import front.ast.mie_item;\n+import front.ast.item_fn;\n+import front.ast.def_local;\n \n import middle.fold;\n import middle.fold.respan;\n@@ -50,16 +58,22 @@ import util.common;\n import util.common.span;\n import util.common.spanned;\n import util.common.new_str_hash;\n+import util.common.new_def_hash;\n import util.typestate_ann;\n import util.typestate_ann.ts_ann;\n import util.typestate_ann.empty_pre_post;\n import util.typestate_ann.true_precond;\n import util.typestate_ann.true_postcond;\n import util.typestate_ann.postcond;\n import util.typestate_ann.precond;\n+import util.typestate_ann.poststate;\n+import util.typestate_ann.prestate;\n import util.typestate_ann.pre_and_post;\n import util.typestate_ann.get_pre;\n import util.typestate_ann.get_post;\n+import util.typestate_ann.implies;\n+import util.typestate_ann.pre_and_post_state;\n+import util.typestate_ann.empty_states;\n \n import middle.ty;\n import middle.ty.ann_to_type;\n@@ -91,28 +105,143 @@ import std.list.cons;\n import std.list.nil;\n import std.list.foldl;\n import std.list.find;\n+import std._uint;\n+import std.bitv;\n \n import util.typestate_ann;\n import util.typestate_ann.difference;\n import util.typestate_ann.union;\n import util.typestate_ann.pps_len;\n import util.typestate_ann.require_and_preserve;\n \n-/**********************************************************************/\n-/* mapping from variable name to bit number */\n-type fn_info = std.map.hashmap[ident, uint];\n+/**** debugging junk  ****/\n+fn log_expr(@expr e) -> () {\n+  let str_writer s = string_writer();\n+  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out = @rec(s=out_,\n+                  comments=option.none[vec[front.lexer.cmnt]],\n+                  mutable cur_cmnt=0u);\n+\n+  print_expr(out, e);\n+  log(s.get_str());\n+}\n+\n+fn log_cond(vec[uint] v) -> () {\n+  auto res = \"\";\n+  for (uint i in v) {\n+    if (i == 0u) {\n+      res += \"0\";\n+    }\n+    else {\n+      res += \"1\";\n+    }\n+  }\n+  log(res);\n+}\n+fn log_pp(&pre_and_post pp) -> () {\n+  auto p1 = bitv.to_vec(pp.precondition);\n+  auto p2 = bitv.to_vec(pp.postcondition);\n+  log(\"pre:\");\n+  log_cond(p1);\n+  log(\"post:\");\n+  log_cond(p2);\n+}\n \n-fn bit_num(ident v, fn_info m) -> uint {\n+fn print_ident(&ident i) -> () {\n+  log(\" \" + i + \" \");\n+}\n+\n+fn print_idents(vec[ident] idents) -> () {\n+  if(len[ident](idents) == 0u) {\n+    ret;\n+  }\n+  else {\n+    log(\"an ident: \" + pop[ident](idents));\n+    print_idents(idents);\n+  }\n+}\n+/**********************************************************************/\n+/* mapping from variable name (def_id is assumed to be for a local\n+   variable in a given function) to bit number */\n+type fn_info      = std.map.hashmap[def_id, uint];\n+/* mapping from function name to fn_info map */\n+type _fn_info_map = std.map.hashmap[def_id, fn_info];\n+ \n+fn bit_num(def_id v, fn_info m) -> uint {\n+  check (m.contains_key(v));\n   ret m.get(v);\n }\n+\n+fn var_is_local(def_id v, fn_info m) -> bool {\n+  ret (m.contains_key(v));\n+}\n+\n fn num_locals(fn_info m) -> uint {\n   ret m.size();\n }\n \n+fn find_locals(_fn f) -> vec[def_id] {\n+  auto res = _vec.alloc[def_id](0u);\n+\n+  for each (@tup(ident, block_index_entry) p\n+          in f.body.node.index.items()) {\n+    alt (p._1) {\n+      case (ast.bie_local(?loc)) {\n+        res += vec(loc.id);\n+      }\n+      case (_) { }\n+    }\n+  }\n+\n+  ret res;\n+}\n+\n+fn add_var(def_id v, uint next, fn_info tbl) -> uint {\n+  tbl.insert(v, next);\n+  // log(v + \" |-> \" + _uint.to_str(next, 10u));\n+  ret (next + 1u);\n+}\n+\n+/* builds a table mapping each local var defined in f\n+ to a bit number in the precondition/postcondition vectors */\n fn mk_fn_info(_fn f) -> fn_info {\n-  ret new_str_hash[uint](); /* FIXME: actually implement this */\n+  auto res = new_def_hash[uint]();\n+  let uint next = 0u;\n+  let vec[ast.arg] f_args = f.decl.inputs;\n+\n+  for (ast.arg v in f_args) {\n+    next = add_var(v.id, next, res);\n+  }\n+\n+  let vec[def_id] locals = find_locals(f);\n+  for (def_id v in locals) {\n+    next = add_var(v, next, res);\n+  }\n+\n+  ret res;\n }\n-/**********************************************************************/\n+\n+/* extends mk_fn_info to an item, side-effecting the map fi from \n+   function IDs to fn_info maps */\n+fn mk_fn_info_item_fn(&_fn_info_map fi, &span sp, ident i, &ast._fn f,\n+                 vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n+  fi.insert(id, mk_fn_info(f));\n+  ret @respan(sp, item_fn(i, f, ty_params, id, a));\n+}\n+\n+/* initializes the global fn_info_map (mapping each function ID, including\n+   nested locally defined functions, onto a mapping from local variable name\n+   to bit number) */\n+fn mk_f_to_fn_info(@ast.crate c) -> _fn_info_map {\n+  auto res = new_def_hash[fn_info]();\n+\n+  auto fld = fold.new_identity_fold[_fn_info_map]();\n+  fld = @rec(fold_item_fn = bind mk_fn_info_item_fn(_,_,_,_,_,_,_) with *fld);\n+  fold.fold_crate[_fn_info_map](res, fld, c);\n+\n+  ret res;\n+}\n+/**** Helpers ****/\n fn expr_ann(&expr e) -> ann {\n   alt(e.node) {\n     case (ast.expr_vec(_,_,?a)) {\n@@ -214,8 +343,53 @@ fn expr_ann(&expr e) -> ann {\n   }\n }\n \n-fn expr_pp(&@expr e) -> pre_and_post {\n-  alt (expr_ann(*e)) {\n+/* returns ann_none if this is the sort\n+ of statement where an ann doesn't make sense */\n+fn stmt_ann(&stmt s) -> ann {\n+  alt (s.node) {\n+    case (stmt_decl(?d)) {\n+      alt (d.node) {\n+        case (decl_local(?l)) {\n+          ret l.ann;\n+        }\n+        case (decl_item(?i)) {\n+          ret ann_none; /* ????? */\n+        }\n+      }\n+    }\n+    case (stmt_expr(?e)) {\n+      ret expr_ann(*e);\n+    }\n+    case (_) {\n+      ret ann_none;\n+    }\n+  }\n+}\n+\n+/* fails if e has no annotation */\n+fn expr_pp(&expr e) -> pre_and_post {\n+  alt (expr_ann(e)) {\n+    case (ann_none) {\n+      log \"expr_pp: the impossible happened (no annotation)\";\n+      fail;\n+    }\n+    case (ann_type(_, _, ?maybe_pp)) {\n+      alt (maybe_pp) {\n+        case (none[@ts_ann]) {\n+          log \"expr_pp: the impossible happened (no pre/post)\";\n+          fail;\n+        }\n+        case (some[@ts_ann](?p)) {\n+          ret p.conditions;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+/* fails if e has no annotation */\n+fn expr_states(&expr e) -> pre_and_post_state {\n+  alt (expr_ann(e)) {\n     case (ann_none) {\n       log \"expr_pp: the impossible happened (no annotation)\";\n       fail;\n@@ -227,29 +401,95 @@ fn expr_pp(&@expr e) -> pre_and_post {\n           fail;\n         }\n         case (some[@ts_ann](?p)) {\n-          ret *p;\n+          ret p.states;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+/* fails if no annotation */\n+fn stmt_pp(&stmt s) -> pre_and_post {\n+  alt (stmt_ann(s)) {\n+    case (ann_none) {\n+      fail;\n+    }\n+    case (ann_type(_, _, ?maybe_pp)) {\n+      alt (maybe_pp) {\n+        case (none[@ts_ann]) {\n+          fail;\n+        }\n+        case (some[@ts_ann](?p)) {\n+          ret p.conditions;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+/* fails if no annotation */\n+fn stmt_states(&stmt s) -> pre_and_post_state {\n+  alt (stmt_ann(s)) {\n+    case (ann_none) {\n+      fail;\n+    }\n+    case (ann_type(_, _, ?maybe_pp)) {\n+      alt (maybe_pp) {\n+        case (none[@ts_ann]) {\n+          fail;\n+        }\n+        case (some[@ts_ann](?p)) {\n+          ret p.states;\n         }\n       }\n     }\n   }\n }\n \n fn expr_precond(&expr e) -> precond {\n-  ret (expr_pp(@e)).precondition;\n+  ret (expr_pp(e)).precondition;\n }\n \n-fn expr_postcond(&@expr e) -> postcond {\n+fn expr_postcond(&expr e) -> postcond {\n   ret (expr_pp(e)).postcondition;\n }\n \n-fn with_pp(ann a, @pre_and_post p) -> ann {\n+fn expr_prestate(&expr e) -> prestate {\n+  ret (expr_states(e)).prestate;\n+}\n+\n+fn expr_poststate(&expr e) -> poststate {\n+  ret (expr_states(e)).poststate;\n+}\n+\n+fn stmt_precond(&stmt s) -> precond {\n+  ret (stmt_pp(s)).precondition;\n+}\n+\n+fn stmt_postcond(&stmt s) -> postcond {\n+  ret (stmt_pp(s)).postcondition;\n+}\n+\n+fn stmt_prestate(&stmt s) -> prestate {\n+  ret (stmt_states(s)).prestate;\n+}\n+\n+fn stmt_poststate(&stmt s) -> poststate {\n+  ret (stmt_states(s)).poststate;\n+}\n+\n+/* returns a new annotation where the pre_and_post is p */\n+fn with_pp(ann a, pre_and_post p) -> ann {\n   alt (a) {\n     case (ann_none) {\n       log(\"with_pp: the impossible happened\");\n       fail; /* shouldn't happen b/c code is typechecked */\n     }\n     case (ann_type(?t, ?ps, _)) {\n-      ret (ann_type(t, ps, some[@ts_ann](p)));\n+      ret (ann_type(t, ps,\n+                    some[@ts_ann]\n+                    (@rec(conditions=p,\n+                          states=empty_states(pps_len(p))))));\n     }\n   }\n }\n@@ -276,9 +516,14 @@ fn seq_preconds(uint num_vars, vec[pre_and_post] pps) -> precond {\n }\n \n fn union_postconds_go(postcond first, &vec[postcond] rest) -> postcond {\n-  auto other = rest.(0);\n-  union(first, other);\n-  union_postconds_go(first, slice[postcond](rest, 1u, len[postcond](rest)));\n+  auto sz = _vec.len[postcond](rest);\n+\n+  if (sz > 0u) {\n+    auto other = rest.(0);\n+    union(first, other);\n+    union_postconds_go(first, slice[postcond](rest, 1u, len[postcond](rest)));\n+  }\n+\n   ret first;\n }\n \n@@ -288,19 +533,7 @@ fn union_postconds(&vec[postcond] pcs) -> postcond {\n   be union_postconds_go(pcs.(0), pcs);\n }\n \n-fn print_ident(&ident i) -> () {\n-  log(\" \" + i + \" \");\n-}\n-\n-fn print_idents(vec[ident] idents) -> () {\n-  if(len[ident](idents) == 0u) {\n-    ret;\n-  }\n-  else {\n-    log(\"an ident: \" + pop[ident](idents));\n-    print_idents(idents);\n-  }\n-}\n+/******* AST-traversing code ********/\n \n fn find_pre_post_mod(&_mod m) -> _mod {\n   ret m; /* FIXME */\n@@ -314,26 +547,29 @@ fn find_pre_post_obj(_obj o) -> _obj {\n   ret o; /* FIXME */\n }\n \n-impure fn find_pre_post_item(fn_info enclosing, &item i) -> item {\n+fn find_pre_post_item(_fn_info_map fm, fn_info enclosing, &item i) -> item {\n   alt (i.node) {\n     case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n       auto e_pp = find_pre_post_expr(enclosing, *e);\n+      log(\"1\");\n       ret (respan(i.span,\n-                   ast.item_const(id, t, e_pp, di,\n-                              with_pp(a, @expr_pp(e_pp)))));\n+                  ast.item_const(id, t, e_pp, di, a)));\n     }\n     case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n-      auto f_pp = find_pre_post_fn(f);\n+      check (fm.contains_key(di));\n+      auto f_pp = find_pre_post_fn(fm, fm.get(di), f);\n       ret (respan(i.span, \n                    ast.item_fn(id, f_pp, ps, di, a)));\n     }\n     case (ast.item_mod(?id, ?m, ?di)) {\n       auto m_pp = find_pre_post_mod(m);\n+      log(\"3\");\n       ret (respan(i.span,\n                    ast.item_mod(id, m_pp, di)));\n     }\n     case (ast.item_native_mod(?id, ?nm, ?di)) {\n       auto n_pp = find_pre_post_native_mod(nm);\n+      log(\"4\");\n       ret (respan(i.span,\n                    ast.item_native_mod(id, n_pp, di)));\n     }\n@@ -345,58 +581,102 @@ impure fn find_pre_post_item(fn_info enclosing, &item i) -> item {\n     }\n     case (ast.item_obj(?id, ?o, ?ps, ?di, ?a)) {\n       auto o_pp = find_pre_post_obj(o);\n+      log(\"5\");\n       ret (respan(i.span,\n                    ast.item_obj(id, o_pp, ps, di, a)));\n     }\n   }\n }\n \n-impure fn find_pre_post_expr(&fn_info enclosing, &expr e) -> @expr {\n+fn find_pre_post_expr(&fn_info enclosing, &expr e) -> @expr {\n   auto num_local_vars = num_locals(enclosing);\n \n   fn do_rand_(fn_info enclosing, &@expr e) -> @expr {\n-    be find_pre_post_expr(enclosing, *e);\n+    log(\"for rand \" );\n+    log_expr(e);\n+    log(\"pp = \");\n+    auto res = find_pre_post_expr(enclosing, *e);\n+    log_pp(expr_pp(*res));\n+    ret res;\n   }\n \n   auto do_rand = bind do_rand_(enclosing,_);\n \n   alt(e.node) {\n     case(expr_call(?oper, ?rands, ?a)) {\n       auto pp_oper = find_pre_post_expr(enclosing, *oper);\n+      log(\"pp_oper =\");\n+      log_pp(expr_pp(*pp_oper));\n       \n       auto f = do_rand;\n       auto pp_rands = _vec.map[@expr, @expr](f, rands);\n       \n-      auto g = expr_pp;\n-      auto pps = _vec.map[@expr, pre_and_post]      \n-        (g, pp_rands);\n-      _vec.push[pre_and_post](pps, expr_pp(pp_oper));\n+      fn pp_one(&@expr e) -> pre_and_post {\n+        be expr_pp(*e);\n+      }\n+      auto g = pp_one;\n+      auto pps = _vec.map[@expr, pre_and_post](g, pp_rands);\n+      _vec.push[pre_and_post](pps, expr_pp(*pp_oper));\n       auto h = get_post;\n       auto res_postconds = _vec.map[pre_and_post, postcond](h, pps);\n       auto res_postcond = union_postconds(res_postconds);\n-      let @pre_and_post pp =\n-        @rec(precondition=seq_preconds(num_local_vars, pps),\n+      let pre_and_post pp =\n+        rec(precondition=seq_preconds(num_local_vars, pps),\n              postcondition=res_postcond);\n       let ann a_res = with_pp(a, pp);\n+      log(\"result for call\");\n+      log_expr(@e);\n+      log(\"is:\");\n+      log_pp(pp);\n       ret (@respan(e.span,\n                    expr_call(pp_oper, pp_rands, a_res)));\n                         \n     }\n     case(expr_path(?p, ?maybe_def, ?a)) {\n-      check (len[ident](p.node.idents) > 0u);\n-      auto referent = p.node.idents.(0);\n-      auto i = bit_num(referent, enclosing);\n+      auto df;\n+      alt (maybe_def) {\n+        case (none[def])\n+          { log(\"expr_path should have a def\"); fail; }\n+        case (some[def](?d)) { df = d; }\n+      }\n+\n       auto res = empty_pre_post(num_local_vars);\n-      require_and_preserve(i, *res);\n+\n+      alt (df) {\n+        case (def_local(?d_id)) {\n+          auto i = bit_num(d_id, enclosing);\n+          require_and_preserve(i, res);\n+        }\n+        case (_) { /* nothing to check */ }\n+      }\n+\n+      // Otherwise, variable is global, so it must be initialized\n+      log(\"pre/post for:\\n\");\n+      log_expr(@e);\n+      log(\"is\");\n+      log_pp(res);\n       ret (@respan\n            (e.span,\n             expr_path(p, maybe_def,\n                       with_pp(a, res))));\n     }\n-    case(expr_log(?e, ?a)) {\n-      auto e_pp = find_pre_post_expr(enclosing, *e);\n+    case(expr_log(?arg, ?a)) {\n+      log(\"log\");\n+      auto e_pp = find_pre_post_expr(enclosing, *arg);\n+      log(\"pre/post for: \");\n+      log_expr(arg);\n+      log(\"is\");\n+      log_pp(expr_pp(*e_pp));\n       ret (@respan(e.span,\n-                   expr_log(e_pp, with_pp(a, @expr_pp(e_pp)))));\n+                   expr_log(e_pp, with_pp(a, expr_pp(*e_pp)))));\n+    }\n+    case (expr_block(?b, ?a)) {\n+      log(\"block!\");\n+      fail;\n+    }\n+    case (expr_lit(?l, ?a)) {\n+      ret @respan(e.span,\n+                  expr_lit(l, with_pp(a, empty_pre_post(num_local_vars))));\n     }\n     case(_) {\n       log(\"this sort of expr isn't implemented!\");\n@@ -405,8 +685,8 @@ impure fn find_pre_post_expr(&fn_info enclosing, &expr e) -> @expr {\n   }\n }\n \n-impure fn find_pre_post_for_each_stmt(&fn_info enclosing, &ast.stmt s)\n-  -> ast.stmt {\n+fn find_pre_post_for_each_stmt(_fn_info_map fm, &fn_info enclosing,\n+                               &ast.stmt s) -> ast.stmt {\n   auto num_local_vars = num_locals(enclosing);\n \n   alt(s.node) {\n@@ -418,7 +698,7 @@ impure fn find_pre_post_for_each_stmt(&fn_info enclosing, &ast.stmt s)\n               let @expr r = find_pre_post_expr(enclosing, *an_init.expr);\n               let init_op o = an_init.op;\n               let initializer a_i = rec(op=o, expr=r);\n-              let ann res_ann = with_pp(alocal.ann, @expr_pp(r));\n+              let ann res_ann = with_pp(alocal.ann, expr_pp(*r));\n               let @local res_local =\n                 @rec(ty=alocal.ty, infer=alocal.infer,\n                      ident=alocal.ident, init=some[initializer](a_i),\n@@ -443,24 +723,26 @@ impure fn find_pre_post_for_each_stmt(&fn_info enclosing, &ast.stmt s)\n           }\n         }\n         case(decl_item(?anitem)) {\n-          auto res_item = find_pre_post_item(enclosing, *anitem);\n+          auto res_item = find_pre_post_item(fm, enclosing, *anitem);\n           ret (respan(s.span, stmt_decl(@respan(adecl.span,\n                                                decl_item(@res_item))))); \n         }\n       }\n     }\n     case(stmt_expr(?e)) {\n+      log_expr(e);\n       let @expr e_pp = find_pre_post_expr(enclosing, *e);\n       ret (respan(s.span, stmt_expr(e_pp)));\n     }    \n   }\n }\n \n-fn find_pre_post_block(fn_info enclosing, block b) -> block {\n-  fn do_one_(fn_info i, &@stmt s) -> @stmt {\n-    ret (@find_pre_post_for_each_stmt(i, *s));\n+fn find_pre_post_block(&_fn_info_map fm, &fn_info enclosing, block b)\n+  -> block {\n+  fn do_one_(_fn_info_map fm, fn_info i, &@stmt s) -> @stmt {\n+    ret (@find_pre_post_for_each_stmt(fm, i, *s));\n   }\n-  auto do_one = bind do_one_(enclosing, _);\n+  auto do_one = bind do_one_(fm, enclosing, _);\n  \n   auto ss = _vec.map[@stmt, @stmt](do_one, b.node.stmts);\n   fn do_inner_(fn_info i, &@expr e) -> @expr {\n@@ -472,24 +754,134 @@ fn find_pre_post_block(fn_info enclosing, block b) -> block {\n   ret respan(b.span, b_res);\n }\n \n-fn find_pre_post_fn(&_fn f) -> _fn {\n-  let fn_info fi = mk_fn_info(f);\n+fn find_pre_post_fn(&_fn_info_map fm, &fn_info fi, &_fn f) -> _fn {\n   ret rec(decl=f.decl, proto=f.proto,\n-          body=find_pre_post_block(fi, f.body));\n+          body=find_pre_post_block(fm, fi, f.body));\n }\n \n-fn check_item_fn(&@() ignore, &span sp, ident i, &ast._fn f,\n+fn check_item_fn(&_fn_info_map fm, &span sp, ident i, &ast._fn f,\n                  vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n \n-  auto res_f = find_pre_post_fn(f);  \n+  check (fm.contains_key(id));\n+  auto res_f = find_pre_post_fn(fm, fm.get(id), f);  \n \n   ret @respan(sp, ast.item_fn(i, res_f, ty_params, id, a));\n }\n \n+/* Returns a pair of a new function, with possibly a changed pre- or\n+   post-state, and a boolean flag saying whether the function's pre- or \n+   poststate changed */\n+fn find_pre_post_state_fn(fn_info f_info, &ast._fn f) -> tup(bool, ast._fn) {\n+  log (\"Implement find_pre_post_state_fn!\");\n+  fail;\n+}\n+\n+fn fixed_point_states(fn_info f_info,\n+                      fn (fn_info, &ast._fn) -> tup(bool, ast._fn) f,\n+                      &ast._fn start) -> ast._fn {\n+  auto next = f(f_info, start);\n+\n+  if (next._0) {\n+    // something changed\n+    be fixed_point_states(f_info, f, next._1);\n+  }\n+  else {\n+    // we're done!\n+    ret next._1;\n+  }\n+}\n+\n+fn check_states_expr(fn_info enclosing, &expr e) -> () {\n+  let precond prec    = expr_precond(e);\n+  let postcond postc  = expr_postcond(e);\n+  let prestate pres   = expr_prestate(e);\n+  let poststate posts = expr_poststate(e);\n+\n+  if (!implies(pres, prec)) {\n+    log(\"check_states_expr: unsatisfied precondition\");\n+    fail;\n+  }\n+  if (!implies(posts, postc)) {\n+    log(\"check_states_expr: unsatisfied postcondition\");\n+    fail;\n+  }\n+}\n+\n+fn check_states_stmt(fn_info enclosing, &stmt s) -> () {\n+  alt (stmt_ann(s)) {\n+    case (ann_none) {\n+      // Statement doesn't require an annotation -- do nothing\n+      ret;\n+    }\n+    case (ann_type(_,_,?m_pp)) {\n+      let precond prec    = stmt_precond(s);\n+      let postcond postc  = stmt_postcond(s);\n+      let prestate pres   = stmt_prestate(s);\n+      let poststate posts = stmt_poststate(s);\n+\n+      if (!implies(pres, prec)) {\n+        log(\"check_states_stmt: unsatisfied precondition\");\n+        fail;\n+      }\n+      if (!implies(posts, postc)) {\n+        log(\"check_states_stmt: unsatisfied postcondition\");\n+        fail;\n+      }\n+    }\n+  }\n+}\n+\n+fn check_states_against_conditions(fn_info enclosing, &ast._fn f) -> () {\n+  fn do_one_(fn_info i, &@stmt s) -> () {\n+    check_states_stmt(i, *s);\n+  }\n+  auto do_one = bind do_one_(enclosing, _);\n+ \n+  _vec.map[@stmt, ()](do_one, f.body.node.stmts);\n+  fn do_inner_(fn_info i, &@expr e) -> () {\n+    check_states_expr(i, *e);\n+  }\n+  auto do_inner = bind do_inner_(enclosing, _);\n+  option.map[@expr, ()](do_inner, f.body.node.expr);\n+  \n+}\n+\n+fn check_item_fn_state(&_fn_info_map f_info_map, &span sp, ident i,\n+                       &ast._fn f, vec[ast.ty_param] ty_params, def_id id,\n+                       ann a) -> @item {\n+\n+  /* Look up the var-to-bit-num map for this function */\n+  check(f_info_map.contains_key(id));\n+  auto f_info = f_info_map.get(id);\n+\n+  /* Compute the pre- and post-states for this function */\n+  auto g = find_pre_post_state_fn;\n+  auto res_f = fixed_point_states(f_info, g, f);\n+\n+  /* Now compare each expr's pre-state to its precondition\n+     and post-state to its postcondition */\n+  check_states_against_conditions(f_info, res_f);\n+\n+  /* Rebuild the same function */\n+  ret @respan(sp, ast.item_fn(i, res_f, ty_params, id, a));\n+}\n+\n fn check_crate(@ast.crate crate) -> @ast.crate {\n-  auto fld = fold.new_identity_fold[@()]();\n \n+  /* Build the global map from function id to var-to-bit-num-map */\n+  auto fn_info_map = mk_f_to_fn_info(crate);\n+\n+  /* Compute the pre and postcondition for every subexpression */\n+  auto fld = fold.new_identity_fold[_fn_info_map]();\n   fld = @rec(fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_) with *fld);\n+  auto with_pre_postconditions = fold.fold_crate[_fn_info_map]\n+    (fn_info_map, fld, crate);\n+\n+  auto fld1 = fold.new_identity_fold[_fn_info_map]();\n+\n+  fld1 = @rec(fold_item_fn = bind check_item_fn_state(_,_,_,_,_,_,_)\n+              with *fld1);\n \n-  ret fold.fold_crate[@()](@(), fld, crate);\n+  ret fold.fold_crate[_fn_info_map](fn_info_map, fld1,\n+                                    with_pre_postconditions);\n }"}, {"sha": "47a37f3325ff374c041b305fc8dc19ffcc427d77", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86d4601827812b4b069e44feec1b1ea64cd34f4e/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/86d4601827812b4b069e44feec1b1ea64cd34f4e/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=86d4601827812b4b069e44feec1b1ea64cd34f4e", "patch": "@@ -62,6 +62,8 @@ auth middle.typestate_check.log_expr = impure;\n auth lib.llvm = unsafe;\n auth pretty.pprust = impure;\n auth middle.typestate_check.find_pre_post_block = impure;\n+auth middle.typestate_check.find_pre_post_expr = impure;\n+auth util.typestate_ann.implies = impure;\n \n mod lib {\n     alt (target_os) {"}, {"sha": "071f55135f5a1ac39d7943a1724d1e454e4784b2", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/86d4601827812b4b069e44feec1b1ea64cd34f4e/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d4601827812b4b069e44feec1b1ea64cd34f4e/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=86d4601827812b4b069e44feec1b1ea64cd34f4e", "patch": "@@ -12,12 +12,21 @@ type precond  = bitv.t; /* 1 means \"this variable must be initialized\"\n type postcond = bitv.t; /* 1 means \"this variable is initialized\"\n                            0 means \"don't know about this variable */\n \n+type prestate = bitv.t; /* 1 means \"this variable is definitely initialized\"\n+                           0 means \"don't know whether this variable is\n+                           initialized\" */\n+type poststate = bitv.t; /* 1 means \"this variable is definitely initialized\"\n+                            0 means \"don't know whether this variable is\n+                            initialized\" */\n+\n /* named thus so as not to confuse with prestate and poststate */\n type pre_and_post = rec(precond precondition, postcond postcondition);\n /* FIXME: once it's implemented: */\n //  : ((*.precondition).nbits == (*.postcondition).nbits);\n \n-type ts_ann = pre_and_post;\n+type pre_and_post_state = rec(prestate prestate, poststate poststate);\n+\n+type ts_ann = rec(pre_and_post conditions, pre_and_post_state states);\n \n fn true_precond(uint num_vars) -> precond {\n   be bitv.create(num_vars, false);\n@@ -27,11 +36,16 @@ fn true_postcond(uint num_vars) -> postcond {\n   be true_precond(num_vars);\n }\n \n-fn empty_pre_post(uint num_vars) -> @pre_and_post {\n-  ret(@rec(precondition=true_precond(num_vars),\n+fn empty_pre_post(uint num_vars) -> pre_and_post {\n+  ret(rec(precondition=true_precond(num_vars),\n            postcondition=true_postcond(num_vars)));\n }\n \n+fn empty_states(uint num_vars) -> pre_and_post_state {\n+  ret(rec(prestate=true_precond(num_vars),\n+           poststate=true_postcond(num_vars)));\n+}\n+\n fn get_pre(&pre_and_post p) -> precond {\n   ret p.precondition;\n }\n@@ -57,5 +71,10 @@ fn pps_len(&pre_and_post p) -> uint {\n impure fn require_and_preserve(uint i, &pre_and_post p) -> () {\n   // sets the ith bit in p's pre and post\n   bitv.set(p.precondition, i, true);\n-  bitv.set(p.postcondition, i, false);\n-}\n\\ No newline at end of file\n+  bitv.set(p.postcondition, i, true);\n+}\n+\n+fn implies(bitv.t a, bitv.t b) -> bool {\n+  bitv.difference(b, a);\n+  ret (bitv.equal(b, bitv.create(b.nbits, false)));\n+}"}]}