{"sha": "a80aa3495167adf791a46059be78e7b377c98606", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MGFhMzQ5NTE2N2FkZjc5MWE0NjA1OWJlNzhlN2IzNzdjOTg2MDY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-18T09:49:27Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-22T23:29:29Z"}, "message": "let_chains: Change AST validation strategy slightly.", "tree": {"sha": "e2807fc62108ad09b97db1a039bc1a5426fe1841", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2807fc62108ad09b97db1a039bc1a5426fe1841"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a80aa3495167adf791a46059be78e7b377c98606", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a80aa3495167adf791a46059be78e7b377c98606", "html_url": "https://github.com/rust-lang/rust/commit/a80aa3495167adf791a46059be78e7b377c98606", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a80aa3495167adf791a46059be78e7b377c98606/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ff947f5967666d9e22162f10ccc572b3e839758", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff947f5967666d9e22162f10ccc572b3e839758", "html_url": "https://github.com/rust-lang/rust/commit/1ff947f5967666d9e22162f10ccc572b3e839758"}], "stats": {"total": 79, "additions": 45, "deletions": 34}, "files": [{"sha": "a168599c9d8b2ac6f37f6b86e89a2df6f7edf718", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 45, "deletions": 34, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a80aa3495167adf791a46059be78e7b377c98606/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80aa3495167adf791a46059be78e7b377c98606/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=a80aa3495167adf791a46059be78e7b377c98606", "patch": "@@ -114,8 +114,10 @@ impl<'a> AstValidator<'a> {\n         with(self, outer, |this| &mut this.outer_impl_trait, f)\n     }\n \n-    fn with_let_allowed(&mut self, v: bool, f: impl FnOnce(&mut Self)) {\n-        with(self, v, |this| &mut this.is_let_allowed, f)\n+    fn with_let_allowed(&mut self, v: bool, f: impl FnOnce(&mut Self, bool)) {\n+        let old = mem::replace(&mut self.is_let_allowed, v);\n+        f(self, old);\n+        self.is_let_allowed = old;\n     }\n \n     fn visit_assoc_ty_constraint_from_generic_args(&mut self, constraint: &'a AssocTyConstraint) {\n@@ -336,27 +338,29 @@ impl<'a> AstValidator<'a> {\n     /// Visits the `expr` and adjusts whether `let $pat = $expr` is allowed in decendants.\n     /// Returns whether we walked into `expr` or not.\n     /// If we did, walking should not happen again.\n-    fn visit_expr_with_let_maybe_allowed(&mut self, expr: &'a Expr) -> bool {\n+    fn visit_expr_with_let_maybe_allowed(&mut self, expr: &'a Expr, let_allowed: bool) -> bool {\n         match &expr.node {\n             // Assuming the context permits, `($expr)` does not impose additional constraints.\n-            ExprKind::Paren(_) => visit::walk_expr(self, expr),\n+            ExprKind::Paren(_) => {\n+                self.with_let_allowed(let_allowed, |this, _| visit::walk_expr(this, expr));\n+            }\n             // Assuming the context permits,\n             // l && r` allows decendants in `l` and `r` to be `let` expressions.\n-            ExprKind::Binary(op, ..) if op.node == BinOpKind::And => visit::walk_expr(self, expr),\n+            ExprKind::Binary(op, ..) if op.node == BinOpKind::And => {\n+                self.with_let_allowed(let_allowed, |this, _| visit::walk_expr(this, expr));\n+            }\n             // However, we do allow it in the condition of the `if` expression.\n             // We do not allow `let` in `then` and `opt_else` directly.\n-            ExprKind::If(ref cond, ref then, ref opt_else) => {\n-                self.with_let_allowed(false, |this| {\n-                    this.visit_block(then);\n-                    walk_list!(this, visit_expr, opt_else);\n-                });\n-                self.with_let_allowed(true, |this| this.visit_expr(cond));\n+            ExprKind::If(cond, then, opt_else) => {\n+                self.visit_block(then);\n+                walk_list!(self, visit_expr, opt_else);\n+                self.with_let_allowed(true, |this, _| this.visit_expr(cond));\n             }\n             // The same logic applies to `While`.\n-            ExprKind::While(ref cond, ref then, ref opt_label) => {\n+            ExprKind::While(cond, then, opt_label) => {\n                 walk_list!(self, visit_label, opt_label);\n-                self.with_let_allowed(false, |this| this.visit_block(then));\n-                self.with_let_allowed(true, |this| this.visit_expr(cond));\n+                self.visit_block(then);\n+                self.with_let_allowed(true, |this, _| this.visit_expr(cond));\n             }\n             // Don't walk into `expr` and defer further checks to the caller.\n             _ => return false,\n@@ -365,6 +369,15 @@ impl<'a> AstValidator<'a> {\n         true\n     }\n \n+    /// Emits an error banning the `let` expression provided.\n+    fn ban_let_expr(&self, expr: &'a Expr) {\n+        self.err_handler()\n+            .struct_span_err(expr.span, \"`let` expressions are not supported here\")\n+            .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n+            .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n+            .emit();\n+    }\n+\n     fn check_fn_decl(&self, fn_decl: &FnDecl) {\n         fn_decl\n             .inputs\n@@ -491,28 +504,26 @@ fn validate_generics_order<'a>(\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_expr(&mut self, expr: &'a Expr) {\n-        match expr.node {\n-            ExprKind::Let(_, _) if !self.is_let_allowed => {\n-                self.err_handler()\n-                    .struct_span_err(expr.span, \"`let` expressions are not supported here\")\n-                    .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n-                    .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n-                    .emit();\n-            }\n-            _ if self.visit_expr_with_let_maybe_allowed(&expr) => {\n-                // Prevent `walk_expr` to happen since we've already done that.\n-                return;\n-            }\n-            ExprKind::Closure(_, _, _, ref fn_decl, _, _) => {\n-                self.check_fn_decl(fn_decl);\n-            }\n-            ExprKind::InlineAsm(..) if !self.session.target.target.options.allow_asm => {\n-                span_err!(self.session, expr.span, E0472, \"asm! is unsupported on this target\");\n+        self.with_let_allowed(false, |this, let_allowed| {\n+            match &expr.node {\n+                ExprKind::Let(_, _) if !let_allowed => {\n+                    this.ban_let_expr(expr);\n+                }\n+                _ if this.visit_expr_with_let_maybe_allowed(&expr, let_allowed) => {\n+                    // Prevent `walk_expr` to happen since we've already done that.\n+                    return;\n+                }\n+                ExprKind::Closure(_, _, _, fn_decl, _, _) => {\n+                    this.check_fn_decl(fn_decl);\n+                }\n+                ExprKind::InlineAsm(..) if !this.session.target.target.options.allow_asm => {\n+                    span_err!(this.session, expr.span, E0472, \"asm! is unsupported on this target\");\n+                }\n+                _ => {}\n             }\n-            _ => {}\n-        }\n \n-        self.with_let_allowed(false, |this| visit::walk_expr(this, expr));\n+            visit::walk_expr(this, expr);\n+        });\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {"}]}