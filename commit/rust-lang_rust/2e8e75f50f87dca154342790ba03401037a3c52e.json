{"sha": "2e8e75f50f87dca154342790ba03401037a3c52e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlOGU3NWY1MGY4N2RjYTE1NDM0Mjc5MGJhMDM0MDEwMzdhM2M1MmU=", "commit": {"author": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2017-08-03T11:50:06Z"}, "committer": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2017-08-03T12:40:40Z"}, "message": "Tweak error message", "tree": {"sha": "f5c257543f16895041d9a2f9b6681118721378fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5c257543f16895041d9a2f9b6681118721378fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e8e75f50f87dca154342790ba03401037a3c52e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8e75f50f87dca154342790ba03401037a3c52e", "html_url": "https://github.com/rust-lang/rust/commit/2e8e75f50f87dca154342790ba03401037a3c52e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e8e75f50f87dca154342790ba03401037a3c52e/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da12c4f8e543cecb3c3841bf4a099522950d3b70", "url": "https://api.github.com/repos/rust-lang/rust/commits/da12c4f8e543cecb3c3841bf4a099522950d3b70", "html_url": "https://github.com/rust-lang/rust/commit/da12c4f8e543cecb3c3841bf4a099522950d3b70"}], "stats": {"total": 123, "additions": 78, "deletions": 45}, "files": [{"sha": "fd148062372fe427a10d940418f02262cb34fcdb", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e8e75f50f87dca154342790ba03401037a3c52e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8e75f50f87dca154342790ba03401037a3c52e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=2e8e75f50f87dca154342790ba03401037a3c52e", "patch": "@@ -110,8 +110,12 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         self.unify_receivers(self_ty, method_sig.inputs()[0]);\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n-        let method_ty = self.tcx.mk_fn_ptr(ty::Binder(method_sig));\n-        self.add_obligations(method_ty, all_substs, &method_predicates);\n+        // We won't add these if we encountered an illegal sized bound, so that we can use\n+        // a custom error in that case.\n+        if !rerun {\n+            let method_ty = self.tcx.mk_fn_ptr(ty::Binder(method_sig));\n+            self.add_obligations(method_ty, all_substs, &method_predicates);\n+        }\n \n         // Create the final `MethodCallee`.\n         let callee = MethodCallee {"}, {"sha": "eda17ab02c49594969c08a5b140e2bfdf4ad6b38", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2e8e75f50f87dca154342790ba03401037a3c52e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8e75f50f87dca154342790ba03401037a3c52e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=2e8e75f50f87dca154342790ba03401037a3c52e", "patch": "@@ -60,6 +60,10 @@ pub enum MethodError<'tcx> {\n \n     // Found an applicable method, but it is not visible.\n     PrivateMatch(Def),\n+\n+    // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n+    // forgotten to import a trait.\n+    IllegalSizedBound(Vec<DefId>),\n }\n \n // Contains a list of static methods that may apply, a list of unsatisfied trait predicates which\n@@ -112,6 +116,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Err(Ambiguity(..)) => true,\n             Err(ClosureAmbiguity(..)) => true,\n             Err(PrivateMatch(..)) => allow_private,\n+            Err(IllegalSizedBound(..)) => true,\n         }\n     }\n \n@@ -173,13 +178,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         self_ty,\n                                         call_expr,\n                                         ProbeScope::AllTraits) {\n+\n+                    // If we find a different result the caller probably forgot to import a trait.\n                     Ok(ref new_pick) if *new_pick != pick => vec![new_pick.item.container.id()],\n-                    Err(MethodError::Ambiguity(ref sources)) => {\n+                    Err(Ambiguity(ref sources)) => {\n                         sources.iter()\n                                .filter_map(|source| {\n                                    match *source {\n                                        // Note: this cannot come from an inherent impl,\n-                                       // because the first probe succeeded.\n+                                       // because the first probing succeeded.\n                                        ImplSource(def) => self.tcx.trait_id_of_impl(def),\n                                        TraitSource(_) => None,\n                                    }\n@@ -189,19 +196,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     _ => Vec::new(),\n                 };\n \n-            // If we find a different result, the caller probably forgot to import a trait.\n-            // We span an error with an appropriate help message.\n-            if !candidates.is_empty() {\n-                let error = MethodError::NoMatch(\n-                    NoMatchData::new(Vec::new(), Vec::new(), candidates, probe::Mode::MethodCall)\n-                );\n-                self.report_method_error(span,\n-                                         self_ty,\n-                                         segment.name,\n-                                         Some(self_expr),\n-                                         error,\n-                                         None);\n-            }\n+            return Err(IllegalSizedBound(candidates));\n         }\n \n         Ok(result.callee)"}, {"sha": "c480febdec66f5c35be501f629ea8e409d4e7454", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 49, "deletions": 24, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/2e8e75f50f87dca154342790ba03401037a3c52e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8e75f50f87dca154342790ba03401037a3c52e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=2e8e75f50f87dca154342790ba03401037a3c52e", "patch": "@@ -315,7 +315,42 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let msg = format!(\"{} `{}` is private\", def.kind_name(), item_name);\n                 self.tcx.sess.span_err(span, &msg);\n             }\n+\n+            MethodError::IllegalSizedBound(candidates) => {\n+                let msg = format!(\"the `{}` method cannot be invoked on a trait object\", item_name);\n+                let mut err = self.sess().struct_span_err(span, &msg);\n+                if !candidates.is_empty() {\n+                    let help = format!(\"{an}other candidate{s} {were} found in the following \\\n+                                        trait{s}, perhaps add a `use` for {one_of_them}:\",\n+                                    an = if candidates.len() == 1 {\"an\" } else { \"\" },\n+                                    s = if candidates.len() == 1 { \"\" } else { \"s\" },\n+                                    were = if candidates.len() == 1 { \"was\" } else { \"were\" },\n+                                    one_of_them = if candidates.len() == 1 {\n+                                        \"it\"\n+                                    } else {\n+                                        \"one_of_them\"\n+                                    });\n+                    self.suggest_use_candidates(&mut err, help, candidates);\n+                }\n+                err.emit();\n+            }\n+        }\n+    }\n+\n+    fn suggest_use_candidates(&self,\n+                              err: &mut DiagnosticBuilder,\n+                              mut msg: String,\n+                              candidates: Vec<DefId>) {\n+        let limit = if candidates.len() == 5 { 5 } else { 4 };\n+        for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n+            msg.push_str(&format!(\"\\ncandidate #{}: `use {};`\",\n+                                    i + 1,\n+                                    self.tcx.item_path_str(*trait_did)));\n+        }\n+        if candidates.len() > limit {\n+            msg.push_str(&format!(\"\\nand {} others\", candidates.len() - limit));\n         }\n+        err.note(&msg[..]);\n     }\n \n     fn suggest_traits_to_import(&self,\n@@ -330,30 +365,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             candidates.sort();\n             candidates.dedup();\n             err.help(\"items from traits can only be used if the trait is in scope\");\n-            let mut msg = format!(\"the following {traits_are} implemented but not in scope, \\\n-                                   perhaps add a `use` for {one_of_them}:\",\n-                              traits_are = if candidates.len() == 1 {\n-                                  \"trait is\"\n-                              } else {\n-                                  \"traits are\"\n-                              },\n-                              one_of_them = if candidates.len() == 1 {\n-                                  \"it\"\n-                              } else {\n-                                  \"one of them\"\n-                              });\n-\n-            let limit = if candidates.len() == 5 { 5 } else { 4 };\n-            for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n-                msg.push_str(&format!(\"\\ncandidate #{}: `use {};`\",\n-                                      i + 1,\n-                                      self.tcx.item_path_str(*trait_did)));\n-            }\n-            if candidates.len() > limit {\n-                msg.push_str(&format!(\"\\nand {} others\", candidates.len() - limit));\n-            }\n-            err.note(&msg[..]);\n-\n+            let msg = format!(\"the following {traits_are} implemented but not in scope, \\\n+                               perhaps add a `use` for {one_of_them}:\",\n+                            traits_are = if candidates.len() == 1 {\n+                                \"trait is\"\n+                            } else {\n+                                \"traits are\"\n+                            },\n+                            one_of_them = if candidates.len() == 1 {\n+                                \"it\"\n+                            } else {\n+                                \"one of them\"\n+                            });\n+\n+            self.suggest_use_candidates(err, msg, candidates);\n             return;\n         }\n "}, {"sha": "169d7b55916706e45a43af982a9e64cca5785abd", "filename": "src/test/ui/issue-35976.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e8e75f50f87dca154342790ba03401037a3c52e/src%2Ftest%2Fui%2Fissue-35976.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8e75f50f87dca154342790ba03401037a3c52e/src%2Ftest%2Fui%2Fissue-35976.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-35976.rs?ref=2e8e75f50f87dca154342790ba03401037a3c52e", "patch": "@@ -22,10 +22,8 @@ mod private {\n \n fn bar(arg: Box<private::Future>) {\n     arg.wait();\n-    //~^ ERROR no method named `wait` found for type `std::boxed::Box<private::Future + 'static>`\n-    //~| the following trait is implemented but not in scope\n-    //~| ERROR the trait bound `private::Future + 'static: std::marker::Sized` is not satisfied\n-    //~| `private::Future + 'static` does not have a constant size known at compile-time\n+    //~^ ERROR the `wait` method cannot be invoked on a trait object\n+    //~| another candidate was found in the following trait, perhaps add a `use` for it:\n }\n \n fn main() {", "previous_filename": "src/test/compile-fail/issue-35976.rs"}, {"sha": "9fb67449734bc6615ed592cd99f84d27c93d0d2a", "filename": "src/test/ui/issue-35976.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2e8e75f50f87dca154342790ba03401037a3c52e/src%2Ftest%2Fui%2Fissue-35976.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e8e75f50f87dca154342790ba03401037a3c52e/src%2Ftest%2Fui%2Fissue-35976.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-35976.stderr?ref=2e8e75f50f87dca154342790ba03401037a3c52e", "patch": "@@ -0,0 +1,11 @@\n+error: the `wait` method cannot be invoked on a trait object\n+  --> $DIR/issue-35976.rs:24:9\n+   |\n+24 |     arg.wait();\n+   |         ^^^^\n+   |\n+   = note: another candidate was found in the following trait, perhaps add a `use` for it:\n+           candidate #1: `use private::Future;`\n+\n+error: aborting due to previous error\n+"}]}