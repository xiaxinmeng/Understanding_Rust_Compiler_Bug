{"sha": "81534496dc3356d5794300d513be200f939350c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNTM0NDk2ZGMzMzU2ZDU3OTQzMDBkNTEzYmUyMDBmOTM5MzUwYzc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-30T15:46:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-01T07:58:03Z"}, "message": "rename RefKind to UsageKind, because it not only used for references now", "tree": {"sha": "84abed1227fd9c3507e814865380c67f92095aec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84abed1227fd9c3507e814865380c67f92095aec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81534496dc3356d5794300d513be200f939350c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81534496dc3356d5794300d513be200f939350c7", "html_url": "https://github.com/rust-lang/rust/commit/81534496dc3356d5794300d513be200f939350c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81534496dc3356d5794300d513be200f939350c7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "478f137c39b827e6de39056b5c27a8e5d797aa4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/478f137c39b827e6de39056b5c27a8e5d797aa4d", "html_url": "https://github.com/rust-lang/rust/commit/478f137c39b827e6de39056b5c27a8e5d797aa4d"}], "stats": {"total": 150, "additions": 84, "deletions": 66}, "files": [{"sha": "5a3e1c7cab0540050f614e360b43e54083e002e3", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -48,7 +48,7 @@ use mono_hash_map::MonoHashMap;\n use stacked_borrows::{EvalContextExt as StackedBorEvalContextExt};\n \n // Used by priroda\n-pub use stacked_borrows::{Borrow, Stacks, Mut as MutBorrow};\n+pub use stacked_borrows::{Borrow, Stack, Stacks, Mut as MutBorrow, BorStackItem};\n \n /// Insert rustc arguments at the beginning of the argument listthat miri wants to be\n /// set per default, for maximal validation power."}, {"sha": "d520c6ff5d47b1a3e361acfb978d6b7426c9cdfd", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 68, "deletions": 50, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -64,6 +64,12 @@ impl Borrow {\n     }\n }\n \n+impl Default for Borrow {\n+    fn default() -> Self {\n+        Borrow::Mut(Mut::Raw)\n+    }\n+}\n+\n /// An item in the borrow stack\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum BorStackItem {\n@@ -74,26 +80,33 @@ pub enum BorStackItem {\n     FnBarrier(usize)\n }\n \n-impl Default for Borrow {\n-    fn default() -> Self {\n-        Borrow::Mut(Mut::Raw)\n+impl BorStackItem {\n+    #[inline(always)]\n+    pub fn is_fn_barrier(self) -> bool {\n+        match self {\n+            BorStackItem::FnBarrier(_) => true,\n+            _ => false,\n+        }\n     }\n }\n \n-/// What kind of reference are we talking about?\n+/// What kind of usage of the pointer are we talking about?\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum RefKind {\n-    Mut,\n-    Shr,\n+pub enum UsageKind {\n+    /// Write, or create &mut\n+    Write,\n+    /// Read, or create &\n+    Read,\n+    /// Create *\n     Raw,\n }\n \n-impl From<Option<hir::Mutability>> for RefKind {\n+impl From<Option<hir::Mutability>> for UsageKind {\n     fn from(mutbl: Option<hir::Mutability>) -> Self {\n         match mutbl {\n-            None => RefKind::Raw,\n-            Some(hir::MutMutable) => RefKind::Mut,\n-            Some(hir::MutImmutable) => RefKind::Shr,\n+            None => UsageKind::Raw,\n+            Some(hir::MutMutable) => UsageKind::Write,\n+            Some(hir::MutImmutable) => UsageKind::Read,\n         }\n     }\n }\n@@ -112,7 +125,7 @@ impl State {\n \n /// Extra per-location state\n #[derive(Clone, Debug)]\n-struct Stack {\n+pub struct Stack {\n     borrows: Vec<BorStackItem>, // used as a stack\n     frozen_since: Option<Timestamp>,\n }\n@@ -143,17 +156,17 @@ pub struct Stacks {\n /// Core operations\n impl<'tcx> Stack {\n     /// Check if `bor` could be activated by unfreezing and popping.\n-    /// `ref_kind` indicates whether this is being used to read/write (or, equivalently, to\n+    /// `usage` indicates whether this is being used to read/write (or, equivalently, to\n     /// borrow as &/&mut), or to borrow as raw.\n     /// Returns `Err` if the answer is \"no\"; otherwise the data says\n     /// what needs to happen to activate this: `None` = nothing,\n     /// `Some(n)` = unfreeze and make item `n` the top item of the stack.\n-    fn reactivatable(&self, bor: Borrow, ref_kind: RefKind) -> Result<Option<usize>, String> {\n+    fn reactivatable(&self, bor: Borrow, usage: UsageKind) -> Result<Option<usize>, String> {\n         let mut_borrow = match bor {\n             Borrow::Frz(since) =>\n                 // The only way to reactivate a `Frz` is if this is already frozen.\n                 return match self.frozen_since {\n-                    _ if ref_kind == RefKind::Mut =>\n+                    _ if usage == UsageKind::Write =>\n                         Err(format!(\"Using a shared borrow for mutation\")),\n                     None =>\n                         Err(format!(\"Location should be frozen but it is not\")),\n@@ -163,10 +176,11 @@ impl<'tcx> Stack {\n                         Err(format!(\"Location should be frozen since {} but it is only frozen \\\n                                      since {}\", since, loc)),\n                 },\n-            Borrow::Mut(Mut::Raw) if self.is_frozen() && ref_kind != RefKind::Mut =>\n+            Borrow::Mut(Mut::Raw) if self.is_frozen() && usage != UsageKind::Write =>\n                 // Non-mutating access with a raw from a frozen location is a special case: The\n                 // shared refs do not mind raw reads, and the raw itself does not assume any\n-                // exclusivity. So we do not even require there to be a raw on the stack.\n+                // exclusivity. So we do not even require there to be a raw on the stack,\n+                // the raw is instead \"matched\" by the fact that this location is frozen.\n                 // This does not break the assumption that an `&mut` we own is\n                 // exclusive for reads, because there we have the invariant that\n                 // the location is *not* frozen.\n@@ -183,7 +197,7 @@ impl<'tcx> Stack {\n                     if loc == mut_borrow {\n                         // We found it!  This is good to know.\n                         // Yet, maybe we do not really want to pop?\n-                        if ref_kind == RefKind::Shr && self.is_frozen() {\n+                        if usage == UsageKind::Read && self.is_frozen() {\n                             // Whoever had exclusive access to this location allowed it\n                             // to become frozen.  That can only happen if they reborrowed\n                             // to a shared ref, at which point they gave up on exclusive access.\n@@ -204,10 +218,10 @@ impl<'tcx> Stack {\n         Err(format!(\"Mutable borrow-to-reactivate ({:?}) does not exist on the stack\", mut_borrow))\n     }\n \n-    /// Reactive `bor` for this stack.  `ref_kind` indicates whether this is being\n+    /// Reactive `bor` for this stack.  `usage` indicates whether this is being\n     /// used to read/write (or, equivalently, to borrow as &/&mut), or to borrow as raw.\n-    fn reactivate(&mut self, bor: Borrow, ref_kind: RefKind) -> EvalResult<'tcx> {\n-        let action = match self.reactivatable(bor, ref_kind) {\n+    fn reactivate(&mut self, bor: Borrow, usage: UsageKind) -> EvalResult<'tcx> {\n+        let action = match self.reactivatable(bor, usage) {\n             Ok(action) => action,\n             Err(err) => return err!(MachineError(err)),\n         };\n@@ -274,20 +288,20 @@ impl State {\n \n /// Higher-level operations\n impl<'tcx> Stacks {\n-    /// The single most operation: Make sure that using `ptr` as `ref_kind` is okay,\n+    /// The single most operation: Make sure that using `ptr` as `usage` is okay,\n     /// and if `new_bor` is present then make that the new current borrow.\n     fn use_and_maybe_re_borrow(\n         &self,\n         ptr: Pointer<Borrow>,\n         size: Size,\n-        ref_kind: RefKind,\n+        usage: UsageKind,\n         new_bor: Option<Borrow>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"use_and_maybe_re_borrow of tag {:?} as {:?}, new {:?}: {:?}, size {}\",\n-            ptr.tag, ref_kind, new_bor, ptr, size.bytes());\n+            ptr.tag, usage, new_bor, ptr, size.bytes());\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.reactivate(ptr.tag, ref_kind)?;\n+            stack.reactivate(ptr.tag, usage)?;\n             if let Some(new_bor) = new_bor {\n                 stack.initiate(new_bor);\n             }\n@@ -303,7 +317,7 @@ impl<'tcx> Stacks {\n         size: Size,\n     ) -> EvalResult<'tcx> {\n         // Reads behave exactly like the first half of a reborrow-to-shr\n-        self.use_and_maybe_re_borrow(ptr, size, RefKind::Shr, None)\n+        self.use_and_maybe_re_borrow(ptr, size, UsageKind::Read, None)\n     }\n \n     #[inline(always)]\n@@ -313,7 +327,7 @@ impl<'tcx> Stacks {\n         size: Size,\n     ) -> EvalResult<'tcx> {\n         // Writes behave exactly like the first half of a reborrow-to-mut\n-        self.use_and_maybe_re_borrow(ptr, size, RefKind::Mut, None)\n+        self.use_and_maybe_re_borrow(ptr, size, UsageKind::Write, None)\n     }\n \n     pub fn memory_deallocated(\n@@ -322,7 +336,7 @@ impl<'tcx> Stacks {\n         size: Size,\n     ) -> EvalResult<'tcx> {\n         // This is like mutating\n-        self.use_and_maybe_re_borrow(ptr, size, RefKind::Mut, None)\n+        self.use_and_maybe_re_borrow(ptr, size, UsageKind::Write, None)\n         // FIXME: Error out of there are any barriers?\n     }\n \n@@ -346,7 +360,7 @@ pub trait EvalContextExt<'tcx> {\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        ref_kind: RefKind,\n+        usage: UsageKind,\n     ) -> EvalResult<'tcx, Borrow>;\n \n \n@@ -355,7 +369,7 @@ pub trait EvalContextExt<'tcx> {\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        ref_kind: RefKind,\n+        usage: UsageKind,\n     ) -> EvalResult<'tcx, Borrow>;\n \n     fn tag_new_allocation(\n@@ -378,12 +392,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        ref_kind: RefKind,\n+        usage: UsageKind,\n     ) -> EvalResult<'tcx, Borrow> {\n         let time = self.machine.stacked_borrows.increment_clock();\n-        let new_bor = match ref_kind {\n-            RefKind::Mut => Borrow::Mut(Mut::Uniq(time)),\n-            RefKind::Shr =>\n+        let new_bor = match usage {\n+            UsageKind::Write => Borrow::Mut(Mut::Uniq(time)),\n+            UsageKind::Read =>\n                 // FIXME This does not do enough checking when only part of the data has\n                 // interior mutability. When the type is `(i32, Cell<i32>)`, we want the\n                 // first field to be frozen but not the second.\n@@ -393,18 +407,18 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                     // Shared reference with interior mutability.\n                     Borrow::Mut(Mut::Raw)\n                 },\n-            RefKind::Raw => Borrow::Mut(Mut::Raw),\n+            UsageKind::Raw => Borrow::Mut(Mut::Raw),\n         };\n         trace!(\"tag_reference: Creating new reference ({:?}) for {:?} (pointee {}, size {}): {:?}\",\n-            ref_kind, ptr, pointee_ty, size.bytes(), new_bor);\n+            usage, ptr, pointee_ty, size.bytes(), new_bor);\n \n         // Make sure this reference is not dangling or so\n         self.memory().check_bounds(ptr, size, false)?;\n \n         // Update the stacks.  We cannot use `get_mut` becuse this might be immutable\n         // memory.\n         let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        alloc.extra.use_and_maybe_re_borrow(ptr, size, ref_kind, Some(new_bor))?;\n+        alloc.extra.use_and_maybe_re_borrow(ptr, size, usage, Some(new_bor))?;\n \n         Ok(new_bor)\n     }\n@@ -418,39 +432,39 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        ref_kind: RefKind,\n+        usage: UsageKind,\n     ) -> EvalResult<'tcx, Borrow> {\n         trace!(\"tag_reference: Accessing reference ({:?}) for {:?} (pointee {}, size {})\",\n-            ref_kind, ptr, pointee_ty, size.bytes());\n+            usage, ptr, pointee_ty, size.bytes());\n         // In principle we should not have to do anything here.  However, with transmutes involved,\n-        // it can happen that the tag of `ptr` does not actually match `ref_kind`, and we\n+        // it can happen that the tag of `ptr` does not actually match `usage`, and we\n         // should adjust for that.\n         // Notably, the compiler can introduce such transmutes by optimizing away `&[mut]*`.\n         // That can transmute a raw ptr to a (shared/mut) ref, and a mut ref to a shared one.\n-        match (ref_kind, ptr.tag) {\n-            (RefKind::Raw, _) => {\n+        match (usage, ptr.tag) {\n+            (UsageKind::Raw, _) => {\n                 // Don't use the tag, this is a raw access!  Even if there is a tag,\n                 // that means transmute happened and we ignore the tag.\n                 // Also don't do any further validation, this is raw after all.\n                 return Ok(Borrow::Mut(Mut::Raw));\n             }\n-            (RefKind::Mut, Borrow::Mut(Mut::Uniq(_))) |\n-            (RefKind::Shr, Borrow::Frz(_)) |\n-            (RefKind::Shr, Borrow::Mut(Mut::Raw)) => {\n+            (UsageKind::Write, Borrow::Mut(Mut::Uniq(_))) |\n+            (UsageKind::Read, Borrow::Frz(_)) |\n+            (UsageKind::Read, Borrow::Mut(Mut::Raw)) => {\n                 // Expected combinations.  Nothing to do.\n                 // FIXME: We probably shouldn't accept this if we got a raw shr without\n                 // interior mutability.\n             }\n-            (RefKind::Mut, Borrow::Mut(Mut::Raw)) => {\n+            (UsageKind::Write, Borrow::Mut(Mut::Raw)) => {\n                 // Raw transmuted to mut ref.  Keep this as raw access.\n                 // We cannot reborrow here; there might be a raw in `&(*var).1` where\n                 // `var` is an `&mut`.  The other field of the struct might be already frozen,\n                 // also using `var`, and that would be okay.\n             }\n-            (RefKind::Shr, Borrow::Mut(Mut::Uniq(_))) => {\n+            (UsageKind::Read, Borrow::Mut(Mut::Uniq(_))) => {\n                 // A mut got transmuted to shr.  The mut borrow must be reactivatable.\n             }\n-            (RefKind::Mut, Borrow::Frz(_)) => {\n+            (UsageKind::Write, Borrow::Frz(_)) => {\n                 // This is just invalid.\n                 // If we ever allow this, we have to consider what we do when a turn a\n                 // `Raw`-tagged `&mut` into a raw pointer pointing to a frozen location.\n@@ -467,8 +481,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         // We need `iter_mut` because `iter` would skip gaps!\n         for stack in stacks.iter_mut(ptr.offset, size) {\n             // Conservatively assume that we will only read.\n-            if let Err(err) = stack.reactivatable(ptr.tag, RefKind::Shr) {\n-                return err!(MachineError(format!(\"Encountered {:?} reference with non-reactivatable tag: {}\", ref_kind, err)))\n+            if let Err(err) = stack.reactivatable(ptr.tag, UsageKind::Read) {\n+                return err!(MachineError(format!(\n+                    \"Encountered {} reference with non-reactivatable tag: {}\",\n+                    if usage == UsageKind::Write { \"mutable\" } else { \"shared\" },\n+                    err\n+                )))\n             }\n         }\n         // All is good."}, {"sha": "0b2d459366ceb56857e7d696d41ef046521a01b5", "filename": "tests/compile-fail/stacked_borrows/alias_through_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -11,5 +11,5 @@ fn main() {\n     retarget(&mut target_alias, target);\n     // now `target_alias` points to the same thing as `target`\n     *target = 13;\n-    let _val = *target_alias; //~ ERROR Shr reference with non-reactivatable tag\n+    let _val = *target_alias; //~ ERROR reference with non-reactivatable tag\n }"}, {"sha": "2c48404ddf364bbd010cdf1a6dd4e84fe52e2c8a", "filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -14,6 +14,6 @@ fn main() {\n     let v = vec![0,1,2];\n     let v1 = safe::as_mut_slice(&v);\n     let v2 = safe::as_mut_slice(&v);\n-    v1[1] = 5; //~ ERROR Mut reference with non-reactivatable tag\n+    v1[1] = 5; //~ ERROR reference with non-reactivatable tag\n     v1[1] = 6;\n }"}, {"sha": "d8a241cab5d49265323c4442a68437fefd236fb8", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -11,7 +11,7 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            //~^ ERROR Mut reference with non-reactivatable tag\n+            //~^ ERROR reference with non-reactivatable tag\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }"}, {"sha": "59190a15db440608710bf4ef199b63effaa14e8e", "filename": "tests/compile-fail/stacked_borrows/illegal_read1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: Mut reference with non-reactivatable tag\n+    //~^ ERROR: mutable reference with non-reactivatable tag\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "594117d28ab84c54ba721248c905fe8b56105a9a", "filename": "tests/compile-fail/stacked_borrows/illegal_read2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: Mut reference with non-reactivatable tag\n+    //~^ ERROR: mutable reference with non-reactivatable tag\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "ab951be5ec911b5221f77fe46a7cbce699704437", "filename": "tests/compile-fail/stacked_borrows/illegal_write1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -8,5 +8,5 @@ fn main() {\n     let target = Box::new(42); // has an implicit raw\n     let ref_ = &*target;\n     evil(ref_); // invalidates shared ref, activates raw\n-    let _x = *ref_; //~ ERROR Shr reference with non-reactivatable tag\n+    let _x = *ref_; //~ ERROR reference with non-reactivatable tag\n }"}, {"sha": "f4704ad57161f37529ca04bada9247c412c6808f", "filename": "tests/compile-fail/stacked_borrows/illegal_write5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: Mut reference with non-reactivatable tag\n+    //~^ ERROR: reference with non-reactivatable tag\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "4ea61cd606fff88ea5bbc3194b1f73e9b3436b64", "filename": "tests/compile-fail/stacked_borrows/load_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xref = unsafe { &mut *xraw };\n     let xref_in_mem = Box::new(xref);\n     let _val = *x; // invalidate xraw\n-    let _val = *xref_in_mem; //~ ERROR Mut reference with non-reactivatable tag\n+    let _val = *xref_in_mem; //~ ERROR mutable reference with non-reactivatable tag\n }"}, {"sha": "53179c954dea28bf488c0d7f9b799fa8efa0e809", "filename": "tests/compile-fail/stacked_borrows/load_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xref = unsafe { &*xraw };\n     let xref_in_mem = Box::new(xref);\n     *x = 42; // invalidate xraw\n-    let _val = *xref_in_mem; //~ ERROR Shr reference with non-reactivatable tag: Location should be frozen\n+    let _val = *xref_in_mem; //~ ERROR shared reference with non-reactivatable tag: Location should be frozen\n }"}, {"sha": "5e1118160a327d9069e5bbe3d6645630b8eefc9c", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &mut *xraw };\n     let _val = *x; // invalidate xraw\n-    foo(xref); //~ ERROR Mut reference with non-reactivatable tag\n+    foo(xref); //~ ERROR mutable reference with non-reactivatable tag\n }"}, {"sha": "e4b26cfff6da421127e50893dd75897981797147", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let xraw = &*x as *const _;\n     let xref = unsafe { &*xraw };\n     *x = 42; // invalidate xraw\n-    foo(xref); //~ ERROR Shr reference with non-reactivatable tag: Location should be frozen\n+    foo(xref); //~ ERROR shared reference with non-reactivatable tag: Location should be frozen\n }"}, {"sha": "949b3829ff8fe301a90a127f0e9d00e1e03329a2", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> &mut i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 };\n     let _val = *x; // invalidate xraw and its children\n-    ret //~ ERROR Mut reference with non-reactivatable tag\n+    ret //~ ERROR mutable reference with non-reactivatable tag\n }\n \n fn main() {"}, {"sha": "2d34350359d13573ade633f46c9a095161d732d2", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> &i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &(*xraw).1 };\n     x.1 = 42; // invalidate xraw on the 2nd field\n-    ret //~ ERROR Shr reference with non-reactivatable tag: Location should be frozen\n+    ret //~ ERROR shared reference with non-reactivatable tag: Location should be frozen\n }\n \n fn main() {"}, {"sha": "624587932cb83ac8ff23cd256b0262bd4623d5d1", "filename": "tests/compile-fail/stacked_borrows/shared_confusion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -21,7 +21,7 @@ fn test(r: &mut RefCell<i32>) {\n     }\n     // Our old raw should be dead by now\n     unsafe { *x_evil = 0; } // this falls back to some Raw higher up the stack\n-    *x_inner = 12; //~ ERROR Mut reference with non-reactivatable tag\n+    *x_inner = 12; //~ ERROR reference with non-reactivatable tag\n }\n \n fn main() {"}, {"sha": "3030f5dd4001b9f696a226287d96188c42aef0ee", "filename": "tests/compile-fail/stacked_borrows/shared_confusion_opt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion_opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81534496dc3356d5794300d513be200f939350c7/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion_opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion_opt.rs?ref=81534496dc3356d5794300d513be200f939350c7", "patch": "@@ -17,7 +17,7 @@ fn test(r: &mut RefCell<i32>) {\n     }\n     // Our old raw should be dead by now\n     unsafe { *x_evil = 0; } // this falls back to some Raw higher up the stack\n-    *x_inner = 12; //~ ERROR Mut reference with non-reactivatable tag\n+    *x_inner = 12; //~ ERROR reference with non-reactivatable tag\n }\n \n fn main() {"}]}