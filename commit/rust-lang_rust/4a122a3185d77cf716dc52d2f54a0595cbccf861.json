{"sha": "4a122a3185d77cf716dc52d2f54a0595cbccf861", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMTIyYTMxODVkNzdjZjcxNmRjNTJkMmY1NGEwNTk1Y2JjY2Y4NjE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-05-01T13:17:36Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-05-02T15:45:17Z"}, "message": "Updated maybe_owned_vec with review feedback.\n\nNamely:\n\n * Added conversion traits both to and from the various vector types,\n   analogous to how `str::MaybeOwned` works with `str::IntoMaybeOwned`\n   and `str::Str`.  This led me to add the `FixedLen` variant of\n   `MaybeOwnedVector` for interoperability with `std::slice`.\n\n * Revised client example code to make use of `into_maybe_owned`\n\n * Added implementations of `Show` and `CloneableVector` for\n   `MaybeOwnedVector`.\n\n * As suggested by kballard, added `into_vec` method that is analogous\n   to `CloneableVector::into_owned` except it produces a `Vec` rather\n   than a `~[T]`.", "tree": {"sha": "dfbf6dedfbe40618fedb99405410b67c222fd3bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfbf6dedfbe40618fedb99405410b67c222fd3bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a122a3185d77cf716dc52d2f54a0595cbccf861", "comment_count": 8, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a122a3185d77cf716dc52d2f54a0595cbccf861", "html_url": "https://github.com/rust-lang/rust/commit/4a122a3185d77cf716dc52d2f54a0595cbccf861", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a122a3185d77cf716dc52d2f54a0595cbccf861/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7374182f7298183f261a0905ac10f5c8c9701ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7374182f7298183f261a0905ac10f5c8c9701ad", "html_url": "https://github.com/rust-lang/rust/commit/b7374182f7298183f261a0905ac10f5c8c9701ad"}], "stats": {"total": 122, "additions": 96, "deletions": 26}, "files": [{"sha": "dff286ed8111cd3a6624e955222e9fa33cc80479", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4a122a3185d77cf716dc52d2f54a0595cbccf861/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a122a3185d77cf716dc52d2f54a0595cbccf861/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=4a122a3185d77cf716dc52d2f54a0595cbccf861", "patch": "@@ -10,7 +10,7 @@\n \n /*! Generate files suitable for use with [Graphviz](http://www.graphviz.org/)\n \n-The `render` function generates output (e.g. a `output.dot` file) for\n+The `render` function generates output (e.g. an `output.dot` file) for\n use with [Graphviz](http://www.graphviz.org/) by walking a labelled\n graph. (Graphviz can then automatically lay out the nodes and edges\n of the graph, and also optionally render the graph as an image or\n@@ -37,16 +37,18 @@ pairs of ints, representing the edges (the node set is implicit).\n Each node label is derived directly from the int representing the node,\n while the edge labels are all empty strings.\n \n-This example also illustrates how to use the `Borrowed` variant of\n-`MaybeOwnedVector` to return a slice into the edge list, rather than\n-constructing a copy from scratch.\n+This example also illustrates how to use `MaybeOwnedVector` to return\n+an owned vector or a borrowed slice as appropriate: we construct the\n+node vector from scratch, but borrow the edge list (rather than\n+constructing a copy of all the edges from scratch).\n \n The output from this example renders five nodes, with the first four\n forming a diamond-shaped acyclic graph and then pointing to the fifth\n which is cyclic.\n \n ```rust\n use dot = graphviz;\n+use graphviz::maybe_owned_vec::IntoMaybeOwnedVector;\n \n type Nd = int;\n type Ed = (int,int);\n@@ -77,12 +79,12 @@ impl<'a> dot::GraphWalk<'a, Nd, Ed> for Edges {\n         }\n         nodes.sort();\n         nodes.dedup();\n-        nodes.move_iter().collect()\n+        nodes.into_maybe_owned()\n     }\n \n     fn edges(&'a self) -> dot::Edges<'a,Ed> {\n         let &Edges(ref edges) = self;\n-        dot::maybe_owned_vec::Borrowed(edges.as_slice())\n+        edges.as_slice().into_maybe_owned()\n     }\n \n     fn source(&self, e: &Ed) -> Nd { let &(s,_) = e; s }\n@@ -119,9 +121,16 @@ This example also illustrates how to use a type (in this case the edge\n type) that shares substructure with the graph: the edge type here is a\n direct reference to the `(source,target)` pair stored in the graph's\n internal vector (rather than passing around a copy of the pair\n-itself). Note that in this case, this implies that `fn edges(&'a\n-self)` must construct a fresh `Vec<&'a (uint,uint)>` from the\n-`Vec<(uint,uint)>` edges stored in `self`.\n+itself). Note that this implies that `fn edges(&'a self)` must\n+construct a fresh `Vec<&'a (uint,uint)>` from the `Vec<(uint,uint)>`\n+edges stored in `self`.\n+\n+Since both the set of nodes and the set of edges are always\n+constructed from scratch via iterators, we use the `collect()` method\n+from the `Iterator` trait to collect the nodes and edges into freshly\n+constructed growable `Vec` values (rather use the `into_maybe_owned`\n+from the `IntoMaybeOwnedVector` trait as was used in the first example\n+above).\n \n The output from this example renders four nodes that make up the\n Hasse-diagram for the subsets of the set `{x, y}`. Each edge is"}, {"sha": "649bad702eaefb34488463a492003a44622d74c9", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 78, "deletions": 17, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4a122a3185d77cf716dc52d2f54a0595cbccf861/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a122a3185d77cf716dc52d2f54a0595cbccf861/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=4a122a3185d77cf716dc52d2f54a0595cbccf861", "patch": "@@ -8,44 +8,69 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::container::Container;\n+use std::fmt;\n use std::iter::FromIterator;\n use std::slice;\n \n-// Note: Once Dynamically Sized Types (DST) lands, this should be\n-// replaced with something like `enum Owned<'a, Sized? U>{ Owned(~U),\n-// Borrowed(&'a U) }`; and then `U` could be instantiated with `[T]`\n-// or `str`, etc.\n+// Note 1: It is not clear whether the flexibility of providing both\n+// the `Growable` and `FixedLen` variants is sufficiently useful.\n+// Consider restricting to just a two variant enum.\n \n-/// MaybeOwnedVector<'a,T> abstracts over `Vec<T>` and `&'a [T]`.\n+// Note 2: Once Dynamically Sized Types (DST) lands, it might be\n+// reasonable to replace this with something like `enum MaybeOwned<'a,\n+// Sized? U>{ Owned(~U), Borrowed(&'a U) }`; and then `U` could be\n+// instantiated with `[T]` or `str`, etc.  Of course, that would imply\n+// removing the `Growable` variant, which relates to note 1 above.\n+// Alternatively, we might add `MaybeOwned` for the general case but\n+// keep some form of `MaybeOwnedVector` to avoid unnecessary copying\n+// of the contents of `Vec<T>`, since we anticipate that to be a\n+// frequent way to dynamically construct a vector.\n+\n+/// MaybeOwnedVector<'a,T> abstracts over `Vec<T>`, `~[T]`, `&'a [T]`.\n ///\n /// Some clients will have a pre-allocated vector ready to hand off in\n /// a slice; others will want to create the set on the fly and hand\n-/// off ownership.\n-#[deriving(Eq)]\n+/// off ownership, via either `Growable` or `FixedLen` depending on\n+/// which kind of vector they have constucted.  (The `FixedLen`\n+/// variant is provided for interoperability with `std::slice` methods\n+/// that return `~[T]`.)\n pub enum MaybeOwnedVector<'a,T> {\n     Growable(Vec<T>),\n+    FixedLen(~[T]),\n     Borrowed(&'a [T]),\n }\n \n+/// Trait for moving into a `MaybeOwnedVector`\n+pub trait IntoMaybeOwnedVector<'a,T> {\n+    /// Moves self into a `MaybeOwnedVector`\n+    fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T>;\n+}\n+\n+impl<'a,T> IntoMaybeOwnedVector<'a,T> for Vec<T> {\n+    #[inline]\n+    fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { Growable(self) }\n+}\n+\n+impl<'a,T> IntoMaybeOwnedVector<'a,T> for ~[T] {\n+    #[inline]\n+    fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { FixedLen(self) }\n+}\n+\n+impl<'a,T> IntoMaybeOwnedVector<'a,T> for &'a [T] {\n+    #[inline]\n+    fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { Borrowed(self) }\n+}\n+\n impl<'a,T> MaybeOwnedVector<'a,T> {\n     pub fn iter(&'a self) -> slice::Items<'a,T> {\n         match self {\n             &Growable(ref v) => v.iter(),\n+            &FixedLen(ref v) => v.iter(),\n             &Borrowed(ref v) => v.iter(),\n         }\n     }\n }\n \n-impl<'a,T> Container for MaybeOwnedVector<'a,T> {\n-    fn len(&self) -> uint {\n-        match self {\n-            &Growable(ref v) => v.len(),\n-            &Borrowed(ref v) => v.len(),\n-        }\n-    }\n-}\n-\n // The `Vector` trait is provided in the prelude and is implemented on\n // both `&'a [T]` and `Vec<T>`, so it makes sense to try to support it\n // seamlessly.  The other vector related traits from the prelude do\n@@ -59,13 +84,49 @@ impl<'b,T> slice::Vector<T> for MaybeOwnedVector<'b,T> {\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match self {\n             &Growable(ref v) => v.as_slice(),\n+            &FixedLen(ref v) => v.as_slice(),\n             &Borrowed(ref v) => v.as_slice(),\n         }\n     }\n }\n \n impl<'a,T> FromIterator<T> for MaybeOwnedVector<'a,T> {\n     fn from_iter<I:Iterator<T>>(iterator: I) -> MaybeOwnedVector<T> {\n+        // If we are building from scratch, might as well build the\n+        // most flexible variant.\n         Growable(FromIterator::from_iter(iterator))\n     }\n }\n+\n+impl<'a,T:fmt::Show> fmt::Show for MaybeOwnedVector<'a,T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.as_slice().fmt(f)\n+    }\n+}\n+\n+impl<'a,T:Clone> CloneableVector<T> for MaybeOwnedVector<'a,T> {\n+    /// Returns a copy of `self`.\n+    fn to_owned(&self) -> ~[T] {\n+        self.as_slice().to_owned()\n+    }\n+\n+    /// Convert `self` into an owned slice, not making a copy if possible.\n+    fn into_owned(self) -> ~[T] {\n+        match self {\n+            Growable(v) => v.as_slice().to_owned(),\n+            FixedLen(v) => v,\n+            Borrowed(v) => v.to_owned(),\n+        }\n+    }\n+}\n+\n+impl<'a,T:Clone> MaybeOwnedVector<'a,T> {\n+    /// Convert `self` into a growable `Vec`, not making a copy if possible.\n+    pub fn into_vec(self) -> Vec<T> {\n+        match self {\n+            Growable(v) => v,\n+            FixedLen(v) => Vec::from_slice(v.as_slice()),\n+            Borrowed(v) => Vec::from_slice(v),\n+        }\n+    }\n+}"}]}