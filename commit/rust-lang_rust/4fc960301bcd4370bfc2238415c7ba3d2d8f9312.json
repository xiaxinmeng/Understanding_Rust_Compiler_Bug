{"sha": "4fc960301bcd4370bfc2238415c7ba3d2d8f9312", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmYzk2MDMwMWJjZDQzNzBiZmMyMjM4NDE1YzdiYTNkMmQ4ZjkzMTI=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-03-10T22:04:12Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-05-05T16:38:26Z"}, "message": "Metadata collection: Rounding up the implementation", "tree": {"sha": "3359689077110144d7dd56042c32f1389fae3699", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3359689077110144d7dd56042c32f1389fae3699"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fc960301bcd4370bfc2238415c7ba3d2d8f9312", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fc960301bcd4370bfc2238415c7ba3d2d8f9312", "html_url": "https://github.com/rust-lang/rust/commit/4fc960301bcd4370bfc2238415c7ba3d2d8f9312", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fc960301bcd4370bfc2238415c7ba3d2d8f9312/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35844d0a48e0a644072ae81857782a6e0bd54740", "url": "https://api.github.com/repos/rust-lang/rust/commits/35844d0a48e0a644072ae81857782a6e0bd54740", "html_url": "https://github.com/rust-lang/rust/commit/35844d0a48e0a644072ae81857782a6e0bd54740"}], "stats": {"total": 5992, "additions": 88, "deletions": 5904}, "files": [{"sha": "523bab1882836e9ddc5c0c6c81db7c0733f2bfdf", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fc960301bcd4370bfc2238415c7ba3d2d8f9312/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/4fc960301bcd4370bfc2238415c7ba3d2d8f9312/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=4fc960301bcd4370bfc2238415c7ba3d2d8f9312", "patch": "@@ -29,7 +29,7 @@ out\n \n # gh pages docs\n util/gh-pages/lints.json\n-# **/metadata_collection.json\n+**/metadata_collection.json\n \n # rustfmt backups\n *.rs.bk"}, {"sha": "37e90bf8686f4f355f235a315b0c898a24bddd14", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 84, "deletions": 68, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4fc960301bcd4370bfc2238415c7ba3d2d8f9312/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fc960301bcd4370bfc2238415c7ba3d2d8f9312/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=4fc960301bcd4370bfc2238415c7ba3d2d8f9312", "patch": "@@ -7,34 +7,21 @@\n //! The module transforms all lint names to ascii lowercase to ensure that we don't have mismatches\n //! during any comparison or mapping. (Please take care of this, it's not fun to spend time on such\n //! a simple mistake)\n-//!\n-//! The metadata currently contains:\n-//! - [x] TODO The lint declaration line for [#1303](https://github.com/rust-lang/rust-clippy/issues/1303)\n-//!   and [#6492](https://github.com/rust-lang/rust-clippy/issues/6492)\n-//! - [ ] TODO The Applicability for each lint for [#4310](https://github.com/rust-lang/rust-clippy/issues/4310)\n-\n-// # Applicability\n-// - TODO xFrednet 2021-01-17: Find lint emit and collect applicability\n-//   - TODO xFrednet 2021-02-28:  4x weird emission forwarding\n-//     - See clippy_lints/src/enum_variants.rs@EnumVariantNames::check_name\n-//   - TODO xFrednet 2021-02-28:  6x emission forwarding with local that is initializes from\n-//     function.\n-//     - See clippy_lints/src/methods/mod.rs@lint_binary_expr_with_method_call\n-//   - TODO xFrednet 2021-02-28:  2x lint from local from function call\n-//     - See clippy_lints/src/misc.rs@check_binary\n-//   - TODO xFrednet 2021-02-28:  2x lint from local from method call\n-//     - See clippy_lints/src/non_copy_const.rs@lint\n+\n // # NITs\n // - TODO xFrednet 2021-02-13: Collect depreciations and maybe renames\n \n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::{self as hir, intravisit, intravisit::Visitor, ExprKind, Item, ItemKind, Mutability, QPath, def::DefKind};\n+use rustc_hir::{\n+    self as hir, def::DefKind, intravisit, intravisit::Visitor, ExprKind, Item, ItemKind, Mutability, QPath,\n+};\n use rustc_lint::{CheckLintNameResult, LateContext, LateLintPass, LintContext, LintId};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Loc, Span, Symbol};\n-use serde::Serialize;\n+use serde::{ser::SerializeStruct, Serialize, Serializer};\n+use std::collections::BinaryHeap;\n use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n use std::path::Path;\n@@ -47,7 +34,7 @@ use crate::utils::{\n /// This is the output file of the lint collector.\n const OUTPUT_FILE: &str = \"../metadata_collection.json\";\n /// These lints are excluded from the export.\n-const BLACK_LISTED_LINTS: [&str; 2] = [\"lint_author\", \"deep_code_inspection\"];\n+const BLACK_LISTED_LINTS: [&str; 3] = [\"lint_author\", \"deep_code_inspection\", \"internal_metadata_collector\"];\n /// These groups will be ignored by the lint group matcher. This is useful for collections like\n /// `clippy::all`\n const IGNORED_LINT_GROUPS: [&str; 1] = [\"clippy::all\"];\n@@ -107,7 +94,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub INTERNAL_METADATA_COLLECTOR,\n-    internal,\n+    internal_warn,\n     \"A busy bee collection metadata about lints\"\n }\n \n@@ -116,22 +103,28 @@ impl_lint_pass!(MetadataCollector => [INTERNAL_METADATA_COLLECTOR]);\n #[allow(clippy::module_name_repetitions)]\n #[derive(Debug, Clone, Default)]\n pub struct MetadataCollector {\n-    lints: Vec<LintMetadata>,\n+    /// All collected lints\n+    ///\n+    /// We use a Heap here to have the lints added in alphabetic order in the export\n+    lints: BinaryHeap<LintMetadata>,\n     applicability_into: FxHashMap<String, ApplicabilityInfo>,\n }\n \n impl Drop for MetadataCollector {\n     /// You might ask: How hacky is this?\n     /// My answer:     YES\n     fn drop(&mut self) {\n+        // The metadata collector gets dropped twice, this makes sure that we only write\n+        // when the list is full\n         if self.lints.is_empty() {\n             return;\n         }\n \n         let mut applicability_info = std::mem::take(&mut self.applicability_into);\n \n         // Mapping the final data\n-        self.lints\n+        let mut lints = std::mem::take(&mut self.lints).into_sorted_vec();\n+        lints\n             .iter_mut()\n             .for_each(|x| x.applicability = applicability_info.remove(&x.id));\n \n@@ -140,11 +133,11 @@ impl Drop for MetadataCollector {\n             fs::remove_file(OUTPUT_FILE).unwrap();\n         }\n         let mut file = OpenOptions::new().write(true).create(true).open(OUTPUT_FILE).unwrap();\n-        writeln!(file, \"{}\", serde_json::to_string_pretty(&self.lints).unwrap()).unwrap();\n+        writeln!(file, \"{}\", serde_json::to_string_pretty(&lints).unwrap()).unwrap();\n     }\n }\n \n-#[derive(Debug, Clone, Serialize)]\n+#[derive(Debug, Clone, Serialize, PartialEq, Eq, PartialOrd, Ord)]\n struct LintMetadata {\n     id: String,\n     id_span: SerializableSpan,\n@@ -155,6 +148,24 @@ struct LintMetadata {\n     applicability: Option<ApplicabilityInfo>,\n }\n \n+// impl Ord for LintMetadata {\n+//     fn cmp(&self, other: &Self) -> Ordering {\n+//         self.id.cmp(&other.id)\n+//     }\n+// }\n+//\n+// impl PartialOrd for LintMetadata {\n+//     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+//         Some(self.cmp(other))\n+//     }\n+// }\n+//\n+// impl PartialEq for LintMetadata {\n+//     fn eq(&self, other: &Self) -> bool {\n+//         self.id == other.id\n+//     }\n+// }\n+\n impl LintMetadata {\n     fn new(id: String, id_span: SerializableSpan, group: String, docs: String) -> Self {\n         Self {\n@@ -167,7 +178,7 @@ impl LintMetadata {\n     }\n }\n \n-#[derive(Debug, Clone, Serialize)]\n+#[derive(Debug, Clone, Serialize, PartialEq, Eq, PartialOrd, Ord)]\n struct SerializableSpan {\n     path: String,\n     line: usize,\n@@ -194,25 +205,30 @@ impl SerializableSpan {\n     }\n }\n \n-#[derive(Debug, Clone, Default, Serialize)]\n+#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord)]\n struct ApplicabilityInfo {\n     /// Indicates if any of the lint emissions uses multiple spans. This is related to\n     /// [rustfix#141](https://github.com/rust-lang/rustfix/issues/141) as such suggestions can\n     /// currently not be applied automatically.\n-    is_multi_suggestion: bool,\n-    applicability: Option<String>,\n-}\n-\n-#[allow(dead_code)]\n-fn log_to_file(msg: &str) {\n-    let mut file = OpenOptions::new()\n-        .write(true)\n-        .append(true)\n-        .create(true)\n-        .open(\"metadata-lint.log\")\n-        .unwrap();\n-\n-    write!(file, \"{}\", msg).unwrap();\n+    is_multi_part_suggestion: bool,\n+    applicability: Option<usize>,\n+}\n+\n+impl Serialize for ApplicabilityInfo {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        let index = self.applicability.unwrap_or_default();\n+\n+        let mut s = serializer.serialize_struct(\"ApplicabilityInfo\", 2)?;\n+        s.serialize_field(\"is_multi_part_suggestion\", &self.is_multi_part_suggestion)?;\n+        s.serialize_field(\n+            \"applicability\",\n+            &paths::APPLICABILITY_VALUES[index][APPLICABILITY_NAME_INDEX],\n+        )?;\n+        s.end()\n+    }\n }\n \n impl<'hir> LateLintPass<'hir> for MetadataCollector {\n@@ -266,16 +282,20 @@ impl<'hir> LateLintPass<'hir> for MetadataCollector {\n     /// ```\n     fn check_expr(&mut self, cx: &LateContext<'hir>, expr: &'hir hir::Expr<'_>) {\n         if let Some(args) = match_lint_emission(cx, expr) {\n-            let mut emission_info = extract_complex_emission_info(cx, args);\n+            let mut emission_info = extract_emission_info(cx, args);\n             if emission_info.is_empty() {\n-                lint_collection_error_span(cx, expr.span, \"Look, here ... I have no clue what todo with it\");\n+                // See:\n+                // - src/misc.rs:734:9\n+                // - src/methods/mod.rs:3545:13\n+                // - src/methods/mod.rs:3496:13\n+                // We are basically unable to resolve the lint name it self.\n                 return;\n             }\n \n             for (lint_name, applicability, is_multi_part) in emission_info.drain(..) {\n                 let app_info = self.applicability_into.entry(lint_name).or_default();\n                 app_info.applicability = applicability;\n-                app_info.is_multi_suggestion = is_multi_part;\n+                app_info.is_multi_part_suggestion = is_multi_part;\n             }\n         }\n     }\n@@ -289,7 +309,7 @@ fn sym_to_string(sym: Symbol) -> String {\n }\n \n fn extract_attr_docs_or_lint(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n-    extract_attr_docs(item).or_else(|| {\n+    extract_attr_docs(cx, item).or_else(|| {\n         lint_collection_error_item(cx, item, \"could not collect the lint documentation\");\n         None\n     })\n@@ -305,8 +325,10 @@ fn extract_attr_docs_or_lint(cx: &LateContext<'_>, item: &Item<'_>) -> Option<St\n /// ```\n ///\n /// Would result in `Hello world!\\n=^.^=\\n`\n-fn extract_attr_docs(item: &Item<'_>) -> Option<String> {\n-    item.attrs\n+fn extract_attr_docs(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n+    cx.tcx\n+        .hir()\n+        .attrs(item.hir_id())\n         .iter()\n         .filter_map(|ref x| x.doc_str().map(|sym| sym.as_str().to_string()))\n         .reduce(|mut acc, sym| {\n@@ -357,15 +379,6 @@ fn lint_collection_error_item(cx: &LateContext<'_>, item: &Item<'_>, message: &s\n     );\n }\n \n-fn lint_collection_error_span(cx: &LateContext<'_>, span: Span, message: &str) {\n-    span_lint(\n-        cx,\n-        INTERNAL_METADATA_COLLECTOR,\n-        span,\n-        &format!(\"Metadata collection error: {}\", message),\n-    );\n-}\n-\n // ==================================================================\n // Applicability\n // ==================================================================\n@@ -377,11 +390,15 @@ fn match_lint_emission<'hir>(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'_>)\n         .find_map(|emission_fn| match_function_call(cx, expr, emission_fn))\n }\n \n-fn extract_complex_emission_info<'hir>(\n+fn take_higher_applicability(a: Option<usize>, b: Option<usize>) -> Option<usize> {\n+    a.map_or(b, |a| a.max(b.unwrap_or_default()).into())\n+}\n+\n+fn extract_emission_info<'hir>(\n     cx: &LateContext<'hir>,\n     args: &'hir [hir::Expr<'hir>],\n-) -> Vec<(String, Option<String>, bool)> {\n-    let mut lints= Vec::new();\n+) -> Vec<(String, Option<usize>, bool)> {\n+    let mut lints = Vec::new();\n     let mut applicability = None;\n     let mut multi_part = false;\n \n@@ -401,7 +418,10 @@ fn extract_complex_emission_info<'hir>(\n         }\n     }\n \n-    lints.drain(..).map(|lint_name| (lint_name, applicability.clone(), multi_part)).collect()\n+    lints\n+        .drain(..)\n+        .map(|lint_name| (lint_name, applicability, multi_part))\n+        .collect()\n }\n \n /// Resolves the possible lints that this expression could reference\n@@ -412,7 +432,7 @@ fn resolve_lints(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Vec<Str\n }\n \n /// This function tries to resolve the linked applicability to the given expression.\n-fn resolve_applicability(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<String> {\n+fn resolve_applicability(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<usize> {\n     let mut resolver = ApplicabilityResolver::new(cx);\n     resolver.visit_expr(expr);\n     resolver.complete()\n@@ -457,7 +477,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for LintResolver<'a, 'hir> {\n         if_chain! {\n             if let ExprKind::Path(qpath) = &expr.kind;\n             if let QPath::Resolved(_, path) = qpath;\n-            \n+\n             let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&expr));\n             if match_type(self.cx, expr_ty, &paths::LINT);\n             then {\n@@ -492,15 +512,11 @@ impl<'a, 'hir> ApplicabilityResolver<'a, 'hir> {\n     }\n \n     fn add_new_index(&mut self, new_index: usize) {\n-        self.applicability_index = self\n-            .applicability_index\n-            .map_or(new_index, |old_index| old_index.min(new_index))\n-            .into();\n+        self.applicability_index = take_higher_applicability(self.applicability_index, Some(new_index));\n     }\n \n-    fn complete(self) -> Option<String> {\n+    fn complete(self) -> Option<usize> {\n         self.applicability_index\n-            .map(|index| paths::APPLICABILITY_VALUES[index][APPLICABILITY_NAME_INDEX].to_string())\n     }\n }\n "}, {"sha": "7c7bb9b02b111b0bbe988de9c162d8e8a6f03f59", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fc960301bcd4370bfc2238415c7ba3d2d8f9312/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fc960301bcd4370bfc2238415c7ba3d2d8f9312/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=4fc960301bcd4370bfc2238415c7ba3d2d8f9312", "patch": "@@ -9,10 +9,10 @@ pub const ANY_TRAIT: [&str; 3] = [\"core\", \"any\", \"Any\"];\n pub const APPLICABILITY: [&str; 2] = [\"rustc_lint_defs\", \"Applicability\"];\n #[cfg(feature = \"metadata-collector-lint\")]\n pub const APPLICABILITY_VALUES: [[&str; 3]; 4] = [\n-    [\"rustc_lint_defs\", \"Applicability\", \"MachineApplicable\"],\n-    [\"rustc_lint_defs\", \"Applicability\", \"MaybeIncorrect\"],\n-    [\"rustc_lint_defs\", \"Applicability\", \"HasPlaceholders\"],\n     [\"rustc_lint_defs\", \"Applicability\", \"Unspecified\"],\n+    [\"rustc_lint_defs\", \"Applicability\", \"HasPlaceholders\"],\n+    [\"rustc_lint_defs\", \"Applicability\", \"MaybeIncorrect\"],\n+    [\"rustc_lint_defs\", \"Applicability\", \"MachineApplicable\"],\n ];\n #[cfg(feature = \"metadata-collector-lint\")]\n pub const DIAGNOSTIC_BUILDER: [&str; 3] = [\"rustc_errors\", \"diagnostic_builder\", \"DiagnosticBuilder\"];"}, {"sha": "f6f72ffa5fa9c8781a59e58eb3a896dc895b8cea", "filename": "metadata_collection.json", "status": "removed", "additions": 0, "deletions": 5778, "changes": 5778, "blob_url": "https://github.com/rust-lang/rust/blob/35844d0a48e0a644072ae81857782a6e0bd54740/metadata_collection.json", "raw_url": "https://github.com/rust-lang/rust/raw/35844d0a48e0a644072ae81857782a6e0bd54740/metadata_collection.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/metadata_collection.json?ref=35844d0a48e0a644072ae81857782a6e0bd54740"}, {"sha": "604968ad8b0c51573a840b0666f1f17016d2eda9", "filename": "tests/dogfood.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fc960301bcd4370bfc2238415c7ba3d2d8f9312/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fc960301bcd4370bfc2238415c7ba3d2d8f9312/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=4fc960301bcd4370bfc2238415c7ba3d2d8f9312", "patch": "@@ -41,10 +41,6 @@ fn dogfood_clippy() {\n         command.args(&[\"-D\", \"clippy::internal\"]);\n     }\n \n-    if cfg!(feature = \"metadata-collector-lint\") {\n-        command.args(&[\"-D\", \"clippy::internal\"]);\n-    }\n-\n     let output = command.output().unwrap();\n \n     println!(\"status: {}\", output.status);"}, {"sha": "b0f59e5cf8a765d07d4d1e382c19960f2ec34d81", "filename": "tests/ui-internal/metadata-collector/track_applicability_value.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/35844d0a48e0a644072ae81857782a6e0bd54740/tests%2Fui-internal%2Fmetadata-collector%2Ftrack_applicability_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35844d0a48e0a644072ae81857782a6e0bd54740/tests%2Fui-internal%2Fmetadata-collector%2Ftrack_applicability_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmetadata-collector%2Ftrack_applicability_value.rs?ref=35844d0a48e0a644072ae81857782a6e0bd54740", "patch": "@@ -1,50 +0,0 @@\n-#![deny(clippy::internal)]\n-#![feature(rustc_private)]\n-\n-extern crate rustc_ast;\n-extern crate rustc_errors;\n-extern crate rustc_lint;\n-extern crate rustc_session;\n-extern crate rustc_span;\n-\n-use rustc_ast::ast::Expr;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc_lint::{EarlyContext, EarlyLintPass, Lint, LintContext};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-\n-fn producer_fn() -> Applicability {\n-    Applicability::MachineApplicable\n-}\n-\n-fn modifier_fn(applicability: &mut Applicability) {\n-    if let Applicability::MaybeIncorrect = applicability {\n-        *applicability = Applicability::HasPlaceholders;\n-    }\n-}\n-\n-fn consumer_fn(_applicability: Applicability) {}\n-\n-struct Muh;\n-\n-impl Muh {\n-    fn producer_method() -> Applicability {\n-        Applicability::MachineApplicable\n-    }\n-}\n-\n-fn main() {\n-    let mut applicability = producer_fn();\n-    applicability = Applicability::MachineApplicable;\n-    applicability = Muh::producer_method();\n-\n-    applicability = if true {\n-        Applicability::HasPlaceholders\n-    } else {\n-        Applicability::MaybeIncorrect\n-    };\n-\n-    modifier_fn(&mut applicability);\n-\n-    consumer_fn(applicability);\n-}"}]}