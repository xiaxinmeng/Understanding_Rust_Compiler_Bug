{"sha": "86a691a5c7d183bc1e19d53832ea40cf41fa7ccd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YTY5MWE1YzdkMTgzYmMxZTE5ZDUzODMyZWE0MGNmNDFmYTdjY2Q=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-06T21:07:36Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-09T20:17:00Z"}, "message": "trans: Consistently name SharedCrateContext instances 'scx'", "tree": {"sha": "f4c1f0913fbd3930ad1e1f93e02de97b61c953ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4c1f0913fbd3930ad1e1f93e02de97b61c953ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86a691a5c7d183bc1e19d53832ea40cf41fa7ccd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86a691a5c7d183bc1e19d53832ea40cf41fa7ccd", "html_url": "https://github.com/rust-lang/rust/commit/86a691a5c7d183bc1e19d53832ea40cf41fa7ccd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86a691a5c7d183bc1e19d53832ea40cf41fa7ccd/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b89a5d1f7c8fb7fcfbbbf06544be9bfaf2c25bf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b89a5d1f7c8fb7fcfbbbf06544be9bfaf2c25bf8", "html_url": "https://github.com/rust-lang/rust/commit/b89a5d1f7c8fb7fcfbbbf06544be9bfaf2c25bf8"}], "stats": {"total": 238, "additions": 119, "deletions": 119}, "files": [{"sha": "4204d810d89a9eb32dc9217e0c6f2e5d7d018c48", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/86a691a5c7d183bc1e19d53832ea40cf41fa7ccd/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a691a5c7d183bc1e19d53832ea40cf41fa7ccd/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=86a691a5c7d183bc1e19d53832ea40cf41fa7ccd", "patch": "@@ -664,7 +664,7 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn custom_coerce_unsize_info<'ccx, 'tcx>(ccx: &SharedCrateContext<'ccx, 'tcx>,\n+pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx>,\n                                              source_ty: Ty<'tcx>,\n                                              target_ty: Ty<'tcx>)\n                                              -> CustomCoerceUnsized {\n@@ -674,13 +674,13 @@ pub fn custom_coerce_unsize_info<'ccx, 'tcx>(ccx: &SharedCrateContext<'ccx, 'tcx\n                                    subst::VecPerParamSpace::empty());\n \n     let trait_ref = ty::Binder(ty::TraitRef {\n-        def_id: ccx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n-        substs: ccx.tcx().mk_substs(trait_substs)\n+        def_id: scx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n+        substs: scx.tcx().mk_substs(trait_substs)\n     });\n \n-    match fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+    match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n-            ccx.tcx().custom_coerce_unsized_kind(impl_def_id)\n+            scx.tcx().custom_coerce_unsized_kind(impl_def_id)\n         }\n         vtable => {\n             bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);\n@@ -2660,10 +2660,10 @@ fn iter_functions(llmod: llvm::ModuleRef) -> ValueIter {\n ///\n /// This list is later used by linkers to determine the set of symbols needed to\n /// be exposed from a dynamic library and it's also encoded into the metadata.\n-pub fn filter_reachable_ids(ccx: &SharedCrateContext) -> NodeSet {\n-    ccx.reachable().iter().map(|x| *x).filter(|id| {\n+pub fn filter_reachable_ids(scx: &SharedCrateContext) -> NodeSet {\n+    scx.reachable().iter().map(|x| *x).filter(|id| {\n         // First, only worry about nodes which have a symbol name\n-        ccx.item_symbols().borrow().contains_key(id)\n+        scx.item_symbols().borrow().contains_key(id)\n     }).filter(|&id| {\n         // Next, we want to ignore some FFI functions that are not exposed from\n         // this crate. Reachable FFI functions can be lumped into two\n@@ -2678,9 +2678,9 @@ pub fn filter_reachable_ids(ccx: &SharedCrateContext) -> NodeSet {\n         //\n         // As a result, if this id is an FFI item (foreign item) then we only\n         // let it through if it's included statically.\n-        match ccx.tcx().map.get(id) {\n+        match scx.tcx().map.get(id) {\n             hir_map::NodeForeignItem(..) => {\n-                ccx.sess().cstore.is_statically_included_foreign_item(id)\n+                scx.sess().cstore.is_statically_included_foreign_item(id)\n             }\n             _ => true,\n         }"}, {"sha": "ba924d6ae3ef621a09c0e1cab8c43f4e0a1b4fb0", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 105, "deletions": 105, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/86a691a5c7d183bc1e19d53832ea40cf41fa7ccd/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a691a5c7d183bc1e19d53832ea40cf41fa7ccd/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=86a691a5c7d183bc1e19d53832ea40cf41fa7ccd", "patch": "@@ -319,22 +319,22 @@ impl<'tcx> ReferenceMap<'tcx> {\n     }\n }\n \n-pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n+pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n                                                  -> (FnvHashSet<TransItem<'tcx>>,\n                                                      ReferenceMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n-    ccx.tcx().dep_graph.with_ignore(|| {\n-        let roots = collect_roots(ccx, mode);\n+    scx.tcx().dep_graph.with_ignore(|| {\n+        let roots = collect_roots(scx, mode);\n \n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FnvHashSet();\n         let mut recursion_depths = DefIdMap();\n         let mut reference_map = ReferenceMap::new();\n \n         for root in roots {\n-            collect_items_rec(ccx,\n+            collect_items_rec(scx,\n                               root,\n                               &mut visited,\n                               &mut recursion_depths,\n@@ -347,28 +347,28 @@ pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &SharedCrateContext<'a, 't\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n-fn collect_roots<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n+fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                            mode: TransItemCollectionMode)\n                            -> Vec<TransItem<'tcx>> {\n     debug!(\"Collecting roots\");\n     let mut roots = Vec::new();\n \n     {\n         let mut visitor = RootCollector {\n-            ccx: ccx,\n+            scx: scx,\n             mode: mode,\n             output: &mut roots,\n             enclosing_item: None,\n         };\n \n-        ccx.tcx().map.krate().visit_all_items(&mut visitor);\n+        scx.tcx().map.krate().visit_all_items(&mut visitor);\n     }\n \n     roots\n }\n \n // Collect all monomorphized translation items reachable from `starting_point`\n-fn collect_items_rec<'a, 'tcx: 'a>(ccx: &SharedCrateContext<'a, 'tcx>,\n+fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n                                    visited: &mut FnvHashSet<TransItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n@@ -377,36 +377,36 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &SharedCrateContext<'a, 'tcx>,\n         // We've been here already, no need to search again.\n         return;\n     }\n-    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(ccx.tcx()));\n+    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n \n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n     match starting_point {\n         TransItem::DropGlue(t) => {\n-            find_drop_glue_neighbors(ccx, t, &mut neighbors);\n+            find_drop_glue_neighbors(scx, t, &mut neighbors);\n             recursion_depth_reset = None;\n         }\n         TransItem::Static(node_id) => {\n-            let def_id = ccx.tcx().map.local_def_id(node_id);\n-            let ty = ccx.tcx().lookup_item_type(def_id).ty;\n-            let ty = glue::get_drop_glue_type(ccx.tcx(), ty);\n+            let def_id = scx.tcx().map.local_def_id(node_id);\n+            let ty = scx.tcx().lookup_item_type(def_id).ty;\n+            let ty = glue::get_drop_glue_type(scx.tcx(), ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n             recursion_depth_reset = None;\n         }\n         TransItem::Fn(instance) => {\n             // Keep track of the monomorphization recursion depth\n-            recursion_depth_reset = Some(check_recursion_limit(ccx.tcx(),\n+            recursion_depth_reset = Some(check_recursion_limit(scx.tcx(),\n                                                                instance,\n                                                                recursion_depths));\n \n             // Scan the MIR in order to find function calls, closures, and\n             // drop-glue\n-            let mir = errors::expect(ccx.sess().diagnostic(), ccx.get_mir(instance.def),\n+            let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(instance.def),\n                 || format!(\"Could not find MIR for function: {}\", instance));\n \n             let mut visitor = MirNeighborCollector {\n-                ccx: ccx,\n+                scx: scx,\n                 mir: &mir,\n                 output: &mut neighbors,\n                 param_substs: instance.substs\n@@ -419,17 +419,17 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &SharedCrateContext<'a, 'tcx>,\n         }\n     }\n \n-    record_references(ccx.tcx(), starting_point, &neighbors[..], reference_map);\n+    record_references(scx.tcx(), starting_point, &neighbors[..], reference_map);\n \n     for neighbour in neighbors {\n-        collect_items_rec(ccx, neighbour, visited, recursion_depths, reference_map);\n+        collect_items_rec(scx, neighbour, visited, recursion_depths, reference_map);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n         recursion_depths.insert(def_id, depth);\n     }\n \n-    debug!(\"END collect_items_rec({})\", starting_point.to_string(ccx.tcx()));\n+    debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n }\n \n fn record_references<'tcx>(tcx: &TyCtxt<'tcx>,\n@@ -473,7 +473,7 @@ fn check_recursion_limit<'tcx>(tcx: &TyCtxt<'tcx>,\n }\n \n struct MirNeighborCollector<'a, 'tcx: 'a> {\n-    ccx: &'a SharedCrateContext<'a, 'tcx>,\n+    scx: &'a SharedCrateContext<'a, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n     output: &'a mut Vec<TransItem<'tcx>>,\n     param_substs: &'tcx Substs<'tcx>\n@@ -487,8 +487,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *rvalue {\n             mir::Rvalue::Aggregate(mir::AggregateKind::Closure(def_id,\n                                                                ref substs), _) => {\n-                assert!(can_have_local_instance(self.ccx.tcx(), def_id));\n-                let trans_item = create_fn_trans_item(self.ccx.tcx(),\n+                assert!(can_have_local_instance(self.scx.tcx(), def_id));\n+                let trans_item = create_fn_trans_item(self.scx.tcx(),\n                                                       def_id,\n                                                       substs.func_substs,\n                                                       self.param_substs);\n@@ -498,37 +498,37 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             // have to instantiate all methods of the trait being cast to, so we\n             // can build the appropriate vtable.\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, target_ty) => {\n-                let target_ty = monomorphize::apply_param_substs(self.ccx.tcx(),\n+                let target_ty = monomorphize::apply_param_substs(self.scx.tcx(),\n                                                                  self.param_substs,\n                                                                  &target_ty);\n-                let source_ty = self.mir.operand_ty(self.ccx.tcx(), operand);\n-                let source_ty = monomorphize::apply_param_substs(self.ccx.tcx(),\n+                let source_ty = self.mir.operand_ty(self.scx.tcx(), operand);\n+                let source_ty = monomorphize::apply_param_substs(self.scx.tcx(),\n                                                                  self.param_substs,\n                                                                  &source_ty);\n-                let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.ccx,\n+                let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.scx,\n                                                                             source_ty,\n                                                                             target_ty);\n                 // This could also be a different Unsize instruction, like\n                 // from a fixed sized array to a slice. But we are only\n                 // interested in things that produce a vtable.\n                 if target_ty.is_trait() && !source_ty.is_trait() {\n-                    create_trans_items_for_vtable_methods(self.ccx,\n+                    create_trans_items_for_vtable_methods(self.scx,\n                                                           target_ty,\n                                                           source_ty,\n                                                           self.output);\n                 }\n             }\n             mir::Rvalue::Box(_) => {\n                 let exchange_malloc_fn_def_id =\n-                    self.ccx\n+                    self.scx\n                         .tcx()\n                         .lang_items\n                         .require(ExchangeMallocFnLangItem)\n-                        .unwrap_or_else(|e| self.ccx.sess().fatal(&e));\n+                        .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n \n-                assert!(can_have_local_instance(self.ccx.tcx(), exchange_malloc_fn_def_id));\n+                assert!(can_have_local_instance(self.scx.tcx(), exchange_malloc_fn_def_id));\n                 let exchange_malloc_fn_trans_item =\n-                    create_fn_trans_item(self.ccx.tcx(),\n+                    create_fn_trans_item(self.scx.tcx(),\n                                          exchange_malloc_fn_def_id,\n                                          &Substs::empty(),\n                                          self.param_substs);\n@@ -547,14 +547,14 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         debug!(\"visiting lvalue {:?}\", *lvalue);\n \n         if let mir_visit::LvalueContext::Drop = context {\n-            let ty = self.mir.lvalue_ty(self.ccx.tcx(), lvalue)\n-                             .to_ty(self.ccx.tcx());\n+            let ty = self.mir.lvalue_ty(self.scx.tcx(), lvalue)\n+                             .to_ty(self.scx.tcx());\n \n-            let ty = monomorphize::apply_param_substs(self.ccx.tcx(),\n+            let ty = monomorphize::apply_param_substs(self.scx.tcx(),\n                                                       self.param_substs,\n                                                       &ty);\n-            let ty = self.ccx.tcx().erase_regions(&ty);\n-            let ty = glue::get_drop_glue_type(self.ccx.tcx(), ty);\n+            let ty = self.scx.tcx().erase_regions(&ty);\n+            let ty = glue::get_drop_glue_type(self.scx.tcx(), ty);\n             self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n         }\n \n@@ -582,7 +582,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             //\n             // Calling do_static_dispatch() here will map the def_id of\n             // `std::cmp::partial_cmp` to the def_id of `i32::partial_cmp<i32>`\n-            let dispatched = do_static_dispatch(self.ccx,\n+            let dispatched = do_static_dispatch(self.scx,\n                                                 callee_def_id,\n                                                 callee_substs,\n                                                 self.param_substs);\n@@ -593,9 +593,9 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 // object shim or a closure that is handled differently),\n                 // we check if the callee is something that will actually\n                 // result in a translation item ...\n-                if can_result_in_trans_item(self.ccx.tcx(), callee_def_id) {\n+                if can_result_in_trans_item(self.scx.tcx(), callee_def_id) {\n                     // ... and create one if it does.\n-                    let trans_item = create_fn_trans_item(self.ccx.tcx(),\n+                    let trans_item = create_fn_trans_item(self.scx.tcx(),\n                                                           callee_def_id,\n                                                           callee_substs,\n                                                           self.param_substs);\n@@ -644,7 +644,7 @@ fn can_have_local_instance<'tcx>(tcx: &TyCtxt<'tcx>,\n     def_id.is_local() || tcx.sess.cstore.is_item_mir_available(def_id)\n }\n \n-fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n+fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                       dg: DropGlueKind<'tcx>,\n                                       output: &mut Vec<TransItem<'tcx>>) {\n     let ty = match dg {\n@@ -656,19 +656,19 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n         }\n     };\n \n-    debug!(\"find_drop_glue_neighbors: {}\", type_to_string(ccx.tcx(), ty));\n+    debug!(\"find_drop_glue_neighbors: {}\", type_to_string(scx.tcx(), ty));\n \n     // Make sure the exchange_free_fn() lang-item gets translated if\n     // there is a boxed value.\n     if let ty::TyBox(_) = ty.sty {\n-        let exchange_free_fn_def_id = ccx.tcx()\n+        let exchange_free_fn_def_id = scx.tcx()\n                                          .lang_items\n                                          .require(ExchangeFreeFnLangItem)\n-                                         .unwrap_or_else(|e| ccx.sess().fatal(&e));\n+                                         .unwrap_or_else(|e| scx.sess().fatal(&e));\n \n-        assert!(can_have_local_instance(ccx.tcx(), exchange_free_fn_def_id));\n+        assert!(can_have_local_instance(scx.tcx(), exchange_free_fn_def_id));\n         let exchange_free_fn_trans_item =\n-            create_fn_trans_item(ccx.tcx(),\n+            create_fn_trans_item(scx.tcx(),\n                                  exchange_free_fn_def_id,\n                                  &Substs::empty(),\n                                  &Substs::empty());\n@@ -687,26 +687,26 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n     if let Some(destructor_did) = destructor_did {\n         use rustc::ty::ToPolyTraitRef;\n \n-        let drop_trait_def_id = ccx.tcx()\n+        let drop_trait_def_id = scx.tcx()\n                                    .lang_items\n                                    .drop_trait()\n                                    .unwrap();\n \n-        let self_type_substs = ccx.tcx().mk_substs(\n+        let self_type_substs = scx.tcx().mk_substs(\n             Substs::empty().with_self_ty(ty));\n \n         let trait_ref = ty::TraitRef {\n             def_id: drop_trait_def_id,\n             substs: self_type_substs,\n         }.to_poly_trait_ref();\n \n-        let substs = match fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+        let substs = match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n             traits::VtableImpl(data) => data.substs,\n             _ => bug!()\n         };\n \n-        if can_have_local_instance(ccx.tcx(), destructor_did) {\n-            let trans_item = create_fn_trans_item(ccx.tcx(),\n+        if can_have_local_instance(scx.tcx(), destructor_did) {\n+            let trans_item = create_fn_trans_item(scx.tcx(),\n                                                   destructor_did,\n                                                   substs,\n                                                   &Substs::empty());\n@@ -737,35 +737,35 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n         ty::TyStruct(ref adt_def, substs) |\n         ty::TyEnum(ref adt_def, substs) => {\n             for field in adt_def.all_fields() {\n-                let field_type = monomorphize::apply_param_substs(ccx.tcx(),\n+                let field_type = monomorphize::apply_param_substs(scx.tcx(),\n                                                                   substs,\n                                                                   &field.unsubst_ty());\n-                let field_type = glue::get_drop_glue_type(ccx.tcx(), field_type);\n+                let field_type = glue::get_drop_glue_type(scx.tcx(), field_type);\n \n-                if glue::type_needs_drop(ccx.tcx(), field_type) {\n+                if glue::type_needs_drop(scx.tcx(), field_type) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(field_type)));\n                 }\n             }\n         }\n         ty::TyClosure(_, ref substs) => {\n             for upvar_ty in &substs.upvar_tys {\n-                let upvar_ty = glue::get_drop_glue_type(ccx.tcx(), upvar_ty);\n-                if glue::type_needs_drop(ccx.tcx(), upvar_ty) {\n+                let upvar_ty = glue::get_drop_glue_type(scx.tcx(), upvar_ty);\n+                if glue::type_needs_drop(scx.tcx(), upvar_ty) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(upvar_ty)));\n                 }\n             }\n         }\n         ty::TyBox(inner_type)      |\n         ty::TyArray(inner_type, _) => {\n-            let inner_type = glue::get_drop_glue_type(ccx.tcx(), inner_type);\n-            if glue::type_needs_drop(ccx.tcx(), inner_type) {\n+            let inner_type = glue::get_drop_glue_type(scx.tcx(), inner_type);\n+            if glue::type_needs_drop(scx.tcx(), inner_type) {\n                 output.push(TransItem::DropGlue(DropGlueKind::Ty(inner_type)));\n             }\n         }\n         ty::TyTuple(ref args) => {\n             for arg in args {\n-                let arg = glue::get_drop_glue_type(ccx.tcx(), arg);\n-                if glue::type_needs_drop(ccx.tcx(), arg) {\n+                let arg = glue::get_drop_glue_type(scx.tcx(), arg);\n+                if glue::type_needs_drop(scx.tcx(), arg) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(arg)));\n                 }\n             }\n@@ -779,25 +779,25 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n     }\n }\n \n-fn do_static_dispatch<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n+fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                 fn_def_id: DefId,\n                                 fn_substs: &'tcx Substs<'tcx>,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> Option<(DefId, &'tcx Substs<'tcx>)> {\n     debug!(\"do_static_dispatch(fn_def_id={}, fn_substs={:?}, param_substs={:?})\",\n-           def_id_to_string(ccx.tcx(), fn_def_id),\n+           def_id_to_string(scx.tcx(), fn_def_id),\n            fn_substs,\n            param_substs);\n \n-    let is_trait_method = ccx.tcx().trait_of_item(fn_def_id).is_some();\n+    let is_trait_method = scx.tcx().trait_of_item(fn_def_id).is_some();\n \n     if is_trait_method {\n-        match ccx.tcx().impl_or_trait_item(fn_def_id) {\n+        match scx.tcx().impl_or_trait_item(fn_def_id) {\n             ty::MethodTraitItem(ref method) => {\n                 match method.container {\n                     ty::TraitContainer(trait_def_id) => {\n                         debug!(\" => trait method, attempting to find impl\");\n-                        do_static_trait_method_dispatch(ccx,\n+                        do_static_trait_method_dispatch(scx,\n                                                         method,\n                                                         trait_def_id,\n                                                         fn_substs,\n@@ -822,19 +822,19 @@ fn do_static_dispatch<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n \n // Given a trait-method and substitution information, find out the actual\n // implementation of the trait method.\n-fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n+fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                              trait_method: &ty::Method,\n                                              trait_id: DefId,\n                                              callee_substs: &'tcx Substs<'tcx>,\n                                              param_substs: &'tcx Substs<'tcx>)\n                                              -> Option<(DefId, &'tcx Substs<'tcx>)> {\n-    let tcx = ccx.tcx();\n+    let tcx = scx.tcx();\n     debug!(\"do_static_trait_method_dispatch(trait_method={}, \\\n                                             trait_id={}, \\\n                                             callee_substs={:?}, \\\n                                             param_substs={:?}\",\n-           def_id_to_string(ccx.tcx(), trait_method.def_id),\n-           def_id_to_string(ccx.tcx(), trait_id),\n+           def_id_to_string(scx.tcx(), trait_method.def_id),\n+           def_id_to_string(scx.tcx(), trait_id),\n            callee_substs,\n            param_substs);\n \n@@ -843,7 +843,7 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n                                                        callee_substs);\n \n     let trait_ref = ty::Binder(rcvr_substs.to_trait_ref(tcx, trait_id));\n-    let vtbl = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+    let vtbl = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -911,7 +911,7 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n ///\n /// Finally, there is also the case of custom unsizing coercions, e.g. for\n /// smart pointers such as `Rc` and `Arc`.\n-fn find_vtable_types_for_unsizing<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n+fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                             source_ty: ty::Ty<'tcx>,\n                                             target_ty: ty::Ty<'tcx>)\n                                             -> (ty::Ty<'tcx>, ty::Ty<'tcx>) {\n@@ -925,18 +925,18 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             let (inner_source, inner_target) = (a, b);\n \n-            if !type_is_sized(ccx.tcx(), inner_source) {\n+            if !type_is_sized(scx.tcx(), inner_source) {\n                 (inner_source, inner_target)\n             } else {\n-                ccx.tcx().struct_lockstep_tails(inner_source, inner_target)\n+                scx.tcx().struct_lockstep_tails(inner_source, inner_target)\n             }\n         }\n \n         (&ty::TyStruct(source_adt_def, source_substs),\n          &ty::TyStruct(target_adt_def, target_substs)) => {\n             assert_eq!(source_adt_def, target_adt_def);\n \n-            let kind = custom_coerce_unsize_info(ccx, source_ty, target_ty);\n+            let kind = custom_coerce_unsize_info(scx, source_ty, target_ty);\n \n             let coerce_index = match kind {\n                 CustomCoerceUnsized::Struct(i) => i\n@@ -948,10 +948,10 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n             assert!(coerce_index < source_fields.len() &&\n                     source_fields.len() == target_fields.len());\n \n-            find_vtable_types_for_unsizing(ccx,\n-                                           source_fields[coerce_index].ty(ccx.tcx(),\n+            find_vtable_types_for_unsizing(scx,\n+                                           source_fields[coerce_index].ty(scx.tcx(),\n                                                                           source_substs),\n-                                           target_fields[coerce_index].ty(ccx.tcx(),\n+                                           target_fields[coerce_index].ty(scx.tcx(),\n                                                                           target_substs))\n         }\n         _ => bug!(\"find_vtable_types_for_unsizing: invalid coercion {:?} -> {:?}\",\n@@ -986,33 +986,33 @@ fn create_fn_trans_item<'tcx>(tcx: &TyCtxt<'tcx>,\n \n /// Creates a `TransItem` for each method that is referenced by the vtable for\n /// the given trait/impl pair.\n-fn create_trans_items_for_vtable_methods<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n+fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                    trait_ty: ty::Ty<'tcx>,\n                                                    impl_ty: ty::Ty<'tcx>,\n                                                    output: &mut Vec<TransItem<'tcx>>) {\n     assert!(!trait_ty.needs_subst() && !impl_ty.needs_subst());\n \n     if let ty::TyTrait(ref trait_ty) = trait_ty.sty {\n-        let poly_trait_ref = trait_ty.principal_trait_ref_with_self_ty(ccx.tcx(),\n+        let poly_trait_ref = trait_ty.principal_trait_ref_with_self_ty(scx.tcx(),\n                                                                        impl_ty);\n \n         // Walk all methods of the trait, including those of its supertraits\n-        for trait_ref in traits::supertraits(ccx.tcx(), poly_trait_ref) {\n-            let vtable = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+        for trait_ref in traits::supertraits(scx.tcx(), poly_trait_ref) {\n+            let vtable = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n             match vtable {\n                 traits::VtableImpl(\n                     traits::VtableImplData {\n                         impl_def_id,\n                         substs,\n                         nested: _ }) => {\n-                    let items = meth::get_vtable_methods(ccx.tcx(), impl_def_id, substs)\n+                    let items = meth::get_vtable_methods(scx.tcx(), impl_def_id, substs)\n                         .into_iter()\n                         // filter out None values\n                         .filter_map(|opt_impl_method| opt_impl_method)\n                         // create translation items\n                         .filter_map(|impl_method| {\n-                            if can_have_local_instance(ccx.tcx(), impl_method.method.def_id) {\n-                                Some(create_fn_trans_item(ccx.tcx(),\n+                            if can_have_local_instance(scx.tcx(), impl_method.method.def_id) {\n+                                Some(create_fn_trans_item(scx.tcx(),\n                                                           impl_method.method.def_id,\n                                                           &impl_method.substs,\n                                                           &Substs::empty()))\n@@ -1035,7 +1035,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(ccx: &SharedCrateContext<'a,\n //=-----------------------------------------------------------------------------\n \n struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n-    ccx: &'b SharedCrateContext<'a, 'tcx>,\n+    scx: &'b SharedCrateContext<'a, 'tcx>,\n     mode: TransItemCollectionMode,\n     output: &'b mut Vec<TransItem<'tcx>>,\n     enclosing_item: Option<&'tcx hir::Item>,\n@@ -1060,7 +1060,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n \n             hir::ItemImpl(..) => {\n                 if self.mode == TransItemCollectionMode::Eager {\n-                    create_trans_items_for_default_impls(self.ccx.tcx(),\n+                    create_trans_items_for_default_impls(self.scx.tcx(),\n                                                          item,\n                                                          self.output);\n                 }\n@@ -1070,35 +1070,35 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemStruct(_, ref generics)      => {\n                 if !generics.is_parameterized() {\n                     let ty = {\n-                        let tables = self.ccx.tcx().tables.borrow();\n+                        let tables = self.scx.tcx().tables.borrow();\n                         tables.node_types[&item.id]\n                     };\n \n                     if self.mode == TransItemCollectionMode::Eager {\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n-                               def_id_to_string(self.ccx.tcx(),\n-                                                self.ccx.tcx().map.local_def_id(item.id)));\n+                               def_id_to_string(self.scx.tcx(),\n+                                                self.scx.tcx().map.local_def_id(item.id)));\n \n-                        let ty = glue::get_drop_glue_type(self.ccx.tcx(), ty);\n+                        let ty = glue::get_drop_glue_type(self.scx.tcx(), ty);\n                         self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                     }\n                 }\n             }\n             hir::ItemStatic(..) => {\n                 debug!(\"RootCollector: ItemStatic({})\",\n-                       def_id_to_string(self.ccx.tcx(),\n-                                        self.ccx.tcx().map.local_def_id(item.id)));\n+                       def_id_to_string(self.scx.tcx(),\n+                                        self.scx.tcx().map.local_def_id(item.id)));\n                 self.output.push(TransItem::Static(item.id));\n             }\n             hir::ItemFn(_, _, constness, _, ref generics, _) => {\n                 if !generics.is_type_parameterized() &&\n                    constness == hir::Constness::NotConst {\n-                    let def_id = self.ccx.tcx().map.local_def_id(item.id);\n+                    let def_id = self.scx.tcx().map.local_def_id(item.id);\n \n                     debug!(\"RootCollector: ItemFn({})\",\n-                           def_id_to_string(self.ccx.tcx(), def_id));\n+                           def_id_to_string(self.scx.tcx(), def_id));\n \n-                    let instance = Instance::mono(self.ccx.tcx(), def_id);\n+                    let instance = Instance::mono(self.scx.tcx(), def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -1115,7 +1115,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                 constness,\n                 ..\n             }, _) if constness == hir::Constness::NotConst => {\n-                let hir_map = &self.ccx.tcx().map;\n+                let hir_map = &self.scx.tcx().map;\n                 let parent_node_id = hir_map.get_parent_node(ii.id);\n                 let is_impl_generic = match hir_map.expect_item(parent_node_id) {\n                     &hir::Item {\n@@ -1130,12 +1130,12 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                 };\n \n                 if !generics.is_type_parameterized() && !is_impl_generic {\n-                    let def_id = self.ccx.tcx().map.local_def_id(ii.id);\n+                    let def_id = self.scx.tcx().map.local_def_id(ii.id);\n \n                     debug!(\"RootCollector: MethodImplItem({})\",\n-                           def_id_to_string(self.ccx.tcx(), def_id));\n+                           def_id_to_string(self.scx.tcx(), def_id));\n \n-                    let instance = Instance::mono(self.ccx.tcx(), def_id);\n+                    let instance = Instance::mono(self.scx.tcx(), def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -1546,15 +1546,15 @@ pub enum TransItemState {\n     NotPredictedButGenerated,\n }\n \n-pub fn collecting_debug_information(ccx: &SharedCrateContext) -> bool {\n+pub fn collecting_debug_information(scx: &SharedCrateContext) -> bool {\n     return cfg!(debug_assertions) &&\n-           ccx.sess().opts.debugging_opts.print_trans_items.is_some();\n+           scx.sess().opts.debugging_opts.print_trans_items.is_some();\n }\n \n-pub fn print_collection_results<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>) {\n+pub fn print_collection_results<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>) {\n     use std::hash::{Hash, SipHasher, Hasher};\n \n-    if !collecting_debug_information(ccx) {\n+    if !collecting_debug_information(scx) {\n         return;\n     }\n \n@@ -1564,14 +1564,14 @@ pub fn print_collection_results<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>) {\n         s.finish()\n     }\n \n-    let trans_items = ccx.translation_items().borrow();\n+    let trans_items = scx.translation_items().borrow();\n \n     {\n         // Check for duplicate item keys\n         let mut item_keys = FnvHashMap();\n \n         for (item, item_state) in trans_items.iter() {\n-            let k = item.to_string(ccx.tcx());\n+            let k = item.to_string(scx.tcx());\n \n             if item_keys.contains_key(&k) {\n                 let prev: (TransItem, TransItemState) = item_keys[&k];\n@@ -1599,7 +1599,7 @@ pub fn print_collection_results<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>) {\n     let mut generated = FnvHashSet();\n \n     for (item, item_state) in trans_items.iter() {\n-        let item_key = item.to_string(ccx.tcx());\n+        let item_key = item.to_string(scx.tcx());\n \n         match *item_state {\n             TransItemState::PredictedAndGenerated => {"}, {"sha": "dc3da79c22612c21cec6357d81e5ade09fdbeda7", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86a691a5c7d183bc1e19d53832ea40cf41fa7ccd/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a691a5c7d183bc1e19d53832ea40cf41fa7ccd/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=86a691a5c7d183bc1e19d53832ea40cf41fa7ccd", "patch": "@@ -1052,17 +1052,17 @@ pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &hir::Expr) ->\n /// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n /// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n-pub fn fulfill_obligation<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n+pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                     span: Span,\n                                     trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> traits::Vtable<'tcx, ()>\n {\n-    let tcx = ccx.tcx();\n+    let tcx = scx.tcx();\n \n     // Remove any references to regions; this helps improve caching.\n     let trait_ref = tcx.erase_regions(&trait_ref);\n \n-    ccx.trait_cache().memoize(trait_ref, || {\n+    scx.trait_cache().memoize(trait_ref, || {\n         debug!(\"trans fulfill_obligation: trait_ref={:?} def_id={:?}\",\n                trait_ref, trait_ref.def_id());\n \n@@ -1090,7 +1090,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n                 debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n                         presuming due to overflow\",\n                        trait_ref);\n-                ccx.sess().span_fatal(\n+                tcx.sess.span_fatal(\n                     span,\n                     \"reached the recursion limit during monomorphization \\\n                      (selection ambiguity)\");"}]}