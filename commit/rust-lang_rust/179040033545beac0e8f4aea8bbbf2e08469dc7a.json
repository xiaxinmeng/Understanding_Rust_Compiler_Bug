{"sha": "179040033545beac0e8f4aea8bbbf2e08469dc7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3OTA0MDAzMzU0NWJlYWMwZThmNGFlYThiYmJmMmUwODQ2OWRjN2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-30T16:32:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-30T16:32:01Z"}, "message": "auto merge of #7465 : alexcrichton/rust/issue-4432, r=cmr\n\nThis stems from trying to perform as few allocations as possible throughout the standard libraries.\r\n\r\nThis specializes the `ToStr` implementation for floats/ints separately because it's known that ints will have a maximum length (whereas floats could be very very large).\r\n\r\nI also removed a `FIXME` to remove a malloc from the `to_str()` of floats in `repr.rs` because I think that this should be addressed elsewhere. I think that we may not be able to avoid it easily because floats can have such large representations, but regardless this should be a problem with the implementation of `float_to_str_bytes_common` now and not in the `Repr` module.", "tree": {"sha": "c7fe8365b82802cb8c634500f6444896014e0286", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7fe8365b82802cb8c634500f6444896014e0286"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/179040033545beac0e8f4aea8bbbf2e08469dc7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/179040033545beac0e8f4aea8bbbf2e08469dc7a", "html_url": "https://github.com/rust-lang/rust/commit/179040033545beac0e8f4aea8bbbf2e08469dc7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/179040033545beac0e8f4aea8bbbf2e08469dc7a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b3569a1b39097481877cf8fee538c78099c5acd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3569a1b39097481877cf8fee538c78099c5acd", "html_url": "https://github.com/rust-lang/rust/commit/2b3569a1b39097481877cf8fee538c78099c5acd"}, {"sha": "d3155faedee97cb916735573fbf067d6305ee730", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3155faedee97cb916735573fbf067d6305ee730", "html_url": "https://github.com/rust-lang/rust/commit/d3155faedee97cb916735573fbf067d6305ee730"}], "stats": {"total": 576, "additions": 323, "deletions": 253}, "files": [{"sha": "b7d21ea0ee3fd00726c0434d918b612c12224151", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=179040033545beac0e8f4aea8bbbf2e08469dc7a", "patch": "@@ -11,7 +11,7 @@\n //! Parameterized string expansion\n \n use std::{char, vec, util};\n-use std::num::strconv::{SignNone,SignNeg,SignAll,DigAll,to_str_bytes_common};\n+use std::num::strconv::{SignNone,SignNeg,SignAll,int_to_str_bytes_common};\n use std::iterator::IteratorUtil;\n \n #[deriving(Eq)]\n@@ -469,14 +469,20 @@ priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n                         FormatHex|FormatHEX => 16,\n                         FormatString => util::unreachable()\n                     };\n-                    let (s,_) = match op {\n+                    let mut s = ~[];\n+                    match op {\n                         FormatDigit => {\n                             let sign = if flags.sign { SignAll } else { SignNeg };\n-                            to_str_bytes_common(&d, radix, false, sign, DigAll)\n+                            do int_to_str_bytes_common(d, radix, sign) |c| {\n+                                s.push(c);\n+                            }\n+                        }\n+                        _ => {\n+                            do int_to_str_bytes_common(d as uint, radix, SignNone) |c| {\n+                                s.push(c);\n+                            }\n                         }\n-                        _ => to_str_bytes_common(&(d as uint), radix, false, SignNone, DigAll)\n                     };\n-                    let mut s = s;\n                     if flags.precision > s.len() {\n                         let mut s_ = vec::with_capacity(flags.precision);\n                         let n = flags.precision - s.len();"}, {"sha": "6a9555f4efcdc1b5671f27bbf0414a53d6b8cc42", "filename": "src/libstd/char.rs", "status": "modified", "additions": 59, "deletions": 50, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=179040033545beac0e8f4aea8bbbf2e08469dc7a", "patch": "@@ -10,14 +10,13 @@\n \n //! Utilities for manipulating the char type\n \n-use container::Container;\n use option::{None, Option, Some};\n-use str;\n-use str::{StrSlice, OwnedStr};\n-use u32;\n-use uint;\n+use int;\n+use str::StrSlice;\n use unicode::{derived_property, general_category};\n \n+#[cfg(test)] use str::OwnedStr;\n+\n #[cfg(not(test))] use cmp::{Eq, Ord};\n #[cfg(not(test))] use num::Zero;\n \n@@ -202,21 +201,21 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n /// - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n /// - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n ///\n-pub fn escape_unicode(c: char) -> ~str {\n-    let s = u32::to_str_radix(c as u32, 16u);\n-    let (c, pad) = cond!(\n-        (c <= '\\xff')   { ('x', 2u) }\n-        (c <= '\\uffff') { ('u', 4u) }\n-        _               { ('U', 8u) }\n+pub fn escape_unicode(c: char, f: &fn(char)) {\n+    // avoid calling str::to_str_radix because we don't really need to allocate\n+    // here.\n+    f('\\\\');\n+    let pad = cond!(\n+        (c <= '\\xff')   { f('x'); 2 }\n+        (c <= '\\uffff') { f('u'); 4 }\n+        _               { f('U'); 8 }\n     );\n-    assert!(s.len() <= pad);\n-    let mut out = ~\"\\\\\";\n-    out.push_str(str::from_char(c));\n-    for uint::range(s.len(), pad) |_| {\n-        out.push_str(\"0\");\n+    for int::range_step(4 * (pad - 1), -1, -4) |offset| {\n+        match ((c as u32) >> offset) & 0xf {\n+            i @ 0 .. 9 => { f('0' + i as char); }\n+            i => { f('a' + (i - 10) as char); }\n+        }\n     }\n-    out.push_str(s);\n-    out\n }\n \n ///\n@@ -231,16 +230,16 @@ pub fn escape_unicode(c: char) -> ~str {\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n /// - Any other chars are given hex unicode escapes; see `escape_unicode`.\n ///\n-pub fn escape_default(c: char) -> ~str {\n+pub fn escape_default(c: char, f: &fn(char)) {\n     match c {\n-        '\\t' => ~\"\\\\t\",\n-        '\\r' => ~\"\\\\r\",\n-        '\\n' => ~\"\\\\n\",\n-        '\\\\' => ~\"\\\\\\\\\",\n-        '\\'' => ~\"\\\\'\",\n-        '\"'  => ~\"\\\\\\\"\",\n-        '\\x20' .. '\\x7e' => str::from_char(c),\n-        _ => c.escape_unicode(),\n+        '\\t' => { f('\\\\'); f('t'); }\n+        '\\r' => { f('\\\\'); f('r'); }\n+        '\\n' => { f('\\\\'); f('n'); }\n+        '\\\\' => { f('\\\\'); f('\\\\'); }\n+        '\\'' => { f('\\\\'); f('\\''); }\n+        '\"'  => { f('\\\\'); f('\"'); }\n+        '\\x20' .. '\\x7e' => { f(c); }\n+        _ => c.escape_unicode(f),\n     }\n }\n \n@@ -274,8 +273,8 @@ pub trait Char {\n     fn is_digit_radix(&self, radix: uint) -> bool;\n     fn to_digit(&self, radix: uint) -> Option<uint>;\n     fn from_digit(num: uint, radix: uint) -> Option<char>;\n-    fn escape_unicode(&self) -> ~str;\n-    fn escape_default(&self) -> ~str;\n+    fn escape_unicode(&self, f: &fn(char));\n+    fn escape_default(&self, f: &fn(char));\n     fn len_utf8_bytes(&self) -> uint;\n }\n \n@@ -302,9 +301,9 @@ impl Char for char {\n \n     fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }\n \n-    fn escape_unicode(&self) -> ~str { escape_unicode(*self) }\n+    fn escape_unicode(&self, f: &fn(char)) { escape_unicode(*self, f) }\n \n-    fn escape_default(&self) -> ~str { escape_default(*self) }\n+    fn escape_default(&self, f: &fn(char)) { escape_default(*self, f) }\n \n     fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n }\n@@ -392,27 +391,37 @@ fn test_is_digit() {\n \n #[test]\n fn test_escape_default() {\n-    assert_eq!('\\n'.escape_default(), ~\"\\\\n\");\n-    assert_eq!('\\r'.escape_default(), ~\"\\\\r\");\n-    assert_eq!('\\''.escape_default(), ~\"\\\\'\");\n-    assert_eq!('\"'.escape_default(), ~\"\\\\\\\"\");\n-    assert_eq!(' '.escape_default(), ~\" \");\n-    assert_eq!('a'.escape_default(), ~\"a\");\n-    assert_eq!('~'.escape_default(), ~\"~\");\n-    assert_eq!('\\x00'.escape_default(), ~\"\\\\x00\");\n-    assert_eq!('\\x1f'.escape_default(), ~\"\\\\x1f\");\n-    assert_eq!('\\x7f'.escape_default(), ~\"\\\\x7f\");\n-    assert_eq!('\\xff'.escape_default(), ~\"\\\\xff\");\n-    assert_eq!('\\u011b'.escape_default(), ~\"\\\\u011b\");\n-    assert_eq!('\\U0001d4b6'.escape_default(), ~\"\\\\U0001d4b6\");\n+    fn string(c: char) -> ~str {\n+        let mut result = ~\"\";\n+        do escape_default(c) |c| { result.push_char(c); }\n+        return result;\n+    }\n+    assert_eq!(string('\\n'), ~\"\\\\n\");\n+    assert_eq!(string('\\r'), ~\"\\\\r\");\n+    assert_eq!(string('\\''), ~\"\\\\'\");\n+    assert_eq!(string('\"'), ~\"\\\\\\\"\");\n+    assert_eq!(string(' '), ~\" \");\n+    assert_eq!(string('a'), ~\"a\");\n+    assert_eq!(string('~'), ~\"~\");\n+    assert_eq!(string('\\x00'), ~\"\\\\x00\");\n+    assert_eq!(string('\\x1f'), ~\"\\\\x1f\");\n+    assert_eq!(string('\\x7f'), ~\"\\\\x7f\");\n+    assert_eq!(string('\\xff'), ~\"\\\\xff\");\n+    assert_eq!(string('\\u011b'), ~\"\\\\u011b\");\n+    assert_eq!(string('\\U0001d4b6'), ~\"\\\\U0001d4b6\");\n }\n \n #[test]\n fn test_escape_unicode() {\n-    assert_eq!('\\x00'.escape_unicode(), ~\"\\\\x00\");\n-    assert_eq!('\\n'.escape_unicode(), ~\"\\\\x0a\");\n-    assert_eq!(' '.escape_unicode(), ~\"\\\\x20\");\n-    assert_eq!('a'.escape_unicode(), ~\"\\\\x61\");\n-    assert_eq!('\\u011b'.escape_unicode(), ~\"\\\\u011b\");\n-    assert_eq!('\\U0001d4b6'.escape_unicode(), ~\"\\\\U0001d4b6\");\n+    fn string(c: char) -> ~str {\n+        let mut result = ~\"\";\n+        do escape_unicode(c) |c| { result.push_char(c); }\n+        return result;\n+    }\n+    assert_eq!(string('\\x00'), ~\"\\\\x00\");\n+    assert_eq!(string('\\n'), ~\"\\\\x0a\");\n+    assert_eq!(string(' '), ~\"\\\\x20\");\n+    assert_eq!(string('a'), ~\"\\\\x61\");\n+    assert_eq!(string('\\u011b'), ~\"\\\\u011b\");\n+    assert_eq!(string('\\U0001d4b6'), ~\"\\\\U0001d4b6\");\n }"}, {"sha": "0b6eb766b2990077b85cff5063642a415bda42b3", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=179040033545beac0e8f4aea8bbbf2e08469dc7a", "patch": "@@ -754,8 +754,8 @@ impl Float for f32 {\n ///\n #[inline]\n pub fn to_str(num: f32) -> ~str {\n-    let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -768,8 +768,8 @@ pub fn to_str(num: f32) -> ~str {\n ///\n #[inline]\n pub fn to_str_hex(num: f32) -> ~str {\n-    let (r, _) = strconv::to_str_common(\n-        &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -789,8 +789,8 @@ pub fn to_str_hex(num: f32) -> ~str {\n ///\n #[inline]\n pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n-    let (r, special) = strconv::to_str_common(\n-        &num, rdx, true, strconv::SignNeg, strconv::DigAll);\n+    let (r, special) = strconv::float_to_str_common(\n+        num, rdx, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(\"number has a special value, \\\n                       try to_str_radix_special() if those are expected\") }\n     r\n@@ -807,7 +807,7 @@ pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n ///\n #[inline]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n-    strconv::to_str_common(&num, rdx, true,\n+    strconv::float_to_str_common(num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n \n@@ -822,8 +822,8 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n ///\n #[inline]\n pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n-    let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n }\n \n@@ -838,8 +838,8 @@ pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n ///\n #[inline]\n pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n-    let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n "}, {"sha": "c39c7a3a57d213c15839127fe61a181cbb0e8828", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=179040033545beac0e8f4aea8bbbf2e08469dc7a", "patch": "@@ -796,8 +796,8 @@ impl Float for f64 {\n ///\n #[inline]\n pub fn to_str(num: f64) -> ~str {\n-    let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -810,8 +810,8 @@ pub fn to_str(num: f64) -> ~str {\n ///\n #[inline]\n pub fn to_str_hex(num: f64) -> ~str {\n-    let (r, _) = strconv::to_str_common(\n-        &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -831,8 +831,8 @@ pub fn to_str_hex(num: f64) -> ~str {\n ///\n #[inline]\n pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n-    let (r, special) = strconv::to_str_common(\n-        &num, rdx, true, strconv::SignNeg, strconv::DigAll);\n+    let (r, special) = strconv::float_to_str_common(\n+        num, rdx, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(\"number has a special value, \\\n                       try to_str_radix_special() if those are expected\") }\n     r\n@@ -849,7 +849,7 @@ pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n ///\n #[inline]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n-    strconv::to_str_common(&num, rdx, true,\n+    strconv::float_to_str_common(num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n \n@@ -864,8 +864,8 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n ///\n #[inline]\n pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n-    let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n }\n \n@@ -880,8 +880,8 @@ pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n ///\n #[inline]\n pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n-    let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n "}, {"sha": "7a6e3042e7b7523b83b15173db01bfc7c4e67ee3", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=179040033545beac0e8f4aea8bbbf2e08469dc7a", "patch": "@@ -101,8 +101,8 @@ pub mod consts {\n ///\n #[inline]\n pub fn to_str(num: float) -> ~str {\n-    let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -115,8 +115,8 @@ pub fn to_str(num: float) -> ~str {\n ///\n #[inline]\n pub fn to_str_hex(num: float) -> ~str {\n-    let (r, _) = strconv::to_str_common(\n-        &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -136,8 +136,8 @@ pub fn to_str_hex(num: float) -> ~str {\n ///\n #[inline]\n pub fn to_str_radix(num: float, radix: uint) -> ~str {\n-    let (r, special) = strconv::to_str_common(\n-        &num, radix, true, strconv::SignNeg, strconv::DigAll);\n+    let (r, special) = strconv::float_to_str_common(\n+        num, radix, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(\"number has a special value, \\\n                          try to_str_radix_special() if those are expected\") }\n     r\n@@ -154,7 +154,7 @@ pub fn to_str_radix(num: float, radix: uint) -> ~str {\n ///\n #[inline]\n pub fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n-    strconv::to_str_common(&num, radix, true,\n+    strconv::float_to_str_common(num, radix, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n \n@@ -169,8 +169,8 @@ pub fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n ///\n #[inline]\n pub fn to_str_exact(num: float, digits: uint) -> ~str {\n-    let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, strconv::SignNeg, strconv::DigExact(digits));\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigExact(digits));\n     r\n }\n \n@@ -185,8 +185,8 @@ pub fn to_str_exact(num: float, digits: uint) -> ~str {\n ///\n #[inline]\n pub fn to_str_digits(num: float, digits: uint) -> ~str {\n-    let (r, _) = strconv::to_str_common(\n-        &num, 10u, true, strconv::SignNeg, strconv::DigMax(digits));\n+    let (r, _) = strconv::float_to_str_common(\n+        num, 10u, true, strconv::SignNeg, strconv::DigMax(digits));\n     r\n }\n "}, {"sha": "f152d60cb7a355c94944af34cb220a00771908d2", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=179040033545beac0e8f4aea8bbbf2e08469dc7a", "patch": "@@ -17,6 +17,7 @@ macro_rules! int_module (($T:ty, $bits:expr) => (mod generated {\n use num::{ToStrRadix, FromStrRadix};\n use num::{Zero, One, strconv};\n use prelude::*;\n+use str;\n \n pub use cmp::{min, max};\n \n@@ -529,25 +530,33 @@ impl FromStrRadix for $T {\n /// Convert to a string as a byte slice in a given base.\n #[inline]\n pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n-    let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n-                            strconv::SignNeg, strconv::DigAll);\n-    f(buf)\n+    // The radix can be as low as 2, so we need at least 64 characters for a\n+    // base 2 number, and then we need another for a possible '-' character.\n+    let mut buf = [0u8, ..65];\n+    let mut cur = 0;\n+    do strconv::int_to_str_bytes_common(n, radix, strconv::SignNeg) |i| {\n+        buf[cur] = i;\n+        cur += 1;\n+    }\n+    f(buf.slice(0, cur))\n }\n \n /// Convert to a string in base 10.\n #[inline]\n pub fn to_str(num: $T) -> ~str {\n-    let (buf, _) = strconv::to_str_common(&num, 10u, false,\n-                                      strconv::SignNeg, strconv::DigAll);\n-    buf\n+    to_str_radix(num, 10u)\n }\n \n /// Convert to a string in a given base.\n #[inline]\n pub fn to_str_radix(num: $T, radix: uint) -> ~str {\n-    let (buf, _) = strconv::to_str_common(&num, radix, false,\n-                                      strconv::SignNeg, strconv::DigAll);\n-    buf\n+    let mut buf: ~[u8] = ~[];\n+    do strconv::int_to_str_bytes_common(num, radix, strconv::SignNeg) |i| {\n+        buf.push(i);\n+    }\n+    // We know we generated valid utf-8, so we don't need to go through that\n+    // check.\n+    unsafe { str::raw::from_bytes_owned(buf) }\n }\n \n impl ToStr for $T {"}, {"sha": "1b1b82190d55283d1ebc73aa1af47905beb27429", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 113, "deletions": 83, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=179040033545beac0e8f4aea8bbbf2e08469dc7a", "patch": "@@ -16,13 +16,13 @@ use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n use char;\n use str;\n-use str::{StrSlice};\n+use str::StrSlice;\n use kinds::Copy;\n use vec;\n use vec::{CopyableVector, ImmutableVector};\n use vec::OwnedVector;\n-use num::{NumCast, Zero, One, cast, pow_with_uint};\n-use f64;\n+use num::{NumCast, Zero, One, cast, pow_with_uint, Integer};\n+use num::{Round, Float, FPNaN, FPInfinite};\n \n pub enum ExponentFormat {\n     ExpNone,\n@@ -42,35 +42,6 @@ pub enum SignFormat {\n     SignAll\n }\n \n-#[inline]\n-fn is_NaN<T:Eq>(num: &T) -> bool {\n-    *num != *num\n-}\n-\n-#[inline]\n-fn is_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n-    match NumStrConv::inf() {\n-        None    => false,\n-        Some(n) => *num == n\n-    }\n-}\n-\n-#[inline]\n-fn is_neg_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n-    match NumStrConv::neg_inf() {\n-        None    => false,\n-        Some(n) => *num == n\n-    }\n-}\n-\n-#[inline]\n-fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Div<T,T>>(num: &T) -> bool {\n-    let _0: T = Zero::zero();\n-    let _1: T = One::one();\n-\n-    *num == _0 && is_neg_inf(&(_1 / *num))\n-}\n-\n pub trait NumStrConv {\n     fn NaN()      -> Option<Self>;\n     fn inf()      -> Option<Self>;\n@@ -93,16 +64,9 @@ macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n         fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n \n         #[inline]\n-        fn round_to_zero(&self) -> $t {\n-            ( if *self < 0.0 { f64::ceil(*self as f64)  }\n-              else           { f64::floor(*self as f64) }\n-            ) as $t\n-        }\n-\n+        fn round_to_zero(&self) -> $t { self.trunc() }\n         #[inline]\n-        fn fractional_part(&self) -> $t {\n-            *self - self.round_to_zero()\n-        }\n+        fn fractional_part(&self) -> $t { self.fract() }\n     }\n ))\n \n@@ -145,6 +109,87 @@ static negative_inf_buf: [u8, ..4] = ['-' as u8, 'i' as u8, 'n' as u8,\n                                       'f' as u8];\n static nan_buf:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n \n+/**\n+ * Converts an integral number to its string representation as a byte vector.\n+ * This is meant to be a common base implementation for all integral string\n+ * conversion functions like `to_str()` or `to_str_radix()`.\n+ *\n+ * # Arguments\n+ * - `num`           - The number to convert. Accepts any number that\n+ *                     implements the numeric traits.\n+ * - `radix`         - Base to use. Accepts only the values 2-36.\n+ * - `sign`          - How to emit the sign. Options are:\n+ *     - `SignNone`: No sign at all. Basically emits `abs(num)`.\n+ *     - `SignNeg`:  Only `-` on negative values.\n+ *     - `SignAll`:  Both `+` on positive, and `-` on negative numbers.\n+ * - `f`             - a callback which will be invoked for each ascii character\n+ *                     which composes the string representation of this integer\n+ *\n+ * # Return value\n+ * A tuple containing the byte vector, and a boolean flag indicating\n+ * whether it represents a special value like `inf`, `-inf`, `NaN` or not.\n+ * It returns a tuple because there can be ambiguity between a special value\n+ * and a number representation at higher bases.\n+ *\n+ * # Failure\n+ * - Fails if `radix` < 2 or `radix` > 36.\n+ */\n+pub fn int_to_str_bytes_common<T:NumCast+Zero+Eq+Ord+Integer+\n+                                 Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n+        num: T, radix: uint, sign: SignFormat, f: &fn(u8)) {\n+    assert!(2 <= radix && radix <= 36);\n+\n+    let _0: T = Zero::zero();\n+\n+    let neg = num < _0;\n+    let radix_gen: T = cast(radix);\n+\n+    let mut deccum = num;\n+    // This is just for integral types, the largest of which is a u64. The\n+    // smallest base that we can have is 2, so the most number of digits we're\n+    // ever going to have is 64\n+    let mut buf = [0u8, ..64];\n+    let mut cur = 0;\n+\n+    // Loop at least once to make sure at least a `0` gets emitted.\n+    loop {\n+        // Calculate the absolute value of each digit instead of only\n+        // doing it once for the whole number because a\n+        // representable negative number doesn't necessary have an\n+        // representable additive inverse of the same type\n+        // (See twos complement). But we assume that for the\n+        // numbers [-35 .. 0] we always have [0 .. 35].\n+        let current_digit_signed = deccum % radix_gen;\n+        let current_digit = if current_digit_signed < _0 {\n+            -current_digit_signed\n+        } else {\n+            current_digit_signed\n+        };\n+        buf[cur] = match current_digit.to_u8() {\n+            i @ 0..9 => '0' as u8 + i,\n+            i        => 'a' as u8 + (i - 10),\n+        };\n+        cur += 1;\n+\n+        deccum = deccum / radix_gen;\n+        // No more digits to calculate for the non-fractional part -> break\n+        if deccum == _0 { break; }\n+    }\n+\n+    // Decide what sign to put in front\n+    match sign {\n+        SignNeg | SignAll if neg => { f('-' as u8); }\n+        SignAll => { f('+' as u8); }\n+        _ => ()\n+    }\n+\n+    // We built the number in reverse order, so un-reverse it here\n+    while cur > 0 {\n+        cur -= 1;\n+        f(buf[cur]);\n+    }\n+}\n+\n /**\n  * Converts a number to its string representation as a byte vector.\n  * This is meant to be a common base implementation for all numeric string\n@@ -176,61 +221,51 @@ static nan_buf:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n-pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n+pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n                                   Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n-        num: &T, radix: uint, negative_zero: bool,\n+        num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n-    if (radix as int) < 2 {\n-        fail!(\"to_str_bytes_common: radix %? to low, must lie in the range [2, 36]\", radix);\n-    } else if radix as int > 36 {\n-        fail!(\"to_str_bytes_common: radix %? to high, must lie in the range [2, 36]\", radix);\n-    }\n+    assert!(2 <= radix && radix <= 36);\n \n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n \n-    if is_NaN(num) {\n-        return (\"NaN\".as_bytes().to_owned(), true);\n-    }\n-    else if is_inf(num){\n-        return match sign {\n-            SignAll => (\"+inf\".as_bytes().to_owned(), true),\n-            _       => (\"inf\".as_bytes().to_owned(), true)\n+    match num.classify() {\n+        FPNaN => { return (\"NaN\".as_bytes().to_owned(), true); }\n+        FPInfinite if num > _0 => {\n+            return match sign {\n+                SignAll => (\"+inf\".as_bytes().to_owned(), true),\n+                _       => (\"inf\".as_bytes().to_owned(), true)\n+            };\n         }\n-    }\n-    else if is_neg_inf(num) {\n-        return match sign {\n-            SignNone => (\"inf\".as_bytes().to_owned(), true),\n-            _        => (\"-inf\".as_bytes().to_owned(), true),\n+        FPInfinite if num < _0 => {\n+            return match sign {\n+                SignNone => (\"inf\".as_bytes().to_owned(), true),\n+                _        => (\"-inf\".as_bytes().to_owned(), true),\n+            };\n         }\n+        _ => {}\n     }\n \n-    let neg = *num < _0 || (negative_zero && is_neg_zero(num));\n+    let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n     let mut buf: ~[u8] = ~[];\n     let radix_gen: T   = cast(radix as int);\n \n-    let mut deccum;\n-\n     // First emit the non-fractional part, looping at least once to make\n     // sure at least a `0` gets emitted.\n-    deccum = num.round_to_zero();\n+    let mut deccum = num.trunc();\n     loop {\n         // Calculate the absolute value of each digit instead of only\n         // doing it once for the whole number because a\n         // representable negative number doesn't necessary have an\n         // representable additive inverse of the same type\n         // (See twos complement). But we assume that for the\n         // numbers [-35 .. 0] we always have [0 .. 35].\n-        let current_digit_signed = deccum % radix_gen;\n-        let current_digit = if current_digit_signed < _0 {\n-            -current_digit_signed\n-        } else {\n-            current_digit_signed\n-        };\n+        let current_digit = (deccum % radix_gen).abs();\n \n         // Decrease the deccumulator one digit at a time\n         deccum = deccum / radix_gen;\n-        deccum = deccum.round_to_zero();\n+        deccum = deccum.trunc();\n \n         buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n              .unwrap() as u8);\n@@ -265,7 +300,7 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n     let start_fractional_digits = buf.len();\n \n     // Now emit the fractional part, if any\n-    deccum = num.fractional_part();\n+    deccum = num.fract();\n     if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n         buf.push('.' as u8);\n         let mut dig = 0u;\n@@ -286,18 +321,13 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n \n             // Calculate the absolute value of each digit.\n             // See note in first loop.\n-            let current_digit_signed = deccum.round_to_zero();\n-            let current_digit = if current_digit_signed < _0 {\n-                -current_digit_signed\n-            } else {\n-                current_digit_signed\n-            };\n+            let current_digit = deccum.trunc().abs();\n \n             buf.push(char::from_digit(\n                 current_digit.to_int() as uint, radix).unwrap() as u8);\n \n             // Decrease the deccumulator one fractional digit at a time\n-            deccum = deccum.fractional_part();\n+            deccum = deccum.fract();\n             dig += 1u;\n         }\n \n@@ -382,11 +412,11 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n  * `to_str_bytes_common()`, for details see there.\n  */\n #[inline]\n-pub fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n-                            Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n-        num: &T, radix: uint, negative_zero: bool,\n+pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+Round+\n+                             Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n+        num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n-    let (bytes, special) = to_str_bytes_common(num, radix,\n+    let (bytes, special) = float_to_str_bytes_common(num, radix,\n                                negative_zero, sign, digits);\n     (str::from_bytes(bytes), special)\n }"}, {"sha": "25e338fcd0f64a80f20027283ea3b260260760c2", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=179040033545beac0e8f4aea8bbbf2e08469dc7a", "patch": "@@ -18,6 +18,7 @@ use num::BitCount;\n use num::{ToStrRadix, FromStrRadix};\n use num::{Zero, One, strconv};\n use prelude::*;\n+use str;\n \n pub use cmp::{min, max};\n \n@@ -356,25 +357,33 @@ impl FromStrRadix for $T {\n /// Convert to a string as a byte slice in a given base.\n #[inline]\n pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n-    let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n-                            strconv::SignNeg, strconv::DigAll);\n-    f(buf)\n+    // The radix can be as low as 2, so we need at least 64 characters for a\n+    // base 2 number.\n+    let mut buf = [0u8, ..64];\n+    let mut cur = 0;\n+    do strconv::int_to_str_bytes_common(n, radix, strconv::SignNone) |i| {\n+        buf[cur] = i;\n+        cur += 1;\n+    }\n+    f(buf.slice(0, cur))\n }\n \n /// Convert to a string in base 10.\n #[inline]\n pub fn to_str(num: $T) -> ~str {\n-    let (buf, _) = strconv::to_str_common(&num, 10u, false,\n-                            strconv::SignNeg, strconv::DigAll);\n-    buf\n+    to_str_radix(num, 10u)\n }\n \n /// Convert to a string in a given base.\n #[inline]\n pub fn to_str_radix(num: $T, radix: uint) -> ~str {\n-    let (buf, _) = strconv::to_str_common(&num, radix, false,\n-                            strconv::SignNeg, strconv::DigAll);\n-    buf\n+    let mut buf = ~[];\n+    do strconv::int_to_str_bytes_common(num, radix, strconv::SignNone) |i| {\n+        buf.push(i);\n+    }\n+    // We know we generated valid utf-8, so we don't need to go through that\n+    // check.\n+    unsafe { str::raw::from_bytes_owned(buf) }\n }\n \n impl ToStr for $T {"}, {"sha": "fdda65d3e95b8c9acea2d491f1a3a6def0612275", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 27, "deletions": 57, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=179040033545beac0e8f4aea8bbbf2e08469dc7a", "patch": "@@ -57,9 +57,9 @@ impl EscapedCharWriter for @Writer {\n             '\"' => self.write_str(\"\\\\\\\"\"),\n             '\\x20'..'\\x7e' => self.write_char(ch),\n             _ => {\n-                // FIXME #4423: This is inefficient because it requires a\n-                // malloc.\n-                self.write_str(char::escape_unicode(ch))\n+                do char::escape_unicode(ch) |c| {\n+                    self.write_char(c);\n+                }\n             }\n         }\n     }\n@@ -81,65 +81,35 @@ impl Repr for bool {\n     }\n }\n \n-impl Repr for int {\n-    fn write_repr(&self, writer: @Writer) { writer.write_int(*self); }\n-}\n-impl Repr for i8 {\n-    fn write_repr(&self, writer: @Writer) { writer.write_int(*self as int); }\n-}\n-impl Repr for i16 {\n-    fn write_repr(&self, writer: @Writer) { writer.write_int(*self as int); }\n-}\n-impl Repr for i32 {\n-    fn write_repr(&self, writer: @Writer) { writer.write_int(*self as int); }\n-}\n-impl Repr for i64 {\n-    // FIXME #4424: This can lose precision.\n-    fn write_repr(&self, writer: @Writer) { writer.write_int(*self as int); }\n-}\n-\n-impl Repr for uint {\n-    fn write_repr(&self, writer: @Writer) { writer.write_uint(*self); }\n-}\n-impl Repr for u8 {\n-    fn write_repr(&self, writer: @Writer) {\n-        writer.write_uint(*self as uint);\n-    }\n-}\n-impl Repr for u16 {\n+macro_rules! int_repr(($ty:ident) => (impl Repr for $ty {\n     fn write_repr(&self, writer: @Writer) {\n-        writer.write_uint(*self as uint);\n-    }\n-}\n-impl Repr for u32 {\n-    fn write_repr(&self, writer: @Writer) {\n-        writer.write_uint(*self as uint);\n-    }\n-}\n-impl Repr for u64 {\n-    // FIXME #4424: This can lose precision.\n-    fn write_repr(&self, writer: @Writer) {\n-        writer.write_uint(*self as uint);\n+        do ::$ty::to_str_bytes(*self, 10u) |bits| {\n+            writer.write(bits);\n+        }\n     }\n-}\n+}))\n \n-impl Repr for float {\n-    // FIXME #4423: This mallocs.\n-    fn write_repr(&self, writer: @Writer) { writer.write_str(self.to_str()); }\n-}\n-impl Repr for f32 {\n-    // FIXME #4423 This mallocs.\n-    fn write_repr(&self, writer: @Writer) { writer.write_str(self.to_str()); }\n-}\n-impl Repr for f64 {\n-    // FIXME #4423: This mallocs.\n-    fn write_repr(&self, writer: @Writer) { writer.write_str(self.to_str()); }\n-}\n+int_repr!(int)\n+int_repr!(i8)\n+int_repr!(i16)\n+int_repr!(i32)\n+int_repr!(i64)\n+int_repr!(uint)\n+int_repr!(u8)\n+int_repr!(u16)\n+int_repr!(u32)\n+int_repr!(u64)\n \n-impl Repr for char {\n-    fn write_repr(&self, writer: @Writer) { writer.write_char(*self); }\n-}\n+macro_rules! num_repr(($ty:ident) => (impl Repr for $ty {\n+    fn write_repr(&self, writer: @Writer) {\n+        let s = self.to_str();\n+        writer.write(s.as_bytes());\n+    }\n+}))\n \n+num_repr!(float)\n+num_repr!(f32)\n+num_repr!(f64)\n \n // New implementation using reflect::MovePtr\n "}, {"sha": "4115cad65594067e91f914150d865d15801f23b5", "filename": "src/libstd/str.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=179040033545beac0e8f4aea8bbbf2e08469dc7a", "patch": "@@ -54,7 +54,6 @@ Section: Creating a string\n  *\n  * Raises the `not_utf8` condition if invalid UTF-8\n  */\n-\n pub fn from_bytes(vv: &[u8]) -> ~str {\n     use str::not_utf8::cond;\n \n@@ -68,6 +67,25 @@ pub fn from_bytes(vv: &[u8]) -> ~str {\n     }\n }\n \n+/**\n+ * Consumes a vector of bytes to create a new utf-8 string\n+ *\n+ * # Failure\n+ *\n+ * Raises the `not_utf8` condition if invalid UTF-8\n+ */\n+pub fn from_bytes_owned(vv: ~[u8]) -> ~str {\n+    use str::not_utf8::cond;\n+\n+    if !is_utf8(vv) {\n+        let first_bad_byte = *vv.iter().find_(|&b| !is_utf8([*b])).get();\n+        cond.raise(fmt!(\"from_bytes: input is not UTF-8; first bad byte is %u\",\n+                        first_bad_byte as uint))\n+    } else {\n+        return unsafe { raw::from_bytes_owned(vv) }\n+    }\n+}\n+\n /**\n  * Convert a vector of bytes to a UTF-8 string.\n  * The vector needs to be one byte longer than the string, and end with a 0 byte.\n@@ -850,6 +868,13 @@ pub mod raw {\n         }\n     }\n \n+    /// Converts an owned vector of bytes to a new owned string. This assumes\n+    /// that the utf-8-ness of the vector has already been validated\n+    pub unsafe fn from_bytes_owned(mut v: ~[u8]) -> ~str {\n+        v.push(0u8);\n+        cast::transmute(v)\n+    }\n+\n     /// Converts a vector of bytes to a string.\n     /// The byte slice needs to contain valid utf8 and needs to be one byte longer than\n     /// the string, if possible ending in a 0 byte.\n@@ -1472,7 +1497,9 @@ impl<'self> StrSlice<'self> for &'self str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n         for self.iter().advance |c| {\n-            out.push_str(char::escape_default(c));\n+            do c.escape_default |c| {\n+                out.push_char(c);\n+            }\n         }\n         out\n     }\n@@ -1482,7 +1509,9 @@ impl<'self> StrSlice<'self> for &'self str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n         for self.iter().advance |c| {\n-            out.push_str(char::escape_unicode(c));\n+            do c.escape_unicode |c| {\n+                out.push_char(c);\n+            }\n         }\n         out\n     }"}, {"sha": "a50fa4168320cc01b8a677addea9eb87e4eeb08d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=179040033545beac0e8f4aea8bbbf2e08469dc7a", "patch": "@@ -16,7 +16,6 @@ use util::interner::StrInterner;\n use util::interner;\n \n use std::cast;\n-use std::char;\n use std::cmp::Equiv;\n use std::local_data;\n use std::rand;\n@@ -166,7 +165,12 @@ pub fn to_str(in: @ident_interner, t: &Token) -> ~str {\n \n       /* Literals */\n       LIT_INT(c, ast::ty_char) => {\n-        ~\"'\" + char::escape_default(c as char) + \"'\"\n+          let mut res = ~\"'\";\n+          do (c as char).escape_default |c| {\n+              res.push_char(c);\n+          }\n+          res.push_char('\\'');\n+          res\n       }\n       LIT_INT(i, t) => {\n           i.to_str() + ast_util::int_ty_to_str(t)"}, {"sha": "5e685d85f95df1bbc75716859439434abe8502ea", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179040033545beac0e8f4aea8bbbf2e08469dc7a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=179040033545beac0e8f4aea8bbbf2e08469dc7a", "patch": "@@ -27,7 +27,6 @@ use print::pp::{breaks, consistent, inconsistent, eof};\n use print::pp;\n use print::pprust;\n \n-use std::char;\n use std::io;\n use std::u64;\n use std::uint;\n@@ -2016,7 +2015,12 @@ pub fn print_literal(s: @ps, lit: @ast::lit) {\n     match lit.node {\n       ast::lit_str(st) => print_string(s, st),\n       ast::lit_int(ch, ast::ty_char) => {\n-        word(s.s, ~\"'\" + char::escape_default(ch as char) + \"'\");\n+          let mut res = ~\"'\";\n+          do (ch as char).escape_default |c| {\n+              res.push_char(c);\n+          }\n+          res.push_char('\\'');\n+          word(s.s, res);\n       }\n       ast::lit_int(i, t) => {\n         if i < 0_i64 {"}]}