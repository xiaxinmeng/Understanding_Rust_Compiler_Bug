{"sha": "70f74719a92ef52bc28610ba04b7e98ada035ec9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwZjc0NzE5YTkyZWY1MmJjMjg2MTBiYTA0YjdlOThhZGEwMzVlYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-25T13:51:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-25T13:51:48Z"}, "message": "Auto merge of #85646 - Moxinilian:separate-const-switch, r=cjgillot\n\nMIR opt: separate constant predecessors of a switch\n\nFor each block S ending with a switch, this pass copies S for each of S's predecessors that seem to assign the value being switched over as a const. This is done using a somewhat simple heuristic to determine what seems to be a const transitively.\n\nMore precisely, this is what the pass does:\n- find a block that ends in a switch\n- track if there is an unique place set before the current basic block that determines the result of the switch (this is the part that resolves switching over discriminants)\n- if there is, iterate over the parents that have a reasonable terminator and find if the found determining place is likely to be (transitively) set from a const within that parent block\n- if so, add the corresponding edge to a vector of edges to duplicate\n- once this is done, iterate over the found edges: copy the target block and replace the reference to the target block in the origin block with the new block\n\nThis pass is not optimal and could probably duplicate in more cases, but the intention was mostly to address cases like in #85133 or #85365, to avoid creating new enums that get destroyed immediately afterwards (notably making the new try v2 `?` desugar zero-cost).\n\nA benefit of this pass working the way it does is that it is easy to ensure its correctness: the worst that can happen is for it to needlessly copy a basic block, which is likely to be destroyed by cleanup passes afterwards. The complex parts where aliasing matters are only heuristics and the hard work is left to further passes like ConstProp.\n\n# LLVM blocker\n\nUnfortunately, I believe it would be unwise to enable this optimization by default for now. Indeed, currently switch lowering passes like SimplifyCFG in LLVM lose the information on the set of possible variant values, which means it tends to actually generate worse code with this optimization enabled. A fix would have to be done in LLVM itself. This is something I also want to look into. I have opened [a bug report at the LLVM bug tracker](https://bugs.llvm.org/show_bug.cgi?id=50455).\n\nWhen this is done, I hope we can enable this pass by default. It should be fairly fast and I think it is beneficial in many cases. Notably, it should be a sound alternative to simplify-arm-identity. By the way, ConstProp only seems to pick up the optimization in functions that are not generic. This is however most likely an issue in ConstProp that I will look into afterwards.\n\nThis is my first contribution to rustc, and I would like to thank everyone on the Zulip mir-opt chat for the help and support, and especially `@scottmcm` for the guidance.", "tree": {"sha": "884d990b4a01abddb5ded9f557791ab1854178e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/884d990b4a01abddb5ded9f557791ab1854178e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70f74719a92ef52bc28610ba04b7e98ada035ec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70f74719a92ef52bc28610ba04b7e98ada035ec9", "html_url": "https://github.com/rust-lang/rust/commit/70f74719a92ef52bc28610ba04b7e98ada035ec9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70f74719a92ef52bc28610ba04b7e98ada035ec9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6489ee10410f7be70dbefad322d1a3e1533ab282", "url": "https://api.github.com/repos/rust-lang/rust/commits/6489ee10410f7be70dbefad322d1a3e1533ab282", "html_url": "https://github.com/rust-lang/rust/commit/6489ee10410f7be70dbefad322d1a3e1533ab282"}, {"sha": "a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "html_url": "https://github.com/rust-lang/rust/commit/a77e2ad5338e0c417dd5c4f5958b8aab526322d6"}], "stats": {"total": 1055, "additions": 1055, "deletions": 0}, "files": [{"sha": "bbe83aa3bd8adc3ee194d4aeabc618c737a486e0", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70f74719a92ef52bc28610ba04b7e98ada035ec9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f74719a92ef52bc28610ba04b7e98ada035ec9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=70f74719a92ef52bc28610ba04b7e98ada035ec9", "patch": "@@ -48,6 +48,7 @@ pub mod remove_unneeded_drops;\n pub mod remove_zsts;\n pub mod required_consts;\n pub mod rustc_peek;\n+pub mod separate_const_switch;\n pub mod simplify;\n pub mod simplify_branches;\n pub mod simplify_comparison_integral;\n@@ -501,6 +502,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // inst combine is after MatchBranchSimplification to clean up Ne(_1, false)\n         &multiple_return_terminators::MultipleReturnTerminators,\n         &instcombine::InstCombine,\n+        &separate_const_switch::SeparateConstSwitch,\n         &const_prop::ConstProp,\n         &simplify_branches::SimplifyBranches::new(\"after-const-prop\"),\n         &early_otherwise_branch::EarlyOtherwiseBranch,"}, {"sha": "87cd27984a073a214cb00c23d26143fa4419d598", "filename": "compiler/rustc_mir/src/transform/separate_const_switch.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/70f74719a92ef52bc28610ba04b7e98ada035ec9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fseparate_const_switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f74719a92ef52bc28610ba04b7e98ada035ec9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fseparate_const_switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fseparate_const_switch.rs?ref=70f74719a92ef52bc28610ba04b7e98ada035ec9", "patch": "@@ -0,0 +1,343 @@\n+//! A pass that duplicates switch-terminated blocks\n+//! into a new copy for each predecessor, provided\n+//! the predecessor sets the value being switched\n+//! over to a constant.\n+//!\n+//! The purpose of this pass is to help constant\n+//! propagation passes to simplify the switch terminator\n+//! of the copied blocks into gotos when some predecessors\n+//! statically determine the output of switches.\n+//!\n+//! ```text\n+//!     x = 12 ---              ---> something\n+//!               \\            / 12\n+//!                --> switch x\n+//!               /            \\ otherwise\n+//!     x = y  ---              ---> something else\n+//! ```\n+//! becomes\n+//! ```text\n+//!     x = 12 ---> switch x ------> something\n+//!                          \\ / 12\n+//!                           X\n+//!                          / \\ otherwise\n+//!     x = y  ---> switch x ------> something else\n+//! ```\n+//! so it can hopefully later be turned by another pass into\n+//! ```text\n+//!     x = 12 --------------------> something\n+//!                            / 12\n+//!                           /\n+//!                          /   otherwise\n+//!     x = y  ---- switch x ------> something else\n+//! ```\n+//!\n+//! This optimization is meant to cover simple cases\n+//! like `?` desugaring. For now, it thus focuses on\n+//! simplicity rather than completeness (it notably\n+//! sometimes duplicates abusively).\n+\n+use crate::transform::MirPass;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::TyCtxt;\n+use smallvec::SmallVec;\n+\n+pub struct SeparateConstSwitch;\n+\n+impl<'tcx> MirPass<'tcx> for SeparateConstSwitch {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        if tcx.sess.mir_opt_level() < 4 {\n+            return;\n+        }\n+\n+        // If execution did something, applying a simplification layer\n+        // helps later passes optimize the copy away.\n+        if separate_const_switch(body) > 0 {\n+            super::simplify::simplify_cfg(tcx, body);\n+        }\n+    }\n+}\n+\n+/// Returns the amount of blocks that were duplicated\n+pub fn separate_const_switch<'tcx>(body: &mut Body<'tcx>) -> usize {\n+    let mut new_blocks: SmallVec<[(BasicBlock, BasicBlock); 6]> = SmallVec::new();\n+    let predecessors = body.predecessors();\n+    'block_iter: for (block_id, block) in body.basic_blocks().iter_enumerated() {\n+        if let TerminatorKind::SwitchInt {\n+            discr: Operand::Copy(switch_place) | Operand::Move(switch_place),\n+            ..\n+        } = block.terminator().kind\n+        {\n+            // If the block is on an unwind path, do not\n+            // apply the optimization as unwind paths\n+            // rely on a unique parent invariant\n+            if block.is_cleanup {\n+                continue 'block_iter;\n+            }\n+\n+            // If the block has fewer than 2 predecessors, ignore it\n+            // we could maybe chain blocks that have exactly one\n+            // predecessor, but for now we ignore that\n+            if predecessors[block_id].len() < 2 {\n+                continue 'block_iter;\n+            }\n+\n+            // First, let's find a non-const place\n+            // that determines the result of the switch\n+            if let Some(switch_place) = find_determining_place(switch_place, block) {\n+                // We now have an input place for which it would\n+                // be interesting if predecessors assigned it from a const\n+\n+                let mut predecessors_left = predecessors[block_id].len();\n+                'predec_iter: for predecessor_id in predecessors[block_id].iter().copied() {\n+                    let predecessor = &body.basic_blocks()[predecessor_id];\n+\n+                    // First we make sure the predecessor jumps\n+                    // in a reasonable way\n+                    match &predecessor.terminator().kind {\n+                        // The following terminators are\n+                        // unconditionally valid\n+                        TerminatorKind::Goto { .. } | TerminatorKind::SwitchInt { .. } => {}\n+\n+                        TerminatorKind::FalseEdge { real_target, .. } => {\n+                            if *real_target != block_id {\n+                                continue 'predec_iter;\n+                            }\n+                        }\n+\n+                        // The following terminators are not allowed\n+                        TerminatorKind::Resume\n+                        | TerminatorKind::Drop { .. }\n+                        | TerminatorKind::DropAndReplace { .. }\n+                        | TerminatorKind::Call { .. }\n+                        | TerminatorKind::Assert { .. }\n+                        | TerminatorKind::FalseUnwind { .. }\n+                        | TerminatorKind::Yield { .. }\n+                        | TerminatorKind::Abort\n+                        | TerminatorKind::Return\n+                        | TerminatorKind::Unreachable\n+                        | TerminatorKind::InlineAsm { .. }\n+                        | TerminatorKind::GeneratorDrop => {\n+                            continue 'predec_iter;\n+                        }\n+                    }\n+\n+                    if is_likely_const(switch_place, predecessor) {\n+                        new_blocks.push((predecessor_id, block_id));\n+                        predecessors_left -= 1;\n+                        if predecessors_left < 2 {\n+                            // If the original block only has one predecessor left,\n+                            // we have nothing left to do\n+                            break 'predec_iter;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Once the analysis is done, perform the duplication\n+    let body_span = body.span;\n+    let copied_blocks = new_blocks.len();\n+    let blocks = body.basic_blocks_mut();\n+    for (pred_id, target_id) in new_blocks {\n+        let new_block = blocks[target_id].clone();\n+        let new_block_id = blocks.push(new_block);\n+        let terminator = blocks[pred_id].terminator_mut();\n+\n+        match terminator.kind {\n+            TerminatorKind::Goto { ref mut target } => {\n+                *target = new_block_id;\n+            }\n+\n+            TerminatorKind::FalseEdge { ref mut real_target, .. } => {\n+                if *real_target == target_id {\n+                    *real_target = new_block_id;\n+                }\n+            }\n+\n+            TerminatorKind::SwitchInt { ref mut targets, .. } => {\n+                targets.all_targets_mut().iter_mut().for_each(|x| {\n+                    if *x == target_id {\n+                        *x = new_block_id;\n+                    }\n+                });\n+            }\n+\n+            TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::Call { .. }\n+            | TerminatorKind::InlineAsm { .. }\n+            | TerminatorKind::Yield { .. } => {\n+                span_bug!(\n+                    body_span,\n+                    \"basic block terminator had unexpected kind {:?}\",\n+                    &terminator.kind\n+                )\n+            }\n+        }\n+    }\n+\n+    copied_blocks\n+}\n+\n+/// This function describes a rough heuristic guessing\n+/// whether a place is last set with a const within the block.\n+/// Notably, it will be overly pessimistic in cases that are already\n+/// not handled by `separate_const_switch`.\n+fn is_likely_const<'tcx>(mut tracked_place: Place<'tcx>, block: &BasicBlockData<'tcx>) -> bool {\n+    for statement in block.statements.iter().rev() {\n+        match &statement.kind {\n+            StatementKind::Assign(assign) => {\n+                if assign.0 == tracked_place {\n+                    match assign.1 {\n+                        // These rvalues are definitely constant\n+                        Rvalue::Use(Operand::Constant(_))\n+                        | Rvalue::Ref(_, _, _)\n+                        | Rvalue::AddressOf(_, _)\n+                        | Rvalue::Cast(_, Operand::Constant(_), _)\n+                        | Rvalue::NullaryOp(_, _)\n+                        | Rvalue::UnaryOp(_, Operand::Constant(_)) => return true,\n+\n+                        // These rvalues make things ambiguous\n+                        Rvalue::Repeat(_, _)\n+                        | Rvalue::ThreadLocalRef(_)\n+                        | Rvalue::Len(_)\n+                        | Rvalue::BinaryOp(_, _)\n+                        | Rvalue::CheckedBinaryOp(_, _)\n+                        | Rvalue::Aggregate(_, _) => return false,\n+\n+                        // These rvalues move the place to track\n+                        Rvalue::Cast(_, Operand::Copy(place) | Operand::Move(place), _)\n+                        | Rvalue::Use(Operand::Copy(place) | Operand::Move(place))\n+                        | Rvalue::UnaryOp(_, Operand::Copy(place) | Operand::Move(place))\n+                        | Rvalue::Discriminant(place) => tracked_place = place,\n+                    }\n+                }\n+            }\n+\n+            // If the discriminant is set, it is always set\n+            // as a constant, so the job is done.\n+            // As we are **ignoring projections**, if the place\n+            // we are tracking sees its discriminant be set,\n+            // that means we had to be tracking the discriminant\n+            // specifically (as it is impossible to switch over\n+            // an enum directly, and if we were switching over\n+            // its content, we would have had to at least cast it to\n+            // some variant first)\n+            StatementKind::SetDiscriminant { place, .. } => {\n+                if **place == tracked_place {\n+                    return true;\n+                }\n+            }\n+\n+            // If inline assembly is found, we probably should\n+            // not try to analyze the code\n+            StatementKind::LlvmInlineAsm(_) => return false,\n+\n+            // These statements have no influence on the place\n+            // we are interested in\n+            StatementKind::FakeRead(_)\n+            | StatementKind::StorageLive(_)\n+            | StatementKind::Retag(_, _)\n+            | StatementKind::AscribeUserType(_, _)\n+            | StatementKind::Coverage(_)\n+            | StatementKind::StorageDead(_)\n+            | StatementKind::CopyNonOverlapping(_)\n+            | StatementKind::Nop => {}\n+        }\n+    }\n+\n+    // If no good reason for the place to be const is found,\n+    // give up. We could maybe go up predecessors, but in\n+    // most cases giving up now should be sufficient.\n+    false\n+}\n+\n+/// Finds a unique place that entirely determines the value\n+/// of `switch_place`, if it exists. This is only a heuristic.\n+/// Ideally we would like to track multiple determining places\n+/// for some edge cases, but one is enough for a lot of situations.\n+fn find_determining_place<'tcx>(\n+    mut switch_place: Place<'tcx>,\n+    block: &BasicBlockData<'tcx>,\n+) -> Option<Place<'tcx>> {\n+    for statement in block.statements.iter().rev() {\n+        match &statement.kind {\n+            StatementKind::Assign(op) => {\n+                if op.0 != switch_place {\n+                    continue;\n+                }\n+\n+                match op.1 {\n+                    // The following rvalues move the place\n+                    // that may be const in the predecessor\n+                    Rvalue::Use(Operand::Move(new) | Operand::Copy(new))\n+                    | Rvalue::UnaryOp(_, Operand::Copy(new) | Operand::Move(new))\n+                    | Rvalue::Cast(_, Operand::Move(new) | Operand::Copy(new), _)\n+                    | Rvalue::Repeat(Operand::Move(new) | Operand::Copy(new), _)\n+                    | Rvalue::Discriminant(new)\n+                    => switch_place = new,\n+\n+                    // The following rvalues might still make the block\n+                    // be valid but for now we reject them\n+                    Rvalue::Len(_)\n+                    | Rvalue::Ref(_, _, _)\n+                    | Rvalue::BinaryOp(_, _)\n+                    | Rvalue::CheckedBinaryOp(_, _)\n+                    | Rvalue::Aggregate(_, _)\n+\n+                    // The following rvalues definitely mean we cannot\n+                    // or should not apply this optimization\n+                    | Rvalue::Use(Operand::Constant(_))\n+                    | Rvalue::Repeat(Operand::Constant(_), _)\n+                    | Rvalue::ThreadLocalRef(_)\n+                    | Rvalue::AddressOf(_, _)\n+                    | Rvalue::NullaryOp(_, _)\n+                    | Rvalue::UnaryOp(_, Operand::Constant(_))\n+                    | Rvalue::Cast(_, Operand::Constant(_), _)\n+                    => return None,\n+                }\n+            }\n+\n+            // These statements have no influence on the place\n+            // we are interested in\n+            StatementKind::FakeRead(_)\n+            | StatementKind::StorageLive(_)\n+            | StatementKind::StorageDead(_)\n+            | StatementKind::Retag(_, _)\n+            | StatementKind::AscribeUserType(_, _)\n+            | StatementKind::Coverage(_)\n+            | StatementKind::CopyNonOverlapping(_)\n+            | StatementKind::Nop => {}\n+\n+            // If inline assembly is found, we probably should\n+            // not try to analyze the code\n+            StatementKind::LlvmInlineAsm(_) => return None,\n+\n+            // If the discriminant is set, it is always set\n+            // as a constant, so the job is already done.\n+            // As we are **ignoring projections**, if the place\n+            // we are tracking sees its discriminant be set,\n+            // that means we had to be tracking the discriminant\n+            // specifically (as it is impossible to switch over\n+            // an enum directly, and if we were switching over\n+            // its content, we would have had to at least cast it to\n+            // some variant first)\n+            StatementKind::SetDiscriminant { place, .. } => {\n+                if **place == switch_place {\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+\n+    Some(switch_place)\n+}"}, {"sha": "57299cee7b726782b78088124bfff9ee901cd54f", "filename": "src/test/mir-opt/separate_const_switch.identity.ConstProp.diff", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.ConstProp.diff?ref=70f74719a92ef52bc28610ba04b7e98ada035ec9", "patch": "@@ -0,0 +1,140 @@\n+- // MIR for `identity` before ConstProp\n++ // MIR for `identity` after ConstProp\n+  \n+  fn identity(_1: Result<i32, i32>) -> Result<i32, i32> {\n+      debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:28:13: 28:14\n+      let mut _0: std::result::Result<i32, i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:28:37: 28:53\n+      let mut _2: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, i32>, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      let mut _4: std::result::Result<i32, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+      let mut _5: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let _6: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let mut _7: !;                       // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let mut _8: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let _9: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      scope 1 {\n+          debug residual => _6;            // in scope 1 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          scope 2 {\n+              scope 8 (inlined <Result<i32, i32> as FromResidual<Result<Infallible, i32>>>::from_residual) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  debug residual => _8;    // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  let _16: i32;            // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  let mut _17: i32;        // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  let mut _18: i32;        // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  scope 9 {\n+                      debug e => _16;      // in scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                      scope 10 (inlined <i32 as From<i32>>::from) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+                          debug t => _18;  // in scope 10 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+      scope 3 {\n+          debug val => _9;                 // in scope 3 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          scope 4 {\n+          }\n+      }\n+      scope 5 (inlined <Result<i32, i32> as Try>::branch) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+          debug self => _4;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _10: isize;              // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let _11: i32;                    // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _12: i32;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let _13: i32;                    // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _14: std::result::Result<std::convert::Infallible, i32>; // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _15: i32;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          scope 6 {\n+              debug v => _11;              // in scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          }\n+          scope 7 {\n+              debug e => _13;              // in scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_3);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+          _4 = _1;                         // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+          StorageLive(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _10 = discriminant(_4);          // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          switchInt(move _10) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      }\n+  \n+      bb1: {\n+          StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _9 = ((_3 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _2 = _9;                         // scope 4 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          ((_0 as Ok).0: i32) = move _2;   // scope 0 at $DIR/separate_const_switch.rs:29:5: 29:11\n+          discriminant(_0) = 0;            // scope 0 at $DIR/separate_const_switch.rs:29:5: 29:11\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:10: 29:11\n+          StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:30:1: 30:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:30:2: 30:2\n+      }\n+  \n+      bb2: {\n+          StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          _6 = ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>); // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageLive(_8);                 // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          _8 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageLive(_16);                // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _16 = move ((_8 as Err).0: i32); // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_17);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_18);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _18 = move _16;                  // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _17 = move _18;                  // scope 10 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_18);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_0 as Err).0: i32) = move _17; // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_0) = 1;            // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_17);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_16);                // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_8);                 // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:10: 29:11\n+          StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:30:1: 30:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:30:2: 30:2\n+      }\n+  \n+      bb3: {\n+          StorageLive(_13);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _13 = move ((_4 as Err).0: i32); // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_14);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_15);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _15 = move _13;                  // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_14 as Err).0: i32) = move _15; // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_14) = 1;           // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_15);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>) = move _14; // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_3) = 1;            // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_14);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_13);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-         switchInt(move _5) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         _5 = const 1_isize;              // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         switchInt(const 1_isize) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      }\n+  \n+      bb4: {\n+          unreachable;                     // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      }\n+  \n+      bb5: {\n+          StorageLive(_11);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _11 = move ((_4 as Ok).0: i32);  // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_12);                // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _12 = move _11;                  // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_3 as Continue).0: i32) = move _12; // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_3) = 0;            // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_12);                // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_11);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-         switchInt(move _5) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         _5 = const 0_isize;              // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         switchInt(const 0_isize) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      }\n+  }\n+  "}, {"sha": "dee45c58403832435554e4c842826f9844fea71f", "filename": "src/test/mir-opt/separate_const_switch.identity.PreCodegen.after.mir", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.PreCodegen.after.mir?ref=70f74719a92ef52bc28610ba04b7e98ada035ec9", "patch": "@@ -0,0 +1,122 @@\n+// MIR for `identity` after PreCodegen\n+\n+fn identity(_1: Result<i32, i32>) -> Result<i32, i32> {\n+    debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:28:13: 28:14\n+    let mut _0: std::result::Result<i32, i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:28:37: 28:53\n+    let mut _2: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, i32>, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+    let mut _4: std::result::Result<i32, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+    let _5: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+    let mut _6: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+    let _7: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+    scope 1 {\n+        debug residual => _5;            // in scope 1 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        scope 2 {\n+            scope 8 (inlined <Result<i32, i32> as FromResidual<Result<Infallible, i32>>>::from_residual) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+                debug residual => _6;    // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                let _14: i32;            // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                let mut _15: i32;        // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                let mut _16: i32;        // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                scope 9 {\n+                    debug e => _14;      // in scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                    scope 10 (inlined <i32 as From<i32>>::from) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+                        debug t => _16;  // in scope 10 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    scope 3 {\n+        debug val => _7;                 // in scope 3 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        scope 4 {\n+        }\n+    }\n+    scope 5 (inlined <Result<i32, i32> as Try>::branch) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+        debug self => _4;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        let mut _8: isize;               // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        let _9: i32;                     // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        let mut _10: i32;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        let _11: i32;                    // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        let mut _12: std::result::Result<std::convert::Infallible, i32>; // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        let mut _13: i32;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        scope 6 {\n+            debug v => _9;               // in scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        }\n+        scope 7 {\n+            debug e => _11;              // in scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_3);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+        _4 = _1;                         // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+        StorageLive(_8);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _8 = discriminant(_4);           // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        switchInt(move _8) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+    }\n+\n+    bb1: {\n+        StorageLive(_11);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _11 = move ((_4 as Err).0: i32); // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_12);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_13);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _13 = move _11;                  // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        ((_12 as Err).0: i32) = move _13; // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        discriminant(_12) = 1;           // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_13);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>) = move _12; // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        discriminant(_3) = 1;            // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_12);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_11);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_8);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        StorageLive(_5);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        _5 = ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>); // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        StorageLive(_6);                 // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        _6 = _5;                         // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        StorageLive(_14);                // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _14 = move ((_6 as Err).0: i32); // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_15);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_16);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _16 = move _14;                  // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _15 = move _16;                  // scope 10 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_16);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        ((_0 as Err).0: i32) = move _15; // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        discriminant(_0) = 1;            // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_15);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_14);                // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_6);                 // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        StorageDead(_5);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:10: 29:11\n+        StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:30:1: 30:2\n+        return;                          // scope 0 at $DIR/separate_const_switch.rs:30:2: 30:2\n+    }\n+\n+    bb2: {\n+        unreachable;                     // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+    }\n+\n+    bb3: {\n+        StorageLive(_9);                 // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _9 = move ((_4 as Ok).0: i32);   // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_10);                // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _10 = move _9;                   // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        ((_3 as Continue).0: i32) = move _10; // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        discriminant(_3) = 0;            // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_10);                // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_9);                 // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_8);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        StorageLive(_7);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _7 = ((_3 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _2 = _7;                         // scope 4 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_7);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        ((_0 as Ok).0: i32) = move _2;   // scope 0 at $DIR/separate_const_switch.rs:29:5: 29:11\n+        discriminant(_0) = 0;            // scope 0 at $DIR/separate_const_switch.rs:29:5: 29:11\n+        StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:10: 29:11\n+        StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:30:1: 30:2\n+        return;                          // scope 0 at $DIR/separate_const_switch.rs:30:2: 30:2\n+    }\n+}"}, {"sha": "4bfd0842db08407280e5065aeab7475e5386d8bf", "filename": "src/test/mir-opt/separate_const_switch.identity.SeparateConstSwitch.diff", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff?ref=70f74719a92ef52bc28610ba04b7e98ada035ec9", "patch": "@@ -0,0 +1,150 @@\n+- // MIR for `identity` before SeparateConstSwitch\n++ // MIR for `identity` after SeparateConstSwitch\n+  \n+  fn identity(_1: Result<i32, i32>) -> Result<i32, i32> {\n+      debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:28:13: 28:14\n+      let mut _0: std::result::Result<i32, i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:28:37: 28:53\n+      let mut _2: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, i32>, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      let mut _4: std::result::Result<i32, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+      let mut _5: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let _6: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let mut _7: !;                       // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let mut _8: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let _9: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      scope 1 {\n+          debug residual => _6;            // in scope 1 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          scope 2 {\n+              scope 8 (inlined <Result<i32, i32> as FromResidual<Result<Infallible, i32>>>::from_residual) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  debug residual => _8;    // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  let _16: i32;            // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  let mut _17: i32;        // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  let mut _18: i32;        // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  scope 9 {\n+                      debug e => _16;      // in scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                      scope 10 (inlined <i32 as From<i32>>::from) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+                          debug t => _18;  // in scope 10 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+      scope 3 {\n+          debug val => _9;                 // in scope 3 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          scope 4 {\n+          }\n+      }\n+      scope 5 (inlined <Result<i32, i32> as Try>::branch) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+          debug self => _4;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _10: isize;              // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let _11: i32;                    // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _12: i32;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let _13: i32;                    // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _14: std::result::Result<std::convert::Infallible, i32>; // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _15: i32;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          scope 6 {\n+              debug v => _11;              // in scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          }\n+          scope 7 {\n+              debug e => _13;              // in scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_3);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+          _4 = _1;                         // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+          StorageLive(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _10 = discriminant(_4);          // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+-         switchInt(move _10) -> [0_isize: bb6, 1_isize: bb4, otherwise: bb5]; // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n++         switchInt(move _10) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      }\n+  \n+      bb1: {\n+-         StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+-         StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-         switchInt(move _5) -> [0_isize: bb2, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-     }\n+- \n+-     bb2: {\n+          StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _9 = ((_3 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _2 = _9;                         // scope 4 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          ((_0 as Ok).0: i32) = move _2;   // scope 0 at $DIR/separate_const_switch.rs:29:5: 29:11\n+          discriminant(_0) = 0;            // scope 0 at $DIR/separate_const_switch.rs:29:5: 29:11\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:10: 29:11\n+          StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:30:1: 30:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:30:2: 30:2\n+      }\n+  \n+-     bb3: {\n++     bb2: {\n+          StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          _6 = ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>); // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageLive(_8);                 // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          _8 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageLive(_16);                // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _16 = move ((_8 as Err).0: i32); // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_17);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_18);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _18 = move _16;                  // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _17 = move _18;                  // scope 10 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_18);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_0 as Err).0: i32) = move _17; // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_0) = 1;            // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_17);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_16);                // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_8);                 // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:10: 29:11\n+          StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:30:1: 30:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:30:2: 30:2\n+      }\n+  \n+-     bb4: {\n++     bb3: {\n+          StorageLive(_13);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _13 = move ((_4 as Err).0: i32); // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_14);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_15);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _15 = move _13;                  // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_14 as Err).0: i32) = move _15; // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_14) = 1;           // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_15);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>) = move _14; // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_3) = 1;            // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_14);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_13);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+-         goto -> bb1;                     // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n++         StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n++         StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         switchInt(move _5) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      }\n+  \n+-     bb5: {\n++     bb4: {\n+          unreachable;                     // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      }\n+  \n+-     bb6: {\n++     bb5: {\n+          StorageLive(_11);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _11 = move ((_4 as Ok).0: i32);  // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_12);                // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _12 = move _11;                  // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_3 as Continue).0: i32) = move _12; // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_3) = 0;            // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_12);                // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_11);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+-         goto -> bb1;                     // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n++         StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n++         StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         switchInt(move _5) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      }\n+  }\n+  "}, {"sha": "5d82acf4d60905259414f168367a26ac7b818044", "filename": "src/test/mir-opt/separate_const_switch.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.rs?ref=70f74719a92ef52bc28610ba04b7e98ada035ec9", "patch": "@@ -0,0 +1,35 @@\n+#![feature(control_flow_enum)]\n+#![feature(try_trait_v2)]\n+\n+use std::ops::ControlFlow;\n+\n+// EMIT_MIR separate_const_switch.too_complex.SeparateConstSwitch.diff\n+// EMIT_MIR separate_const_switch.too_complex.ConstProp.diff\n+// EMIT_MIR separate_const_switch.too_complex.PreCodegen.after.mir\n+fn too_complex(x: Result<i32, usize>) -> Option<i32> {\n+    // The pass should break the outer match into\n+    // two blocks that only have one parent each.\n+    // Parents are one of the two branches of the first\n+    // match, so a later pass can propagate constants.\n+    match {\n+        match x {\n+            Ok(v) => ControlFlow::Continue(v),\n+            Err(r) => ControlFlow::Break(r),\n+        }\n+    } {\n+        ControlFlow::Continue(v) => Some(v),\n+        ControlFlow::Break(r) => None,\n+    }\n+}\n+\n+// EMIT_MIR separate_const_switch.identity.SeparateConstSwitch.diff\n+// EMIT_MIR separate_const_switch.identity.ConstProp.diff\n+// EMIT_MIR separate_const_switch.identity.PreCodegen.after.mir\n+fn identity(x: Result<i32, i32>) -> Result<i32, i32> {\n+    Ok(x?)\n+}\n+\n+fn main() {\n+    too_complex(Ok(0));\n+    identity(Ok(0));\n+}"}, {"sha": "973b7838eca35808a222861da4736ce815043136", "filename": "src/test/mir-opt/separate_const_switch.too_complex.ConstProp.diff", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.ConstProp.diff?ref=70f74719a92ef52bc28610ba04b7e98ada035ec9", "patch": "@@ -0,0 +1,91 @@\n+- // MIR for `too_complex` before ConstProp\n++ // MIR for `too_complex` after ConstProp\n+  \n+  fn too_complex(_1: Result<i32, usize>) -> Option<i32> {\n+      debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:9:16: 9:17\n+      let mut _0: std::option::Option<i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:9:42: 9:53\n+      let mut _2: std::ops::ControlFlow<usize, i32>; // in scope 0 at $DIR/separate_const_switch.rs:14:11: 19:6\n+      let mut _3: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+      let _4: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+      let mut _5: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:16:44: 16:45\n+      let _6: usize;                       // in scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+      let mut _7: usize;                   // in scope 0 at $DIR/separate_const_switch.rs:17:42: 17:43\n+      let mut _8: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+      let _9: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+      let mut _10: i32;                    // in scope 0 at $DIR/separate_const_switch.rs:20:42: 20:43\n+      let _11: usize;                      // in scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+      scope 1 {\n+          debug v => _4;                   // in scope 1 at $DIR/separate_const_switch.rs:16:16: 16:17\n+      }\n+      scope 2 {\n+          debug r => _6;                   // in scope 2 at $DIR/separate_const_switch.rs:17:17: 17:18\n+      }\n+      scope 3 {\n+          debug v => _9;                   // in scope 3 at $DIR/separate_const_switch.rs:20:31: 20:32\n+      }\n+      scope 4 {\n+          debug r => _11;                  // in scope 4 at $DIR/separate_const_switch.rs:21:28: 21:29\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:14:11: 19:6\n+          _3 = discriminant(_1);           // scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+          switchInt(move _3) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+      }\n+  \n+      bb1: {\n+          StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+          _6 = ((_1 as Err).0: usize);     // scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+          StorageLive(_7);                 // scope 2 at $DIR/separate_const_switch.rs:17:42: 17:43\n+          _7 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:17:42: 17:43\n+          ((_2 as Break).0: usize) = move _7; // scope 2 at $DIR/separate_const_switch.rs:17:23: 17:44\n+          discriminant(_2) = 1;            // scope 2 at $DIR/separate_const_switch.rs:17:23: 17:44\n+          StorageDead(_7);                 // scope 2 at $DIR/separate_const_switch.rs:17:43: 17:44\n+          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:17:43: 17:44\n+-         _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+-         switchInt(move _8) -> [0_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n++         _8 = const 1_isize;              // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n++         switchInt(const 1_isize) -> [0_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+      }\n+  \n+      bb2: {\n+          StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+          _4 = ((_1 as Ok).0: i32);        // scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+          StorageLive(_5);                 // scope 1 at $DIR/separate_const_switch.rs:16:44: 16:45\n+          _5 = _4;                         // scope 1 at $DIR/separate_const_switch.rs:16:44: 16:45\n+          ((_2 as Continue).0: i32) = move _5; // scope 1 at $DIR/separate_const_switch.rs:16:22: 16:46\n+          discriminant(_2) = 0;            // scope 1 at $DIR/separate_const_switch.rs:16:22: 16:46\n+          StorageDead(_5);                 // scope 1 at $DIR/separate_const_switch.rs:16:45: 16:46\n+          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:16:45: 16:46\n+-         _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+-         switchInt(move _8) -> [0_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n++         _8 = const 0_isize;              // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n++         switchInt(const 0_isize) -> [0_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+      }\n+  \n+      bb3: {\n+          StorageLive(_11);                // scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+          _11 = ((_2 as Break).0: usize);  // scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+          discriminant(_0) = 0;            // scope 4 at $DIR/separate_const_switch.rs:21:34: 21:38\n+          StorageDead(_11);                // scope 0 at $DIR/separate_const_switch.rs:21:37: 21:38\n+          goto -> bb5;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n+      }\n+  \n+      bb4: {\n+          StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+          _9 = ((_2 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+          StorageLive(_10);                // scope 3 at $DIR/separate_const_switch.rs:20:42: 20:43\n+          _10 = _9;                        // scope 3 at $DIR/separate_const_switch.rs:20:42: 20:43\n+          ((_0 as Some).0: i32) = move _10; // scope 3 at $DIR/separate_const_switch.rs:20:37: 20:44\n+          discriminant(_0) = 1;            // scope 3 at $DIR/separate_const_switch.rs:20:37: 20:44\n+          StorageDead(_10);                // scope 3 at $DIR/separate_const_switch.rs:20:43: 20:44\n+          StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:20:43: 20:44\n+          goto -> bb5;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n+      }\n+  \n+      bb5: {\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:23:1: 23:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:23:2: 23:2\n+      }\n+  }\n+  "}, {"sha": "cc941f251cea5fadf07a36229ea5ccae2312cf52", "filename": "src/test/mir-opt/separate_const_switch.too_complex.PreCodegen.after.mir", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.PreCodegen.after.mir?ref=70f74719a92ef52bc28610ba04b7e98ada035ec9", "patch": "@@ -0,0 +1,74 @@\n+// MIR for `too_complex` after PreCodegen\n+\n+fn too_complex(_1: Result<i32, usize>) -> Option<i32> {\n+    debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:9:16: 9:17\n+    let mut _0: std::option::Option<i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:9:42: 9:53\n+    let mut _2: std::ops::ControlFlow<usize, i32>; // in scope 0 at $DIR/separate_const_switch.rs:14:11: 19:6\n+    let mut _3: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+    let _4: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+    let mut _5: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:16:44: 16:45\n+    let _6: usize;                       // in scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+    let mut _7: usize;                   // in scope 0 at $DIR/separate_const_switch.rs:17:42: 17:43\n+    let _8: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+    let mut _9: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:20:42: 20:43\n+    let _10: usize;                      // in scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+    scope 1 {\n+        debug v => _4;                   // in scope 1 at $DIR/separate_const_switch.rs:16:16: 16:17\n+    }\n+    scope 2 {\n+        debug r => _6;                   // in scope 2 at $DIR/separate_const_switch.rs:17:17: 17:18\n+    }\n+    scope 3 {\n+        debug v => _8;                   // in scope 3 at $DIR/separate_const_switch.rs:20:31: 20:32\n+    }\n+    scope 4 {\n+        debug r => _10;                  // in scope 4 at $DIR/separate_const_switch.rs:21:28: 21:29\n+    }\n+\n+    bb0: {\n+        StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:14:11: 19:6\n+        _3 = discriminant(_1);           // scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+        switchInt(move _3) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+    }\n+\n+    bb1: {\n+        StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+        _6 = ((_1 as Err).0: usize);     // scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+        StorageLive(_7);                 // scope 2 at $DIR/separate_const_switch.rs:17:42: 17:43\n+        _7 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:17:42: 17:43\n+        ((_2 as Break).0: usize) = move _7; // scope 2 at $DIR/separate_const_switch.rs:17:23: 17:44\n+        discriminant(_2) = 1;            // scope 2 at $DIR/separate_const_switch.rs:17:23: 17:44\n+        StorageDead(_7);                 // scope 2 at $DIR/separate_const_switch.rs:17:43: 17:44\n+        StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:17:43: 17:44\n+        StorageLive(_10);                // scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+        _10 = ((_2 as Break).0: usize);  // scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+        discriminant(_0) = 0;            // scope 4 at $DIR/separate_const_switch.rs:21:34: 21:38\n+        StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:21:37: 21:38\n+        goto -> bb3;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n+    }\n+\n+    bb2: {\n+        StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+        _4 = ((_1 as Ok).0: i32);        // scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+        StorageLive(_5);                 // scope 1 at $DIR/separate_const_switch.rs:16:44: 16:45\n+        _5 = _4;                         // scope 1 at $DIR/separate_const_switch.rs:16:44: 16:45\n+        ((_2 as Continue).0: i32) = move _5; // scope 1 at $DIR/separate_const_switch.rs:16:22: 16:46\n+        discriminant(_2) = 0;            // scope 1 at $DIR/separate_const_switch.rs:16:22: 16:46\n+        StorageDead(_5);                 // scope 1 at $DIR/separate_const_switch.rs:16:45: 16:46\n+        StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:16:45: 16:46\n+        StorageLive(_8);                 // scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+        _8 = ((_2 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+        StorageLive(_9);                 // scope 3 at $DIR/separate_const_switch.rs:20:42: 20:43\n+        _9 = _8;                         // scope 3 at $DIR/separate_const_switch.rs:20:42: 20:43\n+        ((_0 as Some).0: i32) = move _9; // scope 3 at $DIR/separate_const_switch.rs:20:37: 20:44\n+        discriminant(_0) = 1;            // scope 3 at $DIR/separate_const_switch.rs:20:37: 20:44\n+        StorageDead(_9);                 // scope 3 at $DIR/separate_const_switch.rs:20:43: 20:44\n+        StorageDead(_8);                 // scope 0 at $DIR/separate_const_switch.rs:20:43: 20:44\n+        goto -> bb3;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n+    }\n+\n+    bb3: {\n+        StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:23:1: 23:2\n+        return;                          // scope 0 at $DIR/separate_const_switch.rs:23:2: 23:2\n+    }\n+}"}, {"sha": "ce32227ed653b87e82d3fd592b79cd009cd85510", "filename": "src/test/mir-opt/separate_const_switch.too_complex.SeparateConstSwitch.diff", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/70f74719a92ef52bc28610ba04b7e98ada035ec9/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff?ref=70f74719a92ef52bc28610ba04b7e98ada035ec9", "patch": "@@ -0,0 +1,98 @@\n+- // MIR for `too_complex` before SeparateConstSwitch\n++ // MIR for `too_complex` after SeparateConstSwitch\n+  \n+  fn too_complex(_1: Result<i32, usize>) -> Option<i32> {\n+      debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:9:16: 9:17\n+      let mut _0: std::option::Option<i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:9:42: 9:53\n+      let mut _2: std::ops::ControlFlow<usize, i32>; // in scope 0 at $DIR/separate_const_switch.rs:14:11: 19:6\n+      let mut _3: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+      let _4: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+      let mut _5: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:16:44: 16:45\n+      let _6: usize;                       // in scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+      let mut _7: usize;                   // in scope 0 at $DIR/separate_const_switch.rs:17:42: 17:43\n+      let mut _8: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+      let _9: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+      let mut _10: i32;                    // in scope 0 at $DIR/separate_const_switch.rs:20:42: 20:43\n+      let _11: usize;                      // in scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+      scope 1 {\n+          debug v => _4;                   // in scope 1 at $DIR/separate_const_switch.rs:16:16: 16:17\n+      }\n+      scope 2 {\n+          debug r => _6;                   // in scope 2 at $DIR/separate_const_switch.rs:17:17: 17:18\n+      }\n+      scope 3 {\n+          debug v => _9;                   // in scope 3 at $DIR/separate_const_switch.rs:20:31: 20:32\n+      }\n+      scope 4 {\n+          debug r => _11;                  // in scope 4 at $DIR/separate_const_switch.rs:21:28: 21:29\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:14:11: 19:6\n+          _3 = discriminant(_1);           // scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+          switchInt(move _3) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+      }\n+  \n+      bb1: {\n+          StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+          _6 = ((_1 as Err).0: usize);     // scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+          StorageLive(_7);                 // scope 2 at $DIR/separate_const_switch.rs:17:42: 17:43\n+          _7 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:17:42: 17:43\n+          ((_2 as Break).0: usize) = move _7; // scope 2 at $DIR/separate_const_switch.rs:17:23: 17:44\n+          discriminant(_2) = 1;            // scope 2 at $DIR/separate_const_switch.rs:17:23: 17:44\n+          StorageDead(_7);                 // scope 2 at $DIR/separate_const_switch.rs:17:43: 17:44\n+          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:17:43: 17:44\n+-         goto -> bb3;                     // scope 0 at $DIR/separate_const_switch.rs:15:9: 18:10\n++         _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n++         switchInt(move _8) -> [0_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+      }\n+  \n+      bb2: {\n+          StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+          _4 = ((_1 as Ok).0: i32);        // scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+          StorageLive(_5);                 // scope 1 at $DIR/separate_const_switch.rs:16:44: 16:45\n+          _5 = _4;                         // scope 1 at $DIR/separate_const_switch.rs:16:44: 16:45\n+          ((_2 as Continue).0: i32) = move _5; // scope 1 at $DIR/separate_const_switch.rs:16:22: 16:46\n+          discriminant(_2) = 0;            // scope 1 at $DIR/separate_const_switch.rs:16:22: 16:46\n+          StorageDead(_5);                 // scope 1 at $DIR/separate_const_switch.rs:16:45: 16:46\n+          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:16:45: 16:46\n+-         goto -> bb3;                     // scope 0 at $DIR/separate_const_switch.rs:15:9: 18:10\n+-     }\n+- \n+-     bb3: {\n+          _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+-         switchInt(move _8) -> [0_isize: bb5, otherwise: bb4]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n++         switchInt(move _8) -> [0_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+      }\n+  \n+-     bb4: {\n++     bb3: {\n+          StorageLive(_11);                // scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+          _11 = ((_2 as Break).0: usize);  // scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+          discriminant(_0) = 0;            // scope 4 at $DIR/separate_const_switch.rs:21:34: 21:38\n+          StorageDead(_11);                // scope 0 at $DIR/separate_const_switch.rs:21:37: 21:38\n+-         goto -> bb6;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n++         goto -> bb5;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n+      }\n+  \n+-     bb5: {\n++     bb4: {\n+          StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+          _9 = ((_2 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+          StorageLive(_10);                // scope 3 at $DIR/separate_const_switch.rs:20:42: 20:43\n+          _10 = _9;                        // scope 3 at $DIR/separate_const_switch.rs:20:42: 20:43\n+          ((_0 as Some).0: i32) = move _10; // scope 3 at $DIR/separate_const_switch.rs:20:37: 20:44\n+          discriminant(_0) = 1;            // scope 3 at $DIR/separate_const_switch.rs:20:37: 20:44\n+          StorageDead(_10);                // scope 3 at $DIR/separate_const_switch.rs:20:43: 20:44\n+          StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:20:43: 20:44\n+-         goto -> bb6;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n++         goto -> bb5;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n+      }\n+  \n+-     bb6: {\n++     bb5: {\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:23:1: 23:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:23:2: 23:2\n+      }\n+  }\n+  "}]}