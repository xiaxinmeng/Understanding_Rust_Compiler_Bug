{"sha": "eaa2ddb04f6f56e48af789dc757982cf99f8fe35", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhYTJkZGIwNGY2ZjU2ZTQ4YWY3ODlkYzc1Nzk4MmNmOTlmOGZlMzU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-10-30T22:06:30Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-20T10:37:15Z"}, "message": "fix tests", "tree": {"sha": "88e62f33eec3373ea7b245b93b61d43f24daeb23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88e62f33eec3373ea7b245b93b61d43f24daeb23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eaa2ddb04f6f56e48af789dc757982cf99f8fe35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eaa2ddb04f6f56e48af789dc757982cf99f8fe35", "html_url": "https://github.com/rust-lang/rust/commit/eaa2ddb04f6f56e48af789dc757982cf99f8fe35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66057a7f7292c49eefae7cd386aa183201a49ca2", "url": "https://api.github.com/repos/rust-lang/rust/commits/66057a7f7292c49eefae7cd386aa183201a49ca2", "html_url": "https://github.com/rust-lang/rust/commit/66057a7f7292c49eefae7cd386aa183201a49ca2"}], "stats": {"total": 169, "additions": 94, "deletions": 75}, "files": [{"sha": "1961a6247ed9131f892a62ccff5626b0f2ba4315", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 64, "deletions": 55, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=eaa2ddb04f6f56e48af789dc757982cf99f8fe35", "patch": "@@ -285,15 +285,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         Some(steps)\n     }\n-\n-    pub fn find_attr(&self, def_id: DefId, attr_name: &str) -> Option<ast::Attribute> {\n-        for item in self.tcx.get_attrs(def_id).iter() {\n-            if item.check_name(attr_name) {\n-                return Some(item.clone());\n-            }\n-        }\n-        None\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n@@ -918,21 +909,21 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             //Some(Ok(p)) => p.iter().map(|p| p.item.container().id()).collect(),\n             Some(Err(MethodError::Ambiguity(v))) => {\n                 v.into_iter()\n-                    .map(|source| {\n-                        match source {\n-                            TraitSource(id) => id,\n-                            ImplSource(impl_id) => {\n-                                match tcx.trait_id_of_impl(impl_id) {\n-                                    Some(id) => id,\n-                                    None => {\n-                                        span_bug!(span,\n-                                                  \"found inherent method when looking at traits\")\n-                                    }\n+                .map(|source| {\n+                    match source {\n+                        TraitSource(id) => id,\n+                        ImplSource(impl_id) => {\n+                            match tcx.trait_id_of_impl(impl_id) {\n+                                Some(id) => id,\n+                                None => {\n+                                    span_bug!(span,\n+                                              \"found inherent method when looking at traits\")\n                                 }\n                             }\n                         }\n-                    })\n-                    .collect()\n+                    }\n+                })\n+                .collect()\n             }\n             Some(Err(MethodError::NoMatch(NoMatchData { out_of_scope_traits: others, .. }))) => {\n                 assert!(others.is_empty());\n@@ -957,25 +948,27 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n         let steps = self.steps.clone();\n-        let mut ret = Vec::new();\n \n-        for step in steps.iter() {\n-            match self.pick_step(step) {\n-                Some(Ok(mut elems)) => ret.append(&mut elems),\n-                Some(Err(elem)) => {\n-                    match self.looking_for {\n-                        LookingFor::MethodName(_) => return Some(Err(elem)),\n-                        LookingFor::ReturnType(_) => {}\n+        match self.looking_for {\n+            LookingFor::MethodName(_) => steps.iter()\n+                                              .filter_map(|step| self.pick_step(step))\n+                                              .next(),\n+            LookingFor::ReturnType(_) => {\n+                let mut ret = Vec::new();\n+\n+                for step in steps.iter() {\n+                    match self.pick_step(step) {\n+                        Some(Ok(mut elems)) => ret.append(&mut elems),\n+                        _ => {}\n                     }\n                 }\n-                _ => {}\n+                if ret.len() < 1 {\n+                    None\n+                } else {\n+                    Some(Ok(ret))\n+                }\n             }\n         }\n-        if ret.len() < 1 {\n-            None\n-        } else {\n-            Some(Ok(ret))\n-        }\n     }\n \n     fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n@@ -1028,12 +1021,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // In general, during probing we erase regions. See\n         // `impl_self_ty()` for an explanation.\n         let region = tcx.mk_region(ty::ReErased);\n-        let mut res = Vec::new();\n \n         // Search through mutabilities in order to find one where pick works:\n-        for _ in [hir::MutImmutable, hir::MutMutable]\n-            .iter()\n-            .filter_map(|&m| {\n+        let mut elements = [hir::MutImmutable, hir::MutMutable];\n+        let mut it = elements\n+            .iter_mut()\n+            .filter_map(|&mut m| {\n                 let autoref_ty = tcx.mk_ref(region,\n                                             ty::TypeAndMut {\n                                                 ty: step.self_ty,\n@@ -1050,15 +1043,24 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                 None\n                             };\n                         }\n-                        res.append(&mut picks);\n+                        picks\n                     })\n                 })\n-            }) {}\n-\n-        if res.len() < 1 {\n-            None\n-        } else {\n-            Some(Ok(res))\n+            });\n+        match self.looking_for {\n+            LookingFor::MethodName(_) => it.nth(0),\n+            LookingFor::ReturnType(_) => {\n+                let mut ret = Vec::new();\n+                it.filter_map(|entry| entry.ok())\n+                  .map(|mut v| { ret.append(&mut v); })\n+                  .all(|_| true);\n+\n+                if ret.len() < 1 {\n+                    None\n+                } else {\n+                    Some(Ok(ret))\n+                }\n+            }\n         }\n     }\n \n@@ -1089,7 +1091,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                            probes: &[Candidate<'tcx>],\n                            possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>)\n                            -> Option<PickResult<'tcx>> {\n-        let applicable_candidates: Vec<_> = probes.iter()\n+        let mut applicable_candidates: Vec<_> = probes.iter()\n             .filter(|&probe| self.consider_probe(self_ty, probe, possibly_unsatisfied_predicates))\n             .collect();\n \n@@ -1109,14 +1111,21 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n-        let ret: Vec<_> = applicable_candidates.iter()\n-                                               .map(|probe| probe.to_unadjusted_pick())\n-                                               .collect();\n-\n-        if ret.len() < 1 {\n-            None\n-        } else {\n-            Some(Ok(ret))\n+        match self.looking_for {\n+            LookingFor::MethodName(_) => applicable_candidates\n+                .pop()\n+                .map(|probe| Ok(vec![probe.to_unadjusted_pick()])),\n+            LookingFor::ReturnType(_) => {\n+                let ret: Vec<_> = applicable_candidates.iter()\n+                                                       .map(|probe| probe.to_unadjusted_pick())\n+                                                       .collect();\n+\n+                if ret.len() < 1 {\n+                    None\n+                } else {\n+                    Some(Ok(ret))\n+                }\n+            }\n         }\n     }\n "}, {"sha": "3177e858ff4fd3b89ada820f849ce3a9889ffc66", "filename": "src/test/compile-fail/coerce_suggestions.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/src%2Ftest%2Fcompile-fail%2Fcoerce_suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/src%2Ftest%2Fcompile-fail%2Fcoerce_suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce_suggestions.rs?ref=eaa2ddb04f6f56e48af789dc757982cf99f8fe35", "patch": "@@ -8,34 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(box_syntax)]\n+\n fn test(_x: &mut String) {}\n fn test2(_x: &mut i32) {}\n \n fn main() {\n     let x: usize = String::new();\n-    //^ ERROR E0308\n-    //| NOTE expected type `usize`\n-    //| NOTE found type `std::string::String`\n-    //| NOTE here are some functions which might fulfill your needs:\n+    //~^ ERROR E0308\n+    //~| NOTE expected usize, found struct `std::string::String`\n+    //~| NOTE expected type `usize`\n+    //~| NOTE found type `std::string::String`\n+    //~| HELP here are some functions which might fulfill your needs:\n     let x: &str = String::new();\n-    //^ ERROR E0308\n-    //| NOTE expected type `&str`\n-    //| NOTE found type `std::string::String`\n-    //| NOTE try with `&String::new()`\n+    //~^ ERROR E0308\n+    //~| NOTE expected &str, found struct `std::string::String`\n+    //~| NOTE expected type `&str`\n+    //~| NOTE found type `std::string::String`\n+    //~| HELP try with `&String::new()`\n     let y = String::new();\n     test(&y);\n-    //^ ERROR E0308\n-    //| NOTE expected type `&mut std::string::String`\n-    //| NOTE found type `&std::string::String`\n-    //| NOTE try with `&mut y`\n+    //~^ ERROR E0308\n+    //~| NOTE types differ in mutability\n+    //~| NOTE expected type `&mut std::string::String`\n+    //~| NOTE found type `&std::string::String`\n+    //~| HELP try with `&mut y`\n     test2(&y);\n-    //^ ERROR E0308\n-    //| NOTE expected type `&mut i32`\n-    //| NOTE found type `&std::string::String`\n-    //| NOTE try with `&mut y`\n+    //~^ ERROR E0308\n+    //~| NOTE types differ in mutability\n+    //~| NOTE expected type `&mut i32`\n+    //~| NOTE found type `&std::string::String`\n     let f;\n     f = box f;\n-    //^ ERROR E0308\n-    //| NOTE expected type `_`\n-    //| NOTE found type `Box<_>`\n+    //~^ ERROR E0308\n+    //~| NOTE cyclic type of infinite size\n+    //~| NOTE expected type `_`\n+    //~| NOTE found type `Box<_>`\n }"}, {"sha": "f50900883999ce1fdbb82ebb220e905260a4cc25", "filename": "src/test/compile-fail/coercion-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs?ref=eaa2ddb04f6f56e48af789dc757982cf99f8fe35", "patch": "@@ -14,6 +14,6 @@ fn main() {\n     let _: &[i32] = [0];\n     //~^ ERROR mismatched types\n     //~| expected type `&[i32]`\n-    //~| found type `[{integer}; 1]`\n+    //~| found type `[i32; 1]`\n     //~| expected &[i32], found array of 1 elements\n }"}, {"sha": "975bc1300aae7bee390f1c0fafd58f15e46269dc", "filename": "src/test/compile-fail/cross-borrow-trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs?ref=eaa2ddb04f6f56e48af789dc757982cf99f8fe35", "patch": "@@ -22,4 +22,5 @@ pub fn main() {\n                         //~| expected type `&Trait`\n                         //~| found type `Box<Trait>`\n                         //~| expected &Trait, found box\n+                        //~^^^^ ERROR E0277\n }"}, {"sha": "728b016b30fa57260c1ded318fe860b39db2ccaf", "filename": "src/test/compile-fail/dst-bad-coercions.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs?ref=eaa2ddb04f6f56e48af789dc757982cf99f8fe35", "patch": "@@ -23,11 +23,13 @@ pub fn main() {\n     let x: *const S = &S;\n     let y: &S = x; //~ ERROR mismatched types\n     let y: &T = x; //~ ERROR mismatched types\n+                   //~^ ERROR E0277\n \n     // Test that we cannot convert from *-ptr to &S and &T (mut version)\n     let x: *mut S = &mut S;\n     let y: &S = x; //~ ERROR mismatched types\n     let y: &T = x; //~ ERROR mismatched types\n+                   //~^ ERROR E0277\n \n     // Test that we cannot convert an immutable ptr to a mutable one using *-ptrs\n     let x: &mut T = &S; //~ ERROR mismatched types"}, {"sha": "df6675510ff2b853a34863ee0debc356acefbb9e", "filename": "src/test/compile-fail/issue-13058.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa2ddb04f6f56e48af789dc757982cf99f8fe35/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs?ref=eaa2ddb04f6f56e48af789dc757982cf99f8fe35", "patch": "@@ -36,4 +36,5 @@ fn check<'r, I: Iterator<Item=usize>, T: Itble<'r, usize, I>>(cont: &T) -> bool\n fn main() {\n     check((3, 5));\n //~^ ERROR mismatched types\n+//~| HELP try with `&(3, 5)`\n }"}]}