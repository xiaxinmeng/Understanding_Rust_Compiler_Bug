{"sha": "d576ef3d7be3efe28f902bbb3b2197f4553db412", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NzZlZjNkN2JlM2VmZTI4ZjkwMmJiYjNiMjE5N2Y0NTUzZGI0MTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-29T06:47:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-29T06:47:55Z"}, "message": "Auto merge of #27261 - arielb1:drop-sanity-check, r=pnkfelix\n\nThis fixes multiple bugs, and as several of these are soundness issue, is a [breaking-change].\r\n\r\nr? @pnkfelix", "tree": {"sha": "c9fba34623e94a9a6222fc2729106e687e12ea30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9fba34623e94a9a6222fc2729106e687e12ea30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d576ef3d7be3efe28f902bbb3b2197f4553db412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d576ef3d7be3efe28f902bbb3b2197f4553db412", "html_url": "https://github.com/rust-lang/rust/commit/d576ef3d7be3efe28f902bbb3b2197f4553db412", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d576ef3d7be3efe28f902bbb3b2197f4553db412/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b4119d5c082e02f34b8ffb9aff41c8a71f30a13", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b4119d5c082e02f34b8ffb9aff41c8a71f30a13", "html_url": "https://github.com/rust-lang/rust/commit/4b4119d5c082e02f34b8ffb9aff41c8a71f30a13"}, {"sha": "e99b53e1c16b6ab7dcac7ccc841fb9cb9fc75381", "url": "https://api.github.com/repos/rust-lang/rust/commits/e99b53e1c16b6ab7dcac7ccc841fb9cb9fc75381", "html_url": "https://github.com/rust-lang/rust/commit/e99b53e1c16b6ab7dcac7ccc841fb9cb9fc75381"}], "stats": {"total": 569, "additions": 315, "deletions": 254}, "files": [{"sha": "24e67860998d5a4bea2002966bb11f87b94f49d6", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 190, "deletions": 253, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/d576ef3d7be3efe28f902bbb3b2197f4553db412/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d576ef3d7be3efe28f902bbb3b2197f4553db412/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=d576ef3d7be3efe28f902bbb3b2197f4553db412", "patch": "@@ -14,6 +14,7 @@ use middle::infer;\n use middle::region;\n use middle::subst::{self, Subst};\n use middle::ty::{self, Ty};\n+use util::nodemap::FnvHashSet;\n \n use syntax::ast;\n use syntax::codemap::{self, Span};\n@@ -258,17 +259,20 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n            typ, scope);\n \n-    // types that have been traversed so far by `traverse_type_if_unseen`\n-    let mut breadcrumbs: Vec<Ty<'tcx>> = Vec::new();\n+    let parent_scope = rcx.tcx().region_maps.opt_encl_scope(scope).unwrap_or_else(|| {\n+        rcx.tcx().sess.span_bug(\n+            span, &format!(\"no enclosing scope found for scope: {:?}\", scope))\n+    });\n \n     let result = iterate_over_potentially_unsafe_regions_in_type(\n-        rcx,\n-        &mut breadcrumbs,\n+        &mut DropckContext {\n+            rcx: rcx,\n+            span: span,\n+            parent_scope: parent_scope,\n+            breadcrumbs: FnvHashSet()\n+        },\n         TypeContext::Root,\n         typ,\n-        span,\n-        scope,\n-        0,\n         0);\n     match result {\n         Ok(()) => {}\n@@ -311,6 +315,7 @@ enum Error<'tcx> {\n     Overflow(TypeContext, ty::Ty<'tcx>),\n }\n \n+#[derive(Copy, Clone)]\n enum TypeContext {\n     Root,\n     EnumVariant {\n@@ -324,269 +329,198 @@ enum TypeContext {\n     }\n }\n \n-// The `depth` counts the number of calls to this function;\n-// the `xref_depth` counts the subset of such calls that go\n-// across a `Box<T>` or `PhantomData<T>`.\n-fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n-    rcx: &mut Rcx<'a, 'tcx>,\n-    breadcrumbs: &mut Vec<Ty<'tcx>>,\n-    context: TypeContext,\n-    ty_root: ty::Ty<'tcx>,\n+struct DropckContext<'a, 'b: 'a, 'tcx: 'b> {\n+    rcx: &'a mut Rcx<'b, 'tcx>,\n+    /// types that have already been traversed\n+    breadcrumbs: FnvHashSet<Ty<'tcx>>,\n+    /// span for error reporting\n     span: Span,\n-    scope: region::CodeExtent,\n-    depth: usize,\n-    xref_depth: usize) -> Result<(), Error<'tcx>>\n+    /// the scope reachable dtorck types must outlive\n+    parent_scope: region::CodeExtent\n+}\n+\n+// `context` is used for reporting overflow errors\n+fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n+    cx: &mut DropckContext<'a, 'b, 'tcx>,\n+    context: TypeContext,\n+    ty: Ty<'tcx>,\n+    depth: usize) -> Result<(), Error<'tcx>>\n {\n+    let tcx = cx.rcx.tcx();\n     // Issue #22443: Watch out for overflow. While we are careful to\n     // handle regular types properly, non-regular ones cause problems.\n-    let recursion_limit = rcx.tcx().sess.recursion_limit.get();\n-    if xref_depth >= recursion_limit {\n-        return Err(Error::Overflow(context, ty_root))\n+    let recursion_limit = tcx.sess.recursion_limit.get();\n+    if depth / 4 >= recursion_limit {\n+        // This can get into rather deep recursion, especially in the\n+        // presence of things like Vec<T> -> Unique<T> -> PhantomData<T> -> T.\n+        // use a higher recursion limit to avoid errors.\n+        return Err(Error::Overflow(context, ty))\n     }\n \n-    let origin = || infer::SubregionOrigin::SafeDestructor(span);\n-    let mut walker = ty_root.walk();\n-    let opt_phantom_data_def_id = rcx.tcx().lang_items.phantom_data();\n+    let opt_phantom_data_def_id = tcx.lang_items.phantom_data();\n \n-    let destructor_for_type = rcx.tcx().destructor_for_type.borrow();\n+    if !cx.breadcrumbs.insert(ty) {\n+        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+               {}ty: {} scope: {:?} - cached\",\n+               (0..depth).map(|_| ' ').collect::<String>(),\n+               ty, cx.parent_scope);\n+        return Ok(()); // we already visited this type\n+    }\n+    debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+           {}ty: {} scope: {:?}\",\n+           (0..depth).map(|_| ' ').collect::<String>(),\n+           ty, cx.parent_scope);\n+\n+    // If `typ` has a destructor, then we must ensure that all\n+    // borrowed data reachable via `typ` must outlive the parent\n+    // of `scope`. This is handled below.\n+    //\n+    // However, there is an important special case: by\n+    // parametricity, any generic type parameters have *no* trait\n+    // bounds in the Drop impl can not be used in any way (apart\n+    // from being dropped), and thus we can treat data borrowed\n+    // via such type parameters remains unreachable.\n+    //\n+    // For example, consider `impl<T> Drop for Vec<T> { ... }`,\n+    // which does have to be able to drop instances of `T`, but\n+    // otherwise cannot read data from `T`.\n+    //\n+    // Of course, for the type expression passed in for any such\n+    // unbounded type parameter `T`, we must resume the recursive\n+    // analysis on `T` (since it would be ignored by\n+    // type_must_outlive).\n+    //\n+    // FIXME (pnkfelix): Long term, we could be smart and actually\n+    // feed which generic parameters can be ignored *into* `fn\n+    // type_must_outlive` (or some generalization thereof). But\n+    // for the short term, it probably covers most cases of\n+    // interest to just special case Drop impls where: (1.) there\n+    // are no generic lifetime parameters and (2.)  *all* generic\n+    // type parameters are unbounded.  If both conditions hold, we\n+    // simply skip the `type_must_outlive` call entirely (but\n+    // resume the recursive checking of the type-substructure).\n+    if has_dtor_of_interest(tcx, ty, cx.span) {\n+        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+                {}ty: {} - is a dtorck type!\",\n+               (0..depth).map(|_| ' ').collect::<String>(),\n+               ty);\n \n-    let xref_depth_orig = xref_depth;\n+        regionck::type_must_outlive(cx.rcx,\n+                                    infer::SubregionOrigin::SafeDestructor(cx.span),\n+                                    ty,\n+                                    ty::ReScope(cx.parent_scope));\n \n-    while let Some(typ) = walker.next() {\n-        // Avoid recursing forever.\n-        if breadcrumbs.contains(&typ) {\n-            continue;\n-        }\n-        breadcrumbs.push(typ);\n-\n-        // If we encounter `PhantomData<T>`, then we should replace it\n-        // with `T`, the type it represents as owned by the\n-        // surrounding context, before doing further analysis.\n-        let (typ, xref_depth) = match typ.sty {\n-            ty::TyStruct(struct_did, substs) => {\n-                if opt_phantom_data_def_id == Some(struct_did) {\n-                    let item_type = rcx.tcx().lookup_item_type(struct_did);\n-                    let tp_def = item_type.generics.types\n-                        .opt_get(subst::TypeSpace, 0).unwrap();\n-                    let new_typ = substs.type_for_def(tp_def);\n-                    debug!(\"replacing phantom {:?} with {:?}\",\n-                           typ, new_typ);\n-                    (new_typ, xref_depth_orig + 1)\n-                } else {\n-                    (typ, xref_depth_orig)\n-                }\n-            }\n-\n-            // Note: When TyBox is removed from compiler, the\n-            // definition of `Box<T>` must carry a PhantomData that\n-            // puts us into the previous case.\n-            ty::TyBox(new_typ) => {\n-                debug!(\"replacing TyBox {:?} with {:?}\",\n-                       typ, new_typ);\n-                (new_typ, xref_depth_orig + 1)\n-            }\n+        return Ok(());\n+    }\n \n-            _ => {\n-                (typ, xref_depth_orig)\n-            }\n-        };\n-\n-        let dtor_kind = match typ.sty {\n-            ty::TyEnum(def_id, _) |\n-            ty::TyStruct(def_id, _) => {\n-                match destructor_for_type.get(&def_id) {\n-                    Some(def_id) => DtorKind::KnownDropMethod(*def_id),\n-                    None => DtorKind::PureRecur,\n-                }\n-            }\n-            ty::TyTrait(ref ty_trait) => {\n-                DtorKind::Unknown(ty_trait.bounds.clone())\n-            }\n-            _ => DtorKind::PureRecur,\n-        };\n+    debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+           {}ty: {} scope: {:?} - checking interior\",\n+           (0..depth).map(|_| ' ').collect::<String>(),\n+           ty, cx.parent_scope);\n+\n+    // We still need to ensure all referenced data is safe.\n+    match ty.sty {\n+        ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n+        ty::TyFloat(_) | ty::TyStr => {\n+            // primitive - definitely safe\n+            Ok(())\n+        }\n \n-        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-                {}typ: {} scope: {:?} xref: {}\",\n-               (0..depth).map(|_| ' ').collect::<String>(),\n-               typ, scope, xref_depth);\n+        ty::TyBox(ity) | ty::TyArray(ity, _) | ty::TySlice(ity) => {\n+            // single-element containers, behave like their element\n+            iterate_over_potentially_unsafe_regions_in_type(\n+                cx, context, ity, depth+1)\n+        }\n \n-        // If `typ` has a destructor, then we must ensure that all\n-        // borrowed data reachable via `typ` must outlive the parent\n-        // of `scope`. This is handled below.\n-        //\n-        // However, there is an important special case: by\n-        // parametricity, any generic type parameters have *no* trait\n-        // bounds in the Drop impl can not be used in any way (apart\n-        // from being dropped), and thus we can treat data borrowed\n-        // via such type parameters remains unreachable.\n-        //\n-        // For example, consider `impl<T> Drop for Vec<T> { ... }`,\n-        // which does have to be able to drop instances of `T`, but\n-        // otherwise cannot read data from `T`.\n-        //\n-        // Of course, for the type expression passed in for any such\n-        // unbounded type parameter `T`, we must resume the recursive\n-        // analysis on `T` (since it would be ignored by\n-        // type_must_outlive).\n-        //\n-        // FIXME (pnkfelix): Long term, we could be smart and actually\n-        // feed which generic parameters can be ignored *into* `fn\n-        // type_must_outlive` (or some generalization thereof). But\n-        // for the short term, it probably covers most cases of\n-        // interest to just special case Drop impls where: (1.) there\n-        // are no generic lifetime parameters and (2.)  *all* generic\n-        // type parameters are unbounded.  If both conditions hold, we\n-        // simply skip the `type_must_outlive` call entirely (but\n-        // resume the recursive checking of the type-substructure).\n-\n-        if has_dtor_of_interest(rcx.tcx(), dtor_kind, typ, span) {\n-            // If `typ` has a destructor, then we must ensure that all\n-            // borrowed data reachable via `typ` must outlive the\n-            // parent of `scope`. (It does not suffice for it to\n-            // outlive `scope` because that could imply that the\n-            // borrowed data is torn down in between the end of\n-            // `scope` and when the destructor itself actually runs.)\n-\n-            let parent_region =\n-                match rcx.tcx().region_maps.opt_encl_scope(scope) {\n-                    Some(parent_scope) => ty::ReScope(parent_scope),\n-                    None => rcx.tcx().sess.span_bug(\n-                        span, &format!(\"no enclosing scope found for scope: {:?}\",\n-                                       scope)),\n-                };\n-\n-            regionck::type_must_outlive(rcx, origin(), typ, parent_region);\n-\n-        } else {\n-            // Okay, `typ` itself is itself not reachable by a\n-            // destructor; but it may contain substructure that has a\n-            // destructor.\n-\n-            match typ.sty {\n-                ty::TyStruct(struct_did, substs) => {\n-                    debug!(\"typ: {:?} is struct; traverse structure and not type-expression\",\n-                           typ);\n-                    // Don't recurse; we extract type's substructure,\n-                    // so do not process subparts of type expression.\n-                    walker.skip_current_subtree();\n-\n-                    let fields =\n-                        rcx.tcx().lookup_struct_fields(struct_did);\n-                    for field in &fields {\n-                        let field_type = rcx.tcx().lookup_field_type(struct_did,\n-                                                                     field.id,\n-                                                                     substs);\n-                        try!(iterate_over_potentially_unsafe_regions_in_type(\n-                            rcx,\n-                            breadcrumbs,\n-                            TypeContext::Struct {\n-                                def_id: struct_did,\n-                                field: field.name,\n-                            },\n-                            field_type,\n-                            span,\n-                            scope,\n-                            depth+1,\n-                            xref_depth))\n-                    }\n-                }\n+        ty::TyStruct(did, substs) if Some(did) == opt_phantom_data_def_id => {\n+            // PhantomData<T> - behaves identically to T\n+            let ity = *substs.types.get(subst::TypeSpace, 0);\n+            iterate_over_potentially_unsafe_regions_in_type(\n+                cx, context, ity, depth+1)\n+        }\n \n-                ty::TyEnum(enum_did, substs) => {\n-                    debug!(\"typ: {:?} is enum; traverse structure and not type-expression\",\n-                           typ);\n-                    // Don't recurse; we extract type's substructure,\n-                    // so do not process subparts of type expression.\n-                    walker.skip_current_subtree();\n-\n-                    let all_variant_info =\n-                        rcx.tcx().substd_enum_variants(enum_did, substs);\n-                    for variant_info in &all_variant_info {\n-                        for (i, arg_type) in variant_info.args.iter().enumerate() {\n-                            try!(iterate_over_potentially_unsafe_regions_in_type(\n-                                rcx,\n-                                breadcrumbs,\n-                                TypeContext::EnumVariant {\n-                                    def_id: enum_did,\n-                                    variant: variant_info.name,\n-                                    arg_index: i,\n-                                },\n-                                *arg_type,\n-                                span,\n-                                scope,\n-                                depth+1,\n-                                xref_depth));\n-                        }\n-                    }\n-                }\n+        ty::TyStruct(did, substs) => {\n+            let fields = tcx.lookup_struct_fields(did);\n+            for field in &fields {\n+                let fty = tcx.lookup_field_type(did, field.id, substs);\n+                let fty = cx.rcx.fcx.resolve_type_vars_if_possible(\n+                    cx.rcx.fcx.normalize_associated_types_in(cx.span, &fty));\n+                try!(iterate_over_potentially_unsafe_regions_in_type(\n+                    cx,\n+                    TypeContext::Struct {\n+                        def_id: did,\n+                        field: field.name,\n+                    },\n+                    fty,\n+                    depth+1))\n+            }\n+            Ok(())\n+        }\n \n-                ty::TyRef(..) | ty::TyRawPtr(_) | ty::TyBareFn(..) => {\n-                    // Don't recurse, since references, pointers,\n-                    // and bare functions don't own instances\n-                    // of the types appearing within them.\n-                    walker.skip_current_subtree();\n+        ty::TyEnum(did, substs) => {\n+            let all_variant_info = tcx.substd_enum_variants(did, substs);\n+            for variant_info in &all_variant_info {\n+                for (i, fty) in variant_info.args.iter().enumerate() {\n+                    let fty = cx.rcx.fcx.resolve_type_vars_if_possible(\n+                        cx.rcx.fcx.normalize_associated_types_in(cx.span, &fty));\n+                    try!(iterate_over_potentially_unsafe_regions_in_type(\n+                        cx,\n+                        TypeContext::EnumVariant {\n+                            def_id: did,\n+                            variant: variant_info.name,\n+                            arg_index: i,\n+                        },\n+                        fty,\n+                        depth+1));\n                 }\n-                _ => {}\n-            };\n+            }\n+            Ok(())\n+        }\n \n-            // You might be tempted to pop breadcrumbs here after\n-            // processing type's internals above, but then you hit\n-            // exponential time blowup e.g. on\n-            // compile-fail/huge-struct.rs. Instead, we do not remove\n-            // anything from the breadcrumbs vector during any particular\n-            // traversal, and instead clear it after the whole traversal\n-            // is done.\n+        ty::TyTuple(ref tys) |\n+        ty::TyClosure(_, box ty::ClosureSubsts { upvar_tys: ref tys, .. }) => {\n+            for ty in tys {\n+                try!(iterate_over_potentially_unsafe_regions_in_type(\n+                    cx, context, ty, depth+1))\n+            }\n+            Ok(())\n         }\n-    }\n \n-    return Ok(());\n-}\n+        ty::TyRawPtr(..) | ty::TyRef(..) | ty::TyParam(..) => {\n+            // these always come with a witness of liveness (references\n+            // explicitly, pointers implicitly, parameters by the\n+            // caller).\n+            Ok(())\n+        }\n \n-enum DtorKind<'tcx> {\n-    // Type has an associated drop method with this def id\n-    KnownDropMethod(ast::DefId),\n+        ty::TyBareFn(..) => {\n+            // FIXME(#26656): this type is always destruction-safe, but\n+            // it implicitly witnesses Self: Fn, which can be false.\n+            Ok(())\n+        }\n \n-    // Type has no destructor (or its dtor is known to be pure\n-    // with respect to lifetimes), though its *substructure*\n-    // may carry a destructor.\n-    PureRecur,\n+        ty::TyInfer(..) | ty::TyError => {\n+            tcx.sess.delay_span_bug(cx.span, \"unresolved type in regionck\");\n+            Ok(())\n+        }\n \n-    // Type may have impure destructor that is unknown;\n-    // e.g. `Box<Trait+'a>`\n-    Unknown(ty::ExistentialBounds<'tcx>),\n+        // these are always dtorck\n+        ty::TyTrait(..) | ty::TyProjection(_) => unreachable!(),\n+    }\n }\n \n fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                              dtor_kind: DtorKind,\n-                              typ: ty::Ty<'tcx>,\n+                              ty: ty::Ty<'tcx>,\n                               span: Span) -> bool {\n-    let has_dtor_of_interest: bool;\n-\n-    match dtor_kind {\n-        DtorKind::PureRecur => {\n-            has_dtor_of_interest = false;\n-            debug!(\"typ: {:?} has no dtor, and thus is uninteresting\",\n-                   typ);\n-        }\n-        DtorKind::Unknown(bounds) => {\n-            match bounds.region_bound {\n-                ty::ReStatic => {\n-                    debug!(\"trait: {:?} has 'static bound, and thus is uninteresting\",\n-                           typ);\n-                    has_dtor_of_interest = false;\n-                }\n-                ty::ReEmpty => {\n-                    debug!(\"trait: {:?} has empty region bound, and thus is uninteresting\",\n-                           typ);\n-                    has_dtor_of_interest = false;\n+    match ty.sty {\n+        ty::TyEnum(def_id, _) | ty::TyStruct(def_id, _) => {\n+            let dtor_method_did = match tcx.destructor_for_type.borrow().get(&def_id) {\n+                Some(def_id) => *def_id,\n+                None => {\n+                    debug!(\"ty: {:?} has no dtor, and thus isn't a dropck type\", ty);\n+                    return false;\n                 }\n-                r => {\n-                    debug!(\"trait: {:?} has non-static bound: {:?}; assumed interesting\",\n-                           typ, r);\n-                    has_dtor_of_interest = true;\n-                }\n-            }\n-        }\n-        DtorKind::KnownDropMethod(dtor_method_did) => {\n+            };\n             let impl_did = tcx.impl_of_method(dtor_method_did)\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_bug(\n@@ -638,8 +572,8 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n                     if result {\n                         has_pred_of_interest = true;\n-                        debug!(\"typ: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n-                               typ, pred);\n+                        debug!(\"ty: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n+                               ty, pred);\n                         break 'items;\n                     }\n                 }\n@@ -658,22 +592,25 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n             let has_region_param_of_interest =\n                 dtor_generics.has_region_params(subst::TypeSpace);\n \n-            has_dtor_of_interest =\n+            let has_dtor_of_interest =\n                 has_region_param_of_interest ||\n                 has_pred_of_interest;\n \n             if has_dtor_of_interest {\n-                debug!(\"typ: {:?} has interesting dtor, due to \\\n+                debug!(\"ty: {:?} has interesting dtor, due to \\\n                         region params: {} or pred: {}\",\n-                       typ,\n+                       ty,\n                        has_region_param_of_interest,\n                        has_pred_of_interest);\n             } else {\n-                debug!(\"typ: {:?} has dtor, but it is uninteresting\",\n-                       typ);\n+                debug!(\"ty: {:?} has dtor, but it is uninteresting\", ty);\n             }\n+            has_dtor_of_interest\n         }\n+        ty::TyTrait(..) | ty::TyProjection(..) => {\n+            debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);\n+            true\n+        },\n+        _ => false\n     }\n-\n-    return has_dtor_of_interest;\n }"}, {"sha": "aeac38dab9047dbcc53b65f1b42911fb847ac96c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d576ef3d7be3efe28f902bbb3b2197f4553db412/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d576ef3d7be3efe28f902bbb3b2197f4553db412/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d576ef3d7be3efe28f902bbb3b2197f4553db412", "patch": "@@ -174,7 +174,7 @@ pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n // INTERNALS\n \n pub struct Rcx<'a, 'tcx: 'a> {\n-    fcx: &'a FnCtxt<'a, 'tcx>,\n+    pub fcx: &'a FnCtxt<'a, 'tcx>,\n \n     region_bound_pairs: Vec<(ty::Region, GenericKind<'tcx>)>,\n "}, {"sha": "ee957f20d005bed5d88fb55c88173d636a44ac4c", "filename": "src/test/compile-fail/dropck_misc_variants.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d576ef3d7be3efe28f902bbb3b2197f4553db412/src%2Ftest%2Fcompile-fail%2Fdropck_misc_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d576ef3d7be3efe28f902bbb3b2197f4553db412/src%2Ftest%2Fcompile-fail%2Fdropck_misc_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_misc_variants.rs?ref=d576ef3d7be3efe28f902bbb3b2197f4553db412", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that dropck does the right thing with misc. Ty variants\n+\n+use std::fmt;\n+struct NoisyDrop<T: fmt::Debug>(T);\n+impl<T: fmt::Debug> Drop for NoisyDrop<T> {\n+    fn drop(&mut self) {\n+        let _ = vec![\"0wned\"];\n+        println!(\"dropping {:?}\", self.0)\n+    }\n+}\n+\n+trait Associator {\n+    type As;\n+}\n+impl<T: fmt::Debug> Associator for T {\n+    type As = NoisyDrop<T>;\n+}\n+struct Wrap<A: Associator>(<A as Associator>::As);\n+\n+fn projection() {\n+    let (_w, bomb);\n+    bomb = vec![\"\"];\n+    _w = Wrap::<&[&str]>(NoisyDrop(&bomb));\n+    //~^ ERROR `bomb` does not live long enough\n+}\n+\n+fn closure() {\n+    let (_w,v);\n+    v = vec![\"\"];\n+    _w = {\n+        let u = NoisyDrop(&v);\n+        //~^ ERROR `v` does not live long enough\n+        move || u.0.len()\n+    };\n+}\n+\n+fn main() { closure(); projection() }"}, {"sha": "0a8324eafe295b6b63454d97ed28e2ac5f050c9f", "filename": "src/test/run-pass/issue-24086.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d576ef3d7be3efe28f902bbb3b2197f4553db412/src%2Ftest%2Frun-pass%2Fissue-24086.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d576ef3d7be3efe28f902bbb3b2197f4553db412/src%2Ftest%2Frun-pass%2Fissue-24086.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-24086.rs?ref=d576ef3d7be3efe28f902bbb3b2197f4553db412", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Registry<'a> {\n+    listener: &'a mut (),\n+}\n+\n+pub struct Listener<'a> {\n+    pub announce: Option<Box<FnMut(&mut Registry) + 'a>>,\n+    pub remove: Option<Box<FnMut(&mut Registry) + 'a>>,\n+}\n+\n+impl<'a> Drop for Registry<'a> {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {\n+    let mut registry_listener = Listener {\n+        announce: None,\n+        remove: None,\n+    };\n+}"}, {"sha": "16f1d4626fbaf3af88fe04b6b041548a20893ab5", "filename": "src/test/run-pass/issue-26641.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d576ef3d7be3efe28f902bbb3b2197f4553db412/src%2Ftest%2Frun-pass%2Fissue-26641.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d576ef3d7be3efe28f902bbb3b2197f4553db412/src%2Ftest%2Frun-pass%2Fissue-26641.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-26641.rs?ref=d576ef3d7be3efe28f902bbb3b2197f4553db412", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Parser<'a>(Box<FnMut(Parser) + 'a>);\n+\n+fn main() {\n+    let _x = Parser(Box::new(|_|{}));\n+}"}, {"sha": "4e341d311729d5f34ff7d064047d98a9f84e868d", "filename": "src/test/run-pass/issue-27240.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d576ef3d7be3efe28f902bbb3b2197f4553db412/src%2Ftest%2Frun-pass%2Fissue-27240.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d576ef3d7be3efe28f902bbb3b2197f4553db412/src%2Ftest%2Frun-pass%2Fissue-27240.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27240.rs?ref=d576ef3d7be3efe28f902bbb3b2197f4553db412", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+struct NoisyDrop<T: fmt::Debug>(T);\n+impl<T: fmt::Debug> Drop for NoisyDrop<T> {\n+    fn drop(&mut self) {}\n+}\n+\n+struct Bar<T: fmt::Debug>([*const NoisyDrop<T>; 2]);\n+\n+fn fine() {\n+    let (u,b);\n+    u = vec![43];\n+    b = Bar([&NoisyDrop(&u), &NoisyDrop(&u)]);\n+}\n+\n+struct Bar2<T: fmt::Debug>(*const NoisyDrop<T>, *const NoisyDrop<T>);\n+\n+fn lolwut() {\n+    let (u,v);\n+    u = vec![43];\n+    v = Bar2(&NoisyDrop(&u), &NoisyDrop(&u));\n+}\n+\n+fn main() { fine(); lolwut() }"}]}