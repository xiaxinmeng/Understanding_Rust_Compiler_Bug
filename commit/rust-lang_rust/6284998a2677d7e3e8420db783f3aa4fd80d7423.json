{"sha": "6284998a2677d7e3e8420db783f3aa4fd80d7423", "node_id": "C_kwDOAAsO6NoAKDYyODQ5OThhMjY3N2Q3ZTNlODQyMGRiNzgzZjNhYTRmZDgwZDc0MjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-12T20:48:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-12T20:48:27Z"}, "message": "Auto merge of #103913 - Neutron3529:patch-1, r=thomcc\n\nImprove performance of `rem_euclid()` for signed integers\n\nsuch code is copy from\nhttps://github.com/rust-lang/rust/blob/master/library/std/src/f32.rs and\nhttps://github.com/rust-lang/rust/blob/master/library/std/src/f64.rs\nusing `r+rhs.abs()` is faster than calc it with an if clause. Bench result:\n```\n$ cargo bench\n   Compiling div-euclid v0.1.0 (/me/div-euclid)\n    Finished bench [optimized] target(s) in 1.01s\n     Running unittests src/lib.rs (target/release/deps/div_euclid-7a4530ca7817d1ef)\n\nrunning 7 tests\ntest tests::it_works ... ignored\ntest tests::bench_aaabs     ... bench:  10,498,793 ns/iter (+/- 104,360)\ntest tests::bench_aadefault ... bench:  11,061,862 ns/iter (+/- 94,107)\ntest tests::bench_abs       ... bench:  10,477,193 ns/iter (+/- 81,942)\ntest tests::bench_default   ... bench:  10,622,983 ns/iter (+/- 25,119)\ntest tests::bench_zzabs     ... bench:  10,481,971 ns/iter (+/- 43,787)\ntest tests::bench_zzdefault ... bench:  11,074,976 ns/iter (+/- 29,633)\n\ntest result: ok. 0 passed; 0 failed; 1 ignored; 6 measured; 0 filtered out; finished in 19.35s\n```\nIt seems that, default `rem_euclid` triggered a branch prediction, thus `bench_default` is faster than `bench_aadefault` and `bench_aadefault`, which shuffles the order of calculations. but all of them slower than what it was in `f64`'s and `f32`'s `rem_euclid`, thus I submit this PR.\n\nbench code:\n```rust\n#![feature(test)]\nextern crate test;\n\nfn rem_euclid(a:i32,rhs:i32)->i32{\n    let r = a % rhs;\n    if r < 0 { r + rhs.abs() } else { r }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use test::Bencher;\n    use rand::prelude::*;\n    use rand::rngs::SmallRng;\n    const N:i32=1000;\n    #[test]\n    fn it_works() {\n        let a: i32 = 7; // or any other integer type\n        let b = 4;\n\n        let d:Vec<i32>=(-N..=N).collect();\n        let n:Vec<i32>=(-N..0).chain(1..=N).collect();\n\n        for i in &d {\n            for j in &n {\n                assert_eq!(i.rem_euclid(*j),rem_euclid(*i,*j));\n            }\n        }\n\n        assert_eq!(rem_euclid(a,b), 3);\n        assert_eq!(rem_euclid(-a,b), 1);\n        assert_eq!(rem_euclid(a,-b), 3);\n        assert_eq!(rem_euclid(-a,-b), 1);\n    }\n\n    #[bench]\n    fn bench_aaabs(b: &mut Bencher) {\n        let mut d:Vec<i32>=(-N..=N).collect();\n        let mut n:Vec<i32>=(-N..0).chain(1..=N).collect();\n        let mut rng=SmallRng::from_seed([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,21]);\n        n.shuffle(&mut rng);\n        d.shuffle(&mut rng);\n        n.shuffle(&mut rng);\n        b.iter(||{\n            let mut res=0;\n            for i in &d {\n                for j in &n {\n                    res+=rem_euclid(*i,*j);\n                }\n            }\n            res\n        });\n    }\n    #[bench]\n    fn bench_aadefault(b: &mut Bencher) {\n        let mut d:Vec<i32>=(-N..=N).collect();\n        let mut n:Vec<i32>=(-N..0).chain(1..=N).collect();\n        let mut rng=SmallRng::from_seed([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,21]);\n        n.shuffle(&mut rng);\n        d.shuffle(&mut rng);\n        n.shuffle(&mut rng);\n        b.iter(||{\n            let mut res=0;\n            for i in &d {\n                for j in &n {\n                    res+=i.rem_euclid(*j);\n                }\n            }\n            res\n        });\n    }\n\n    #[bench]\n    fn bench_abs(b: &mut Bencher) {\n        let d:Vec<i32>=(-N..=N).collect();\n        let n:Vec<i32>=(-N..0).chain(1..=N).collect();\n        b.iter(||{\n            let mut res=0;\n            for i in &d {\n                for j in &n {\n                    res+=rem_euclid(*i,*j);\n                }\n            }\n            res\n        });\n    }\n    #[bench]\n    fn bench_default(b: &mut Bencher) {\n        let d:Vec<i32>=(-N..=N).collect();\n        let n:Vec<i32>=(-N..0).chain(1..=N).collect();\n        b.iter(||{\n            let mut res=0;\n            for i in &d {\n                for j in &n {\n                    res+=i.rem_euclid(*j);\n                }\n            }\n            res\n        });\n    }\n\n    #[bench]\n    fn bench_zzabs(b: &mut Bencher) {\n        let mut d:Vec<i32>=(-N..=N).collect();\n        let mut n:Vec<i32>=(-N..0).chain(1..=N).collect();\n        let mut rng=SmallRng::from_seed([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,21]);\n        d.shuffle(&mut rng);\n        n.shuffle(&mut rng);\n        d.shuffle(&mut rng);\n        b.iter(||{\n            let mut res=0;\n            for i in &d {\n                for j in &n {\n                    res+=rem_euclid(*i,*j);\n                }\n            }\n            res\n        });\n    }\n    #[bench]\n    fn bench_zzdefault(b: &mut Bencher) {\n        let mut d:Vec<i32>=(-N..=N).collect();\n        let mut n:Vec<i32>=(-N..0).chain(1..=N).collect();\n        let mut rng=SmallRng::from_seed([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,21]);\n        d.shuffle(&mut rng);\n        n.shuffle(&mut rng);\n        d.shuffle(&mut rng);\n        b.iter(||{\n            let mut res=0;\n            for i in &d {\n                for j in &n {\n                    res+=i.rem_euclid(*j);\n                }\n            }\n            res\n        });\n    }\n}\n```", "tree": {"sha": "0ef0aaaecbcf734354d9749bbd87a5c02be0c169", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ef0aaaecbcf734354d9749bbd87a5c02be0c169"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6284998a2677d7e3e8420db783f3aa4fd80d7423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6284998a2677d7e3e8420db783f3aa4fd80d7423", "html_url": "https://github.com/rust-lang/rust/commit/6284998a2677d7e3e8420db783f3aa4fd80d7423", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6284998a2677d7e3e8420db783f3aa4fd80d7423/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd128880b13bc9f7a919567926e801c8a1487cdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd128880b13bc9f7a919567926e801c8a1487cdb", "html_url": "https://github.com/rust-lang/rust/commit/cd128880b13bc9f7a919567926e801c8a1487cdb"}, {"sha": "d81a0e9e2df9d6a693d7eef362c0aed393e1bf2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d81a0e9e2df9d6a693d7eef362c0aed393e1bf2e", "html_url": "https://github.com/rust-lang/rust/commit/d81a0e9e2df9d6a693d7eef362c0aed393e1bf2e"}], "stats": {"total": 14, "additions": 9, "deletions": 5}, "files": [{"sha": "582c8524cf0fd2dd4c169348eb1423ee9076afbd", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6284998a2677d7e3e8420db783f3aa4fd80d7423/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284998a2677d7e3e8420db783f3aa4fd80d7423/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=6284998a2677d7e3e8420db783f3aa4fd80d7423", "patch": "@@ -2072,11 +2072,15 @@ macro_rules! int_impl {\n         pub const fn rem_euclid(self, rhs: Self) -> Self {\n             let r = self % rhs;\n             if r < 0 {\n-                if rhs < 0 {\n-                    r - rhs\n-                } else {\n-                    r + rhs\n-                }\n+                // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.\n+                // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow\n+                // and is clearly equivalent, because `r` is negative.\n+                // Otherwise, `rhs` is `Self::MIN`, then we have\n+                // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates\n+                // to `r.wrapping_add(Self::MIN)`, which is equivalent to\n+                // `r - Self::MIN`, which is what we wanted (and will not overflow\n+                // for negative `r`).\n+                r.wrapping_add(rhs.wrapping_abs())\n             } else {\n                 r\n             }"}]}