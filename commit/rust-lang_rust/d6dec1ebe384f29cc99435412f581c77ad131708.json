{"sha": "d6dec1ebe384f29cc99435412f581c77ad131708", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZGVjMWViZTM4NGYyOWNjOTk0MzU0MTJmNTgxYzc3YWQxMzE3MDg=", "commit": {"author": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2021-01-17T16:51:37Z"}, "committer": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2021-01-17T17:48:50Z"}, "message": "Optimize Vec::retain", "tree": {"sha": "21e2f482c32aa8b1dba148fbce960939f816a7af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21e2f482c32aa8b1dba148fbce960939f816a7af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6dec1ebe384f29cc99435412f581c77ad131708", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAmAEeIQACgkQztOS3gxI\nPQC/Ew//XOWZpcVfhi1wLELL98d5aoOyNXR5nty2FbGTck3SbJDfngVcRGGubgU+\nPXTT8KQ0vxwMFRebwRw+R8z8G/u45dK1eFReDa+zLHPCS5WxMRmvvnzi5kCi66V7\ntZT9On6n7AmiEcug23ggRbbqdILFRW1EMhzboVtmssi7iZJ4dyWkWWMQTlJ8OPlO\nffdLwvPZB4XpAcburJkTSRhOytq9OTodEAXiyC2Sjqm3iHfrmBEn52OJ2Kx7j3jh\nFDc0qoLGTzqL1lE8lAzjQKATP/1EjbHFfgY3uso/tSUNcD64OcMXYP5RlZBGf3sK\n31M+Ze9yGp4nwGJW/fb6NH3/5HgeM7bp4MoqnxzE1V39dCvV1VTK7Ld+ouYTGCzf\no+WwA0DPSikqmKKIH2yoM0whfmzzzd95EQM6K8nL7Lh1vau5cnVO5+LSMw9UaNbx\nwVrcop2OLe9IzlWSDTn8EKqrvGVrrw8DrSdtcymKXto5zm3s0+XfMaB4+XHngmKm\n1TDm8165bOsSMo4H/aSxMOBc1JEoyvFJvf7IdYGAmAoKHnKgX6PQyLY6jgT48cdI\nGjhY4aQIsH6wmYdIpQiyd8BIFrqkvPoWgg/5LPFLBRStkWuSQAhPjIsWAE/VNxqm\nzTVHofjSd+xoQtK8N/zLkt3TAxPYYTDHmFXBms1HXj+lKSYZMEI=\n=43eX\n-----END PGP SIGNATURE-----", "payload": "tree 21e2f482c32aa8b1dba148fbce960939f816a7af\nparent efdb859dcdf7077cf6b8c85af0ea8820c93bcbdf\nauthor oxalica <oxalicc@pm.me> 1610902297 +0800\ncommitter oxalica <oxalicc@pm.me> 1610905730 +0800\n\nOptimize Vec::retain\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6dec1ebe384f29cc99435412f581c77ad131708", "html_url": "https://github.com/rust-lang/rust/commit/d6dec1ebe384f29cc99435412f581c77ad131708", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6dec1ebe384f29cc99435412f581c77ad131708/comments", "author": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efdb859dcdf7077cf6b8c85af0ea8820c93bcbdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/efdb859dcdf7077cf6b8c85af0ea8820c93bcbdf", "html_url": "https://github.com/rust-lang/rust/commit/efdb859dcdf7077cf6b8c85af0ea8820c93bcbdf"}], "stats": {"total": 151, "additions": 140, "deletions": 11}, "files": [{"sha": "2c510b8b2ae61de27fc422433b60a23574110466", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 68, "deletions": 11, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d6dec1ebe384f29cc99435412f581c77ad131708/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dec1ebe384f29cc99435412f581c77ad131708/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=d6dec1ebe384f29cc99435412f581c77ad131708", "patch": "@@ -1371,21 +1371,78 @@ impl<T, A: Allocator> Vec<T, A> {\n         F: FnMut(&T) -> bool,\n     {\n         let len = self.len();\n-        let mut del = 0;\n-        {\n-            let v = &mut **self;\n-\n-            for i in 0..len {\n-                if !f(&v[i]) {\n-                    del += 1;\n-                } else if del > 0 {\n-                    v.swap(i - del, i);\n+        // Avoid double drop if the drop guard is not executed,\n+        // since we may make some holes during the process.\n+        unsafe { self.set_len(0) };\n+\n+        // Vec: [Kept, Kept, Hole, Hole, Hole, Hole, Unchecked, Unchecked]\n+        //      |<-              processed len   ->| ^- next to check\n+        //                  |<-  deleted cnt     ->|\n+        //      |<-              original_len                          ->|\n+        // Kept: Elements which predicate returns true on.\n+        // Hole: Moved or dropped element slot.\n+        // Unchecked: Unchecked valid elements.\n+        //\n+        // This drop guard will be invoked when predicate or `drop` of element panicked.\n+        // It shifts unchecked elements to cover holes and `set_len` to the correct length.\n+        // In cases when predicate and `drop` never panick, it will be optimized out.\n+        struct BackshiftOnDrop<'a, T, A: Allocator> {\n+            v: &'a mut Vec<T, A>,\n+            processed_len: usize,\n+            deleted_cnt: usize,\n+            original_len: usize,\n+        }\n+\n+        impl<T, A: Allocator> Drop for BackshiftOnDrop<'_, T, A> {\n+            fn drop(&mut self) {\n+                if self.deleted_cnt > 0 {\n+                    // SAFETY: Fill the hole of dropped or moved\n+                    unsafe {\n+                        ptr::copy(\n+                            self.v.as_ptr().offset(self.processed_len as isize),\n+                            self.v\n+                                .as_mut_ptr()\n+                                .offset(self.processed_len as isize - self.deleted_cnt as isize),\n+                            self.original_len - self.processed_len,\n+                        );\n+                        self.v.set_len(self.original_len - self.deleted_cnt);\n+                    }\n                 }\n             }\n         }\n-        if del > 0 {\n-            self.truncate(len - del);\n+\n+        let mut guard = BackshiftOnDrop {\n+            v: self,\n+            processed_len: 0,\n+            deleted_cnt: 0,\n+            original_len: len,\n+        };\n+\n+        let mut del = 0usize;\n+        for i in 0..len {\n+            // SAFETY: Unchecked element must be valid.\n+            let cur = unsafe { &mut *guard.v.as_mut_ptr().offset(i as isize) };\n+            if !f(cur) {\n+                del += 1;\n+                // Advance early to avoid double drop if `drop_in_place` panicked.\n+                guard.processed_len = i + 1;\n+                guard.deleted_cnt = del;\n+                // SAFETY: We never touch this element again after dropped.\n+                unsafe { ptr::drop_in_place(cur) };\n+            } else if del > 0 {\n+                // SAFETY: `del` > 0 so the hole slot must not overlap with current element.\n+                // We use copy for move, and never touch this element again.\n+                unsafe {\n+                    let hole_slot = guard.v.as_mut_ptr().offset(i as isize - del as isize);\n+                    ptr::copy_nonoverlapping(cur, hole_slot, 1);\n+                }\n+                guard.processed_len = i + 1;\n+            }\n         }\n+\n+        // All holes are at the end now. Simply cut them out.\n+        unsafe { guard.v.set_len(len - del) };\n+        mem::forget(guard);\n     }\n \n     /// Removes all but the first of consecutive elements in the vector that resolve to the same"}, {"sha": "856efb1d3a98e0e1bc6329978c2800a20ee0771f", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d6dec1ebe384f29cc99435412f581c77ad131708/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dec1ebe384f29cc99435412f581c77ad131708/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=d6dec1ebe384f29cc99435412f581c77ad131708", "patch": "@@ -287,6 +287,78 @@ fn test_retain() {\n     assert_eq!(vec, [2, 4]);\n }\n \n+#[test]\n+fn test_retain_pred_panic() {\n+    use std::sync::atomic::{AtomicU64, Ordering};\n+\n+    struct Wrap<'a>(&'a AtomicU64, u64, bool);\n+\n+    impl Drop for Wrap<'_> {\n+        fn drop(&mut self) {\n+            self.0.fetch_or(self.1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let dropped = AtomicU64::new(0);\n+\n+    let ret = std::panic::catch_unwind(|| {\n+        let mut v = vec![\n+            Wrap(&dropped, 1, false),\n+            Wrap(&dropped, 2, false),\n+            Wrap(&dropped, 4, false),\n+            Wrap(&dropped, 8, false),\n+            Wrap(&dropped, 16, false),\n+        ];\n+        v.retain(|w| match w.1 {\n+            1 => true,\n+            2 => false,\n+            4 => true,\n+            _ => panic!(),\n+        });\n+    });\n+    assert!(ret.is_err());\n+    // Everything is dropped when predicate panicked.\n+    assert_eq!(dropped.load(Ordering::SeqCst), 1 | 2 | 4 | 8 | 16);\n+}\n+\n+#[test]\n+fn test_retain_drop_panic() {\n+    use std::sync::atomic::{AtomicU64, Ordering};\n+\n+    struct Wrap<'a>(&'a AtomicU64, u64);\n+\n+    impl Drop for Wrap<'_> {\n+        fn drop(&mut self) {\n+            if self.1 == 8 {\n+                panic!();\n+            }\n+            self.0.fetch_or(self.1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let dropped = AtomicU64::new(0);\n+\n+    let ret = std::panic::catch_unwind(|| {\n+        let mut v = vec![\n+            Wrap(&dropped, 1),\n+            Wrap(&dropped, 2),\n+            Wrap(&dropped, 4),\n+            Wrap(&dropped, 8),\n+            Wrap(&dropped, 16),\n+        ];\n+        v.retain(|w| match w.1 {\n+            1 => true,\n+            2 => false,\n+            4 => true,\n+            8 => false,\n+            _ => true,\n+        });\n+    });\n+    assert!(ret.is_err());\n+    // Other elements are dropped when `drop` of one element panicked.\n+    assert_eq!(dropped.load(Ordering::SeqCst), 1 | 2 | 4 | 16);\n+}\n+\n #[test]\n fn test_dedup() {\n     fn case(a: Vec<i32>, b: Vec<i32>) {"}]}