{"sha": "0429493363414d5be8e028812fd01a8a309ef24e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0Mjk0OTMzNjM0MTRkNWJlOGUwMjg4MTJmZDAxYThhMzA5ZWYyNGU=", "commit": {"author": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2013-01-07T20:06:59Z"}, "committer": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2013-01-07T22:22:01Z"}, "message": "fmt: fix formatting and style", "tree": {"sha": "d1e8a8b24cbd91f57caf8010f72db68845b185db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1e8a8b24cbd91f57caf8010f72db68845b185db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0429493363414d5be8e028812fd01a8a309ef24e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0429493363414d5be8e028812fd01a8a309ef24e", "html_url": "https://github.com/rust-lang/rust/commit/0429493363414d5be8e028812fd01a8a309ef24e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0429493363414d5be8e028812fd01a8a309ef24e/comments", "author": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "428abb3d97bbecb90f29e6238dfbedfcf67df2b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/428abb3d97bbecb90f29e6238dfbedfcf67df2b6", "html_url": "https://github.com/rust-lang/rust/commit/428abb3d97bbecb90f29e6238dfbedfcf67df2b6"}], "stats": {"total": 139, "additions": 75, "deletions": 64}, "files": [{"sha": "f92ed6ad8347c14dc8959e44f1a772c1619d25df", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 75, "deletions": 64, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/0429493363414d5be8e028812fd01a8a309ef24e/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0429493363414d5be8e028812fd01a8a309ef24e/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=0429493363414d5be8e028812fd01a8a309ef24e", "patch": "@@ -103,7 +103,9 @@ pub mod ct {\n     use vec;\n \n     pub enum Signedness { Signed, Unsigned, }\n+\n     pub enum Caseness { CaseUpper, CaseLower, }\n+\n     pub enum Ty {\n         TyBool,\n         TyStr,\n@@ -115,13 +117,15 @@ pub mod ct {\n         TyFloat,\n         TyPoly,\n     }\n+\n     pub enum Flag {\n         FlagLeftJustify,\n         FlagLeftZeroPad,\n         FlagSpaceForSign,\n         FlagSignAlways,\n         FlagAlternate,\n     }\n+\n     pub enum Count {\n         CountIs(uint),\n         CountIsParam(uint),\n@@ -136,22 +140,23 @@ pub mod ct {\n \n     impl<T> Parsed<T> {\n         static pure fn new(val: T, next: uint) -> Parsed<T> {\n-            Parsed { val: val, next: next }\n+            Parsed {val: val, next: next}\n         }\n     }\n \n     // A formatted conversion from an expression to a string\n-    pub struct Conv\n-        {param: Option<uint>,\n-         flags: ~[Flag],\n-         width: Count,\n-         precision: Count,\n-         ty: Ty}\n-\n+    pub struct Conv {\n+        param: Option<uint>,\n+        flags: ~[Flag],\n+        width: Count,\n+        precision: Count,\n+        ty: Ty\n+    }\n \n     // A fragment of the output sequence\n     pub enum Piece { PieceString(~str), PieceConv(Conv), }\n-    pub type ErrorFn = fn@(&str) -> ! ;\n+\n+    pub type ErrorFn = @fn(&str) -> !;\n \n     pub fn parse_fmt_string(s: &str, err: ErrorFn) -> ~[Piece] {\n         fn push_slice(ps: &mut ~[Piece], s: &str, from: uint, to: uint) {\n@@ -190,57 +195,61 @@ pub mod ct {\n         push_slice(&mut pieces, s, h, i);\n         pieces\n     }\n-    pub fn peek_num(s: &str, i: uint, lim: uint) ->\n-       Option<Parsed<uint>> {\n-        let mut j = i;\n-        let mut accum = 0u;\n+\n+    pub fn peek_num(s: &str, i: uint, lim: uint) -> Option<Parsed<uint>> {\n+        let mut i = i;\n+        let mut accum = 0;\n         let mut found = false;\n-        while j < lim {\n-            match char::to_digit(s[j] as char, 10) {\n+\n+        while i < lim {\n+            match char::to_digit(s[i] as char, 10) {\n                 Some(x) => {\n                     found = true;\n                     accum *= 10;\n                     accum += x;\n-                    j += 1;\n-                },\n+                    i += 1;\n+                }\n                 None => break\n             }\n         }\n+\n         if found {\n-            Some(Parsed::new(accum, j))\n+            Some(Parsed::new(accum, i))\n         } else {\n             None\n         }\n     }\n-    pub fn parse_conversion(s: &str, i: uint, lim: uint,\n-                            err: ErrorFn) ->\n-       Parsed<Piece> {\n-        let parm = parse_parameter(s, i, lim);\n+\n+    pub fn parse_conversion(s: &str, i: uint, lim: uint, err: ErrorFn) ->\n+        Parsed<Piece> {\n+        let param = parse_parameter(s, i, lim);\n         // avoid copying ~[Flag] by destructuring\n         let Parsed {val: flags_val, next: flags_next} = parse_flags(s,\n-            parm.next, lim);\n+            param.next, lim);\n         let width = parse_count(s, flags_next, lim);\n         let prec = parse_precision(s, width.next, lim);\n         let ty = parse_type(s, prec.next, lim, err);\n-        Parsed::new(\n-                 PieceConv(Conv {param: parm.val,\n-                             flags: flags_val,\n-                             width: width.val,\n-                             precision: prec.val,\n-                             ty: ty.val}),\n-             ty.next)\n+\n+        Parsed::new(PieceConv(Conv {\n+            param: param.val,\n+            flags: flags_val,\n+            width: width.val,\n+            precision: prec.val,\n+            ty: ty.val}), ty.next)\n     }\n+\n     pub fn parse_parameter(s: &str, i: uint, lim: uint) ->\n-       Parsed<Option<uint>> {\n+        Parsed<Option<uint>> {\n         if i >= lim { return Parsed::new(None, i); }\n+\n         match peek_num(s, i, lim) {\n             Some(num) if num.next < lim && s[num.next] == '$' as u8 =>\n                 Parsed::new(Some(num.val), num.next + 1),\n             _ => Parsed::new(None, i)\n         }\n     }\n-    pub fn parse_flags(s: &str, i: uint, lim: uint) ->\n-       Parsed<~[Flag]> {\n+\n+    pub fn parse_flags(s: &str, i: uint, lim: uint) -> Parsed<~[Flag]> {\n         let mut i = i;\n         let mut flags = ~[];\n \n@@ -260,44 +269,45 @@ pub mod ct {\n \n         Parsed::new(flags, i)\n     }\n-        pub fn parse_count(s: &str, i: uint, lim: uint)\n-        -> Parsed<Count> {\n-            if i >= lim {\n-                Parsed::new(CountImplied, i)\n-            } else if s[i] == '*' as u8 {\n-                let param = parse_parameter(s, i + 1, lim);\n-                let j = param.next;\n-                match param.val {\n-                  None => Parsed::new(CountIsNextParam, j),\n-                  Some(n) => Parsed::new(CountIsParam(n), j)\n-                }\n-            } else {\n-                match peek_num(s, i, lim) {\n-                  None => Parsed::new(CountImplied, i),\n-                  Some(num) => Parsed::new(\n-                    CountIs(num.val),\n-                    num.next\n-                  )\n-                }\n+\n+    pub fn parse_count(s: &str, i: uint, lim: uint) -> Parsed<Count> {\n+        if i >= lim {\n+            Parsed::new(CountImplied, i)\n+        } else if s[i] == '*' as u8 {\n+            let param = parse_parameter(s, i + 1, lim);\n+            let j = param.next;\n+\n+            match param.val {\n+                None => Parsed::new(CountIsNextParam, j),\n+                Some(n) => Parsed::new(CountIsParam(n), j)\n+            }\n+        } else {\n+            match peek_num(s, i, lim) {\n+                None => Parsed::new(CountImplied, i),\n+                Some(num) => Parsed::new(CountIs(num.val), num.next)\n             }\n+        }\n     }\n-    pub fn parse_precision(s: &str, i: uint, lim: uint) ->\n-       Parsed<Count> {\n-            if i < lim && s[i] == '.' as u8 {\n-                let count = parse_count(s, i + 1u, lim);\n \n+    pub fn parse_precision(s: &str, i: uint, lim: uint) -> Parsed<Count> {\n+        if i < lim && s[i] == '.' as u8 {\n+            let count = parse_count(s, i + 1, lim);\n \n-                // If there were no digits specified, i.e. the precision\n-                // was \".\", then the precision is 0\n-                match count.val {\n-                  CountImplied => Parsed::new(CountIs(0), count.next),\n-                  _ => count\n-                }\n-            } else { Parsed::new(CountImplied, i) }\n+            // If there were no digits specified, i.e. the precision\n+            // was \".\", then the precision is 0\n+            match count.val {\n+                CountImplied => Parsed::new(CountIs(0), count.next),\n+                _ => count\n+            }\n+        } else {\n+            Parsed::new(CountImplied, i)\n+        }\n     }\n+\n     pub fn parse_type(s: &str, i: uint, lim: uint, err: ErrorFn) ->\n-       Parsed<Ty> {\n+        Parsed<Ty> {\n         if i >= lim { err(~\"missing type in conversion\"); }\n+\n         // FIXME (#2249): Do we really want two signed types here?\n         // How important is it to be printf compatible?\n         let t = match s[i] {\n@@ -314,6 +324,7 @@ pub mod ct {\n             '?' as u8 => TyPoly,\n             _ => err(~\"unknown type in conversion: \" + s.substr(i, 1))\n         };\n+\n         Parsed::new(t, i + 1)\n     }\n }"}]}