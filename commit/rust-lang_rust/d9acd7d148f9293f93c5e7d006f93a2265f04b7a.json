{"sha": "d9acd7d148f9293f93c5e7d006f93a2265f04b7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5YWNkN2QxNDhmOTI5M2Y5M2M1ZTdkMDA2ZjkzYTIyNjVmMDRiN2E=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-10-24T12:12:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-24T12:12:01Z"}, "message": "Rollup merge of #78109 - cuviper:exhausted-rangeinc, r=dtolnay\n\nCheck for exhaustion in RangeInclusive::contains and slicing\n\nWhen a range has finished iteration, `is_empty` returns true, so it\nshould also be the case that `contains` returns false.\n\nFixes #77941.", "tree": {"sha": "2407e7e968c747a46bc7ce0456166ac580e92738", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2407e7e968c747a46bc7ce0456166ac580e92738"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9acd7d148f9293f93c5e7d006f93a2265f04b7a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJflBoRCRBK7hj4Ov3rIwAAdHIIACus+OaItgjxTvDR+BR4HMMq\n8Rep4hUYIkprqWlwXkVEt/cJ6J5MPol5TY1O0dP2AJ8IaiI75jOW6dBKWQs8b6xm\nC/mQnwe76frfA7HJ/igyW0VuZQKXv7pFLdHBYct+YOT+A2ARsXGyLFcZF9UuEV8Y\nA45RpE7yhR5UFYHUeR1pfzJc41MVB2s3VjBnTfYd1HPRZAP84HTTDO9GY9Fq8o47\nuNmVPKnOU4Cno2FEPIr4z0/cRTaOxdbCyIJT6Fe/xg6Wk0eWUqa0RhrBp3YLOdz5\nksoHJBDtqk5CdYXK58xWj1/SYxaPvw7CIeXQLN7d0QiUfNK314I1raC+m461Dpc=\n=saLO\n-----END PGP SIGNATURE-----\n", "payload": "tree 2407e7e968c747a46bc7ce0456166ac580e92738\nparent fb92b70f95205f98a8f863cdf94734b9647ff20d\nparent 9202fbdbdbd60adb62839c3230738274e30f15fc\nauthor Jonas Schievink <jonasschievink@gmail.com> 1603541521 +0200\ncommitter GitHub <noreply@github.com> 1603541521 +0200\n\nRollup merge of #78109 - cuviper:exhausted-rangeinc, r=dtolnay\n\nCheck for exhaustion in RangeInclusive::contains and slicing\n\nWhen a range has finished iteration, `is_empty` returns true, so it\nshould also be the case that `contains` returns false.\n\nFixes #77941.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9acd7d148f9293f93c5e7d006f93a2265f04b7a", "html_url": "https://github.com/rust-lang/rust/commit/d9acd7d148f9293f93c5e7d006f93a2265f04b7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9acd7d148f9293f93c5e7d006f93a2265f04b7a/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb92b70f95205f98a8f863cdf94734b9647ff20d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb92b70f95205f98a8f863cdf94734b9647ff20d", "html_url": "https://github.com/rust-lang/rust/commit/fb92b70f95205f98a8f863cdf94734b9647ff20d"}, {"sha": "9202fbdbdbd60adb62839c3230738274e30f15fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9202fbdbdbd60adb62839c3230738274e30f15fc", "html_url": "https://github.com/rust-lang/rust/commit/9202fbdbdbd60adb62839c3230738274e30f15fc"}], "stats": {"total": 123, "additions": 102, "deletions": 21}, "files": [{"sha": "834dd4656ff76bdb171ef96c3329af15e6ff1e31", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d9acd7d148f9293f93c5e7d006f93a2265f04b7a/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9acd7d148f9293f93c5e7d006f93a2265f04b7a/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=d9acd7d148f9293f93c5e7d006f93a2265f04b7a", "patch": "@@ -529,6 +529,13 @@ mod slice_index {\n             message: \"out of bounds\";\n         }\n \n+        in mod rangeinclusive_len {\n+            data: \"abcdef\";\n+            good: data[0..=5] == \"abcdef\";\n+            bad: data[0..=6];\n+            message: \"out of bounds\";\n+        }\n+\n         in mod range_len_len {\n             data: \"abcdef\";\n             good: data[6..6] == \"\";\n@@ -544,6 +551,28 @@ mod slice_index {\n         }\n     }\n \n+    panic_cases! {\n+        in mod rangeinclusive_exhausted {\n+            data: \"abcdef\";\n+\n+            good: data[0..=5] == \"abcdef\";\n+            good: data[{\n+                let mut iter = 0..=5;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }] == \"\";\n+\n+            // 0..=6 is out of bounds before exhaustion, so it\n+            // stands to reason that it still would be after.\n+            bad: data[{\n+                let mut iter = 0..=6;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }];\n+            message: \"out of bounds\";\n+        }\n+    }\n+\n     panic_cases! {\n         in mod range_neg_width {\n             data: \"abcdef\";"}, {"sha": "1d67e65e51f5f16effad651f589cd99b13a2163b", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d9acd7d148f9293f93c5e7d006f93a2265f04b7a/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9acd7d148f9293f93c5e7d006f93a2265f04b7a/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=d9acd7d148f9293f93c5e7d006f93a2265f04b7a", "patch": "@@ -446,6 +446,20 @@ impl<Idx> RangeInclusive<Idx> {\n     }\n }\n \n+impl RangeInclusive<usize> {\n+    /// Converts to an exclusive `Range` for `SliceIndex` implementations.\n+    /// The caller is responsible for dealing with `end == usize::MAX`.\n+    #[inline]\n+    pub(crate) fn into_slice_range(self) -> Range<usize> {\n+        // If we're not exhausted, we want to simply slice `start..end + 1`.\n+        // If we are exhausted, then slicing with `end + 1..end + 1` gives us an\n+        // empty range that is still subject to bounds-checks for that endpoint.\n+        let exclusive_end = self.end + 1;\n+        let start = if self.exhausted { exclusive_end } else { self.start };\n+        start..exclusive_end\n+    }\n+}\n+\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -479,6 +493,16 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(!(0.0..=f32::NAN).contains(&0.0));\n     /// assert!(!(f32::NAN..=1.0).contains(&1.0));\n     /// ```\n+    ///\n+    /// This method always returns `false` after iteration has finished:\n+    ///\n+    /// ```\n+    /// let mut r = 3..=5;\n+    /// assert!(r.contains(&3) && r.contains(&5));\n+    /// for _ in r.by_ref() {}\n+    /// // Precise field values are unspecified here\n+    /// assert!(!r.contains(&3) && !r.contains(&5));\n+    /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n@@ -881,7 +905,13 @@ impl<T> RangeBounds<T> for RangeInclusive<T> {\n         Included(&self.start)\n     }\n     fn end_bound(&self) -> Bound<&T> {\n-        Included(&self.end)\n+        if self.exhausted {\n+            // When the iterator is exhausted, we usually have start == end,\n+            // but we want the range to appear empty, containing nothing.\n+            Excluded(&self.end)\n+        } else {\n+            Included(&self.end)\n+        }\n     }\n }\n "}, {"sha": "660c8a2da5da04ac3a8006d05ea6bd830e80cd93", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d9acd7d148f9293f93c5e7d006f93a2265f04b7a/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9acd7d148f9293f93c5e7d006f93a2265f04b7a/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=d9acd7d148f9293f93c5e7d006f93a2265f04b7a", "patch": "@@ -376,44 +376,40 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get(slice) }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        if *self.end() == usize::MAX {\n-            None\n-        } else {\n-            (*self.start()..self.end() + 1).get_mut(slice)\n-        }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get_mut(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n+        unsafe { self.into_slice_range().get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n+        unsafe { self.into_slice_range().get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n         if *self.end() == usize::MAX {\n             slice_end_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index(slice)\n+        self.into_slice_range().index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n         if *self.end() == usize::MAX {\n             slice_end_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index_mut(slice)\n+        self.into_slice_range().index_mut(slice)\n     }\n }\n "}, {"sha": "9cfb5a899877371ce156bb4860324faca2e85eae", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d9acd7d148f9293f93c5e7d006f93a2265f04b7a/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9acd7d148f9293f93c5e7d006f93a2265f04b7a/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=d9acd7d148f9293f93c5e7d006f93a2265f04b7a", "patch": "@@ -398,39 +398,35 @@ unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n-        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get(slice) }\n     }\n     #[inline]\n     fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-        if *self.end() == usize::MAX {\n-            None\n-        } else {\n-            (*self.start()..self.end() + 1).get_mut(slice)\n-        }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get_mut(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n+        unsafe { self.into_slice_range().get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n+        unsafe { self.into_slice_range().get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n         if *self.end() == usize::MAX {\n             str_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index(slice)\n+        self.into_slice_range().index(slice)\n     }\n     #[inline]\n     fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n         if *self.end() == usize::MAX {\n             str_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index_mut(slice)\n+        self.into_slice_range().index_mut(slice)\n     }\n }\n "}, {"sha": "9ccc5a08dcbeab1e254f54f9a90fcbadb8bb786d", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d9acd7d148f9293f93c5e7d006f93a2265f04b7a/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9acd7d148f9293f93c5e7d006f93a2265f04b7a/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=d9acd7d148f9293f93c5e7d006f93a2265f04b7a", "patch": "@@ -1341,6 +1341,14 @@ mod slice_index {\n             message: \"out of range\";\n         }\n \n+        in mod rangeinclusive_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[0..=5] == [0, 1, 2, 3, 4, 5];\n+            bad: data[0..=6];\n+            message: \"out of range\";\n+        }\n+\n         in mod range_len_len {\n             data: [0, 1, 2, 3, 4, 5];\n \n@@ -1358,6 +1366,28 @@ mod slice_index {\n         }\n     }\n \n+    panic_cases! {\n+        in mod rangeinclusive_exhausted {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[0..=5] == [0, 1, 2, 3, 4, 5];\n+            good: data[{\n+                let mut iter = 0..=5;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }] == [];\n+\n+            // 0..=6 is out of range before exhaustion, so it\n+            // stands to reason that it still would be after.\n+            bad: data[{\n+                let mut iter = 0..=6;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }];\n+            message: \"out of range\";\n+        }\n+    }\n+\n     panic_cases! {\n         in mod range_neg_width {\n             data: [0, 1, 2, 3, 4, 5];"}]}