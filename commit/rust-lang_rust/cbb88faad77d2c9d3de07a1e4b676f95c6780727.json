{"sha": "cbb88faad77d2c9d3de07a1e4b676f95c6780727", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYjg4ZmFhZDc3ZDJjOWQzZGUwN2ExZTRiNjc2Zjk1YzY3ODA3Mjc=", "commit": {"author": {"name": "Cameron Hart", "email": "cameron.hart@gmail.com", "date": "2016-08-06T05:50:48Z"}, "committer": {"name": "Cameron Hart", "email": "cameron.hart@gmail.com", "date": "2016-08-06T05:50:48Z"}, "message": "Merge branch 'master' into issue-30961", "tree": {"sha": "8f6d010cb4334d31514a08392d784aaecdeae42d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f6d010cb4334d31514a08392d784aaecdeae42d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbb88faad77d2c9d3de07a1e4b676f95c6780727", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbb88faad77d2c9d3de07a1e4b676f95c6780727", "html_url": "https://github.com/rust-lang/rust/commit/cbb88faad77d2c9d3de07a1e4b676f95c6780727", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbb88faad77d2c9d3de07a1e4b676f95c6780727/comments", "author": {"login": "bitshifter", "id": 135700, "node_id": "MDQ6VXNlcjEzNTcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/135700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitshifter", "html_url": "https://github.com/bitshifter", "followers_url": "https://api.github.com/users/bitshifter/followers", "following_url": "https://api.github.com/users/bitshifter/following{/other_user}", "gists_url": "https://api.github.com/users/bitshifter/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitshifter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitshifter/subscriptions", "organizations_url": "https://api.github.com/users/bitshifter/orgs", "repos_url": "https://api.github.com/users/bitshifter/repos", "events_url": "https://api.github.com/users/bitshifter/events{/privacy}", "received_events_url": "https://api.github.com/users/bitshifter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bitshifter", "id": 135700, "node_id": "MDQ6VXNlcjEzNTcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/135700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitshifter", "html_url": "https://github.com/bitshifter", "followers_url": "https://api.github.com/users/bitshifter/followers", "following_url": "https://api.github.com/users/bitshifter/following{/other_user}", "gists_url": "https://api.github.com/users/bitshifter/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitshifter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitshifter/subscriptions", "organizations_url": "https://api.github.com/users/bitshifter/orgs", "repos_url": "https://api.github.com/users/bitshifter/repos", "events_url": "https://api.github.com/users/bitshifter/events{/privacy}", "received_events_url": "https://api.github.com/users/bitshifter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc210a8994174d48965453fa6cbeafc8902bd399", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc210a8994174d48965453fa6cbeafc8902bd399", "html_url": "https://github.com/rust-lang/rust/commit/fc210a8994174d48965453fa6cbeafc8902bd399"}, {"sha": "b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "html_url": "https://github.com/rust-lang/rust/commit/b30eff7ba72a78e31acd61a2b6931919a0ad62e8"}], "stats": {"total": 23929, "additions": 15287, "deletions": 8642}, "files": [{"sha": "0abd858d8228baaf5daa76454e4fa76185154f39", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -7,6 +7,7 @@ services:\n # our configure script, so disable auto submodule management.\n git:\n   submodules: false\n+  depth: 1\n \n before_install:\n   - docker build -t rust -f src/etc/Dockerfile src/etc"}, {"sha": "29f16da058129f917ae7e667a346a6020b5e0334", "filename": "configure", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/configure", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -609,7 +609,7 @@ opt dist-host-only 0 \"only install bins for the host architecture\"\n opt inject-std-version 1 \"inject the current compiler version of libstd into programs\"\n opt llvm-version-check 1 \"check if the LLVM version is supported, build anyway\"\n opt rustbuild 0 \"use the rust and cargo based build system\"\n-opt orbit 0 \"get MIR where it belongs - everywhere; most importantly, in orbit\"\n+opt orbit 1 \"get MIR where it belongs - everywhere; most importantly, in orbit\"\n opt codegen-tests 1 \"run the src/test/codegen tests\"\n opt option-checking 1 \"complain about unrecognized options in this configure script\"\n opt ninja 0 \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\"\n@@ -733,7 +733,7 @@ if [ -n \"$CFG_ENABLE_DEBUG_ASSERTIONS\" ]; then putvar CFG_ENABLE_DEBUG_ASSERTION\n if [ -n \"$CFG_ENABLE_DEBUGINFO\" ]; then putvar CFG_ENABLE_DEBUGINFO; fi\n if [ -n \"$CFG_ENABLE_DEBUG_JEMALLOC\" ]; then putvar CFG_ENABLE_DEBUG_JEMALLOC; fi\n \n-if [ -n \"$CFG_ENABLE_ORBIT\" ]; then putvar CFG_ENABLE_ORBIT; fi\n+if [ -n \"$CFG_DISABLE_ORBIT\" ]; then putvar CFG_DISABLE_ORBIT; fi\n \n step_msg \"looking for build programs\"\n \n@@ -1020,6 +1020,12 @@ then\n             err \"bad LLVM version: $LLVM_VERSION, need >=3.7\"\n             ;;\n     esac\n+\n+    if \"$CFG_LLVM_ROOT/bin/llvm-mc\" -help | grep -- \"-relocation-model\"; then\n+        msg \"found older llvm-mc\"\n+        CFG_LLVM_MC_HAS_RELOCATION_MODEL=1\n+        putvar CFG_LLVM_MC_HAS_RELOCATION_MODEL\n+    fi\n fi\n \n # Even when the user overrides the choice of CC, still try to detect\n@@ -1192,7 +1198,7 @@ do\n             ;;\n \n \n-        x86_64-*-musl)\n+        x86_64-*-musl | arm-*-musleabi)\n             if [ ! -f $CFG_MUSL_ROOT/lib/libc.a ]\n             then\n                 err \"musl libc $CFG_MUSL_ROOT/lib/libc.a not found\""}, {"sha": "5d822f1b1aba62c645969712bab2bba46ad73018", "filename": "mk/cfg/aarch64-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Faarch64-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Faarch64-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-apple-ios.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -17,7 +17,7 @@ CFG_STATIC_LIB_NAME_aarch64-apple-ios=lib$(1).a\n CFG_LIB_DSYM_GLOB_aarch64-apple-ios = lib$(1)-*.a.dSYM\n CFG_CFLAGS_aarch64-apple-ios := $(CFG_IOS_SDK_FLAGS_aarch64-apple-ios)\n CFG_JEMALLOC_CFLAGS_aarch64-apple-ios := $(CFG_IOS_SDK_FLAGS_aarch64-apple-ios)\n-CFG_GCCISH_CFLAGS_aarch64-apple-ios := -Wall -Werror -fPIC $(CFG_IOS_SDK_FLAGS_aarch64-apple-ios)\n+CFG_GCCISH_CFLAGS_aarch64-apple-ios :=  -fPIC $(CFG_IOS_SDK_FLAGS_aarch64-apple-ios)\n CFG_GCCISH_CXXFLAGS_aarch64-apple-ios := -fno-rtti $(CFG_IOS_SDK_FLAGS_aarch64-apple-ios) -I$(CFG_IOS_SDK_aarch64-apple-ios)/usr/include/c++/4.2.1\n CFG_GCCISH_LINK_FLAGS_aarch64-apple-ios := -lpthread -syslibroot $(CFG_IOS_SDK_aarch64-apple-ios) -Wl,-no_compact_unwind\n CFG_GCCISH_DEF_FLAG_aarch64-apple-ios := -Wl,-exported_symbols_list,"}, {"sha": "8120250150d43abae3d03e0be4fe31573d862b61", "filename": "mk/cfg/arm-unknown-linux-musleabi.mk", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Farm-unknown-linux-musleabi.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Farm-unknown-linux-musleabi.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-unknown-linux-musleabi.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -0,0 +1,3 @@\n+# This file is intentially left empty to indicate that, while this target is\n+# supported, it's not supported using plain GNU Make builds. Use a --rustbuild\n+# instead.\n\\ No newline at end of file"}, {"sha": "8120250150d43abae3d03e0be4fe31573d862b61", "filename": "mk/cfg/arm-unknown-linux-musleabihf.mk", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Farm-unknown-linux-musleabihf.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Farm-unknown-linux-musleabihf.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-unknown-linux-musleabihf.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -0,0 +1,3 @@\n+# This file is intentially left empty to indicate that, while this target is\n+# supported, it's not supported using plain GNU Make builds. Use a --rustbuild\n+# instead.\n\\ No newline at end of file"}, {"sha": "34ca4de6563e41626fe59d68bca0af2a3437b724", "filename": "mk/cfg/armv7-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Farmv7-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Farmv7-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farmv7-apple-ios.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -15,7 +15,7 @@ CFG_INSTALL_ONLY_RLIB_armv7-apple-ios = 1\n CFG_STATIC_LIB_NAME_armv7-apple-ios=lib$(1).a\n CFG_LIB_DSYM_GLOB_armv7-apple-ios = lib$(1)-*.a.dSYM\n CFG_JEMALLOC_CFLAGS_armv7-apple-ios := -arch armv7 -mfpu=vfp3 $(CFG_IOS_SDK_FLAGS_armv7-apple-ios)\n-CFG_GCCISH_CFLAGS_armv7-apple-ios := -Wall -Werror -g -fPIC $(CFG_IOS_SDK_FLAGS_armv7-apple-ios) -mfpu=vfp3 -arch armv7\n+CFG_GCCISH_CFLAGS_armv7-apple-ios :=  -g -fPIC $(CFG_IOS_SDK_FLAGS_armv7-apple-ios) -mfpu=vfp3 -arch armv7\n CFG_GCCISH_CXXFLAGS_armv7-apple-ios := -fno-rtti $(CFG_IOS_SDK_FLAGS_armv7-apple-ios) -I$(CFG_IOS_SDK_armv7-apple-ios)/usr/include/c++/4.2.1\n CFG_GCCISH_LINK_FLAGS_armv7-apple-ios := -lpthread -syslibroot $(CFG_IOS_SDK_armv7-apple-ios) -Wl,-no_compact_unwind\n CFG_GCCISH_DEF_FLAG_armv7-apple-ios := -Wl,-exported_symbols_list,"}, {"sha": "8120250150d43abae3d03e0be4fe31573d862b61", "filename": "mk/cfg/armv7-unknown-linux-musleabihf.mk", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Farmv7-unknown-linux-musleabihf.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Farmv7-unknown-linux-musleabihf.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farmv7-unknown-linux-musleabihf.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -0,0 +1,3 @@\n+# This file is intentially left empty to indicate that, while this target is\n+# supported, it's not supported using plain GNU Make builds. Use a --rustbuild\n+# instead.\n\\ No newline at end of file"}, {"sha": "6da7905a7003bd955ebd6e7a18b5c3c0dfd2a3df", "filename": "mk/cfg/armv7s-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Farmv7s-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Farmv7s-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farmv7s-apple-ios.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -15,7 +15,7 @@ CFG_INSTALL_ONLY_RLIB_armv7s-apple-ios = 1\n CFG_STATIC_LIB_NAME_armv7s-apple-ios=lib$(1).a\n CFG_LIB_DSYM_GLOB_armv7s-apple-ios = lib$(1)-*.a.dSYM\n CFG_JEMALLOC_CFLAGS_armv7s-apple-ios := -arch armv7s $(CFG_IOS_SDK_FLAGS_armv7s-apple-ios)\n-CFG_GCCISH_CFLAGS_armv7s-apple-ios := -Wall -Werror -g -fPIC $(CFG_IOS_SDK_FLAGS_armv7s-apple-ios) -arch armv7s\n+CFG_GCCISH_CFLAGS_armv7s-apple-ios :=  -g -fPIC $(CFG_IOS_SDK_FLAGS_armv7s-apple-ios) -arch armv7s\n CFG_GCCISH_CXXFLAGS_armv7s-apple-ios := -fno-rtti $(CFG_IOS_SDK_FLAGS_armv7s-apple-ios) -I$(CFG_IOS_SDK_armv7s-apple-ios)/usr/include/c++/4.2.1\n CFG_GCCISH_LINK_FLAGS_armv7s-apple-ios := -lpthread -syslibroot $(CFG_IOS_SDK_armv7s-apple-ios) -Wl,-no_compact_unwind\n CFG_GCCISH_DEF_FLAG_armv7s-apple-ios := -Wl,-exported_symbols_list,"}, {"sha": "a98a51b06b5d3374e38a2588b6a30d9adb1febc3", "filename": "mk/cfg/asmjs-unknown-emscripten.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fasmjs-unknown-emscripten.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fasmjs-unknown-emscripten.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fasmjs-unknown-emscripten.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,7 +8,7 @@ CFG_STATIC_LIB_NAME_asmjs-unknown-emscripten=lib$(1).a\n CFG_LIB_GLOB_asmjs-unknown-emscripten=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_asmjs-unknown-emscripten=lib$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_asmjs-unknown-emscripten := -m32 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_asmjs-unknown-emscripten := -Wall -Werror -g -fPIC -m32 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_asmjs-unknown-emscripten :=  -g -fPIC -m32 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_asmjs-unknown-emscripten := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_asmjs-unknown-emscripten := -shared -fPIC -ldl -pthread  -lrt -g -m32\n CFG_GCCISH_DEF_FLAG_asmjs-unknown-emscripten := -Wl,--export-dynamic,--dynamic-list="}, {"sha": "bfb7fa281f242aadf870ef16185b5de8faaaed5e", "filename": "mk/cfg/i386-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi386-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi386-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi386-apple-ios.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -14,7 +14,7 @@ CFG_LIB_GLOB_i386-apple-ios = lib$(1)-*.dylib\n CFG_INSTALL_ONLY_RLIB_i386-apple-ios = 1\n CFG_STATIC_LIB_NAME_i386-apple-ios=lib$(1).a\n CFG_LIB_DSYM_GLOB_i386-apple-ios = lib$(1)-*.dylib.dSYM\n-CFG_GCCISH_CFLAGS_i386-apple-ios := -Wall -Werror -g -fPIC -m32 $(CFG_IOSSIM_FLAGS_i386-apple-ios)\n+CFG_GCCISH_CFLAGS_i386-apple-ios :=  -g -fPIC -m32 $(CFG_IOSSIM_FLAGS_i386-apple-ios)\n CFG_GCCISH_CXXFLAGS_i386-apple-ios := -fno-rtti $(CFG_IOSSIM_FLAGS_i386-apple-ios) -I$(CFG_IOSSIM_SDK_i386-apple-ios)/usr/include/c++/4.2.1\n CFG_GCCISH_LINK_FLAGS_i386-apple-ios := -lpthread -m32 -Wl,-no_compact_unwind -m32 -Wl,-syslibroot $(CFG_IOSSIM_SDK_i386-apple-ios)\n CFG_GCCISH_DEF_FLAG_i386-apple-ios := -Wl,-exported_symbols_list,"}, {"sha": "14b9ebfdba66851f8c8d8031afc2eb006c526359", "filename": "mk/cfg/i586-unknown-linux-gnu.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi586-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi586-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi586-unknown-linux-gnu.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,7 +8,7 @@ CFG_STATIC_LIB_NAME_i586-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_i586-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_i586-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_i586-unknown-linux-gnu := -m32 $(CFLAGS) -march=pentium\n-CFG_GCCISH_CFLAGS_i586-unknown-linux-gnu := -Wall -Werror -g -fPIC -m32 $(CFLAGS) -march=pentium\n+CFG_GCCISH_CFLAGS_i586-unknown-linux-gnu :=  -g -fPIC -m32 $(CFLAGS) -march=pentium\n CFG_GCCISH_CXXFLAGS_i586-unknown-linux-gnu := -fno-rtti $(CXXFLAGS) -march=pentium\n CFG_GCCISH_LINK_FLAGS_i586-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m32\n CFG_GCCISH_DEF_FLAG_i586-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list="}, {"sha": "e4b3431e8b67f0256916445fafa712ffd94f3253", "filename": "mk/cfg/i686-apple-darwin.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi686-apple-darwin.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi686-apple-darwin.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-apple-darwin.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,7 +8,7 @@ CFG_STATIC_LIB_NAME_i686-apple-darwin=lib$(1).a\n CFG_LIB_GLOB_i686-apple-darwin=lib$(1)-*.dylib\n CFG_LIB_DSYM_GLOB_i686-apple-darwin=lib$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_i686-apple-darwin := -m32 -arch i386 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_i686-apple-darwin := -Wall -Werror -g -fPIC -m32 -arch i386 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_i686-apple-darwin :=  -g -fPIC -m32 -arch i386 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_i686-apple-darwin := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_i686-apple-darwin := -dynamiclib -pthread  -framework CoreServices -m32\n CFG_GCCISH_DEF_FLAG_i686-apple-darwin := -Wl,-exported_symbols_list,"}, {"sha": "50c2b8c98acd3c130d221dfdfc327f165b960036", "filename": "mk/cfg/i686-pc-windows-gnu.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi686-pc-windows-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi686-pc-windows-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-pc-windows-gnu.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -9,7 +9,7 @@ CFG_STATIC_LIB_NAME_i686-pc-windows-gnu=$(1).lib\n CFG_LIB_GLOB_i686-pc-windows-gnu=$(1)-*.dll\n CFG_LIB_DSYM_GLOB_i686-pc-windows-gnu=$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_i686-pc-windows-gnu := -march=i686 -m32 -D_WIN32_WINNT=0x0600 -D__USE_MINGW_ANSI_STDIO=1 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_i686-pc-windows-gnu := -Wall -Werror -g -m32 -D_WIN32_WINNT=0x0600 -D__USE_MINGW_ANSI_STDIO=1 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_i686-pc-windows-gnu :=  -g -m32 -D_WIN32_WINNT=0x0600 -D__USE_MINGW_ANSI_STDIO=1 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_i686-pc-windows-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_i686-pc-windows-gnu := -shared -g -m32\n CFG_GCCISH_DEF_FLAG_i686-pc-windows-gnu :="}, {"sha": "a9d4446d5d49b5048060977cb1585d62e3b7b77a", "filename": "mk/cfg/i686-unknown-freebsd.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi686-unknown-freebsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi686-unknown-freebsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-unknown-freebsd.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,7 +8,7 @@ CFG_STATIC_LIB_NAME_i686-unknown-freebsd=lib$(1).a\n CFG_LIB_GLOB_i686-unknown-freebsd=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_i686-unknown-freebsd=$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_i686-unknown-freebsd := -m32 -I/usr/local/include $(CFLAGS)\n-CFG_GCCISH_CFLAGS_i686-unknown-freebsd := -Wall -Werror -g -fPIC -m32 -arch i386 -I/usr/local/include $(CFLAGS)\n+CFG_GCCISH_CFLAGS_i686-unknown-freebsd :=  -g -fPIC -m32 -arch i386 -I/usr/local/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_i686-unknown-freebsd := -m32 -shared -fPIC -g -pthread -lrt\n CFG_GCCISH_DEF_FLAG_i686-unknown-freebsd := -Wl,--export-dynamic,--dynamic-list=\n CFG_LLC_FLAGS_i686-unknown-freebsd :="}, {"sha": "9e2312008a10ad6916ea34dbe5fb9b32b5d7cb6b", "filename": "mk/cfg/i686-unknown-linux-gnu.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi686-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi686-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-unknown-linux-gnu.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,7 +8,7 @@ CFG_STATIC_LIB_NAME_i686-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_i686-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_i686-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_i686-unknown-linux-gnu := -m32 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_i686-unknown-linux-gnu := -Wall -Werror -g -fPIC -m32 $(CFLAGS) -march=i686\n+CFG_GCCISH_CFLAGS_i686-unknown-linux-gnu :=  -g -fPIC -m32 $(CFLAGS) -march=i686\n CFG_GCCISH_CXXFLAGS_i686-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_i686-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m32\n CFG_GCCISH_DEF_FLAG_i686-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list="}, {"sha": "80918728316a665f6c110c6aa940cfde8796962b", "filename": "mk/cfg/i686-unknown-linux-musl.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi686-unknown-linux-musl.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fi686-unknown-linux-musl.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-unknown-linux-musl.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,7 +8,7 @@ CFG_LIB_NAME_i686-unknown-linux-musl=lib$(1).so\n CFG_STATIC_LIB_NAME_i686-unknown-linux-musl=lib$(1).a\n CFG_LIB_GLOB_i686-unknown-linux-musl=lib$(1)-*.so\n CFG_JEMALLOC_CFLAGS_i686-unknown-linux-musl := -m32 -Wl,-melf_i386\n-CFG_GCCISH_CFLAGS_i686-unknown-linux-musl := -Wall -Werror -g -fPIC -m32 -Wl,-melf_i386\n+CFG_GCCISH_CFLAGS_i686-unknown-linux-musl :=  -g -fPIC -m32 -Wl,-melf_i386\n CFG_GCCISH_CXXFLAGS_i686-unknown-linux-musl :=\n CFG_GCCISH_LINK_FLAGS_i686-unknown-linux-musl :=\n CFG_GCCISH_DEF_FLAG_i686-unknown-linux-musl :="}, {"sha": "9c5720de4b310dc8d44f9691d6382df55a456987", "filename": "mk/cfg/powerpc-unknown-linux-gnu.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fpowerpc-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fpowerpc-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fpowerpc-unknown-linux-gnu.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -9,7 +9,7 @@ CFG_STATIC_LIB_NAME_powerpc-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_powerpc-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_powerpc-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n CFG_CFLAGS_powerpc-unknown-linux-gnu := -m32 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_powerpc-unknown-linux-gnu := -Wall -Werror -g -fPIC -m32 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_powerpc-unknown-linux-gnu :=  -g -fPIC -m32 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_powerpc-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_powerpc-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m32\n CFG_GCCISH_DEF_FLAG_powerpc-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list="}, {"sha": "389bb6f0cab492e02110d3f6f1bc74a33faa3f4b", "filename": "mk/cfg/powerpc64-unknown-linux-gnu.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fpowerpc64-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fpowerpc64-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fpowerpc64-unknown-linux-gnu.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -10,7 +10,7 @@ CFG_LIB_GLOB_powerpc64-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_powerpc64-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_powerpc64-unknown-linux-gnu := -m64\n CFG_CFLAGS_powerpc64-unknown-linux-gnu := -m64 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_powerpc64-unknown-linux-gnu := -Wall -Werror -g -fPIC -m64 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_powerpc64-unknown-linux-gnu :=  -g -fPIC -m64 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_powerpc64-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_powerpc64-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m64\n CFG_GCCISH_DEF_FLAG_powerpc64-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list="}, {"sha": "6884fa11e7412ceedd76d40cf4a5e44e15143c49", "filename": "mk/cfg/powerpc64le-unknown-linux-gnu.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fpowerpc64le-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fpowerpc64le-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fpowerpc64le-unknown-linux-gnu.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -9,7 +9,7 @@ CFG_STATIC_LIB_NAME_powerpc64le-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_powerpc64le-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_powerpc64le-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n CFG_CFLAGS_powerpc64le-unknown-linux-gnu := -m64 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_powerpc64le-unknown-linux-gnu := -Wall -Werror -g -fPIC -m64 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_powerpc64le-unknown-linux-gnu :=  -g -fPIC -m64 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_powerpc64le-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_powerpc64le-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m64\n CFG_GCCISH_DEF_FLAG_powerpc64le-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list="}, {"sha": "8af47b671a8505a2727b7d69adfae00b23afed19", "filename": "mk/cfg/x86_64-apple-darwin.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-apple-darwin.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-apple-darwin.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-apple-darwin.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,7 +8,7 @@ CFG_STATIC_LIB_NAME_x86_64-apple-darwin=lib$(1).a\n CFG_LIB_GLOB_x86_64-apple-darwin=lib$(1)-*.dylib\n CFG_LIB_DSYM_GLOB_x86_64-apple-darwin=lib$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_x86_64-apple-darwin := -m64 -arch x86_64 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_x86_64-apple-darwin := -Wall -Werror -g -fPIC -m64 -arch x86_64 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-apple-darwin :=  -g -fPIC -m64 -arch x86_64 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_x86_64-apple-darwin := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-apple-darwin := -dynamiclib -pthread  -framework CoreServices -m64\n CFG_GCCISH_DEF_FLAG_x86_64-apple-darwin := -Wl,-exported_symbols_list,"}, {"sha": "764cdc15996d0c5fe8fc93f8b0d1ca35bc949194", "filename": "mk/cfg/x86_64-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-apple-ios.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -16,7 +16,7 @@ CFG_STATIC_LIB_NAME_x86_64-apple-ios=lib$(1).a\n CFG_LIB_DSYM_GLOB_x86_64-apple-ios = lib$(1)-*.a.dSYM\n CFG_CFLAGS_x86_64-apple-ios := $(CFG_IOSSIM_FLAGS_x86_64-apple-ios)\n CFG_JEMALLOC_CFLAGS_x86_64-apple-ios := $(CFG_IOSSIM_FLAGS_x86_64-apple-ios)\n-CFG_GCCISH_CFLAGS_x86_64-apple-ios := -Wall -Werror -fPIC $(CFG_IOSSIM_FLAGS_x86_64-apple-ios)\n+CFG_GCCISH_CFLAGS_x86_64-apple-ios :=  -fPIC $(CFG_IOSSIM_FLAGS_x86_64-apple-ios)\n CFG_GCCISH_CXXFLAGS_x86_64-apple-ios := -fno-rtti $(CFG_IOSSIM_FLAGS_x86_64-apple-ios) -I$(CFG_IOSSIM_SDK_x86_64-apple-ios)/usr/include/c++/4.2.1\n CFG_GCCISH_LINK_FLAGS_x86_64-apple-ios := -lpthread -Wl,-no_compact_unwind -m64 -Wl,-syslibroot $(CFG_IOSSIM_SDK_x86_64-apple-ios)\n CFG_GCCISH_DEF_FLAG_x86_64-apple-ios := -Wl,-exported_symbols_list,"}, {"sha": "82e7b23279fb5339c9fe773df72f26341132880c", "filename": "mk/cfg/x86_64-pc-windows-gnu.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -9,7 +9,7 @@ CFG_STATIC_LIB_NAME_x86_64-pc-windows-gnu=$(1).lib\n CFG_LIB_GLOB_x86_64-pc-windows-gnu=$(1)-*.dll\n CFG_LIB_DSYM_GLOB_x86_64-pc-windows-gnu=$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_x86_64-pc-windows-gnu := -m64 -D_WIN32_WINNT=0x0600 -D__USE_MINGW_ANSI_STDIO=1 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_x86_64-pc-windows-gnu := -Wall -Werror -g -m64 -D_WIN32_WINNT=0x0600 -D__USE_MINGW_ANSI_STDIO=1 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-pc-windows-gnu :=  -g -m64 -D_WIN32_WINNT=0x0600 -D__USE_MINGW_ANSI_STDIO=1 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_x86_64-pc-windows-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-pc-windows-gnu := -shared -g -m64\n CFG_GCCISH_DEF_FLAG_x86_64-pc-windows-gnu :="}, {"sha": "53d58b9fceaa6ab0b762bf74229558de5e0ca1a4", "filename": "mk/cfg/x86_64-rumprun-netbsd.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-rumprun-netbsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-rumprun-netbsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-rumprun-netbsd.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -9,7 +9,7 @@ CFG_LIB_NAME_x86_64-rumprun-netbsd=lib$(1).so\n CFG_STATIC_LIB_NAME_x86_64-rumprun-netbsd=lib$(1).a\n CFG_LIB_GLOB_x86_64-rumprun-netbsd=lib$(1)-*.so\n CFG_JEMALLOC_CFLAGS_x86_64-rumprun-netbsd := -m64\n-CFG_GCCISH_CFLAGS_x86_64-rumprun-netbsd := -Wall -Werror -g -fPIC -m64\n+CFG_GCCISH_CFLAGS_x86_64-rumprun-netbsd :=  -g -fPIC -m64\n CFG_GCCISH_CXXFLAGS_x86_64-rumprun-netbsd :=\n CFG_GCCISH_LINK_FLAGS_x86_64-rumprun-netbsd :=\n CFG_GCCISH_DEF_FLAG_x86_64-rumprun-netbsd :="}, {"sha": "7fc323b234aee9b750dfff8813d4904caa1a723b", "filename": "mk/cfg/x86_64-sun-solaris.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-sun-solaris.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-sun-solaris.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-sun-solaris.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -9,7 +9,7 @@ CFG_STATIC_LIB_NAME_x86_64-sun-solaris=lib$(1).a\n CFG_LIB_GLOB_x86_64-sun-solaris=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-sun-solaris=$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_x86_64-sun-solaris := -I/usr/local/include $(CFLAGS)\n-CFG_GCCISH_CFLAGS_x86_64-sun-solaris := -Wall -Werror -g -D_POSIX_PTHREAD_SEMANTICS -fPIC -I/usr/local/include $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-sun-solaris :=  -g -D_POSIX_PTHREAD_SEMANTICS -fPIC -I/usr/local/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-sun-solaris := -shared -fPIC -g -pthread  -lrt\n CFG_GCCISH_DEF_FLAG_x86_64-sun-solaris := -Wl,--export-dynamic,--dynamic-list=\n CFG_LLC_FLAGS_x86_64-sun-solaris :="}, {"sha": "8ac31c176188b0a50a4efcf923f5825868ace821", "filename": "mk/cfg/x86_64-unknown-bitrig.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-bitrig.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-bitrig.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-bitrig.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,7 +8,7 @@ CFG_STATIC_LIB_NAME_x86_64-unknown-bitrig=lib$(1).a\n CFG_LIB_GLOB_x86_64-unknown-bitrig=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-bitrig=$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_x86_64-unknown-bitrig := -m64 -I/usr/include $(CFLAGS)\n-CFG_GCCISH_CFLAGS_x86_64-unknown-bitrig := -Wall -Werror -fPIE -fPIC -m64 -I/usr/include $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-unknown-bitrig :=  -fPIE -fPIC -m64 -I/usr/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-bitrig := -shared -pic -pthread -m64 $(LDFLAGS)\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-bitrig := -Wl,--export-dynamic,--dynamic-list=\n CFG_LLC_FLAGS_x86_64-unknown-bitrig :="}, {"sha": "579a9a809e205604011e59c73deb368f3eb248ec", "filename": "mk/cfg/x86_64-unknown-dragonfly.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-dragonfly.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-dragonfly.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-dragonfly.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,7 +8,7 @@ CFG_STATIC_LIB_NAME_x86_64-unknown-dragonfly=lib$(1).a\n CFG_LIB_GLOB_x86_64-unknown-dragonfly=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-dragonfly=$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_x86_64-unknown-dragonfly := -m64 -I/usr/include -I/usr/local/include $(CFLAGS)\n-CFG_GCCISH_CFLAGS_x86_64-unknown-dragonfly := -Wall -Werror -g -fPIC -m64 -I/usr/include -I/usr/local/include $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-unknown-dragonfly :=  -g -fPIC -m64 -I/usr/include -I/usr/local/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-dragonfly := -shared -fPIC -g -pthread  -lrt -m64\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-dragonfly := -Wl,--export-dynamic,--dynamic-list=\n CFG_LLC_FLAGS_x86_64-unknown-dragonfly :="}, {"sha": "c700601eac7a18a1427d48fcc866e37d5b40ad2b", "filename": "mk/cfg/x86_64-unknown-freebsd.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-freebsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-freebsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-freebsd.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,7 +8,7 @@ CFG_STATIC_LIB_NAME_x86_64-unknown-freebsd=lib$(1).a\n CFG_LIB_GLOB_x86_64-unknown-freebsd=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-freebsd=$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_x86_64-unknown-freebsd := -I/usr/local/include $(CFLAGS)\n-CFG_GCCISH_CFLAGS_x86_64-unknown-freebsd := -Wall -Werror -g -fPIC -I/usr/local/include $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-unknown-freebsd :=  -g -fPIC -I/usr/local/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-freebsd := -shared -fPIC -g -pthread  -lrt\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-freebsd := -Wl,--export-dynamic,--dynamic-list=\n CFG_LLC_FLAGS_x86_64-unknown-freebsd :="}, {"sha": "817ce22e4f59d10fdf099113ca8a6ea447210dac", "filename": "mk/cfg/x86_64-unknown-linux-gnu.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-linux-gnu.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,7 +8,7 @@ CFG_STATIC_LIB_NAME_x86_64-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_x86_64-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_x86_64-unknown-linux-gnu := -m64\n-CFG_GCCISH_CFLAGS_x86_64-unknown-linux-gnu := -Wall -Werror -g -fPIC -m64\n+CFG_GCCISH_CFLAGS_x86_64-unknown-linux-gnu :=  -g -fPIC -m64\n CFG_GCCISH_CXXFLAGS_x86_64-unknown-linux-gnu := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m64\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list="}, {"sha": "6f707ac3b3fb8512fa4b67e86b77816ee1589979", "filename": "mk/cfg/x86_64-unknown-linux-musl.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-linux-musl.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-linux-musl.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-linux-musl.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -7,8 +7,8 @@ CFG_INSTALL_ONLY_RLIB_x86_64-unknown-linux-musl = 1\n CFG_LIB_NAME_x86_64-unknown-linux-musl=lib$(1).so\n CFG_STATIC_LIB_NAME_x86_64-unknown-linux-musl=lib$(1).a\n CFG_LIB_GLOB_x86_64-unknown-linux-musl=lib$(1)-*.so\n-CFG_JEMALLOC_CFLAGS_x86_64-unknown-linux-musl := -m64\n-CFG_GCCISH_CFLAGS_x86_64-unknown-linux-musl := -Wall -Werror -g -fPIC -m64\n+CFG_JEMALLOC_CFLAGS_x86_64-unknown-linux-musl := -m64 -Wa,-mrelax-relocations=no\n+CFG_GCCISH_CFLAGS_x86_64-unknown-linux-musl :=  -g -fPIC -m64 -Wa,-mrelax-relocations=no\n CFG_GCCISH_CXXFLAGS_x86_64-unknown-linux-musl :=\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-linux-musl :=\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-linux-musl :="}, {"sha": "93bb2d672653e8f46b68cf5efb8dc1059fe04abf", "filename": "mk/cfg/x86_64-unknown-netbsd.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-netbsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-netbsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-netbsd.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -9,7 +9,7 @@ CFG_STATIC_LIB_NAME_x86_64-unknown-netbsd=lib$(1).a\n CFG_LIB_GLOB_x86_64-unknown-netbsd=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-netbsd=$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_x86_64-unknown-netbsd := -I/usr/local/include $(CFLAGS)\n-CFG_GCCISH_CFLAGS_x86_64-unknown-netbsd := -Wall -Werror -g -fPIC -I/usr/local/include $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-unknown-netbsd :=  -g -fPIC -I/usr/local/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-netbsd := -shared -fPIC -g -pthread  -lrt\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-netbsd := -Wl,--export-dynamic,--dynamic-list=\n CFG_LLC_FLAGS_x86_64-unknown-netbsd :="}, {"sha": "7cca1f7b18b3d6cdd5ffc65d6cbced0897f0ed6f", "filename": "mk/cfg/x86_64-unknown-openbsd.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-openbsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fcfg%2Fx86_64-unknown-openbsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-openbsd.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,7 +8,7 @@ CFG_STATIC_LIB_NAME_x86_64-unknown-openbsd=lib$(1).a\n CFG_LIB_GLOB_x86_64-unknown-openbsd=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-openbsd=$(1)-*.dylib.dSYM\n CFG_JEMALLOC_CFLAGS_x86_64-unknown-openbsd := -m64 -I/usr/include $(CFLAGS)\n-CFG_GCCISH_CFLAGS_x86_64-unknown-openbsd := -Wall -Werror -g -fPIC -m64 -I/usr/include $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-unknown-openbsd :=  -g -fPIC -m64 -I/usr/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-openbsd := -shared -fPIC -g -pthread -m64\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-openbsd := -Wl,--export-dynamic,--dynamic-list=\n CFG_LLC_FLAGS_x86_64-unknown-openbsd :="}, {"sha": "c6c3e70abc37ae50c2e7c0f56e1aab0ea0d9b11a", "filename": "mk/main.mk", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -162,9 +162,10 @@ ifdef CFG_ENABLE_DEBUGINFO\n   CFG_RUSTC_FLAGS += -g\n endif\n \n-ifdef CFG_ENABLE_ORBIT\n-  $(info cfg: launching MIR (CFG_ENABLE_ORBIT))\n-  CFG_RUSTC_FLAGS += -Z orbit\n+ifdef CFG_DISABLE_ORBIT\n+  $(info cfg: HOLD HOLD HOLD (CFG_DISABLE_ORBIT))\n+  RUSTFLAGS_STAGE1 += -Z orbit=off\n+  RUSTFLAGS_STAGE2 += -Z orbit=off\n endif\n \n ifdef SAVE_TEMPS"}, {"sha": "d601cab7221f4f097859c2336bbac41ae96df0c0", "filename": "mk/platform.mk", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -221,12 +221,19 @@ define CFG_MAKE_TOOLCHAIN\n     LLVM_MC_RELOCATION_MODEL=\"default\"\n   endif\n \n+  # LLVM changed this flag in 3.9\n+  ifdef CFG_LLVM_MC_HAS_RELOCATION_MODEL\n+    LLVM_MC_RELOC_FLAG := -relocation-model=$$(LLVM_MC_RELOCATION_MODEL)\n+  else\n+    LLVM_MC_RELOC_FLAG := -position-independent\n+  endif\n+\n   # We're using llvm-mc as our assembler because it supports\n   # .cfi pseudo-ops on mac\n   CFG_ASSEMBLE_$(1)=$$(CPP_$(1)) -E $$(2) | \\\n                     $$(LLVM_MC_$$(CFG_BUILD)) \\\n                     -assemble \\\n-                    -relocation-model=$$(LLVM_MC_RELOCATION_MODEL) \\\n+                    $$(LLVM_MC_RELOC_FLAG) \\\n                     -filetype=obj \\\n                     -triple=$(1) \\\n                     -o=$$(1)"}, {"sha": "e86aec60893e9f42c03836d6be379d864230da11", "filename": "mk/rt.mk", "status": "modified", "additions": 330, "deletions": 100, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -223,148 +223,378 @@ endif\n # compiler-rt\n ################################################################################\n \n-ifdef CFG_ENABLE_FAST_MAKE\n-COMPRT_DEPS := $(S)/.gitmodules\n-else\n-COMPRT_DEPS := $(wildcard \\\n-              $(S)src/compiler-rt/* \\\n-              $(S)src/compiler-rt/*/* \\\n-              $(S)src/compiler-rt/*/*/* \\\n-              $(S)src/compiler-rt/*/*/*/*)\n-endif\n-\n-# compiler-rt's build system is a godawful mess. Here we figure out\n-# the ridiculous platform-specific values and paths necessary to get\n-# useful artifacts out of it.\n+# Everything below is a manual compilation of compiler-rt, disregarding its\n+# build system. See comments in `src/bootstrap/native.rs` for more information.\n \n COMPRT_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),compiler-rt)\n COMPRT_LIB_$(1) := $$(RT_OUTPUT_DIR_$(1))/$$(COMPRT_NAME_$(1))\n COMPRT_BUILD_DIR_$(1) := $$(RT_OUTPUT_DIR_$(1))/compiler-rt\n \n-COMPRT_ARCH_$(1) := $$(word 1,$$(subst -, ,$(1)))\n+# GENERIC_SOURCES in CMakeLists.txt\n+COMPRT_OBJS_$(1) := \\\n+  absvdi2.o \\\n+  absvsi2.o \\\n+  adddf3.o \\\n+  addsf3.o \\\n+  addvdi3.o \\\n+  addvsi3.o \\\n+  apple_versioning.o \\\n+  ashldi3.o \\\n+  ashrdi3.o \\\n+  clear_cache.o \\\n+  clzdi2.o \\\n+  clzsi2.o \\\n+  cmpdi2.o \\\n+  comparedf2.o \\\n+  comparesf2.o \\\n+  ctzdi2.o \\\n+  ctzsi2.o \\\n+  divdc3.o \\\n+  divdf3.o \\\n+  divdi3.o \\\n+  divmoddi4.o \\\n+  divmodsi4.o \\\n+  divsc3.o \\\n+  divsf3.o \\\n+  divsi3.o \\\n+  divxc3.o \\\n+  extendsfdf2.o \\\n+  extendhfsf2.o \\\n+  ffsdi2.o \\\n+  fixdfdi.o \\\n+  fixdfsi.o \\\n+  fixsfdi.o \\\n+  fixsfsi.o \\\n+  fixunsdfdi.o \\\n+  fixunsdfsi.o \\\n+  fixunssfdi.o \\\n+  fixunssfsi.o \\\n+  fixunsxfdi.o \\\n+  fixunsxfsi.o \\\n+  fixxfdi.o \\\n+  floatdidf.o \\\n+  floatdisf.o \\\n+  floatdixf.o \\\n+  floatsidf.o \\\n+  floatsisf.o \\\n+  floatundidf.o \\\n+  floatundisf.o \\\n+  floatundixf.o \\\n+  floatunsidf.o \\\n+  floatunsisf.o \\\n+  int_util.o \\\n+  lshrdi3.o \\\n+  moddi3.o \\\n+  modsi3.o \\\n+  muldc3.o \\\n+  muldf3.o \\\n+  muldi3.o \\\n+  mulodi4.o \\\n+  mulosi4.o \\\n+  muloti4.o \\\n+  mulsc3.o \\\n+  mulsf3.o \\\n+  mulvdi3.o \\\n+  mulvsi3.o \\\n+  mulxc3.o \\\n+  negdf2.o \\\n+  negdi2.o \\\n+  negsf2.o \\\n+  negvdi2.o \\\n+  negvsi2.o \\\n+  paritydi2.o \\\n+  paritysi2.o \\\n+  popcountdi2.o \\\n+  popcountsi2.o \\\n+  powidf2.o \\\n+  powisf2.o \\\n+  powixf2.o \\\n+  subdf3.o \\\n+  subsf3.o \\\n+  subvdi3.o \\\n+  subvsi3.o \\\n+  truncdfhf2.o \\\n+  truncdfsf2.o \\\n+  truncsfhf2.o \\\n+  ucmpdi2.o \\\n+  udivdi3.o \\\n+  udivmoddi4.o \\\n+  udivmodsi4.o \\\n+  udivsi3.o \\\n+  umoddi3.o \\\n+  umodsi3.o\n \n-# All this is to figure out the path to the compiler-rt bin\n-ifeq ($$(findstring windows-msvc,$(1)),windows-msvc)\n-COMPRT_DIR_$(1) := windows/Release\n-COMPRT_LIB_NAME_$(1) := clang_rt.builtins-$$(patsubst i%86,i386,$$(COMPRT_ARCH_$(1)))\n+ifeq ($$(findstring ios,$(1)),)\n+COMPRT_OBJS_$(1) += \\\n+  absvti2.o \\\n+  addtf3.o \\\n+  addvti3.o \\\n+  ashlti3.o \\\n+  ashrti3.o \\\n+  clzti2.o \\\n+  cmpti2.o \\\n+  ctzti2.o \\\n+  divtf3.o \\\n+  divti3.o \\\n+  ffsti2.o \\\n+  fixdfti.o \\\n+  fixsfti.o \\\n+  fixunsdfti.o \\\n+  fixunssfti.o \\\n+  fixunsxfti.o \\\n+  fixxfti.o \\\n+  floattidf.o \\\n+  floattisf.o \\\n+  floattixf.o \\\n+  floatuntidf.o \\\n+  floatuntisf.o \\\n+  floatuntixf.o \\\n+  lshrti3.o \\\n+  modti3.o \\\n+  multf3.o \\\n+  multi3.o \\\n+  mulvti3.o \\\n+  negti2.o \\\n+  negvti2.o \\\n+  parityti2.o \\\n+  popcountti2.o \\\n+  powitf2.o \\\n+  subtf3.o \\\n+  subvti3.o \\\n+  trampoline_setup.o \\\n+  ucmpti2.o \\\n+  udivmodti4.o \\\n+  udivti3.o \\\n+  umodti3.o\n endif\n \n-ifeq ($$(findstring windows-gnu,$(1)),windows-gnu)\n-COMPRT_DIR_$(1) := windows\n-COMPRT_LIB_NAME_$(1) := clang_rt.builtins-$$(COMPRT_ARCH_$(1))\n+ifeq ($$(findstring apple,$(1)),apple)\n+COMPRT_OBJS_$(1) +=  \\\n+\t    atomic_flag_clear.o \\\n+\t    atomic_flag_clear_explicit.o \\\n+\t    atomic_flag_test_and_set.o \\\n+\t    atomic_flag_test_and_set_explicit.o \\\n+\t    atomic_signal_fence.o \\\n+\t    atomic_thread_fence.o\n endif\n \n-ifeq ($$(findstring darwin,$(1)),darwin)\n-COMPRT_DIR_$(1) := builtins\n-COMPRT_LIB_NAME_$(1) := clang_rt.builtins_$$(patsubst i686,i386,$$(COMPRT_ARCH_$(1)))_osx\n-endif\n \n-ifeq ($$(findstring ios,$(1)),ios)\n-COMPRT_DIR_$(1) := builtins\n-COMPRT_ARCH_$(1) := $$(patsubst armv7s,armv7em,$$(COMPRT_ARCH_$(1)))\n-COMPRT_LIB_NAME_$(1) := clang_rt.hard_pic_$$(COMPRT_ARCH_$(1))_macho_embedded\n-ifeq ($$(COMPRT_ARCH_$(1)),aarch64)\n-COMPRT_LIB_NAME_$(1) := clang_rt.builtins_arm64_ios\n-endif\n-COMPRT_DEFINES_$(1) := -DCOMPILER_RT_ENABLE_IOS=ON\n+ifeq ($$(findstring windows,$(1)),)\n+COMPRT_OBJS_$(1) += emutls.o\n endif\n \n-ifndef COMPRT_DIR_$(1)\n-# NB: FreeBSD and NetBSD output to \"linux\"...\n-COMPRT_DIR_$(1) := linux\n-COMPRT_ARCH_$(1) := $$(patsubst i586,i386,$$(COMPRT_ARCH_$(1)))\n+ifeq ($$(findstring msvc,$(1)),)\n \n-ifeq ($$(findstring android,$(1)),android)\n-ifeq ($$(findstring arm,$$(COMPRT_ARCH_$(1))),arm)\n-COMPRT_ARCH_$(1) := armhf\n-endif\n+ifeq ($$(findstring freebsd,$(1)),)\n+COMPRT_OBJS_$(1) += gcc_personality_v0.o\n endif\n \n-ifeq ($$(findstring eabihf,$(1)),eabihf)\n-ifeq ($$(findstring armv7,$(1)),)\n-COMPRT_LIB_NAME_$(1) := clang_rt.builtins-armhf\n-endif\n+COMPRT_OBJS_$(1) += emutls.o\n+\n+ifeq ($$(findstring x86_64,$(1)),x86_64)\n+COMPRT_OBJS_$(1) += \\\n+      x86_64/chkstk.o \\\n+      x86_64/chkstk2.o \\\n+      x86_64/floatdidf.o \\\n+      x86_64/floatdisf.o \\\n+      x86_64/floatdixf.o \\\n+      x86_64/floatundidf.o \\\n+      x86_64/floatundisf.o \\\n+      x86_64/floatundixf.o\n endif\n \n-ifndef COMPRT_LIB_NAME_$(1)\n-COMPRT_LIB_NAME_$(1) := clang_rt.builtins-$$(COMPRT_ARCH_$(1))\n-endif\n+ifeq ($$(findstring i686,$$(patsubts i%86,i686,$(1))),i686)\n+COMPRT_OBJS_$(1) += \\\n+      i386/ashldi3.o \\\n+      i386/ashrdi3.o \\\n+      i386/chkstk.o \\\n+      i386/chkstk2.o \\\n+      i386/divdi3.o \\\n+      i386/floatdidf.o \\\n+      i386/floatdisf.o \\\n+      i386/floatdixf.o \\\n+      i386/floatundidf.o \\\n+      i386/floatundisf.o \\\n+      i386/floatundixf.o \\\n+      i386/lshrdi3.o \\\n+      i386/moddi3.o \\\n+      i386/muldi3.o \\\n+      i386/udivdi3.o \\\n+      i386/umoddi3.o\n endif\n \n+else\n+\n+ifeq ($$(findstring x86_64,$(1)),x86_64)\n+COMPRT_OBJS_$(1) += \\\n+      x86_64/floatdidf.o \\\n+      x86_64/floatdisf.o \\\n+      x86_64/floatdixf.o\n+endif\n \n-ifeq ($$(findstring windows-gnu,$(1)),windows-gnu)\n-COMPRT_LIB_FILE_$(1) := lib$$(COMPRT_LIB_NAME_$(1)).a\n endif\n \n-ifeq ($$(findstring android,$(1)),android)\n+# Generic ARM sources, nothing compiles on iOS though\n ifeq ($$(findstring arm,$(1)),arm)\n-COMPRT_LIB_FILE_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),$$(COMPRT_LIB_NAME_$(1))-android)\n+ifeq ($$(findstring ios,$(1)),)\n+COMPRT_OBJS_$(1) += \\\n+  arm/aeabi_cdcmp.o \\\n+  arm/aeabi_cdcmpeq_check_nan.o \\\n+  arm/aeabi_cfcmp.o \\\n+  arm/aeabi_cfcmpeq_check_nan.o \\\n+  arm/aeabi_dcmp.o \\\n+  arm/aeabi_div0.o \\\n+  arm/aeabi_drsub.o \\\n+  arm/aeabi_fcmp.o \\\n+  arm/aeabi_frsub.o \\\n+  arm/aeabi_idivmod.o \\\n+  arm/aeabi_ldivmod.o \\\n+  arm/aeabi_memcmp.o \\\n+  arm/aeabi_memcpy.o \\\n+  arm/aeabi_memmove.o \\\n+  arm/aeabi_memset.o \\\n+  arm/aeabi_uidivmod.o \\\n+  arm/aeabi_uldivmod.o \\\n+  arm/bswapdi2.o \\\n+  arm/bswapsi2.o \\\n+  arm/clzdi2.o \\\n+  arm/clzsi2.o \\\n+  arm/comparesf2.o \\\n+  arm/divmodsi4.o \\\n+  arm/divsi3.o \\\n+  arm/modsi3.o \\\n+  arm/switch16.o \\\n+  arm/switch32.o \\\n+  arm/switch8.o \\\n+  arm/switchu8.o \\\n+  arm/sync_synchronize.o \\\n+  arm/udivmodsi4.o \\\n+  arm/udivsi3.o \\\n+  arm/umodsi3.o\n endif\n endif\n \n-ifndef COMPRT_LIB_FILE_$(1)\n-COMPRT_LIB_FILE_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),$$(COMPRT_LIB_NAME_$(1)))\n+# Thumb sources\n+ifeq ($$(findstring armv7,$(1)),armv7)\n+COMPRT_OBJS_$(1) += \\\n+  arm/sync_fetch_and_add_4.o \\\n+  arm/sync_fetch_and_add_8.o \\\n+  arm/sync_fetch_and_and_4.o \\\n+  arm/sync_fetch_and_and_8.o \\\n+  arm/sync_fetch_and_max_4.o \\\n+  arm/sync_fetch_and_max_8.o \\\n+  arm/sync_fetch_and_min_4.o \\\n+  arm/sync_fetch_and_min_8.o \\\n+  arm/sync_fetch_and_nand_4.o \\\n+  arm/sync_fetch_and_nand_8.o \\\n+  arm/sync_fetch_and_or_4.o \\\n+  arm/sync_fetch_and_or_8.o \\\n+  arm/sync_fetch_and_sub_4.o \\\n+  arm/sync_fetch_and_sub_8.o \\\n+  arm/sync_fetch_and_umax_4.o \\\n+  arm/sync_fetch_and_umax_8.o \\\n+  arm/sync_fetch_and_umin_4.o \\\n+  arm/sync_fetch_and_umin_8.o \\\n+  arm/sync_fetch_and_xor_4.o \\\n+  arm/sync_fetch_and_xor_8.o\n endif\n \n-COMPRT_OUTPUT_$(1) := $$(COMPRT_BUILD_DIR_$(1))/lib/$$(COMPRT_DIR_$(1))/$$(COMPRT_LIB_FILE_$(1))\n-\n-ifeq ($$(findstring windows-msvc,$(1)),windows-msvc)\n-COMPRT_BUILD_ARGS_$(1) := //v:m //nologo\n-COMPRT_BUILD_TARGET_$(1) := lib/builtins/builtins\n-COMPRT_BUILD_CC_$(1) :=\n-else\n-COMPRT_BUILD_ARGS_$(1) :=\n-ifndef COMPRT_BUILD_TARGET_$(1)\n-COMPRT_BUILD_TARGET_$(1) := $$(COMPRT_LIB_NAME_$(1))\n+# VFP sources\n+ifeq ($$(findstring eabihf,$(1)),eabihf)\n+COMPRT_OBJS_$(1) += \\\n+  arm/adddf3vfp.o \\\n+  arm/addsf3vfp.o \\\n+  arm/divdf3vfp.o \\\n+  arm/divsf3vfp.o \\\n+  arm/eqdf2vfp.o \\\n+  arm/eqsf2vfp.o \\\n+  arm/extendsfdf2vfp.o \\\n+  arm/fixdfsivfp.o \\\n+  arm/fixsfsivfp.o \\\n+  arm/fixunsdfsivfp.o \\\n+  arm/fixunssfsivfp.o \\\n+  arm/floatsidfvfp.o \\\n+  arm/floatsisfvfp.o \\\n+  arm/floatunssidfvfp.o \\\n+  arm/floatunssisfvfp.o \\\n+  arm/gedf2vfp.o \\\n+  arm/gesf2vfp.o \\\n+  arm/gtdf2vfp.o \\\n+  arm/gtsf2vfp.o \\\n+  arm/ledf2vfp.o \\\n+  arm/lesf2vfp.o \\\n+  arm/ltdf2vfp.o \\\n+  arm/ltsf2vfp.o \\\n+  arm/muldf3vfp.o \\\n+  arm/mulsf3vfp.o \\\n+  arm/negdf2vfp.o \\\n+  arm/negsf2vfp.o \\\n+  arm/nedf2vfp.o \\\n+  arm/nesf2vfp.o \\\n+  arm/restore_vfp_d8_d15_regs.o \\\n+  arm/save_vfp_d8_d15_regs.o \\\n+  arm/subdf3vfp.o \\\n+  arm/subsf3vfp.o \\\n+  arm/truncdfsf2vfp.o \\\n+  arm/unorddf2vfp.o \\\n+  arm/unordsf2vfp.o\n endif\n-COMPRT_BUILD_CC_$(1) := -DCMAKE_C_COMPILER=$$(call FIND_COMPILER,$$(CC_$(1))) \\\n-\t\t\t-DCMAKE_CXX_COMPILER=$$(call FIND_COMPILER,$$(CXX_$(1)))\n \n-ifeq ($$(findstring ios,$(1)),)\n-COMPRT_BUILD_CC_$(1) := $$(COMPRT_BUILD_CC_$(1)) \\\n-\t\t\t-DCMAKE_C_FLAGS=\"$$(CFG_GCCISH_CFLAGS_$(1)) -Wno-error\"\n+ifeq ($$(findstring aarch64,$(1)),aarch64)\n+COMPRT_OBJS_$(1) += \\\n+  comparetf2.o \\\n+  extenddftf2.o \\\n+  extendsftf2.o \\\n+  fixtfdi.o \\\n+  fixtfsi.o \\\n+  fixtfti.o \\\n+  fixunstfdi.o \\\n+  fixunstfsi.o \\\n+  fixunstfti.o \\\n+  floatditf.o \\\n+  floatsitf.o \\\n+  floatunditf.o \\\n+  floatunsitf.o \\\n+  multc3.o \\\n+  trunctfdf2.o \\\n+  trunctfsf2.o\n endif\n \n+ifeq ($$(findstring msvc,$(1)),msvc)\n+$$(COMPRT_BUILD_DIR_$(1))/%.o: CFLAGS += -Zl -D__func__=__FUNCTION__\n+else\n+$$(COMPRT_BUILD_DIR_$(1))/%.o: CFLAGS += -fno-builtin -fvisibility=hidden \\\n+\t-fomit-frame-pointer -ffreestanding\n endif\n \n-ifeq ($$(findstring emscripten,$(1)),emscripten)\n+COMPRT_OBJS_$(1) := $$(COMPRT_OBJS_$(1):%=$$(COMPRT_BUILD_DIR_$(1))/%)\n \n-# FIXME: emscripten doesn't use compiler-rt and can't build it without\n-# further hacks\n-$$(COMPRT_LIB_$(1)):\n-\ttouch $$@\n+$$(COMPRT_BUILD_DIR_$(1))/%.o: $(S)src/compiler-rt/lib/builtins/%.c\n+\t@mkdir -p $$(@D)\n+\t@$$(call E, compile: $$@)\n+\t$$(Q)$$(call CFG_COMPILE_C_$(1),$$@,$$<)\n \n-else\n+$$(COMPRT_BUILD_DIR_$(1))/%.o: $(S)src/compiler-rt/lib/builtins/%.S \\\n+\t    $$(LLVM_CONFIG_$$(CFG_BUILD))\n+\t@mkdir -p $$(@D)\n+\t@$$(call E, compile: $$@)\n+\t$$(Q)$$(call CFG_ASSEMBLE_$(1),$$@,$$<)\n \n-$$(COMPRT_LIB_$(1)): $$(COMPRT_DEPS) $$(MKFILE_DEPS) $$(LLVM_CONFIG_$$(CFG_BUILD))\n-\t@$$(call E, cmake: compiler-rt)\n-\t$$(Q)rm -rf $$(COMPRT_BUILD_DIR_$(1))\n-\t$$(Q)mkdir $$(COMPRT_BUILD_DIR_$(1))\n-\t$$(Q)cd \"$$(COMPRT_BUILD_DIR_$(1))\"; \\\n-\t\t$$(CFG_CMAKE) \"$(S)src/compiler-rt\" \\\n-\t\t-DCMAKE_BUILD_TYPE=$$(LLVM_BUILD_CONFIG_MODE) \\\n-\t\t-DLLVM_CONFIG_PATH=$$(LLVM_CONFIG_$$(CFG_BUILD)) \\\n-\t\t-DCOMPILER_RT_DEFAULT_TARGET_TRIPLE=$(1) \\\n-\t\t-DCOMPILER_RT_BUILD_SANITIZERS=OFF \\\n-\t\t-DCOMPILER_RT_BUILD_EMUTLS=OFF \\\n-\t\t$$(COMPRT_DEFINES_$(1)) \\\n-\t\t$$(COMPRT_BUILD_CC_$(1)) \\\n-\t\t-G\"$$(CFG_CMAKE_GENERATOR)\"\n-ifneq ($$(CFG_NINJA),)\n-\t$$(CFG_CMAKE) --build \"$$(COMPRT_BUILD_DIR_$(1))\" \\\n-\t\t--target $$(COMPRT_BUILD_TARGET_$(1)) \\\n-\t\t--config $$(LLVM_BUILD_CONFIG_MODE) \\\n-\t\t-- $$(COMPRT_BUILD_ARGS_$(1))\n-else\n-\t$$(Q)$$(CFG_CMAKE) --build \"$$(COMPRT_BUILD_DIR_$(1))\" \\\n-\t\t--target $$(COMPRT_BUILD_TARGET_$(1)) \\\n-\t\t--config $$(LLVM_BUILD_CONFIG_MODE) \\\n-\t\t-- $$(COMPRT_BUILD_ARGS_$(1)) $$(MFLAGS)\n+ifeq ($$(findstring msvc,$(1)),msvc)\n+$$(COMPRT_BUILD_DIR_$(1))/%.o: \\\n+\texport INCLUDE := $$(CFG_MSVC_INCLUDE_PATH_$$(HOST_$(1)))\n endif\n-\t$$(Q)cp \"$$(COMPRT_OUTPUT_$(1))\" $$@\n \n+ifeq ($$(findstring emscripten,$(1)),emscripten)\n+# FIXME: emscripten doesn't use compiler-rt and can't build it without\n+# further hacks\n+COMPRT_OBJS_$(1) :=\n endif\n \n+$$(COMPRT_LIB_$(1)): $$(COMPRT_OBJS_$(1))\n+\t@$$(call E, link: $$@)\n+\t$$(Q)$$(call CFG_CREATE_ARCHIVE_$(1),$$@) $$^\n+\n ################################################################################\n # libbacktrace\n #"}, {"sha": "2d63f69960f78a949b952d4fdf8e916c1559c398", "filename": "mk/rustllvm.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Frustllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Frustllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frustllvm.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -24,7 +24,7 @@ LLVM_EXTRA_INCDIRS_$(1)= $$(call CFG_CC_INCLUDE_$(1),$(S)src/llvm/include) \\\n endif\n \n RUSTLLVM_OBJS_CS_$(1) := $$(addprefix rustllvm/, \\\n-\tExecutionEngineWrapper.cpp RustWrapper.cpp PassWrapper.cpp \\\n+\tRustWrapper.cpp PassWrapper.cpp \\\n \tArchiveWrapper.cpp)\n \n RUSTLLVM_INCS_$(1) = $$(LLVM_EXTRA_INCDIRS_$(1)) \\"}, {"sha": "201e4cae51d6d9a4e293d2eedfa276f477991cd3", "filename": "mk/tests.mk", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -277,7 +277,8 @@ check-stage$(1)-T-$(2)-H-$(3)-exec: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-ui-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-doc-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-doc-error-index-exec \\\n-\tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-exec\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-exec \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-mir-opt-exec\n \n ifndef CFG_DISABLE_CODEGEN_TESTS\n check-stage$(1)-T-$(2)-H-$(3)-exec: \\\n@@ -458,6 +459,7 @@ UI_RS := $(call rwildcard,$(S)src/test/ui/,*.rs) \\\n          $(call rwildcard,$(S)src/test/ui/,*.stdout) \\\n          $(call rwildcard,$(S)src/test/ui/,*.stderr)\n RUSTDOCCK_RS := $(call rwildcard,$(S)src/test/rustdoc/,*.rs)\n+MIR_OPT_RS := $(call rwildcard,$(S)src/test/mir-opt/,*.rs)\n \n RPASS_TESTS := $(RPASS_RS)\n RPASS_VALGRIND_TESTS := $(RPASS_VALGRIND_RS)\n@@ -475,6 +477,7 @@ CODEGEN_UNITS_TESTS := $(CODEGEN_UNITS_RS)\n INCREMENTAL_TESTS := $(INCREMENTAL_RS)\n RMAKE_TESTS := $(RMAKE_RS)\n UI_TESTS := $(UI_RS)\n+MIR_OPT_TESTS := $(MIR_OPT_RS)\n RUSTDOCCK_TESTS := $(RUSTDOCCK_RS)\n \n CTEST_SRC_BASE_rpass = run-pass\n@@ -552,6 +555,11 @@ CTEST_BUILD_BASE_ui = ui\n CTEST_MODE_ui = ui\n CTEST_RUNTOOL_ui = $(CTEST_RUNTOOL)\n \n+CTEST_SRC_BASE_mir-opt = mir-opt\n+CTEST_BUILD_BASE_mir-opt = mir-opt\n+CTEST_MODE_mir-opt = mir-opt\n+CTEST_RUNTOOL_mir-opt = $(CTEST_RUNTOOL)\n+\n CTEST_SRC_BASE_rustdocck = rustdoc\n CTEST_BUILD_BASE_rustdocck = rustdoc\n CTEST_MODE_rustdocck = rustdoc\n@@ -684,6 +692,7 @@ CTEST_DEPS_incremental_$(1)-T-$(2)-H-$(3) = $$(INCREMENTAL_TESTS)\n CTEST_DEPS_rmake_$(1)-T-$(2)-H-$(3) = $$(RMAKE_TESTS) \\\n \t$$(CSREQ$(1)_T_$(3)_H_$(3)) $$(SREQ$(1)_T_$(2)_H_$(3))\n CTEST_DEPS_ui_$(1)-T-$(2)-H-$(3) = $$(UI_TESTS)\n+CTEST_DEPS_mir-opt_$(1)-T-$(2)-H-$(3) = $$(MIR_OPT_TESTS)\n CTEST_DEPS_rustdocck_$(1)-T-$(2)-H-$(3) = $$(RUSTDOCCK_TESTS) \\\n \t\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n \t\t$(S)src/etc/htmldocck.py\n@@ -755,7 +764,7 @@ endef\n \n CTEST_NAMES = rpass rpass-valgrind rpass-full rfail-full cfail-full rfail cfail pfail \\\n \tdebuginfo-gdb debuginfo-lldb codegen codegen-units rustdocck incremental \\\n-\trmake ui\n+\trmake ui mir-opt\n \n $(foreach host,$(CFG_HOST), \\\n  $(eval $(foreach target,$(CFG_TARGET), \\\n@@ -964,6 +973,7 @@ TEST_GROUPS = \\\n \tpretty-rfail-full \\\n \tpretty-rfail \\\n \tpretty-pretty \\\n+\tmir-opt \\\n \t$(NULL)\n \n define DEF_CHECK_FOR_STAGE_AND_TARGET_AND_HOST"}, {"sha": "02698d6f7a1237cdbd014173bd1a0b52a6ac3eb0", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -5,10 +5,10 @@ dependencies = [\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.31 (git+https://github.com/alexcrichton/gcc-rs)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"kernel32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -25,20 +25,25 @@ name = \"cmake\"\n version = \"0.1.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"filetime\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.26\"\n+version = \"0.3.31\"\n+source = \"git+https://github.com/alexcrichton/gcc-rs#b8e2400883f1a2749b323354dad372cdd1c838c7\"\n+\n+[[package]]\n+name = \"gcc\"\n+version = \"0.3.31\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -48,7 +53,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"kernel32-sys\"\n-version = \"0.2.1\"\n+version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"winapi 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -57,7 +62,7 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.9\"\n+version = \"0.2.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -70,7 +75,7 @@ name = \"num_cpus\"\n version = \"0.2.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "02746034cca695460fac0eccda1fbdf395f59a75", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -29,6 +29,6 @@ getopts = \"0.2\"\n rustc-serialize = \"0.3\"\n winapi = \"0.2\"\n kernel32-sys = \"0.2\"\n-gcc = \"0.3.17\"\n+gcc = { git = \"https://github.com/alexcrichton/gcc-rs\" }\n libc = \"0.2\"\n md5 = \"0.1\""}, {"sha": "9e1ee7ccd1e19bc99f471b2c5845aae4a2a125be", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -92,8 +92,7 @@ pub fn std_link(build: &Build,\n     }\n     add_to_sysroot(&out_dir, &libdir);\n \n-    if target.contains(\"musl\") &&\n-       (target.contains(\"x86_64\") || target.contains(\"i686\")) {\n+    if target.contains(\"musl\") && !target.contains(\"mips\") {\n         copy_third_party_objects(build, target, &libdir);\n     }\n }"}, {"sha": "aafbf68d1b7b60b712fac8ba7a6b091b2266c98d", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -72,6 +72,7 @@ pub struct Config {\n     // libstd features\n     pub debug_jemalloc: bool,\n     pub use_jemalloc: bool,\n+    pub backtrace: bool, // support for RUST_BACKTRACE\n \n     // misc\n     pub channel: String,\n@@ -134,6 +135,7 @@ struct Rust {\n     debuginfo: Option<bool>,\n     debug_jemalloc: Option<bool>,\n     use_jemalloc: Option<bool>,\n+    backtrace: Option<bool>,\n     default_linker: Option<String>,\n     default_ar: Option<String>,\n     channel: Option<String>,\n@@ -158,6 +160,7 @@ impl Config {\n         let mut config = Config::default();\n         config.llvm_optimize = true;\n         config.use_jemalloc = true;\n+        config.backtrace = true;\n         config.rust_optimize = true;\n         config.rust_optimize_tests = true;\n         config.submodules = true;\n@@ -230,6 +233,7 @@ impl Config {\n             set(&mut config.rust_rpath, rust.rpath);\n             set(&mut config.debug_jemalloc, rust.debug_jemalloc);\n             set(&mut config.use_jemalloc, rust.use_jemalloc);\n+            set(&mut config.backtrace, rust.backtrace);\n             set(&mut config.channel, rust.channel.clone());\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.rustc_default_ar = rust.default_ar.clone();"}, {"sha": "2894adafef622dab873f3595bd264aaac1cfb004", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -99,6 +99,9 @@\n # Whether or not jemalloc is built with its debug option set\n #debug-jemalloc = false\n \n+# Whether or not `panic!`s generate backtraces (RUST_BACKTRACE)\n+#backtrace = true\n+\n # The default linker that will be used by the generated compiler. Note that this\n # is not the linker used to link said compiler.\n #default-linker = \"cc\""}, {"sha": "acb7e0fadd90a5049aeed4de71982625d2cc5a75", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -388,6 +388,10 @@ impl Build {\n                     check::compiletest(self, &compiler, target.target,\n                                        \"pretty\", \"run-pass-valgrind\");\n                 }\n+                CheckMirOpt { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"mir-opt\", \"mir-opt\");\n+                }\n                 CheckCodegen { compiler } => {\n                     check::compiletest(self, &compiler, target.target,\n                                        \"codegen\", \"codegen\");\n@@ -648,6 +652,9 @@ impl Build {\n         if self.config.use_jemalloc {\n             features.push_str(\" jemalloc\");\n         }\n+        if self.config.backtrace {\n+            features.push_str(\" backtrace\");\n+        }\n         return features\n     }\n \n@@ -848,6 +855,12 @@ impl Build {\n             base.push(\"-stdlib=libc++\".into());\n             base.push(\"-mmacosx-version-min=10.7\".into());\n         }\n+        // This is a hack, because newer binutils broke things on some vms/distros\n+        // (i.e., linking against unknown relocs disabled by the following flag)\n+        // See: https://github.com/rust-lang/rust/issues/34978\n+        if target == \"x86_64-unknown-linux-musl\" {\n+            base.push(\"-Wa,-mrelax-relocations=no\".into());\n+        }\n         return base\n     }\n "}, {"sha": "a78cef4f409b43e1001b209459eb4604e0ff3a5c", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 385, "deletions": 74, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -133,86 +133,397 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n \n /// Compiles the `compiler-rt` library, or at least the builtins part of it.\n ///\n-/// This uses the CMake build system and an existing LLVM build directory to\n-/// compile the project.\n+/// Note that while compiler-rt has a build system associated with it, we\n+/// specifically don't use it here. The compiler-rt build system, written in\n+/// CMake, is actually *very* difficult to work with in terms of getting it to\n+/// compile on all the relevant platforms we want it to compile on. In the end\n+/// it became so much pain to work with local patches, work around the oddities\n+/// of the build system, etc, that we're just building everything by hand now.\n+///\n+/// In general compiler-rt is just a bunch of intrinsics that are in practice\n+/// *very* stable. We just need to make sure that all the relevant functions and\n+/// such are compiled somewhere and placed in an object file somewhere.\n+/// Eventually, these should all be written in Rust!\n+///\n+/// So below you'll find a listing of every single file in the compiler-rt repo\n+/// that we're compiling. We just reach in and compile with the `gcc` crate\n+/// which should have all the relevant flags and such already configured.\n+///\n+/// The risk here is that if we update compiler-rt we may need to compile some\n+/// new intrinsics, but to be honest we surely don't use all of the intrinsics\n+/// listed below today so the likelihood of us actually needing a new intrinsic\n+/// is quite low. The failure case is also just that someone reports a link\n+/// error (if any) and then we just add it to the list. Overall, that cost is\n+/// far far less than working with compiler-rt's build system over time.\n pub fn compiler_rt(build: &Build, target: &str) {\n-    let dst = build.compiler_rt_out(target);\n-    let arch = target.split('-').next().unwrap();\n-    let mode = if build.config.rust_optimize {\"Release\"} else {\"Debug\"};\n+    let build_dir = build.compiler_rt_out(target);\n+    let output = build_dir.join(staticlib(\"compiler-rt\", target));\n+    build.compiler_rt_built.borrow_mut().insert(target.to_string(),\n+                                                output.clone());\n+    t!(fs::create_dir_all(&build_dir));\n \n-    let build_llvm_config = build.llvm_config(&build.config.build);\n-    let mut cfg = cmake::Config::new(build.src.join(\"src/compiler-rt\"));\n-    cfg.target(target)\n+    let mut cfg = gcc::Config::new();\n+    cfg.cargo_metadata(false)\n+       .out_dir(&build_dir)\n+       .target(target)\n        .host(&build.config.build)\n-       .out_dir(&dst)\n-       .profile(mode)\n-       .define(\"LLVM_CONFIG_PATH\", build_llvm_config)\n-       .define(\"COMPILER_RT_DEFAULT_TARGET_TRIPLE\", target)\n-       .define(\"COMPILER_RT_BUILD_SANITIZERS\", \"OFF\")\n-       .define(\"COMPILER_RT_BUILD_EMUTLS\", \"OFF\")\n-       // inform about c/c++ compilers, the c++ compiler isn't actually used but\n-       // it's needed to get the initial configure to work on all platforms.\n-       .define(\"CMAKE_C_COMPILER\", build.cc(target))\n-       .define(\"CMAKE_CXX_COMPILER\", build.cc(target));\n-\n-    let (dir, build_target, libname) = if target.contains(\"linux\") ||\n-                                          target.contains(\"freebsd\") ||\n-                                          target.contains(\"netbsd\") {\n-        let os_extra = if target.contains(\"android\") && target.contains(\"arm\") {\n-            \"-android\"\n-        } else {\n-            \"\"\n-        };\n-        let builtins_arch = match arch {\n-            \"i586\" => \"i386\",\n-            \"arm\" | \"armv7\" if target.contains(\"android\") => \"armhf\",\n-            \"arm\" if target.contains(\"eabihf\") => \"armhf\",\n-            _ => arch,\n-        };\n-        let target = format!(\"clang_rt.builtins-{}\", builtins_arch);\n-        (\"linux\".to_string(),\n-         target.clone(),\n-         format!(\"{}{}\", target, os_extra))\n-    } else if target.contains(\"apple-darwin\") {\n-        let builtins_arch = match arch {\n-            \"i686\" => \"i386\",\n-            _ => arch,\n-        };\n-        let target = format!(\"clang_rt.builtins_{}_osx\", builtins_arch);\n-        (\"builtins\".to_string(), target.clone(), target)\n-    } else if target.contains(\"apple-ios\") {\n-        cfg.define(\"COMPILER_RT_ENABLE_IOS\", \"ON\");\n-        let target = match arch {\n-            \"armv7s\" => \"hard_pic_armv7em_macho_embedded\".to_string(),\n-            \"aarch64\" => \"builtins_arm64_ios\".to_string(),\n-            _ => format!(\"hard_pic_{}_macho_embedded\", arch),\n-        };\n-        (\"builtins\".to_string(), target.clone(), target)\n-    } else if target.contains(\"windows-gnu\") {\n-        let target = format!(\"clang_rt.builtins-{}\", arch);\n-        (\"windows\".to_string(), target.clone(), target)\n-    } else if target.contains(\"windows-msvc\") {\n-        let builtins_arch = match arch {\n-            \"i586\" | \"i686\" => \"i386\",\n-            _ => arch,\n-        };\n-        (format!(\"windows/{}\", mode),\n-         \"lib/builtins/builtins\".to_string(),\n-         format!(\"clang_rt.builtins-{}\", builtins_arch))\n+       .opt_level(2)\n+       .debug(false);\n+\n+    if target.contains(\"msvc\") {\n+        // Don't pull in extra libraries on MSVC\n+        cfg.flag(\"/Zl\");\n+\n+        // Emulate C99 and C++11's __func__ for MSVC prior to 2013 CTP\n+        cfg.define(\"__func__\", Some(\"__FUNCTION__\"));\n     } else {\n-        panic!(\"can't get os from target: {}\", target)\n-    };\n-    let output = dst.join(\"build/lib\").join(dir)\n-                    .join(staticlib(&libname, target));\n-    build.compiler_rt_built.borrow_mut().insert(target.to_string(),\n-                                                output.clone());\n-    if fs::metadata(&output).is_ok() {\n+        // Turn off various features of gcc and such, mostly copying\n+        // compiler-rt's build system already\n+        cfg.flag(\"-fno-builtin\");\n+        cfg.flag(\"-fvisibility=hidden\");\n+        cfg.flag(\"-fomit-frame-pointer\");\n+        cfg.flag(\"-ffreestanding\");\n+    }\n+\n+    let mut sources = vec![\n+        \"absvdi2.c\",\n+        \"absvsi2.c\",\n+        \"adddf3.c\",\n+        \"addsf3.c\",\n+        \"addvdi3.c\",\n+        \"addvsi3.c\",\n+        \"apple_versioning.c\",\n+        \"ashldi3.c\",\n+        \"ashrdi3.c\",\n+        \"clear_cache.c\",\n+        \"clzdi2.c\",\n+        \"clzsi2.c\",\n+        \"cmpdi2.c\",\n+        \"comparedf2.c\",\n+        \"comparesf2.c\",\n+        \"ctzdi2.c\",\n+        \"ctzsi2.c\",\n+        \"divdc3.c\",\n+        \"divdf3.c\",\n+        \"divdi3.c\",\n+        \"divmoddi4.c\",\n+        \"divmodsi4.c\",\n+        \"divsc3.c\",\n+        \"divsf3.c\",\n+        \"divsi3.c\",\n+        \"divxc3.c\",\n+        \"extendsfdf2.c\",\n+        \"extendhfsf2.c\",\n+        \"ffsdi2.c\",\n+        \"fixdfdi.c\",\n+        \"fixdfsi.c\",\n+        \"fixsfdi.c\",\n+        \"fixsfsi.c\",\n+        \"fixunsdfdi.c\",\n+        \"fixunsdfsi.c\",\n+        \"fixunssfdi.c\",\n+        \"fixunssfsi.c\",\n+        \"fixunsxfdi.c\",\n+        \"fixunsxfsi.c\",\n+        \"fixxfdi.c\",\n+        \"floatdidf.c\",\n+        \"floatdisf.c\",\n+        \"floatdixf.c\",\n+        \"floatsidf.c\",\n+        \"floatsisf.c\",\n+        \"floatundidf.c\",\n+        \"floatundisf.c\",\n+        \"floatundixf.c\",\n+        \"floatunsidf.c\",\n+        \"floatunsisf.c\",\n+        \"int_util.c\",\n+        \"lshrdi3.c\",\n+        \"moddi3.c\",\n+        \"modsi3.c\",\n+        \"muldc3.c\",\n+        \"muldf3.c\",\n+        \"muldi3.c\",\n+        \"mulodi4.c\",\n+        \"mulosi4.c\",\n+        \"muloti4.c\",\n+        \"mulsc3.c\",\n+        \"mulsf3.c\",\n+        \"mulvdi3.c\",\n+        \"mulvsi3.c\",\n+        \"mulxc3.c\",\n+        \"negdf2.c\",\n+        \"negdi2.c\",\n+        \"negsf2.c\",\n+        \"negvdi2.c\",\n+        \"negvsi2.c\",\n+        \"paritydi2.c\",\n+        \"paritysi2.c\",\n+        \"popcountdi2.c\",\n+        \"popcountsi2.c\",\n+        \"powidf2.c\",\n+        \"powisf2.c\",\n+        \"powixf2.c\",\n+        \"subdf3.c\",\n+        \"subsf3.c\",\n+        \"subvdi3.c\",\n+        \"subvsi3.c\",\n+        \"truncdfhf2.c\",\n+        \"truncdfsf2.c\",\n+        \"truncsfhf2.c\",\n+        \"ucmpdi2.c\",\n+        \"udivdi3.c\",\n+        \"udivmoddi4.c\",\n+        \"udivmodsi4.c\",\n+        \"udivsi3.c\",\n+        \"umoddi3.c\",\n+        \"umodsi3.c\",\n+    ];\n+\n+    if !target.contains(\"ios\") {\n+        sources.extend(vec![\n+            \"absvti2.c\",\n+            \"addtf3.c\",\n+            \"addvti3.c\",\n+            \"ashlti3.c\",\n+            \"ashrti3.c\",\n+            \"clzti2.c\",\n+            \"cmpti2.c\",\n+            \"ctzti2.c\",\n+            \"divtf3.c\",\n+            \"divti3.c\",\n+            \"ffsti2.c\",\n+            \"fixdfti.c\",\n+            \"fixsfti.c\",\n+            \"fixunsdfti.c\",\n+            \"fixunssfti.c\",\n+            \"fixunsxfti.c\",\n+            \"fixxfti.c\",\n+            \"floattidf.c\",\n+            \"floattisf.c\",\n+            \"floattixf.c\",\n+            \"floatuntidf.c\",\n+            \"floatuntisf.c\",\n+            \"floatuntixf.c\",\n+            \"lshrti3.c\",\n+            \"modti3.c\",\n+            \"multf3.c\",\n+            \"multi3.c\",\n+            \"mulvti3.c\",\n+            \"negti2.c\",\n+            \"negvti2.c\",\n+            \"parityti2.c\",\n+            \"popcountti2.c\",\n+            \"powitf2.c\",\n+            \"subtf3.c\",\n+            \"subvti3.c\",\n+            \"trampoline_setup.c\",\n+            \"ucmpti2.c\",\n+            \"udivmodti4.c\",\n+            \"udivti3.c\",\n+            \"umodti3.c\",\n+        ]);\n+    }\n+\n+    if target.contains(\"apple\") {\n+        sources.extend(vec![\n+            \"atomic_flag_clear.c\",\n+            \"atomic_flag_clear_explicit.c\",\n+            \"atomic_flag_test_and_set.c\",\n+            \"atomic_flag_test_and_set_explicit.c\",\n+            \"atomic_signal_fence.c\",\n+            \"atomic_thread_fence.c\",\n+        ]);\n+    }\n+\n+    if !target.contains(\"windows\") {\n+        sources.push(\"emutls.c\");\n+    }\n+\n+    if target.contains(\"msvc\") {\n+        if target.contains(\"x86_64\") {\n+            sources.extend(vec![\n+                \"x86_64/floatdidf.c\",\n+                \"x86_64/floatdisf.c\",\n+                \"x86_64/floatdixf.c\",\n+            ]);\n+        }\n+    } else {\n+        if !target.contains(\"freebsd\") {\n+            sources.push(\"gcc_personality_v0.c\");\n+        }\n+\n+        if target.contains(\"x86_64\") {\n+            sources.extend(vec![\n+                \"x86_64/chkstk.S\",\n+                \"x86_64/chkstk2.S\",\n+                \"x86_64/floatdidf.c\",\n+                \"x86_64/floatdisf.c\",\n+                \"x86_64/floatdixf.c\",\n+                \"x86_64/floatundidf.S\",\n+                \"x86_64/floatundisf.S\",\n+                \"x86_64/floatundixf.S\",\n+            ]);\n+        }\n+\n+        if target.contains(\"i386\") ||\n+           target.contains(\"i586\") ||\n+           target.contains(\"i686\") {\n+            sources.extend(vec![\n+                \"i386/ashldi3.S\",\n+                \"i386/ashrdi3.S\",\n+                \"i386/chkstk.S\",\n+                \"i386/chkstk2.S\",\n+                \"i386/divdi3.S\",\n+                \"i386/floatdidf.S\",\n+                \"i386/floatdisf.S\",\n+                \"i386/floatdixf.S\",\n+                \"i386/floatundidf.S\",\n+                \"i386/floatundisf.S\",\n+                \"i386/floatundixf.S\",\n+                \"i386/lshrdi3.S\",\n+                \"i386/moddi3.S\",\n+                \"i386/muldi3.S\",\n+                \"i386/udivdi3.S\",\n+                \"i386/umoddi3.S\",\n+            ]);\n+        }\n+    }\n+\n+    if target.contains(\"arm\") && !target.contains(\"ios\") {\n+        sources.extend(vec![\n+            \"arm/aeabi_cdcmp.S\",\n+            \"arm/aeabi_cdcmpeq_check_nan.c\",\n+            \"arm/aeabi_cfcmp.S\",\n+            \"arm/aeabi_cfcmpeq_check_nan.c\",\n+            \"arm/aeabi_dcmp.S\",\n+            \"arm/aeabi_div0.c\",\n+            \"arm/aeabi_drsub.c\",\n+            \"arm/aeabi_fcmp.S\",\n+            \"arm/aeabi_frsub.c\",\n+            \"arm/aeabi_idivmod.S\",\n+            \"arm/aeabi_ldivmod.S\",\n+            \"arm/aeabi_memcmp.S\",\n+            \"arm/aeabi_memcpy.S\",\n+            \"arm/aeabi_memmove.S\",\n+            \"arm/aeabi_memset.S\",\n+            \"arm/aeabi_uidivmod.S\",\n+            \"arm/aeabi_uldivmod.S\",\n+            \"arm/bswapdi2.S\",\n+            \"arm/bswapsi2.S\",\n+            \"arm/clzdi2.S\",\n+            \"arm/clzsi2.S\",\n+            \"arm/comparesf2.S\",\n+            \"arm/divmodsi4.S\",\n+            \"arm/divsi3.S\",\n+            \"arm/modsi3.S\",\n+            \"arm/switch16.S\",\n+            \"arm/switch32.S\",\n+            \"arm/switch8.S\",\n+            \"arm/switchu8.S\",\n+            \"arm/sync_synchronize.S\",\n+            \"arm/udivmodsi4.S\",\n+            \"arm/udivsi3.S\",\n+            \"arm/umodsi3.S\",\n+        ]);\n+    }\n+\n+    if target.contains(\"armv7\") {\n+        sources.extend(vec![\n+            \"arm/sync_fetch_and_add_4.S\",\n+            \"arm/sync_fetch_and_add_8.S\",\n+            \"arm/sync_fetch_and_and_4.S\",\n+            \"arm/sync_fetch_and_and_8.S\",\n+            \"arm/sync_fetch_and_max_4.S\",\n+            \"arm/sync_fetch_and_max_8.S\",\n+            \"arm/sync_fetch_and_min_4.S\",\n+            \"arm/sync_fetch_and_min_8.S\",\n+            \"arm/sync_fetch_and_nand_4.S\",\n+            \"arm/sync_fetch_and_nand_8.S\",\n+            \"arm/sync_fetch_and_or_4.S\",\n+            \"arm/sync_fetch_and_or_8.S\",\n+            \"arm/sync_fetch_and_sub_4.S\",\n+            \"arm/sync_fetch_and_sub_8.S\",\n+            \"arm/sync_fetch_and_umax_4.S\",\n+            \"arm/sync_fetch_and_umax_8.S\",\n+            \"arm/sync_fetch_and_umin_4.S\",\n+            \"arm/sync_fetch_and_umin_8.S\",\n+            \"arm/sync_fetch_and_xor_4.S\",\n+            \"arm/sync_fetch_and_xor_8.S\",\n+        ]);\n+    }\n+\n+    if target.contains(\"eabihf\") {\n+        sources.extend(vec![\n+            \"arm/adddf3vfp.S\",\n+            \"arm/addsf3vfp.S\",\n+            \"arm/divdf3vfp.S\",\n+            \"arm/divsf3vfp.S\",\n+            \"arm/eqdf2vfp.S\",\n+            \"arm/eqsf2vfp.S\",\n+            \"arm/extendsfdf2vfp.S\",\n+            \"arm/fixdfsivfp.S\",\n+            \"arm/fixsfsivfp.S\",\n+            \"arm/fixunsdfsivfp.S\",\n+            \"arm/fixunssfsivfp.S\",\n+            \"arm/floatsidfvfp.S\",\n+            \"arm/floatsisfvfp.S\",\n+            \"arm/floatunssidfvfp.S\",\n+            \"arm/floatunssisfvfp.S\",\n+            \"arm/gedf2vfp.S\",\n+            \"arm/gesf2vfp.S\",\n+            \"arm/gtdf2vfp.S\",\n+            \"arm/gtsf2vfp.S\",\n+            \"arm/ledf2vfp.S\",\n+            \"arm/lesf2vfp.S\",\n+            \"arm/ltdf2vfp.S\",\n+            \"arm/ltsf2vfp.S\",\n+            \"arm/muldf3vfp.S\",\n+            \"arm/mulsf3vfp.S\",\n+            \"arm/negdf2vfp.S\",\n+            \"arm/negsf2vfp.S\",\n+            \"arm/nedf2vfp.S\",\n+            \"arm/nesf2vfp.S\",\n+            \"arm/restore_vfp_d8_d15_regs.S\",\n+            \"arm/save_vfp_d8_d15_regs.S\",\n+            \"arm/subdf3vfp.S\",\n+            \"arm/subsf3vfp.S\",\n+            \"arm/truncdfsf2vfp.S\",\n+            \"arm/unorddf2vfp.S\",\n+            \"arm/unordsf2vfp.S\",\n+        ]);\n+    }\n+\n+    if target.contains(\"aarch64\") {\n+        sources.extend(vec![\n+            \"comparetf2.c\",\n+            \"extenddftf2.c\",\n+            \"extendsftf2.c\",\n+            \"fixtfdi.c\",\n+            \"fixtfsi.c\",\n+            \"fixtfti.c\",\n+            \"fixunstfdi.c\",\n+            \"fixunstfsi.c\",\n+            \"fixunstfti.c\",\n+            \"floatditf.c\",\n+            \"floatsitf.c\",\n+            \"floatunditf.c\",\n+            \"floatunsitf.c\",\n+            \"multc3.c\",\n+            \"trunctfdf2.c\",\n+            \"trunctfsf2.c\",\n+        ]);\n+    }\n+\n+    let mut out_of_date = false;\n+    for src in sources {\n+        let src = build.src.join(\"src/compiler-rt/lib/builtins\").join(src);\n+        out_of_date = out_of_date || !up_to_date(&src, &output);\n+        cfg.file(src);\n+    }\n+    if !out_of_date {\n         return\n     }\n-    let _ = fs::remove_dir_all(&dst);\n-    t!(fs::create_dir_all(&dst));\n-    cfg.build_target(&build_target);\n-    cfg.build();\n+    cfg.compile(\"libcompiler-rt.a\");\n }\n \n /// Compiles the `rust_test_helpers.c` library which we used in various"}, {"sha": "09f96782e7184a9af4a9564430164224fcfb6fb2", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -31,6 +31,15 @@ use Build;\n pub fn check(build: &mut Build) {\n     let mut checked = HashSet::new();\n     let path = env::var_os(\"PATH\").unwrap_or(OsString::new());\n+    // On Windows, quotes are invalid characters for filename paths, and if\n+    // one is present as part of the PATH then that can lead to the system\n+    // being unable to identify the files properly. See\n+    // https://github.com/rust-lang/rust/issues/34959 for more details.\n+    if cfg!(windows) {\n+        if path.to_string_lossy().contains(\"\\\"\") {\n+            panic!(\"PATH contains invalid character '\\\"'\");\n+        }\n+    }\n     let mut need_cmd = |cmd: &OsStr| {\n         if !checked.insert(cmd.to_owned()) {\n             return\n@@ -100,7 +109,7 @@ pub fn check(build: &mut Build) {\n         }\n \n         // Make sure musl-root is valid if specified\n-        if target.contains(\"musl\") && (target.contains(\"x86_64\") || target.contains(\"i686\")) {\n+        if target.contains(\"musl\") && !target.contains(\"mips\") {\n             match build.config.musl_root {\n                 Some(ref root) => {\n                     if fs::metadata(root.join(\"lib/libc.a\")).is_err() {"}, {"sha": "f715ceb16d71b969313528ebd1a1510d3dfab688", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -124,6 +124,7 @@ macro_rules! targets {\n             (check_codegen_units, CheckCodegenUnits { compiler: Compiler<'a> }),\n             (check_incremental, CheckIncremental { compiler: Compiler<'a> }),\n             (check_ui, CheckUi { compiler: Compiler<'a> }),\n+            (check_mir_opt, CheckMirOpt { compiler: Compiler<'a> }),\n             (check_debuginfo, CheckDebuginfo { compiler: Compiler<'a> }),\n             (check_rustdoc, CheckRustdoc { compiler: Compiler<'a> }),\n             (check_docs, CheckDocs { compiler: Compiler<'a> }),\n@@ -347,9 +348,7 @@ impl<'a> Step<'a> {\n                 vec![self.libstd(compiler),\n                      self.target(host).rustc(compiler.stage)]\n             }\n-            Source::CompilerRt { _dummy } => {\n-                vec![self.llvm(()).target(&build.config.build)]\n-            }\n+            Source::CompilerRt { _dummy } => Vec::new(),\n             Source::Llvm { _dummy } => Vec::new(),\n             Source::TestHelpers { _dummy } => Vec::new(),\n             Source::DebuggerScripts { stage: _ } => Vec::new(),\n@@ -452,6 +451,7 @@ impl<'a> Step<'a> {\n                         self.check_pretty_rfail_full(compiler),\n                         self.check_rpass_valgrind(compiler),\n                         self.check_rmake(compiler),\n+                        self.check_mir_opt(compiler),\n \n                         // crates\n                         self.check_crate_rustc(compiler),\n@@ -479,6 +479,7 @@ impl<'a> Step<'a> {\n             Source::CheckTidy { stage } => {\n                 vec![self.tool_tidy(stage)]\n             }\n+            Source::CheckMirOpt { compiler} |\n             Source::CheckPrettyRPass { compiler } |\n             Source::CheckPrettyRFail { compiler } |\n             Source::CheckRFail { compiler } |"}, {"sha": "b5230132bcb666e3cb9dac6e821fe1d9edd71c3c", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -103,7 +103,10 @@ pub fn add_lib_path(path: Vec<PathBuf>, cmd: &mut Command) {\n /// Uses last-modified time checks to verify this.\n pub fn up_to_date(src: &Path, dst: &Path) -> bool {\n     let threshold = mtime(dst);\n-    let meta = t!(fs::metadata(src));\n+    let meta = match fs::metadata(src) {\n+        Ok(meta) => meta,\n+        Err(e) => panic!(\"source {:?} failed to get metadata: {}\", src, e),\n+    };\n     if meta.is_dir() {\n         dir_up_to_date(src, &threshold)\n     } else {"}, {"sha": "8598065bd965d9713bfafb6c1e766d63a7b17b89", "filename": "src/compiler-rt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler-rt?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -1 +1 @@\n-Subproject commit ac3d1cda612edccb6f1da53cbf7716e248405f3b\n+Subproject commit 8598065bd965d9713bfafb6c1e766d63a7b17b89"}, {"sha": "1470eac98295e8860c02464d7e445e68e2593aeb", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -223,6 +223,7 @@ trait system to overload operators. Calling functions is no different. We have\n three separate traits to overload with:\n \n ```rust\n+# #![feature(unboxed_closures)]\n # mod foo {\n pub trait Fn<Args> : FnMut<Args> {\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n@@ -291,9 +292,9 @@ isn\u2019t interesting. The next part is:\n #   some_closure(1) }\n ```\n \n-Because `Fn` is a trait, we can bound our generic with it. In this case, our\n-closure takes a `i32` as an argument and returns an `i32`, and so the generic\n-bound we use is `Fn(i32) -> i32`.\n+Because `Fn` is a trait, we can use it as a bound for our generic type. In\n+this case, our closure takes a `i32` as an argument and returns an `i32`, and\n+so the generic bound we use is `Fn(i32) -> i32`.\n \n There\u2019s one other key point here: because we\u2019re bounding a generic with a\n trait, this will get monomorphized, and therefore, we\u2019ll be doing static"}, {"sha": "ca104ff29ace3377c7ccb9efb5d53b7c350963a8", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 63, "deletions": 10, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -575,16 +575,69 @@ against `libc` and `libm` by default.\n \n # The \"nullable pointer optimization\"\n \n-Certain types are defined to not be NULL. This includes references (`&T`,\n-`&mut T`), boxes (`Box<T>`), and function pointers (`extern \"abi\" fn()`).\n-When interfacing with C, pointers that might be NULL are often used.\n-As a special case, a generic `enum` that contains exactly two variants, one of\n-which contains no data and the other containing a single field, is eligible\n-for the \"nullable pointer optimization\". When such an enum is instantiated\n-with one of the non-nullable types, it is represented as a single pointer,\n-and the non-data variant is represented as the NULL pointer. So\n-`Option<extern \"C\" fn(c_int) -> c_int>` is how one represents a nullable\n-function pointer using the C ABI.\n+Certain Rust types are defined to never be `null`. This includes references (`&T`,\n+`&mut T`), boxes (`Box<T>`), and function pointers (`extern \"abi\" fn()`). When\n+interfacing with C, pointers that might be `null` are often used, which would seem to\n+require some messy `transmute`s and/or unsafe code to handle conversions to/from Rust types.\n+However, the language provides a workaround.\n+\n+As a special case, an `enum` is eligible for the \"nullable pointer optimization\" if it contains\n+exactly two variants, one of which contains no data and the other contains a field of one of the\n+non-nullable types listed above.  This means no extra space is required for a discriminant; rather,\n+the empty variant is represented by putting a `null` value into the non-nullable field. This is\n+called an \"optimization\", but unlike other optimizations it is guaranteed to apply to eligible\n+types.\n+\n+The most common type that takes advantage of the nullable pointer optimization is `Option<T>`,\n+where `None` corresponds to `null`. So `Option<extern \"C\" fn(c_int) -> c_int>` is a correct way\n+to represent a nullable function pointer using the C ABI (corresponding to the C type\n+`int (*)(int)`).\n+\n+Here is a contrived example. Let's say some C library has a facility for registering a\n+callback, which gets called in certain situations. The callback is passed a function pointer\n+and an integer and it is supposed to run the function with the integer as a parameter. So\n+we have function pointers flying across the FFI boundary in both directions.\n+\n+```rust\n+# #![feature(libc)]\n+extern crate libc;\n+use libc::c_int;\n+\n+# #[cfg(hidden)]\n+extern \"C\" {\n+    /// Register the callback.\n+    fn register(cb: Option<extern \"C\" fn(Option<extern \"C\" fn(c_int) -> c_int>, c_int) -> c_int>);\n+}\n+# unsafe fn register(_: Option<extern \"C\" fn(Option<extern \"C\" fn(c_int) -> c_int>,\n+#                                            c_int) -> c_int>)\n+# {}\n+\n+/// This fairly useless function receives a function pointer and an integer\n+/// from C, and returns the result of calling the function with the integer.\n+/// In case no function is provided, it squares the integer by default.\n+extern \"C\" fn apply(process: Option<extern \"C\" fn(c_int) -> c_int>, int: c_int) -> c_int {\n+    match process {\n+        Some(f) => f(int),\n+        None    => int * int\n+    }\n+}\n+\n+fn main() {\n+    unsafe {\n+        register(Some(apply));\n+    }\n+}\n+```\n+\n+And the code on the C side looks like this:\n+\n+```c\n+void register(void (*f)(void (*)(int), int)) {\n+    ...\n+}\n+```\n+\n+No `transmute` required!\n \n # Calling Rust code from C\n "}, {"sha": "22cf6068e4d5a20f79fa61075ed31fa23e10b5b8", "filename": "src/doc/book/guessing-game.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fguessing-game.md?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -365,7 +365,7 @@ numbers. A bare number like above is actually shorthand for `^0.3.0`,\n meaning \"anything compatible with 0.3.0\".\n If we wanted to use only `0.3.0` exactly, we could say `rand=\"=0.3.0\"`\n (note the two equal signs).\n-And if we wanted to use the latest version we could use `*`.\n+And if we wanted to use the latest version we could use `rand=\"*\"`.\n We could also use a range of versions.\n [Cargo\u2019s documentation][cargodoc] contains more details.\n "}, {"sha": "62e196a7ccdf3a4772db6e8ba86c5808241a6e2f", "filename": "src/doc/book/inline-assembly.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Finline-assembly.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Finline-assembly.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Finline-assembly.md?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -60,6 +60,8 @@ asm!(\"xor %eax, %eax\"\n     : \"eax\"\n    );\n # } }\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn main() {}\n ```\n \n Whitespace also doesn't matter:\n@@ -70,6 +72,8 @@ Whitespace also doesn't matter:\n # fn main() { unsafe {\n asm!(\"xor %eax, %eax\" ::: \"eax\");\n # } }\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn main() {}\n ```\n \n ## Operands\n@@ -129,6 +133,8 @@ stay valid.\n // Put the value 0x200 in eax\n asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n # } }\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn main() {}\n ```\n \n Input and output registers need not be listed since that information\n@@ -164,6 +170,8 @@ unsafe {\n }\n println!(\"eax is currently {}\", result);\n # }\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn main() {}\n ```\n \n ## More Information"}, {"sha": "72a3c08225d035866f8269f273b4a00839492295", "filename": "src/doc/book/lang-items.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flang-items.md?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -15,7 +15,7 @@ For example, `Box` pointers require two lang items, one for allocation\n and one for deallocation. A freestanding program that uses the `Box`\n sugar for dynamic allocations via `malloc` and `free`:\n \n-```rust\n+```rust,ignore\n #![feature(lang_items, box_syntax, start, libc)]\n #![no_std]\n "}, {"sha": "e4cb861d3b0f5299243fbd22f22a66ac91561dc3", "filename": "src/doc/book/loops.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Floops.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Floops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Floops.md?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -105,19 +105,19 @@ When you need to keep track of how many times you already looped, you can use th\n #### On ranges:\n \n ```rust\n-for (i, j) in (5..10).enumerate() {\n-    println!(\"i = {} and j = {}\", i, j);\n+for (index, value) in (5..10).enumerate() {\n+    println!(\"index = {} and value = {}\", index, value);\n }\n ```\n \n Outputs:\n \n ```text\n-i = 0 and j = 5\n-i = 1 and j = 6\n-i = 2 and j = 7\n-i = 3 and j = 8\n-i = 4 and j = 9\n+index = 0 and value = 5\n+index = 1 and value = 6\n+index = 2 and value = 7\n+index = 3 and value = 8\n+index = 4 and value = 9\n ```\n \n Don't forget to add the parentheses around the range."}, {"sha": "0259db221b6bc0dbaa0a47c94e7386eec91d22a3", "filename": "src/doc/book/syntax-index.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsyntax-index.md?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -94,7 +94,7 @@\n * `|` (`|\u2026| expr`): closures.  See [Closures].\n * `|=` (`var |= expr`): bitwise or & assignment. Overloadable (`BitOrAssign`).\n * `||` (`expr || expr`): logical or.\n-* `_`: \"ignored\" pattern binding.  See [Patterns (Ignoring bindings)].\n+* `_`: \"ignored\" pattern binding (see [Patterns (Ignoring bindings)]). Also used to make integer-literals readable (see [Reference (Integer literals)]).\n \n ## Other Syntax\n \n@@ -231,6 +231,7 @@\n [Primitive Types (Tuples)]: primitive-types.html#tuples\n [Raw Pointers]: raw-pointers.html\n [Reference (Byte String Literals)]: ../reference.html#byte-string-literals\n+[Reference (Integer literals)]: ../reference.html#integer-literals\n [Reference (Raw Byte String Literals)]: ../reference.html#raw-byte-string-literals\n [Reference (Raw String Literals)]: ../reference.html#raw-string-literals\n [References and Borrowing]: references-and-borrowing.html"}, {"sha": "aee45299cf22d77369fde008fc9b2cba292f7058", "filename": "src/doc/book/the-stack-and-the-heap.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fthe-stack-and-the-heap.md?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -26,6 +26,8 @@ The stack is very fast, and is where memory is allocated in Rust by default.\n But the allocation is local to a function call, and is limited in size. The\n heap, on the other hand, is slower, and is explicitly allocated by your\n program. But it\u2019s effectively unlimited in size, and is globally accessible.\n+Note this meaning of heap, which allocates arbitrary-sized blocks of memory in arbitrary\n+order, is quite different from the heap data structure.  \n \n # The Stack\n "}, {"sha": "b1aee579aabc26ae560c72e7187532fc0fd95c00", "filename": "src/doc/book/trait-objects.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fbook%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftrait-objects.md?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -123,7 +123,6 @@ dispatch with trait objects by casting:\n # trait Foo { fn method(&self) -> String; }\n # impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n # impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n-\n fn do_something(x: &Foo) {\n     x.method();\n }\n@@ -140,7 +139,6 @@ or by coercing:\n # trait Foo { fn method(&self) -> String; }\n # impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n # impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n-\n fn do_something(x: &Foo) {\n     x.method();\n }"}, {"sha": "189695716deb1bb776f46aee347699529bcd42c4", "filename": "src/doc/nomicon/phantom-data.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fnomicon%2Fphantom-data.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Fnomicon%2Fphantom-data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fphantom-data.md?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -50,7 +50,7 @@ struct Vec<T> {\n }\n ```\n \n-Unlike the previous example it *appears* that everything is exactly as we\n+Unlike the previous example, it *appears* that everything is exactly as we\n want. Every generic argument to Vec shows up in at least one field.\n Good to go!\n \n@@ -84,4 +84,3 @@ standard library made a utility for itself called `Unique<T>` which:\n * includes a `PhantomData<T>`\n * auto-derives Send/Sync as if T was contained\n * marks the pointer as NonZero for the null-pointer optimization\n-"}, {"sha": "f4ffe5774d27cd0f3dd121f42bb89255e0e11da6", "filename": "src/doc/reference.md", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -1653,14 +1653,43 @@ the Rust ABI and the foreign ABI.\n A number of [attributes](#ffi-attributes) control the behavior of external blocks.\n \n By default external blocks assume that the library they are calling uses the\n-standard C \"cdecl\" ABI. Other ABIs may be specified using an `abi` string, as\n-shown here:\n+standard C ABI on the specific platform. Other ABIs may be specified using an\n+`abi` string, as shown here:\n \n ```ignore\n // Interface to the Windows API\n extern \"stdcall\" { }\n ```\n \n+There are three ABI strings which are cross-platform, and which all compilers\n+are guaranteed to support:\n+\n+* `extern \"Rust\"` -- The default ABI when you write a normal `fn foo()` in any\n+  Rust code.\n+* `extern \"C\"` -- This is the same as `extern fn foo()`; whatever the default\n+  your C compiler supports.\n+* `extern \"system\"` -- Usually the same as `extern \"C\"`, except on Win32, in\n+  which case it's `\"stdcall\"`, or what you should use to link to the Windows API\n+  itself\n+\n+There are also some platform-specific ABI strings:\n+\n+* `extern \"cdecl\"` -- The default for x86\\_32 C code.\n+* `extern \"stdcall\"` -- The default for the Win32 API on x86\\_32.\n+* `extern \"win64\"` -- The default for C code on x86\\_64 Windows.\n+* `extern \"aapcs\"` -- The default for ARM.\n+* `extern \"fastcall\"` -- The `fastcall` ABI -- corresponds to MSVC's\n+  `__fastcall` and GCC and clang's `__attribute__((fastcall))`\n+* `extern \"vectorcall\"` -- The `vectorcall` ABI -- corresponds to MSVC's\n+  `__vectorcall` and clang's `__attribute__((vectorcall))`\n+\n+Finally, there are some rustc-specific ABI strings:\n+\n+* `extern \"rust-intrinsic\"` -- The ABI of rustc intrinsics.\n+* `extern \"rust-call\"` -- The ABI of the Fn::call trait functions.\n+* `extern \"platform-intrinsic\"` -- Specific platform intrinsics -- like, for\n+  example, `sqrt` -- have this ABI. You should never have to deal with it.\n+\n The `link` attribute allows the name of the library to be specified. When\n specified the compiler will attempt to link against the native library of the\n specified name.\n@@ -3020,7 +3049,8 @@ as\n == != < > <= >=\n &&\n ||\n-= ..\n+.. ...\n+=\n ```\n \n Operators at the same precedence level are evaluated left-to-right. [Unary"}, {"sha": "83d54789ff3572a12b8ec6ae4ade1c6fa9d638a0", "filename": "src/etc/Dockerfile", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fetc%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fetc%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2FDockerfile?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -23,11 +23,5 @@ RUN apt-get update && apt-get -y install \\\n     libedit-dev zlib1g-dev \\\n     llvm-3.7-tools cmake\n \n-# When we compile compiler-rt we pass it the llvm-config we just installed on\n-# the system, but unfortunately it doesn't infer correctly where\n-# LLVMConfig.cmake is so we need to coerce it a bit...\n-RUN mkdir -p /usr/lib/llvm-3.7/build/share/llvm\n-RUN ln -s /usr/share/llvm-3.7/cmake /usr/lib/llvm-3.7/build/share/llvm/cmake\n-\n RUN mkdir /build\n WORKDIR /build"}, {"sha": "3566d143529be9135a6ce18f80e3b7ba8bb08fe2", "filename": "src/etc/char_private.py", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fetc%2Fchar_private.py", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fetc%2Fchar_private.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fchar_private.py?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -0,0 +1,154 @@\n+#!/usr/bin/env python\n+#\n+# Copyright 2011-2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# This script uses the following Unicode tables:\n+# - Categories.txt\n+\n+import os\n+import subprocess\n+\n+def to_ranges(iter):\n+    current = None\n+    for i in iter:\n+        if current is None or i != current[1] or i in (0x10000, 0x20000):\n+            if current is not None:\n+                yield tuple(current)\n+            current = [i, i + 1]\n+        else:\n+            current[1] += 1\n+    if current is not None:\n+        yield tuple(current)\n+\n+def get_escaped(dictionary):\n+    for i in range(0x110000):\n+        if dictionary.get(i, \"Cn\") in \"Cc Cf Cs Co Cn Zl Zp Zs\".split() and i != ord(' '):\n+            yield i\n+\n+def get_file(f):\n+    try:\n+        return open(os.path.basename(f))\n+    except FileNotFoundError:\n+        subprocess.run([\"curl\", \"-O\", f], check=True)\n+        return open(os.path.basename(f))\n+\n+def main():\n+    file = get_file(\"http://www.unicode.org/notes/tn36/Categories.txt\")\n+\n+    dictionary = {int(line.split()[0], 16): line.split()[1] for line in file}\n+\n+    CUTOFF=0x10000\n+    singletons0 = []\n+    singletons1 = []\n+    normal0 = []\n+    normal1 = []\n+    extra = []\n+\n+    for a, b in to_ranges(get_escaped(dictionary)):\n+        if a > 2 * CUTOFF:\n+            extra.append((a, b - a))\n+        elif a == b - 1:\n+            if a & CUTOFF:\n+                singletons1.append(a & ~CUTOFF)\n+            else:\n+                singletons0.append(a)\n+        elif a == b - 2:\n+            if a & CUTOFF:\n+                singletons1.append(a & ~CUTOFF)\n+                singletons1.append((a + 1) & ~CUTOFF)\n+            else:\n+                singletons0.append(a)\n+                singletons0.append(a + 1)\n+        else:\n+            if a >= 2 * CUTOFF:\n+                extra.append((a, b - a))\n+            elif a & CUTOFF:\n+                normal1.append((a & ~CUTOFF, b - a))\n+            else:\n+                normal0.append((a, b - a))\n+\n+    print(\"\"\"\\\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// NOTE: The following code was generated by \"src/etc/char_private.py\",\n+//       do not edit directly!\n+\n+use slice::SliceExt;\n+\n+fn check(x: u16, singletons: &[u16], normal: &[u16]) -> bool {\n+    for &s in singletons {\n+        if x == s {\n+            return false;\n+        } else if x < s {\n+            break;\n+        }\n+    }\n+    for w in normal.chunks(2) {\n+        let start = w[0];\n+        let len = w[1];\n+        let difference = (x as i32) - (start as i32);\n+        if 0 <= difference {\n+            if difference < len as i32 {\n+                return false;\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+    true\n+}\n+\n+pub fn is_printable(x: char) -> bool {\n+    let x = x as u32;\n+    let lower = x as u16;\n+    if x < 0x10000 {\n+        check(lower, SINGLETONS0, NORMAL0)\n+    } else if x < 0x20000 {\n+        check(lower, SINGLETONS1, NORMAL1)\n+    } else {\\\n+\"\"\")\n+    for a, b in extra:\n+        print(\"        if 0x{:x} <= x && x < 0x{:x} {{\".format(a, a + b))\n+        print(\"            return false;\")\n+        print(\"        }\")\n+    print(\"\"\"\\\n+        true\n+    }\n+}\\\n+\"\"\")\n+    print()\n+    print(\"const SINGLETONS0: &'static [u16] = &[\")\n+    for s in singletons0:\n+        print(\"    0x{:x},\".format(s))\n+    print(\"];\")\n+    print(\"const SINGLETONS1: &'static [u16] = &[\")\n+    for s in singletons1:\n+        print(\"    0x{:x},\".format(s))\n+    print(\"];\")\n+    print(\"const NORMAL0: &'static [u16] = &[\")\n+    for a, b in normal0:\n+        print(\"    0x{:x}, 0x{:x},\".format(a, b))\n+    print(\"];\")\n+    print(\"const NORMAL1: &'static [u16] = &[\")\n+    for a, b in normal1:\n+        print(\"    0x{:x}, 0x{:x},\".format(a, b))\n+    print(\"];\")\n+\n+if __name__ == '__main__':\n+    main()"}, {"sha": "f5f39d264a6b0a2f1cb7704aacabbbfc721522d9", "filename": "src/etc/local_stage0.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fetc%2Flocal_stage0.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fetc%2Flocal_stage0.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flocal_stage0.sh?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -58,6 +58,7 @@ case \"$TARG_DIR\" in\n \n cp ${PREFIX}/bin/rustc${BIN_SUF} ${TARG_DIR}/stage0/bin/\n cp ${PREFIX}/${LIB_DIR}/${RUSTLIBDIR}/${TARG_DIR}/${LIB_DIR}/* ${TARG_DIR}/stage0/${LIB_DIR}/\n+cp ${PREFIX}/${LIB_DIR}/${LIB_PREFIX}arena*${LIB_SUF} ${TARG_DIR}/stage0/${LIB_DIR}/\n cp ${PREFIX}/${LIB_DIR}/${LIB_PREFIX}extra*${LIB_SUF} ${TARG_DIR}/stage0/${LIB_DIR}/\n cp ${PREFIX}/${LIB_DIR}/${LIB_PREFIX}rust*${LIB_SUF} ${TARG_DIR}/stage0/${LIB_DIR}/\n cp ${PREFIX}/${LIB_DIR}/${LIB_PREFIX}std*${LIB_SUF} ${TARG_DIR}/stage0/${LIB_DIR}/"}, {"sha": "24b007576aa24ad673a6687d246400f0dd16b459", "filename": "src/etc/mklldeps.py", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fetc%2Fmklldeps.py", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fetc%2Fmklldeps.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmklldeps.py?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -77,6 +77,13 @@ def runErr(args):\n         lib = lib.strip()[2:]\n     elif lib[0] == '-':\n         lib = lib.strip()[1:]\n+    # If this actually points at a literal file then we're on MSVC which now\n+    # prints full paths, so get just the name of the library and strip off the\n+    # trailing \".lib\"\n+    elif os.path.exists(lib):\n+        lib = os.path.basename(lib)[:-4]\n+    elif lib[-4:] == '.lib':\n+        lib = lib[:-4]\n     f.write(\"#[link(name = \\\"\" + lib + \"\\\"\")\n     if not llvm_shared and 'LLVM' in lib:\n         f.write(\", kind = \\\"static\\\"\")"}, {"sha": "64b780413f884f4a33045525a98d83717d6053e5", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -21,6 +21,10 @@\n //!\n //! Sharing some immutable data between threads:\n //!\n+// Note that we **do not** run these tests here. The windows builders get super\n+// unhappy of a thread outlives the main thread and then exits at the same time\n+// (something deadlocks) so we just avoid this entirely by not running these\n+// tests.\n //! ```no_run\n //! use std::sync::Arc;\n //! use std::thread;\n@@ -97,7 +101,8 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// by putting it inside `Mutex` and then share `Mutex` immutably\n /// with `Arc<T>` as shown below.\n ///\n-/// ```\n+// See comment at the top of this file for why the test is no_run\n+/// ```no_run\n /// use std::sync::{Arc, Mutex};\n /// use std::thread;\n ///"}, {"sha": "25b3c8a3a0a8355a89888a305ddb9c373cd04f05", "filename": "src/liballoc_jemalloc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fliballoc_jemalloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fliballoc_jemalloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2FCargo.toml?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -16,7 +16,7 @@ libc = { path = \"../rustc/libc_shim\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-gcc = \"0.3.17\"\n+gcc = \"0.3.27\"\n \n [features]\n debug = []"}, {"sha": "dc1b8d6ea983509ef7b91dfb2f9867552e718f20", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -73,7 +73,16 @@ fn main() {\n                    .replace(\"\\\\\", \"/\"))\n        .current_dir(&build_dir)\n        .env(\"CC\", compiler.path())\n-       .env(\"EXTRA_CFLAGS\", cflags)\n+       .env(\"EXTRA_CFLAGS\", cflags.clone())\n+       // jemalloc generates Makefile deps using GCC's \"-MM\" flag. This means\n+       // that GCC will run the preprocessor, and only the preprocessor, over\n+       // jemalloc's source files. If we don't specify CPPFLAGS, then at least\n+       // on ARM that step fails with a \"Missing implementation for 32-bit\n+       // atomic operations\" error. This is because no \"-march\" flag will be\n+       // passed to GCC, and then GCC won't define the\n+       // \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\" macro that jemalloc needs to\n+       // select an atomic operation implementation.\n+       .env(\"CPPFLAGS\", cflags.clone())\n        .env(\"AR\", &ar)\n        .env(\"RANLIB\", format!(\"{} s\", ar.display()));\n "}, {"sha": "c3a7d4023754aac97d45a0539a9cf0e4a8cfe490", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 222, "deletions": 2, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -313,6 +313,10 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n+/// This enum is constructed from the [`entry`] method on [`BTreeMap`].\n+///\n+/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`entry`]: struct.BTreeMap.html#method.entry\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// A vacant Entry\n@@ -326,7 +330,23 @@ pub enum Entry<'a, K: 'a, V: 'a> {\n              OccupiedEntry<'a, K, V>),\n }\n \n-/// A vacant Entry.\n+#[stable(feature= \"debug_btree_map\", since = \"1.12.0\")]\n+impl<'a, K: 'a + Debug + Ord, V: 'a + Debug> Debug for Entry<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Vacant(ref v) => f.debug_tuple(\"Entry\")\n+                              .field(v)\n+                              .finish(),\n+            Occupied(ref o) => f.debug_tuple(\"Entry\")\n+                                .field(o)\n+                                .finish(),\n+        }\n+    }\n+}\n+\n+/// A vacant Entry. It is part of the [`Entry`] enum.\n+///\n+/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     key: K,\n@@ -337,7 +357,18 @@ pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     _marker: PhantomData<&'a mut (K, V)>,\n }\n \n-/// An occupied Entry.\n+#[stable(feature= \"debug_btree_map\", since = \"1.12.0\")]\n+impl<'a, K: 'a + Debug + Ord, V: 'a> Debug for VacantEntry<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"VacantEntry\")\n+         .field(self.key())\n+         .finish()\n+    }\n+}\n+\n+/// An occupied Entry. It is part of the [`Entry`] enum.\n+///\n+/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n@@ -348,6 +379,16 @@ pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     _marker: PhantomData<&'a mut (K, V)>,\n }\n \n+#[stable(feature= \"debug_btree_map\", since = \"1.12.0\")]\n+impl<'a, K: 'a + Debug + Ord, V: 'a + Debug> Debug for OccupiedEntry<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"OccupiedEntry\")\n+         .field(\"key\", self.key())\n+         .field(\"value\", self.get())\n+         .finish()\n+    }\n+}\n+\n // An iterator for merging two sorted sequences into one\n struct MergeIter<K, V, I: Iterator<Item = (K, V)>> {\n     left: Peekable<I>,\n@@ -1857,6 +1898,17 @@ impl<K, V> BTreeMap<K, V> {\n impl<'a, K: Ord, V> Entry<'a, K, V> {\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_insert(self, default: V) -> &'a mut V {\n         match self {\n@@ -1867,6 +1919,19 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n \n     /// Ensures a value is in the entry by inserting the result of the default function if empty,\n     /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n+    /// let s = \"hoho\".to_owned();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with(|| s);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_owned());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n         match self {\n@@ -1876,6 +1941,15 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     }\n \n     /// Returns a reference to this entry's key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         match *self {\n@@ -1888,19 +1962,58 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Gets a reference to the key that would be used when inserting a value\n     /// through the VacantEntry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         &self.key\n     }\n \n     /// Take ownership of the key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_recover_keys)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n+    ///     v.into_key();\n+    /// }\n+    /// ```\n     #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n     pub fn into_key(self) -> K {\n         self.key\n     }\n \n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// // count the number of occurrences of letters in the vec\n+    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"] {\n+    ///     *count.entry(x).or_insert(0) += 1;\n+    /// }\n+    ///\n+    /// assert_eq!(count[\"a\"], 3);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         *self.length += 1;\n@@ -1946,43 +2059,150 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         self.handle.reborrow().into_kv().0\n     }\n \n     /// Take ownership of the key and value from the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_recover_keys)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     // We delete the entry from the map.\n+    ///     o.remove_pair();\n+    /// }\n+    ///\n+    /// // If now try to get the value, it will panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n     #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n     pub fn remove_pair(self) -> (K, V) {\n         self.remove_kv()\n     }\n \n     /// Gets a reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.get(), &12);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n         self.handle.reborrow().into_kv().1\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///      *o.get_mut() += 10;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.handle.kv_mut().1\n     }\n \n     /// Converts the entry into a mutable reference to its value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     *o.into_mut() += 10;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.handle.into_kv_mut().1\n     }\n \n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.insert(15), 12);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 15);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: V) -> V {\n         mem::replace(self.get_mut(), value)\n     }\n \n     /// Takes the value of the entry out of the map, and returns it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.remove(), 12);\n+    /// }\n+    /// // If we try to get \"poneyland\"'s value, it'll panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n         self.remove_kv().1"}, {"sha": "be0ef85d6b114aad2c2c975774bc209af7311fac", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -409,8 +409,8 @@\n //! ## Precision\n //!\n //! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n-//! longer than this width, then it is truncated down to this many characters and only those are\n-//! emitted.\n+//! longer than this width, then it is truncated down to this many characters and that truncated\n+//! value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n //!\n //! For integral types, this is ignored.\n //!\n@@ -434,49 +434,45 @@\n //!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n //!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n //!\n-//! For example, these:\n+//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n //!\n //! ```\n-//! // Hello {arg 0 (x)} is {arg 1 (0.01) with precision specified inline (5)}\n+//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n //! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n //!\n-//! // Hello {arg 1 (x)} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n+//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n //! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n //!\n-//! // Hello {arg 0 (x)} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n+//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n //! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n //!\n-//! // Hello {next arg (x)} is {second of next two args (0.01) with precision\n+//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n //! //                          specified in first of next two args (5)}\n //! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n //!\n-//! // Hello {next arg (x)} is {arg 2 (0.01) with precision\n+//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n //! //                          specified in its predecessor (5)}\n //! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n //!\n-//! // Hello {next arg (x)} is {arg \"number\" (0.01) with precision specified\n+//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n //! //                          in arg \"prec\" (5)}\n //! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n //! ```\n //!\n-//! All print the same thing:\n-//!\n-//! ```text\n-//! Hello x is 0.01000\n-//! ```\n-//!\n //! While these:\n //!\n //! ```\n //! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n //! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n+//! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n //! ```\n //!\n //! print two significantly different things:\n //!\n //! ```text\n //! Hello, `1234.560` has 3 fractional digits\n //! Hello, `123` has 3 characters\n+//! Hello, `     123` has 3 right-aligned characters\n //! ```\n //!\n //! # Escaping"}, {"sha": "21387a1aa95543031fa403d3893c2a102f9afed1", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -33,6 +33,7 @@\n #![feature(allow_internal_unstable)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![cfg_attr(not(test), feature(char_escape_debug))]\n #![feature(core_intrinsics)]\n #![feature(dropck_parametricity)]\n #![feature(fmt_internals)]\n@@ -48,7 +49,6 @@\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(step_by)]\n-#![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag)]"}, {"sha": "6842f02e0e19b1732d3ded4cc9a169f09c46b5c0", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 79, "deletions": 20, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -172,6 +172,14 @@ impl<T> Default for LinkedList<T> {\n \n impl<T> LinkedList<T> {\n     /// Creates an empty `LinkedList`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let list: LinkedList<u32> = LinkedList::new();\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Self {\n@@ -195,19 +203,22 @@ impl<T> LinkedList<T> {\n     /// ```\n     /// use std::collections::LinkedList;\n     ///\n-    /// let mut a = LinkedList::new();\n-    /// let mut b = LinkedList::new();\n-    /// a.push_back(1);\n-    /// a.push_back(2);\n-    /// b.push_back(3);\n-    /// b.push_back(4);\n+    /// let mut list1 = LinkedList::new();\n+    /// list1.push_back('a');\n     ///\n-    /// a.append(&mut b);\n+    /// let mut list2 = LinkedList::new();\n+    /// list2.push_back('b');\n+    /// list2.push_back('c');\n     ///\n-    /// for e in &a {\n-    ///     println!(\"{}\", e); // prints 1, then 2, then 3, then 4\n-    /// }\n-    /// println!(\"{}\", b.len()); // prints 0\n+    /// list1.append(&mut list2);\n+    ///\n+    /// let mut iter = list1.iter();\n+    /// assert_eq!(iter.next(), Some(&'a'));\n+    /// assert_eq!(iter.next(), Some(&'b'));\n+    /// assert_eq!(iter.next(), Some(&'c'));\n+    /// assert!(iter.next().is_none());\n+    ///\n+    /// assert!(list2.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n@@ -226,6 +237,24 @@ impl<T> LinkedList<T> {\n     }\n \n     /// Provides a forward iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut list: LinkedList<u32> = LinkedList::new();\n+    ///\n+    /// list.push_back(0);\n+    /// list.push_back(1);\n+    /// list.push_back(2);\n+    ///\n+    /// let mut iter = list.iter();\n+    /// assert_eq!(iter.next(), Some(&0));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n@@ -238,6 +267,28 @@ impl<T> LinkedList<T> {\n     }\n \n     /// Provides a forward iterator with mutable references.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut list: LinkedList<u32> = LinkedList::new();\n+    ///\n+    /// list.push_back(0);\n+    /// list.push_back(1);\n+    /// list.push_back(2);\n+    ///\n+    /// for element in list.iter_mut() {\n+    ///     *element += 10;\n+    /// }\n+    ///\n+    /// let mut iter = list.iter();\n+    /// assert_eq!(iter.next(), Some(&10));\n+    /// assert_eq!(iter.next(), Some(&11));\n+    /// assert_eq!(iter.next(), Some(&12));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n@@ -289,7 +340,6 @@ impl<T> LinkedList<T> {\n     ///\n     /// dl.push_back(3);\n     /// assert_eq!(dl.len(), 3);\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -316,7 +366,6 @@ impl<T> LinkedList<T> {\n     /// dl.clear();\n     /// assert_eq!(dl.len(), 0);\n     /// assert_eq!(dl.front(), None);\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -326,6 +375,23 @@ impl<T> LinkedList<T> {\n \n     /// Returns `true` if the `LinkedList` contains an element equal to the\n     /// given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(linked_list_contains)]\n+    ///\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut list: LinkedList<u32> = LinkedList::new();\n+    ///\n+    /// list.push_back(0);\n+    /// list.push_back(1);\n+    /// list.push_back(2);\n+    ///\n+    /// assert_eq!(list.contains(&0), true);\n+    /// assert_eq!(list.contains(&10), false);\n+    /// ```\n     #[unstable(feature = \"linked_list_contains\", reason = \"recently added\",\n                issue = \"32630\")]\n     pub fn contains(&self, x: &T) -> bool\n@@ -347,7 +413,6 @@ impl<T> LinkedList<T> {\n     ///\n     /// dl.push_front(1);\n     /// assert_eq!(dl.front(), Some(&1));\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -374,7 +439,6 @@ impl<T> LinkedList<T> {\n     ///     Some(x) => *x = 5,\n     /// }\n     /// assert_eq!(dl.front(), Some(&5));\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -395,7 +459,6 @@ impl<T> LinkedList<T> {\n     ///\n     /// dl.push_back(1);\n     /// assert_eq!(dl.back(), Some(&1));\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -422,7 +485,6 @@ impl<T> LinkedList<T> {\n     ///     Some(x) => *x = 5,\n     /// }\n     /// assert_eq!(dl.back(), Some(&5));\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -446,7 +508,6 @@ impl<T> LinkedList<T> {\n     ///\n     /// dl.push_front(1);\n     /// assert_eq!(dl.front().unwrap(), &1);\n-    ///\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, elt: T) {\n@@ -471,9 +532,7 @@ impl<T> LinkedList<T> {\n     /// assert_eq!(d.pop_front(), Some(3));\n     /// assert_eq!(d.pop_front(), Some(1));\n     /// assert_eq!(d.pop_front(), None);\n-    ///\n     /// ```\n-    ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n         self.pop_front_node().map(Node::into_element)"}, {"sha": "1badc72aed07c1a9d21eab781c59fd6ef5fed9f9", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -23,13 +23,45 @@ pub trait RangeArgument<T> {\n     /// Start index (inclusive)\n     ///\n     /// Return start value if present, else `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collections)]\n+    /// #![feature(collections_range)]\n+    ///\n+    /// extern crate collections;\n+    ///\n+    /// # fn main() {\n+    /// use collections::range::RangeArgument;\n+    ///\n+    /// assert_eq!((..10).start(), None);\n+    /// assert_eq!((3..10).start(), Some(&3));\n+    /// # }\n+    /// ```\n     fn start(&self) -> Option<&T> {\n         None\n     }\n \n     /// End index (exclusive)\n     ///\n     /// Return end value if present, else `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collections)]\n+    /// #![feature(collections_range)]\n+    ///\n+    /// extern crate collections;\n+    ///\n+    /// # fn main() {\n+    /// use collections::range::RangeArgument;\n+    ///\n+    /// assert_eq!((3..).end(), None);\n+    /// assert_eq!((3..10).end(), Some(&10));\n+    /// # }\n+    /// ```\n     fn end(&self) -> Option<&T> {\n         None\n     }"}, {"sha": "ff2b8cdea22789076a31416392827ecfee6ba742", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 52, "deletions": 22, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -544,14 +544,21 @@ impl<T> [T] {\n     ///\n     /// # Example\n     ///\n-    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n-    /// `[3,4]`):\n+    /// ```\n+    /// let slice = ['r', 'u', 's', 't'];\n+    /// let mut iter = slice.windows(2);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'u']);\n+    /// assert_eq!(iter.next().unwrap(), &['u', 's']);\n+    /// assert_eq!(iter.next().unwrap(), &['s', 't']);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n     ///\n-    /// ```rust\n-    /// let v = &[1, 2, 3, 4];\n-    /// for win in v.windows(2) {\n-    ///     println!(\"{:?}\", win);\n-    /// }\n+    /// If the slice is shorter than `size`:\n+    ///\n+    /// ```\n+    /// let slice = ['f', 'o', 'o'];\n+    /// let mut iter = slice.windows(4);\n+    /// assert!(iter.next().is_none());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -570,15 +577,13 @@ impl<T> [T] {\n     ///\n     /// # Example\n     ///\n-    /// Print the slice two elements at a time (i.e. `[1,2]`,\n-    /// `[3,4]`, `[5]`):\n-    ///\n-    /// ```rust\n-    /// let v = &[1, 2, 3, 4, 5];\n-    ///\n-    /// for chunk in v.chunks(2) {\n-    ///     println!(\"{:?}\", chunk);\n-    /// }\n+    /// ```\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.chunks(2);\n+    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n+    /// assert_eq!(iter.next().unwrap(), &['m']);\n+    /// assert!(iter.next().is_none());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -684,15 +689,40 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// Print the slice split by numbers divisible by 3 (i.e. `[10, 40]`,\n-    /// `[20]`, `[50]`):\n+    /// ```\n+    /// let slice = [10, 40, 33, 20];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n     ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n     /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n     ///\n-    /// for group in v.split(|num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n+    /// If the first element is matched, an empty slice will be the first item\n+    /// returned by the iterator. Similarly, if the last element in the slice\n+    /// is matched, an empty slice will be the last item returned by the\n+    /// iterator:\n+    ///\n+    /// ```\n+    /// let slice = [10, 40, 33];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n+    /// assert_eq!(iter.next().unwrap(), &[]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// If two matched elements are directly adjacent, an empty slice will be\n+    /// present between them:\n+    ///\n+    /// ```\n+    /// let slice = [10, 6, 33, 20];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10]);\n+    /// assert_eq!(iter.next().unwrap(), &[]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "4c64019de097ef8a7c2a5295df19c60681f8c2ef", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -1697,6 +1697,14 @@ impl str {\n         return s;\n     }\n \n+    /// Escapes each char in `s` with `char::escape_debug`.\n+    #[unstable(feature = \"str_escape\",\n+               reason = \"return type may change to be an iterator\",\n+               issue = \"27791\")]\n+    pub fn escape_debug(&self) -> String {\n+        self.chars().flat_map(|c| c.escape_debug()).collect()\n+    }\n+\n     /// Escapes each char in `s` with `char::escape_default`.\n     #[unstable(feature = \"str_escape\",\n                reason = \"return type may change to be an iterator\","}, {"sha": "06952253ef3b09540017a1211dccd8e75b21bfe5", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 88, "deletions": 10, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -59,7 +59,7 @@ use core::fmt;\n use core::hash;\n use core::iter::FromIterator;\n use core::mem;\n-use core::ops::{self, Add, Index, IndexMut};\n+use core::ops::{self, Add, AddAssign, Index, IndexMut};\n use core::ptr;\n use core::str::pattern::Pattern;\n use rustc_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n@@ -701,6 +701,12 @@ impl String {\n     /// Violating these may cause problems like corrupting the allocator's\n     /// internal datastructures.\n     ///\n+    /// The ownership of `ptr` is effectively transferred to the\n+    /// `String` which may then deallocate, reallocate or change the\n+    /// contents of memory pointed to by the pointer at will. Ensure\n+    /// that nothing else uses the pointer after calling this\n+    /// function.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1126,18 +1132,62 @@ impl String {\n         assert!(idx <= len);\n         assert!(self.is_char_boundary(idx));\n         let bits = ch.encode_utf8();\n-        let bits = bits.as_slice();\n-        let amt = bits.len();\n+\n+        unsafe {\n+            self.insert_bytes(idx, bits.as_slice());\n+        }\n+    }\n+\n+    unsafe fn insert_bytes(&mut self, idx: usize, bytes: &[u8]) {\n+        let len = self.len();\n+        let amt = bytes.len();\n         self.vec.reserve(amt);\n \n+        ptr::copy(self.vec.as_ptr().offset(idx as isize),\n+                  self.vec.as_mut_ptr().offset((idx + amt) as isize),\n+                  len - idx);\n+        ptr::copy(bytes.as_ptr(),\n+                  self.vec.as_mut_ptr().offset(idx as isize),\n+                  amt);\n+        self.vec.set_len(len + amt);\n+    }\n+\n+    /// Inserts a string into this `String` at a byte position.\n+    ///\n+    /// This is an `O(n)` operation as it requires copying every element in the\n+    /// buffer.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `idx` is larger than the `String`'s length, or if it does not\n+    /// lie on a [`char`] boundary.\n+    ///\n+    /// [`char`]: ../../std/primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(insert_str)]\n+    ///\n+    /// let mut s = String::from(\"bar\");\n+    ///\n+    /// s.insert_str(0, \"foo\");\n+    ///\n+    /// assert_eq!(\"foobar\", s);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"insert_str\",\n+               reason = \"recent addition\",\n+               issue = \"0\")]\n+    pub fn insert_str(&mut self, idx: usize, string: &str) {\n+        let len = self.len();\n+        assert!(idx <= len);\n+        assert!(self.is_char_boundary(idx));\n+\n         unsafe {\n-            ptr::copy(self.vec.as_ptr().offset(idx as isize),\n-                      self.vec.as_mut_ptr().offset((idx + amt) as isize),\n-                      len - idx);\n-            ptr::copy(bits.as_ptr(),\n-                      self.vec.as_mut_ptr().offset(idx as isize),\n-                      amt);\n-            self.vec.set_len(len + amt);\n+            self.insert_bytes(idx, string.as_bytes());\n         }\n     }\n \n@@ -1559,6 +1609,14 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n+#[stable(feature = \"stringaddassign\", since = \"1.12.0\")]\n+impl<'a> AddAssign<&'a str> for String {\n+    #[inline]\n+    fn add_assign(&mut self, other: &str) {\n+        self.push_str(other);\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::Range<usize>> for String {\n     type Output = str;\n@@ -1823,6 +1881,26 @@ impl Into<Vec<u8>> for String {\n     }\n }\n \n+#[stable(feature = \"stringfromchars\", since = \"1.12.0\")]\n+impl<'a> From<&'a [char]> for String {\n+    #[inline]\n+    fn from(v: &'a [char]) -> String {\n+        let mut s = String::with_capacity(v.len());\n+        for c in v {\n+            s.push(*c);\n+        }\n+        s\n+    }\n+}\n+\n+#[stable(feature = \"stringfromchars\", since = \"1.12.0\")]\n+impl From<Vec<char>> for String {\n+    #[inline]\n+    fn from(v: Vec<char>) -> String {\n+        String::from(v.as_slice())\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Write for String {\n     #[inline]"}, {"sha": "8b4fce158de4645d60b1557bde684283d0d21509", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 107, "deletions": 9, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -73,6 +73,7 @@ use core::mem;\n use core::ops::{Index, IndexMut};\n use core::ops;\n use core::ptr;\n+use core::ptr::Shared;\n use core::slice;\n \n use super::SpecExtend;\n@@ -342,12 +343,18 @@ impl<T> Vec<T> {\n     ///\n     /// * `ptr` needs to have been previously allocated via `String`/`Vec<T>`\n     ///   (at least, it's highly likely to be incorrect if it wasn't).\n-    /// * `length` needs to be the length that less than or equal to `capacity`.\n+    /// * `length` needs to be less than or equal to `capacity`.\n     /// * `capacity` needs to be the capacity that the pointer was allocated with.\n     ///\n     /// Violating these may cause problems like corrupting the allocator's\n     /// internal datastructures.\n     ///\n+    /// The ownership of `ptr` is effectively transferred to the\n+    /// `Vec<T>` which may then deallocate, reallocate or change the\n+    /// contents of memory pointed to by the pointer at will. Ensure\n+    /// that nothing else uses the pointer after calling this\n+    /// function.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -469,6 +476,25 @@ impl<T> Vec<T> {\n     /// Note that this will drop any excess capacity. Calling this and\n     /// converting back to a vector with `into_vec()` is equivalent to calling\n     /// `shrink_to_fit()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2, 3];\n+    ///\n+    /// let slice = v.into_boxed_slice();\n+    /// ```\n+    ///\n+    /// Any excess capacity is removed:\n+    ///\n+    /// ```\n+    /// let mut vec = Vec::with_capacity(10);\n+    /// vec.extend([1, 2, 3].iter().cloned());\n+    ///\n+    /// assert_eq!(vec.capacity(), 10);\n+    /// let slice = vec.into_boxed_slice();\n+    /// assert_eq!(slice.into_vec().capacity(), 3);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         unsafe {\n@@ -479,18 +505,45 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Shorten a vector to be `len` elements long, dropping excess elements.\n+    /// Shortens the vector, keeping the first `len` elements and dropping\n+    /// the rest.\n     ///\n     /// If `len` is greater than the vector's current length, this has no\n     /// effect.\n     ///\n+    /// The [`drain`] method can emulate `truncate`, but causes the excess\n+    /// elements to be returned instead of dropped.\n+    ///\n     /// # Examples\n     ///\n+    /// Truncating a five element vector to two elements:\n+    ///\n     /// ```\n     /// let mut vec = vec![1, 2, 3, 4, 5];\n     /// vec.truncate(2);\n     /// assert_eq!(vec, [1, 2]);\n     /// ```\n+    ///\n+    /// No truncation occurs when `len` is greater than the vector's current\n+    /// length:\n+    ///\n+    /// ```\n+    /// let mut vec = vec![1, 2, 3];\n+    /// vec.truncate(8);\n+    /// assert_eq!(vec, [1, 2, 3]);\n+    /// ```\n+    ///\n+    /// Truncating when `len == 0` is equivalent to calling the [`clear`]\n+    /// method.\n+    ///\n+    /// ```\n+    /// let mut vec = vec![1, 2, 3];\n+    /// vec.truncate(0);\n+    /// assert_eq!(vec, []);\n+    /// ```\n+    ///\n+    /// [`clear`]: #method.clear\n+    /// [`drain`]: #method.drain\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: usize) {\n         unsafe {\n@@ -508,6 +561,14 @@ impl<T> Vec<T> {\n     /// Extracts a slice containing the entire vector.\n     ///\n     /// Equivalent to `&s[..]`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{self, Write};\n+    /// let buffer = vec![1, 2, 3, 5, 8];\n+    /// io::sink().write(buffer.as_slice()).unwrap();\n+    /// ```\n     #[inline]\n     #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n     pub fn as_slice(&self) -> &[T] {\n@@ -517,6 +578,14 @@ impl<T> Vec<T> {\n     /// Extracts a mutable slice of the entire vector.\n     ///\n     /// Equivalent to `&mut s[..]`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{self, Read};\n+    /// let mut buffer = vec![0; 3];\n+    /// io::repeat(0b101).read_exact(buffer.as_mut_slice()).unwrap();\n+    /// ```\n     #[inline]\n     #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n@@ -532,9 +601,38 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![1, 2, 3, 4];\n+    /// use std::ptr;\n+    ///\n+    /// let mut vec = vec!['r', 'u', 's', 't'];\n+    ///\n+    /// unsafe {\n+    ///     ptr::drop_in_place(&mut vec[3]);\n+    ///     vec.set_len(3);\n+    /// }\n+    /// assert_eq!(vec, ['r', 'u', 's']);\n+    /// ```\n+    ///\n+    /// In this example, there is a memory leak since the memory locations\n+    /// owned by the inner vectors were not freed prior to the `set_len` call:\n+    ///\n+    /// ```\n+    /// let mut vec = vec![vec![1, 0, 0],\n+    ///                    vec![0, 1, 0],\n+    ///                    vec![0, 0, 1]];\n+    /// unsafe {\n+    ///     vec.set_len(0);\n+    /// }\n+    /// ```\n+    ///\n+    /// In this example, the vector gets expanded from zero to four items\n+    /// without any memory allocations occurring, resulting in vector\n+    /// values of unallocated memory:\n+    ///\n+    /// ```\n+    /// let mut vec: Vec<char> = Vec::new();\n+    ///\n     /// unsafe {\n-    ///     v.set_len(1);\n+    ///     vec.set_len(4);\n     /// }\n     /// ```\n     #[inline]\n@@ -821,8 +919,8 @@ impl<T> Vec<T> {\n             Drain {\n                 tail_start: end,\n                 tail_len: len - end,\n-                iter: range_slice.iter_mut(),\n-                vec: self as *mut _,\n+                iter: range_slice.iter(),\n+                vec: Shared::new(self as *mut _),\n             }\n         }\n     }\n@@ -1728,8 +1826,8 @@ pub struct Drain<'a, T: 'a> {\n     /// Length of tail\n     tail_len: usize,\n     /// Current remaining range to remove\n-    iter: slice::IterMut<'a, T>,\n-    vec: *mut Vec<T>,\n+    iter: slice::Iter<'a, T>,\n+    vec: Shared<Vec<T>>,\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n@@ -1767,7 +1865,7 @@ impl<'a, T> Drop for Drain<'a, T> {\n \n         if self.tail_len > 0 {\n             unsafe {\n-                let source_vec = &mut *self.vec;\n+                let source_vec = &mut **self.vec;\n                 // memmove back untouched tail, update to new length\n                 let start = source_vec.len();\n                 let tail = self.tail_start;"}, {"sha": "9c3792afa2f1c91b5e87e234f1258028d2dc5f30", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -365,12 +365,28 @@ impl<T> VecDeque<T> {\n \n impl<T> VecDeque<T> {\n     /// Creates an empty `VecDeque`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let vector: VecDeque<u32> = VecDeque::new();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> VecDeque<T> {\n         VecDeque::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty `VecDeque` with space for at least `n` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let vector: VecDeque<u32> = VecDeque::with_capacity(10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(n: usize) -> VecDeque<T> {\n         // +1 since the ringbuffer always leaves one space empty\n@@ -386,6 +402,8 @@ impl<T> VecDeque<T> {\n \n     /// Retrieves an element in the `VecDeque` by index.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -409,6 +427,8 @@ impl<T> VecDeque<T> {\n \n     /// Retrieves an element in the `VecDeque` mutably by index.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -440,6 +460,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// Fails if there is no element with either index.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -696,6 +718,25 @@ impl<T> VecDeque<T> {\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut vector: VecDeque<u32> = VecDeque::new();\n+    ///\n+    /// vector.push_back(0);\n+    /// vector.push_back(1);\n+    /// vector.push_back(2);\n+    ///\n+    /// assert_eq!(vector.as_slices(), (&[0u32, 1, 2] as &[u32], &[] as &[u32]));\n+    ///\n+    /// vector.push_front(10);\n+    /// vector.push_front(9);\n+    ///\n+    /// assert_eq!(vector.as_slices(), (&[9u32, 10] as &[u32], &[0u32, 1, 2] as &[u32]));\n+    /// ```\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n@@ -715,6 +756,24 @@ impl<T> VecDeque<T> {\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut vector: VecDeque<u32> = VecDeque::new();\n+    ///\n+    /// vector.push_back(0);\n+    /// vector.push_back(1);\n+    ///\n+    /// vector.push_front(10);\n+    /// vector.push_front(9);\n+    ///\n+    /// vector.as_mut_slices().0[0] = 42;\n+    /// vector.as_mut_slices().1[0] = 24;\n+    /// assert_eq!(vector.as_slices(), (&[42u32, 10] as &[u32], &[24u32, 1] as &[u32]));\n+    /// ```\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n@@ -789,7 +848,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n-\n+    ///\n     /// let mut v: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n     /// assert_eq!(vec![3].into_iter().collect::<VecDeque<_>>(), v.drain(2..).collect());\n     /// assert_eq!(vec![1, 2].into_iter().collect::<VecDeque<_>>(), v);\n@@ -875,6 +934,22 @@ impl<T> VecDeque<T> {\n \n     /// Returns `true` if the `VecDeque` contains an element equal to the\n     /// given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_deque_contains)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut vector: VecDeque<u32> = VecDeque::new();\n+    ///\n+    /// vector.push_back(0);\n+    /// vector.push_back(1);\n+    ///\n+    /// assert_eq!(vector.contains(&1), true);\n+    /// assert_eq!(vector.contains(&10), false);\n+    /// ```\n     #[unstable(feature = \"vec_deque_contains\", reason = \"recently added\",\n                issue = \"32630\")]\n     pub fn contains(&self, x: &T) -> bool\n@@ -1111,6 +1186,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1145,6 +1222,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1176,6 +1255,8 @@ impl<T> VecDeque<T> {\n     /// end is closer to the insertion point will be moved to make room,\n     /// and all the affected elements will be moved to new positions.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Panics\n     ///\n     /// Panics if `index` is greater than `VecDeque`'s length\n@@ -1403,7 +1484,10 @@ impl<T> VecDeque<T> {\n     /// room, and all the affected elements will be moved to new positions.\n     /// Returns `None` if `index` is out of bounds.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n+    ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n@@ -1581,6 +1665,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// Note that the capacity of `self` does not change.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Panics\n     ///\n     /// Panics if `at > len`"}, {"sha": "e2a57bd8d3862df021cf5325a4c68a5b926901d8", "filename": "src/libcollectionstest/binary_heap.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollectionstest%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollectionstest%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbinary_heap.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::collections::BinaryHeap;\n+use std::collections::binary_heap::Drain;\n \n #[test]\n fn test_iterator() {\n@@ -292,3 +293,8 @@ fn test_extend_specialization() {\n \n     assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n }\n+\n+#[allow(dead_code)]\n+fn assert_covariance() {\n+    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n+}"}, {"sha": "a61925cd3be5a1637dcab91b0c0024a77d9330bd", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -703,16 +703,32 @@ fn test_escape_unicode() {\n     assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode(), \"\\\\u{1d4ea}\\\\u{d}\");\n }\n \n+#[test]\n+fn test_escape_debug() {\n+    assert_eq!(\"abc\".escape_debug(), \"abc\");\n+    assert_eq!(\"a c\".escape_debug(), \"a c\");\n+    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_debug(), \"\u00e9\u00e8\u00ea\");\n+    assert_eq!(\"\\r\\n\\t\".escape_debug(), \"\\\\r\\\\n\\\\t\");\n+    assert_eq!(\"'\\\"\\\\\".escape_debug(), \"\\\\'\\\\\\\"\\\\\\\\\");\n+    assert_eq!(\"\\u{7f}\\u{ff}\".escape_debug(), \"\\\\u{7f}\\u{ff}\");\n+    assert_eq!(\"\\u{100}\\u{ffff}\".escape_debug(), \"\\u{100}\\\\u{ffff}\");\n+    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_debug(), \"\\u{10000}\\\\u{10ffff}\");\n+    assert_eq!(\"ab\\u{200b}\".escape_debug(), \"ab\\\\u{200b}\");\n+    assert_eq!(\"\\u{10d4ea}\\r\".escape_debug(), \"\\\\u{10d4ea}\\\\r\");\n+}\n+\n #[test]\n fn test_escape_default() {\n     assert_eq!(\"abc\".escape_default(), \"abc\");\n     assert_eq!(\"a c\".escape_default(), \"a c\");\n+    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_default(), \"\\\\u{e9}\\\\u{e8}\\\\u{ea}\");\n     assert_eq!(\"\\r\\n\\t\".escape_default(), \"\\\\r\\\\n\\\\t\");\n     assert_eq!(\"'\\\"\\\\\".escape_default(), \"\\\\'\\\\\\\"\\\\\\\\\");\n+    assert_eq!(\"\\u{7f}\\u{ff}\".escape_default(), \"\\\\u{7f}\\\\u{ff}\");\n     assert_eq!(\"\\u{100}\\u{ffff}\".escape_default(), \"\\\\u{100}\\\\u{ffff}\");\n     assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_default(), \"\\\\u{10000}\\\\u{10ffff}\");\n-    assert_eq!(\"ab\\u{fb00}\".escape_default(), \"ab\\\\u{fb00}\");\n-    assert_eq!(\"\\u{1d4ea}\\r\".escape_default(), \"\\\\u{1d4ea}\\\\r\");\n+    assert_eq!(\"ab\\u{200b}\".escape_default(), \"ab\\\\u{200b}\");\n+    assert_eq!(\"\\u{10d4ea}\\r\".escape_default(), \"\\\\u{10d4ea}\\\\r\");\n }\n \n #[test]"}, {"sha": "1652fb5a88d80dc46d1089adbb277cf9fa330ba7", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -192,6 +192,17 @@ fn test_push_str() {\n     assert_eq!(&s[0..], \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n }\n \n+#[test]\n+fn test_add_assign() {\n+    let mut s = String::new();\n+    s += \"\";\n+    assert_eq!(s.as_str(), \"\");\n+    s += \"abc\";\n+    assert_eq!(s.as_str(), \"abc\");\n+    s += \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    assert_eq!(s.as_str(), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+}\n+\n #[test]\n fn test_push() {\n     let mut data = String::from(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");"}, {"sha": "7a6bd958a5f8c7cb915c5756e055d1d25a65be78", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -11,6 +11,7 @@\n use std::borrow::Cow;\n use std::iter::{FromIterator, repeat};\n use std::mem::size_of;\n+use std::vec::Drain;\n \n use test::Bencher;\n \n@@ -510,6 +511,11 @@ fn test_cow_from() {\n     }\n }\n \n+#[allow(dead_code)]\n+fn assert_covariance() {\n+    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n+}\n+\n #[bench]\n fn bench_new(b: &mut Bencher) {\n     b.iter(|| {"}, {"sha": "06af200e47839b9c5a5d5ed6aa6c249264a71fb5", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -847,6 +847,20 @@ impl<'b, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<RefMut<'b, U>> for RefM\n /// The `UnsafeCell<T>` type is the only legal way to obtain aliasable data that is considered\n /// mutable. In general, transmuting an `&T` type into an `&mut T` is considered undefined behavior.\n ///\n+/// The compiler makes optimizations based on the knowledge that `&T` is not mutably aliased or\n+/// mutated, and that `&mut T` is unique. When building abstractions like `Cell`, `RefCell`,\n+/// `Mutex`, etc, you need to turn these optimizations off. `UnsafeCell` is the only legal way\n+/// to do this. When `UnsafeCell<T>` is immutably aliased, it is still safe to obtain a mutable\n+/// reference to its interior and/or to mutate it. However, it is up to the abstraction designer\n+/// to ensure that no two mutable references obtained this way are active at the same time, and\n+/// that there are no active mutable references or mutations when an immutable reference is obtained\n+/// from the cell. This is often done via runtime checks.\n+///\n+/// Note that while mutating or mutably aliasing the contents of an `& UnsafeCell<T>` is\n+/// okay (provided you enforce the invariants some other way); it is still undefined behavior\n+/// to have multiple `&mut UnsafeCell<T>` aliases.\n+///\n+///\n /// Types like `Cell<T>` and `RefCell<T>` use this type to wrap their internal data.\n ///\n /// # Examples\n@@ -916,6 +930,11 @@ impl<T> UnsafeCell<T> {\n impl<T: ?Sized> UnsafeCell<T> {\n     /// Gets a mutable pointer to the wrapped value.\n     ///\n+    /// This can be cast to a pointer of any kind.\n+    /// Ensure that the access is unique when casting to\n+    /// `&mut T`, and ensure that there are no mutations or mutable\n+    /// aliases going on when casting to `&T`\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "a3440fe8aa644883f9baad14bdc9102b911ccfd1", "filename": "src/libcore/char.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -17,6 +17,7 @@\n \n use prelude::v1::*;\n \n+use char_private::is_printable;\n use mem::transmute;\n \n // UTF-8 ranges and tags for encoding characters\n@@ -263,6 +264,8 @@ pub trait CharExt {\n     fn escape_unicode(self) -> EscapeUnicode;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn escape_default(self) -> EscapeDefault;\n+    #[unstable(feature = \"char_escape_debug\", issue = \"35068\")]\n+    fn escape_debug(self) -> EscapeDebug;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn len_utf8(self) -> usize;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -326,6 +329,19 @@ impl CharExt for char {\n         EscapeDefault { state: init_state }\n     }\n \n+    #[inline]\n+    fn escape_debug(self) -> EscapeDebug {\n+        let init_state = match self {\n+            '\\t' => EscapeDefaultState::Backslash('t'),\n+            '\\r' => EscapeDefaultState::Backslash('r'),\n+            '\\n' => EscapeDefaultState::Backslash('n'),\n+            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n+            c if is_printable(c) => EscapeDefaultState::Char(c),\n+            c => EscapeDefaultState::Unicode(c.escape_unicode()),\n+        };\n+        EscapeDebug(EscapeDefault { state: init_state })\n+    }\n+\n     #[inline]\n     fn len_utf8(self) -> usize {\n         let code = self as u32;\n@@ -600,6 +616,27 @@ impl ExactSizeIterator for EscapeDefault {\n     }\n }\n \n+/// An iterator that yields the literal escape code of a `char`.\n+///\n+/// This `struct` is created by the [`escape_debug()`] method on [`char`]. See its\n+/// documentation for more.\n+///\n+/// [`escape_debug()`]: ../../std/primitive.char.html#method.escape_debug\n+/// [`char`]: ../../std/primitive.char.html\n+#[unstable(feature = \"char_escape_debug\", issue = \"35068\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeDebug(EscapeDefault);\n+\n+#[unstable(feature = \"char_escape_debug\", issue = \"35068\")]\n+impl Iterator for EscapeDebug {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> { self.0.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n+}\n+\n+#[unstable(feature = \"char_escape_debug\", issue = \"35068\")]\n+impl ExactSizeIterator for EscapeDebug { }\n+\n /// An iterator over `u8` entries represending the UTF-8 encoding of a `char`\n /// value.\n ///"}, {"sha": "1d8f95cd4b81cd800aa3320a4510193496caf3f1", "filename": "src/libcore/char_private.rs", "status": "added", "additions": 695, "deletions": 0, "changes": 695, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fchar_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fchar_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar_private.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -0,0 +1,695 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// NOTE: The following code was generated by \"src/etc/char_private.py\",\n+//       do not edit directly!\n+\n+use slice::SliceExt;\n+\n+fn check(x: u16, singletons: &[u16], normal: &[u16]) -> bool {\n+    for &s in singletons {\n+        if x == s {\n+            return false;\n+        } else if x < s {\n+            break;\n+        }\n+    }\n+    for w in normal.chunks(2) {\n+        let start = w[0];\n+        let len = w[1];\n+        let difference = (x as i32) - (start as i32);\n+        if 0 <= difference {\n+            if difference < len as i32 {\n+                return false;\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+    true\n+}\n+\n+pub fn is_printable(x: char) -> bool {\n+    let x = x as u32;\n+    let lower = x as u16;\n+    if x < 0x10000 {\n+        check(lower, SINGLETONS0, NORMAL0)\n+    } else if x < 0x20000 {\n+        check(lower, SINGLETONS1, NORMAL1)\n+    } else {\n+        if 0x20000 <= x && x < 0x2f800 {\n+            return false;\n+        }\n+        if 0x2fa1e <= x && x < 0xe0100 {\n+            return false;\n+        }\n+        if 0xe01f0 <= x && x < 0x110000 {\n+            return false;\n+        }\n+        true\n+    }\n+}\n+\n+const SINGLETONS0: &'static [u16] = &[\n+    0xad,\n+    0x378,\n+    0x379,\n+    0x38b,\n+    0x38d,\n+    0x3a2,\n+    0x557,\n+    0x558,\n+    0x560,\n+    0x588,\n+    0x590,\n+    0x61c,\n+    0x61d,\n+    0x6dd,\n+    0x70e,\n+    0x70f,\n+    0x74b,\n+    0x74c,\n+    0x82e,\n+    0x82f,\n+    0x83f,\n+    0x85c,\n+    0x85d,\n+    0x8a1,\n+    0x8ff,\n+    0x978,\n+    0x980,\n+    0x984,\n+    0x98d,\n+    0x98e,\n+    0x991,\n+    0x992,\n+    0x9a9,\n+    0x9b1,\n+    0x9ba,\n+    0x9bb,\n+    0x9c5,\n+    0x9c6,\n+    0x9c9,\n+    0x9ca,\n+    0x9de,\n+    0x9e4,\n+    0x9e5,\n+    0xa04,\n+    0xa11,\n+    0xa12,\n+    0xa29,\n+    0xa31,\n+    0xa34,\n+    0xa37,\n+    0xa3a,\n+    0xa3b,\n+    0xa3d,\n+    0xa49,\n+    0xa4a,\n+    0xa5d,\n+    0xa84,\n+    0xa8e,\n+    0xa92,\n+    0xaa9,\n+    0xab1,\n+    0xab4,\n+    0xaba,\n+    0xabb,\n+    0xac6,\n+    0xaca,\n+    0xace,\n+    0xacf,\n+    0xae4,\n+    0xae5,\n+    0xb04,\n+    0xb0d,\n+    0xb0e,\n+    0xb11,\n+    0xb12,\n+    0xb29,\n+    0xb31,\n+    0xb34,\n+    0xb3a,\n+    0xb3b,\n+    0xb45,\n+    0xb46,\n+    0xb49,\n+    0xb4a,\n+    0xb5e,\n+    0xb64,\n+    0xb65,\n+    0xb84,\n+    0xb91,\n+    0xb9b,\n+    0xb9d,\n+    0xbc9,\n+    0xbce,\n+    0xbcf,\n+    0xc04,\n+    0xc0d,\n+    0xc11,\n+    0xc29,\n+    0xc34,\n+    0xc45,\n+    0xc49,\n+    0xc57,\n+    0xc64,\n+    0xc65,\n+    0xc80,\n+    0xc81,\n+    0xc84,\n+    0xc8d,\n+    0xc91,\n+    0xca9,\n+    0xcb4,\n+    0xcba,\n+    0xcbb,\n+    0xcc5,\n+    0xcc9,\n+    0xcdf,\n+    0xce4,\n+    0xce5,\n+    0xcf0,\n+    0xd04,\n+    0xd0d,\n+    0xd11,\n+    0xd3b,\n+    0xd3c,\n+    0xd45,\n+    0xd49,\n+    0xd64,\n+    0xd65,\n+    0xd80,\n+    0xd81,\n+    0xd84,\n+    0xdb2,\n+    0xdbc,\n+    0xdbe,\n+    0xdbf,\n+    0xdd5,\n+    0xdd7,\n+    0xe83,\n+    0xe85,\n+    0xe86,\n+    0xe89,\n+    0xe8b,\n+    0xe8c,\n+    0xe98,\n+    0xea0,\n+    0xea4,\n+    0xea6,\n+    0xea8,\n+    0xea9,\n+    0xeac,\n+    0xeba,\n+    0xebe,\n+    0xebf,\n+    0xec5,\n+    0xec7,\n+    0xece,\n+    0xecf,\n+    0xeda,\n+    0xedb,\n+    0xf48,\n+    0xf98,\n+    0xfbd,\n+    0xfcd,\n+    0x10c6,\n+    0x10ce,\n+    0x10cf,\n+    0x1249,\n+    0x124e,\n+    0x124f,\n+    0x1257,\n+    0x1259,\n+    0x125e,\n+    0x125f,\n+    0x1289,\n+    0x128e,\n+    0x128f,\n+    0x12b1,\n+    0x12b6,\n+    0x12b7,\n+    0x12bf,\n+    0x12c1,\n+    0x12c6,\n+    0x12c7,\n+    0x12d7,\n+    0x1311,\n+    0x1316,\n+    0x1317,\n+    0x135b,\n+    0x135c,\n+    0x1680,\n+    0x170d,\n+    0x176d,\n+    0x1771,\n+    0x17de,\n+    0x17df,\n+    0x180e,\n+    0x180f,\n+    0x196e,\n+    0x196f,\n+    0x1a1c,\n+    0x1a1d,\n+    0x1a5f,\n+    0x1a7d,\n+    0x1a7e,\n+    0x1f16,\n+    0x1f17,\n+    0x1f1e,\n+    0x1f1f,\n+    0x1f46,\n+    0x1f47,\n+    0x1f4e,\n+    0x1f4f,\n+    0x1f58,\n+    0x1f5a,\n+    0x1f5c,\n+    0x1f5e,\n+    0x1f7e,\n+    0x1f7f,\n+    0x1fb5,\n+    0x1fc5,\n+    0x1fd4,\n+    0x1fd5,\n+    0x1fdc,\n+    0x1ff0,\n+    0x1ff1,\n+    0x1ff5,\n+    0x2072,\n+    0x2073,\n+    0x208f,\n+    0x2700,\n+    0x2c2f,\n+    0x2c5f,\n+    0x2d26,\n+    0x2d2e,\n+    0x2d2f,\n+    0x2da7,\n+    0x2daf,\n+    0x2db7,\n+    0x2dbf,\n+    0x2dc7,\n+    0x2dcf,\n+    0x2dd7,\n+    0x2ddf,\n+    0x2e9a,\n+    0x3040,\n+    0x3097,\n+    0x3098,\n+    0x318f,\n+    0x321f,\n+    0x32ff,\n+    0xa78f,\n+    0xa9ce,\n+    0xaa4e,\n+    0xaa4f,\n+    0xaa5a,\n+    0xaa5b,\n+    0xab07,\n+    0xab08,\n+    0xab0f,\n+    0xab10,\n+    0xab27,\n+    0xabee,\n+    0xabef,\n+    0xfa6e,\n+    0xfa6f,\n+    0xfb37,\n+    0xfb3d,\n+    0xfb3f,\n+    0xfb42,\n+    0xfb45,\n+    0xfd90,\n+    0xfd91,\n+    0xfdfe,\n+    0xfdff,\n+    0xfe53,\n+    0xfe67,\n+    0xfe75,\n+    0xffc8,\n+    0xffc9,\n+    0xffd0,\n+    0xffd1,\n+    0xffd8,\n+    0xffd9,\n+    0xffe7,\n+    0xfffe,\n+    0xffff,\n+];\n+const SINGLETONS1: &'static [u16] = &[\n+    0xc,\n+    0x27,\n+    0x3b,\n+    0x3e,\n+    0x4e,\n+    0x4f,\n+    0x31f,\n+    0x39e,\n+    0x49e,\n+    0x49f,\n+    0x806,\n+    0x807,\n+    0x809,\n+    0x836,\n+    0x83d,\n+    0x83e,\n+    0x856,\n+    0xa04,\n+    0xa14,\n+    0xa18,\n+    0xb56,\n+    0xb57,\n+    0x10bd,\n+    0x1135,\n+    0xd127,\n+    0xd128,\n+    0xd455,\n+    0xd49d,\n+    0xd4a0,\n+    0xd4a1,\n+    0xd4a3,\n+    0xd4a4,\n+    0xd4a7,\n+    0xd4a8,\n+    0xd4ad,\n+    0xd4ba,\n+    0xd4bc,\n+    0xd4c4,\n+    0xd506,\n+    0xd50b,\n+    0xd50c,\n+    0xd515,\n+    0xd51d,\n+    0xd53a,\n+    0xd53f,\n+    0xd545,\n+    0xd551,\n+    0xd6a6,\n+    0xd6a7,\n+    0xd7cc,\n+    0xd7cd,\n+    0xee04,\n+    0xee20,\n+    0xee23,\n+    0xee25,\n+    0xee26,\n+    0xee28,\n+    0xee33,\n+    0xee38,\n+    0xee3a,\n+    0xee48,\n+    0xee4a,\n+    0xee4c,\n+    0xee50,\n+    0xee53,\n+    0xee55,\n+    0xee56,\n+    0xee58,\n+    0xee5a,\n+    0xee5c,\n+    0xee5e,\n+    0xee60,\n+    0xee63,\n+    0xee65,\n+    0xee66,\n+    0xee6b,\n+    0xee73,\n+    0xee78,\n+    0xee7d,\n+    0xee7f,\n+    0xee8a,\n+    0xeea4,\n+    0xeeaa,\n+    0xf0af,\n+    0xf0b0,\n+    0xf0bf,\n+    0xf0c0,\n+    0xf0d0,\n+    0xf12f,\n+    0xf336,\n+    0xf3c5,\n+    0xf43f,\n+    0xf441,\n+    0xf4f8,\n+    0xf53e,\n+    0xf53f,\n+];\n+const NORMAL0: &'static [u16] = &[\n+    0x0, 0x20,\n+    0x7f, 0x22,\n+    0x37f, 0x5,\n+    0x528, 0x9,\n+    0x58b, 0x4,\n+    0x5c8, 0x8,\n+    0x5eb, 0x5,\n+    0x5f5, 0x11,\n+    0x7b2, 0xe,\n+    0x7fb, 0x5,\n+    0x85f, 0x41,\n+    0x8ad, 0x37,\n+    0x9b3, 0x3,\n+    0x9cf, 0x8,\n+    0x9d8, 0x4,\n+    0x9fc, 0x5,\n+    0xa0b, 0x4,\n+    0xa43, 0x4,\n+    0xa4e, 0x3,\n+    0xa52, 0x7,\n+    0xa5f, 0x7,\n+    0xa76, 0xb,\n+    0xad1, 0xf,\n+    0xaf2, 0xf,\n+    0xb4e, 0x8,\n+    0xb58, 0x4,\n+    0xb78, 0xa,\n+    0xb8b, 0x3,\n+    0xb96, 0x3,\n+    0xba0, 0x3,\n+    0xba5, 0x3,\n+    0xbab, 0x3,\n+    0xbba, 0x4,\n+    0xbc3, 0x3,\n+    0xbd1, 0x6,\n+    0xbd8, 0xe,\n+    0xbfb, 0x6,\n+    0xc3a, 0x3,\n+    0xc4e, 0x7,\n+    0xc5a, 0x6,\n+    0xc70, 0x8,\n+    0xcce, 0x7,\n+    0xcd7, 0x7,\n+    0xcf3, 0xf,\n+    0xd4f, 0x8,\n+    0xd58, 0x8,\n+    0xd76, 0x3,\n+    0xd97, 0x3,\n+    0xdc7, 0x3,\n+    0xdcb, 0x4,\n+    0xde0, 0x12,\n+    0xdf5, 0xc,\n+    0xe3b, 0x4,\n+    0xe5c, 0x25,\n+    0xe8e, 0x6,\n+    0xee0, 0x20,\n+    0xf6d, 0x4,\n+    0xfdb, 0x25,\n+    0x10c8, 0x5,\n+    0x137d, 0x3,\n+    0x139a, 0x6,\n+    0x13f5, 0xb,\n+    0x169d, 0x3,\n+    0x16f1, 0xf,\n+    0x1715, 0xb,\n+    0x1737, 0x9,\n+    0x1754, 0xc,\n+    0x1774, 0xc,\n+    0x17ea, 0x6,\n+    0x17fa, 0x6,\n+    0x181a, 0x6,\n+    0x1878, 0x8,\n+    0x18ab, 0x5,\n+    0x18f6, 0xa,\n+    0x191d, 0x3,\n+    0x192c, 0x4,\n+    0x193c, 0x4,\n+    0x1941, 0x3,\n+    0x1975, 0xb,\n+    0x19ac, 0x4,\n+    0x19ca, 0x6,\n+    0x19db, 0x3,\n+    0x1a8a, 0x6,\n+    0x1a9a, 0x6,\n+    0x1aae, 0x52,\n+    0x1b4c, 0x4,\n+    0x1b7d, 0x3,\n+    0x1bf4, 0x8,\n+    0x1c38, 0x3,\n+    0x1c4a, 0x3,\n+    0x1c80, 0x40,\n+    0x1cc8, 0x8,\n+    0x1cf7, 0x9,\n+    0x1de7, 0x15,\n+    0x1fff, 0x11,\n+    0x2028, 0x8,\n+    0x205f, 0x11,\n+    0x209d, 0x3,\n+    0x20ba, 0x16,\n+    0x20f1, 0xf,\n+    0x218a, 0x6,\n+    0x23f4, 0xc,\n+    0x2427, 0x19,\n+    0x244b, 0x15,\n+    0x2b4d, 0x3,\n+    0x2b5a, 0xa6,\n+    0x2cf4, 0x5,\n+    0x2d28, 0x5,\n+    0x2d68, 0x7,\n+    0x2d71, 0xe,\n+    0x2d97, 0x9,\n+    0x2e3c, 0x44,\n+    0x2ef4, 0xc,\n+    0x2fd6, 0x1a,\n+    0x2ffc, 0x5,\n+    0x3100, 0x5,\n+    0x312e, 0x3,\n+    0x31bb, 0x5,\n+    0x31e4, 0xc,\n+    0x3400, 0x19c0,\n+    0x4e00, 0x5200,\n+    0xa48d, 0x3,\n+    0xa4c7, 0x9,\n+    0xa62c, 0x14,\n+    0xa698, 0x7,\n+    0xa6f8, 0x8,\n+    0xa794, 0xc,\n+    0xa7ab, 0x4d,\n+    0xa82c, 0x4,\n+    0xa83a, 0x6,\n+    0xa878, 0x8,\n+    0xa8c5, 0x9,\n+    0xa8da, 0x6,\n+    0xa8fc, 0x4,\n+    0xa954, 0xb,\n+    0xa97d, 0x3,\n+    0xa9da, 0x4,\n+    0xa9e0, 0x20,\n+    0xaa37, 0x9,\n+    0xaa7c, 0x4,\n+    0xaac3, 0x18,\n+    0xaaf7, 0xa,\n+    0xab17, 0x9,\n+    0xab2f, 0x91,\n+    0xabfa, 0x2bb6,\n+    0xd7c7, 0x4,\n+    0xd7fc, 0x2104,\n+    0xfada, 0x26,\n+    0xfb07, 0xc,\n+    0xfb18, 0x5,\n+    0xfbc2, 0x11,\n+    0xfd40, 0x10,\n+    0xfdc8, 0x28,\n+    0xfe1a, 0x6,\n+    0xfe27, 0x9,\n+    0xfe6c, 0x4,\n+    0xfefd, 0x4,\n+    0xffbf, 0x3,\n+    0xffdd, 0x3,\n+    0xffef, 0xd,\n+];\n+const NORMAL1: &'static [u16] = &[\n+    0x5e, 0x22,\n+    0xfb, 0x5,\n+    0x103, 0x4,\n+    0x134, 0x3,\n+    0x18b, 0x5,\n+    0x19c, 0x34,\n+    0x1fe, 0x82,\n+    0x29d, 0x3,\n+    0x2d1, 0x2f,\n+    0x324, 0xc,\n+    0x34b, 0x35,\n+    0x3c4, 0x4,\n+    0x3d6, 0x2a,\n+    0x4aa, 0x356,\n+    0x839, 0x3,\n+    0x860, 0xa0,\n+    0x91c, 0x3,\n+    0x93a, 0x5,\n+    0x940, 0x40,\n+    0x9b8, 0x6,\n+    0x9c0, 0x40,\n+    0xa07, 0x5,\n+    0xa34, 0x4,\n+    0xa3b, 0x4,\n+    0xa48, 0x8,\n+    0xa59, 0x7,\n+    0xa80, 0x80,\n+    0xb36, 0x3,\n+    0xb73, 0x5,\n+    0xb80, 0x80,\n+    0xc49, 0x217,\n+    0xe7f, 0x181,\n+    0x104e, 0x4,\n+    0x1070, 0x10,\n+    0x10c2, 0xe,\n+    0x10e9, 0x7,\n+    0x10fa, 0x6,\n+    0x1144, 0x3c,\n+    0x11c9, 0x7,\n+    0x11da, 0x4a6,\n+    0x16b8, 0x8,\n+    0x16ca, 0x936,\n+    0x236f, 0x91,\n+    0x2463, 0xd,\n+    0x2474, 0xb8c,\n+    0x342f, 0x33d1,\n+    0x6a39, 0x4c7,\n+    0x6f45, 0xb,\n+    0x6f7f, 0x10,\n+    0x6fa0, 0x4060,\n+    0xb002, 0x1ffe,\n+    0xd0f6, 0xa,\n+    0xd173, 0x8,\n+    0xd1de, 0x22,\n+    0xd246, 0xba,\n+    0xd357, 0x9,\n+    0xd372, 0x8e,\n+    0xd547, 0x3,\n+    0xd800, 0x1600,\n+    0xee3c, 0x6,\n+    0xee43, 0x4,\n+    0xee9c, 0x5,\n+    0xeebc, 0x34,\n+    0xeef2, 0x10e,\n+    0xf02c, 0x4,\n+    0xf094, 0xc,\n+    0xf0e0, 0x20,\n+    0xf10b, 0x5,\n+    0xf16c, 0x4,\n+    0xf19b, 0x4b,\n+    0xf203, 0xd,\n+    0xf23b, 0x5,\n+    0xf249, 0x7,\n+    0xf252, 0xae,\n+    0xf321, 0xf,\n+    0xf37d, 0x3,\n+    0xf394, 0xc,\n+    0xf3cb, 0x15,\n+    0xf3f1, 0xf,\n+    0xf4fd, 0x3,\n+    0xf544, 0xc,\n+    0xf568, 0x93,\n+    0xf641, 0x4,\n+    0xf650, 0x30,\n+    0xf6c6, 0x3a,\n+    0xf774, 0x88c,\n+];"}, {"sha": "173c55e35d51e5a680cd62c84929e22caa798193", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -980,15 +980,19 @@ impl<'a> Formatter<'a> {\n             return self.buf.write_str(s);\n         }\n         // The `precision` field can be interpreted as a `max-width` for the\n-        // string being formatted\n-        if let Some(max) = self.precision {\n-            // If there's a maximum width and our string is longer than\n-            // that, then we must always have truncation. This is the only\n-            // case where the maximum length will matter.\n+        // string being formatted.\n+        let s = if let Some(max) = self.precision {\n+            // If our string is longer that the precision, then we must have\n+            // truncation. However other flags like `fill`, `width` and `align`\n+            // must act as always.\n             if let Some((i, _)) = s.char_indices().skip(max).next() {\n-                return self.buf.write_str(&s[..i])\n+                &s[..i]\n+            } else {\n+                &s\n             }\n-        }\n+        } else {\n+            &s\n+        };\n         // The `width` field is more of a `min-width` parameter at this point.\n         match self.width {\n             // If we're under the maximum length, and there's no minimum length\n@@ -1379,7 +1383,7 @@ impl Debug for str {\n         f.write_char('\"')?;\n         let mut from = 0;\n         for (i, c) in self.char_indices() {\n-            let esc = c.escape_default();\n+            let esc = c.escape_debug();\n             // If char needs escaping, flush backlog so far and write, else skip\n             if esc.len() != 1 {\n                 f.write_str(&self[from..i])?;\n@@ -1405,7 +1409,7 @@ impl Display for str {\n impl Debug for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.write_char('\\'')?;\n-        for c in self.escape_default() {\n+        for c in self.escape_debug() {\n             f.write_char(c)?\n         }\n         f.write_char('\\'')"}, {"sha": "27fdbd383017f08ea3e38350b47e0a6b9c9a84aa", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -234,6 +234,16 @@ pub trait BuildHasher {\n     type Hasher: Hasher;\n \n     /// Creates a new hasher.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::hash_map::RandomState;\n+    /// use std::hash::BuildHasher;\n+    ///\n+    /// let s = RandomState::new();\n+    /// let new_s = s.build_hasher();\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n     fn build_hasher(&self) -> Self::Hasher;\n }"}, {"sha": "c645608dda7902ed3189dbe7ad6af7b948fdf1b4", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 188, "deletions": 5, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -277,17 +277,200 @@ extern \"rust-intrinsic\" {\n     /// Moves a value out of scope without running drop glue.\n     pub fn forget<T>(_: T) -> ();\n \n-    /// Unsafely transforms a value of one type into a value of another type.\n+    /// Reinterprets the bits of a value of one type as another type; both types\n+    /// must have the same size. Neither the original, nor the result, may be an\n+    /// [invalid value] (../../nomicon/meet-safe-and-unsafe.html).\n     ///\n-    /// Both types must have the same size.\n+    /// `transmute` is semantically equivalent to a bitwise move of one type\n+    /// into another. It copies the bits from the destination type into the\n+    /// source type, then forgets the original. It's equivalent to C's `memcpy`\n+    /// under the hood, just like `transmute_copy`.\n+    ///\n+    /// `transmute` is incredibly unsafe. There are a vast number of ways to\n+    /// cause undefined behavior with this function. `transmute` should be\n+    /// the absolute last resort.\n+    ///\n+    /// The [nomicon](../../nomicon/transmutes.html) has additional\n+    /// documentation.\n     ///\n     /// # Examples\n     ///\n+    /// There are a few things that `transmute` is really useful for.\n+    ///\n+    /// Getting the bitpattern of a floating point type (or, more generally,\n+    /// type punning, when `T` and `U` aren't pointers):\n+    ///\n     /// ```\n-    /// use std::mem;\n+    /// let bitpattern = unsafe {\n+    ///     std::mem::transmute::<f32, u32>(1.0)\n+    /// };\n+    /// assert_eq!(bitpattern, 0x3F800000);\n+    /// ```\n+    ///\n+    /// Turning a pointer into a function pointer:\n+    ///\n+    /// ```\n+    /// fn foo() -> i32 {\n+    ///     0\n+    /// }\n+    /// let pointer = foo as *const ();\n+    /// let function = unsafe {\n+    ///     std::mem::transmute::<*const (), fn() -> i32>(pointer)\n+    /// };\n+    /// assert_eq!(function(), 0);\n+    /// ```\n+    ///\n+    /// Extending a lifetime, or shortening an invariant lifetime; this is\n+    /// advanced, very unsafe rust:\n+    ///\n+    /// ```\n+    /// struct R<'a>(&'a i32);\n+    /// unsafe fn extend_lifetime<'b>(r: R<'b>) -> R<'static> {\n+    ///     std::mem::transmute::<R<'b>, R<'static>>(r)\n+    /// }\n+    ///\n+    /// unsafe fn shorten_invariant_lifetime<'b, 'c>(r: &'b mut R<'static>)\n+    ///                                              -> &'b mut R<'c> {\n+    ///     std::mem::transmute::<&'b mut R<'static>, &'b mut R<'c>>(r)\n+    /// }\n+    /// ```\n+    ///\n+    /// # Alternatives\n+    ///\n+    /// However, many uses of `transmute` can be achieved through other means.\n+    /// `transmute` can transform any type into any other, with just the caveat\n+    /// that they're the same size, and often interesting results occur. Below\n+    /// are common applications of `transmute` which can be replaced with safe\n+    /// applications of `as`:\n     ///\n-    /// let array: &[u8] = unsafe { mem::transmute(\"Rust\") };\n-    /// assert_eq!(array, [82, 117, 115, 116]);\n+    /// Turning a pointer into a `usize`:\n+    ///\n+    /// ```\n+    /// let ptr = &0;\n+    /// let ptr_num_transmute = unsafe {\n+    ///     std::mem::transmute::<&i32, usize>(ptr)\n+    /// };\n+    /// // Use an `as` cast instead\n+    /// let ptr_num_cast = ptr as *const i32 as usize;\n+    /// ```\n+    ///\n+    /// Turning a `*mut T` into an `&mut T`:\n+    ///\n+    /// ```\n+    /// let ptr: *mut i32 = &mut 0;\n+    /// let ref_transmuted = unsafe {\n+    ///     std::mem::transmute::<*mut i32, &mut i32>(ptr)\n+    /// };\n+    /// // Use a reborrow instead\n+    /// let ref_casted = unsafe { &mut *ptr };\n+    /// ```\n+    ///\n+    /// Turning an `&mut T` into an `&mut U`:\n+    ///\n+    /// ```\n+    /// let ptr = &mut 0;\n+    /// let val_transmuted = unsafe {\n+    ///     std::mem::transmute::<&mut i32, &mut u32>(ptr)\n+    /// };\n+    /// // Now, put together `as` and reborrowing - note the chaining of `as`\n+    /// // `as` is not transitive\n+    /// let val_casts = unsafe { &mut *(ptr as *mut i32 as *mut u32) };\n+    /// ```\n+    ///\n+    /// Turning an `&str` into an `&[u8]`:\n+    ///\n+    /// ```\n+    /// // this is not a good way to do this.\n+    /// let slice = unsafe { std::mem::transmute::<&str, &[u8]>(\"Rust\") };\n+    /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    /// // You could use `str::as_bytes`\n+    /// let slice = \"Rust\".as_bytes();\n+    /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    /// // Or, just use a byte string, if you have control over the string\n+    /// // literal\n+    /// assert_eq!(b\"Rust\", &[82, 117, 115, 116]);\n+    /// ```\n+    ///\n+    /// Turning a `Vec<&T>` into a `Vec<Option<&T>>`:\n+    ///\n+    /// ```\n+    /// let store = [0, 1, 2, 3];\n+    /// let mut v_orig = store.iter().collect::<Vec<&i32>>();\n+    /// // Using transmute: this is Undefined Behavior, and a bad idea.\n+    /// // However, it is no-copy.\n+    /// let v_transmuted = unsafe {\n+    ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(\n+    ///         v_orig.clone())\n+    /// };\n+    /// // This is the suggested, safe way.\n+    /// // It does copy the entire Vector, though, into a new array.\n+    /// let v_collected = v_orig.clone()\n+    ///                         .into_iter()\n+    ///                         .map(|r| Some(r))\n+    ///                         .collect::<Vec<Option<&i32>>>();\n+    /// // The no-copy, unsafe way, still using transmute, but not UB.\n+    /// // This is equivalent to the original, but safer, and reuses the\n+    /// // same Vec internals. Therefore the new inner type must have the\n+    /// // exact same size, and the same or lesser alignment, as the old\n+    /// // type. The same caveats exist for this method as transmute, for\n+    /// // the original inner type (`&i32`) to the converted inner type\n+    /// // (`Option<&i32>`), so read the nomicon pages linked above.\n+    /// let v_from_raw = unsafe {\n+    ///     Vec::from_raw_parts(v_orig.as_mut_ptr(),\n+    ///                         v_orig.len(),\n+    ///                         v_orig.capacity())\n+    /// };\n+    /// std::mem::forget(v_orig);\n+    /// ```\n+    ///\n+    /// Implementing `split_at_mut`:\n+    ///\n+    /// ```\n+    /// use std::{slice, mem};\n+    /// // There are multiple ways to do this; and there are multiple problems\n+    /// // with the following, transmute, way.\n+    /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n+    ///                              -> (&mut [T], &mut [T]) {\n+    ///     let len = slice.len();\n+    ///     assert!(mid <= len);\n+    ///     unsafe {\n+    ///         let slice2 = mem::transmute::<&mut [T], &mut [T]>(slice);\n+    ///         // first: transmute is not typesafe; all it checks is that T and\n+    ///         // U are of the same size. Second, right here, you have two\n+    ///         // mutable references pointing to the same memory.\n+    ///         (&mut slice[0..mid], &mut slice2[mid..len])\n+    ///     }\n+    /// }\n+    /// // This gets rid of the typesafety problems; `&mut *` will *only* give\n+    /// // you an `&mut T` from an `&mut T` or `*mut T`.\n+    /// fn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\n+    ///                          -> (&mut [T], &mut [T]) {\n+    ///     let len = slice.len();\n+    ///     assert!(mid <= len);\n+    ///     unsafe {\n+    ///         let slice2 = &mut *(slice as *mut [T]);\n+    ///         // however, you still have two mutable references pointing to\n+    ///         // the same memory.\n+    ///         (&mut slice[0..mid], &mut slice2[mid..len])\n+    ///     }\n+    /// }\n+    /// // This is how the standard library does it. This is the best method, if\n+    /// // you need to do something like this\n+    /// fn split_at_stdlib<T>(slice: &mut [T], mid: usize)\n+    ///                       -> (&mut [T], &mut [T]) {\n+    ///     let len = slice.len();\n+    ///     assert!(mid <= len);\n+    ///     unsafe {\n+    ///         let ptr = slice.as_mut_ptr();\n+    ///         // This now has three mutable references pointing at the same\n+    ///         // memory. `slice`, the rvalue ret.0, and the rvalue ret.1.\n+    ///         // `slice` is never used after `let ptr = ...`, and so one can\n+    ///         // treat it as \"dead\", and therefore, you only have two real\n+    ///         // mutable slices.\n+    ///         (slice::from_raw_parts_mut(ptr, mid),\n+    ///          slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n+    ///     }\n+    /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn transmute<T, U>(e: T) -> U;"}, {"sha": "292d72dd362ad5c203497361cd9cda2febfaebc7", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -386,10 +386,11 @@ pub trait Extend<A> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DoubleEndedIterator: Iterator {\n-    /// An iterator able to yield elements from both ends.\n+    /// Removes and returns an element from the end of the iterator.\n     ///\n-    /// As this is the only method for this trait, the [trait-level] docs\n-    /// contain more details.\n+    /// Returns `None` when there are no more elements.\n+    ///\n+    /// The [trait-level] docs contain more details.\n     ///\n     /// [trait-level]: trait.DoubleEndedIterator.html\n     ///"}, {"sha": "fabb3900ec6483be59ef239c86eed6202c15d68b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -103,17 +103,17 @@ mod int_macros;\n #[macro_use]\n mod uint_macros;\n \n-#[path = \"num/isize.rs\"]  pub mod isize;\n-#[path = \"num/i8.rs\"]   pub mod i8;\n-#[path = \"num/i16.rs\"]  pub mod i16;\n-#[path = \"num/i32.rs\"]  pub mod i32;\n-#[path = \"num/i64.rs\"]  pub mod i64;\n+#[path = \"num/isize.rs\"] pub mod isize;\n+#[path = \"num/i8.rs\"]    pub mod i8;\n+#[path = \"num/i16.rs\"]   pub mod i16;\n+#[path = \"num/i32.rs\"]   pub mod i32;\n+#[path = \"num/i64.rs\"]   pub mod i64;\n \n #[path = \"num/usize.rs\"] pub mod usize;\n-#[path = \"num/u8.rs\"]   pub mod u8;\n-#[path = \"num/u16.rs\"]  pub mod u16;\n-#[path = \"num/u32.rs\"]  pub mod u32;\n-#[path = \"num/u64.rs\"]  pub mod u64;\n+#[path = \"num/u8.rs\"]    pub mod u8;\n+#[path = \"num/u16.rs\"]   pub mod u16;\n+#[path = \"num/u32.rs\"]   pub mod u32;\n+#[path = \"num/u64.rs\"]   pub mod u64;\n \n #[path = \"num/f32.rs\"]   pub mod f32;\n #[path = \"num/f64.rs\"]   pub mod f64;\n@@ -161,5 +161,6 @@ pub mod hash;\n pub mod fmt;\n \n // note: does not need to be public\n+mod char_private;\n mod iter_private;\n mod tuple;"}, {"sha": "b0c79a3a88547b0551436df2d562bc4ea6d0c6d9", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -35,6 +35,17 @@ macro_rules! panic {\n /// This will invoke the `panic!` macro if the provided expression cannot be\n /// evaluated to `true` at runtime.\n ///\n+/// Assertions are always checked in both debug and release builds, and cannot\n+/// be disabled. See `debug_assert!` for assertions that are not enabled in\n+/// release builds by default.\n+///\n+/// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n+/// violated could lead to unsafety.\n+///\n+/// Other use-cases of `assert!` include\n+/// [testing](https://doc.rust-lang.org/book/testing.html) and enforcing\n+/// run-time invariants in safe code (whose violation cannot result in unsafety).\n+///\n /// This macro has a second version, where a custom panic message can be provided.\n ///\n /// # Examples\n@@ -123,6 +134,13 @@ macro_rules! assert_eq {\n /// expensive to be present in a release build but may be helpful during\n /// development.\n ///\n+/// An unchecked assertion allows a program in an inconsistent state to keep\n+/// running, which might have unexpected consequences but does not introduce\n+/// unsafety as long as this only happens in safe code. The performance cost\n+/// of assertions, is however, not measurable in general. Replacing `assert!`\n+/// with `debug_assert!` is thus only encouraged after thorough profiling, and\n+/// more importantly, only in safe code!\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "894982abaa939879f58e410e03c595ddf17cb684", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -144,6 +144,12 @@ pub trait Unsize<T: ?Sized> {\n /// Generalizing the latter case, any type implementing `Drop` can't be `Copy`, because it's\n /// managing some resource besides its own `size_of::<T>()` bytes.\n ///\n+/// ## What if I derive `Copy` on a type that can't?\n+///\n+/// If you try to derive `Copy` on a struct or enum, you will get a compile-time error.\n+/// Specifically, with structs you'll get [E0204](https://doc.rust-lang.org/error-index.html#E0204)\n+/// and with enums you'll get [E0205](https://doc.rust-lang.org/error-index.html#E0205).\n+///\n /// ## When should my type be `Copy`?\n ///\n /// Generally speaking, if your type _can_ implement `Copy`, it should. There's one important thing"}, {"sha": "4636811aa46da2c95f96d6c87bf9cdd3a06a09b6", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -611,6 +611,31 @@ macro_rules! int_impl {\n             if b {None} else {Some(a)}\n         }\n \n+        /// Checked absolute value. Computes `self.abs()`, returning `None` if\n+        /// `self == MIN`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(no_panic_abs)]\n+        ///\n+        /// use std::i32;\n+        ///\n+        /// assert_eq!((-5i32).checked_abs(), Some(5));\n+        /// assert_eq!(i32::MIN.checked_abs(), None);\n+        /// ```\n+        #[unstable(feature = \"no_panic_abs\", issue = \"35057\")]\n+        #[inline]\n+        pub fn checked_abs(self) -> Option<Self> {\n+            if self.is_negative() {\n+                self.checked_neg()\n+            } else {\n+                Some(self)\n+            }\n+        }\n+\n         /// Saturating integer addition. Computes `self + other`, saturating at\n         /// the numeric bounds instead of overflowing.\n         ///\n@@ -863,6 +888,36 @@ macro_rules! int_impl {\n             self.overflowing_shr(rhs).0\n         }\n \n+        /// Wrapping (modular) absolute value. Computes `self.abs()`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// The only case where such wrapping can occur is when one takes\n+        /// the absolute value of the negative minimal value for the type\n+        /// this is a positive value that is too large to represent in the\n+        /// type. In such a case, this function returns `MIN` itself.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(no_panic_abs)]\n+        ///\n+        /// assert_eq!(100i8.wrapping_abs(), 100);\n+        /// assert_eq!((-100i8).wrapping_abs(), 100);\n+        /// assert_eq!((-128i8).wrapping_abs(), -128);\n+        /// assert_eq!((-128i8).wrapping_abs() as u8, 128);\n+        /// ```\n+        #[unstable(feature = \"no_panic_abs\", issue = \"35057\")]\n+        #[inline(always)]\n+        pub fn wrapping_abs(self) -> Self {\n+            if self.is_negative() {\n+                self.wrapping_neg()\n+            } else {\n+                self\n+            }\n+        }\n+\n         /// Calculates `self` + `rhs`\n         ///\n         /// Returns a tuple of the addition along with a boolean indicating\n@@ -1071,6 +1126,35 @@ macro_rules! int_impl {\n             (self >> (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n \n+        /// Computes the absolute value of `self`.\n+        ///\n+        /// Returns a tuple of the absolute version of self along with a\n+        /// boolean indicating whether an overflow happened. If self is the\n+        /// minimum value (e.g. i32::MIN for values of type i32), then the\n+        /// minimum value will be returned again and true will be returned for\n+        /// an overflow happening.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(no_panic_abs)]\n+        ///\n+        /// assert_eq!(10i8.overflowing_abs(), (10,false));\n+        /// assert_eq!((-10i8).overflowing_abs(), (10,false));\n+        /// assert_eq!((-128i8).overflowing_abs(), (-128,true));\n+        /// ```\n+        #[unstable(feature = \"no_panic_abs\", issue = \"35057\")]\n+        #[inline]\n+        pub fn overflowing_abs(self) -> (Self, bool) {\n+            if self.is_negative() {\n+                self.overflowing_neg()\n+            } else {\n+                (self, false)\n+            }\n+        }\n+\n         /// Raises self to the power of `exp`, using exponentiation by squaring.\n         ///\n         /// # Examples"}, {"sha": "fe508adb71380089d4e313114288410fcb6274eb", "filename": "src/libcore/option.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -142,6 +142,7 @@\n use self::Option::*;\n \n use clone::Clone;\n+use convert::From;\n use default::Default;\n use iter::ExactSizeIterator;\n use iter::{Iterator, DoubleEndedIterator, FromIterator, IntoIterator};\n@@ -754,6 +755,13 @@ impl<'a, T> IntoIterator for &'a mut Option<T> {\n     }\n }\n \n+#[stable(since = \"1.12.0\", feature = \"option_from\")]\n+impl<T> From<T> for Option<T> {\n+    fn from(val: T) -> Option<T> {\n+        Some(val)\n+    }\n+}\n+\n /////////////////////////////////////////////////////////////////////////////\n // The Option Iterators\n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "d8a11581c3b69be0de75868e938add9a8d135a20", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -902,6 +902,8 @@ macro_rules! make_mut_slice {\n \n /// Immutable slice iterator\n ///\n+/// This struct is created by the [`iter`] method on [slices].\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -915,6 +917,9 @@ macro_rules! make_mut_slice {\n ///     println!(\"{}\", element);\n /// }\n /// ```\n+///\n+/// [`iter`]: ../../std/primitive.slice.html#method.iter\n+/// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n@@ -993,6 +998,8 @@ impl<'a, T> Clone for Iter<'a, T> {\n \n /// Mutable slice iterator.\n ///\n+/// This struct is created by the [`iter_mut`] method on [slices].\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -1010,6 +1017,9 @@ impl<'a, T> Clone for Iter<'a, T> {\n /// // We now have \"[2, 3, 4]\":\n /// println!(\"{:?}\", slice);\n /// ```\n+///\n+/// [`iter_mut`]: ../../std/primitive.slice.html#method.iter_mut\n+/// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,"}, {"sha": "fdcadd43a0fb64deeda403b43c42ebf3a74c4277", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -459,6 +459,19 @@ impl<'a> Chars<'a> {\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut chars = \"abc\".chars();\n+    ///\n+    /// assert_eq!(chars.as_str(), \"abc\");\n+    /// chars.next();\n+    /// assert_eq!(chars.as_str(), \"bc\");\n+    /// chars.next();\n+    /// chars.next();\n+    /// assert_eq!(chars.as_str(), \"\");\n+    /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     #[inline]\n     pub fn as_str(&self) -> &'a str {"}, {"sha": "2a7a0b62329362b626d01f5d3d78f96a0d471cae", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -74,6 +74,8 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![cfg_attr(not(target_has_atomic = \"8\"), allow(dead_code))]\n+#![cfg_attr(not(target_has_atomic = \"8\"), allow(unused_imports))]\n \n use self::Ordering::*;\n "}, {"sha": "4632419336d7f5f047e0057d02a3ce48d45a44b2", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -123,6 +123,49 @@ fn test_is_digit() {\n    assert!(!'Q'.is_numeric());\n }\n \n+#[test]\n+fn test_escape_debug() {\n+    fn string(c: char) -> String {\n+        c.escape_debug().collect()\n+    }\n+    let s = string('\\n');\n+    assert_eq!(s, \"\\\\n\");\n+    let s = string('\\r');\n+    assert_eq!(s, \"\\\\r\");\n+    let s = string('\\'');\n+    assert_eq!(s, \"\\\\'\");\n+    let s = string('\"');\n+    assert_eq!(s, \"\\\\\\\"\");\n+    let s = string(' ');\n+    assert_eq!(s, \" \");\n+    let s = string('a');\n+    assert_eq!(s, \"a\");\n+    let s = string('~');\n+    assert_eq!(s, \"~\");\n+    let s = string('\u00e9');\n+    assert_eq!(s, \"\u00e9\");\n+    let s = string('\\x00');\n+    assert_eq!(s, \"\\\\u{0}\");\n+    let s = string('\\x1f');\n+    assert_eq!(s, \"\\\\u{1f}\");\n+    let s = string('\\x7f');\n+    assert_eq!(s, \"\\\\u{7f}\");\n+    let s = string('\\u{80}');\n+    assert_eq!(s, \"\\\\u{80}\");\n+    let s = string('\\u{ff}');\n+    assert_eq!(s, \"\\u{ff}\");\n+    let s = string('\\u{11b}');\n+    assert_eq!(s, \"\\u{11b}\");\n+    let s = string('\\u{1d4b6}');\n+    assert_eq!(s, \"\\u{1d4b6}\");\n+    let s = string('\\u{200b}'); // zero width space\n+    assert_eq!(s, \"\\\\u{200b}\");\n+    let s = string('\\u{e000}'); // private use 1\n+    assert_eq!(s, \"\\\\u{e000}\");\n+    let s = string('\\u{100000}'); // private use 2\n+    assert_eq!(s, \"\\\\u{100000}\");\n+}\n+\n #[test]\n fn test_escape_default() {\n     fn string(c: char) -> String {\n@@ -142,18 +185,28 @@ fn test_escape_default() {\n     assert_eq!(s, \"a\");\n     let s = string('~');\n     assert_eq!(s, \"~\");\n+    let s = string('\u00e9');\n+    assert_eq!(s, \"\\\\u{e9}\");\n     let s = string('\\x00');\n     assert_eq!(s, \"\\\\u{0}\");\n     let s = string('\\x1f');\n     assert_eq!(s, \"\\\\u{1f}\");\n     let s = string('\\x7f');\n     assert_eq!(s, \"\\\\u{7f}\");\n+    let s = string('\\u{80}');\n+    assert_eq!(s, \"\\\\u{80}\");\n     let s = string('\\u{ff}');\n     assert_eq!(s, \"\\\\u{ff}\");\n     let s = string('\\u{11b}');\n     assert_eq!(s, \"\\\\u{11b}\");\n     let s = string('\\u{1d4b6}');\n     assert_eq!(s, \"\\\\u{1d4b6}\");\n+    let s = string('\\u{200b}'); // zero width space\n+    assert_eq!(s, \"\\\\u{200b}\");\n+    let s = string('\\u{e000}'); // private use 1\n+    assert_eq!(s, \"\\\\u{e000}\");\n+    let s = string('\\u{100000}'); // private use 2\n+    assert_eq!(s, \"\\\\u{100000}\");\n }\n \n #[test]"}, {"sha": "9428b4096bfeceaa74fdd5ea61d50f1f518bbd7e", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -14,6 +14,7 @@\n #![feature(borrow_state)]\n #![feature(box_syntax)]\n #![feature(cell_extras)]\n+#![feature(char_escape_debug)]\n #![feature(const_fn)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n@@ -29,10 +30,9 @@\n #![feature(slice_patterns)]\n #![feature(step_by)]\n #![feature(test)]\n-#![feature(unboxed_closures)]\n+#![feature(try_from)]\n #![feature(unicode)]\n #![feature(unique)]\n-#![feature(try_from)]\n \n extern crate core;\n extern crate test;"}, {"sha": "5423da9c81c02880c991871943c00b6442751fe6", "filename": "src/libflate/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibflate%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibflate%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2FCargo.toml?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -11,4 +11,4 @@ crate-type = [\"dylib\"]\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-gcc = \"0.3\"\n+gcc = \"0.3.27\""}, {"sha": "5066b7dcab7e700844b0e2ba71b8af9dc627a59b", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -1 +1 @@\n-Subproject commit b0d62534d48b711c8978d1bbe8cca0558ae7b1cb\n+Subproject commit 5066b7dcab7e700844b0e2ba71b8af9dc627a59b"}, {"sha": "2284a9bbb73e124bcc32db89160180acf3def2c3", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 71, "deletions": 35, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -45,16 +45,25 @@ pub const DW_EH_PE_aligned: u8 = 0x50;\n pub const DW_EH_PE_indirect: u8 = 0x80;\n \n #[derive(Copy, Clone)]\n-pub struct EHContext {\n+pub struct EHContext<'a> {\n     pub ip: usize, // Current instruction pointer\n     pub func_start: usize, // Address of the current function\n-    pub text_start: usize, // Address of the code section\n-    pub data_start: usize, // Address of the data section\n+    pub get_text_start: &'a Fn() -> usize, // Get address of the code section\n+    pub get_data_start: &'a Fn() -> usize, // Get address of the data section\n }\n \n-pub unsafe fn find_landing_pad(lsda: *const u8, context: &EHContext) -> Option<usize> {\n+pub enum EHAction {\n+    None,\n+    Cleanup(usize),\n+    Catch(usize),\n+    Terminate,\n+}\n+\n+pub const USING_SJLJ_EXCEPTIONS: bool = cfg!(all(target_os = \"ios\", target_arch = \"arm\"));\n+\n+pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n     if lsda.is_null() {\n-        return None;\n+        return EHAction::None;\n     }\n \n     let func_start = context.func_start;\n@@ -77,32 +86,61 @@ pub unsafe fn find_landing_pad(lsda: *const u8, context: &EHContext) -> Option<u\n     let call_site_encoding = reader.read::<u8>();\n     let call_site_table_length = reader.read_uleb128();\n     let action_table = reader.ptr.offset(call_site_table_length as isize);\n-    // Return addresses point 1 byte past the call instruction, which could\n-    // be in the next IP range.\n-    let ip = context.ip - 1;\n-\n-    while reader.ptr < action_table {\n-        let cs_start = read_encoded_pointer(&mut reader, context, call_site_encoding);\n-        let cs_len = read_encoded_pointer(&mut reader, context, call_site_encoding);\n-        let cs_lpad = read_encoded_pointer(&mut reader, context, call_site_encoding);\n-        let cs_action = reader.read_uleb128();\n-        // Callsite table is sorted by cs_start, so if we've passed the ip, we\n-        // may stop searching.\n-        if ip < func_start + cs_start {\n-            break;\n+    let ip = context.ip;\n+\n+    if !USING_SJLJ_EXCEPTIONS {\n+        while reader.ptr < action_table {\n+            let cs_start = read_encoded_pointer(&mut reader, context, call_site_encoding);\n+            let cs_len = read_encoded_pointer(&mut reader, context, call_site_encoding);\n+            let cs_lpad = read_encoded_pointer(&mut reader, context, call_site_encoding);\n+            let cs_action = reader.read_uleb128();\n+            // Callsite table is sorted by cs_start, so if we've passed the ip, we\n+            // may stop searching.\n+            if ip < func_start + cs_start {\n+                break;\n+            }\n+            if ip < func_start + cs_start + cs_len {\n+                if cs_lpad == 0 {\n+                    return EHAction::None;\n+                } else {\n+                    let lpad = lpad_base + cs_lpad;\n+                    return interpret_cs_action(cs_action, lpad);\n+                }\n+            }\n         }\n-        if ip < func_start + cs_start + cs_len {\n-            if cs_lpad != 0 {\n-                return Some(lpad_base + cs_lpad);\n-            } else {\n-                return None;\n+        // Ip is not present in the table.  This should not happen... but it does: issue #35011.\n+        // So rather than returning EHAction::Terminate, we do this.\n+        EHAction::None\n+    } else {\n+        // SjLj version:\n+        // The \"IP\" is an index into the call-site table, with two exceptions:\n+        // -1 means 'no-action', and 0 means 'terminate'.\n+        match ip as isize {\n+           -1 => return EHAction::None,\n+            0 => return EHAction::Terminate,\n+            _ => (),\n+        }\n+        let mut idx = ip;\n+        loop {\n+            let cs_lpad = reader.read_uleb128();\n+            let cs_action = reader.read_uleb128();\n+            idx -= 1;\n+            if idx == 0 {\n+                // Can never have null landing pad for sjlj -- that would have\n+                // been indicated by a -1 call site index.\n+                let lpad = (cs_lpad + 1) as usize;\n+                return interpret_cs_action(cs_action, lpad);\n             }\n         }\n     }\n-    // IP range not found: gcc's C++ personality calls terminate() here,\n-    // however the rest of the languages treat this the same as cs_lpad == 0.\n-    // We follow this suit.\n-    None\n+}\n+\n+fn interpret_cs_action(cs_action: u64, lpad: usize) -> EHAction {\n+    if cs_action == 0 {\n+        EHAction::Cleanup(lpad)\n+    } else {\n+        EHAction::Catch(lpad)\n+    }\n }\n \n #[inline]\n@@ -140,18 +178,16 @@ unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n         DW_EH_PE_absptr => 0,\n         // relative to address of the encoded value, despite the name\n         DW_EH_PE_pcrel => reader.ptr as usize,\n-        DW_EH_PE_textrel => {\n-            assert!(context.text_start != 0);\n-            context.text_start\n-        }\n-        DW_EH_PE_datarel => {\n-            assert!(context.data_start != 0);\n-            context.data_start\n-        }\n         DW_EH_PE_funcrel => {\n             assert!(context.func_start != 0);\n             context.func_start\n         }\n+        DW_EH_PE_textrel => {\n+            (*context.get_text_start)()\n+        }\n+        DW_EH_PE_datarel => {\n+            (*context.get_data_start)()\n+        }\n         _ => panic!(),\n     };\n "}, {"sha": "fdae8f69a9c0ef31f49fca61b919c7e17cfa0244", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 158, "deletions": 132, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -61,6 +61,8 @@ use core::ptr;\n use alloc::boxed::Box;\n \n use unwind as uw;\n+use libc::{c_int, uintptr_t};\n+use dwarf::eh::{self, EHContext, EHAction};\n \n #[repr(C)]\n struct Exception {\n@@ -106,160 +108,184 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n     0x4d4f5a_00_52555354\n }\n \n-// We could implement our personality routine in Rust, however exception\n-// info decoding is tedious.  More importantly, personality routines have to\n-// handle various platform quirks, which are not fun to maintain.  For this\n-// reason, we attempt to reuse personality routine of the C language:\n-// __gcc_personality_v0.\n-//\n-// Since C does not support exception catching, __gcc_personality_v0 simply\n-// always returns _URC_CONTINUE_UNWIND in search phase, and always returns\n-// _URC_INSTALL_CONTEXT (i.e. \"invoke cleanup code\") in cleanup phase.\n-//\n-// This is pretty close to Rust's exception handling approach, except that Rust\n-// does have a single \"catch-all\" handler at the bottom of each thread's stack.\n-// So we have two versions of the personality routine:\n-// - rust_eh_personality, used by all cleanup landing pads, which never catches,\n-//   so the behavior of __gcc_personality_v0 is perfectly adequate there, and\n-// - rust_eh_personality_catch, used only by rust_try(), which always catches.\n-//\n-// See also: rustc_trans::trans::intrinsic::trans_gnu_try\n \n-#[cfg(all(not(target_arch = \"arm\"),\n-          not(all(windows, target_arch = \"x86_64\"))))]\n-pub mod eabi {\n-    use unwind as uw;\n-    use libc::c_int;\n+// Register ids were lifted from LLVM's TargetLowering::getExceptionPointerRegister()\n+// and TargetLowering::getExceptionSelectorRegister() for each architecture,\n+// then mapped to DWARF register numbers via register definition tables\n+// (typically <arch>RegisterInfo.td, search for \"DwarfRegNum\").\n+// See also http://llvm.org/docs/WritingAnLLVMBackend.html#defining-a-register.\n \n-    extern \"C\" {\n-        fn __gcc_personality_v0(version: c_int,\n-                                actions: uw::_Unwind_Action,\n-                                exception_class: uw::_Unwind_Exception_Class,\n-                                ue_header: *mut uw::_Unwind_Exception,\n-                                context: *mut uw::_Unwind_Context)\n-                                -> uw::_Unwind_Reason_Code;\n-    }\n+#[cfg(target_arch = \"x86\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 2); // EAX, EDX\n \n-    #[lang = \"eh_personality\"]\n-    #[no_mangle]\n-    extern \"C\" fn rust_eh_personality(version: c_int,\n-                                      actions: uw::_Unwind_Action,\n-                                      exception_class: uw::_Unwind_Exception_Class,\n-                                      ue_header: *mut uw::_Unwind_Exception,\n-                                      context: *mut uw::_Unwind_Context)\n-                                      -> uw::_Unwind_Reason_Code {\n-        unsafe { __gcc_personality_v0(version, actions, exception_class, ue_header, context) }\n-    }\n+#[cfg(target_arch = \"x86_64\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // RAX, RDX\n \n-    #[lang = \"eh_personality_catch\"]\n-    #[no_mangle]\n-    pub extern \"C\" fn rust_eh_personality_catch(version: c_int,\n-                                                actions: uw::_Unwind_Action,\n-                                                exception_class: uw::_Unwind_Exception_Class,\n-                                                ue_header: *mut uw::_Unwind_Exception,\n-                                                context: *mut uw::_Unwind_Context)\n-                                                -> uw::_Unwind_Reason_Code {\n+#[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1 / X0, X1\n \n-        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 {\n-            // search phase\n-            uw::_URC_HANDLER_FOUND // catch!\n-        } else {\n-            // cleanup phase\n-            unsafe { __gcc_personality_v0(version, actions, exception_class, ue_header, context) }\n+#[cfg(any(target_arch = \"mips\", target_arch = \"mipsel\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (4, 5); // A0, A1\n+\n+#[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (3, 4); // R3, R4 / X3, X4\n+\n+// The following code is based on GCC's C and C++ personality routines.  For reference, see:\n+// https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/eh_personality.cc\n+// https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c\n+\n+// The personality routine for most of our targets, except ARM, which has a slightly different ABI\n+// (however, iOS goes here as it uses SjLj unwinding).  Also, the 64-bit Windows implementation\n+// lives in seh64_gnu.rs\n+#[cfg(all(any(target_os = \"ios\", not(target_arch = \"arm\"))))]\n+#[lang = \"eh_personality\"]\n+#[no_mangle]\n+#[allow(unused)]\n+unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n+                                         actions: uw::_Unwind_Action,\n+                                         exception_class: uw::_Unwind_Exception_Class,\n+                                         exception_object: *mut uw::_Unwind_Exception,\n+                                         context: *mut uw::_Unwind_Context)\n+                                         -> uw::_Unwind_Reason_Code {\n+    if version != 1 {\n+        return uw::_URC_FATAL_PHASE1_ERROR;\n+    }\n+    let eh_action = find_eh_action(context);\n+    if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n+        match eh_action {\n+            EHAction::None | EHAction::Cleanup(_) => return uw::_URC_CONTINUE_UNWIND,\n+            EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n+            EHAction::Terminate => return uw::_URC_FATAL_PHASE1_ERROR,\n+        }\n+    } else {\n+        match eh_action {\n+            EHAction::None => return uw::_URC_CONTINUE_UNWIND,\n+            EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n+                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                uw::_Unwind_SetIP(context, lpad);\n+                return uw::_URC_INSTALL_CONTEXT;\n+            }\n+            EHAction::Terminate => return uw::_URC_FATAL_PHASE2_ERROR,\n         }\n     }\n }\n \n-// iOS on armv7 is using SjLj exceptions and therefore requires to use\n-// a specialized personality routine: __gcc_personality_sj0\n-\n-#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n-pub mod eabi {\n-    use unwind as uw;\n-    use libc::c_int;\n+// ARM EHABI personality routine.\n+// http://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf\n+#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]\n+#[lang = \"eh_personality\"]\n+#[no_mangle]\n+unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n+                                         exception_object: *mut uw::_Unwind_Exception,\n+                                         context: *mut uw::_Unwind_Context)\n+                                        -> uw::_Unwind_Reason_Code {\n+    let state = state as c_int;\n+    let action = state & uw::_US_ACTION_MASK as c_int;\n+    let search_phase = if action == uw::_US_VIRTUAL_UNWIND_FRAME as c_int {\n+        // Backtraces on ARM will call the personality routine with\n+        // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n+        // we want to continue unwinding the stack, otherwise all our backtraces\n+        // would end at __rust_try\n+        if state & uw::_US_FORCE_UNWIND as c_int != 0 {\n+            return continue_unwind(exception_object, context)\n+        }\n+        true\n+    } else if action == uw::_US_UNWIND_FRAME_STARTING as c_int {\n+        false\n+    } else if action == uw::_US_UNWIND_FRAME_RESUME as c_int {\n+        return continue_unwind(exception_object, context);\n+    } else {\n+        return uw::_URC_FAILURE;\n+    };\n \n-    extern \"C\" {\n-        fn __gcc_personality_sj0(version: c_int,\n-                                 actions: uw::_Unwind_Action,\n-                                 exception_class: uw::_Unwind_Exception_Class,\n-                                 ue_header: *mut uw::_Unwind_Exception,\n-                                 context: *mut uw::_Unwind_Context)\n-                                 -> uw::_Unwind_Reason_Code;\n-    }\n+    // The DWARF unwinder assumes that _Unwind_Context holds things like the function\n+    // and LSDA pointers, however ARM EHABI places them into the exception object.\n+    // To preserve signatures of functions like _Unwind_GetLanguageSpecificData(), which\n+    // take only the context pointer, GCC personality routines stash a pointer to exception_object\n+    // in the context, using location reserved for ARM's \"scratch register\" (r12).\n+    uw::_Unwind_SetGR(context, uw::UNWIND_POINTER_REG, exception_object as uw::_Unwind_Ptr);\n+    // ...A more principled approach would be to provide the full definition of ARM's\n+    // _Unwind_Context in our libunwind bindings and fetch the required data from there directly,\n+    // bypassing DWARF compatibility functions.\n \n-    #[lang = \"eh_personality\"]\n-    #[no_mangle]\n-    pub extern \"C\" fn rust_eh_personality(version: c_int,\n-                                          actions: uw::_Unwind_Action,\n-                                          exception_class: uw::_Unwind_Exception_Class,\n-                                          ue_header: *mut uw::_Unwind_Exception,\n-                                          context: *mut uw::_Unwind_Context)\n-                                          -> uw::_Unwind_Reason_Code {\n-        unsafe { __gcc_personality_sj0(version, actions, exception_class, ue_header, context) }\n+    let eh_action = find_eh_action(context);\n+    if search_phase {\n+        match eh_action {\n+            EHAction::None |\n+            EHAction::Cleanup(_) => return continue_unwind(exception_object, context),\n+            EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n+            EHAction::Terminate => return uw::_URC_FAILURE,\n+        }\n+    } else {\n+        match eh_action {\n+            EHAction::None => return continue_unwind(exception_object, context),\n+            EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n+                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                uw::_Unwind_SetIP(context, lpad);\n+                return uw::_URC_INSTALL_CONTEXT;\n+            }\n+            EHAction::Terminate => return uw::_URC_FAILURE,\n+        }\n     }\n \n-    #[lang = \"eh_personality_catch\"]\n-    #[no_mangle]\n-    pub extern \"C\" fn rust_eh_personality_catch(version: c_int,\n-                                                actions: uw::_Unwind_Action,\n-                                                exception_class: uw::_Unwind_Exception_Class,\n-                                                ue_header: *mut uw::_Unwind_Exception,\n-                                                context: *mut uw::_Unwind_Context)\n-                                                -> uw::_Unwind_Reason_Code {\n-        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 {\n-            // search phase\n-            uw::_URC_HANDLER_FOUND // catch!\n+    // On ARM EHABI the personality routine is responsible for actually\n+    // unwinding a single stack frame before returning (ARM EHABI Sec. 6.1).\n+    unsafe fn continue_unwind(exception_object: *mut uw::_Unwind_Exception,\n+                              context: *mut uw::_Unwind_Context)\n+                              -> uw::_Unwind_Reason_Code {\n+        if __gnu_unwind_frame(exception_object, context) == uw::_URC_NO_REASON {\n+            uw::_URC_CONTINUE_UNWIND\n         } else {\n-            // cleanup phase\n-            unsafe { __gcc_personality_sj0(version, actions, exception_class, ue_header, context) }\n+            uw::_URC_FAILURE\n         }\n     }\n-}\n-\n-\n-// ARM EHABI uses a slightly different personality routine signature,\n-// but otherwise works the same.\n-#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]\n-pub mod eabi {\n-    use unwind as uw;\n-    use libc::c_int;\n-\n+    // defined in libgcc\n     extern \"C\" {\n-        fn __gcc_personality_v0(state: uw::_Unwind_State,\n-                                ue_header: *mut uw::_Unwind_Exception,\n+        fn __gnu_unwind_frame(exception_object: *mut uw::_Unwind_Exception,\n                                 context: *mut uw::_Unwind_Context)\n                                 -> uw::_Unwind_Reason_Code;\n     }\n+}\n \n-    #[lang = \"eh_personality\"]\n-    #[no_mangle]\n-    extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n-                                      ue_header: *mut uw::_Unwind_Exception,\n-                                      context: *mut uw::_Unwind_Context)\n-                                      -> uw::_Unwind_Reason_Code {\n-        unsafe { __gcc_personality_v0(state, ue_header, context) }\n-    }\n+unsafe fn find_eh_action(context: *mut uw::_Unwind_Context) -> EHAction {\n+    let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n+    let mut ip_before_instr: c_int = 0;\n+    let ip = uw::_Unwind_GetIPInfo(context, &mut ip_before_instr);\n+    let eh_context = EHContext {\n+        // The return address points 1 byte past the call instruction,\n+        // which could be in the next IP range in LSDA range table.\n+        ip: if ip_before_instr != 0 { ip } else { ip - 1 },\n+        func_start: uw::_Unwind_GetRegionStart(context),\n+        get_text_start: &|| uw::_Unwind_GetTextRelBase(context),\n+        get_data_start: &|| uw::_Unwind_GetDataRelBase(context),\n+    };\n+    eh::find_eh_action(lsda, &eh_context)\n+}\n \n-    #[lang = \"eh_personality_catch\"]\n-    #[no_mangle]\n-    pub extern \"C\" fn rust_eh_personality_catch(state: uw::_Unwind_State,\n-                                                ue_header: *mut uw::_Unwind_Exception,\n-                                                context: *mut uw::_Unwind_Context)\n-                                                -> uw::_Unwind_Reason_Code {\n-        // Backtraces on ARM will call the personality routine with\n-        // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n-        // we want to continue unwinding the stack, otherwise all our backtraces\n-        // would end at __rust_try.\n-        if (state as c_int & uw::_US_ACTION_MASK as c_int) ==\n-           uw::_US_VIRTUAL_UNWIND_FRAME as c_int &&\n-           (state as c_int & uw::_US_FORCE_UNWIND as c_int) == 0 {\n-            // search phase\n-            uw::_URC_HANDLER_FOUND // catch!\n-        } else {\n-            // cleanup phase\n-            unsafe { __gcc_personality_v0(state, ue_header, context) }\n-        }\n-    }\n+// *** Delete after a new snapshot ***\n+#[cfg(all(stage0, any(target_os = \"ios\", not(target_arch = \"arm\"))))]\n+#[lang = \"eh_personality_catch\"]\n+#[no_mangle]\n+pub unsafe extern \"C\" fn rust_eh_personality_catch(version: c_int,\n+                                                    actions: uw::_Unwind_Action,\n+                                                    exception_class: uw::_Unwind_Exception_Class,\n+                                                    ue_header: *mut uw::_Unwind_Exception,\n+                                                    context: *mut uw::_Unwind_Context)\n+                                                    -> uw::_Unwind_Reason_Code {\n+    rust_eh_personality(version, actions, exception_class, ue_header, context)\n+}\n+\n+// *** Delete after a new snapshot ***\n+#[cfg(all(stage0, target_arch = \"arm\", not(target_os = \"ios\")))]\n+#[lang = \"eh_personality_catch\"]\n+#[no_mangle]\n+pub unsafe extern \"C\" fn rust_eh_personality_catch(state: uw::_Unwind_State,\n+                                                    ue_header: *mut uw::_Unwind_Exception,\n+                                                    context: *mut uw::_Unwind_Context)\n+                                                    -> uw::_Unwind_Reason_Code {\n+    rust_eh_personality(state, ue_header, context)\n }\n \n // See docs in the `unwind` module."}, {"sha": "11dd9befe0a82e940da630f68317591ef960187b", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -101,6 +101,7 @@ pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n // Entry point for raising an exception, just delegates to the platform-specific\n // implementation.\n #[no_mangle]\n+#[unwind]\n pub unsafe extern \"C\" fn __rust_start_panic(data: usize, vtable: usize) -> u32 {\n     imp::panic(mem::transmute(raw::TraitObject {\n         data: data as *mut (),"}, {"sha": "3642e2488958e921fa8b1efd6a514858873a5de8", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -19,7 +19,7 @@ use alloc::boxed::Box;\n use core::any::Any;\n use core::intrinsics;\n use core::ptr;\n-use dwarf::eh;\n+use dwarf::eh::{EHContext, EHAction, find_eh_action};\n use windows as c;\n \n // Define our exception codes:\n@@ -81,6 +81,8 @@ pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {\n // This is considered acceptable, because the behavior of throwing exceptions\n // through a C ABI boundary is undefined.\n \n+// *** Delete after a new snapshot ***\n+#[cfg(stage0)]\n #[lang = \"eh_personality_catch\"]\n #[cfg(not(test))]\n unsafe extern \"C\" fn rust_eh_personality_catch(exceptionRecord: *mut c::EXCEPTION_RECORD,\n@@ -132,11 +134,17 @@ unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: c::LPVOID) -> ! {\n }\n \n unsafe fn find_landing_pad(dc: &c::DISPATCHER_CONTEXT) -> Option<usize> {\n-    let eh_ctx = eh::EHContext {\n-        ip: dc.ControlPc as usize,\n+    let eh_ctx = EHContext {\n+        // The return address points 1 byte past the call instruction,\n+        // which could be in the next IP range in LSDA range table.\n+        ip: dc.ControlPc as usize - 1,\n         func_start: dc.ImageBase as usize + (*dc.FunctionEntry).BeginAddress as usize,\n-        text_start: dc.ImageBase as usize,\n-        data_start: 0,\n+        get_text_start: &|| dc.ImageBase as usize,\n+        get_data_start: &|| unimplemented!(),\n     };\n-    eh::find_landing_pad(dc.HandlerData, &eh_ctx)\n+    match find_eh_action(dc.HandlerData, &eh_ctx) {\n+        EHAction::None => None,\n+        EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => Some(lpad),\n+        EHAction::Terminate => intrinsics::abort(),\n+    }\n }"}, {"sha": "c9247539990a9a8273508a2ea673a6ce6d65a0aa", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::fmt::Debug;\n+use std::sync::Arc;\n \n macro_rules! try_opt {\n     ($e:expr) => (\n@@ -45,6 +46,10 @@ pub enum DepNode<D: Clone + Debug> {\n     // in an extern crate.\n     MetaData(D),\n \n+    // Represents some artifact that we save to disk. Note that these\n+    // do not have a def-id as part of their identifier.\n+    WorkProduct(Arc<WorkProductId>),\n+\n     // Represents different phases in the compiler.\n     CrateReader,\n     CollectLanguageItems,\n@@ -189,6 +194,11 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransCrate => Some(TransCrate),\n             TransWriteMetadata => Some(TransWriteMetadata),\n             LinkBinary => Some(LinkBinary),\n+\n+            // work product names do not need to be mapped, because\n+            // they are always absolute.\n+            WorkProduct(ref id) => Some(WorkProduct(id.clone())),\n+\n             Hir(ref d) => op(d).map(Hir),\n             MetaData(ref d) => op(d).map(MetaData),\n             CollectItem(ref d) => op(d).map(CollectItem),\n@@ -229,3 +239,12 @@ impl<D: Clone + Debug> DepNode<D> {\n         }\n     }\n }\n+\n+/// A \"work product\" corresponds to a `.o` (or other) file that we\n+/// save in between runs. These ids do not have a DefId but rather\n+/// some independent path or string that persists between runs without\n+/// the need to be mapped or unmapped. (This ensures we can serialize\n+/// them even in the absence of a tcx.)\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct WorkProductId(pub String);\n+"}, {"sha": "bb027b11b45afa6bed09f25340ab648b6cbb8c00", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 106, "deletions": 9, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -9,42 +9,65 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n+use rustc_data_structures::fnv::FnvHashMap;\n+use session::config::OutputType;\n+use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n+use std::sync::Arc;\n \n-use super::dep_node::DepNode;\n+use super::dep_node::{DepNode, WorkProductId};\n use super::query::DepGraphQuery;\n use super::raii;\n use super::thread::{DepGraphThreadData, DepMessage};\n \n #[derive(Clone)]\n pub struct DepGraph {\n-    data: Rc<DepGraphThreadData>\n+    data: Rc<DepGraphData>\n+}\n+\n+struct DepGraphData {\n+    /// We send messages to the thread to let it build up the dep-graph\n+    /// from the current run.\n+    thread: DepGraphThreadData,\n+\n+    /// When we load, there may be `.o` files, cached mir, or other such\n+    /// things available to us. If we find that they are not dirty, we\n+    /// load the path to the file storing those work-products here into\n+    /// this map. We can later look for and extract that data.\n+    previous_work_products: RefCell<FnvHashMap<Arc<WorkProductId>, WorkProduct>>,\n+\n+    /// Work-products that we generate in this run.\n+    work_products: RefCell<FnvHashMap<Arc<WorkProductId>, WorkProduct>>,\n }\n \n impl DepGraph {\n     pub fn new(enabled: bool) -> DepGraph {\n         DepGraph {\n-            data: Rc::new(DepGraphThreadData::new(enabled))\n+            data: Rc::new(DepGraphData {\n+                thread: DepGraphThreadData::new(enabled),\n+                previous_work_products: RefCell::new(FnvHashMap()),\n+                work_products: RefCell::new(FnvHashMap())\n+            })\n         }\n     }\n \n     /// True if we are actually building a dep-graph. If this returns false,\n     /// then the other methods on this `DepGraph` will have no net effect.\n     #[inline]\n     pub fn enabled(&self) -> bool {\n-        self.data.enabled()\n+        self.data.thread.enabled()\n     }\n \n     pub fn query(&self) -> DepGraphQuery<DefId> {\n-        self.data.query()\n+        self.data.thread.query()\n     }\n \n     pub fn in_ignore<'graph>(&'graph self) -> raii::IgnoreTask<'graph> {\n-        raii::IgnoreTask::new(&self.data)\n+        raii::IgnoreTask::new(&self.data.thread)\n     }\n \n     pub fn in_task<'graph>(&'graph self, key: DepNode<DefId>) -> raii::DepTask<'graph> {\n-        raii::DepTask::new(&self.data, key)\n+        raii::DepTask::new(&self.data.thread, key)\n     }\n \n     pub fn with_ignore<OP,R>(&self, op: OP) -> R\n@@ -62,10 +85,84 @@ impl DepGraph {\n     }\n \n     pub fn read(&self, v: DepNode<DefId>) {\n-        self.data.enqueue(DepMessage::Read(v));\n+        self.data.thread.enqueue(DepMessage::Read(v));\n     }\n \n     pub fn write(&self, v: DepNode<DefId>) {\n-        self.data.enqueue(DepMessage::Write(v));\n+        self.data.thread.enqueue(DepMessage::Write(v));\n+    }\n+\n+    /// Indicates that a previous work product exists for `v`. This is\n+    /// invoked during initial start-up based on what nodes are clean\n+    /// (and what files exist in the incr. directory).\n+    pub fn insert_previous_work_product(&self, v: &Arc<WorkProductId>, data: WorkProduct) {\n+        debug!(\"insert_previous_work_product({:?}, {:?})\", v, data);\n+        self.data.previous_work_products.borrow_mut()\n+                                        .insert(v.clone(), data);\n+    }\n+\n+    /// Indicates that we created the given work-product in this run\n+    /// for `v`. This record will be preserved and loaded in the next\n+    /// run.\n+    pub fn insert_work_product(&self, v: &Arc<WorkProductId>, data: WorkProduct) {\n+        debug!(\"insert_work_product({:?}, {:?})\", v, data);\n+        self.data.work_products.borrow_mut()\n+                               .insert(v.clone(), data);\n     }\n+\n+    /// Check whether a previous work product exists for `v` and, if\n+    /// so, return the path that leads to it. Used to skip doing work.\n+    pub fn previous_work_product(&self, v: &Arc<WorkProductId>) -> Option<WorkProduct> {\n+        self.data.previous_work_products.borrow()\n+                                        .get(v)\n+                                        .cloned()\n+    }\n+\n+    /// Access the map of work-products created during this run. Only\n+    /// used during saving of the dep-graph.\n+    pub fn work_products(&self) -> Ref<FnvHashMap<Arc<WorkProductId>, WorkProduct>> {\n+        self.data.work_products.borrow()\n+    }\n+}\n+\n+/// A \"work product\" is an intermediate result that we save into the\n+/// incremental directory for later re-use. The primary example are\n+/// the object files that we save for each partition at code\n+/// generation time.\n+///\n+/// Each work product is associated with a dep-node, representing the\n+/// process that produced the work-product. If that dep-node is found\n+/// to be dirty when we load up, then we will delete the work-product\n+/// at load time. If the work-product is found to be clean, then we\n+/// will keep a record in the `previous_work_products` list.\n+///\n+/// In addition, work products have an associated hash. This hash is\n+/// an extra hash that can be used to decide if the work-product from\n+/// a previous compilation can be re-used (in addition to the dirty\n+/// edges check).\n+///\n+/// As the primary example, consider the object files we generate for\n+/// each partition. In the first run, we create partitions based on\n+/// the symbols that need to be compiled. For each partition P, we\n+/// hash the symbols in P and create a `WorkProduct` record associated\n+/// with `DepNode::TransPartition(P)`; the hash is the set of symbols\n+/// in P.\n+///\n+/// The next time we compile, if the `DepNode::TransPartition(P)` is\n+/// judged to be clean (which means none of the things we read to\n+/// generate the partition were found to be dirty), it will be loaded\n+/// into previous work products. We will then regenerate the set of\n+/// symbols in the partition P and hash them (note that new symbols\n+/// may be added -- for example, new monomorphizations -- even if\n+/// nothing in P changed!). We will compare that hash against the\n+/// previous hash. If it matches up, we can reuse the object file.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct WorkProduct {\n+    /// Extra hash used to decide if work-product is still suitable;\n+    /// note that this is *not* a hash of the work-product itself.\n+    /// See documentation on `WorkProduct` type for an example.\n+    pub input_hash: u64,\n+\n+    /// Saved files associated with this CGU\n+    pub saved_files: Vec<(OutputType, String)>,\n }"}, {"sha": "a499cb10f2325d3032f72d58b106ef18a5559d10", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -20,7 +20,9 @@ mod visit;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::DepNode;\n+pub use self::dep_node::WorkProductId;\n pub use self::graph::DepGraph;\n+pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n pub use self::visit::visit_all_items_in_krate;\n pub use self::raii::DepTask;"}, {"sha": "74e2c90503cd37fd66477a45e7f024eb485e2480", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -23,7 +23,7 @@ code example:\n #[deny(const_err)]\n \n const X: i32 = 42 / 0;\n-// error: attempted to divide by zero in a constant expression\n+// error: attempt to divide by zero in a constant expression\n ```\n \"##,\n "}, {"sha": "aded220c0cdfe6893c854a8c734a560606cd6bff", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 69, "deletions": 189, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -94,11 +94,14 @@ pub trait Visitor<'v> : Sized {\n \n     ///////////////////////////////////////////////////////////////////////////\n \n+    fn visit_id(&mut self, _node_id: NodeId) {\n+        // Nothing to do.\n+    }\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n-    fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) {\n-        walk_mod(self, m)\n+    fn visit_mod(&mut self, m: &'v Mod, _s: Span, n: NodeId) {\n+        walk_mod(self, m, n)\n     }\n     fn visit_foreign_item(&mut self, i: &'v ForeignItem) {\n         walk_foreign_item(self, i)\n@@ -135,8 +138,8 @@ pub trait Visitor<'v> : Sized {\n     fn visit_where_predicate(&mut self, predicate: &'v WherePredicate) {\n         walk_where_predicate(self, predicate)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, _: NodeId) {\n-        walk_fn(self, fk, fd, b, s)\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, id: NodeId) {\n+        walk_fn(self, fk, fd, b, s, id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n         walk_trait_item(self, ti)\n@@ -157,7 +160,7 @@ pub trait Visitor<'v> : Sized {\n                           s: &'v VariantData,\n                           _: Name,\n                           _: &'v Generics,\n-                          _: NodeId,\n+                          _parent_id: NodeId,\n                           _: Span) {\n         walk_struct_def(self, s)\n     }\n@@ -225,24 +228,28 @@ pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n }\n \n pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef) {\n+    visitor.visit_id(macro_def.id);\n     visitor.visit_name(macro_def.span, macro_def.name);\n     walk_opt_name(visitor, macro_def.span, macro_def.imported_from);\n     walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n \n-pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n+pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod, mod_node_id: NodeId) {\n+    visitor.visit_id(mod_node_id);\n     for &item_id in &module.item_ids {\n         visitor.visit_nested_item(item_id);\n     }\n }\n \n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n+    visitor.visit_id(local.id);\n     visitor.visit_pat(&local.pat);\n     walk_list!(visitor, visit_ty, &local.ty);\n     walk_list!(visitor, visit_expr, &local.init);\n }\n \n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n+    visitor.visit_id(lifetime.id);\n     visitor.visit_name(lifetime.span, lifetime.name);\n }\n \n@@ -263,6 +270,7 @@ pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef)\n     where V: Visitor<'v>\n {\n+    visitor.visit_id(trait_ref.ref_id);\n     visitor.visit_path(&trait_ref.path, trait_ref.ref_id)\n }\n \n@@ -271,9 +279,11 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_name(item.span, item.name);\n     match item.node {\n         ItemExternCrate(opt_name) => {\n+            visitor.visit_id(item.id);\n             walk_opt_name(visitor, item.span, opt_name)\n         }\n         ItemUse(ref vp) => {\n+            visitor.visit_id(item.id);\n             match vp.node {\n                 ViewPathSimple(name, ref path) => {\n                     visitor.visit_name(vp.span, name);\n@@ -292,6 +302,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemStatic(ref typ, _, ref expr) |\n         ItemConst(ref typ, ref expr) => {\n+            visitor.visit_id(item.id);\n             visitor.visit_ty(typ);\n             visitor.visit_expr(expr);\n         }\n@@ -309,33 +320,41 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                              item.id)\n         }\n         ItemMod(ref module) => {\n+            // visit_mod() takes care of visiting the Item's NodeId\n             visitor.visit_mod(module, item.span, item.id)\n         }\n         ItemForeignMod(ref foreign_module) => {\n+            visitor.visit_id(item.id);\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n         ItemTy(ref typ, ref type_parameters) => {\n+            visitor.visit_id(item.id);\n             visitor.visit_ty(typ);\n             visitor.visit_generics(type_parameters)\n         }\n         ItemEnum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n+            // visit_enum_def() takes care of visiting the Item's NodeId\n             visitor.visit_enum_def(enum_definition, type_parameters, item.id, item.span)\n         }\n         ItemDefaultImpl(_, ref trait_ref) => {\n+            visitor.visit_id(item.id);\n             visitor.visit_trait_ref(trait_ref)\n         }\n         ItemImpl(_, _, ref type_parameters, ref opt_trait_reference, ref typ, ref impl_items) => {\n+            visitor.visit_id(item.id);\n             visitor.visit_generics(type_parameters);\n             walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n             visitor.visit_ty(typ);\n             walk_list!(visitor, visit_impl_item, impl_items);\n         }\n         ItemStruct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n+            visitor.visit_id(item.id);\n             visitor.visit_variant_data(struct_definition, item.name, generics, item.id, item.span);\n         }\n         ItemTrait(_, ref generics, ref bounds, ref methods) => {\n+            visitor.visit_id(item.id);\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n             walk_list!(visitor, visit_trait_item, methods);\n@@ -348,6 +367,7 @@ pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                          enum_definition: &'v EnumDef,\n                                          generics: &'v Generics,\n                                          item_id: NodeId) {\n+    visitor.visit_id(item_id);\n     walk_list!(visitor,\n                visit_variant,\n                &enum_definition.variants,\n@@ -358,18 +378,20 @@ pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                         variant: &'v Variant,\n                                         generics: &'v Generics,\n-                                        item_id: NodeId) {\n+                                        parent_item_id: NodeId) {\n     visitor.visit_name(variant.span, variant.node.name);\n     visitor.visit_variant_data(&variant.node.data,\n                                variant.node.name,\n                                generics,\n-                               item_id,\n+                               parent_item_id,\n                                variant.span);\n     walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n+    visitor.visit_id(typ.id);\n+\n     match typ.node {\n         TyVec(ref ty) => {\n             visitor.visit_ty(ty)\n@@ -421,6 +443,7 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                _prefix: &'v Path,\n                                                item: &'v PathListItem) {\n+    visitor.visit_id(item.node.id());\n     walk_opt_name(visitor, item.span, item.node.name());\n     walk_opt_name(visitor, item.span, item.node.rename());\n }\n@@ -450,11 +473,13 @@ pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                    type_binding: &'v TypeBinding) {\n+    visitor.visit_id(type_binding.id);\n     visitor.visit_name(type_binding.span, type_binding.name);\n     visitor.visit_ty(&type_binding.ty);\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n+    visitor.visit_id(pattern.id);\n     match pattern.node {\n         PatKind::TupleStruct(ref path, ref children, _) => {\n             visitor.visit_path(path, pattern.id);\n@@ -499,6 +524,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n }\n \n pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem) {\n+    visitor.visit_id(foreign_item.id);\n     visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_name(foreign_item.span, foreign_item.name);\n \n@@ -526,11 +552,13 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v TyPar\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n     for param in &generics.ty_params {\n+        visitor.visit_id(param.id);\n         visitor.visit_name(param.span, param.name);\n         walk_list!(visitor, visit_ty_param_bound, &param.bounds);\n         walk_list!(visitor, visit_ty, &param.default);\n     }\n     walk_list!(visitor, visit_lifetime_def, &generics.lifetimes);\n+    visitor.visit_id(generics.where_clause.id);\n     walk_list!(visitor, visit_where_predicate, &generics.where_clause.predicates);\n }\n \n@@ -557,6 +585,7 @@ pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n                                                       ref path,\n                                                       ref ty,\n                                                       ..}) => {\n+            visitor.visit_id(id);\n             visitor.visit_path(path, id);\n             visitor.visit_ty(ty);\n         }\n@@ -571,6 +600,7 @@ pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionR\n \n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n     for argument in &function_declaration.inputs {\n+        visitor.visit_id(argument.id);\n         visitor.visit_pat(&argument.pat);\n         visitor.visit_ty(&argument.ty)\n     }\n@@ -579,6 +609,7 @@ pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &\n \n pub fn walk_fn_decl_nopat<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n     for argument in &function_declaration.inputs {\n+        visitor.visit_id(argument.id);\n         visitor.visit_ty(&argument.ty)\n     }\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n@@ -600,7 +631,9 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n                                    function_kind: FnKind<'v>,\n                                    function_declaration: &'v FnDecl,\n                                    function_body: &'v Block,\n-                                   _span: Span) {\n+                                   _span: Span,\n+                                   id: NodeId) {\n+    visitor.visit_id(id);\n     walk_fn_decl(visitor, function_declaration);\n     walk_fn_kind(visitor, function_kind);\n     visitor.visit_block(function_body)\n@@ -611,10 +644,12 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     match trait_item.node {\n         ConstTraitItem(ref ty, ref default) => {\n+            visitor.visit_id(trait_item.id);\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, default);\n         }\n         MethodTraitItem(ref sig, None) => {\n+            visitor.visit_id(trait_item.id);\n             visitor.visit_generics(&sig.generics);\n             walk_fn_decl(visitor, &sig.decl);\n         }\n@@ -629,6 +664,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n                              trait_item.id);\n         }\n         TypeTraitItem(ref bounds, ref default) => {\n+            visitor.visit_id(trait_item.id);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n             walk_list!(visitor, visit_ty, default);\n         }\n@@ -641,6 +677,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     walk_list!(visitor, visit_attribute, &impl_item.attrs);\n     match impl_item.node {\n         ImplItemKind::Const(ref ty, ref expr) => {\n+            visitor.visit_id(impl_item.id);\n             visitor.visit_ty(ty);\n             visitor.visit_expr(expr);\n         }\n@@ -655,31 +692,40 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n                              impl_item.id);\n         }\n         ImplItemKind::Type(ref ty) => {\n+            visitor.visit_id(impl_item.id);\n             visitor.visit_ty(ty);\n         }\n     }\n }\n \n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v VariantData) {\n+    visitor.visit_id(struct_definition.id());\n     walk_list!(visitor, visit_struct_field, struct_definition.fields());\n }\n \n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v StructField) {\n+    visitor.visit_id(struct_field.id);\n     visitor.visit_vis(&struct_field.vis);\n     visitor.visit_name(struct_field.span, struct_field.name);\n     visitor.visit_ty(&struct_field.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.attrs);\n }\n \n pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n+    visitor.visit_id(block.id);\n     walk_list!(visitor, visit_stmt, &block.stmts);\n     walk_list!(visitor, visit_expr, &block.expr);\n }\n \n pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n     match statement.node {\n-        StmtDecl(ref declaration, _) => visitor.visit_decl(declaration),\n-        StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n+        StmtDecl(ref declaration, id) => {\n+            visitor.visit_id(id);\n+            visitor.visit_decl(declaration)\n+        }\n+        StmtExpr(ref expression, id) |\n+        StmtSemi(ref expression, id) => {\n+            visitor.visit_id(id);\n             visitor.visit_expr(expression)\n         }\n     }\n@@ -693,6 +739,7 @@ pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n }\n \n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n+    visitor.visit_id(expression.id);\n     match expression.node {\n         ExprBox(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n@@ -815,11 +862,12 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n \n pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n     if let Visibility::Restricted { ref path, id } = *vis {\n+        visitor.visit_id(id);\n         visitor.visit_path(path, id)\n     }\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq)]\n pub struct IdRange {\n     pub min: NodeId,\n     pub max: NodeId,\n@@ -837,16 +885,18 @@ impl IdRange {\n         self.min >= self.max\n     }\n \n+    pub fn contains(&self, id: NodeId) -> bool {\n+        id >= self.min && id < self.max\n+    }\n+\n     pub fn add(&mut self, id: NodeId) {\n         self.min = cmp::min(self.min, id);\n         self.max = cmp::max(self.max, id + 1);\n     }\n-}\n \n-pub trait IdVisitingOperation {\n-    fn visit_id(&mut self, node_id: NodeId);\n }\n \n+\n pub struct IdRangeComputingVisitor {\n     pub result: IdRange,\n }\n@@ -861,190 +911,20 @@ impl IdRangeComputingVisitor {\n     }\n }\n \n-impl IdVisitingOperation for IdRangeComputingVisitor {\n+impl<'v> Visitor<'v> for IdRangeComputingVisitor {\n     fn visit_id(&mut self, id: NodeId) {\n         self.result.add(id);\n     }\n }\n \n-pub struct IdVisitor<'a, O: 'a> {\n-    operation: &'a mut O,\n-\n-    // In general, the id visitor visits the contents of an item, but\n-    // not including nested trait/impl items, nor other nested items.\n-    // The base visitor itself always skips nested items, but not\n-    // trait/impl items. This means in particular that if you start by\n-    // visiting a trait or an impl, you should not visit the\n-    // trait/impl items respectively.  This is handled by setting\n-    // `skip_members` to true when `visit_item` is on the stack. This\n-    // way, if the user begins by calling `visit_trait_item`, we will\n-    // visit the trait item, but if they begin with `visit_item`, we\n-    // won't visit the (nested) trait items.\n-    skip_members: bool,\n-}\n-\n-impl<'a, O: IdVisitingOperation> IdVisitor<'a, O> {\n-    pub fn new(operation: &'a mut O) -> IdVisitor<'a, O> {\n-        IdVisitor { operation: operation, skip_members: false }\n-    }\n-\n-    fn visit_generics_helper(&mut self, generics: &Generics) {\n-        for type_parameter in generics.ty_params.iter() {\n-            self.operation.visit_id(type_parameter.id)\n-        }\n-        for lifetime in &generics.lifetimes {\n-            self.operation.visit_id(lifetime.lifetime.id)\n-        }\n-    }\n-}\n-\n-impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n-    fn visit_mod(&mut self, module: &Mod, _: Span, node_id: NodeId) {\n-        self.operation.visit_id(node_id);\n-        walk_mod(self, module)\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n-        self.operation.visit_id(foreign_item.id);\n-        walk_foreign_item(self, foreign_item)\n-    }\n-\n-    fn visit_item(&mut self, item: &Item) {\n-        assert!(!self.skip_members);\n-        self.skip_members = true;\n-\n-        self.operation.visit_id(item.id);\n-        match item.node {\n-            ItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathSimple(_, _) |\n-                    ViewPathGlob(_) => {}\n-                    ViewPathList(_, ref paths) => {\n-                        for path in paths {\n-                            self.operation.visit_id(path.node.id())\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-        walk_item(self, item);\n-\n-        self.skip_members = false;\n-    }\n-\n-    fn visit_local(&mut self, local: &Local) {\n-        self.operation.visit_id(local.id);\n-        walk_local(self, local)\n-    }\n-\n-    fn visit_block(&mut self, block: &Block) {\n-        self.operation.visit_id(block.id);\n-        walk_block(self, block)\n-    }\n-\n-    fn visit_stmt(&mut self, statement: &Stmt) {\n-        self.operation.visit_id(statement.node.id());\n-        walk_stmt(self, statement)\n-    }\n-\n-    fn visit_pat(&mut self, pattern: &Pat) {\n-        self.operation.visit_id(pattern.id);\n-        walk_pat(self, pattern)\n-    }\n-\n-    fn visit_expr(&mut self, expression: &Expr) {\n-        self.operation.visit_id(expression.id);\n-        walk_expr(self, expression)\n-    }\n-\n-    fn visit_ty(&mut self, typ: &Ty) {\n-        self.operation.visit_id(typ.id);\n-        walk_ty(self, typ)\n-    }\n-\n-    fn visit_generics(&mut self, generics: &Generics) {\n-        self.visit_generics_helper(generics);\n-        walk_generics(self, generics)\n-    }\n-\n-    fn visit_fn(&mut self,\n-                function_kind: FnKind<'v>,\n-                function_declaration: &'v FnDecl,\n-                block: &'v Block,\n-                span: Span,\n-                node_id: NodeId) {\n-        self.operation.visit_id(node_id);\n-\n-        match function_kind {\n-            FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n-                self.visit_generics_helper(generics)\n-            }\n-            FnKind::Method(_, sig, _, _) => {\n-                self.visit_generics_helper(&sig.generics)\n-            }\n-            FnKind::Closure(_) => {}\n-        }\n-\n-        for argument in &function_declaration.inputs {\n-            self.operation.visit_id(argument.id)\n-        }\n-\n-        walk_fn(self, function_kind, function_declaration, block, span);\n-    }\n-\n-    fn visit_struct_field(&mut self, struct_field: &StructField) {\n-        self.operation.visit_id(struct_field.id);\n-        walk_struct_field(self, struct_field)\n-    }\n-\n-    fn visit_variant_data(&mut self,\n-                          struct_def: &VariantData,\n-                          _: Name,\n-                          _: &Generics,\n-                          _: NodeId,\n-                          _: Span) {\n-        self.operation.visit_id(struct_def.id());\n-        walk_struct_def(self, struct_def);\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &TraitItem) {\n-        if !self.skip_members {\n-            self.operation.visit_id(ti.id);\n-            walk_trait_item(self, ti);\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &ImplItem) {\n-        if !self.skip_members {\n-            self.operation.visit_id(ii.id);\n-            walk_impl_item(self, ii);\n-        }\n-    }\n-\n-    fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n-        self.operation.visit_id(lifetime.id);\n-    }\n-\n-    fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n-        self.visit_lifetime(&def.lifetime);\n-    }\n-\n-    fn visit_trait_ref(&mut self, trait_ref: &TraitRef) {\n-        self.operation.visit_id(trait_ref.ref_id);\n-        walk_trait_ref(self, trait_ref);\n-    }\n-}\n-\n /// Computes the id range for a single fn body, ignoring nested items.\n pub fn compute_id_range_for_fn_body(fk: FnKind,\n                                     decl: &FnDecl,\n                                     body: &Block,\n                                     sp: Span,\n                                     id: NodeId)\n                                     -> IdRange {\n-    let mut visitor = IdRangeComputingVisitor { result: IdRange::max() };\n-    let mut id_visitor = IdVisitor::new(&mut visitor);\n-    id_visitor.visit_fn(fk, decl, body, sp, id);\n-    id_visitor.operation.result\n+    let mut visitor = IdRangeComputingVisitor::new();\n+    visitor.visit_fn(fk, decl, body, sp, id);\n+    visitor.result()\n }"}, {"sha": "b3f222b22e8915314c1b1d7883b00a22aa8ac935", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -197,7 +197,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n                 b: &'ast Block, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);\n-        intravisit::walk_fn(self, fk, fd, b, s);\n+        intravisit::walk_fn(self, fk, fd, b, s, id);\n     }\n \n     fn visit_block(&mut self, block: &'ast Block) {"}, {"sha": "aed3613f44ed489328e3df2f1a6ae1013fafd684", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -32,6 +32,7 @@ use hir::print as pprust;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n+use std::cmp;\n use std::io;\n use std::mem;\n \n@@ -127,7 +128,10 @@ impl<'ast> MapEntry<'ast> {\n             EntryStructCtor(id, _) => id,\n             EntryLifetime(id, _) => id,\n             EntryTyParam(id, _) => id,\n-            _ => return None\n+\n+            NotPresent |\n+            RootCrate |\n+            RootInlinedParent(_) => return None,\n         })\n     }\n \n@@ -196,6 +200,10 @@ pub struct Map<'ast> {\n     map: RefCell<Vec<MapEntry<'ast>>>,\n \n     definitions: RefCell<Definitions>,\n+\n+    /// All NodeIds that are numerically greater or equal to this value come\n+    /// from inlined items.\n+    local_node_id_watermark: NodeId,\n }\n \n impl<'ast> Map<'ast> {\n@@ -550,6 +558,13 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    pub fn expect_inlined_item(&self, id: NodeId) -> &'ast InlinedItem {\n+        match self.find_entry(id) {\n+            Some(RootInlinedParent(inlined_item)) => inlined_item,\n+            _ => bug!(\"expected inlined item, found {}\", self.node_to_string(id)),\n+        }\n+    }\n+\n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n@@ -649,6 +664,10 @@ impl<'ast> Map<'ast> {\n     pub fn node_to_user_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id, false)\n     }\n+\n+    pub fn is_inlined(&self, id: NodeId) -> bool {\n+        id >= self.local_node_id_watermark\n+    }\n }\n \n pub struct NodesMatchingSuffix<'a, 'ast:'a> {\n@@ -765,13 +784,37 @@ pub trait FoldOps {\n }\n \n /// A Folder that updates IDs and Span's according to fold_ops.\n-struct IdAndSpanUpdater<F> {\n-    fold_ops: F\n+pub struct IdAndSpanUpdater<F> {\n+    fold_ops: F,\n+    min_id_assigned: NodeId,\n+    max_id_assigned: NodeId,\n+}\n+\n+impl<F: FoldOps> IdAndSpanUpdater<F> {\n+    pub fn new(fold_ops: F) -> IdAndSpanUpdater<F> {\n+        IdAndSpanUpdater {\n+            fold_ops: fold_ops,\n+            min_id_assigned: ::std::u32::MAX,\n+            max_id_assigned: ::std::u32::MIN,\n+        }\n+    }\n+\n+    pub fn id_range(&self) -> intravisit::IdRange {\n+        intravisit::IdRange {\n+            min: self.min_id_assigned,\n+            max: self.max_id_assigned + 1,\n+        }\n+    }\n }\n \n impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n     fn new_id(&mut self, id: NodeId) -> NodeId {\n-        self.fold_ops.new_id(id)\n+        let id = self.fold_ops.new_id(id);\n+\n+        self.min_id_assigned = cmp::min(self.min_id_assigned, id);\n+        self.max_id_assigned = cmp::max(self.max_id_assigned, id);\n+\n+        id\n     }\n \n     fn new_span(&mut self, span: Span) -> Span {\n@@ -802,11 +845,14 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n+    let local_node_id_watermark = map.len() as NodeId;\n+\n     Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: RefCell::new(map),\n         definitions: RefCell::new(definitions),\n+        local_node_id_watermark: local_node_id_watermark\n     }\n }\n \n@@ -818,7 +864,7 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                                           ii: InlinedItem,\n                                           fold_ops: F)\n                                           -> &'ast InlinedItem {\n-    let mut fld = IdAndSpanUpdater { fold_ops: fold_ops };\n+    let mut fld = IdAndSpanUpdater::new(fold_ops);\n     let ii = match ii {\n         II::Item(i) => II::Item(i.map(|i| fld.fold_item(i))),\n         II::TraitItem(d, ti) => {\n@@ -835,6 +881,12 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     let ii = map.forest.inlined_items.alloc(ii);\n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n \n+    // Assert that the ii_parent_id is the last NodeId in our reserved range\n+    assert!(ii_parent_id == fld.max_id_assigned);\n+    // Assert that we did not violate the invariant that all inlined HIR items\n+    // have NodeIds greater than or equal to `local_node_id_watermark`\n+    assert!(fld.min_id_assigned >= map.local_node_id_watermark);\n+\n     let defs = &mut *map.definitions.borrow_mut();\n     let mut def_collector = DefCollector::extend(ii_parent_id,\n                                                  parent_def_path.clone(),"}, {"sha": "9212fda6502532e1ab5fc75e466fac752334ad14", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -36,7 +36,7 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use util::nodemap::{NodeMap, FnvHashSet};\n \n-use syntax_pos::{mk_sp, Span, ExpnId};\n+use syntax_pos::{BytePos, mk_sp, Span, ExpnId};\n use syntax::codemap::{self, respan, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n@@ -326,6 +326,38 @@ impl Generics {\n     pub fn is_parameterized(&self) -> bool {\n         self.is_lt_parameterized() || self.is_type_parameterized()\n     }\n+\n+    // Does return a span which includes lifetimes and type parameters,\n+    // not where clause.\n+    pub fn span(&self) -> Option<Span> {\n+        if !self.is_parameterized() {\n+            None\n+        } else {\n+            let mut span: Option<Span> = None;\n+            for lifetime in self.lifetimes.iter() {\n+                if let Some(ref mut span) = span {\n+                    let life_span = lifetime.lifetime.span;\n+                    span.hi = if span.hi > life_span.hi { span.hi } else { life_span.hi };\n+                    span.lo = if span.lo < life_span.lo { span.lo } else { life_span.lo };\n+                } else {\n+                    span = Some(lifetime.lifetime.span.clone());\n+                }\n+            }\n+            for ty_param in self.ty_params.iter() {\n+                if let Some(ref mut span) = span {\n+                    span.lo = if span.lo < ty_param.span.lo { span.lo } else { ty_param.span.lo };\n+                    span.hi = if span.hi > ty_param.span.hi { span.hi } else { ty_param.span.hi };\n+                } else {\n+                    span = Some(ty_param.span.clone());\n+                }\n+            }\n+            if let Some(ref mut span) = span {\n+                span.lo = span.lo - BytePos(1);\n+                span.hi = span.hi + BytePos(1);\n+            }\n+            span\n+        }\n+    }\n }\n \n /// A `where` clause in a definition\n@@ -1362,9 +1394,9 @@ pub enum ViewPath_ {\n /// TraitRef's appear in impls.\n ///\n /// resolve maps each TraitRef's ref_id to its defining trait; that's all\n-/// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n-/// If this impl is an ItemImpl, the impl_id is redundant (it could be the\n-/// same as the impl's node id).\n+/// that the ref_id is for. Note that ref_id's value is not the NodeId of the\n+/// trait being referred to but just a unique NodeId that serves as a key\n+/// within the DefMap.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitRef {\n     pub path: Path,"}, {"sha": "125f815feda6fa6d902bea13a91be128cb1a603c", "filename": "src/librustc/infer/bivariate.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fbivariate.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -32,22 +32,27 @@ use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n-pub struct Bivariate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'gcx, 'tcx>\n+pub struct Bivariate<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+    a_is_expected: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Bivariate<'a, 'gcx, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Bivariate<'a, 'gcx, 'tcx> {\n-        Bivariate { fields: fields }\n+impl<'combine, 'infcx, 'gcx, 'tcx> Bivariate<'combine, 'infcx, 'gcx, 'tcx> {\n+    pub fn new(fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n+        -> Bivariate<'combine, 'infcx, 'gcx, 'tcx>\n+    {\n+        Bivariate { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Bivariate<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n+    for Bivariate<'combine, 'infcx, 'gcx, 'tcx>\n+{\n     fn tag(&self) -> &'static str { \"Bivariate\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              variance: ty::Variance,\n@@ -86,12 +91,12 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Bivariate<'a, 'gcx, 'tcx>\n             }\n \n             (&ty::TyInfer(TyVar(a_id)), _) => {\n-                self.fields.instantiate(b, BiTo, a_id)?;\n+                self.fields.instantiate(b, BiTo, a_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, BiTo, b_id)?;\n+                self.fields.instantiate(a, BiTo, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n "}, {"sha": "b4818f963b3ba76e4b6ae71f2ad4f381dbbd1616", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -52,21 +52,20 @@ use syntax::ast;\n use syntax_pos::Span;\n \n #[derive(Clone)]\n-pub struct CombineFields<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    pub a_is_expected: bool,\n+pub struct CombineFields<'infcx, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n+    pub infcx: &'infcx InferCtxt<'infcx, 'gcx, 'tcx>,\n     pub trace: TypeTrace<'tcx>,\n     pub cause: Option<ty::relate::Cause>,\n     pub obligations: PredicateObligations<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n     pub fn super_combine_tys<R>(&self,\n                                 relation: &mut R,\n                                 a: Ty<'tcx>,\n                                 b: Ty<'tcx>)\n                                 -> RelateResult<'tcx, Ty<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>\n+        where R: TypeRelation<'infcx, 'gcx, 'tcx>\n     {\n         let a_is_expected = relation.a_is_expected();\n \n@@ -150,42 +149,36 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn switch_expected(&self) -> CombineFields<'a, 'gcx, 'tcx> {\n-        CombineFields {\n-            a_is_expected: !self.a_is_expected,\n-            ..(*self).clone()\n-        }\n-    }\n-\n-    pub fn equate(&self) -> Equate<'a, 'gcx, 'tcx> {\n-        Equate::new(self.clone())\n+    pub fn equate<'a>(&'a mut self, a_is_expected: bool) -> Equate<'a, 'infcx, 'gcx, 'tcx> {\n+        Equate::new(self, a_is_expected)\n     }\n \n-    pub fn bivariate(&self) -> Bivariate<'a, 'gcx, 'tcx> {\n-        Bivariate::new(self.clone())\n+    pub fn bivariate<'a>(&'a mut self, a_is_expected: bool) -> Bivariate<'a, 'infcx, 'gcx, 'tcx> {\n+        Bivariate::new(self, a_is_expected)\n     }\n \n-    pub fn sub(&self) -> Sub<'a, 'gcx, 'tcx> {\n-        Sub::new(self.clone())\n+    pub fn sub<'a>(&'a mut self, a_is_expected: bool) -> Sub<'a, 'infcx, 'gcx, 'tcx> {\n+        Sub::new(self, a_is_expected)\n     }\n \n-    pub fn lub(&self) -> Lub<'a, 'gcx, 'tcx> {\n-        Lub::new(self.clone())\n+    pub fn lub<'a>(&'a mut self, a_is_expected: bool) -> Lub<'a, 'infcx, 'gcx, 'tcx> {\n+        Lub::new(self, a_is_expected)\n     }\n \n-    pub fn glb(&self) -> Glb<'a, 'gcx, 'tcx> {\n-        Glb::new(self.clone())\n+    pub fn glb<'a>(&'a mut self, a_is_expected: bool) -> Glb<'a, 'infcx, 'gcx, 'tcx> {\n+        Glb::new(self, a_is_expected)\n     }\n \n-    pub fn instantiate(&self,\n+    pub fn instantiate(&mut self,\n                        a_ty: Ty<'tcx>,\n                        dir: RelationDir,\n-                       b_vid: ty::TyVid)\n+                       b_vid: ty::TyVid,\n+                       a_is_expected: bool)\n                        -> RelateResult<'tcx, ()>\n     {\n         let mut stack = Vec::new();\n@@ -255,10 +248,11 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // to associate causes/spans with each of the relations in\n             // the stack to get this right.\n             match dir {\n-                BiTo => self.bivariate().relate(&a_ty, &b_ty),\n-                EqTo => self.equate().relate(&a_ty, &b_ty),\n-                SubtypeOf => self.sub().relate(&a_ty, &b_ty),\n-                SupertypeOf => self.sub().relate_with_variance(ty::Contravariant, &a_ty, &b_ty),\n+                BiTo => self.bivariate(a_is_expected).relate(&a_ty, &b_ty),\n+                EqTo => self.equate(a_is_expected).relate(&a_ty, &b_ty),\n+                SubtypeOf => self.sub(a_is_expected).relate(&a_ty, &b_ty),\n+                SupertypeOf => self.sub(a_is_expected).relate_with_variance(\n+                    ty::Contravariant, &a_ty, &b_ty),\n             }?;\n         }\n "}, {"sha": "e06f7303acb2927ac99950a43b087c39f9c6c7ac", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -15,29 +15,29 @@ use super::type_variable::{EqTo};\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use traits::PredicateObligations;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n-pub struct Equate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'gcx, 'tcx>\n+pub struct Equate<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+    a_is_expected: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Equate<'a, 'gcx, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Equate<'a, 'gcx, 'tcx> {\n-        Equate { fields: fields }\n-    }\n-\n-    pub fn obligations(self) -> PredicateObligations<'tcx> {\n-        self.fields.obligations\n+impl<'combine, 'infcx, 'gcx, 'tcx> Equate<'combine, 'infcx, 'gcx, 'tcx> {\n+    pub fn new(fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n+        -> Equate<'combine, 'infcx, 'gcx, 'tcx>\n+    {\n+        Equate { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Equate<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n+    for Equate<'combine, 'infcx, 'gcx, 'tcx>\n+{\n     fn tag(&self) -> &'static str { \"Equate\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              _: ty::Variance,\n@@ -63,12 +63,12 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Equate<'a, 'gcx, 'tcx> {\n             }\n \n             (&ty::TyInfer(TyVar(a_id)), _) => {\n-                self.fields.instantiate(b, EqTo, a_id)?;\n+                self.fields.instantiate(b, EqTo, a_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, EqTo, b_id)?;\n+                self.fields.instantiate(a, EqTo, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n@@ -93,7 +93,7 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Equate<'a, 'gcx, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>\n     {\n-        self.fields.higher_ranked_sub(a, b)?;\n-        self.fields.higher_ranked_sub(b, a)\n+        self.fields.higher_ranked_sub(a, b, self.a_is_expected)?;\n+        self.fields.higher_ranked_sub(b, a, self.a_is_expected)\n     }\n }"}, {"sha": "511cc32d2e1e6cfeb47d00fa65076fba5445de64", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 93, "deletions": 143, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -83,7 +83,7 @@ use hir::def_id::DefId;\n use infer::{self, TypeOrigin};\n use middle::region;\n use ty::subst;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, ReFree};\n use ty::error::TypeError;\n \n@@ -462,52 +462,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn report_type_error(&self,\n-                         trace: TypeTrace<'tcx>,\n-                         terr: &TypeError<'tcx>)\n-                         -> DiagnosticBuilder<'tcx> {\n-        let (expected, found) = match self.values_str(&trace.values) {\n-            Some(v) => v,\n-            None => {\n-                return self.tcx.sess.diagnostic().struct_dummy(); /* derived error */\n-            }\n-        };\n-\n-        let is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n-            values.expected.is_primitive() && values.found.is_primitive()\n-        } else {\n-            false\n-        };\n-\n-        let mut err = struct_span_err!(self.tcx.sess,\n-                                       trace.origin.span(),\n-                                       E0308,\n-                                       \"{}\",\n-                                       trace.origin);\n-\n-        if !is_simple_error || check_old_school() {\n-            err.note_expected_found(&\"type\", &expected, &found);\n-        }\n-\n-        err.span_label(trace.origin.span(), &terr);\n-\n-        self.check_and_note_conflicting_crates(&mut err, terr, trace.origin.span());\n-\n-        match trace.origin {\n-            TypeOrigin::MatchExpressionArm(_, arm_span, source) => match source {\n-                hir::MatchSource::IfLetDesugar{..} => {\n-                    err.span_note(arm_span, \"`if let` arm with an incompatible type\");\n-                }\n-                _ => {\n-                    err.span_note(arm_span, \"match arm with an incompatible type\");\n-                }\n-            },\n-            _ => ()\n-        }\n-\n-        err\n-    }\n-\n     /// Adds a note if the types come from similarly named crates\n     fn check_and_note_conflicting_crates(&self,\n                                          err: &mut DiagnosticBuilder,\n@@ -550,42 +504,102 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn note_error_origin(&self,\n+                         err: &mut DiagnosticBuilder<'tcx>,\n+                         origin: &TypeOrigin)\n+    {\n+        match origin {\n+            &TypeOrigin::MatchExpressionArm(_, arm_span, source) => match source {\n+                hir::MatchSource::IfLetDesugar {..} => {\n+                    err.span_note(arm_span, \"`if let` arm with an incompatible type\");\n+                }\n+                _ => {\n+                    err.span_note(arm_span, \"match arm with an incompatible type\");\n+                }\n+            },\n+            _ => ()\n+        }\n+    }\n+\n+    pub fn note_type_err(&self,\n+                         diag: &mut DiagnosticBuilder<'tcx>,\n+                         origin: TypeOrigin,\n+                         values: Option<ValuePairs<'tcx>>,\n+                         terr: &TypeError<'tcx>)\n+    {\n+        let expected_found = match values {\n+            None => None,\n+            Some(values) => match self.values_str(&values) {\n+                Some((expected, found)) => Some((expected, found)),\n+                None => {\n+                    // Derived error. Cancel the emitter.\n+                    self.tcx.sess.diagnostic().cancel(diag);\n+                    return\n+                }\n+            }\n+        };\n+\n+        let span = origin.span();\n+\n+        let mut is_simple_error = false;\n+\n+        if let Some((expected, found)) = expected_found {\n+            is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n+                values.expected.is_primitive() && values.found.is_primitive()\n+            } else {\n+                false\n+            };\n+\n+            if !is_simple_error || check_old_school() {\n+                diag.note_expected_found(&\"type\", &expected, &found);\n+            }\n+        }\n+\n+        if !is_simple_error && check_old_school() {\n+            diag.span_note(span, &format!(\"{}\", terr));\n+        } else {\n+            diag.span_label(span, &terr);\n+        }\n+\n+        self.note_error_origin(diag, &origin);\n+        self.check_and_note_conflicting_crates(diag, terr, span);\n+        self.tcx.note_and_explain_type_err(diag, terr, span);\n+    }\n+\n     pub fn report_and_explain_type_error(&self,\n                                          trace: TypeTrace<'tcx>,\n                                          terr: &TypeError<'tcx>)\n-                                         -> DiagnosticBuilder<'tcx> {\n-        let span = trace.origin.span();\n-        let mut err = self.report_type_error(trace, terr);\n-        self.tcx.note_and_explain_type_err(&mut err, terr, span);\n-        err\n+                                         -> DiagnosticBuilder<'tcx>\n+    {\n+        // FIXME: do we want to use a different error code for each origin?\n+        let mut diag = struct_span_err!(\n+            self.tcx.sess, trace.origin.span(), E0308,\n+            \"{}\", trace.origin.as_failure_str()\n+        );\n+        self.note_type_err(&mut diag, trace.origin, Some(trace.values), terr);\n+        diag\n     }\n \n-    /// Returns a string of the form \"expected `{}`, found `{}`\", or None if this is a derived\n-    /// error.\n+    /// Returns a string of the form \"expected `{}`, found `{}`\".\n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<(String, String)> {\n         match *values {\n             infer::Types(ref exp_found) => self.expected_found_str(exp_found),\n             infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n-            infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found)\n+            infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n         }\n     }\n \n-    fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + TypeFoldable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>)\n         -> Option<(String, String)>\n     {\n-        let expected = exp_found.expected.resolve(self);\n-        if expected.references_error() {\n-            return None;\n-        }\n-\n-        let found = exp_found.found.resolve(self);\n-        if found.references_error() {\n+        let exp_found = self.resolve_type_vars_if_possible(exp_found);\n+        if exp_found.references_error() {\n             return None;\n         }\n \n-        Some((format!(\"{}\", expected), format!(\"{}\", found)))\n+        Some((format!(\"{}\", exp_found.expected), format!(\"{}\", exp_found.found)))\n     }\n \n     fn report_generic_bound_failure(&self,\n@@ -1608,59 +1622,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn note_region_origin(&self, err: &mut DiagnosticBuilder, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n             infer::Subtype(ref trace) => {\n-                let desc = match trace.origin {\n-                    TypeOrigin::Misc(_) => {\n-                        \"types are compatible\"\n-                    }\n-                    TypeOrigin::MethodCompatCheck(_) => {\n-                        \"method type is compatible with trait\"\n-                    }\n-                    TypeOrigin::ExprAssignable(_) => {\n-                        \"expression is assignable\"\n-                    }\n-                    TypeOrigin::RelateTraitRefs(_) => {\n-                        \"traits are compatible\"\n-                    }\n-                    TypeOrigin::RelateSelfType(_) => {\n-                        \"self type matches impl self type\"\n-                    }\n-                    TypeOrigin::RelateOutputImplTypes(_) => {\n-                        \"trait type parameters matches those \\\n-                                 specified on the impl\"\n-                    }\n-                    TypeOrigin::MatchExpressionArm(_, _, _) => {\n-                        \"match arms have compatible types\"\n-                    }\n-                    TypeOrigin::IfExpression(_) => {\n-                        \"if and else have compatible types\"\n-                    }\n-                    TypeOrigin::IfExpressionWithNoElse(_) => {\n-                        \"if may be missing an else clause\"\n-                    }\n-                    TypeOrigin::RangeExpression(_) => {\n-                        \"start and end of range have compatible types\"\n-                    }\n-                    TypeOrigin::EquatePredicate(_) => {\n-                        \"equality where clause is satisfied\"\n-                    }\n-                };\n-\n-                match self.values_str(&trace.values) {\n-                    Some((expected, found)) => {\n-                        err.span_note(\n-                            trace.origin.span(),\n-                            &format!(\"...so that {} (expected {}, found {})\",\n-                                    desc, expected, found));\n-                    }\n-                    None => {\n-                        // Really should avoid printing this error at\n-                        // all, since it is derived, but that would\n-                        // require more refactoring than I feel like\n-                        // doing right now. - nmatsakis\n-                        err.span_note(\n-                            trace.origin.span(),\n-                            &format!(\"...so that {}\", desc));\n-                    }\n+                if let Some((expected, found)) = self.values_str(&trace.values) {\n+                    // FIXME: do we want a \"the\" here?\n+                    err.span_note(\n+                        trace.origin.span(),\n+                        &format!(\"...so that {} (expected {}, found {})\",\n+                                 trace.origin.as_requirement_str(), expected, found));\n+                } else {\n+                    // FIXME: this really should be handled at some earlier stage. Our\n+                    // handling of region checking when type errors are present is\n+                    // *terrible*.\n+\n+                    err.span_note(\n+                        trace.origin.span(),\n+                        &format!(\"...so that {}\",\n+                                 trace.origin.as_requirement_str()));\n                 }\n             }\n             infer::Reborrow(span) => {\n@@ -1803,32 +1779,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub trait Resolvable<'tcx> {\n-    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self;\n-}\n-\n-impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n-    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        infcx.resolve_type_vars_if_possible(self)\n-    }\n-}\n-\n-impl<'tcx> Resolvable<'tcx> for ty::TraitRef<'tcx> {\n-    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                         -> ty::TraitRef<'tcx> {\n-        infcx.resolve_type_vars_if_possible(self)\n-    }\n-}\n-\n-impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n-    fn resolve<'a, 'gcx>(&self,\n-                         infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                         -> ty::PolyTraitRef<'tcx>\n-    {\n-        infcx.resolve_type_vars_if_possible(self)\n-    }\n-}\n-\n fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                       scope_id: ast::NodeId)\n                                       -> Vec<hir::LifetimeDef> {"}, {"sha": "5dd85a31a9a2087effd0487c3e1393c0b058107c", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -15,29 +15,29 @@ use super::Subtype;\n \n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use traits::PredicateObligations;\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Glb<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'gcx, 'tcx>\n+pub struct Glb<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+    a_is_expected: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Glb<'a, 'gcx, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Glb<'a, 'gcx, 'tcx> {\n-        Glb { fields: fields }\n-    }\n-\n-    pub fn obligations(self) -> PredicateObligations<'tcx> {\n-        self.fields.obligations\n+impl<'combine, 'infcx, 'gcx, 'tcx> Glb<'combine, 'infcx, 'gcx, 'tcx> {\n+    pub fn new(fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n+        -> Glb<'combine, 'infcx, 'gcx, 'tcx>\n+    {\n+        Glb { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Glb<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n+    for Glb<'combine, 'infcx, 'gcx, 'tcx>\n+{\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              variance: ty::Variance,\n@@ -46,10 +46,10 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Glb<'a, 'gcx, 'tcx> {\n                                              -> RelateResult<'tcx, T>\n     {\n         match variance {\n-            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n-            ty::Bivariant => self.fields.bivariate().relate(a, b),\n-            ty::Contravariant => self.fields.lub().relate(a, b),\n+            ty::Bivariant => self.fields.bivariate(self.a_is_expected).relate(a, b),\n+            ty::Contravariant => self.fields.lub(self.a_is_expected).relate(a, b),\n         }\n     }\n \n@@ -71,17 +71,19 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Glb<'a, 'gcx, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>\n     {\n-        self.fields.higher_ranked_glb(a, b)\n+        self.fields.higher_ranked_glb(a, b, self.a_is_expected)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> LatticeDir<'a, 'gcx, 'tcx> for Glb<'a, 'gcx, 'tcx> {\n-    fn infcx(&self) -> &'a InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> LatticeDir<'infcx, 'gcx, 'tcx>\n+    for Glb<'combine, 'infcx, 'gcx, 'tcx>\n+{\n+    fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'gcx, 'tcx> {\n         self.fields.infcx\n     }\n \n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n-        let mut sub = self.fields.sub();\n+    fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n+        let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(&v, &a)?;\n         sub.relate(&v, &b)?;\n         Ok(())"}, {"sha": "743d6135fbb5b555a9c61b151a023626a2325dd1", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -40,7 +40,7 @@ pub struct HrMatchResult<U> {\n }\n \n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n-    pub fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+    pub fn higher_ranked_sub<T>(&mut self, a: &Binder<T>, b: &Binder<T>, a_is_expected: bool)\n                                 -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'tcx>\n     {\n@@ -77,11 +77,11 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             debug!(\"b_prime={:?}\", b_prime);\n \n             // Compare types now that bound regions have been replaced.\n-            let result = self.sub().relate(&a_prime, &b_prime)?;\n+            let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n \n             // Presuming type comparison succeeds, we need to check\n             // that the skolemized regions do not \"leak\".\n-            self.infcx.leak_check(!self.a_is_expected, span, &skol_map, snapshot)?;\n+            self.infcx.leak_check(!a_is_expected, span, &skol_map, snapshot)?;\n \n             // We are finished with the skolemized regions now so pop\n             // them off.\n@@ -106,10 +106,11 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n     /// NB. It should not happen that there are LBR appearing in `U`\n     /// that do not appear in `T`. If that happens, those regions are\n     /// unconstrained, and this routine replaces them with `'static`.\n-    pub fn higher_ranked_match<T, U>(&self,\n+    pub fn higher_ranked_match<T, U>(&mut self,\n                                      span: Span,\n                                      a_pair: &Binder<(T, U)>,\n-                                     b_match: &T)\n+                                     b_match: &T,\n+                                     a_is_expected: bool)\n                                      -> RelateResult<'tcx, HrMatchResult<U>>\n         where T: Relate<'tcx>,\n               U: TypeFoldable<'tcx>\n@@ -129,7 +130,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             debug!(\"higher_ranked_match: skol_map={:?}\", skol_map);\n \n             // Equate types now that bound regions have been replaced.\n-            try!(self.equate().relate(&a_match, &b_match));\n+            try!(self.equate(a_is_expected).relate(&a_match, &b_match));\n \n             // Map each skolemized region to a vector of other regions that it\n             // must be equated with. (Note that this vector may include other\n@@ -221,7 +222,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    pub fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+    pub fn higher_ranked_lub<T>(&mut self, a: &Binder<T>, b: &Binder<T>, a_is_expected: bool)\n                                 -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'tcx>\n     {\n@@ -239,7 +240,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             // Collect constraints.\n             let result0 =\n-                self.lub().relate(&a_with_fresh, &b_with_fresh)?;\n+                self.lub(a_is_expected).relate(&a_with_fresh, &b_with_fresh)?;\n             let result0 =\n                 self.infcx.resolve_type_vars_if_possible(&result0);\n             debug!(\"lub result0 = {:?}\", result0);\n@@ -311,7 +312,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+    pub fn higher_ranked_glb<T>(&mut self, a: &Binder<T>, b: &Binder<T>, a_is_expected: bool)\n                                 -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'tcx>\n     {\n@@ -333,7 +334,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             // Collect constraints.\n             let result0 =\n-                self.glb().relate(&a_with_fresh, &b_with_fresh)?;\n+                self.glb(a_is_expected).relate(&a_with_fresh, &b_with_fresh)?;\n             let result0 =\n                 self.infcx.resolve_type_vars_if_possible(&result0);\n             debug!(\"glb result0 = {:?}\", result0);"}, {"sha": "eda78428e61ad41c4690fccc8adf8668e8ad6ed2", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -40,7 +40,7 @@ pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx>\n \n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n+    fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,"}, {"sha": "ad1b32ffaeb320ac18159277ee07d34df3a016c7", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -15,29 +15,29 @@ use super::Subtype;\n \n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use traits::PredicateObligations;\n \n /// \"Least upper bound\" (common supertype)\n-pub struct Lub<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'gcx, 'tcx>\n+pub struct Lub<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+    a_is_expected: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Lub<'a, 'gcx, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Lub<'a, 'gcx, 'tcx> {\n-        Lub { fields: fields }\n-    }\n-\n-    pub fn obligations(self) -> PredicateObligations<'tcx> {\n-        self.fields.obligations\n+impl<'combine, 'infcx, 'gcx, 'tcx> Lub<'combine, 'infcx, 'gcx, 'tcx> {\n+    pub fn new(fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n+        -> Lub<'combine, 'infcx, 'gcx, 'tcx>\n+    {\n+        Lub { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Lub<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n+    for Lub<'combine, 'infcx, 'gcx, 'tcx>\n+{\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              variance: ty::Variance,\n@@ -46,10 +46,10 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Lub<'a, 'gcx, 'tcx> {\n                                              -> RelateResult<'tcx, T>\n     {\n         match variance {\n-            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n-            ty::Bivariant => self.fields.bivariate().relate(a, b),\n-            ty::Contravariant => self.fields.glb().relate(a, b),\n+            ty::Bivariant => self.fields.bivariate(self.a_is_expected).relate(a, b),\n+            ty::Contravariant => self.fields.glb(self.a_is_expected).relate(a, b),\n         }\n     }\n \n@@ -71,17 +71,19 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Lub<'a, 'gcx, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>\n     {\n-        self.fields.higher_ranked_lub(a, b)\n+        self.fields.higher_ranked_lub(a, b, self.a_is_expected)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> LatticeDir<'a, 'gcx, 'tcx> for Lub<'a, 'gcx, 'tcx> {\n-    fn infcx(&self) -> &'a InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> LatticeDir<'infcx, 'gcx, 'tcx>\n+    for Lub<'combine, 'infcx, 'gcx, 'tcx>\n+{\n+    fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'gcx, 'tcx> {\n         self.fields.infcx\n     }\n \n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n-        let mut sub = self.fields.sub();\n+    fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n+        let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(&a, &v)?;\n         sub.relate(&b, &v)?;\n         Ok(())"}, {"sha": "be9adf7085cd4aee2780ccc5fd00719f656ab1a7", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 128, "deletions": 112, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -32,7 +32,7 @@ use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use ty::fold::TypeFoldable;\n+use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::{self, PredicateObligations, ProjectionMode};\n use rustc_data_structures::unify::{self, UnificationTable};\n@@ -48,18 +48,18 @@ use self::higher_ranked::HrMatchResult;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::unify_key::ToType;\n \n-pub mod bivariate;\n-pub mod combine;\n-pub mod equate;\n+mod bivariate;\n+mod combine;\n+mod equate;\n pub mod error_reporting;\n-pub mod glb;\n+mod glb;\n mod higher_ranked;\n pub mod lattice;\n-pub mod lub;\n+mod lub;\n pub mod region_inference;\n pub mod resolve;\n mod freshen;\n-pub mod sub;\n+mod sub;\n pub mod type_variable;\n pub mod unify_key;\n \n@@ -196,12 +196,6 @@ pub enum TypeOrigin {\n     // FIXME(eddyb) #11161 is the original Expr required?\n     ExprAssignable(Span),\n \n-    // Relating trait refs when resolving vtables\n-    RelateTraitRefs(Span),\n-\n-    // Relating self types when resolving vtables\n-    RelateSelfType(Span),\n-\n     // Relating trait type parameters to those found in impl etc\n     RelateOutputImplTypes(Span),\n \n@@ -219,16 +213,26 @@ pub enum TypeOrigin {\n \n     // `where a == b`\n     EquatePredicate(Span),\n+\n+    // `main` has wrong type\n+    MainFunctionType(Span),\n+\n+    // `start` has wrong type\n+    StartFunctionType(Span),\n+\n+    // intrinsic has wrong type\n+    IntrinsicType(Span),\n+\n+    // method receiver\n+    MethodReceiver(Span),\n }\n \n impl TypeOrigin {\n-    fn as_str(&self) -> &'static str {\n+    fn as_failure_str(&self) -> &'static str {\n         match self {\n             &TypeOrigin::Misc(_) |\n-            &TypeOrigin::RelateSelfType(_) |\n             &TypeOrigin::RelateOutputImplTypes(_) |\n             &TypeOrigin::ExprAssignable(_) => \"mismatched types\",\n-            &TypeOrigin::RelateTraitRefs(_) => \"mismatched traits\",\n             &TypeOrigin::MethodCompatCheck(_) => \"method not compatible with trait\",\n             &TypeOrigin::MatchExpressionArm(_, _, source) => match source {\n                 hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have incompatible types\",\n@@ -238,13 +242,31 @@ impl TypeOrigin {\n             &TypeOrigin::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n             &TypeOrigin::RangeExpression(_) => \"start and end of range have incompatible types\",\n             &TypeOrigin::EquatePredicate(_) => \"equality predicate not satisfied\",\n+            &TypeOrigin::MainFunctionType(_) => \"main function has wrong type\",\n+            &TypeOrigin::StartFunctionType(_) => \"start function has wrong type\",\n+            &TypeOrigin::IntrinsicType(_) => \"intrinsic has wrong type\",\n+            &TypeOrigin::MethodReceiver(_) => \"mismatched method receiver\",\n         }\n     }\n-}\n \n-impl fmt::Display for TypeOrigin {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(),fmt::Error> {\n-        fmt::Display::fmt(self.as_str(), f)\n+    fn as_requirement_str(&self) -> &'static str {\n+        match self {\n+            &TypeOrigin::Misc(_) => \"types are compatible\",\n+            &TypeOrigin::MethodCompatCheck(_) => \"method type is compatible with trait\",\n+            &TypeOrigin::ExprAssignable(_) => \"expression is assignable\",\n+            &TypeOrigin::RelateOutputImplTypes(_) => {\n+                \"trait type parameters matches those specified on the impl\"\n+            }\n+            &TypeOrigin::MatchExpressionArm(_, _, _) => \"match arms have compatible types\",\n+            &TypeOrigin::IfExpression(_) => \"if and else have compatible types\",\n+            &TypeOrigin::IfExpressionWithNoElse(_) => \"if missing an else returns ()\",\n+            &TypeOrigin::RangeExpression(_) => \"start and end of range have compatible types\",\n+            &TypeOrigin::EquatePredicate(_) => \"equality where clause is satisfied\",\n+            &TypeOrigin::MainFunctionType(_) => \"`main` function has the correct type\",\n+            &TypeOrigin::StartFunctionType(_) => \"`start` function has the correct type\",\n+            &TypeOrigin::IntrinsicType(_) => \"intrinsic has the correct type\",\n+            &TypeOrigin::MethodReceiver(_) => \"method receiver has the correct type\",\n+        }\n     }\n }\n \n@@ -799,11 +821,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         return variables;\n     }\n \n-    fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+    fn combine_fields(&'a self, trace: TypeTrace<'tcx>)\n                       -> CombineFields<'a, 'gcx, 'tcx> {\n         CombineFields {\n             infcx: self,\n-            a_is_expected: a_is_expected,\n             trace: trace,\n             cause: None,\n             obligations: PredicateObligations::new(),\n@@ -814,36 +835,36 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         -> InferResult<'tcx, T>\n         where T: Relate<'tcx>\n     {\n-        let mut equate = self.combine_fields(a_is_expected, trace).equate();\n-        let result = equate.relate(a, b);\n-        result.map(|t| InferOk { value: t, obligations: equate.obligations() })\n+        let mut fields = self.combine_fields(trace);\n+        let result = fields.equate(a_is_expected).relate(a, b);\n+        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n     pub fn sub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n         where T: Relate<'tcx>\n     {\n-        let mut sub = self.combine_fields(a_is_expected, trace).sub();\n-        let result = sub.relate(a, b);\n-        result.map(|t| InferOk { value: t, obligations: sub.obligations() })\n+        let mut fields = self.combine_fields(trace);\n+        let result = fields.sub(a_is_expected).relate(a, b);\n+        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n     pub fn lub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n         where T: Relate<'tcx>\n     {\n-        let mut lub = self.combine_fields(a_is_expected, trace).lub();\n-        let result = lub.relate(a, b);\n-        result.map(|t| InferOk { value: t, obligations: lub.obligations() })\n+        let mut fields = self.combine_fields(trace);\n+        let result = fields.lub(a_is_expected).relate(a, b);\n+        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n     pub fn glb<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n         where T: Relate<'tcx>\n     {\n-        let mut glb = self.combine_fields(a_is_expected, trace).glb();\n-        let result = glb.relate(a, b);\n-        result.map(|t| InferOk { value: t, obligations: glb.obligations() })\n+        let mut fields = self.combine_fields(trace);\n+        let result = fields.glb(a_is_expected).relate(a, b);\n+        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n@@ -1468,104 +1489,50 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // error type, meaning that an error occurred when typechecking this expression),\n     // this is a derived error. The error cascaded from another error (that was already\n     // reported), so it's not useful to display it to the user.\n-    // The following four methods -- type_error_message_str, type_error_message_str_with_expected,\n-    // type_error_message, and report_mismatched_types -- implement this logic.\n+    // The following methods implement this logic.\n     // They check if either the actual or expected type is TyError, and don't print the error\n     // in this case. The typechecker should only ever report type errors involving mismatched\n-    // types using one of these four methods, and should not call span_err directly for such\n+    // types using one of these methods, and should not call span_err directly for such\n     // errors.\n-    pub fn type_error_message_str<M>(&self,\n-                                     sp: Span,\n-                                     mk_msg: M,\n-                                     actual_ty: String,\n-                                     err: Option<&TypeError<'tcx>>)\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n-    }\n-\n-    pub fn type_error_struct_str<M>(&self,\n-                                    sp: Span,\n-                                    mk_msg: M,\n-                                    actual_ty: String,\n-                                    err: Option<&TypeError<'tcx>>)\n-                                    -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        self.type_error_struct_str_with_expected(sp, mk_msg, None, actual_ty, err)\n-    }\n-\n-    pub fn type_error_message_str_with_expected<M>(&self,\n-                                                   sp: Span,\n-                                                   mk_msg: M,\n-                                                   expected_ty: Option<Ty<'tcx>>,\n-                                                   actual_ty: String,\n-                                                   err: Option<&TypeError<'tcx>>)\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        self.type_error_struct_str_with_expected(sp, mk_msg, expected_ty, actual_ty, err)\n-            .emit();\n-    }\n-\n-    pub fn type_error_struct_str_with_expected<M>(&self,\n-                                                  sp: Span,\n-                                                  mk_msg: M,\n-                                                  expected_ty: Option<Ty<'tcx>>,\n-                                                  actual_ty: String,\n-                                                  err: Option<&TypeError<'tcx>>)\n-                                                  -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n-\n-        let resolved_expected = expected_ty.map(|e_ty| self.resolve_type_vars_if_possible(&e_ty));\n-\n-        if !resolved_expected.references_error() {\n-            let error_str = err.map_or(\"\".to_string(), |t_err| {\n-                format!(\" ({})\", t_err)\n-            });\n-\n-            let mut db = self.tcx.sess.struct_span_err(sp, &format!(\"{}{}\",\n-                mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                error_str));\n-\n-            if let Some(err) = err {\n-                self.tcx.note_and_explain_type_err(&mut db, err, sp);\n-            }\n-            db\n-        } else {\n-            self.tcx.sess.diagnostic().struct_dummy()\n-        }\n-    }\n \n     pub fn type_error_message<M>(&self,\n                                  sp: Span,\n                                  mk_msg: M,\n-                                 actual_ty: Ty<'tcx>,\n-                                 err: Option<&TypeError<'tcx>>)\n+                                 actual_ty: Ty<'tcx>)\n         where M: FnOnce(String) -> String,\n     {\n-        self.type_error_struct(sp, mk_msg, actual_ty, err).emit();\n+        self.type_error_struct(sp, mk_msg, actual_ty).emit();\n     }\n \n+    // FIXME: this results in errors without an error code. Deprecate?\n     pub fn type_error_struct<M>(&self,\n                                 sp: Span,\n                                 mk_msg: M,\n-                                actual_ty: Ty<'tcx>,\n-                                err: Option<&TypeError<'tcx>>)\n+                                actual_ty: Ty<'tcx>)\n                                 -> DiagnosticBuilder<'tcx>\n         where M: FnOnce(String) -> String,\n+    {\n+        self.type_error_struct_with_diag(sp, |actual_ty| {\n+            self.tcx.sess.struct_span_err(sp, &mk_msg(actual_ty))\n+        }, actual_ty)\n+    }\n+\n+    pub fn type_error_struct_with_diag<M>(&self,\n+                                          sp: Span,\n+                                          mk_diag: M,\n+                                          actual_ty: Ty<'tcx>)\n+                                          -> DiagnosticBuilder<'tcx>\n+        where M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n+        debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n \n         // Don't report an error if actual type is TyError.\n         if actual_ty.references_error() {\n             return self.tcx.sess.diagnostic().struct_dummy();\n         }\n \n-        self.type_error_struct_str(sp,\n-            move |_e, a| { mk_msg(a) },\n-            self.ty_to_string(actual_ty), err)\n+        mk_diag(self.ty_to_string(actual_ty))\n     }\n \n     pub fn report_mismatched_types(&self,\n@@ -1646,8 +1613,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref, p.ty));\n-        let combine = self.combine_fields(true, trace);\n-        let result = combine.higher_ranked_match(span, &match_pair, &match_b)?;\n+        let mut combine = self.combine_fields(trace);\n+        let result = combine.higher_ranked_match(span, &match_pair, &match_b, true)?;\n         Ok(InferOk { value: result, obligations: combine.obligations })\n     }\n \n@@ -1833,14 +1800,16 @@ impl TypeOrigin {\n             TypeOrigin::MethodCompatCheck(span) => span,\n             TypeOrigin::ExprAssignable(span) => span,\n             TypeOrigin::Misc(span) => span,\n-            TypeOrigin::RelateTraitRefs(span) => span,\n-            TypeOrigin::RelateSelfType(span) => span,\n             TypeOrigin::RelateOutputImplTypes(span) => span,\n             TypeOrigin::MatchExpressionArm(match_span, _, _) => match_span,\n             TypeOrigin::IfExpression(span) => span,\n             TypeOrigin::IfExpressionWithNoElse(span) => span,\n             TypeOrigin::RangeExpression(span) => span,\n             TypeOrigin::EquatePredicate(span) => span,\n+            TypeOrigin::MainFunctionType(span) => span,\n+            TypeOrigin::StartFunctionType(span) => span,\n+            TypeOrigin::IntrinsicType(span) => span,\n+            TypeOrigin::MethodReceiver(span) => span,\n         }\n     }\n }\n@@ -1891,3 +1860,50 @@ impl RegionVariableOrigin {\n         }\n     }\n }\n+\n+impl<'tcx> TypeFoldable<'tcx> for TypeOrigin {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n+        self.clone()\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ValuePairs<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            ValuePairs::Types(ref ef) => {\n+                ValuePairs::Types(ef.fold_with(folder))\n+            }\n+            ValuePairs::TraitRefs(ref ef) => {\n+                ValuePairs::TraitRefs(ef.fold_with(folder))\n+            }\n+            ValuePairs::PolyTraitRefs(ref ef) => {\n+                ValuePairs::PolyTraitRefs(ef.fold_with(folder))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ValuePairs::Types(ref ef) => ef.visit_with(visitor),\n+            ValuePairs::TraitRefs(ref ef) => ef.visit_with(visitor),\n+            ValuePairs::PolyTraitRefs(ref ef) => ef.visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for TypeTrace<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        TypeTrace {\n+            origin: self.origin.fold_with(folder),\n+            values: self.values.fold_with(folder)\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.origin.visit_with(visitor) || self.values.visit_with(visitor)\n+    }\n+}"}, {"sha": "2f7f5254727db15d1f245be227498b046bc307fc", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -15,28 +15,35 @@ use super::type_variable::{SubtypeOf, SupertypeOf};\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n-use traits::PredicateObligations;\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n-pub struct Sub<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'gcx, 'tcx>,\n+pub struct Sub<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+    a_is_expected: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Sub<'a, 'gcx, 'tcx> {\n-    pub fn new(f: CombineFields<'a, 'gcx, 'tcx>) -> Sub<'a, 'gcx, 'tcx> {\n-        Sub { fields: f }\n+impl<'combine, 'infcx, 'gcx, 'tcx> Sub<'combine, 'infcx, 'gcx, 'tcx> {\n+    pub fn new(f: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n+        -> Sub<'combine, 'infcx, 'gcx, 'tcx>\n+    {\n+        Sub { fields: f, a_is_expected: a_is_expected }\n     }\n \n-    pub fn obligations(self) -> PredicateObligations<'tcx> {\n-        self.fields.obligations\n+    fn with_expected_switched<R, F: FnOnce(&mut Self) -> R>(&mut self, f: F) -> R {\n+        self.a_is_expected = !self.a_is_expected;\n+        let result = f(self);\n+        self.a_is_expected = !self.a_is_expected;\n+        result\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Sub<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n+    for Sub<'combine, 'infcx, 'gcx, 'tcx>\n+{\n     fn tag(&self) -> &'static str { \"Sub\" }\n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.infcx.tcx }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.infcx.tcx }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn with_cause<F,R>(&mut self, cause: Cause, f: F) -> R\n         where F: FnOnce(&mut Self) -> R\n@@ -56,10 +63,10 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Sub<'a, 'gcx, 'tcx> {\n                                              -> RelateResult<'tcx, T>\n     {\n         match variance {\n-            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n-            ty::Bivariant => self.fields.bivariate().relate(a, b),\n-            ty::Contravariant => self.fields.switch_expected().sub().relate(b, a),\n+            ty::Bivariant => self.fields.bivariate(self.a_is_expected).relate(a, b),\n+            ty::Contravariant => self.with_expected_switched(|this| { this.relate(b, a) }),\n         }\n     }\n \n@@ -80,12 +87,11 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Sub<'a, 'gcx, 'tcx> {\n             }\n             (&ty::TyInfer(TyVar(a_id)), _) => {\n                 self.fields\n-                    .switch_expected()\n-                    .instantiate(b, SupertypeOf, a_id)?;\n+                    .instantiate(b, SupertypeOf, a_id, !self.a_is_expected)?;\n                 Ok(a)\n             }\n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, SubtypeOf, b_id)?;\n+                self.fields.instantiate(a, SubtypeOf, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n@@ -116,6 +122,6 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Sub<'a, 'gcx, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>\n     {\n-        self.fields.higher_ranked_sub(a, b)\n+        self.fields.higher_ranked_sub(a, b, self.a_is_expected)\n     }\n }"}, {"sha": "daac315e14def73aed895377000e610242272a72", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -29,7 +29,7 @@ use dep_graph::DepNode;\n use middle::privacy::AccessLevels;\n use ty::TyCtxt;\n use session::{config, early_error, Session};\n-use lint::{Level, LevelSource, Lint, LintId, LintPass};\n+use lint::{Level, LevelSource, Lint, LintId, LintPass, LintSource};\n use lint::{EarlyLintPassObject, LateLintPassObject};\n use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n use lint::builtin;\n@@ -45,7 +45,6 @@ use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n use hir;\n use hir::intravisit as hir_visit;\n-use hir::intravisit::{IdVisitor, IdVisitingOperation};\n use syntax::visit as ast_visit;\n \n /// Information about the registered lints.\n@@ -366,18 +365,18 @@ pub fn gather_attr(attr: &ast::Attribute)\n     attr::mark_used(attr);\n \n     let meta = &attr.node.value;\n-    let metas = match meta.node {\n-        ast::MetaItemKind::List(_, ref metas) => metas,\n-        _ => {\n-            out.push(Err(meta.span));\n-            return out;\n-        }\n+    let metas = if let Some(metas) = meta.meta_item_list() {\n+        metas\n+    } else {\n+        out.push(Err(meta.span));\n+        return out;\n     };\n \n     for meta in metas {\n-        out.push(match meta.node {\n-            ast::MetaItemKind::Word(ref lint_name) => Ok((lint_name.clone(), level, meta.span)),\n-            _ => Err(meta.span),\n+        out.push(if meta.is_word() {\n+            Ok((meta.name().clone(), level, meta.span))\n+        } else {\n+            Err(meta.span)\n         });\n     }\n \n@@ -600,13 +599,23 @@ pub trait LintContext: Sized {\n             };\n \n             for (lint_id, level, span) in v {\n-                let now = self.lints().get_level_source(lint_id).0;\n+                let (now, now_source) = self.lints().get_level_source(lint_id);\n                 if now == Forbid && level != Forbid {\n                     let lint_name = lint_id.as_str();\n-                    span_err!(self.sess(), span, E0453,\n-                              \"{}({}) overruled by outer forbid({})\",\n-                              level.as_str(), lint_name,\n-                              lint_name);\n+                    let mut diag_builder = struct_span_err!(self.sess(), span, E0453,\n+                                                            \"{}({}) overruled by outer forbid({})\",\n+                                                            level.as_str(), lint_name,\n+                                                            lint_name);\n+                    match now_source {\n+                        LintSource::Default => &mut diag_builder,\n+                        LintSource::Node(forbid_source_span) => {\n+                            diag_builder.span_note(forbid_source_span,\n+                                                   \"`forbid` lint level set here\")\n+                        },\n+                        LintSource::CommandLine => {\n+                            diag_builder.note(\"`forbid` lint level was set on command line\")\n+                        }\n+                    }.emit()\n                 } else if now != level {\n                     let src = self.lints().get_level_source(lint_id).1;\n                     self.level_stack().push((lint_id, (now, src)));\n@@ -663,9 +672,11 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     }\n \n     fn visit_ids<F>(&mut self, f: F)\n-        where F: FnOnce(&mut IdVisitor<LateContext>)\n+        where F: FnOnce(&mut IdVisitor)\n     {\n-        let mut v = IdVisitor::new(self);\n+        let mut v = IdVisitor {\n+            cx: self\n+        };\n         f(&mut v);\n     }\n }\n@@ -779,7 +790,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'v>, decl: &'v hir::FnDecl,\n                 body: &'v hir::Block, span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n-        hir_visit::walk_fn(self, fk, decl, body, span);\n+        hir_visit::walk_fn(self, fk, decl, body, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n     }\n \n@@ -820,7 +831,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n \n     fn visit_mod(&mut self, m: &hir::Mod, s: Span, n: ast::NodeId) {\n         run_lints!(self, check_mod, late_passes, m, s, n);\n-        hir_visit::walk_mod(self, m);\n+        hir_visit::walk_mod(self, m, n);\n         run_lints!(self, check_mod_post, late_passes, m, s, n);\n     }\n \n@@ -859,7 +870,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         self.with_lint_attrs(&trait_item.attrs, |cx| {\n             run_lints!(cx, check_trait_item, late_passes, trait_item);\n-            cx.visit_ids(|v| v.visit_trait_item(trait_item));\n+            cx.visit_ids(|v| hir_visit::walk_trait_item(v, trait_item));\n             hir_visit::walk_trait_item(cx, trait_item);\n             run_lints!(cx, check_trait_item_post, late_passes, trait_item);\n         });\n@@ -868,7 +879,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n         self.with_lint_attrs(&impl_item.attrs, |cx| {\n             run_lints!(cx, check_impl_item, late_passes, impl_item);\n-            cx.visit_ids(|v| v.visit_impl_item(impl_item));\n+            cx.visit_ids(|v| hir_visit::walk_impl_item(v, impl_item));\n             hir_visit::walk_impl_item(cx, impl_item);\n             run_lints!(cx, check_impl_item_post, late_passes, impl_item);\n         });\n@@ -1046,16 +1057,30 @@ impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n     }\n }\n \n+struct IdVisitor<'a, 'b: 'a, 'tcx: 'a+'b> {\n+    cx: &'a mut LateContext<'b, 'tcx>\n+}\n+\n // Output any lints that were previously added to the session.\n-impl<'a, 'tcx> IdVisitingOperation for LateContext<'a, 'tcx> {\n+impl<'a, 'b, 'tcx, 'v> hir_visit::Visitor<'v> for IdVisitor<'a, 'b, 'tcx> {\n+\n     fn visit_id(&mut self, id: ast::NodeId) {\n-        if let Some(lints) = self.sess().lints.borrow_mut().remove(&id) {\n+        if let Some(lints) = self.cx.sess().lints.borrow_mut().remove(&id) {\n             debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);\n             for (lint_id, span, msg) in lints {\n-                self.span_lint(lint_id.lint, span, &msg[..])\n+                self.cx.span_lint(lint_id.lint, span, &msg[..])\n             }\n         }\n     }\n+\n+    fn visit_trait_item(&mut self, _ti: &hir::TraitItem) {\n+        // Do not recurse into trait or impl items automatically. These are\n+        // processed separately by calling hir_visit::walk_trait_item()\n+    }\n+\n+    fn visit_impl_item(&mut self, _ii: &hir::ImplItem) {\n+        // See visit_trait_item()\n+    }\n }\n \n enum CheckLintNameResult {\n@@ -1172,7 +1197,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Visit the whole crate.\n     cx.with_lint_attrs(&krate.attrs, |cx| {\n-        cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             hir_visit::walk_crate(v, krate);\n         });"}, {"sha": "0a5f6884af9bb33fd28d122cbfd7926fe7e670bf", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -24,13 +24,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn prohibit_type_params(self, segments: &[ast::PathSegment]) {\n         for segment in segments {\n             for typ in segment.parameters.types() {\n-                span_err!(self.sess, typ.span, E0109,\n-                          \"type parameters are not allowed on this type\");\n+                struct_span_err!(self.sess, typ.span, E0109,\n+                                 \"type parameters are not allowed on this type\")\n+                    .span_label(typ.span, &format!(\"type parameter not allowed\"))\n+                    .emit();\n                 break;\n             }\n             for lifetime in segment.parameters.lifetimes() {\n-                span_err!(self.sess, lifetime.span, E0110,\n-                          \"lifetime parameters are not allowed on this type\");\n+                struct_span_err!(self.sess, lifetime.span, E0110,\n+                                 \"lifetime parameters are not allowed on this type\")\n+                    .span_label(lifetime.span,\n+                                &format!(\"lifetime parameter not allowed on this type\"))\n+                    .emit();\n                 break;\n             }\n             for binding in segment.parameters.bindings() {"}, {"sha": "32344a7b9c8deb1485d2d5ac8e27c8102144c0c3", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -44,7 +44,7 @@ use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;\n-use hir::intravisit::{IdVisitor, IdVisitingOperation, Visitor};\n+use hir::intravisit::Visitor;\n \n pub use self::DefLike::{DlDef, DlField, DlImpl};\n pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n@@ -120,12 +120,6 @@ pub struct ChildItem {\n     pub vis: ty::Visibility,\n }\n \n-pub enum FoundAst<'ast> {\n-    Found(&'ast InlinedItem),\n-    FoundParent(DefId, &'ast hir::Item),\n-    NotFound,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct ExternCrate {\n     /// def_id of an `extern crate` in the current crate that caused\n@@ -250,7 +244,10 @@ pub trait CrateStore<'tcx> {\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> FoundAst<'tcx>;\n+                              -> Option<(&'tcx InlinedItem, ast::NodeId)>;\n+    fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId>;\n+    fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId>;\n+\n     fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<Mir<'tcx>>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n@@ -292,11 +289,6 @@ impl InlinedItem {\n             InlinedItem::ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n         }\n     }\n-\n-    pub fn visit_ids<O: IdVisitingOperation>(&self, operation: &mut O) {\n-        let mut id_visitor = IdVisitor::new(operation);\n-        self.visit(&mut id_visitor);\n-    }\n }\n \n // FIXME: find a better place for this?\n@@ -452,7 +444,16 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> FoundAst<'tcx> { bug!(\"maybe_get_item_ast\") }\n+                              -> Option<(&'tcx InlinedItem, ast::NodeId)> {\n+        bug!(\"maybe_get_item_ast\")\n+    }\n+    fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId> {\n+        bug!(\"local_node_for_inlined_defid\")\n+    }\n+    fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId> {\n+        bug!(\"defid_for_inlined_node\")\n+    }\n+\n     fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<Mir<'tcx>> { bug!(\"maybe_get_item_mir\") }\n     fn is_item_mir_available(&self, def: DefId) -> bool {"}, {"sha": "446767ecbcaba1e1cb1daf08da4c0602b2826fff", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self, fn_kind: FnKind<'v>, fn_decl: &'v hir::FnDecl,\n-                block: &'v hir::Block, span: Span, _: ast::NodeId) {\n+                block: &'v hir::Block, span: Span, id: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             FnKind::ItemFn(_, _, unsafety, _, _, _, _) =>\n@@ -96,7 +96,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             self.unsafe_context = UnsafeContext::new(SafeContext)\n         }\n \n-        intravisit::walk_fn(self, fn_kind, fn_decl, block, span);\n+        intravisit::walk_fn(self, fn_kind, fn_decl, block, span, id);\n \n         self.unsafe_context = old_unsafe_context\n     }"}, {"sha": "0a363fddd53124f6d9cc7218e88d552b94e1469b", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -121,8 +121,11 @@ fn find_item(item: &Item, ctxt: &mut EntryContext, at_root: bool) {\n             if ctxt.attr_main_fn.is_none() {\n                 ctxt.attr_main_fn = Some((item.id, item.span));\n             } else {\n-                span_err!(ctxt.session, item.span, E0137,\n-                          \"multiple functions with a #[main] attribute\");\n+                struct_span_err!(ctxt.session, item.span, E0137,\n+                          \"multiple functions with a #[main] attribute\")\n+                .span_label(item.span, &format!(\"additional #[main] function\"))\n+                .span_label(ctxt.attr_main_fn.unwrap().1, &format!(\"first #[main] function\"))\n+                .emit();\n             }\n         },\n         EntryPointType::Start => {"}, {"sha": "18b80a9636b45e0c2d91a605167bb4b127f2df96", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -271,10 +271,19 @@ enum PassArgs {\n \n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n-               infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self\n+               infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n+               -> Self\n+    {\n+        ExprUseVisitor::with_options(delegate, infcx, mc::MemCategorizationOptions::default())\n+    }\n+\n+    pub fn with_options(delegate: &'a mut (Delegate<'tcx>+'a),\n+                        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                        options: mc::MemCategorizationOptions)\n+               -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::new(infcx),\n+            mc: mc::MemCategorizationContext::with_options(infcx, options),\n             delegate: delegate\n         }\n     }"}, {"sha": "a209b1d1abd7c6e320fbf0e129a59a2f992f4bce", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -359,7 +359,6 @@ language_item_table! {\n     StartFnLangItem,                 \"start\",                   start_fn;\n \n     EhPersonalityLangItem,           \"eh_personality\",          eh_personality;\n-    EhPersonalityCatchLangItem,      \"eh_personality_catch\",    eh_personality_catch;\n     EhUnwindResumeLangItem,          \"eh_unwind_resume\",        eh_unwind_resume;\n     MSVCTryFilterLangItem,           \"msvc_try_filter\",         msvc_try_filter;\n "}, {"sha": "1222b5f42a19f6aeca5de5d471cadc434a05f1a9", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -390,7 +390,7 @@ fn visit_fn(ir: &mut IrMaps,\n \n     // gather up the various local variables, significant expressions,\n     // and so forth:\n-    intravisit::walk_fn(&mut fn_maps, fk, decl, body, sp);\n+    intravisit::walk_fn(&mut fn_maps, fk, decl, body, sp, id);\n \n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or panic"}, {"sha": "0bc3c1ae899dd267d235e507c18eaded12278d50", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -259,6 +259,18 @@ impl ast_node for hir::Pat {\n #[derive(Copy, Clone)]\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    options: MemCategorizationOptions,\n+}\n+\n+#[derive(Copy, Clone, Default)]\n+pub struct MemCategorizationOptions {\n+    // If true, then when analyzing a closure upvar, if the closure\n+    // has a missing kind, we treat it like a Fn closure. When false,\n+    // we ICE if the closure has a missing kind. Should be false\n+    // except during closure kind inference. It is used by the\n+    // mem-categorization code to be able to have stricter assertions\n+    // (which are always true except during upvar inference).\n+    pub during_closure_kind_inference: bool,\n }\n \n pub type McResult<T> = Result<T, ()>;\n@@ -362,7 +374,16 @@ impl MutabilityCategory {\n impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n                -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-        MemCategorizationContext { infcx: infcx }\n+        MemCategorizationContext::with_options(infcx, MemCategorizationOptions::default())\n+    }\n+\n+    pub fn with_options(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                        options: MemCategorizationOptions)\n+                        -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+        MemCategorizationContext {\n+            infcx: infcx,\n+            options: options,\n+        }\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -584,10 +605,20 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                               self.cat_upvar(id, span, var_id, fn_node_id, kind)\n                           }\n                           None => {\n-                              span_bug!(\n-                                  span,\n-                                  \"No closure kind for {:?}\",\n-                                  closure_id);\n+                              if !self.options.during_closure_kind_inference {\n+                                  span_bug!(\n+                                      span,\n+                                      \"No closure kind for {:?}\",\n+                                      closure_id);\n+                              }\n+\n+                              // during closure kind inference, we\n+                              // don't know the closure kind yet, but\n+                              // it's ok because we detect that we are\n+                              // accessing an upvar and handle that\n+                              // case specially anyhow. Use Fn\n+                              // arbitrarily.\n+                              self.cat_upvar(id, span, var_id, fn_node_id, ty::ClosureKind::Fn)\n                           }\n                       }\n                   }"}, {"sha": "cbbc2c4f98f5e09b025f59756289a153805b0f7d", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 56, "deletions": 17, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -19,7 +19,7 @@ use session::Session;\n use lint;\n use middle::cstore::LOCAL_CRATE;\n use hir::def::Def;\n-use hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n use ty::{self, TyCtxt};\n use middle::privacy::AccessLevels;\n use syntax::parse::token::InternedString;\n@@ -61,12 +61,46 @@ enum AnnotationKind {\n     Container,\n }\n \n+/// An entry in the `depr_map`.\n+#[derive(Clone)]\n+pub struct DeprecationEntry {\n+    /// The metadata of the attribute associated with this entry.\n+    pub attr: Deprecation,\n+    /// The def id where the attr was originally attached. `None` for non-local\n+    /// `DefId`'s.\n+    origin: Option<DefIndex>,\n+}\n+\n+impl DeprecationEntry {\n+    fn local(attr: Deprecation, id: DefId) -> DeprecationEntry {\n+        assert!(id.is_local());\n+        DeprecationEntry {\n+            attr: attr,\n+            origin: Some(id.index),\n+        }\n+    }\n+\n+    fn external(attr: Deprecation) -> DeprecationEntry {\n+        DeprecationEntry {\n+            attr: attr,\n+            origin: None,\n+        }\n+    }\n+\n+    pub fn same_origin(&self, other: &DeprecationEntry) -> bool {\n+        match (self.origin, other.origin) {\n+            (Some(o1), Some(o2)) => o1 == o2,\n+            _ => false\n+        }\n+    }\n+}\n+\n /// A stability index, giving the stability level for items and methods.\n pub struct Index<'tcx> {\n     /// This is mostly a cache, except the stabilities of local items\n     /// are filled by the annotator.\n     stab_map: DefIdMap<Option<&'tcx Stability>>,\n-    depr_map: DefIdMap<Option<Deprecation>>,\n+    depr_map: DefIdMap<Option<DeprecationEntry>>,\n \n     /// Maps for each crate whether it is part of the staged API.\n     staged_api: FnvHashMap<ast::CrateNum, bool>\n@@ -77,7 +111,7 @@ struct Annotator<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     index: &'a mut Index<'tcx>,\n     parent_stab: Option<&'tcx Stability>,\n-    parent_depr: Option<Deprecation>,\n+    parent_depr: Option<DeprecationEntry>,\n     access_levels: &'a AccessLevels,\n     in_trait_impl: bool,\n }\n@@ -184,14 +218,15 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n \n                 // `Deprecation` is just two pointers, no need to intern it\n                 let def_id = self.tcx.map.local_def_id(id);\n-                self.index.depr_map.insert(def_id, Some(depr.clone()));\n+                let depr_entry = Some(DeprecationEntry::local(depr, def_id));\n+                self.index.depr_map.insert(def_id, depr_entry.clone());\n \n-                let orig_parent_depr = replace(&mut self.parent_depr, Some(depr));\n+                let orig_parent_depr = replace(&mut self.parent_depr, depr_entry);\n                 visit_children(self);\n                 self.parent_depr = orig_parent_depr;\n-            } else if let Some(depr) = self.parent_depr.clone() {\n+            } else if let parent_depr @ Some(_) = self.parent_depr.clone() {\n                 let def_id = self.tcx.map.local_def_id(id);\n-                self.index.depr_map.insert(def_id, Some(depr));\n+                self.index.depr_map.insert(def_id, parent_depr);\n                 visit_children(self);\n             } else {\n                 visit_children(self);\n@@ -351,7 +386,7 @@ struct Checker<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Checker<'a, 'tcx> {\n     fn check(&mut self, id: DefId, span: Span,\n-             stab: &Option<&Stability>, _depr: &Option<Deprecation>) {\n+             stab: &Option<&Stability>, _depr: &Option<DeprecationEntry>) {\n         if !is_staged_api(self.tcx, id) {\n             return;\n         }\n@@ -476,7 +511,7 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             warn_about_defns: bool,\n                             cb: &mut FnMut(DefId, Span,\n                                            &Option<&Stability>,\n-                                           &Option<Deprecation>)) {\n+                                           &Option<DeprecationEntry>)) {\n     match item.node {\n         hir::ItemExternCrate(_) => {\n             // compiler-generated `extern crate` items have a dummy span.\n@@ -515,7 +550,7 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n                             cb: &mut FnMut(DefId, Span,\n                                            &Option<&Stability>,\n-                                           &Option<Deprecation>)) {\n+                                           &Option<DeprecationEntry>)) {\n     let span;\n     let id = match e.node {\n         hir::ExprMethodCall(i, _, _) => {\n@@ -579,7 +614,7 @@ pub fn check_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             path: &hir::Path, id: ast::NodeId,\n                             cb: &mut FnMut(DefId, Span,\n                                            &Option<&Stability>,\n-                                           &Option<Deprecation>)) {\n+                                           &Option<DeprecationEntry>)) {\n     // Paths in import prefixes may have no resolution.\n     match tcx.expect_def_or_none(id) {\n         Some(Def::PrimTy(..)) => {}\n@@ -595,7 +630,7 @@ pub fn check_path_list_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       item: &hir::PathListItem,\n                                       cb: &mut FnMut(DefId, Span,\n                                                      &Option<&Stability>,\n-                                                     &Option<Deprecation>)) {\n+                                                     &Option<DeprecationEntry>)) {\n     match tcx.expect_def(item.node.id()) {\n         Def::PrimTy(..) => {}\n         def => {\n@@ -607,7 +642,7 @@ pub fn check_path_list_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n                            cb: &mut FnMut(DefId, Span,\n                                           &Option<&Stability>,\n-                                          &Option<Deprecation>)) {\n+                                          &Option<DeprecationEntry>)) {\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n@@ -638,7 +673,7 @@ fn maybe_do_stability_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       id: DefId, span: Span,\n                                       cb: &mut FnMut(DefId, Span,\n                                                      &Option<&Stability>,\n-                                                     &Option<Deprecation>)) {\n+                                                     &Option<DeprecationEntry>)) {\n     if is_internal(tcx, span) {\n         debug!(\"maybe_do_stability_check: \\\n                 skipping span={:?} since it is internal\", span);\n@@ -647,7 +682,7 @@ fn maybe_do_stability_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (stability, deprecation) = if is_staged_api(tcx, id) {\n         (tcx.lookup_stability(id), None)\n     } else {\n-        (None, tcx.lookup_deprecation(id))\n+        (None, tcx.lookup_deprecation_entry(id))\n     };\n     debug!(\"maybe_do_stability_check: \\\n             inspecting id={:?} span={:?} of stability={:?}\", id, span, stability);\n@@ -685,6 +720,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n+        self.lookup_deprecation_entry(id).map(|depr| depr.attr)\n+    }\n+\n+    pub fn lookup_deprecation_entry(self, id: DefId) -> Option<DeprecationEntry> {\n         if let Some(depr) = self.stability.borrow().depr_map.get(&id) {\n             return depr.clone();\n         }\n@@ -703,12 +742,12 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    fn lookup_deprecation_uncached(self, id: DefId) -> Option<Deprecation> {\n+    fn lookup_deprecation_uncached(self, id: DefId) -> Option<DeprecationEntry> {\n         debug!(\"lookup(id={:?})\", id);\n         if id.is_local() {\n             None // The stability cache is filled partially lazily\n         } else {\n-            self.sess.cstore.deprecation(id)\n+            self.sess.cstore.deprecation(id).map(DeprecationEntry::external)\n         }\n     }\n }"}, {"sha": "f32db9207fc6f261bf1750c712d396150a0104a1", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 56, "deletions": 15, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -30,7 +30,7 @@ use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::feature_gate::UnstableFeatures;\n \n-use errors::{ColorConfig, Handler};\n+use errors::{ColorConfig, FatalError, Handler};\n \n use getopts;\n use std::collections::HashMap;\n@@ -61,7 +61,7 @@ pub enum DebugInfoLevel {\n     FullDebugInfo,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum OutputType {\n     Bitcode,\n     Assembly,\n@@ -105,6 +105,17 @@ impl OutputType {\n             OutputType::DepInfo => \"dep-info\",\n         }\n     }\n+\n+    pub fn extension(&self) -> &'static str {\n+        match *self {\n+            OutputType::Bitcode => \"bc\",\n+            OutputType::Assembly => \"s\",\n+            OutputType::LlvmAssembly => \"ll\",\n+            OutputType::Object => \"o\",\n+            OutputType::DepInfo => \"d\",\n+            OutputType::Exe => \"\",\n+        }\n+    }\n }\n \n #[derive(Clone)]\n@@ -219,15 +230,7 @@ impl OutputFilenames {\n                      flavor: OutputType,\n                      codegen_unit_name: Option<&str>)\n                      -> PathBuf {\n-        let extension = match flavor {\n-            OutputType::Bitcode => \"bc\",\n-            OutputType::Assembly => \"s\",\n-            OutputType::LlvmAssembly => \"ll\",\n-            OutputType::Object => \"o\",\n-            OutputType::DepInfo => \"d\",\n-            OutputType::Exe => \"\",\n-        };\n-\n+        let extension = flavor.extension();\n         self.temp_path_ext(extension, codegen_unit_name)\n     }\n \n@@ -331,6 +334,11 @@ impl Options {\n             self.debugging_opts.dump_dep_graph ||\n             self.debugging_opts.query_dep_graph\n     }\n+\n+    pub fn single_codegen_unit(&self) -> bool {\n+        self.incremental.is_none() ||\n+        self.cg.codegen_units == 1\n+    }\n }\n \n // The type of entry function, so\n@@ -459,6 +467,8 @@ macro_rules! options {\n         pub const parse_bool: Option<&'static str> = None;\n         pub const parse_opt_bool: Option<&'static str> =\n             Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n+        pub const parse_all_bool: Option<&'static str> =\n+            Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n         pub const parse_string: Option<&'static str> = Some(\"a string\");\n         pub const parse_opt_string: Option<&'static str> = Some(\"a string\");\n         pub const parse_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n@@ -508,6 +518,25 @@ macro_rules! options {\n             }\n         }\n \n+        fn parse_all_bool(slot: &mut bool, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => {\n+                    match s {\n+                        \"n\" | \"no\" | \"off\" => {\n+                            *slot = false;\n+                        }\n+                        \"y\" | \"yes\" | \"on\" => {\n+                            *slot = true;\n+                        }\n+                        _ => { return false; }\n+                    }\n+\n+                    true\n+                },\n+                None => { *slot = true; true }\n+            }\n+        }\n+\n         fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => { *slot = Some(s.to_string()); true },\n@@ -656,7 +685,6 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"panic strategy to compile crate with\"),\n }\n \n-\n options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n          build_debugging_options, \"Z\", \"debugging\",\n          DB_OPTIONS, db_type_desc, dbsetters,\n@@ -751,7 +779,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"set the MIR optimization level (0-3)\"),\n     dump_mir: Option<String> = (None, parse_opt_string,\n           \"dump MIR state at various points in translation\"),\n-    orbit: bool = (false, parse_bool,\n+    dump_mir_dir: Option<String> = (None, parse_opt_string,\n+          \"the directory the MIR is dumped into\"),\n+    orbit: bool = (true, parse_all_bool,\n           \"get MIR where it belongs - everywhere; most importantly, in orbit\"),\n }\n \n@@ -835,7 +865,10 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n     let target = match Target::search(&opts.target_triple) {\n         Ok(t) => t,\n         Err(e) => {\n-            panic!(sp.fatal(&format!(\"Error loading target specification: {}\", e)));\n+            sp.struct_fatal(&format!(\"Error loading target specification: {}\", e))\n+                .help(\"Use `--print target-list` for a list of built-in targets\")\n+                .emit();\n+            panic!(FatalError);\n         }\n     };\n \n@@ -1140,7 +1173,15 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         })\n     });\n \n-    let debugging_opts = build_debugging_options(matches, error_format);\n+    let mut debugging_opts = build_debugging_options(matches, error_format);\n+\n+    // Incremental compilation only works reliably when translation is done via\n+    // MIR, so let's enable -Z orbit if necessary (see #34973).\n+    if debugging_opts.incremental.is_some() && !debugging_opts.orbit {\n+        early_warn(error_format, \"Automatically enabling `-Z orbit` because \\\n+                                  `-Z incremental` was specified\");\n+        debugging_opts.orbit = true;\n+    }\n \n     let parse_only = debugging_opts.parse_only;\n     let no_trans = debugging_opts.no_trans;"}, {"sha": "cee18232ec98a05b71e2400ffc63b9a30bb833b3", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 9, "deletions": 79, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -80,7 +80,7 @@ pub struct Session {\n     // forms a unique global identifier for the crate. It is used to allow\n     // multiple crates with the same name to coexist. See the\n     // trans::back::symbol_names module for more information.\n-    pub crate_disambiguator: Cell<ast::Name>,\n+    pub crate_disambiguator: RefCell<token::InternedString>,\n     pub features: RefCell<feature_gate::Features>,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n@@ -106,6 +106,9 @@ pub struct Session {\n }\n \n impl Session {\n+    pub fn local_crate_disambiguator(&self) -> token::InternedString {\n+        self.crate_disambiguator.borrow().clone()\n+    }\n     pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n                                                     sp: S,\n                                                     msg: &str)\n@@ -126,20 +129,14 @@ impl Session {\n                                                    sp: S,\n                                                    msg: &str)\n                                                    -> DiagnosticBuilder<'a>  {\n-        match split_msg_into_multilines(msg) {\n-            Some(ref msg) => self.diagnostic().struct_span_err(sp, msg),\n-            None => self.diagnostic().struct_span_err(sp, msg),\n-        }\n+        self.diagnostic().struct_span_err(sp, msg)\n     }\n     pub fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n                                                              sp: S,\n                                                              msg: &str,\n                                                              code: &str)\n                                                              -> DiagnosticBuilder<'a>  {\n-        match split_msg_into_multilines(msg) {\n-            Some(ref msg) => self.diagnostic().struct_span_err_with_code(sp, msg, code),\n-            None => self.diagnostic().struct_span_err_with_code(sp, msg, code),\n-        }\n+        self.diagnostic().struct_span_err_with_code(sp, msg, code)\n     }\n     pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n         self.diagnostic().struct_err(msg)\n@@ -178,16 +175,10 @@ impl Session {\n         }\n     }\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        match split_msg_into_multilines(msg) {\n-            Some(msg) => self.diagnostic().span_err(sp, &msg),\n-            None => self.diagnostic().span_err(sp, msg)\n-        }\n+        self.diagnostic().span_err(sp, msg)\n     }\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n-        match split_msg_into_multilines(msg) {\n-            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg, code),\n-            None => self.diagnostic().span_err_with_code(sp, msg, code)\n-        }\n+        self.diagnostic().span_err_with_code(sp, &msg, code)\n     }\n     pub fn err(&self, msg: &str) {\n         self.diagnostic().err(msg)\n@@ -343,67 +334,6 @@ impl Session {\n     }\n }\n \n-fn split_msg_into_multilines(msg: &str) -> Option<String> {\n-    // Conditions for enabling multi-line errors:\n-    if !msg.contains(\"mismatched types\") &&\n-        !msg.contains(\"type mismatch resolving\") &&\n-        !msg.contains(\"if and else have incompatible types\") &&\n-        !msg.contains(\"if may be missing an else clause\") &&\n-        !msg.contains(\"match arms have incompatible types\") &&\n-        !msg.contains(\"structure constructor specifies a structure of type\") &&\n-        !msg.contains(\"has an incompatible type for trait\") {\n-            return None\n-    }\n-    let first = msg.match_indices(\"expected\").filter(|s| {\n-        let last = msg[..s.0].chars().rev().next();\n-        last == Some(' ') || last == Some('(')\n-    }).map(|(a, b)| (a - 1, a + b.len()));\n-    let second = msg.match_indices(\"found\").filter(|s| {\n-        msg[..s.0].chars().rev().next() == Some(' ')\n-    }).map(|(a, b)| (a - 1, a + b.len()));\n-\n-    let mut new_msg = String::new();\n-    let mut head = 0;\n-\n-    // Insert `\\n` before expected and found.\n-    for (pos1, pos2) in first.zip(second) {\n-        new_msg = new_msg +\n-        // A `(` may be preceded by a space and it should be trimmed\n-                  msg[head..pos1.0].trim_right() + // prefix\n-                  \"\\n\" +                           // insert before first\n-                  &msg[pos1.0..pos1.1] +           // insert what first matched\n-                  &msg[pos1.1..pos2.0] +           // between matches\n-                  \"\\n   \" +                        // insert before second\n-        //           123\n-        // `expected` is 3 char longer than `found`. To align the types,\n-        // `found` gets 3 spaces prepended.\n-                  &msg[pos2.0..pos2.1];            // insert what second matched\n-\n-        head = pos2.1;\n-    }\n-\n-    let mut tail = &msg[head..];\n-    let third = tail.find(\"(values differ\")\n-                   .or(tail.find(\"(lifetime\"))\n-                   .or(tail.find(\"(cyclic type of infinite size\"));\n-    // Insert `\\n` before any remaining messages which match.\n-    if let Some(pos) = third {\n-        // The end of the message may just be wrapped in `()` without\n-        // `expected`/`found`.  Push this also to a new line and add the\n-        // final tail after.\n-        new_msg = new_msg +\n-        // `(` is usually preceded by a space and should be trimmed.\n-                  tail[..pos].trim_right() + // prefix\n-                  \"\\n\" +                     // insert before paren\n-                  &tail[pos..];              // append the tail\n-\n-        tail = \"\";\n-    }\n-\n-    new_msg.push_str(tail);\n-    return Some(new_msg);\n-}\n-\n pub fn build_session(sopts: config::Options,\n                      dep_graph: &DepGraph,\n                      local_crate_source_file: Option<PathBuf>,\n@@ -511,7 +441,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FnvHashMap()),\n-        crate_disambiguator: Cell::new(token::intern(\"\")),\n+        crate_disambiguator: RefCell::new(token::intern(\"\").as_str()),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n         next_node_id: Cell::new(1),"}, {"sha": "67ad887530eb318ccabe450784dc9480e11e5297", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 57, "deletions": 17, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -26,8 +26,9 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n-use infer::{InferCtxt};\n+use infer::{self, InferCtxt, TypeOrigin};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n use ty::subst::{self, Subst, TypeSpace};\n@@ -107,24 +108,63 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let predicate =\n             self.resolve_type_vars_if_possible(&obligation.predicate);\n \n-        if !predicate.references_error() {\n-            if let Some(warning_node_id) = warning_node_id {\n-                self.tcx.sess.add_lint(\n-                    ::lint::builtin::UNSIZED_IN_TUPLE,\n-                    warning_node_id,\n+        if predicate.references_error() {\n+            return\n+        }\n+        if let Some(warning_node_id) = warning_node_id {\n+            self.tcx.sess.add_lint(\n+                ::lint::builtin::UNSIZED_IN_TUPLE,\n+                warning_node_id,\n+                obligation.cause.span,\n+                format!(\"type mismatch resolving `{}`: {}\",\n+                        predicate,\n+                        error.err));\n+            return\n+        }\n+        self.probe(|_| {\n+            let origin = TypeOrigin::Misc(obligation.cause.span);\n+            let err_buf;\n+            let mut err = &error.err;\n+            let mut values = None;\n+\n+            // try to find the mismatched types to report the error with.\n+            //\n+            // this can fail if the problem was higher-ranked, in which\n+            // cause I have no idea for a good error message.\n+            if let ty::Predicate::Projection(ref data) = predicate {\n+                let mut selcx = SelectionContext::new(self);\n+                let (data, _) = self.replace_late_bound_regions_with_fresh_var(\n                     obligation.cause.span,\n-                    format!(\"type mismatch resolving `{}`: {}\",\n-                            predicate,\n-                            error.err));\n-            } else {\n-                let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0271,\n-                                               \"type mismatch resolving `{}`: {}\",\n-                                               predicate,\n-                                               error.err);\n-                self.note_obligation_cause(&mut err, obligation);\n-                err.emit();\n+                    infer::LateBoundRegionConversionTime::HigherRankedType,\n+                    data);\n+                let normalized = super::normalize_projection_type(\n+                    &mut selcx,\n+                    data.projection_ty,\n+                    obligation.cause.clone(),\n+                    0\n+                );\n+                let origin = TypeOrigin::Misc(obligation.cause.span);\n+                if let Err(error) = self.eq_types(\n+                    false, origin,\n+                    data.ty, normalized.value\n+                ) {\n+                    values = Some(infer::ValuePairs::Types(ExpectedFound {\n+                        expected: normalized.value,\n+                        found: data.ty,\n+                    }));\n+                    err_buf = error;\n+                    err = &err_buf;\n+                }\n             }\n-        }\n+\n+            let mut diag = struct_span_err!(\n+                self.tcx.sess, origin.span(), E0271,\n+                \"type mismatch resolving `{}`\", predicate\n+            );\n+            self.note_type_err(&mut diag, origin, values, err);\n+            self.note_obligation_cause(&mut diag, obligation);\n+            diag.emit();\n+        });\n     }\n \n     fn impl_substs(&self,"}, {"sha": "5444dd9476120ed2f8cb01418c7bb14b81afb83c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -504,7 +504,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn crate_disambiguator(self, cnum: ast::CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n-            self.sess.crate_disambiguator.get().as_str()\n+            self.sess.local_crate_disambiguator()\n         } else {\n             self.sess.cstore.crate_disambiguator(cnum)\n         }"}, {"sha": "16a54c20925deda7b8417a3747be29e6e0289bec", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -1018,3 +1018,16 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeScheme<'tcx>  {\n         self.generics.visit_with(visitor) || self.ty.visit_with(visitor)\n     }\n }\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::error::ExpectedFound<T> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::error::ExpectedFound {\n+            expected: self.expected.fold_with(folder),\n+            found: self.found.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.expected.visit_with(visitor) || self.found.visit_with(visitor)\n+    }\n+}"}, {"sha": "fadf36471555b7f83a151bffd55c7c6fa020a915", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -182,6 +182,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         pat_util::arm_contains_ref_binding(arm)\n     }\n \n+    pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n+        match ty.sty {\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                for field in def.all_fields() {\n+                    let field_ty = field.ty(self, substs);\n+                    if let TyError = field_ty.sty {\n+                        return true;\n+                    }\n+                }\n+            }\n+            _ => ()\n+        }\n+        false\n+    }\n+\n     /// Returns the type of element at index `i` in tuple or tuple-like type `t`.\n     /// For an enum `t`, `variant` is None only if `t` is a univariant enum.\n     pub fn positional_element_ty(self,"}, {"sha": "f4e1c06090e591a9d5d2abd1f33d4db4b019b10f", "filename": "src/librustc/util/fs.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Futil%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Futil%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Ffs.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -10,6 +10,8 @@\n \n use std::path::{self, Path, PathBuf};\n use std::ffi::OsString;\n+use std::fs;\n+use std::io;\n \n // Unfortunately, on windows, it looks like msvcrt.dll is silently translating\n // verbatim paths under the hood to non-verbatim paths! This manifests itself as\n@@ -53,3 +55,15 @@ pub fn fix_windows_verbatim_for_gcc(p: &Path) -> PathBuf {\n         _ => p.to_path_buf(),\n     }\n }\n+\n+/// Copy `p` into `q`, preferring to use hard-linking if possible. If\n+/// `q` already exists, it is removed first.\n+pub fn link_or_copy<P: AsRef<Path>, Q: AsRef<Path>>(p: P, q: Q) -> io::Result<()> {\n+    let p = p.as_ref();\n+    let q = q.as_ref();\n+    if q.exists() {\n+        try!(fs::remove_file(&q));\n+    }\n+    fs::hard_link(p, q)\n+        .or_else(|_| fs::copy(p, q).map(|_| ()))\n+}"}, {"sha": "60977a80946ff6e23950ef024d739eb4764a45a1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -974,7 +974,9 @@ impl fmt::Display for ty::InferTy {\n             ty::TyVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n             ty::IntVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n             ty::FloatVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => write!(f, \"_\"),\n+            ty::TyVar(_) => write!(f, \"_\"),\n+            ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n+            ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n             ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n             ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n             ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)"}, {"sha": "6530ccb0630db0342729b6f1892c9a560e39e007", "filename": "src/librustc_back/target/aarch64_apple_ios.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetOptions};\n+use target::{Target, TargetOptions, TargetResult};\n use super::apple_ios_base::{opts, Arch};\n \n-pub fn target() -> Target {\n-    Target {\n+pub fn target() -> TargetResult {\n+    let base = try!(opts(Arch::Arm64));\n+    Ok(Target {\n         llvm_target: \"arm64-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -25,7 +26,7 @@ pub fn target() -> Target {\n             features: \"+neon,+fp-armv8,+cyclone\".to_string(),\n             eliminate_frame_pointer: false,\n             max_atomic_width: 128,\n-            .. opts(Arch::Arm64)\n+            .. base\n         },\n-    }\n+    })\n }"}, {"sha": "7f54dab5b5385faa87e0185ab446712dec3cdcbc", "filename": "src/librustc_back/target/aarch64_linux_android.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,23 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n     base.max_atomic_width = 128;\n     // As documented in http://developer.android.com/ndk/guides/cpu-features.html\n     // the neon (ASIMD) and FP must exist on all android aarch64 targets.\n     base.features = \"+neon,+fp-armv8\".to_string();\n-    Target {\n+    Ok(Target {\n         llvm_target: \"aarch64-linux-android\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n-        data_layout: \"e-m:e-i64:64-i128:128-n32:64-S128\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"android\".to_string(),\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "cca965f9d4ff16c0c52d40f16c781c12171f953b", "filename": "src/librustc_back/target/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,20 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n     base.max_atomic_width = 128;\n-    Target {\n+    Ok(Target {\n         llvm_target: \"aarch64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n         target_env: \"gnu\".to_string(),\n-        data_layout: \"e-m:e-i64:64-i128:128-n32:64-S128\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "8bd9feabdbebe2a37e4bd099ef669c4659886b00", "filename": "src/librustc_back/target/apple_ios_base.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -36,7 +36,7 @@ impl Arch {\n     }\n }\n \n-pub fn get_sdk_root(sdk_name: &str) -> String {\n+pub fn get_sdk_root(sdk_name: &str) -> Result<String, String> {\n     let res = Command::new(\"xcrun\")\n                       .arg(\"--show-sdk-path\")\n                       .arg(\"-sdk\")\n@@ -55,21 +55,23 @@ pub fn get_sdk_root(sdk_name: &str) -> String {\n                       });\n \n     match res {\n-        Ok(output) => output.trim().to_string(),\n-        Err(e) => panic!(\"failed to get {} SDK path: {}\", sdk_name, e)\n+        Ok(output) => Ok(output.trim().to_string()),\n+        Err(e) => Err(format!(\"failed to get {} SDK path: {}\", sdk_name, e))\n     }\n }\n \n-fn pre_link_args(arch: Arch) -> Vec<String> {\n+fn build_pre_link_args(arch: Arch) -> Result<Vec<String>, String> {\n     let sdk_name = match arch {\n         Armv7 | Armv7s | Arm64 => \"iphoneos\",\n         I386 | X86_64 => \"iphonesimulator\"\n     };\n \n     let arch_name = arch.to_string();\n \n-    vec![\"-arch\".to_string(), arch_name.to_string(),\n-         \"-Wl,-syslibroot\".to_string(), get_sdk_root(sdk_name)]\n+    let sdk_root = try!(get_sdk_root(sdk_name));\n+\n+    Ok(vec![\"-arch\".to_string(), arch_name.to_string(),\n+         \"-Wl,-syslibroot\".to_string(), sdk_root])\n }\n \n fn target_cpu(arch: Arch) -> String {\n@@ -82,13 +84,14 @@ fn target_cpu(arch: Arch) -> String {\n     }.to_string()\n }\n \n-pub fn opts(arch: Arch) -> TargetOptions {\n-    TargetOptions {\n+pub fn opts(arch: Arch) -> Result<TargetOptions, String> {\n+    let pre_link_args = try!(build_pre_link_args(arch));\n+    Ok(TargetOptions {\n         cpu: target_cpu(arch),\n         dynamic_linking: false,\n         executables: true,\n-        pre_link_args: pre_link_args(arch),\n+        pre_link_args: pre_link_args,\n         has_elf_tls: false,\n         .. super::apple_base::opts()\n-    }\n+    })\n }"}, {"sha": "f3a18b13c6783b35cfd879e22b5b5fdbd0e605db", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n     base.features = \"+v7,+vfp3,+d16\".to_string();\n     base.max_atomic_width = 64;\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"arm-linux-androideabi\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -25,5 +25,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "e666a8460e5ea85d4ec626a6b7fa2ae9d000a189", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetOptions};\n+use target::{Target, TargetOptions, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n     base.max_atomic_width = 64;\n-    Target {\n+    Ok(Target {\n         llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -27,5 +27,5 @@ pub fn target() -> Target {\n             features: \"+v6\".to_string(),\n             .. base\n         },\n-    }\n+    })\n }"}, {"sha": "d65c89abc206496002f0194466e6969dfa62c7c3", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetOptions};\n+use target::{Target, TargetOptions, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n     base.max_atomic_width = 64;\n-    Target {\n+    Ok(Target {\n         llvm_target: \"arm-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -27,5 +27,5 @@ pub fn target() -> Target {\n             features: \"+v6,+vfp2\".to_string(),\n             .. base\n         }\n-    }\n+    })\n }"}, {"sha": "028c91eadaeb3e672b00f016a1f9df6278c13f08", "filename": "src/librustc_back/target/arm_unknown_linux_musleabi.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabi.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_musl_base::opts();\n+\n+    // Most of these settings are copied from the arm_unknown_linux_gnueabi\n+    // target.\n+    base.features = \"+v6\".to_string();\n+    base.max_atomic_width = 64;\n+    Ok(Target {\n+        // It's important we use \"gnueabi\" and not \"musleabi\" here. LLVM uses it\n+        // to determine the calling convention and float ABI, and it doesn't\n+        // support the \"musleabi\" value.\n+        llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        options: base,\n+    })\n+}"}, {"sha": "c7dda186f42589cb97a8be622a7e5c635381aa86", "filename": "src/librustc_back/target/arm_unknown_linux_musleabihf.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabihf.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_musl_base::opts();\n+\n+    // Most of these settings are copied from the arm_unknown_linux_gnueabihf\n+    // target.\n+    base.features = \"+v6,+vfp2\".to_string();\n+    base.max_atomic_width = 64;\n+    Ok(Target {\n+        // It's important we use \"gnueabihf\" and not \"musleabihf\" here. LLVM\n+        // uses it to determine the calling convention and float ABI, and it\n+        // doesn't support the \"musleabihf\" value.\n+        llvm_target: \"arm-unknown-linux-gnueabihf\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        options: base,\n+    })\n+}"}, {"sha": "a806204d0a6bcb6064bfd46bc7b2862a0e88b5bb", "filename": "src/librustc_back/target/armv7_apple_ios.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetOptions};\n+use target::{Target, TargetOptions, TargetResult};\n use super::apple_ios_base::{opts, Arch};\n \n-pub fn target() -> Target {\n-    Target {\n+pub fn target() -> TargetResult {\n+    let base = try!(opts(Arch::Armv7));\n+    Ok(Target {\n         llvm_target: \"armv7-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -24,7 +25,7 @@ pub fn target() -> Target {\n         options: TargetOptions {\n             features: \"+v7,+vfp3,+neon\".to_string(),\n             max_atomic_width: 64,\n-            .. opts(Arch::Armv7)\n+            .. base\n         }\n-    }\n+    })\n }"}, {"sha": "1c59262e04198b519cec108b2d81ff1c122d77f8", "filename": "src/librustc_back/target/armv7_linux_androideabi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n     base.features = \"+v7,+thumb2,+vfp3,+d16\".to_string();\n     base.max_atomic_width = 64;\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"armv7-none-linux-android\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -25,5 +25,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "52269f0cd4a08788408745f8dbc202bd728e6992", "filename": "src/librustc_back/target/armv7_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_gnueabihf.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetOptions};\n+use target::{Target, TargetOptions, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let base = super::linux_base::opts();\n-    Target {\n+    Ok(Target {\n         llvm_target: \"armv7-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -28,6 +28,6 @@ pub fn target() -> Target {\n             max_atomic_width: 64,\n             .. base\n         }\n-    }\n+    })\n }\n "}, {"sha": "e40704e5d49975e56c51bb88b22b0485bba7f530", "filename": "src/librustc_back/target/armv7_unknown_linux_musleabihf.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_musleabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_musleabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_musleabihf.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_musl_base::opts();\n+\n+    // Most of these settings are copied from the armv7_unknown_linux_gnueabihf\n+    // target.\n+    base.features = \"+v7,+vfp3,+neon\".to_string();\n+    base.cpu = \"cortex-a8\".to_string();\n+    base.max_atomic_width = 64;\n+    Ok(Target {\n+        // It's important we use \"gnueabihf\" and not \"musleabihf\" here. LLVM\n+        // uses it to determine the calling convention and float ABI, and LLVM\n+        // doesn't support the \"musleabihf\" value.\n+        llvm_target: \"armv7-unknown-linux-gnueabihf\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        options: base,\n+    })\n+}"}, {"sha": "aaa3570fa62ee6e2e01afad79b6a8b674557d570", "filename": "src/librustc_back/target/armv7s_apple_ios.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetOptions};\n+use target::{Target, TargetOptions, TargetResult};\n use super::apple_ios_base::{opts, Arch};\n \n-pub fn target() -> Target {\n-    Target {\n+pub fn target() -> TargetResult {\n+    let base = try!(opts(Arch::Armv7s));\n+    Ok(Target {\n         llvm_target: \"armv7s-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -24,7 +25,7 @@ pub fn target() -> Target {\n         options: TargetOptions {\n             features: \"+v7,+vfp4,+neon\".to_string(),\n             max_atomic_width: 64,\n-            .. opts(Arch::Armv7s)\n+            .. base\n         }\n-    }\n+    })\n }"}, {"sha": "07eb191471c46c58de2915ea70c32467377562bb", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -10,7 +10,7 @@\n \n use super::{Target, TargetOptions};\n \n-pub fn target() -> Target {\n+pub fn target() -> Result<Target, String> {\n     let opts = TargetOptions {\n         linker: \"emcc\".to_string(),\n         ar: \"emar\".to_string(),\n@@ -25,7 +25,7 @@ pub fn target() -> Target {\n         max_atomic_width: 32,\n         .. Default::default()\n     };\n-    Target {\n+    Ok(Target {\n         llvm_target: \"asmjs-unknown-emscripten\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -35,5 +35,5 @@ pub fn target() -> Target {\n         data_layout: \"e-p:32:32-i64:64-v128:32:128-n32-S128\".to_string(),\n         arch: \"asmjs\".to_string(),\n         options: opts,\n-    }\n+    })\n }"}, {"sha": "f391d4118ea74c6fc6b0a09cb67cc66e618d10b2", "filename": "src/librustc_back/target/i386_apple_ios.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetOptions};\n+use target::{Target, TargetOptions, TargetResult};\n use super::apple_ios_base::{opts, Arch};\n \n-pub fn target() -> Target {\n-    Target {\n+pub fn target() -> TargetResult {\n+    let base = try!(opts(Arch::I386));\n+    Ok(Target {\n         llvm_target: \"i386-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -23,7 +24,7 @@ pub fn target() -> Target {\n         target_vendor: \"apple\".to_string(),\n         options: TargetOptions {\n             max_atomic_width: 64,\n-            .. opts(Arch::I386)\n+            .. base\n         }\n-    }\n+    })\n }"}, {"sha": "445ee6c412283ff009b86d5d6a6e7b809bbf8a7c", "filename": "src/librustc_back/target/i586_pc_windows_msvc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi586_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi586_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi586_pc_windows_msvc.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::TargetResult;\n \n-pub fn target() -> Target {\n-    let mut base = super::i686_pc_windows_msvc::target();\n+pub fn target() -> TargetResult {\n+    let mut base = try!(super::i686_pc_windows_msvc::target());\n     base.options.cpu = \"pentium\".to_string();\n     base.llvm_target = \"i586-pc-windows-msvc\".to_string();\n-    return base\n+    Ok(base)\n }"}, {"sha": "1ca8606149bff6adf54a19887ee9b5864840d710", "filename": "src/librustc_back/target/i586_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi586_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi586_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi586_unknown_linux_gnu.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::TargetResult;\n \n-pub fn target() -> Target {\n-    let mut base = super::i686_unknown_linux_gnu::target();\n+pub fn target() -> TargetResult {\n+    let mut base = try!(super::i686_unknown_linux_gnu::target());\n     base.options.cpu = \"pentium\".to_string();\n     base.llvm_target = \"i586-unknown-linux-gnu\".to_string();\n-    return base\n+    Ok(base)\n }"}, {"sha": "4876a3489d4707a74cea0b21943421f4af44f62e", "filename": "src/librustc_back/target/i686_apple_darwin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::apple_base::opts();\n     base.cpu = \"yonah\".to_string();\n     base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m32\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"i686-apple-darwin\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"apple\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "1de629238a13c7b54c33f5794c5d7a2dfe5ae7f3", "filename": "src/librustc_back/target/i686_linux_android.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n \n     base.max_atomic_width = 64;\n@@ -19,7 +19,7 @@ pub fn target() -> Target {\n     base.cpu = \"pentiumpro\".to_string();\n     base.features = \"+mmx,+sse,+sse2,+sse3,+ssse3\".to_string();\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"i686-linux-android\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -29,5 +29,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "2c19b8109c36214db01be556fafb07efda981cd5", "filename": "src/librustc_back/target/i686_pc_windows_gnu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::windows_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = 64;\n@@ -19,7 +19,7 @@ pub fn target() -> Target {\n     // space available to x86 Windows binaries on x86_64.\n     base.pre_link_args.push(\"-Wl,--large-address-aware\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"i686-pc-windows-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -29,5 +29,5 @@ pub fn target() -> Target {\n         target_env: \"gnu\".to_string(),\n         target_vendor: \"pc\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "cb02fcc308c2d8f71cbbd8dd7e54d2193aecae23", "filename": "src/librustc_back/target/i686_pc_windows_msvc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::windows_msvc_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = 64;\n@@ -24,7 +24,7 @@ pub fn target() -> Target {\n     // https://msdn.microsoft.com/en-us/library/9a89h429.aspx\n     base.pre_link_args.push(\"/SAFESEH\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"i686-pc-windows-msvc\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -34,5 +34,5 @@ pub fn target() -> Target {\n         target_env: \"msvc\".to_string(),\n         target_vendor: \"pc\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "f96ec004b481eaf98fb908a1191bb8a814768294", "filename": "src/librustc_back/target/i686_unknown_dragonfly.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::dragonfly_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m32\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"i686-unknown-dragonfly\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "3489ecfe614d910a89901a686073f49307f9adac", "filename": "src/librustc_back/target/i686_unknown_freebsd.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::freebsd_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m32\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"i686-unknown-freebsd\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "f2e865c015e353b8e7b3e070cbb0fa1af11e1e78", "filename": "src/librustc_back/target/i686_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m32\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"i686-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"gnu\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "a0a8de46e2f59bd97eca8df993737cd26c5daef6", "filename": "src/librustc_back/target/i686_unknown_linux_musl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,16 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::linux_musl_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m32\".to_string());\n     base.pre_link_args.push(\"-Wl,-melf_i386\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"i686-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -27,5 +27,5 @@ pub fn target() -> Target {\n         target_env: \"musl\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "25132f8a044d6faacba46c043699aa994166bcb5", "filename": "src/librustc_back/target/le32_unknown_nacl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{Target, TargetOptions};\n+use super::{Target, TargetOptions, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let opts = TargetOptions {\n         linker: \"pnacl-clang\".to_string(),\n         ar: \"pnacl-ar\".to_string(),\n@@ -28,7 +28,7 @@ pub fn target() -> Target {\n         max_atomic_width: 32,\n         .. Default::default()\n     };\n-    Target {\n+    Ok(Target {\n         llvm_target: \"le32-unknown-nacl\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -38,5 +38,5 @@ pub fn target() -> Target {\n         data_layout: \"e-i64:64:64-p:32:32:32-v128:32:32\".to_string(),\n         arch: \"le32\".to_string(),\n         options: opts,\n-    }\n+    })\n }"}, {"sha": "ab967f6b40fbead30c78c771d38b723b90eac6af", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetOptions};\n+use target::{Target, TargetOptions, TargetResult};\n \n-pub fn target() -> Target {\n-    Target {\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n         llvm_target: \"mips-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -22,9 +22,9 @@ pub fn target() -> Target {\n         target_vendor: \"unknown\".to_string(),\n         options: TargetOptions {\n             cpu: \"mips32r2\".to_string(),\n-            features: \"+mips32r2,+soft-float\".to_string(),\n+            features: \"+mips32r2\".to_string(),\n             max_atomic_width: 32,\n             ..super::linux_base::opts()\n         },\n-    }\n+    })\n }"}, {"sha": "4a69bce53bc978a5a6c6b9a9ddbcf7f38ed4c107", "filename": "src/librustc_back/target/mips_unknown_linux_musl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetOptions};\n+use target::{Target, TargetOptions, TargetResult};\n \n-pub fn target() -> Target {\n-    Target {\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n         llvm_target: \"mips-unknown-linux-musl\".to_string(),\n         target_endian: \"big\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n             max_atomic_width: 32,\n             ..super::linux_base::opts()\n         }\n-    }\n+    })\n }"}, {"sha": "b66fb62cd591ecc97929f9547c930497c232867a", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetOptions};\n+use target::{Target, TargetOptions, TargetResult};\n \n-pub fn target() -> Target {\n-    Target {\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n         llvm_target: \"mipsel-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -27,5 +27,5 @@ pub fn target() -> Target {\n             max_atomic_width: 32,\n             ..super::linux_base::opts()\n         },\n-    }\n+    })\n }"}, {"sha": "a0524e5e763895877cc62067bfcd0b0d6a1d8836", "filename": "src/librustc_back/target/mipsel_unknown_linux_musl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetOptions};\n+use target::{Target, TargetOptions, TargetResult};\n \n-pub fn target() -> Target {\n-    Target {\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n         llvm_target: \"mipsel-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -22,9 +22,9 @@ pub fn target() -> Target {\n         target_vendor: \"unknown\".to_string(),\n         options: TargetOptions {\n             cpu: \"mips32\".to_string(),\n-            features: \"+mips32\".to_string(),\n+            features: \"+mips32,+soft-float\".to_string(),\n             max_atomic_width: 32,\n             ..super::linux_base::opts()\n         }\n-    }\n+    })\n }"}, {"sha": "3d24fd8ab67e4a2d4b1bd1d1a25ff95f3336933b", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 191, "deletions": 38, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -44,7 +44,8 @@\n //! the target's settings, though `target-feature` and `link-args` will *add*\n //! to the list specified by the target, rather than replace.\n \n-use serialize::json::Json;\n+use serialize::json::{Json, ToJson};\n+use std::collections::BTreeMap;\n use std::default::Default;\n use std::io::prelude::*;\n use syntax::abi::Abi;\n@@ -63,27 +64,61 @@ mod solaris_base;\n mod windows_base;\n mod windows_msvc_base;\n \n+pub type TargetResult = Result<Target, String>;\n+\n macro_rules! supported_targets {\n     ( $(($triple:expr, $module:ident)),+ ) => (\n         $(mod $module;)*\n \n         /// List of supported targets\n-        pub const TARGETS: &'static [&'static str] = &[$($triple),*];\n+        const TARGETS: &'static [&'static str] = &[$($triple),*];\n+\n+        fn load_specific(target: &str) -> TargetResult {\n+            match target {\n+                $(\n+                    $triple => {\n+                        let mut t = try!($module::target());\n+                        t.options.is_builtin = true;\n+\n+                        // round-trip through the JSON parser to ensure at\n+                        // run-time that the parser works correctly\n+                        t = try!(Target::from_json(t.to_json()));\n+                        debug!(\"Got builtin target: {:?}\", t);\n+                        Ok(t)\n+                    },\n+                )+\n+                _ => Err(format!(\"Unable to find target: {}\", target))\n+            }\n+        }\n+\n+        pub fn get_targets() -> Box<Iterator<Item=String>> {\n+            Box::new(TARGETS.iter().filter_map(|t| -> Option<String> {\n+                load_specific(t)\n+                    .map(|t| t.llvm_target)\n+                    .ok()\n+            }))\n+        }\n+\n+        #[cfg(test)]\n+        mod test_json_encode_decode {\n+            use serialize::json::ToJson;\n+            use super::Target;\n+            $(use super::$module;)*\n \n-        // this would use a match if stringify! were allowed in pattern position\n-        fn load_specific(target: &str) -> Option<Target> {\n-            let target = target.replace(\"-\", \"_\");\n-            if false { }\n             $(\n-                else if target == stringify!($module) {\n-                    let mut t = $module::target();\n-                    t.options.is_builtin = true;\n-                    debug!(\"Got builtin target: {:?}\", t);\n-                    return Some(t);\n+                #[test]\n+                fn $module() {\n+                    // Grab the TargetResult struct. If we successfully retrieved\n+                    // a Target, then the test JSON encoding/decoding can run for this\n+                    // Target on this testing platform (i.e., checking the iOS targets\n+                    // only on a Mac test platform).\n+                    let _ = $module::target().map(|original| {\n+                        let as_json = original.to_json();\n+                        let parsed = Target::from_json(as_json).unwrap();\n+                        assert_eq!(original, parsed);\n+                    });\n                 }\n             )*\n-\n-            None\n         }\n     )\n }\n@@ -99,7 +134,10 @@ supported_targets! {\n     (\"powerpc64le-unknown-linux-gnu\", powerpc64le_unknown_linux_gnu),\n     (\"arm-unknown-linux-gnueabi\", arm_unknown_linux_gnueabi),\n     (\"arm-unknown-linux-gnueabihf\", arm_unknown_linux_gnueabihf),\n+    (\"arm-unknown-linux-musleabi\", arm_unknown_linux_musleabi),\n+    (\"arm-unknown-linux-musleabihf\", arm_unknown_linux_musleabihf),\n     (\"armv7-unknown-linux-gnueabihf\", armv7_unknown_linux_gnueabihf),\n+    (\"armv7-unknown-linux-musleabihf\", armv7_unknown_linux_musleabihf),\n     (\"aarch64-unknown-linux-gnu\", aarch64_unknown_linux_gnu),\n     (\"x86_64-unknown-linux-musl\", x86_64_unknown_linux_musl),\n     (\"i686-unknown-linux-musl\", i686_unknown_linux_musl),\n@@ -147,7 +185,7 @@ supported_targets! {\n /// Everything `rustc` knows about how to compile for a specific target.\n ///\n /// Every field here must be specified, and has no default value.\n-#[derive(Clone, Debug)]\n+#[derive(PartialEq, Clone, Debug)]\n pub struct Target {\n     /// Target triple to pass to LLVM.\n     pub llvm_target: String,\n@@ -174,7 +212,7 @@ pub struct Target {\n ///\n /// This has an implementation of `Default`, see each field for what the default is. In general,\n /// these try to take \"minimal defaults\" that don't assume anything about the runtime they run in.\n-#[derive(Clone, Debug)]\n+#[derive(PartialEq, Clone, Debug)]\n pub struct TargetOptions {\n     /// Whether the target is built-in or loaded from a custom target specification.\n     pub is_builtin: bool,\n@@ -254,6 +292,13 @@ pub struct TargetOptions {\n     pub is_like_android: bool,\n     /// Whether the linker support GNU-like arguments such as -O. Defaults to false.\n     pub linker_is_gnu: bool,\n+    /// The MinGW toolchain has a known issue that prevents it from correctly\n+    /// handling COFF object files with more than 2^15 sections. Since each weak\n+    /// symbol needs its own COMDAT section, weak linkage implies a large\n+    /// number sections that easily exceeds the given limit for larger\n+    /// codebases. Consequently we want a way to disallow weak linkage on some\n+    /// platforms.\n+    pub allows_weak_linkage: bool,\n     /// Whether the linker support rpaths or not. Defaults to false.\n     pub has_rpath: bool,\n     /// Whether to disable linking to compiler-rt. Defaults to false, as LLVM\n@@ -329,6 +374,7 @@ impl Default for TargetOptions {\n             is_like_android: false,\n             is_like_msvc: false,\n             linker_is_gnu: false,\n+            allows_weak_linkage: true,\n             has_rpath: false,\n             no_compiler_rt: false,\n             no_default_libraries: true,\n@@ -365,16 +411,21 @@ impl Target {\n     }\n \n     /// Load a target descriptor from a JSON object.\n-    pub fn from_json(obj: Json) -> Target {\n-        // this is 1. ugly, 2. error prone.\n+    pub fn from_json(obj: Json) -> TargetResult {\n+        // While ugly, this code must remain this way to retain\n+        // compatibility with existing JSON fields and the internal\n+        // expected naming of the Target and TargetOptions structs.\n+        // To ensure compatibility is retained, the built-in targets\n+        // are round-tripped through this code to catch cases where\n+        // the JSON parser is not updated to match the structs.\n \n         let get_req_field = |name: &str| {\n             match obj.find(name)\n                      .map(|s| s.as_string())\n                      .and_then(|os| os.map(|s| s.to_string())) {\n-                Some(val) => val,\n+                Some(val) => Ok(val),\n                 None => {\n-                    panic!(\"Field {} in target specification is required\", name)\n+                    return Err(format!(\"Field {} in target specification is required\", name))\n                 }\n             }\n         };\n@@ -386,12 +437,12 @@ impl Target {\n         };\n \n         let mut base = Target {\n-            llvm_target: get_req_field(\"llvm-target\"),\n-            target_endian: get_req_field(\"target-endian\"),\n-            target_pointer_width: get_req_field(\"target-pointer-width\"),\n-            data_layout: get_req_field(\"data-layout\"),\n-            arch: get_req_field(\"arch\"),\n-            target_os: get_req_field(\"os\"),\n+            llvm_target: try!(get_req_field(\"llvm-target\")),\n+            target_endian: try!(get_req_field(\"target-endian\")),\n+            target_pointer_width: try!(get_req_field(\"target-pointer-width\")),\n+            data_layout: try!(get_req_field(\"data-layout\")),\n+            arch: try!(get_req_field(\"arch\")),\n+            target_os: try!(get_req_field(\"os\")),\n             target_env: get_opt_field(\"env\", \"\"),\n             target_vendor: get_opt_field(\"vendor\", \"unknown\"),\n             options: Default::default(),\n@@ -436,38 +487,51 @@ impl Target {\n             } );\n         }\n \n-        key!(cpu);\n-        key!(ar);\n+        key!(is_builtin, bool);\n         key!(linker);\n+        key!(ar);\n+        key!(pre_link_args, list);\n+        key!(pre_link_objects_exe, list);\n+        key!(pre_link_objects_dll, list);\n+        key!(late_link_args, list);\n+        key!(post_link_objects, list);\n+        key!(post_link_args, list);\n+        key!(cpu);\n+        key!(features);\n+        key!(dynamic_linking, bool);\n+        key!(executables, bool);\n         key!(relocation_model);\n         key!(code_model);\n+        key!(disable_redzone, bool);\n+        key!(eliminate_frame_pointer, bool);\n+        key!(function_sections, bool);\n         key!(dll_prefix);\n         key!(dll_suffix);\n         key!(exe_suffix);\n         key!(staticlib_prefix);\n         key!(staticlib_suffix);\n-        key!(features);\n-        key!(dynamic_linking, bool);\n-        key!(executables, bool);\n-        key!(disable_redzone, bool);\n-        key!(eliminate_frame_pointer, bool);\n-        key!(function_sections, bool);\n         key!(target_family, optional);\n         key!(is_like_osx, bool);\n+        key!(is_like_solaris, bool);\n         key!(is_like_windows, bool);\n         key!(is_like_msvc, bool);\n+        key!(is_like_android, bool);\n         key!(linker_is_gnu, bool);\n+        key!(allows_weak_linkage, bool);\n         key!(has_rpath, bool);\n         key!(no_compiler_rt, bool);\n         key!(no_default_libraries, bool);\n-        key!(pre_link_args, list);\n-        key!(post_link_args, list);\n+        key!(position_independent_executables, bool);\n         key!(archive_format);\n         key!(allow_asm, bool);\n         key!(custom_unwind_resume, bool);\n+        key!(lib_allocation_crate);\n+        key!(exe_allocation_crate);\n+        key!(has_elf_tls, bool);\n+        key!(obj_is_bitcode, bool);\n         key!(max_atomic_width, u64);\n \n-        base\n+        Ok(base)\n     }\n \n     /// Search RUST_TARGET_PATH for a JSON file specifying the given target\n@@ -490,10 +554,10 @@ impl Target {\n             f.read_to_end(&mut contents).map_err(|e| e.to_string())?;\n             let obj = json::from_reader(&mut &contents[..])\n                            .map_err(|e| e.to_string())?;\n-            Ok(Target::from_json(obj))\n+            Target::from_json(obj)\n         }\n \n-        if let Some(t) = load_specific(target) {\n+        if let Ok(t) = load_specific(target) {\n             return Ok(t)\n         }\n \n@@ -525,6 +589,95 @@ impl Target {\n     }\n }\n \n+impl ToJson for Target {\n+    fn to_json(&self) -> Json {\n+        let mut d = BTreeMap::new();\n+        let default: TargetOptions = Default::default();\n+\n+        macro_rules! target_val {\n+            ($attr:ident) => ( {\n+                let name = (stringify!($attr)).replace(\"_\", \"-\");\n+                d.insert(name.to_string(), self.$attr.to_json());\n+            } );\n+            ($attr:ident, $key_name:expr) => ( {\n+                let name = $key_name;\n+                d.insert(name.to_string(), self.$attr.to_json());\n+            } );\n+        }\n+\n+        macro_rules! target_option_val {\n+            ($attr:ident) => ( {\n+                let name = (stringify!($attr)).replace(\"_\", \"-\");\n+                if default.$attr != self.options.$attr {\n+                    d.insert(name.to_string(), self.options.$attr.to_json());\n+                }\n+            } );\n+            ($attr:ident, $key_name:expr) => ( {\n+                let name = $key_name;\n+                if default.$attr != self.options.$attr {\n+                    d.insert(name.to_string(), self.options.$attr.to_json());\n+                }\n+            } );\n+        }\n+\n+        target_val!(llvm_target);\n+        target_val!(target_endian);\n+        target_val!(target_pointer_width);\n+        target_val!(arch);\n+        target_val!(target_os, \"os\");\n+        target_val!(target_env, \"env\");\n+        target_val!(target_vendor, \"vendor\");\n+        target_val!(arch);\n+        target_val!(data_layout);\n+\n+        target_option_val!(is_builtin);\n+        target_option_val!(linker);\n+        target_option_val!(ar);\n+        target_option_val!(pre_link_args);\n+        target_option_val!(pre_link_objects_exe);\n+        target_option_val!(pre_link_objects_dll);\n+        target_option_val!(late_link_args);\n+        target_option_val!(post_link_objects);\n+        target_option_val!(post_link_args);\n+        target_option_val!(cpu);\n+        target_option_val!(features);\n+        target_option_val!(dynamic_linking);\n+        target_option_val!(executables);\n+        target_option_val!(relocation_model);\n+        target_option_val!(code_model);\n+        target_option_val!(disable_redzone);\n+        target_option_val!(eliminate_frame_pointer);\n+        target_option_val!(function_sections);\n+        target_option_val!(dll_prefix);\n+        target_option_val!(dll_suffix);\n+        target_option_val!(exe_suffix);\n+        target_option_val!(staticlib_prefix);\n+        target_option_val!(staticlib_suffix);\n+        target_option_val!(target_family);\n+        target_option_val!(is_like_osx);\n+        target_option_val!(is_like_solaris);\n+        target_option_val!(is_like_windows);\n+        target_option_val!(is_like_msvc);\n+        target_option_val!(is_like_android);\n+        target_option_val!(linker_is_gnu);\n+        target_option_val!(allows_weak_linkage);\n+        target_option_val!(has_rpath);\n+        target_option_val!(no_compiler_rt);\n+        target_option_val!(no_default_libraries);\n+        target_option_val!(position_independent_executables);\n+        target_option_val!(archive_format);\n+        target_option_val!(allow_asm);\n+        target_option_val!(custom_unwind_resume);\n+        target_option_val!(lib_allocation_crate);\n+        target_option_val!(exe_allocation_crate);\n+        target_option_val!(has_elf_tls);\n+        target_option_val!(obj_is_bitcode);\n+        target_option_val!(max_atomic_width);\n+\n+        Json::Object(d)\n+    }\n+}\n+\n fn maybe_jemalloc() -> String {\n     if cfg!(feature = \"jemalloc\") {\n         \"alloc_jemalloc\".to_string()"}, {"sha": "1c04e763417c4b0574e6c043a9c8f2f0b1b7bdca", "filename": "src/librustc_back/target/powerpc64_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n     base.cpu = \"ppc64\".to_string();\n     base.pre_link_args.push(\"-m64\".to_string());\n     base.max_atomic_width = 64;\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"powerpc64-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"gnu\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "906e28d2f20cb1d0c778f8ab9e455414deaac481", "filename": "src/librustc_back/target/powerpc64le_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n     base.cpu = \"ppc64le\".to_string();\n     base.pre_link_args.push(\"-m64\".to_string());\n     base.max_atomic_width = 64;\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"powerpc64le-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"gnu\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "aebf9cd68717d18cc357114fbb99e122a8dbb13a", "filename": "src/librustc_back/target/powerpc_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n     base.pre_link_args.push(\"-m32\".to_string());\n     base.max_atomic_width = 32;\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"powerpc-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n@@ -25,5 +25,5 @@ pub fn target() -> Target {\n         target_env: \"gnu\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "c398ee40f2f9790bfe5b4f310a8773baf79a982c", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -25,6 +25,7 @@ pub fn opts() -> TargetOptions {\n         staticlib_suffix: \".lib\".to_string(),\n         no_default_libraries: true,\n         is_like_windows: true,\n+        allows_weak_linkage: false,\n         pre_link_args: vec!(\n             // And here, we see obscure linker flags #45. On windows, it has been\n             // found to be necessary to have this flag to compile liblibc."}, {"sha": "65e4b1400fcf8a68171356f1418c48b7e9f9db08", "filename": "src/librustc_back/target/x86_64_apple_darwin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,16 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::apple_base::opts();\n     base.cpu = \"core2\".to_string();\n     base.max_atomic_width = 128; // core2 support cmpxchg16b\n     base.eliminate_frame_pointer = false;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"x86_64-apple-darwin\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -27,5 +27,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"apple\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "4afc9bcb946c29da9b04cc13effaa140fcf17a50", "filename": "src/librustc_back/target/x86_64_apple_ios.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetOptions};\n+use target::{Target, TargetOptions, TargetResult};\n use super::apple_ios_base::{opts, Arch};\n \n-pub fn target() -> Target {\n-    Target {\n+pub fn target() -> TargetResult {\n+    let base = try!(opts(Arch::X86_64));\n+    Ok(Target {\n         llvm_target: \"x86_64-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -23,7 +24,7 @@ pub fn target() -> Target {\n         target_vendor: \"apple\".to_string(),\n         options: TargetOptions {\n             max_atomic_width: 64,\n-            .. opts(Arch::X86_64)\n+            .. base\n         }\n-    }\n+    })\n }"}, {"sha": "086e0e6bf4fe7edc723082853fdd9e9ee71c12d7", "filename": "src/librustc_back/target/x86_64_pc_windows_gnu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::windows_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.pre_link_args.push(\"-m64\".to_string());\n     base.max_atomic_width = 64;\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"x86_64-pc-windows-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"gnu\".to_string(),\n         target_vendor: \"pc\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "064f06e9b31d6fbc1555cf0aa1ee3fe55a810ccb", "filename": "src/librustc_back/target/x86_64_pc_windows_msvc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::windows_msvc_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = 64;\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"x86_64-pc-windows-msvc\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -25,5 +25,5 @@ pub fn target() -> Target {\n         target_env: \"msvc\".to_string(),\n         target_vendor: \"pc\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "fd6578c2a2a0a91fe55c3589a9d6446aa539d6e1", "filename": "src/librustc_back/target/x86_64_rumprun_netbsd.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::netbsd_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n     base.pre_link_args.push(\"-m64\".to_string());\n     base.linker = \"x86_64-rumprun-netbsd-gcc\".to_string();\n     base.ar = \"x86_64-rumprun-netbsd-ar\".to_string();\n@@ -24,7 +25,7 @@ pub fn target() -> Target {\n     base.no_default_libraries = false;\n     base.exe_allocation_crate = \"alloc_system\".to_string();\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"x86_64-rumprun-netbsd\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -34,5 +35,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"rumprun\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "2a1feb937f742f3fc59a9fc2141701465af30737", "filename": "src/librustc_back/target/x86_64_sun_solaris.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_sun_solaris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_sun_solaris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_sun_solaris.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::solaris_base::opts();\n     base.pre_link_args.push(\"-m64\".to_string());\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = 64;\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"x86_64-pc-solaris\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"sun\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "38209655898156b61ba3392f90c0e743bb9ad242", "filename": "src/librustc_back/target/x86_64_unknown_bitrig.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::bitrig_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"x86_64-unknown-bitrig\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -25,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "7e40d49b870ade9d49c3d21faebd71f0ac6cd0d7", "filename": "src/librustc_back/target/x86_64_unknown_dragonfly.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::dragonfly_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"x86_64-unknown-dragonfly\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "f38cdd4bec55f733be6955868e77949777bd0336", "filename": "src/librustc_back/target/x86_64_unknown_freebsd.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::freebsd_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"x86_64-unknown-freebsd\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "ef81d397a8f1e9f9684721988a864261481c214d", "filename": "src/librustc_back/target/x86_64_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"x86_64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"gnu\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "4bad7754b3907d8b0ef51e108415c61267d2e64a", "filename": "src/librustc_back/target/x86_64_unknown_linux_musl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::linux_musl_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"x86_64-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"musl\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "2d0b1e2a9330bac956cbfd18ed9d3efd8a57f4e6", "filename": "src/librustc_back/target/x86_64_unknown_netbsd.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_netbsd.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::netbsd_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"x86_64-unknown-netbsd\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -25,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "339dbd591a02e21be8de7a9775260d37e1b63a09", "filename": "src/librustc_back/target/x86_64_unknown_openbsd.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::Target;\n+use target::{Target, TargetResult};\n \n-pub fn target() -> Target {\n+pub fn target() -> TargetResult {\n     let mut base = super::openbsd_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = 64;\n     base.pre_link_args.push(\"-m64\".to_string());\n \n-    Target {\n+    Ok(Target {\n         llvm_target: \"x86_64-unknown-openbsd\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> Target {\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         options: base,\n-    }\n+    })\n }"}, {"sha": "1fe47cd4853876ae544d568f32e65ac0481ffab2", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -197,7 +197,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                              decl,\n                              body);\n \n-    intravisit::walk_fn(this, fk, decl, body, sp);\n+    intravisit::walk_fn(this, fk, decl, body, sp, id);\n }\n \n fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,"}, {"sha": "8967672548b101b3b35a01f04b8207ab8b5d1198", "filename": "src/librustc_const_eval/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -14,6 +14,7 @@ serialize = { path = \"../libserialize\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n syntax = { path = \"../libsyntax\" }\n graphviz = { path = \"../libgraphviz\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file"}, {"sha": "d148d2a0885ed3375f59da34e09b648967462fc4", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -17,6 +17,7 @@ use rustc::middle::const_val::ConstVal;\n use ::{eval_const_expr, eval_const_expr_partial, compare_const_vals};\n use ::{const_expr_to_pat, lookup_const_by_id};\n use ::EvalHint::ExprTypeChecked;\n+use eval::report_const_eval_err;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{DefId};\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n@@ -33,7 +34,7 @@ use std::iter::{FromIterator, IntoIterator, repeat};\n \n use rustc::hir;\n use rustc::hir::{Pat, PatKind};\n-use rustc::hir::intravisit::{self, IdVisitor, IdVisitingOperation, Visitor, FnKind};\n+use rustc::hir::intravisit::{self, Visitor, FnKind};\n use rustc_back::slice;\n \n use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n@@ -42,6 +43,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir::fold::{Folder, noop_fold_pat};\n use rustc::hir::print::pat_to_string;\n use syntax::ptr::P;\n+use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n@@ -279,13 +281,7 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n                 Ok(_) => {}\n \n                 Err(err) => {\n-                    let mut diag = struct_span_err!(cx.tcx.sess, err.span, E0471,\n-                                                    \"constant evaluation error: {}\",\n-                                                    err.description());\n-                    if !p.span.contains(err.span) {\n-                        diag.span_note(p.span, \"in pattern here\");\n-                    }\n-                    diag.emit();\n+                    report_const_eval_err(cx.tcx, &err, p.span, \"pattern\").emit();\n                 }\n             }\n         }\n@@ -339,6 +335,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n                         hir::MatchSource::Normal => {\n                             let mut err = struct_span_err!(cx.tcx.sess, pat.span, E0001,\n                                                            \"unreachable pattern\");\n+                            err.span_label(pat.span, &format!(\"this is an unreachable pattern\"));\n                             // if we had a catchall pattern, hint at that\n                             for row in &seen.0 {\n                                 if pat_is_catchall(&cx.tcx.def_map.borrow(), row[0].0) {\n@@ -478,7 +475,7 @@ struct RenamingRecorder<'map> {\n     renaming_map: &'map mut FnvHashMap<(NodeId, Span), NodeId>\n }\n \n-impl<'map> IdVisitingOperation for RenamingRecorder<'map> {\n+impl<'v, 'map> Visitor<'v> for RenamingRecorder<'map> {\n     fn visit_id(&mut self, node_id: NodeId) {\n         let key = (node_id, self.origin_span);\n         self.renaming_map.insert(key, self.substituted_node_id);\n@@ -533,9 +530,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                 renaming_map: renaming_map,\n             };\n \n-            let mut id_visitor = IdVisitor::new(&mut renaming_recorder);\n-\n-            id_visitor.visit_expr(const_expr);\n+            renaming_recorder.visit_expr(const_expr);\n         }\n     }\n }\n@@ -838,22 +833,19 @@ pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> us\n     }\n }\n \n-fn range_covered_by_constructor(ctor: &Constructor,\n-                                from: &ConstVal, to: &ConstVal) -> Option<bool> {\n+fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n+                                ctor: &Constructor,\n+                                from: &ConstVal, to: &ConstVal)\n+                                -> Result<bool, ErrorReported> {\n     let (c_from, c_to) = match *ctor {\n         ConstantValue(ref value)        => (value, value),\n         ConstantRange(ref from, ref to) => (from, to),\n-        Single                          => return Some(true),\n+        Single                          => return Ok(true),\n         _                               => bug!()\n     };\n-    let cmp_from = compare_const_vals(c_from, from);\n-    let cmp_to = compare_const_vals(c_to, to);\n-    match (cmp_from, cmp_to) {\n-        (Some(cmp_from), Some(cmp_to)) => {\n-            Some(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n-        }\n-        _ => None\n-    }\n+    let cmp_from = compare_const_vals(tcx, span, c_from, from)?;\n+    let cmp_to = compare_const_vals(tcx, span, c_to, to)?;\n+    Ok(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n }\n \n fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n@@ -965,27 +957,25 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Some(vec![(pat, Some(mt.ty))])\n             } else {\n                 let expr_value = eval_const_expr(cx.tcx, &expr);\n-                match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n-                    Some(true) => Some(vec![]),\n-                    Some(false) => None,\n-                    None => {\n-                        span_err!(cx.tcx.sess, pat_span, E0298, \"mismatched types between arms\");\n-                        None\n-                    }\n+                match range_covered_by_constructor(\n+                    cx.tcx, expr.span, constructor, &expr_value, &expr_value\n+                ) {\n+                    Ok(true) => Some(vec![]),\n+                    Ok(false) => None,\n+                    Err(ErrorReported) => None,\n                 }\n             }\n         }\n \n         PatKind::Range(ref from, ref to) => {\n             let from_value = eval_const_expr(cx.tcx, &from);\n             let to_value = eval_const_expr(cx.tcx, &to);\n-            match range_covered_by_constructor(constructor, &from_value, &to_value) {\n-                Some(true) => Some(vec![]),\n-                Some(false) => None,\n-                None => {\n-                    span_err!(cx.tcx.sess, pat_span, E0299, \"mismatched types between arms\");\n-                    None\n-                }\n+            match range_covered_by_constructor(\n+                cx.tcx, pat_span, constructor, &from_value, &to_value\n+            ) {\n+                Ok(true) => Some(vec![]),\n+                Ok(false) => None,\n+                Err(ErrorReported) => None,\n             }\n         }\n \n@@ -1058,7 +1048,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n         _ => cx.param_env = ParameterEnvironment::for_item(cx.tcx, fn_id),\n     }\n \n-    intravisit::walk_fn(cx, kind, decl, body, sp);\n+    intravisit::walk_fn(cx, kind, decl, body, sp, fn_id);\n \n     for input in &decl.inputs {\n         check_irrefutable(cx, &input.pat, true);"}, {"sha": "45414c33c075448640ef116443fcaf58f23d4e0d", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -551,44 +551,46 @@ The `op_string_ref` binding has type `&Option<&String>` in both cases.\n See also https://github.com/rust-lang/rust/issues/14587\n \"##,\n \n-E0306: r##\"\n-In an array literal `[x; N]`, `N` is the number of elements in the array. This\n-must be an unsigned integer. Erroneous code example:\n+E0080: r##\"\n+This error indicates that the compiler was unable to sensibly evaluate an\n+constant expression that had to be evaluated. Attempting to divide by 0\n+or causing integer overflow are two ways to induce this error. For example:\n \n ```compile_fail\n-let x = [0i32; true]; // error: expected positive integer for repeat count,\n-                      //        found boolean\n+enum Enum {\n+    X = (1 << 500),\n+    Y = (1 / 0)\n+}\n ```\n \n-Working example:\n+Ensure that the expressions given can be evaluated as the desired integer type.\n+See the FFI section of the Reference for more information about using a custom\n+integer type:\n \n-```\n-let x = [0i32; 2];\n-```\n+https://doc.rust-lang.org/reference.html#ffi-attributes\n \"##,\n \n-E0307: r##\"\n-The length of an array is part of its type. For this reason, this length must\n-be a compile-time constant. Erroneous code example:\n+\n+E0306: r##\"\n+In an array literal `[x; N]`, `N` is the number of elements in the array. This\n+must be an unsigned integer. Erroneous code example:\n \n ```compile_fail\n-    let len = 10;\n-    let x = [0i32; len]; // error: expected constant integer for repeat count,\n-                         //        found variable\n+let x = [0i32; true]; // error: expected positive integer for repeat count,\n+                      //        found boolean\n ```\n \n Working example:\n \n ```\n-let x = [0i32; 10];\n+let x = [0i32; 2];\n ```\n \"##,\n-\n }\n \n \n register_diagnostics! {\n-E0298, // mismatched types between arms\n-E0299, // mismatched types between arms\n-E0471, // constant evaluation error: ..\n+    E0298, // cannot compare constants\n+//  E0299, // mismatched types between arms\n+//  E0471, // constant evaluation error (in pattern)\n }"}, {"sha": "d424b57c938411168550c1e229c9ff022fca94bf", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 187, "deletions": 75, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -17,14 +17,15 @@ use self::EvalHint::*;\n \n use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::middle::cstore::{self, InlinedItem};\n+use rustc::middle::cstore::InlinedItem;\n use rustc::traits;\n use rustc::hir::def::{Def, PathResolution};\n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt, subst};\n use rustc::ty::util::IntTypeExt;\n use rustc::traits::ProjectionMode;\n+use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc::lint;\n \n@@ -43,6 +44,7 @@ use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n \n use rustc_const_math::*;\n+use rustc_errors::{DiagnosticBuilder, check_old_school};\n \n macro_rules! math {\n     ($e:expr, $op:expr) => {\n@@ -140,13 +142,13 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         let mut used_substs = false;\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-            cstore::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n+            Some((&InlinedItem::Item(ref item), _)) => match item.node {\n                 hir::ItemConst(ref ty, ref const_expr) => {\n                     Some((&**const_expr, tcx.ast_ty_to_prim_ty(ty)))\n                 },\n                 _ => None\n             },\n-            cstore::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n+            Some((&InlinedItem::TraitItem(trait_id, ref ti), _)) => match ti.node {\n                 hir::ConstTraitItem(_, _) => {\n                     used_substs = true;\n                     if let Some(substs) = substs {\n@@ -161,7 +163,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n                 _ => None\n             },\n-            cstore::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n+            Some((&InlinedItem::ImplItem(_, ref ii), _)) => match ii.node {\n                 hir::ImplItemKind::Const(ref ty, ref expr) => {\n                     Some((&**expr, tcx.ast_ty_to_prim_ty(ty)))\n                 },\n@@ -196,8 +198,8 @@ fn inline_const_fn_from_external_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let fn_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-        cstore::FoundAst::Found(&InlinedItem::Item(ref item)) => Some(item.id),\n-        cstore::FoundAst::Found(&InlinedItem::ImplItem(_, ref item)) => Some(item.id),\n+        Some((&InlinedItem::Item(ref item), _)) => Some(item.id),\n+        Some((&InlinedItem::ImplItem(_, ref item), _)) => Some(item.id),\n         _ => None\n     };\n     tcx.extern_const_fns.borrow_mut().insert(def_id,\n@@ -338,20 +340,71 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Ok(P(hir::Pat { id: expr.id, node: pat, span: span }))\n }\n \n+pub fn report_const_eval_err<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    err: &ConstEvalErr,\n+    primary_span: Span,\n+    primary_kind: &str)\n+    -> DiagnosticBuilder<'tcx>\n+{\n+    let mut err = err;\n+    while let &ConstEvalErr { kind: ErroneousReferencedConstant(box ref i_err), .. } = err {\n+        err = i_err;\n+    }\n+\n+    let mut diag = struct_span_err!(tcx.sess, err.span, E0080, \"constant evaluation error\");\n+    note_const_eval_err(tcx, err, primary_span, primary_kind, &mut diag);\n+    diag\n+}\n+\n+pub fn fatal_const_eval_err<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    err: &ConstEvalErr,\n+    primary_span: Span,\n+    primary_kind: &str)\n+    -> !\n+{\n+    report_const_eval_err(tcx, err, primary_span, primary_kind).emit();\n+    tcx.sess.abort_if_errors();\n+    unreachable!()\n+}\n+\n+pub fn note_const_eval_err<'a, 'tcx>(\n+    _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    err: &ConstEvalErr,\n+    primary_span: Span,\n+    primary_kind: &str,\n+    diag: &mut DiagnosticBuilder)\n+{\n+    match err.description() {\n+        ConstEvalErrDescription::Simple(message) => {\n+            if check_old_school() {\n+                diag.note(&message);\n+            } else {\n+                diag.span_label(err.span, &message);\n+            }\n+        }\n+    }\n+\n+    if !primary_span.contains(err.span) {\n+        diag.span_note(primary_span,\n+                       &format!(\"for {} here\", primary_kind));\n+    }\n+}\n+\n pub fn eval_const_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  e: &Expr) -> ConstVal {\n     match eval_const_expr_partial(tcx, e, ExprTypeChecked, None) {\n         Ok(r) => r,\n         // non-const path still needs to be a fatal error, because enums are funky\n         Err(s) => {\n+            report_const_eval_err(tcx, &s, e.span, \"expression\").emit();\n             match s.kind {\n                 NonConstPath |\n-                UnimplementedConstVal(_) => tcx.sess.span_fatal(s.span, &s.description()),\n-                _ => {\n-                    tcx.sess.span_err(s.span, &s.description());\n-                    Dummy\n-                }\n+                UnimplementedConstVal(_) => tcx.sess.abort_if_errors(),\n+                _ => {}\n             }\n+            Dummy\n         },\n     }\n }\n@@ -400,6 +453,7 @@ pub enum ErrKind {\n     IntermediateUnsignedNegative,\n     /// Expected, Got\n     TypeMismatch(String, ConstInt),\n+\n     BadType(ConstVal),\n     ErroneousReferencedConstant(Box<ConstEvalErr>),\n     CharCast(ConstInt),\n@@ -411,57 +465,79 @@ impl From<ConstMathErr> for ErrKind {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+pub enum ConstEvalErrDescription<'a> {\n+    Simple(Cow<'a, str>),\n+}\n+\n+impl<'a> ConstEvalErrDescription<'a> {\n+    /// Return a one-line description of the error, for lints and such\n+    pub fn into_oneline(self) -> Cow<'a, str> {\n+        match self {\n+            ConstEvalErrDescription::Simple(simple) => simple,\n+        }\n+    }\n+}\n+\n impl ConstEvalErr {\n-    pub fn description(&self) -> Cow<str> {\n+    pub fn description(&self) -> ConstEvalErrDescription {\n         use self::ErrKind::*;\n+        use self::ConstEvalErrDescription::*;\n+\n+        macro_rules! simple {\n+            ($msg:expr) => ({ Simple($msg.into_cow()) });\n+            ($fmt:expr, $($arg:tt)+) => ({\n+                Simple(format!($fmt, $($arg)+).into_cow())\n+            })\n+        }\n \n         match self.kind {\n-            CannotCast => \"can't cast this type\".into_cow(),\n-            CannotCastTo(s) => format!(\"can't cast this type to {}\", s).into_cow(),\n-            InvalidOpForInts(_) =>  \"can't do this op on integrals\".into_cow(),\n-            InvalidOpForBools(_) =>  \"can't do this op on bools\".into_cow(),\n-            InvalidOpForFloats(_) => \"can't do this op on floats\".into_cow(),\n-            InvalidOpForIntUint(..) => \"can't do this op on an isize and usize\".into_cow(),\n-            InvalidOpForUintInt(..) => \"can't do this op on a usize and isize\".into_cow(),\n-            NegateOn(ref const_val) => format!(\"negate on {}\", const_val.description()).into_cow(),\n-            NotOn(ref const_val) => format!(\"not on {}\", const_val.description()).into_cow(),\n-            CallOn(ref const_val) => format!(\"call on {}\", const_val.description()).into_cow(),\n-\n-            MissingStructField  => \"nonexistent struct field\".into_cow(),\n-            NonConstPath        => \"non-constant path in constant expression\".into_cow(),\n+            CannotCast => simple!(\"can't cast this type\"),\n+            CannotCastTo(s) => simple!(\"can't cast this type to {}\", s),\n+            InvalidOpForInts(_) =>  simple!(\"can't do this op on integrals\"),\n+            InvalidOpForBools(_) =>  simple!(\"can't do this op on bools\"),\n+            InvalidOpForFloats(_) => simple!(\"can't do this op on floats\"),\n+            InvalidOpForIntUint(..) => simple!(\"can't do this op on an isize and usize\"),\n+            InvalidOpForUintInt(..) => simple!(\"can't do this op on a usize and isize\"),\n+            NegateOn(ref const_val) => simple!(\"negate on {}\", const_val.description()),\n+            NotOn(ref const_val) => simple!(\"not on {}\", const_val.description()),\n+            CallOn(ref const_val) => simple!(\"call on {}\", const_val.description()),\n+\n+            MissingStructField  => simple!(\"nonexistent struct field\"),\n+            NonConstPath        => simple!(\"non-constant path in constant expression\"),\n             UnimplementedConstVal(what) =>\n-                format!(\"unimplemented constant expression: {}\", what).into_cow(),\n-            UnresolvedPath => \"unresolved path in constant expression\".into_cow(),\n-            ExpectedConstTuple => \"expected constant tuple\".into_cow(),\n-            ExpectedConstStruct => \"expected constant struct\".into_cow(),\n-            TupleIndexOutOfBounds => \"tuple index out of bounds\".into_cow(),\n-            IndexedNonVec => \"indexing is only supported for arrays\".into_cow(),\n-            IndexNegative => \"indices must be non-negative integers\".into_cow(),\n-            IndexNotInt => \"indices must be integers\".into_cow(),\n+                simple!(\"unimplemented constant expression: {}\", what),\n+            UnresolvedPath => simple!(\"unresolved path in constant expression\"),\n+            ExpectedConstTuple => simple!(\"expected constant tuple\"),\n+            ExpectedConstStruct => simple!(\"expected constant struct\"),\n+            TupleIndexOutOfBounds => simple!(\"tuple index out of bounds\"),\n+            IndexedNonVec => simple!(\"indexing is only supported for arrays\"),\n+            IndexNegative => simple!(\"indices must be non-negative integers\"),\n+            IndexNotInt => simple!(\"indices must be integers\"),\n             IndexOutOfBounds { len, index } => {\n-                format!(\"index out of bounds: the len is {} but the index is {}\",\n-                        len, index).into_cow()\n+                simple!(\"index out of bounds: the len is {} but the index is {}\",\n+                        len, index)\n             }\n-            RepeatCountNotNatural => \"repeat count must be a natural number\".into_cow(),\n-            RepeatCountNotInt => \"repeat count must be integers\".into_cow(),\n+            RepeatCountNotNatural => simple!(\"repeat count must be a natural number\"),\n+            RepeatCountNotInt => simple!(\"repeat count must be integers\"),\n \n-            MiscBinaryOp => \"bad operands for binary\".into_cow(),\n-            MiscCatchAll => \"unsupported constant expr\".into_cow(),\n-            IndexOpFeatureGated => \"the index operation on const values is unstable\".into_cow(),\n-            Math(ref err) => err.description().into_cow(),\n+            MiscBinaryOp => simple!(\"bad operands for binary\"),\n+            MiscCatchAll => simple!(\"unsupported constant expr\"),\n+            IndexOpFeatureGated => simple!(\"the index operation on const values is unstable\"),\n+            Math(ref err) => Simple(err.description().into_cow()),\n \n-            IntermediateUnsignedNegative => \"during the computation of an unsigned a negative \\\n-                                             number was encountered. This is most likely a bug in\\\n-                                             the constant evaluator\".into_cow(),\n+            IntermediateUnsignedNegative => simple!(\n+                \"during the computation of an unsigned a negative \\\n+                 number was encountered. This is most likely a bug in\\\n+                 the constant evaluator\"),\n \n             TypeMismatch(ref expected, ref got) => {\n-                format!(\"mismatched types: expected `{}`, found `{}`\",\n-                        expected, got.description()).into_cow()\n+                simple!(\"expected {}, found {}\", expected, got.description())\n             },\n-            BadType(ref i) => format!(\"value of wrong type: {:?}\", i).into_cow(),\n-            ErroneousReferencedConstant(_) => \"could not evaluate referenced constant\".into_cow(),\n+            BadType(ref i) => simple!(\"value of wrong type: {:?}\", i),\n+            ErroneousReferencedConstant(_) => simple!(\"could not evaluate referenced constant\"),\n             CharCast(ref got) => {\n-                format!(\"only `u8` can be cast as `char`, not `{}`\", got.description()).into_cow()\n+                simple!(\"only `u8` can be cast as `char`, not `{}`\", got.description())\n             },\n         }\n     }\n@@ -1105,11 +1181,25 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstVal, ty: ty::Ty)\n         Float(f) => cast_const_float(tcx, f, ty),\n         Char(c) => cast_const_int(tcx, Infer(c as u64), ty),\n         Function(_) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n-        ByteStr(_) => match ty.sty {\n+        ByteStr(b) => match ty.sty {\n             ty::TyRawPtr(_) => {\n                 Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to a raw ptr\"))\n             },\n-            ty::TyRef(..) => Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to slice\")),\n+            ty::TyRef(_, ty::TypeAndMut { ref ty, mutbl: hir::MutImmutable }) => match ty.sty {\n+                ty::TyArray(ty, n) if ty == tcx.types.u8 && n == b.len() => Ok(ByteStr(b)),\n+                ty::TySlice(_) => {\n+                    Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to slice\"))\n+                },\n+                _ => Err(CannotCast),\n+            },\n+            _ => Err(CannotCast),\n+        },\n+        Str(s) => match ty.sty {\n+            ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting a str to a raw ptr\")),\n+            ty::TyRef(_, ty::TypeAndMut { ref ty, mutbl: hir::MutImmutable }) => match ty.sty {\n+                ty::TyStr => Ok(Str(s)),\n+                _ => Err(CannotCast),\n+            },\n             _ => Err(CannotCast),\n         },\n         _ => Err(CannotCast),\n@@ -1185,71 +1275,93 @@ fn parse_float(num: &str, fty_hint: Option<ast::FloatTy>, span: Span) -> ConstFl\n     })\n }\n \n-pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n-    match (a, b) {\n+pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n+                          -> Result<Ordering, ErrorReported>\n+{\n+    let result = match (a, b) {\n         (&Integral(a), &Integral(b)) => a.try_cmp(b).ok(),\n         (&Float(a), &Float(b)) => a.try_cmp(b).ok(),\n         (&Str(ref a), &Str(ref b)) => Some(a.cmp(b)),\n         (&Bool(a), &Bool(b)) => Some(a.cmp(&b)),\n         (&ByteStr(ref a), &ByteStr(ref b)) => Some(a.cmp(b)),\n         (&Char(a), &Char(ref b)) => Some(a.cmp(b)),\n         _ => None,\n+    };\n+\n+    match result {\n+        Some(result) => Ok(result),\n+        None => {\n+            // FIXME: can this ever be reached?\n+            span_err!(tcx.sess, span, E0298,\n+                      \"type mismatch comparing {} and {}\",\n+                      a.description(),\n+                      b.description());\n+            Err(ErrorReported)\n+        }\n     }\n }\n \n pub fn compare_lit_exprs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   span: Span,\n                                    a: &Expr,\n-                                   b: &Expr) -> Option<Ordering> {\n+                                   b: &Expr) -> Result<Ordering, ErrorReported> {\n     let a = match eval_const_expr_partial(tcx, a, ExprTypeChecked, None) {\n         Ok(a) => a,\n         Err(e) => {\n-            tcx.sess.span_err(a.span, &e.description());\n-            return None;\n+            report_const_eval_err(tcx, &e, a.span, \"expression\").emit();\n+            return Err(ErrorReported);\n         }\n     };\n     let b = match eval_const_expr_partial(tcx, b, ExprTypeChecked, None) {\n         Ok(b) => b,\n         Err(e) => {\n-            tcx.sess.span_err(b.span, &e.description());\n-            return None;\n+            report_const_eval_err(tcx, &e, b.span, \"expression\").emit();\n+            return Err(ErrorReported);\n         }\n     };\n-    compare_const_vals(&a, &b)\n+    compare_const_vals(tcx, span, &a, &b)\n }\n \n \n-/// Returns the repeat count for a repeating vector expression.\n-pub fn eval_repeat_count<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   count_expr: &hir::Expr) -> usize {\n+/// Returns the value of the length-valued expression\n+pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             count_expr: &hir::Expr,\n+                             reason: &str)\n+                             -> Result<usize, ErrorReported>\n+{\n     let hint = UncheckedExprHint(tcx.types.usize);\n     match eval_const_expr_partial(tcx, count_expr, hint, None) {\n         Ok(Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);\n-            val as usize\n+            Ok(val as usize)\n         },\n         Ok(const_val) => {\n             span_err!(tcx.sess, count_expr.span, E0306,\n-                      \"expected positive integer for repeat count, found {}\",\n+                      \"expected usize for {}, found {}\",\n+                      reason,\n                       const_val.description());\n-            0\n+            Err(ErrorReported)\n         }\n         Err(err) => {\n-            let err_msg = match count_expr.node {\n+            let mut diag = report_const_eval_err(\n+                tcx, &err, count_expr.span, reason);\n+\n+            match count_expr.node {\n                 hir::ExprPath(None, hir::Path {\n                     global: false,\n                     ref segments,\n                     ..\n-                }) if segments.len() == 1 =>\n-                    format!(\"found variable\"),\n-                _ => match err.kind {\n-                    MiscCatchAll => format!(\"but found {}\", err.description()),\n-                    _ => format!(\"but {}\", err.description())\n+                }) if segments.len() == 1 => {\n+                    if let Some(Def::Local(..)) = tcx.expect_def_or_none(count_expr.id) {\n+                        diag.note(&format!(\"`{}` is a variable\", segments[0].name));\n+                    }\n                 }\n-            };\n-            span_err!(tcx.sess, count_expr.span, E0307,\n-                \"expected constant integer for repeat count, {}\", err_msg);\n-            0\n+                _ => {}\n+            }\n+\n+            diag.emit();\n+            Err(ErrorReported)\n         }\n     }\n }"}, {"sha": "a6714c178e7cf68c46e750891dd39703f285c401", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -36,6 +36,7 @@\n #[macro_use] extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_const_math;\n+extern crate rustc_errors;\n extern crate graphviz;\n extern crate syntax_pos;\n extern crate serialize as rustc_serialize; // used by deriving"}, {"sha": "e2e30ef026c2fd81f255071216e819c665633a43", "filename": "src/librustc_const_math/err.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_const_math%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_const_math%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ferr.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -57,18 +57,18 @@ impl ConstMathErr {\n             UnequalTypes(BitOr) => \"tried to bitor two values of different types\",\n             UnequalTypes(BitXor) => \"tried to xor two values of different types\",\n             UnequalTypes(_) => unreachable!(),\n-            Overflow(Add) => \"attempted to add with overflow\",\n-            Overflow(Sub) => \"attempted to subtract with overflow\",\n-            Overflow(Mul) => \"attempted to multiply with overflow\",\n-            Overflow(Div) => \"attempted to divide with overflow\",\n-            Overflow(Rem) => \"attempted to calculate the remainder with overflow\",\n-            Overflow(Neg) => \"attempted to negate with overflow\",\n-            Overflow(Shr) => \"attempted to shift right with overflow\",\n-            Overflow(Shl) => \"attempted to shift left with overflow\",\n+            Overflow(Add) => \"attempt to add with overflow\",\n+            Overflow(Sub) => \"attempt to subtract with overflow\",\n+            Overflow(Mul) => \"attempt to multiply with overflow\",\n+            Overflow(Div) => \"attempt to divide with overflow\",\n+            Overflow(Rem) => \"attempt to calculate the remainder with overflow\",\n+            Overflow(Neg) => \"attempt to negate with overflow\",\n+            Overflow(Shr) => \"attempt to shift right with overflow\",\n+            Overflow(Shl) => \"attempt to shift left with overflow\",\n             Overflow(_) => unreachable!(),\n-            ShiftNegative => \"attempted to shift by a negative amount\",\n-            DivisionByZero => \"attempted to divide by zero\",\n-            RemainderByZero => \"attempted to calculate the remainder with a divisor of zero\",\n+            ShiftNegative => \"attempt to shift by a negative amount\",\n+            DivisionByZero => \"attempt to divide by zero\",\n+            RemainderByZero => \"attempt to calculate the remainder with a divisor of zero\",\n             UnsignedNegation => \"unary negation of unsigned integer\",\n             ULitOutOfRange(ast::UintTy::U8) => \"literal out of range for u8\",\n             ULitOutOfRange(ast::UintTy::U16) => \"literal out of range for u16\","}, {"sha": "f1f5e194da4d16538418838c23725cad0f45e392", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -88,7 +88,7 @@ pub fn compile_input(sess: &Session,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (outputs, trans) = {\n+    let (outputs, trans, crate_name) = {\n         let krate = match phase_1_parse_input(sess, cfg, input) {\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n@@ -113,21 +113,21 @@ pub fn compile_input(sess: &Session,\n         };\n \n         let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n-        let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n+        let crate_name = link::find_crate_name(Some(sess), &krate.attrs, input);\n         let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {\n             phase_2_configure_and_expand(\n-                sess, &cstore, krate, &id, addl_plugins, control.make_glob_map,\n+                sess, &cstore, krate, &crate_name, addl_plugins, control.make_glob_map,\n                 |expanded_crate| {\n                     let mut state = CompileState::state_after_expand(\n-                        input, sess, outdir, output, &cstore, expanded_crate, &id,\n+                        input, sess, outdir, output, &cstore, expanded_crate, &crate_name,\n                     );\n                     controller_entry_point!(after_expand, sess, state, Ok(()));\n                     Ok(())\n                 }\n             )?\n         };\n \n-        write_out_deps(sess, &outputs, &id);\n+        write_out_deps(sess, &outputs, &crate_name);\n \n         let arenas = ty::CtxtArenas::new();\n \n@@ -151,7 +151,7 @@ pub fn compile_input(sess: &Session,\n                                                                   &resolutions,\n                                                                   &expanded_crate,\n                                                                   &hir_map.krate(),\n-                                                                  &id),\n+                                                                  &crate_name),\n                                     Ok(()));\n         }\n \n@@ -171,7 +171,7 @@ pub fn compile_input(sess: &Session,\n                                     analysis,\n                                     resolutions,\n                                     &arenas,\n-                                    &id,\n+                                    &crate_name,\n                                     |tcx, mir_map, analysis, result| {\n             {\n                 // Eventually, we will want to track plugins.\n@@ -186,7 +186,7 @@ pub fn compile_input(sess: &Session,\n                                                                    &analysis,\n                                                                    mir_map.as_ref(),\n                                                                    tcx,\n-                                                                   &id);\n+                                                                   &crate_name);\n                 (control.after_analysis.callback)(&mut state);\n \n                 if control.after_analysis.stop == Compilation::Stop {\n@@ -212,11 +212,11 @@ pub fn compile_input(sess: &Session,\n             // Discard interned strings as they are no longer required.\n             token::clear_ident_interner();\n \n-            Ok((outputs, trans))\n+            Ok((outputs, trans, crate_name.clone()))\n         })??\n     };\n \n-    let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n+    let phase5_result = phase_5_run_llvm_passes(sess, &crate_name, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,\n                             sess,\n@@ -478,10 +478,6 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session,\n                                cfg: ast::CrateConfig,\n                                input: &Input)\n                                -> PResult<'a, ast::Crate> {\n-    // These may be left in an incoherent state after a previous compile.\n-    syntax::ext::hygiene::reset_hygiene_data();\n-    // `clear_ident_interner` can be used to free memory, but it does not restore the initial state.\n-    token::reset_ident_interner();\n     let continue_after_error = sess.opts.continue_parse_after_error;\n     sess.diagnostic().set_continue_after_error(continue_after_error);\n \n@@ -570,7 +566,8 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     });\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n-    sess.crate_disambiguator.set(token::intern(&compute_crate_disambiguator(sess)));\n+    *sess.crate_disambiguator.borrow_mut() =\n+        token::intern(&compute_crate_disambiguator(sess)).as_str();\n \n     time(time_passes, \"recursion limit\", || {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -998,6 +995,8 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n         passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"elaborate-drops\"));\n \n+        passes.push_pass(box mir::transform::deaggregator::Deaggregator);\n+\n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n         passes.push_pass(box mir::transform::dump_mir::Marker(\"PreTrans\"));\n \n@@ -1023,6 +1022,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n pub fn phase_5_run_llvm_passes(sess: &Session,\n+                               crate_name: &str,\n                                trans: &trans::CrateTranslation,\n                                outputs: &OutputFilenames) -> CompileResult {\n     if sess.opts.cg.no_integrated_as {\n@@ -1044,6 +1044,10 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n              || write::run_passes(sess, trans, &sess.opts.output_types, outputs));\n     }\n \n+    time(sess.time_passes(),\n+         \"serialize work products\",\n+         move || rustc_incremental::save_work_products(sess, crate_name));\n+\n     if sess.err_count() > 0 {\n         Err(sess.err_count())\n     } else {\n@@ -1067,14 +1071,14 @@ fn escape_dep_filename(filename: &str) -> String {\n     filename.replace(\" \", \"\\\\ \")\n }\n \n-fn write_out_deps(sess: &Session, outputs: &OutputFilenames, id: &str) {\n+fn write_out_deps(sess: &Session, outputs: &OutputFilenames, crate_name: &str) {\n     let mut out_filenames = Vec::new();\n     for output_type in sess.opts.output_types.keys() {\n         let file = outputs.path(*output_type);\n         match *output_type {\n             OutputType::Exe => {\n                 for output in sess.crate_types.borrow().iter() {\n-                    let p = link::filename_for_input(sess, *output, id, outputs);\n+                    let p = link::filename_for_input(sess, *output, crate_name, outputs);\n                     out_filenames.push(p);\n                 }\n             }\n@@ -1298,3 +1302,11 @@ pub fn build_output_filenames(input: &Input,\n         }\n     }\n }\n+\n+// For use by the `rusti` project (https://github.com/murarth/rusti).\n+pub fn reset_thread_local_state() {\n+    // These may be left in an incoherent state after a previous compile.\n+    syntax::ext::hygiene::reset_hygiene_data();\n+    // `clear_ident_interner` can be used to free memory, but it does not restore the initial state.\n+    token::reset_ident_interner();\n+}"}, {"sha": "d92ecfaec32865c7ab1b739ebf73a06631fb437a", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -31,7 +31,6 @@\n #![feature(set_stdio)]\n #![feature(staged_api)]\n #![feature(question_mark)]\n-#![feature(unboxed_closures)]\n \n extern crate arena;\n extern crate flate;\n@@ -96,6 +95,7 @@ use std::thread;\n use rustc::session::early_error;\n \n use syntax::{ast, json};\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n@@ -187,7 +187,7 @@ pub fn run_compiler_with_file_loader<'a, L>(args: &[String],\n     let sopts = config::build_session_options(&matches);\n \n     if sopts.debugging_opts.debug_llvm {\n-        unsafe { llvm::LLVMSetDebug(1); }\n+        unsafe { llvm::LLVMRustSetDebug(1); }\n     }\n \n     let descriptions = diagnostics_registry();\n@@ -393,15 +393,12 @@ fn check_cfg(sopts: &config::Options,\n \n     let mut saw_invalid_predicate = false;\n     for item in sopts.cfg.iter() {\n-        match item.node {\n-            ast::MetaItemKind::List(ref pred, _) => {\n-                saw_invalid_predicate = true;\n-                handler.emit(&MultiSpan::new(),\n-                             &format!(\"invalid predicate in --cfg command line argument: `{}`\",\n-                                      pred),\n-                                errors::Level::Fatal);\n-            }\n-            _ => {},\n+        if item.is_meta_item_list() {\n+            saw_invalid_predicate = true;\n+            handler.emit(&MultiSpan::new(),\n+                         &format!(\"invalid predicate in --cfg command line argument: `{}`\",\n+                                  item.name()),\n+                            errors::Level::Fatal);\n         }\n     }\n \n@@ -610,7 +607,7 @@ impl RustcDefaultCalls {\n         for req in &sess.opts.prints {\n             match *req {\n                 PrintRequest::TargetList => {\n-                    let mut targets = rustc_back::target::TARGETS.to_vec();\n+                    let mut targets = rustc_back::target::get_targets().collect::<Vec<String>>();\n                     targets.sort();\n                     println!(\"{}\", targets.join(\"\\n\"));\n                 },\n@@ -650,20 +647,17 @@ impl RustcDefaultCalls {\n                         if !allow_unstable_cfg && GatedCfg::gate(&*cfg).is_some() {\n                             continue;\n                         }\n-                        match cfg.node {\n-                            ast::MetaItemKind::Word(ref word) => println!(\"{}\", word),\n-                            ast::MetaItemKind::NameValue(ref name, ref value) => {\n-                                println!(\"{}=\\\"{}\\\"\", name, match value.node {\n-                                    ast::LitKind::Str(ref s, _) => s,\n-                                    _ => continue,\n-                                });\n+                        if cfg.is_word() {\n+                            println!(\"{}\", cfg.name());\n+                        } else if cfg.is_value_str() {\n+                            if let Some(s) = cfg.value_str() {\n+                                println!(\"{}=\\\"{}\\\"\", cfg.name(), s);\n                             }\n+                        } else if cfg.is_meta_item_list() {\n                             // Right now there are not and should not be any\n                             // MetaItemKind::List items in the configuration returned by\n                             // `build_configuration`.\n-                            ast::MetaItemKind::List(..) => {\n-                                panic!(\"MetaItemKind::List encountered in default cfg\")\n-                            }\n+                            panic!(\"MetaItemKind::List encountered in default cfg\")\n                         }\n                     }\n                 }"}, {"sha": "610e5647d6d12893547923c65d361474d0914c00", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -531,10 +531,12 @@ impl Handler {\n         DiagnosticBuilder::new(self, Level::Fatal, msg)\n     }\n \n-    pub fn cancel(&mut self, err: &mut DiagnosticBuilder) {\n+    pub fn cancel(&self, err: &mut DiagnosticBuilder) {\n         if err.level == Level::Error || err.level == Level::Fatal {\n-            assert!(self.has_errors());\n-            self.err_count.set(self.err_count.get() + 1);\n+            self.err_count.set(\n+                self.err_count.get().checked_sub(1)\n+                    .expect(\"cancelled an error but err_count is 0\")\n+            );\n         }\n         err.cancel();\n     }"}, {"sha": "774c5ca6d6b239a75b8a72ad583f23248e698280", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -110,13 +110,11 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n             if attr.check_name(IF_THIS_CHANGED) {\n                 let mut id = None;\n                 for meta_item in attr.meta_item_list().unwrap_or_default() {\n-                    match meta_item.node {\n-                        ast::MetaItemKind::Word(ref s) if id.is_none() => id = Some(s.clone()),\n-                        _ => {\n-                            self.tcx.sess.span_err(\n-                                meta_item.span,\n-                                &format!(\"unexpected meta-item {:?}\", meta_item.node));\n-                        }\n+                    if meta_item.is_word() && id.is_none() {\n+                        id = Some(meta_item.name().clone());\n+                    } else {\n+                        // FIXME better-encapsulate meta_item (don't directly access `node`)\n+                        span_bug!(meta_item.span(), \"unexpected meta-item {:?}\", meta_item.node)\n                     }\n                 }\n                 let id = id.unwrap_or(InternedString::new(ID));\n@@ -127,16 +125,13 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                 let mut dep_node_interned = None;\n                 let mut id = None;\n                 for meta_item in attr.meta_item_list().unwrap_or_default() {\n-                    match meta_item.node {\n-                        ast::MetaItemKind::Word(ref s) if dep_node_interned.is_none() =>\n-                            dep_node_interned = Some(s.clone()),\n-                        ast::MetaItemKind::Word(ref s) if id.is_none() =>\n-                            id = Some(s.clone()),\n-                        _ => {\n-                            self.tcx.sess.span_err(\n-                                meta_item.span,\n-                                &format!(\"unexpected meta-item {:?}\", meta_item.node));\n-                        }\n+                    if meta_item.is_word() && dep_node_interned.is_none() {\n+                        dep_node_interned = Some(meta_item.name().clone());\n+                    } else if meta_item.is_word() && id.is_none() {\n+                        id = Some(meta_item.name().clone());\n+                    } else {\n+                        // FIXME better-encapsulate meta_item (don't directly access `node`)\n+                        span_bug!(meta_item.span(), \"unexpected meta-item {:?}\", meta_item.node)\n                     }\n                 }\n                 let dep_node = match dep_node_interned {"}, {"sha": "bea6b7e28344e01e08d60337d81c102d80228ef1", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -11,6 +11,7 @@\n //! Calculation of a Strict Version Hash for crates.  For a length\n //! comment explaining the general idea, see `librustc/middle/svh.rs`.\n \n+use syntax::attr::AttributeMethods;\n use std::hash::{Hash, SipHasher, Hasher};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::svh::Svh;\n@@ -36,7 +37,7 @@ impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n         // to ensure it is not incorporating implementation artifacts into\n         // the hash that are not otherwise visible.)\n \n-        let crate_disambiguator = self.sess.crate_disambiguator.get();\n+        let crate_disambiguator = self.sess.local_crate_disambiguator();\n         let krate = self.map.krate();\n \n         // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n@@ -47,10 +48,10 @@ impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n         // FIXME(#32753) -- at (*) we `to_le` for endianness, but is\n         // this enough, and does it matter anyway?\n         \"crate_disambiguator\".hash(&mut state);\n-        crate_disambiguator.as_str().len().to_le().hash(&mut state); // (*)\n-        crate_disambiguator.as_str().hash(&mut state);\n+        crate_disambiguator.len().to_le().hash(&mut state); // (*)\n+        crate_disambiguator.hash(&mut state);\n \n-        debug!(\"crate_disambiguator: {:?}\", crate_disambiguator.as_str());\n+        debug!(\"crate_disambiguator: {:?}\", crate_disambiguator);\n         debug!(\"state: {:?}\", state);\n \n         {\n@@ -69,7 +70,7 @@ impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n         // to avoid hashing the AttrId\n         for attr in &krate.attrs {\n             debug!(\"krate attr {:?}\", attr);\n-            attr.node.value.hash(&mut state);\n+            attr.meta().hash(&mut state);\n         }\n \n         Svh::new(state.finish())\n@@ -119,6 +120,7 @@ mod svh_visitor {\n     use rustc::ty::TyCtxt;\n     use rustc::hir;\n     use rustc::hir::*;\n+    use rustc::hir::map::DefPath;\n     use rustc::hir::intravisit as visit;\n     use rustc::hir::intravisit::{Visitor, FnKind};\n \n@@ -135,6 +137,15 @@ mod svh_visitor {\n                    -> Self {\n             StrictVersionHashVisitor { st: st, tcx: tcx }\n         }\n+\n+        fn hash_def_path(&mut self, path: &DefPath) {\n+            self.tcx.crate_name(path.krate).hash(self.st);\n+            self.tcx.crate_disambiguator(path.krate).hash(self.st);\n+            for data in &path.data {\n+                data.data.as_interned_str().hash(self.st);\n+                data.disambiguator.hash(self.st);\n+            }\n+        }\n     }\n \n     // To off-load the bulk of the hash-computation on #[derive(Hash)],\n@@ -289,19 +300,21 @@ mod svh_visitor {\n \n     impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n         fn visit_nested_item(&mut self, item: ItemId) {\n-            debug!(\"visit_nested_item: {:?} st={:?}\", item, self.st);\n-            let def_path = self.tcx.map.def_path_from_id(item.id);\n-            def_path.hash(self.st);\n+            let def_path = self.tcx.map.def_path_from_id(item.id).unwrap();\n+            debug!(\"visit_nested_item: def_path={:?} st={:?}\", def_path, self.st);\n+            self.hash_def_path(&def_path);\n         }\n \n         fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n                               g: &'a Generics, _: NodeId, _: Span) {\n+            debug!(\"visit_variant_data: st={:?}\", self.st);\n             SawStructDef(name.as_str()).hash(self.st);\n             visit::walk_generics(self, g);\n             visit::walk_struct_def(self, s)\n         }\n \n         fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+            debug!(\"visit_variant: st={:?}\", self.st);\n             SawVariant.hash(self.st);\n             // walk_variant does not call walk_generics, so do it here.\n             visit::walk_generics(self, g);\n@@ -323,14 +336,17 @@ mod svh_visitor {\n         // pattern, please move that method up above this comment.)\n \n         fn visit_name(&mut self, _: Span, name: Name) {\n+            debug!(\"visit_name: st={:?}\", self.st);\n             SawIdent(name.as_str()).hash(self.st);\n         }\n \n         fn visit_lifetime(&mut self, l: &'a Lifetime) {\n+            debug!(\"visit_lifetime: st={:?}\", self.st);\n             SawLifetime(l.name.as_str()).hash(self.st);\n         }\n \n         fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n+            debug!(\"visit_lifetime_def: st={:?}\", self.st);\n             SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n         }\n \n@@ -340,14 +356,18 @@ mod svh_visitor {\n         // that a change to a crate body will require downstream\n         // crates to be recompiled.\n         fn visit_expr(&mut self, ex: &'a Expr) {\n+            debug!(\"visit_expr: st={:?}\", self.st);\n             SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n         }\n \n         fn visit_stmt(&mut self, s: &'a Stmt) {\n+            debug!(\"visit_stmt: st={:?}\", self.st);\n             SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n         }\n \n         fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n+            debug!(\"visit_foreign_item: st={:?}\", self.st);\n+\n             // FIXME (#14132) ideally we would incorporate privacy (or\n             // perhaps reachability) somewhere here, so foreign items\n             // that do not leak into downstream crates would not be\n@@ -357,63 +377,77 @@ mod svh_visitor {\n \n         fn visit_item(&mut self, i: &'a Item) {\n             debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n+\n             // FIXME (#14132) ideally would incorporate reachability\n             // analysis somewhere here, so items that never leak into\n             // downstream crates (e.g. via monomorphisation or\n             // inlining) would not be part of the ABI.\n             SawItem.hash(self.st); visit::walk_item(self, i)\n         }\n \n-        fn visit_mod(&mut self, m: &'a Mod, _s: Span, _n: NodeId) {\n-            SawMod.hash(self.st); visit::walk_mod(self, m)\n+        fn visit_mod(&mut self, m: &'a Mod, _s: Span, n: NodeId) {\n+            debug!(\"visit_mod: st={:?}\", self.st);\n+            SawMod.hash(self.st); visit::walk_mod(self, m, n)\n         }\n \n         fn visit_decl(&mut self, d: &'a Decl) {\n+            debug!(\"visit_decl: st={:?}\", self.st);\n             SawDecl.hash(self.st); visit::walk_decl(self, d)\n         }\n \n         fn visit_ty(&mut self, t: &'a Ty) {\n+            debug!(\"visit_ty: st={:?}\", self.st);\n             SawTy.hash(self.st); visit::walk_ty(self, t)\n         }\n \n         fn visit_generics(&mut self, g: &'a Generics) {\n+            debug!(\"visit_generics: st={:?}\", self.st);\n             SawGenerics.hash(self.st); visit::walk_generics(self, g)\n         }\n \n         fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n-                    b: &'a Block, s: Span, _: NodeId) {\n-            SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s)\n+                    b: &'a Block, s: Span, n: NodeId) {\n+            debug!(\"visit_fn: st={:?}\", self.st);\n+            SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s, n)\n         }\n \n         fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n+            debug!(\"visit_trait_item: st={:?}\", self.st);\n             SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n         }\n \n         fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n+            debug!(\"visit_impl_item: st={:?}\", self.st);\n             SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n         }\n \n         fn visit_struct_field(&mut self, s: &'a StructField) {\n+            debug!(\"visit_struct_field: st={:?}\", self.st);\n             SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n         }\n \n         fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n+            debug!(\"visit_path: st={:?}\", self.st);\n             SawPath.hash(self.st); visit::walk_path(self, path)\n         }\n \n         fn visit_block(&mut self, b: &'a Block) {\n+            debug!(\"visit_block: st={:?}\", self.st);\n             SawBlock.hash(self.st); visit::walk_block(self, b)\n         }\n \n         fn visit_pat(&mut self, p: &'a Pat) {\n+            debug!(\"visit_pat: st={:?}\", self.st);\n             SawPat.hash(self.st); visit::walk_pat(self, p)\n         }\n \n         fn visit_local(&mut self, l: &'a Local) {\n+            debug!(\"visit_local: st={:?}\", self.st);\n             SawLocal.hash(self.st); visit::walk_local(self, l)\n         }\n \n         fn visit_arm(&mut self, a: &'a Arm) {\n+            debug!(\"visit_arm: st={:?}\", self.st);\n             SawArm.hash(self.st); visit::walk_arm(self, a)\n         }\n     }"}, {"sha": "0d11b0794feacea61a4292f1be2c7bc7286b0d58", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -19,6 +19,7 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+#![feature(question_mark)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n \n@@ -40,3 +41,6 @@ pub use assert_dep_graph::assert_dep_graph;\n pub use calculate_svh::SvhCalculate;\n pub use persist::load_dep_graph;\n pub use persist::save_dep_graph;\n+pub use persist::save_trans_partition;\n+pub use persist::save_work_products;\n+pub use persist::in_incr_comp_dir;"}, {"sha": "95e9a16f29bbe927db40164283e00576231eb789", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -10,8 +10,9 @@\n \n //! The data that we will serialize and deserialize.\n \n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use rustc::hir::def_id::DefIndex;\n+use std::sync::Arc;\n \n use super::directory::DefPathIndex;\n \n@@ -55,6 +56,15 @@ pub struct SerializedHash {\n     pub hash: u64,\n }\n \n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedWorkProduct {\n+    /// node that produced the work-product\n+    pub id: Arc<WorkProductId>,\n+\n+    /// work-product data itself\n+    pub work_product: WorkProduct,\n+}\n+\n /// Data for use when downstream crates get recompiled.\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedMetadataHashes {"}, {"sha": "36b6c79c40f5dc9379fac023bb43b567d0334198", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 107, "deletions": 26, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -14,12 +14,13 @@ use rbml::Error;\n use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n+use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashSet;\n use rustc_serialize::Decodable as RustcDecodable;\n use std::io::Read;\n-use std::fs::File;\n-use std::path::Path;\n+use std::fs::{self, File};\n+use std::path::{Path};\n \n use super::data::*;\n use super::directory::*;\n@@ -38,50 +39,74 @@ type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    if tcx.sess.opts.incremental.is_none() {\n+        return;\n+    }\n+\n     let _ignore = tcx.dep_graph.in_ignore();\n+    load_dep_graph_if_exists(tcx);\n+    dirty_clean::check_dirty_clean_annotations(tcx);\n+}\n \n-    if let Some(dep_graph) = dep_graph_path(tcx) {\n-        // FIXME(#32754) lock file?\n-        load_dep_graph_if_exists(tcx, &dep_graph);\n-        dirty_clean::check_dirty_clean_annotations(tcx);\n+fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let dep_graph_path = dep_graph_path(tcx).unwrap();\n+    let dep_graph_data = match load_data(tcx.sess, &dep_graph_path) {\n+        Some(p) => p,\n+        None => return // no file\n+    };\n+\n+    let work_products_path = tcx_work_products_path(tcx).unwrap();\n+    let work_products_data = match load_data(tcx.sess, &work_products_path) {\n+        Some(p) => p,\n+        None => return // no file\n+    };\n+\n+    match decode_dep_graph(tcx, &dep_graph_data, &work_products_data) {\n+        Ok(()) => return,\n+        Err(err) => {\n+            tcx.sess.warn(\n+                &format!(\"decoding error in dep-graph from `{}` and `{}`: {}\",\n+                         dep_graph_path.display(),\n+                         work_products_path.display(),\n+                         err));\n+        }\n     }\n }\n \n-pub fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, path: &Path) {\n+fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n     if !path.exists() {\n-        return;\n+        return None;\n     }\n \n     let mut data = vec![];\n     match\n         File::open(path)\n         .and_then(|mut file| file.read_to_end(&mut data))\n     {\n-        Ok(_) => { }\n+        Ok(_) => {\n+            Some(data)\n+        }\n         Err(err) => {\n-            tcx.sess.err(\n+            sess.err(\n                 &format!(\"could not load dep-graph from `{}`: {}\",\n                          path.display(), err));\n-            return;\n+            None\n         }\n     }\n \n-    match decode_dep_graph(tcx, &data) {\n-        Ok(dirty) => dirty,\n-        Err(err) => {\n-            bug!(\"decoding error in dep-graph from `{}`: {}\", path.display(), err);\n-        }\n-    }\n }\n \n+/// Decode the dep graph and load the edges/nodes that are still clean\n+/// into `tcx.dep_graph`.\n pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  data: &[u8])\n+                                  dep_graph_data: &[u8],\n+                                  work_products_data: &[u8])\n                                   -> Result<(), Error>\n {\n     // Deserialize the directory and dep-graph.\n-    let mut decoder = Decoder::new(data, 0);\n-    let directory = try!(DefIdDirectory::decode(&mut decoder));\n-    let serialized_dep_graph = try!(SerializedDepGraph::decode(&mut decoder));\n+    let mut dep_graph_decoder = Decoder::new(dep_graph_data, 0);\n+    let directory = try!(DefIdDirectory::decode(&mut dep_graph_decoder));\n+    let serialized_dep_graph = try!(SerializedDepGraph::decode(&mut dep_graph_decoder));\n \n     debug!(\"decode_dep_graph: directory = {:#?}\", directory);\n     debug!(\"decode_dep_graph: serialized_dep_graph = {:#?}\", serialized_dep_graph);\n@@ -121,12 +146,18 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Add nodes and edges that are not dirty into our main graph.\n     let dep_graph = tcx.dep_graph.clone();\n     for (source, target) in clean_edges.into_iter().chain(clean_nodes) {\n-        let _task = dep_graph.in_task(target.clone());\n-        dep_graph.read(source.clone());\n-\n         debug!(\"decode_dep_graph: clean edge: {:?} -> {:?}\", source, target);\n+\n+        let _task = dep_graph.in_task(target);\n+        dep_graph.read(source);\n     }\n \n+    // Add in work-products that are still clean, and delete those that are\n+    // dirty.\n+    let mut work_product_decoder = Decoder::new(work_products_data, 0);\n+    let work_products = try!(<Vec<SerializedWorkProduct>>::decode(&mut work_product_decoder));\n+    reconcile_work_products(tcx, work_products, &dirty_nodes);\n+\n     Ok(())\n }\n \n@@ -141,9 +172,9 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         match hash.node.map_def(|&i| retraced.def_id(i)) {\n             Some(dep_node) => {\n                 let current_hash = hcx.hash(&dep_node).unwrap();\n-                debug!(\"initial_dirty_nodes: hash of {:?} is {:?}, was {:?}\",\n-                       dep_node, current_hash, hash.hash);\n                 if current_hash != hash.hash {\n+                    debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n+                           dep_node, current_hash, hash.hash);\n                     dirty_nodes.insert(dep_node);\n                 }\n             }\n@@ -177,6 +208,8 @@ fn compute_clean_edges(serialized_edges: &[(SerializedEdge)],\n                 clean_edges.push((source, target))\n             } else {\n                 // source removed, target must be dirty\n+                debug!(\"compute_clean_edges: {:?} dirty because {:?} no longer exists\",\n+                       target, serialized_source);\n                 dirty_nodes.insert(target);\n             }\n         } else {\n@@ -213,3 +246,51 @@ fn compute_clean_edges(serialized_edges: &[(SerializedEdge)],\n \n     clean_edges\n }\n+\n+/// Go through the list of work-products produced in the previous run.\n+/// Delete any whose nodes have been found to be dirty or which are\n+/// otherwise no longer applicable.\n+fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     work_products: Vec<SerializedWorkProduct>,\n+                                     dirty_nodes: &DirtyNodes) {\n+    debug!(\"reconcile_work_products({:?})\", work_products);\n+    for swp in work_products {\n+        let dep_node = DepNode::WorkProduct(swp.id.clone());\n+        if dirty_nodes.contains(&dep_node) {\n+            debug!(\"reconcile_work_products: dep-node for {:?} is dirty\", swp);\n+            delete_dirty_work_product(tcx, swp);\n+        } else {\n+            let all_files_exist =\n+                swp.work_product\n+                   .saved_files\n+                   .iter()\n+                   .all(|&(_, ref file_name)| {\n+                       let path = in_incr_comp_dir(tcx.sess, &file_name).unwrap();\n+                       path.exists()\n+                   });\n+            if all_files_exist {\n+                debug!(\"reconcile_work_products: all files for {:?} exist\", swp);\n+                tcx.dep_graph.insert_previous_work_product(&swp.id, swp.work_product);\n+            } else {\n+                debug!(\"reconcile_work_products: some file for {:?} does not exist\", swp);\n+                delete_dirty_work_product(tcx, swp);\n+            }\n+        }\n+    }\n+}\n+\n+fn delete_dirty_work_product(tcx: TyCtxt,\n+                             swp: SerializedWorkProduct) {\n+    debug!(\"delete_dirty_work_product({:?})\", swp);\n+    for &(_, ref file_name) in &swp.work_product.saved_files {\n+        let path = in_incr_comp_dir(tcx.sess, file_name).unwrap();\n+        match fs::remove_file(&path) {\n+            Ok(()) => { }\n+            Err(err) => {\n+                tcx.sess.warn(\n+                    &format!(\"file-system error deleting outdated file `{}`: {}\",\n+                             path.display(), err));\n+            }\n+        }\n+    }\n+}"}, {"sha": "1157f494ce604e32c2d9fdd5512416f1c8c967fe", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -19,6 +19,10 @@ mod hash;\n mod load;\n mod save;\n mod util;\n+mod work_product;\n \n pub use self::load::load_dep_graph;\n pub use self::save::save_dep_graph;\n+pub use self::save::save_work_products;\n+pub use self::work_product::save_trans_partition;\n+pub use self::util::in_incr_comp_dir;"}, {"sha": "305250d59623c50d644da6ad3cb3e7de2f538e19", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -11,6 +11,7 @@\n use rbml::opaque::Encoder;\n use rustc::dep_graph::DepNode;\n use rustc::middle::cstore::LOCAL_CRATE;\n+use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_serialize::{Encodable as RustcEncodable};\n use std::hash::{Hasher, SipHasher};\n@@ -24,19 +25,26 @@ use super::hash::*;\n use super::util::*;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    debug!(\"save_dep_graph()\");\n     let _ignore = tcx.dep_graph.in_ignore();\n+    let sess = tcx.sess;\n     let mut hcx = HashContext::new(tcx);\n-    save_in(&mut hcx, dep_graph_path(tcx), encode_dep_graph);\n-    save_in(&mut hcx, metadata_hash_path(tcx, LOCAL_CRATE), encode_metadata_hashes);\n+    save_in(sess, dep_graph_path(tcx), |e| encode_dep_graph(&mut hcx, e));\n+    save_in(sess, metadata_hash_path(tcx, LOCAL_CRATE), |e| encode_metadata_hashes(&mut hcx, e));\n }\n \n-fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n-                        opt_path_buf: Option<PathBuf>,\n-                        encode: F)\n-    where F: FnOnce(&mut HashContext<'a, 'tcx>, &mut Encoder) -> io::Result<()>\n-{\n-    let tcx = hcx.tcx;\n+pub fn save_work_products(sess: &Session, local_crate_name: &str) {\n+    debug!(\"save_work_products()\");\n+    let _ignore = sess.dep_graph.in_ignore();\n+    let path = sess_work_products_path(sess, local_crate_name);\n+    save_in(sess, path, |e| encode_work_products(sess, e));\n+}\n \n+fn save_in<F>(sess: &Session,\n+              opt_path_buf: Option<PathBuf>,\n+              encode: F)\n+    where F: FnOnce(&mut Encoder) -> io::Result<()>\n+{\n     let path_buf = match opt_path_buf {\n         Some(p) => p,\n         None => return\n@@ -49,7 +57,7 @@ fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n         match fs::remove_file(&path_buf) {\n             Ok(()) => { }\n             Err(err) => {\n-                tcx.sess.err(\n+                sess.err(\n                     &format!(\"unable to delete old dep-graph at `{}`: {}\",\n                              path_buf.display(), err));\n                 return;\n@@ -59,10 +67,10 @@ fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n \n     // generate the data in a memory buffer\n     let mut wr = Cursor::new(Vec::new());\n-    match encode(hcx, &mut Encoder::new(&mut wr)) {\n+    match encode(&mut Encoder::new(&mut wr)) {\n         Ok(()) => { }\n         Err(err) => {\n-            tcx.sess.err(\n+            sess.err(\n                 &format!(\"could not encode dep-graph to `{}`: {}\",\n                          path_buf.display(), err));\n             return;\n@@ -77,7 +85,7 @@ fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n     {\n         Ok(_) => { }\n         Err(err) => {\n-            tcx.sess.err(\n+            sess.err(\n                 &format!(\"failed to write dep-graph to `{}`: {}\",\n                          path_buf.display(), err));\n             return;\n@@ -192,3 +200,22 @@ pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n \n     Ok(())\n }\n+\n+pub fn encode_work_products(sess: &Session,\n+                            encoder: &mut Encoder)\n+                            -> io::Result<()>\n+{\n+    let work_products: Vec<_> =\n+        sess.dep_graph.work_products()\n+                     .iter()\n+                     .map(|(id, work_product)| {\n+                         SerializedWorkProduct {\n+                             id: id.clone(),\n+                             work_product: work_product.clone(),\n+                         }\n+                     })\n+                     .collect();\n+\n+    work_products.encode(encoder)\n+}\n+"}, {"sha": "f1e81fdb266b9b201271281c02851e8248b16083", "filename": "src/librustc_incremental/persist/util.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Futil.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use rustc::middle::cstore::LOCAL_CRATE;\n+use rustc::session::Session;\n use rustc::ty::TyCtxt;\n \n use std::fs;\n@@ -17,33 +18,56 @@ use std::path::{Path, PathBuf};\n use syntax::ast;\n \n pub fn dep_graph_path(tcx: TyCtxt) -> Option<PathBuf> {\n-    path(tcx, LOCAL_CRATE, \"local\")\n+    tcx_path(tcx, LOCAL_CRATE, \"local\")\n }\n \n pub fn metadata_hash_path(tcx: TyCtxt, cnum: ast::CrateNum) -> Option<PathBuf> {\n-    path(tcx, cnum, \"metadata\")\n+    tcx_path(tcx, cnum, \"metadata\")\n }\n \n-fn path(tcx: TyCtxt, cnum: ast::CrateNum, suffix: &str) -> Option<PathBuf> {\n+pub fn tcx_work_products_path(tcx: TyCtxt) -> Option<PathBuf> {\n+    let crate_name = tcx.crate_name(LOCAL_CRATE);\n+    sess_work_products_path(tcx.sess, &crate_name)\n+}\n+\n+pub fn sess_work_products_path(sess: &Session,\n+                               local_crate_name: &str)\n+                               -> Option<PathBuf> {\n+    let crate_disambiguator = sess.local_crate_disambiguator();\n+    path(sess, local_crate_name, &crate_disambiguator, \"work-products\")\n+}\n+\n+pub fn in_incr_comp_dir(sess: &Session, file_name: &str) -> Option<PathBuf> {\n+    sess.opts.incremental.as_ref().map(|incr_dir| incr_dir.join(file_name))\n+}\n+\n+fn tcx_path(tcx: TyCtxt,\n+            cnum: ast::CrateNum,\n+            middle: &str)\n+            -> Option<PathBuf> {\n+    path(tcx.sess, &tcx.crate_name(cnum), &tcx.crate_disambiguator(cnum), middle)\n+}\n+\n+fn path(sess: &Session,\n+        crate_name: &str,\n+        crate_disambiguator: &str,\n+        middle: &str)\n+        -> Option<PathBuf> {\n     // For now, just save/load dep-graph from\n     // directory/dep_graph.rbml\n-    tcx.sess.opts.incremental.as_ref().and_then(|incr_dir| {\n+    sess.opts.incremental.as_ref().and_then(|incr_dir| {\n         match create_dir_racy(&incr_dir) {\n             Ok(()) => {}\n             Err(err) => {\n-                tcx.sess.err(\n+                sess.err(\n                     &format!(\"could not create the directory `{}`: {}\",\n                              incr_dir.display(), err));\n                 return None;\n             }\n         }\n \n-        let crate_name = tcx.crate_name(cnum);\n-        let crate_disambiguator = tcx.crate_disambiguator(cnum);\n-        let file_name = format!(\"{}-{}.{}.bin\",\n-                                crate_name,\n-                                crate_disambiguator,\n-                                suffix);\n+        let file_name = format!(\"{}-{}.{}.bin\", crate_name, crate_disambiguator, middle);\n+\n         Some(incr_dir.join(file_name))\n     })\n }"}, {"sha": "c106ea8f262691ec83cfe693efaaadc6663734c2", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains files for saving intermediate work-products.\n+\n+use persist::util::*;\n+use rustc::dep_graph::{WorkProduct, WorkProductId};\n+use rustc::session::Session;\n+use rustc::session::config::OutputType;\n+use rustc::util::fs::link_or_copy;\n+use std::path::PathBuf;\n+use std::sync::Arc;\n+\n+pub fn save_trans_partition(sess: &Session,\n+                            cgu_name: &str,\n+                            partition_hash: u64,\n+                            files: &[(OutputType, PathBuf)]) {\n+    debug!(\"save_trans_partition({:?},{},{:?})\",\n+           cgu_name,\n+           partition_hash,\n+           files);\n+    if sess.opts.incremental.is_none() {\n+        return;\n+    }\n+    let work_product_id = Arc::new(WorkProductId(cgu_name.to_string()));\n+\n+    let saved_files: Option<Vec<_>> =\n+        files.iter()\n+             .map(|&(kind, ref path)| {\n+                 let file_name = format!(\"cgu-{}.{}\", cgu_name, kind.extension());\n+                 let path_in_incr_dir = in_incr_comp_dir(sess, &file_name).unwrap();\n+                 match link_or_copy(path, &path_in_incr_dir) {\n+                     Ok(_) => Some((kind, file_name)),\n+                     Err(err) => {\n+                         sess.warn(&format!(\"error copying object file `{}` \\\n+                                             to incremental directory as `{}`: {}\",\n+                                            path.display(),\n+                                            path_in_incr_dir.display(),\n+                                            err));\n+                         None\n+                     }\n+                 }\n+             })\n+             .collect();\n+    let saved_files = match saved_files {\n+        Some(v) => v,\n+        None => return,\n+    };\n+\n+    let work_product = WorkProduct {\n+        input_hash: partition_hash,\n+        saved_files: saved_files,\n+    };\n+\n+    sess.dep_graph.insert_work_product(&work_product_id, work_product);\n+}"}, {"sha": "49dad2d0f6d924653de235ab358a5540f163c512", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 70, "deletions": 15, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -44,7 +44,7 @@ use lint::{LintPass, LateLintPass};\n use std::collections::HashSet;\n \n use syntax::{ast};\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr::{self, AttrMetaMethods, AttributeMethods};\n use syntax_pos::{self, Span};\n \n use rustc::hir::{self, PatKind};\n@@ -298,12 +298,7 @@ impl MissingDoc {\n             }\n         }\n \n-        let has_doc = attrs.iter().any(|a| {\n-            match a.node.value.node {\n-                ast::MetaItemKind::NameValue(ref name, _) if *name == \"doc\" => true,\n-                _ => false\n-            }\n-        });\n+        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name() == \"doc\");\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS, sp,\n                          &format!(\"missing documentation for {}\", desc));\n@@ -572,18 +567,36 @@ declare_lint! {\n }\n \n /// Checks for use of items with `#[deprecated]` or `#[rustc_deprecated]` attributes\n-#[derive(Copy, Clone)]\n-pub struct Deprecated;\n+#[derive(Clone)]\n+pub struct Deprecated {\n+    /// Tracks the `NodeId` of the current item.\n+    ///\n+    /// This is required since not all node ids are present in the hir map.\n+    current_item: ast::NodeId,\n+}\n \n impl Deprecated {\n+    pub fn new() -> Deprecated {\n+        Deprecated {\n+            current_item: ast::CRATE_NODE_ID,\n+        }\n+    }\n+\n     fn lint(&self, cx: &LateContext, _id: DefId, span: Span,\n-            stability: &Option<&attr::Stability>, deprecation: &Option<attr::Deprecation>) {\n+            stability: &Option<&attr::Stability>,\n+            deprecation: &Option<stability::DeprecationEntry>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n         if let Some(&attr::Stability{rustc_depr: Some(attr::RustcDeprecation{ref reason, ..}), ..})\n                 = *stability {\n             output(cx, DEPRECATED, span, Some(&reason))\n-        } else if let Some(attr::Deprecation{ref note, ..}) = *deprecation {\n-            output(cx, DEPRECATED, span, note.as_ref().map(|x| &**x))\n+        } else if let Some(ref depr_entry) = *deprecation {\n+            if let Some(parent_depr) = cx.tcx.lookup_deprecation_entry(self.parent_def(cx)) {\n+                if parent_depr.same_origin(depr_entry) {\n+                    return;\n+                }\n+            }\n+\n+            output(cx, DEPRECATED, span, depr_entry.attr.note.as_ref().map(|x| &**x))\n         }\n \n         fn output(cx: &LateContext, lint: &'static Lint, span: Span, note: Option<&str>) {\n@@ -596,6 +609,19 @@ impl Deprecated {\n             cx.span_lint(lint, span, &msg);\n         }\n     }\n+\n+    fn push_item(&mut self, item_id: ast::NodeId) {\n+        self.current_item = item_id;\n+    }\n+\n+    fn item_post(&mut self, cx: &LateContext, item_id: ast::NodeId) {\n+        assert_eq!(self.current_item, item_id);\n+        self.current_item = cx.tcx.map.get_parent(item_id);\n+    }\n+\n+    fn parent_def(&self, cx: &LateContext) -> DefId {\n+        cx.tcx.map.local_def_id(self.current_item)\n+    }\n }\n \n impl LintPass for Deprecated {\n@@ -606,11 +632,16 @@ impl LintPass for Deprecated {\n \n impl LateLintPass for Deprecated {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n+        self.push_item(item.id);\n         stability::check_item(cx.tcx, item, false,\n                               &mut |id, sp, stab, depr|\n                                 self.lint(cx, id, sp, &stab, &depr));\n     }\n \n+    fn check_item_post(&mut self, cx: &LateContext, item: &hir::Item) {\n+        self.item_post(cx, item.id);\n+    }\n+\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         stability::check_expr(cx.tcx, e,\n                               &mut |id, sp, stab, depr|\n@@ -634,6 +665,30 @@ impl LateLintPass for Deprecated {\n                              &mut |id, sp, stab, depr|\n                                 self.lint(cx, id, sp, &stab, &depr));\n     }\n+\n+    fn check_impl_item(&mut self, _: &LateContext, item: &hir::ImplItem) {\n+        self.push_item(item.id);\n+    }\n+\n+    fn check_impl_item_post(&mut self, cx: &LateContext, item: &hir::ImplItem) {\n+        self.item_post(cx, item.id);\n+    }\n+\n+    fn check_trait_item(&mut self, _: &LateContext, item: &hir::TraitItem) {\n+        self.push_item(item.id);\n+    }\n+\n+    fn check_trait_item_post(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n+        self.item_post(cx, item.id);\n+    }\n+\n+    fn check_foreign_item(&mut self, _: &LateContext, item: &hir::ForeignItem) {\n+        self.push_item(item.id);\n+    }\n+\n+    fn check_foreign_item_post(&mut self, cx: &LateContext, item: &hir::ForeignItem) {\n+        self.item_post(cx, item.id);\n+    }\n }\n \n declare_lint! {\n@@ -1094,10 +1149,10 @@ impl LintPass for UnstableFeatures {\n \n impl LateLintPass for UnstableFeatures {\n     fn check_attribute(&mut self, ctx: &LateContext, attr: &ast::Attribute) {\n-        if attr::contains_name(&[attr.node.value.clone()], \"feature\") {\n-            if let Some(items) = attr.node.value.meta_item_list() {\n+        if attr::contains_name(&[attr.meta().clone()], \"feature\") {\n+            if let Some(items) = attr.meta().meta_item_list() {\n                 for item in items {\n-                    ctx.span_lint(UNSTABLE_FEATURES, item.span, \"unstable feature\");\n+                    ctx.span_lint(UNSTABLE_FEATURES, item.span(), \"unstable feature\");\n                 }\n             }\n         }"}, {"sha": "43376dfd8c2a0ec6dac298f4ba802f5d4caa84d8", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -124,7 +124,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  UnusedAllocation,\n                  MissingCopyImplementations,\n                  UnstableFeatures,\n-                 Deprecated,\n                  UnconditionalRecursion,\n                  InvalidNoMangleItems,\n                  PluginAsLibrary,\n@@ -133,6 +132,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  );\n \n     add_builtin_with_new!(sess,\n+                          Deprecated,\n                           TypeLimits,\n                           MissingDoc,\n                           MissingDebugImplementations,"}, {"sha": "f97daa22ff6624c26487dfe8b9a5e1d1a1c43fb0", "filename": "src/librustc_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.toml?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -17,4 +17,4 @@ rustc_bitflags = { path = \"../librustc_bitflags\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-gcc = \"0.3\"\n+gcc = \"0.3.27\""}, {"sha": "5f7a0f788ca1289e8da69b9e001289622041af8b", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -13,7 +13,7 @@ extern crate build_helper;\n \n use std::process::Command;\n use std::env;\n-use std::path::PathBuf;\n+use std::path::{PathBuf, Path};\n \n use build_helper::output;\n \n@@ -116,8 +116,7 @@ fn main() {\n         cfg.flag(\"-DLLVM_RUSTLLVM\");\n     }\n \n-    cfg.file(\"../rustllvm/ExecutionEngineWrapper.cpp\")\n-       .file(\"../rustllvm/PassWrapper.cpp\")\n+    cfg.file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n        .file(\"../rustllvm/ArchiveWrapper.cpp\")\n        .cpp(true)\n@@ -139,8 +138,17 @@ fn main() {\n             &lib[2..]\n         } else if lib.starts_with(\"-\") {\n             &lib[1..]\n+        } else if Path::new(lib).exists() {\n+            // On MSVC llvm-config will print the full name to libraries, but\n+            // we're only interested in the name part\n+            let name = Path::new(lib).file_name().unwrap().to_str().unwrap();\n+            name.trim_right_matches(\".lib\")\n+        } else if lib.ends_with(\".lib\") {\n+            // Some MSVC libraries just come up with `.lib` tacked on, so chop\n+            // that off\n+            lib.trim_right_matches(\".lib\")\n         } else {\n-            continue;\n+            continue\n         };\n \n         // Don't need or want this library, but LLVM's CMake build system\n@@ -149,7 +157,7 @@ fn main() {\n         // library and it otherwise may just pull in extra dependencies on\n         // libedit which we don't want\n         if name == \"LLVMLineEditor\" {\n-            continue;\n+            continue\n         }\n \n         let kind = if name.starts_with(\"LLVM\") {\n@@ -169,7 +177,9 @@ fn main() {\n     let mut cmd = Command::new(&llvm_config);\n     cmd.arg(\"--ldflags\");\n     for lib in output(&mut cmd).split_whitespace() {\n-        if is_crossed {\n+        if lib.starts_with(\"-LIBPATH:\") {\n+                println!(\"cargo:rustc-link-search=native={}\", &lib[9..]);\n+        } else if is_crossed {\n             if lib.starts_with(\"-L\") {\n                 println!(\"cargo:rustc-link-search=native={}\",\n                          lib[2..].replace(&host, &target));"}, {"sha": "8520ae1df60dd460898aa08fa6549d2bd23b432a", "filename": "src/librustc_llvm/diagnostic.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -16,22 +16,29 @@ pub use self::Diagnostic::*;\n use libc::{c_char, c_uint};\n use std::ptr;\n \n-use {DebugLocRef, DiagnosticInfoRef, TwineRef, ValueRef};\n+use {DiagnosticInfoRef, TwineRef, ValueRef};\n+use ffi::DebugLocRef;\n \n #[derive(Copy, Clone)]\n pub enum OptimizationDiagnosticKind {\n     OptimizationRemark,\n     OptimizationMissed,\n     OptimizationAnalysis,\n+    OptimizationAnalysisFPCommute,\n+    OptimizationAnalysisAliasing,\n     OptimizationFailure,\n+    OptimizationRemarkOther,\n }\n \n impl OptimizationDiagnosticKind {\n     pub fn describe(self) -> &'static str {\n         match self {\n-            OptimizationRemark => \"remark\",\n+            OptimizationRemark |\n+            OptimizationRemarkOther => \"remark\",\n             OptimizationMissed => \"missed\",\n             OptimizationAnalysis => \"analysis\",\n+            OptimizationAnalysisFPCommute => \"floating-point\",\n+            OptimizationAnalysisAliasing => \"aliasing\",\n             OptimizationFailure => \"failure\",\n         }\n     }\n@@ -58,11 +65,11 @@ impl OptimizationDiagnostic {\n             message: ptr::null_mut(),\n         };\n \n-        super::LLVMUnpackOptimizationDiagnostic(di,\n-                                                &mut opt.pass_name,\n-                                                &mut opt.function,\n-                                                &mut opt.debug_loc,\n-                                                &mut opt.message);\n+        super::LLVMRustUnpackOptimizationDiagnostic(di,\n+                                                    &mut opt.pass_name,\n+                                                    &mut opt.function,\n+                                                    &mut opt.debug_loc,\n+                                                    &mut opt.message);\n \n         opt\n     }\n@@ -84,10 +91,10 @@ impl InlineAsmDiagnostic {\n             instruction: ptr::null_mut(),\n         };\n \n-        super::LLVMUnpackInlineAsmDiagnostic(di,\n-                                             &mut opt.cookie,\n-                                             &mut opt.message,\n-                                             &mut opt.instruction);\n+        super::LLVMRustUnpackInlineAsmDiagnostic(di,\n+                                                 &mut opt.cookie,\n+                                                 &mut opt.message,\n+                                                 &mut opt.instruction);\n \n         opt\n     }\n@@ -103,24 +110,39 @@ pub enum Diagnostic {\n \n impl Diagnostic {\n     pub unsafe fn unpack(di: DiagnosticInfoRef) -> Diagnostic {\n-        let kind = super::LLVMGetDiagInfoKind(di);\n+        use super::DiagnosticKind as Dk;\n+        let kind = super::LLVMRustGetDiagInfoKind(di);\n \n         match kind {\n-            super::DK_InlineAsm => InlineAsm(InlineAsmDiagnostic::unpack(di)),\n+            Dk::InlineAsm => InlineAsm(InlineAsmDiagnostic::unpack(di)),\n \n-            super::DK_OptimizationRemark => {\n+            Dk::OptimizationRemark => {\n                 Optimization(OptimizationDiagnostic::unpack(OptimizationRemark, di))\n             }\n-\n-            super::DK_OptimizationRemarkMissed => {\n+            Dk::OptimizationRemarkOther => {\n+                Optimization(OptimizationDiagnostic::unpack(OptimizationRemarkOther, di))\n+            }\n+            Dk::OptimizationRemarkMissed => {\n                 Optimization(OptimizationDiagnostic::unpack(OptimizationMissed, di))\n             }\n \n-            super::DK_OptimizationRemarkAnalysis => {\n+            Dk::OptimizationRemarkAnalysis => {\n                 Optimization(OptimizationDiagnostic::unpack(OptimizationAnalysis, di))\n             }\n \n-            super::DK_OptimizationFailure => {\n+\n+            Dk::OptimizationRemarkAnalysisFPCommute => {\n+                Optimization(OptimizationDiagnostic::unpack(\n+                    OptimizationAnalysisFPCommute, di))\n+            }\n+\n+            Dk::OptimizationRemarkAnalysisAliasing => {\n+                Optimization(OptimizationDiagnostic::unpack(\n+                    OptimizationAnalysisAliasing, di))\n+            }\n+\n+\n+            Dk::OptimizationFailure => {\n                 Optimization(OptimizationDiagnostic::unpack(OptimizationFailure, di))\n             }\n "}, {"sha": "b2ffcac365bad34760351052003f8411d7265fb0", "filename": "src/librustc_llvm/ffi.rs", "status": "added", "additions": 2071, "deletions": 0, "changes": 2071, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -0,0 +1,2071 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use debuginfo::{DIBuilderRef, DIDescriptor,\n+                DIFile, DILexicalBlock, DISubprogram, DIType,\n+                DIBasicType, DIDerivedType, DICompositeType, DIScope,\n+                DIVariable, DIGlobalVariable, DIArray, DISubrange,\n+                DITemplateTypeParameter, DIEnumerator, DINameSpace};\n+\n+use libc::{c_uint, c_int, size_t, c_char};\n+use libc::{c_longlong, c_ulonglong, c_void};\n+\n+use RustStringRef;\n+\n+pub type Opcode = u32;\n+pub type Bool = c_uint;\n+\n+pub const True: Bool = 1 as Bool;\n+pub const False: Bool = 0 as Bool;\n+\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum LLVMRustResult {\n+    Success,\n+    Failure,\n+}\n+// Consts for the LLVM CallConv type, pre-cast to usize.\n+\n+/// LLVM CallingConv::ID. Should we wrap this?\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum CallConv {\n+    CCallConv = 0,\n+    FastCallConv = 8,\n+    ColdCallConv = 9,\n+    X86StdcallCallConv = 64,\n+    X86FastcallCallConv = 65,\n+    X86_64_Win64 = 79,\n+    X86_VectorCall = 80\n+}\n+\n+/// LLVMLinkage\n+///\n+/// This enum omits the obsolete (and no-op) linkage types DLLImportLinkage,\n+/// DLLExportLinkage, GhostLinkage and LinkOnceODRAutoHideLinkage.\n+/// LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n+/// they've been removed in upstream LLVM commit r203866.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[repr(C)]\n+pub enum Linkage {\n+    ExternalLinkage = 0,\n+    AvailableExternallyLinkage = 1,\n+    LinkOnceAnyLinkage = 2,\n+    LinkOnceODRLinkage = 3,\n+    WeakAnyLinkage = 5,\n+    WeakODRLinkage = 6,\n+    AppendingLinkage = 7,\n+    InternalLinkage = 8,\n+    PrivateLinkage = 9,\n+    ExternalWeakLinkage = 12,\n+    CommonLinkage = 14,\n+}\n+\n+/// LLVMDiagnosticSeverity\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub enum DiagnosticSeverity {\n+    Error = 0,\n+    Warning = 1,\n+    Remark = 2,\n+    Note = 3,\n+}\n+\n+/// LLVMDLLStorageClass\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum DLLStorageClass {\n+  Default   = 0,\n+  DllImport = 1, /* Function to be imported from DLL. */\n+  DllExport = 2, /* Function to be accessible from DLL. */\n+}\n+\n+bitflags! {\n+    #[derive(Default, Debug)]\n+    flags Attribute : u64 {\n+        const ZExt            = 1 << 0,\n+        const SExt            = 1 << 1,\n+        const NoReturn        = 1 << 2,\n+        const InReg           = 1 << 3,\n+        const StructRet       = 1 << 4,\n+        const NoUnwind        = 1 << 5,\n+        const NoAlias         = 1 << 6,\n+        const ByVal           = 1 << 7,\n+        const Nest            = 1 << 8,\n+        const ReadNone        = 1 << 9,\n+        const ReadOnly        = 1 << 10,\n+        const NoInline        = 1 << 11,\n+        const AlwaysInline    = 1 << 12,\n+        const OptimizeForSize = 1 << 13,\n+        const StackProtect    = 1 << 14,\n+        const StackProtectReq = 1 << 15,\n+        const NoCapture       = 1 << 21,\n+        const NoRedZone       = 1 << 22,\n+        const NoImplicitFloat = 1 << 23,\n+        const Naked           = 1 << 24,\n+        const InlineHint      = 1 << 25,\n+        const ReturnsTwice    = 1 << 29,\n+        const UWTable         = 1 << 30,\n+        const NonLazyBind     = 1 << 31,\n+\n+        // Some of these are missing from the LLVM C API, the rest are\n+        // present, but commented out, and preceded by the following warning:\n+        // FIXME: These attributes are currently not included in the C API as\n+        // a temporary measure until the API/ABI impact to the C API is understood\n+        // and the path forward agreed upon.\n+        const SanitizeAddress = 1 << 32,\n+        const MinSize         = 1 << 33,\n+        const NoDuplicate     = 1 << 34,\n+        const StackProtectStrong = 1 << 35,\n+        const SanitizeThread  = 1 << 36,\n+        const SanitizeMemory  = 1 << 37,\n+        const NoBuiltin       = 1 << 38,\n+        const Returned        = 1 << 39,\n+        const Cold            = 1 << 40,\n+        const Builtin         = 1 << 41,\n+        const OptimizeNone    = 1 << 42,\n+        const InAlloca        = 1 << 43,\n+        const NonNull         = 1 << 44,\n+        const JumpTable       = 1 << 45,\n+        const Convergent      = 1 << 46,\n+        const SafeStack       = 1 << 47,\n+        const NoRecurse       = 1 << 48,\n+        const InaccessibleMemOnly         = 1 << 49,\n+        const InaccessibleMemOrArgMemOnly = 1 << 50,\n+    }\n+}\n+\n+/// LLVMIntPredicate\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum IntPredicate {\n+    IntEQ = 32,\n+    IntNE = 33,\n+    IntUGT = 34,\n+    IntUGE = 35,\n+    IntULT = 36,\n+    IntULE = 37,\n+    IntSGT = 38,\n+    IntSGE = 39,\n+    IntSLT = 40,\n+    IntSLE = 41,\n+}\n+\n+/// LLVMRealPredicate\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum RealPredicate {\n+    RealPredicateFalse = 0,\n+    RealOEQ = 1,\n+    RealOGT = 2,\n+    RealOGE = 3,\n+    RealOLT = 4,\n+    RealOLE = 5,\n+    RealONE = 6,\n+    RealORD = 7,\n+    RealUNO = 8,\n+    RealUEQ = 9,\n+    RealUGT = 10,\n+    RealUGE = 11,\n+    RealULT = 12,\n+    RealULE = 13,\n+    RealUNE = 14,\n+    RealPredicateTrue = 15,\n+}\n+\n+/// LLVMTypeKind\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+#[repr(C)]\n+pub enum TypeKind {\n+    Void      = 0,\n+    Half      = 1,\n+    Float     = 2,\n+    Double    = 3,\n+    X86_FP80  = 4,\n+    FP128     = 5,\n+    PPC_FP128 = 6,\n+    Label     = 7,\n+    Integer   = 8,\n+    Function  = 9,\n+    Struct    = 10,\n+    Array     = 11,\n+    Pointer   = 12,\n+    Vector    = 13,\n+    Metadata  = 14,\n+    X86_MMX   = 15,\n+    Token     = 16,\n+}\n+\n+/// LLVMAtomicRmwBinOp\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum AtomicRmwBinOp {\n+    AtomicXchg = 0,\n+    AtomicAdd  = 1,\n+    AtomicSub  = 2,\n+    AtomicAnd  = 3,\n+    AtomicNand = 4,\n+    AtomicOr   = 5,\n+    AtomicXor  = 6,\n+    AtomicMax  = 7,\n+    AtomicMin  = 8,\n+    AtomicUMax = 9,\n+    AtomicUMin = 10,\n+}\n+\n+/// LLVMAtomicOrdering\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum AtomicOrdering {\n+    NotAtomic = 0,\n+    Unordered = 1,\n+    Monotonic = 2,\n+    // Consume = 3,  // Not specified yet.\n+    Acquire = 4,\n+    Release = 5,\n+    AcquireRelease = 6,\n+    SequentiallyConsistent = 7\n+}\n+\n+/// LLVMRustSynchronizationScope\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum SynchronizationScope {\n+    Other,\n+    SingleThread,\n+    CrossThread,\n+}\n+\n+/// LLVMRustFileType\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum FileType {\n+    Other,\n+    AssemblyFile,\n+    ObjectFile,\n+}\n+\n+/// Enum pinned in LLVMContext, used in\n+/// LLVMSetMetadata so ABI-stable.\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum MetadataType {\n+    MD_dbg = 0,\n+    MD_tbaa = 1,\n+    MD_prof = 2,\n+    MD_fpmath = 3,\n+    MD_range = 4,\n+    MD_tbaa_struct = 5,\n+    MD_invariant_load = 6,\n+    MD_alias_scope = 7,\n+    MD_noalias = 8,\n+    MD_nontemporal = 9,\n+    MD_mem_parallel_loop_access = 10,\n+    MD_nonnull = 11,\n+}\n+\n+/// LLVMRustAsmDialect\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum AsmDialect {\n+    Other,\n+    Att,\n+    Intel,\n+}\n+\n+/// LLVMRustCodeGenOptLevel\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum CodeGenOptLevel {\n+    Other,\n+    None,\n+    Less,\n+    Default,\n+    Aggressive,\n+}\n+\n+/// LLVMRelocMode\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum RelocMode {\n+    Default = 0,\n+    Static = 1,\n+    PIC = 2,\n+    DynamicNoPic = 3,\n+}\n+\n+/// LLVMRustCodeModel\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum CodeModel {\n+    Other,\n+    Default,\n+    JITDefault,\n+    Small,\n+    Kernel,\n+    Medium,\n+    Large,\n+}\n+\n+/// LLVMRustDiagnosticKind\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum DiagnosticKind {\n+    Other,\n+    InlineAsm,\n+    StackSize,\n+    DebugMetadataVersion,\n+    SampleProfile,\n+    OptimizationRemark,\n+    OptimizationRemarkMissed,\n+    OptimizationRemarkAnalysis,\n+    OptimizationRemarkAnalysisFPCommute,\n+    OptimizationRemarkAnalysisAliasing,\n+    OptimizationRemarkOther,\n+    OptimizationFailure,\n+}\n+\n+/// LLVMRustArchiveKind\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum ArchiveKind {\n+    Other,\n+    K_GNU,\n+    K_MIPS64,\n+    K_BSD,\n+    K_COFF,\n+}\n+\n+/// LLVMRustPassKind\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+#[repr(C)]\n+pub enum PassKind {\n+    Other,\n+    Function,\n+    Module,\n+}\n+\n+// Opaque pointer types\n+#[allow(missing_copy_implementations)]\n+pub enum Module_opaque {}\n+pub type ModuleRef = *mut Module_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Context_opaque {}\n+pub type ContextRef = *mut Context_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Type_opaque {}\n+pub type TypeRef = *mut Type_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Value_opaque {}\n+pub type ValueRef = *mut Value_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Metadata_opaque {}\n+pub type MetadataRef = *mut Metadata_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum BasicBlock_opaque {}\n+pub type BasicBlockRef = *mut BasicBlock_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Builder_opaque {}\n+pub type BuilderRef = *mut Builder_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum ExecutionEngine_opaque {}\n+pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum MemoryBuffer_opaque {}\n+pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum PassManager_opaque {}\n+pub type PassManagerRef = *mut PassManager_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum PassManagerBuilder_opaque {}\n+pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Use_opaque {}\n+pub type UseRef = *mut Use_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum TargetData_opaque {}\n+pub type TargetDataRef = *mut TargetData_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum ObjectFile_opaque {}\n+pub type ObjectFileRef = *mut ObjectFile_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum SectionIterator_opaque {}\n+pub type SectionIteratorRef = *mut SectionIterator_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Pass_opaque {}\n+pub type PassRef = *mut Pass_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum TargetMachine_opaque {}\n+pub type TargetMachineRef = *mut TargetMachine_opaque;\n+pub enum Archive_opaque {}\n+pub type ArchiveRef = *mut Archive_opaque;\n+pub enum ArchiveIterator_opaque {}\n+pub type ArchiveIteratorRef = *mut ArchiveIterator_opaque;\n+pub enum ArchiveChild_opaque {}\n+pub type ArchiveChildRef = *mut ArchiveChild_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Twine_opaque {}\n+pub type TwineRef = *mut Twine_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum DiagnosticInfo_opaque {}\n+pub type DiagnosticInfoRef = *mut DiagnosticInfo_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum DebugLoc_opaque {}\n+pub type DebugLocRef = *mut DebugLoc_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum SMDiagnostic_opaque {}\n+pub type SMDiagnosticRef = *mut SMDiagnostic_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum RustArchiveMember_opaque {}\n+pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum OperandBundleDef_opaque {}\n+pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n+\n+pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n+pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n+\n+pub mod debuginfo {\n+    pub use self::DIDescriptorFlags::*;\n+    use super::{MetadataRef};\n+\n+    #[allow(missing_copy_implementations)]\n+    pub enum DIBuilder_opaque {}\n+    pub type DIBuilderRef = *mut DIBuilder_opaque;\n+\n+    pub type DIDescriptor = MetadataRef;\n+    pub type DIScope = DIDescriptor;\n+    pub type DILocation = DIDescriptor;\n+    pub type DIFile = DIScope;\n+    pub type DILexicalBlock = DIScope;\n+    pub type DISubprogram = DIScope;\n+    pub type DINameSpace = DIScope;\n+    pub type DIType = DIDescriptor;\n+    pub type DIBasicType = DIType;\n+    pub type DIDerivedType = DIType;\n+    pub type DICompositeType = DIDerivedType;\n+    pub type DIVariable = DIDescriptor;\n+    pub type DIGlobalVariable = DIDescriptor;\n+    pub type DIArray = DIDescriptor;\n+    pub type DISubrange = DIDescriptor;\n+    pub type DIEnumerator = DIDescriptor;\n+    pub type DITemplateTypeParameter = DIDescriptor;\n+\n+    #[derive(Copy, Clone)]\n+    pub enum DIDescriptorFlags {\n+      FlagPrivate            = 1 << 0,\n+      FlagProtected          = 1 << 1,\n+      FlagFwdDecl            = 1 << 2,\n+      FlagAppleBlock         = 1 << 3,\n+      FlagBlockByrefStruct   = 1 << 4,\n+      FlagVirtual            = 1 << 5,\n+      FlagArtificial         = 1 << 6,\n+      FlagExplicit           = 1 << 7,\n+      FlagPrototyped         = 1 << 8,\n+      FlagObjcClassComplete  = 1 << 9,\n+      FlagObjectPointer      = 1 << 10,\n+      FlagVector             = 1 << 11,\n+      FlagStaticMember       = 1 << 12,\n+      FlagIndirectVariable   = 1 << 13,\n+      FlagLValueReference    = 1 << 14,\n+      FlagRValueReference    = 1 << 15\n+    }\n+}\n+\n+\n+// Link to our native llvm bindings (things that we need to use the C++ api\n+// for) and because llvm is written in C++ we need to link against libstdc++\n+//\n+// You'll probably notice that there is an omission of all LLVM libraries\n+// from this location. This is because the set of LLVM libraries that we\n+// link to is mostly defined by LLVM, and the `llvm-config` tool is used to\n+// figure out the exact set of libraries. To do this, the build system\n+// generates an llvmdeps.rs file next to this one which will be\n+// automatically updated whenever LLVM is updated to include an up-to-date\n+// set of the libraries we need to link to LLVM for.\n+#[link(name = \"rustllvm\", kind = \"static\")]\n+#[cfg(not(cargobuild))]\n+extern {}\n+\n+#[linked_from = \"rustllvm\"] // not quite true but good enough\n+extern {\n+    /* Create and destroy contexts. */\n+    pub fn LLVMContextCreate() -> ContextRef;\n+    pub fn LLVMContextDispose(C: ContextRef);\n+    pub fn LLVMGetMDKindIDInContext(C: ContextRef,\n+                                    Name: *const c_char,\n+                                    SLen: c_uint)\n+                                    -> c_uint;\n+\n+    /* Create and destroy modules. */\n+    pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char,\n+                                             C: ContextRef)\n+                                             -> ModuleRef;\n+    pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n+    pub fn LLVMCloneModule(M: ModuleRef) -> ModuleRef;\n+    pub fn LLVMDisposeModule(M: ModuleRef);\n+\n+    /// Data layout. See Module::getDataLayout.\n+    pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n+    pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n+\n+    /// Target triple. See Module::getTargetTriple.\n+    pub fn LLVMGetTarget(M: ModuleRef) -> *const c_char;\n+    pub fn LLVMSetTarget(M: ModuleRef, Triple: *const c_char);\n+\n+    /// See Module::dump.\n+    pub fn LLVMDumpModule(M: ModuleRef);\n+\n+    /// See Module::setModuleInlineAsm.\n+    pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n+\n+    /// See llvm::LLVMTypeKind::getTypeID.\n+    pub fn LLVMRustGetTypeKind(Ty: TypeRef) -> TypeKind;\n+\n+    /// See llvm::LLVMType::getContext.\n+    pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n+\n+    /* Operations on integer types */\n+    pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint)\n+                                -> TypeRef;\n+\n+    pub fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n+\n+    /* Operations on real types */\n+    pub fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n+\n+    /* Operations on function types */\n+    pub fn LLVMFunctionType(ReturnType: TypeRef,\n+                            ParamTypes: *const TypeRef,\n+                            ParamCount: c_uint,\n+                            IsVarArg: Bool)\n+                            -> TypeRef;\n+    pub fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n+    pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n+    pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *mut TypeRef);\n+\n+    /* Operations on struct types */\n+    pub fn LLVMStructTypeInContext(C: ContextRef,\n+                                   ElementTypes: *const TypeRef,\n+                                   ElementCount: c_uint,\n+                                   Packed: Bool)\n+                                   -> TypeRef;\n+    pub fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetStructElementTypes(StructTy: TypeRef,\n+                                     Dest: *mut TypeRef);\n+    pub fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n+\n+    /* Operations on array, pointer, and vector types (sequence types) */\n+    pub fn LLVMRustArrayType(ElementType: TypeRef, ElementCount: u64) -> TypeRef;\n+    pub fn LLVMPointerType(ElementType: TypeRef, AddressSpace: c_uint)\n+                           -> TypeRef;\n+    pub fn LLVMVectorType(ElementType: TypeRef, ElementCount: c_uint)\n+                          -> TypeRef;\n+\n+    pub fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n+    pub fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef, V: ValueRef)\n+                                  -> *const c_void;\n+    pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n+\n+    /* Operations on other types */\n+    pub fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMRustMetadataTypeInContext(C: ContextRef) -> TypeRef;\n+\n+    /* Operations on all values */\n+    pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n+    pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n+    pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n+    pub fn LLVMDumpValue(Val: ValueRef);\n+    pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n+    pub fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n+\n+    /* Operations on Uses */\n+    pub fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n+    pub fn LLVMGetNextUse(U: UseRef) -> UseRef;\n+    pub fn LLVMGetUser(U: UseRef) -> ValueRef;\n+    pub fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n+\n+    /* Operations on Users */\n+    pub fn LLVMGetNumOperands(Val: ValueRef) -> c_int;\n+    pub fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n+    pub fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n+\n+    /* Operations on constants of any type */\n+    pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n+    /* all zeroes */\n+    pub fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMConstICmp(Pred: IntPredicate, V1: ValueRef, V2: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef)\n+                         -> ValueRef;\n+    /* only for isize/vector */\n+    pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMIsConstant(Val: ValueRef) -> Bool;\n+    pub fn LLVMIsNull(Val: ValueRef) -> Bool;\n+    pub fn LLVMIsUndef(Val: ValueRef) -> Bool;\n+    pub fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n+\n+    /* Operations on metadata */\n+    pub fn LLVMMDStringInContext(C: ContextRef,\n+                                 Str: *const c_char,\n+                                 SLen: c_uint)\n+                                 -> ValueRef;\n+    pub fn LLVMMDNodeInContext(C: ContextRef,\n+                               Vals: *const ValueRef,\n+                               Count: c_uint)\n+                               -> ValueRef;\n+    pub fn LLVMAddNamedMetadataOperand(M: ModuleRef,\n+                                       Str: *const c_char,\n+                                       Val: ValueRef);\n+\n+    /* Operations on scalar constants */\n+    pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool)\n+                        -> ValueRef;\n+    pub fn LLVMConstIntOfString(IntTy: TypeRef, Text: *const c_char, Radix: u8)\n+                                -> ValueRef;\n+    pub fn LLVMConstIntOfStringAndSize(IntTy: TypeRef,\n+                                       Text: *const c_char,\n+                                       SLen: c_uint,\n+                                       Radix: u8)\n+                                       -> ValueRef;\n+    pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n+    pub fn LLVMConstRealOfString(RealTy: TypeRef, Text: *const c_char)\n+                                 -> ValueRef;\n+    pub fn LLVMConstRealOfStringAndSize(RealTy: TypeRef,\n+                                        Text: *const c_char,\n+                                        SLen: c_uint)\n+                                        -> ValueRef;\n+    pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n+    pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n+\n+\n+    /* Operations on composite constants */\n+    pub fn LLVMConstStringInContext(C: ContextRef,\n+                                    Str: *const c_char,\n+                                    Length: c_uint,\n+                                    DontNullTerminate: Bool)\n+                                    -> ValueRef;\n+    pub fn LLVMConstStructInContext(C: ContextRef,\n+                                    ConstantVals: *const ValueRef,\n+                                    Count: c_uint,\n+                                    Packed: Bool)\n+                                    -> ValueRef;\n+\n+    pub fn LLVMConstArray(ElementTy: TypeRef,\n+                          ConstantVals: *const ValueRef,\n+                          Length: c_uint)\n+                          -> ValueRef;\n+    pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint)\n+                           -> ValueRef;\n+\n+    /* Constant expressions */\n+    pub fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstNSWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstNUWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstNSWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstNUWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstNSWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstNUWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstUDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstSDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n+                              RHSConstant: ValueRef)\n+                              -> ValueRef;\n+    pub fn LLVMConstFDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstURem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstSRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstFRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstAnd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstOr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                       -> ValueRef;\n+    pub fn LLVMConstXor(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstGEP(ConstantVal: ValueRef,\n+                        ConstantIndices: *const ValueRef,\n+                        NumIndices: c_uint)\n+                        -> ValueRef;\n+    pub fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n+                                ConstantIndices: *const ValueRef,\n+                                NumIndices: c_uint)\n+                                -> ValueRef;\n+    pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n+                          -> ValueRef;\n+    pub fn LLVMConstSExt(ConstantVal: ValueRef, ToType: TypeRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstFPTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n+                            -> ValueRef;\n+    pub fn LLVMConstFPExt(ConstantVal: ValueRef, ToType: TypeRef)\n+                          -> ValueRef;\n+    pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: TypeRef)\n+                             -> ValueRef;\n+    pub fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: TypeRef)\n+                             -> ValueRef;\n+    pub fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                            -> ValueRef;\n+    pub fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                   -> ValueRef;\n+    pub fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                -> ValueRef;\n+    pub fn LLVMConstIntCast(ConstantVal: ValueRef,\n+                            ToType: TypeRef,\n+                            isSigned: Bool)\n+                            -> ValueRef;\n+    pub fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstSelect(ConstantCondition: ValueRef,\n+                           ConstantIfTrue: ValueRef,\n+                           ConstantIfFalse: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstExtractElement(VectorConstant: ValueRef,\n+                                   IndexConstant: ValueRef)\n+                                   -> ValueRef;\n+    pub fn LLVMConstInsertElement(VectorConstant: ValueRef,\n+                                  ElementValueConstant: ValueRef,\n+                                  IndexConstant: ValueRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n+                                  VectorBConstant: ValueRef,\n+                                  MaskConstant: ValueRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n+                                 IdxList: *const c_uint,\n+                                 NumIdx: c_uint)\n+                                 -> ValueRef;\n+    pub fn LLVMConstInsertValue(AggConstant: ValueRef,\n+                                ElementValueConstant: ValueRef,\n+                                IdxList: *const c_uint,\n+                                NumIdx: c_uint)\n+                                -> ValueRef;\n+    pub fn LLVMConstInlineAsm(Ty: TypeRef,\n+                              AsmString: *const c_char,\n+                              Constraints: *const c_char,\n+                              HasSideEffects: Bool,\n+                              IsAlignStack: Bool)\n+                              -> ValueRef;\n+    pub fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n+\n+\n+\n+    /* Operations on global variables, functions, and aliases (globals) */\n+    pub fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n+    pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n+    pub fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n+    pub fn LLVMSetLinkage(Global: ValueRef, Link: Linkage);\n+    pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n+    pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n+    pub fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n+    pub fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n+    pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n+    pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n+    pub fn LLVMSetDLLStorageClass(V: ValueRef,\n+                                  C: DLLStorageClass);\n+\n+\n+    /* Operations on global variables */\n+    pub fn LLVMIsAGlobalVariable(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n+                                       Ty: TypeRef,\n+                                       Name: *const c_char,\n+                                       AddressSpace: c_uint)\n+                                       -> ValueRef;\n+    pub fn LLVMGetNamedGlobal(M: ModuleRef,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMRustGetOrInsertGlobal(M: ModuleRef,\n+                                     Name: *const c_char,\n+                                     T: TypeRef)\n+                                     -> ValueRef;\n+    pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n+    pub fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMSetInitializer(GlobalVar: ValueRef,\n+                              ConstantVal: ValueRef);\n+    pub fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n+    pub fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n+    pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n+    pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n+    pub fn LLVMRustGetNamedValue(M: ModuleRef, Name: *const c_char) -> ValueRef;\n+\n+    /* Operations on aliases */\n+    pub fn LLVMAddAlias(M: ModuleRef,\n+                        Ty: TypeRef,\n+                        Aliasee: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+\n+    /* Operations on functions */\n+    pub fn LLVMAddFunction(M: ModuleRef,\n+                           Name: *const c_char,\n+                           FunctionTy: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMDeleteFunction(Fn: ValueRef);\n+    pub fn LLVMRustGetOrInsertFunction(M: ModuleRef,\n+                                       Name: *const c_char,\n+                                       FunctionTy: TypeRef)\n+                                       -> ValueRef;\n+    pub fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n+    pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n+    pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n+    pub fn LLVMRustAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: u64);\n+    pub fn LLVMRustAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n+    pub fn LLVMRustAddFunctionAttrStringValue(Fn: ValueRef, index: c_uint,\n+                                              Name: *const c_char,\n+                                              Value: *const c_char);\n+    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef,\n+                                            index: c_uint,\n+                                            attr: u64);\n+    pub fn LLVMRustRemoveFunctionAttrString(Fn: ValueRef,\n+                                            index: c_uint,\n+                                            Name: *const c_char);\n+    pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMRemoveFunctionAttr(Fn: ValueRef, val: c_uint);\n+\n+    /* Operations on parameters */\n+    pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMGetParams(Fn: ValueRef, Params: *const ValueRef);\n+    pub fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n+    pub fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n+    pub fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n+    pub fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n+    pub fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n+    pub fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n+\n+    /* Operations on basic blocks */\n+    pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n+    pub fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *const ValueRef);\n+    pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n+    pub fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n+    pub fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+\n+    pub fn LLVMAppendBasicBlockInContext(C: ContextRef,\n+                                         Fn: ValueRef,\n+                                         Name: *const c_char)\n+                                         -> BasicBlockRef;\n+    pub fn LLVMInsertBasicBlockInContext(C: ContextRef,\n+                                         BB: BasicBlockRef,\n+                                         Name: *const c_char)\n+                                         -> BasicBlockRef;\n+    pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n+\n+    pub fn LLVMMoveBasicBlockAfter(BB: BasicBlockRef,\n+                                   MoveAfter: BasicBlockRef);\n+\n+    pub fn LLVMMoveBasicBlockBefore(BB: BasicBlockRef,\n+                                    MoveBefore: BasicBlockRef);\n+\n+    /* Operations on instructions */\n+    pub fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n+\n+    /* Operations on call sites */\n+    pub fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n+    pub fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n+    pub fn LLVMAddInstrAttribute(Instr: ValueRef,\n+                                 index: c_uint,\n+                                 IA: c_uint);\n+    pub fn LLVMRemoveInstrAttribute(Instr: ValueRef,\n+                                    index: c_uint,\n+                                    IA: c_uint);\n+    pub fn LLVMSetInstrParamAlignment(Instr: ValueRef,\n+                                      index: c_uint,\n+                                      align: c_uint);\n+    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef,\n+                                    index: c_uint,\n+                                    Val: u64);\n+    pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: ValueRef,\n+                                                  index: c_uint,\n+                                                  bytes: u64);\n+\n+    /* Operations on call instructions (only) */\n+    pub fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n+    pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n+\n+    /* Operations on load/store instructions (only) */\n+    pub fn LLVMGetVolatile(MemoryAccessInst: ValueRef) -> Bool;\n+    pub fn LLVMSetVolatile(MemoryAccessInst: ValueRef, volatile: Bool);\n+\n+    /* Operations on phi nodes */\n+    pub fn LLVMAddIncoming(PhiNode: ValueRef,\n+                           IncomingValues: *const ValueRef,\n+                           IncomingBlocks: *const BasicBlockRef,\n+                           Count: c_uint);\n+    pub fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n+    pub fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: c_uint)\n+                                -> ValueRef;\n+    pub fn LLVMGetIncomingBlock(PhiNode: ValueRef, Index: c_uint)\n+                                -> BasicBlockRef;\n+\n+    /* Instruction builders */\n+    pub fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n+    pub fn LLVMPositionBuilder(Builder: BuilderRef,\n+                               Block: BasicBlockRef,\n+                               Instr: ValueRef);\n+    pub fn LLVMPositionBuilderBefore(Builder: BuilderRef,\n+                                     Instr: ValueRef);\n+    pub fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n+                                    Block: BasicBlockRef);\n+    pub fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n+    pub fn LLVMClearInsertionPosition(Builder: BuilderRef);\n+    pub fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n+    pub fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n+                                         Instr: ValueRef,\n+                                         Name: *const c_char);\n+    pub fn LLVMDisposeBuilder(Builder: BuilderRef);\n+\n+    /* Metadata */\n+    pub fn LLVMSetCurrentDebugLocation(Builder: BuilderRef, L: ValueRef);\n+    pub fn LLVMGetCurrentDebugLocation(Builder: BuilderRef) -> ValueRef;\n+    pub fn LLVMSetInstDebugLocation(Builder: BuilderRef, Inst: ValueRef);\n+\n+    /* Terminators */\n+    pub fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n+    pub fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildAggregateRet(B: BuilderRef,\n+                                 RetVals: *const ValueRef,\n+                                 N: c_uint)\n+                                 -> ValueRef;\n+    pub fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMBuildCondBr(B: BuilderRef,\n+                           If: ValueRef,\n+                           Then: BasicBlockRef,\n+                           Else: BasicBlockRef)\n+                           -> ValueRef;\n+    pub fn LLVMBuildSwitch(B: BuilderRef,\n+                           V: ValueRef,\n+                           Else: BasicBlockRef,\n+                           NumCases: c_uint)\n+                           -> ValueRef;\n+    pub fn LLVMBuildIndirectBr(B: BuilderRef,\n+                               Addr: ValueRef,\n+                               NumDests: c_uint)\n+                               -> ValueRef;\n+    pub fn LLVMRustBuildInvoke(B: BuilderRef,\n+                               Fn: ValueRef,\n+                               Args: *const ValueRef,\n+                               NumArgs: c_uint,\n+                               Then: BasicBlockRef,\n+                               Catch: BasicBlockRef,\n+                               Bundle: OperandBundleDefRef,\n+                               Name: *const c_char)\n+                               -> ValueRef;\n+    pub fn LLVMRustBuildLandingPad(B: BuilderRef,\n+                                   Ty: TypeRef,\n+                                   PersFn: ValueRef,\n+                                   NumClauses: c_uint,\n+                                   Name: *const c_char,\n+                                   F: ValueRef)\n+                                   -> ValueRef;\n+    pub fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n+\n+    pub fn LLVMRustBuildCleanupPad(B: BuilderRef,\n+                                   ParentPad: ValueRef,\n+                                   ArgCnt: c_uint,\n+                                   Args: *const ValueRef,\n+                                   Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustBuildCleanupRet(B: BuilderRef,\n+                                   CleanupPad: ValueRef,\n+                                   UnwindBB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMRustBuildCatchPad(B: BuilderRef,\n+                                 ParentPad: ValueRef,\n+                                 ArgCnt: c_uint,\n+                                 Args: *const ValueRef,\n+                                 Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustBuildCatchRet(B: BuilderRef,\n+                                 Pad: ValueRef,\n+                                 BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMRustBuildCatchSwitch(Builder: BuilderRef,\n+                                    ParentPad: ValueRef,\n+                                    BB: BasicBlockRef,\n+                                    NumHandlers: c_uint,\n+                                    Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustAddHandler(CatchSwitch: ValueRef,\n+                              Handler: BasicBlockRef);\n+    pub fn LLVMRustSetPersonalityFn(B: BuilderRef, Pers: ValueRef);\n+\n+    /* Add a case to the switch instruction */\n+    pub fn LLVMAddCase(Switch: ValueRef,\n+                       OnVal: ValueRef,\n+                       Dest: BasicBlockRef);\n+\n+    /* Add a destination to the indirectbr instruction */\n+    pub fn LLVMAddDestination(IndirectBr: ValueRef, Dest: BasicBlockRef);\n+\n+    /* Add a clause to the landing pad instruction */\n+    pub fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n+\n+    /* Set the cleanup on a landing pad instruction */\n+    pub fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n+\n+    /* Arithmetic */\n+    pub fn LLVMBuildAdd(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWAdd(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWAdd(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFAdd(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSub(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWSub(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWSub(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFSub(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildMul(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWMul(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWMul(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFMul(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildUDiv(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSDiv(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildExactSDiv(B: BuilderRef,\n+                              LHS: ValueRef,\n+                              RHS: ValueRef,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMBuildFDiv(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildURem(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSRem(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildFRem(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildShl(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildLShr(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildAShr(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildAnd(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildOr(B: BuilderRef,\n+                       LHS: ValueRef,\n+                       RHS: ValueRef,\n+                       Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildXor(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildBinOp(B: BuilderRef,\n+                          Op: Opcode,\n+                          LHS: ValueRef,\n+                          RHS: ValueRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMRustSetHasUnsafeAlgebra(Instr: ValueRef);\n+\n+    /* Memory */\n+    pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildLoad(B: BuilderRef,\n+                         PointerVal: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+\n+    pub fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef)\n+                          -> ValueRef;\n+\n+    pub fn LLVMBuildGEP(B: BuilderRef,\n+                        Pointer: ValueRef,\n+                        Indices: *const ValueRef,\n+                        NumIndices: c_uint,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildInBoundsGEP(B: BuilderRef,\n+                                Pointer: ValueRef,\n+                                Indices: *const ValueRef,\n+                                NumIndices: c_uint,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+    pub fn LLVMBuildStructGEP(B: BuilderRef,\n+                              Pointer: ValueRef,\n+                              Idx: c_uint,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMBuildGlobalString(B: BuilderRef,\n+                                 Str: *const c_char,\n+                                 Name: *const c_char)\n+                                 -> ValueRef;\n+    pub fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n+                                    Str: *const c_char,\n+                                    Name: *const c_char)\n+                                    -> ValueRef;\n+\n+    /* Casts */\n+    pub fn LLVMBuildTrunc(B: BuilderRef,\n+                          Val: ValueRef,\n+                          DestTy: TypeRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildZExt(B: BuilderRef,\n+                         Val: ValueRef,\n+                         DestTy: TypeRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSExt(B: BuilderRef,\n+                         Val: ValueRef,\n+                         DestTy: TypeRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildFPToUI(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFPToSI(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildUIToFP(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildSIToFP(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFPTrunc(B: BuilderRef,\n+                            Val: ValueRef,\n+                            DestTy: TypeRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+    pub fn LLVMBuildFPExt(B: BuilderRef,\n+                          Val: ValueRef,\n+                          DestTy: TypeRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildPtrToInt(B: BuilderRef,\n+                             Val: ValueRef,\n+                             DestTy: TypeRef,\n+                             Name: *const c_char)\n+                             -> ValueRef;\n+    pub fn LLVMBuildIntToPtr(B: BuilderRef,\n+                             Val: ValueRef,\n+                             DestTy: TypeRef,\n+                             Name: *const c_char)\n+                             -> ValueRef;\n+    pub fn LLVMBuildBitCast(B: BuilderRef,\n+                            Val: ValueRef,\n+                            DestTy: TypeRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+    pub fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n+                                   Val: ValueRef,\n+                                   DestTy: TypeRef,\n+                                   Name: *const c_char)\n+                                   -> ValueRef;\n+    pub fn LLVMBuildCast(B: BuilderRef,\n+                         Op: Opcode,\n+                         Val: ValueRef,\n+                         DestTy: TypeRef,\n+                         Name: *const c_char) -> ValueRef;\n+    pub fn LLVMBuildPointerCast(B: BuilderRef,\n+                                Val: ValueRef,\n+                                DestTy: TypeRef,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+    pub fn LLVMBuildIntCast(B: BuilderRef,\n+                            Val: ValueRef,\n+                            DestTy: TypeRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+    pub fn LLVMBuildFPCast(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+\n+    /* Comparisons */\n+    pub fn LLVMBuildICmp(B: BuilderRef,\n+                         Op: c_uint,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildFCmp(B: BuilderRef,\n+                         Op: c_uint,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+\n+    /* Miscellaneous instructions */\n+    pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMRustBuildCall(B: BuilderRef,\n+                             Fn: ValueRef,\n+                             Args: *const ValueRef,\n+                             NumArgs: c_uint,\n+                             Bundle: OperandBundleDefRef,\n+                             Name: *const c_char)\n+                             -> ValueRef;\n+    pub fn LLVMBuildSelect(B: BuilderRef,\n+                           If: ValueRef,\n+                           Then: ValueRef,\n+                           Else: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildVAArg(B: BuilderRef,\n+                          list: ValueRef,\n+                          Ty: TypeRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildExtractElement(B: BuilderRef,\n+                                   VecVal: ValueRef,\n+                                   Index: ValueRef,\n+                                   Name: *const c_char)\n+                                   -> ValueRef;\n+    pub fn LLVMBuildInsertElement(B: BuilderRef,\n+                                  VecVal: ValueRef,\n+                                  EltVal: ValueRef,\n+                                  Index: ValueRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildShuffleVector(B: BuilderRef,\n+                                  V1: ValueRef,\n+                                  V2: ValueRef,\n+                                  Mask: ValueRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildExtractValue(B: BuilderRef,\n+                                 AggVal: ValueRef,\n+                                 Index: c_uint,\n+                                 Name: *const c_char)\n+                                 -> ValueRef;\n+    pub fn LLVMBuildInsertValue(B: BuilderRef,\n+                                AggVal: ValueRef,\n+                                EltVal: ValueRef,\n+                                Index: c_uint,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+\n+    pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMBuildPtrDiff(B: BuilderRef,\n+                            LHS: ValueRef,\n+                            RHS: ValueRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+\n+    /* Atomic Operations */\n+    pub fn LLVMRustBuildAtomicLoad(B: BuilderRef,\n+                                   PointerVal: ValueRef,\n+                                   Name: *const c_char,\n+                                   Order: AtomicOrdering,\n+                                   Alignment: c_uint)\n+                                   -> ValueRef;\n+\n+    pub fn LLVMRustBuildAtomicStore(B: BuilderRef,\n+                                    Val: ValueRef,\n+                                    Ptr: ValueRef,\n+                                    Order: AtomicOrdering,\n+                                    Alignment: c_uint)\n+                                    -> ValueRef;\n+\n+    pub fn LLVMRustBuildAtomicCmpXchg(B: BuilderRef,\n+                                      LHS: ValueRef,\n+                                      CMP: ValueRef,\n+                                      RHS: ValueRef,\n+                                      Order: AtomicOrdering,\n+                                      FailureOrder: AtomicOrdering,\n+                                      Weak: Bool)\n+                                      -> ValueRef;\n+\n+    pub fn LLVMBuildAtomicRMW(B: BuilderRef,\n+                              Op: AtomicRmwBinOp,\n+                              LHS: ValueRef,\n+                              RHS: ValueRef,\n+                              Order: AtomicOrdering,\n+                              SingleThreaded: Bool)\n+                              -> ValueRef;\n+\n+    pub fn LLVMRustBuildAtomicFence(B: BuilderRef,\n+                                    Order: AtomicOrdering,\n+                                    Scope: SynchronizationScope);\n+\n+\n+    /* Selected entries from the downcasts. */\n+    pub fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n+\n+    /// Writes a module to the specified path. Returns 0 on success.\n+    pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n+\n+    /// Creates target data from a target layout string.\n+    pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n+    /// Number of bytes clobbered when doing a Store to *T.\n+    pub fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n+                               -> c_ulonglong;\n+\n+    /// Number of bytes clobbered when doing a Store to *T.\n+    pub fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n+                                -> c_ulonglong;\n+\n+    /// Distance between successive elements in an array of T. Includes ABI padding.\n+    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n+\n+    /// Returns the preferred alignment of a type.\n+    pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n+                                        -> c_uint;\n+    /// Returns the minimum alignment of a type.\n+    pub fn LLVMABIAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n+                                  -> c_uint;\n+\n+    /// Computes the byte offset of the indexed struct element for a\n+    /// target.\n+    pub fn LLVMOffsetOfElement(TD: TargetDataRef,\n+                               StructTy: TypeRef,\n+                               Element: c_uint)\n+                               -> c_ulonglong;\n+\n+    /// Returns the minimum alignment of a type when part of a call frame.\n+    pub fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n+                                        -> c_uint;\n+\n+    /// Disposes target data.\n+    pub fn LLVMDisposeTargetData(TD: TargetDataRef);\n+\n+    /// Creates a pass manager.\n+    pub fn LLVMCreatePassManager() -> PassManagerRef;\n+\n+    /// Creates a function-by-function pass manager\n+    pub fn LLVMCreateFunctionPassManagerForModule(M: ModuleRef)\n+                                                  -> PassManagerRef;\n+\n+    /// Disposes a pass manager.\n+    pub fn LLVMDisposePassManager(PM: PassManagerRef);\n+\n+    /// Runs a pass manager on a module.\n+    pub fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n+\n+    /// Runs the function passes on the provided function.\n+    pub fn LLVMRunFunctionPassManager(FPM: PassManagerRef, F: ValueRef)\n+                                      -> Bool;\n+\n+    /// Initializes all the function passes scheduled in the manager\n+    pub fn LLVMInitializeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n+\n+    /// Finalizes all the function passes scheduled in the manager\n+    pub fn LLVMFinalizeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n+\n+    pub fn LLVMInitializePasses();\n+\n+    /// Adds a verification pass.\n+    pub fn LLVMAddVerifierPass(PM: PassManagerRef);\n+\n+    pub fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n+    pub fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n+    pub fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n+    pub fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n+    pub fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n+    pub fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n+    pub fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n+    pub fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n+    pub fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n+    pub fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n+    pub fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n+    pub fn LLVMAddReassociatePass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n+    pub fn LLVMAddLICMPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n+    pub fn LLVMAddGVNPass(PM: PassManagerRef);\n+    pub fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n+    pub fn LLVMAddSCCPPass(PM: PassManagerRef);\n+    pub fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n+    pub fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n+    pub fn LLVMAddConstantMergePass(PM: PassManagerRef);\n+    pub fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n+    pub fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n+    pub fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n+    pub fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n+    pub fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n+    pub fn LLVMAddCorrelatedValuePropagationPass(PM: PassManagerRef);\n+    pub fn LLVMAddPruneEHPass(PM: PassManagerRef);\n+    pub fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n+    pub fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n+    pub fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n+    pub fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n+\n+    pub fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n+    pub fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n+    pub fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n+                                             OptimizationLevel: c_uint);\n+    pub fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n+                                              Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(\n+        PMB: PassManagerBuilderRef,\n+        threshold: c_uint);\n+    pub fn LLVMPassManagerBuilderPopulateModulePassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef);\n+\n+    pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef);\n+    pub fn LLVMPassManagerBuilderPopulateLTOPassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef,\n+        Internalize: Bool,\n+        RunInliner: Bool);\n+\n+    /// Destroys a memory buffer.\n+    pub fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n+\n+\n+    /* Stuff that's in rustllvm/ because it's not upstream yet. */\n+\n+    /// Opens an object file.\n+    pub fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n+    /// Closes an object file.\n+    pub fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n+\n+    /// Enumerates the sections in an object file.\n+    pub fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n+    /// Destroys a section iterator.\n+    pub fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n+    /// Returns true if the section iterator is at the end of the section\n+    /// list:\n+    pub fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n+                                      SI: SectionIteratorRef)\n+                                      -> Bool;\n+    /// Moves the section iterator to point to the next section.\n+    pub fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n+    /// Returns the current section size.\n+    pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n+    /// Returns the current section contents as a string buffer.\n+    pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *const c_char;\n+\n+    /// Reads the given file and returns it as a memory buffer. Use\n+    /// LLVMDisposeMemoryBuffer() to get rid of it.\n+    pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *const c_char)\n+                                                        -> MemoryBufferRef;\n+    /// Borrows the contents of the memory buffer (doesn't copy it)\n+    pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *const c_char,\n+                                                 InputDataLength: size_t,\n+                                                 BufferName: *const c_char,\n+                                                 RequiresNull: Bool)\n+                                                 -> MemoryBufferRef;\n+    pub fn LLVMCreateMemoryBufferWithMemoryRangeCopy(InputData: *const c_char,\n+                                                     InputDataLength: size_t,\n+                                                     BufferName: *const c_char)\n+                                                     -> MemoryBufferRef;\n+\n+    pub fn LLVMIsMultithreaded() -> Bool;\n+    pub fn LLVMStartMultithreaded() -> Bool;\n+\n+    /// Returns a string describing the last error caused by an LLVMRust* call.\n+    pub fn LLVMRustGetLastError() -> *const c_char;\n+\n+    /// Print the pass timings since static dtors aren't picking them up.\n+    pub fn LLVMRustPrintPassTimings();\n+\n+    pub fn LLVMStructCreateNamed(C: ContextRef, Name: *const c_char) -> TypeRef;\n+\n+    pub fn LLVMStructSetBody(StructTy: TypeRef,\n+                             ElementTypes: *const TypeRef,\n+                             ElementCount: c_uint,\n+                             Packed: Bool);\n+\n+    pub fn LLVMConstNamedStruct(S: TypeRef,\n+                                ConstantVals: *const ValueRef,\n+                                Count: c_uint)\n+                                -> ValueRef;\n+\n+    /// Enables LLVM debug output.\n+    pub fn LLVMRustSetDebug(Enabled: c_int);\n+\n+    /// Prepares inline assembly.\n+    pub fn LLVMRustInlineAsm(Ty: TypeRef,\n+                             AsmString: *const c_char,\n+                             Constraints: *const c_char,\n+                             SideEffects: Bool,\n+                             AlignStack: Bool,\n+                             Dialect: AsmDialect)\n+                             -> ValueRef;\n+\n+    pub fn LLVMRustDebugMetadataVersion() -> u32;\n+    pub fn LLVMRustVersionMajor() -> u32;\n+    pub fn LLVMRustVersionMinor() -> u32;\n+\n+    pub fn LLVMRustAddModuleFlag(M: ModuleRef,\n+                                 name: *const c_char,\n+                                 value: u32);\n+\n+    pub fn LLVMRustDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n+\n+    pub fn LLVMRustDIBuilderDispose(Builder: DIBuilderRef);\n+\n+    pub fn LLVMRustDIBuilderFinalize(Builder: DIBuilderRef);\n+\n+    pub fn LLVMRustDIBuilderCreateCompileUnit(Builder: DIBuilderRef,\n+                                              Lang: c_uint,\n+                                              File: *const c_char,\n+                                              Dir: *const c_char,\n+                                              Producer: *const c_char,\n+                                              isOptimized: bool,\n+                                              Flags: *const c_char,\n+                                              RuntimeVer: c_uint,\n+                                              SplitName: *const c_char)\n+                                              -> DIDescriptor;\n+\n+    pub fn LLVMRustDIBuilderCreateFile(Builder: DIBuilderRef,\n+                                       Filename: *const c_char,\n+                                       Directory: *const c_char)\n+                                       -> DIFile;\n+\n+    pub fn LLVMRustDIBuilderCreateSubroutineType(Builder: DIBuilderRef,\n+                                                 File: DIFile,\n+                                                 ParameterTypes: DIArray)\n+                                                 -> DICompositeType;\n+\n+    pub fn LLVMRustDIBuilderCreateFunction(Builder: DIBuilderRef,\n+                                           Scope: DIDescriptor,\n+                                           Name: *const c_char,\n+                                           LinkageName: *const c_char,\n+                                           File: DIFile,\n+                                           LineNo: c_uint,\n+                                           Ty: DIType,\n+                                           isLocalToUnit: bool,\n+                                           isDefinition: bool,\n+                                           ScopeLine: c_uint,\n+                                           Flags: c_uint,\n+                                           isOptimized: bool,\n+                                           Fn: ValueRef,\n+                                           TParam: DIArray,\n+                                           Decl: DIDescriptor)\n+                                           -> DISubprogram;\n+\n+    pub fn LLVMRustDIBuilderCreateBasicType(Builder: DIBuilderRef,\n+                                            Name: *const c_char,\n+                                            SizeInBits: u64,\n+                                            AlignInBits: u64,\n+                                            Encoding: c_uint)\n+                                            -> DIBasicType;\n+\n+    pub fn LLVMRustDIBuilderCreatePointerType(Builder: DIBuilderRef,\n+                                          PointeeTy: DIType,\n+                                          SizeInBits: u64,\n+                                          AlignInBits: u64,\n+                                          Name: *const c_char)\n+                                          -> DIDerivedType;\n+\n+    pub fn LLVMRustDIBuilderCreateStructType(Builder: DIBuilderRef,\n+                                             Scope: DIDescriptor,\n+                                             Name: *const c_char,\n+                                             File: DIFile,\n+                                             LineNumber: c_uint,\n+                                             SizeInBits: u64,\n+                                             AlignInBits: u64,\n+                                             Flags: c_uint,\n+                                             DerivedFrom: DIType,\n+                                             Elements: DIArray,\n+                                             RunTimeLang: c_uint,\n+                                             VTableHolder: DIType,\n+                                             UniqueId: *const c_char)\n+                                             -> DICompositeType;\n+\n+    pub fn LLVMRustDIBuilderCreateMemberType(Builder: DIBuilderRef,\n+                                             Scope: DIDescriptor,\n+                                             Name: *const c_char,\n+                                             File: DIFile,\n+                                             LineNo: c_uint,\n+                                             SizeInBits: u64,\n+                                             AlignInBits: u64,\n+                                             OffsetInBits: u64,\n+                                             Flags: c_uint,\n+                                             Ty: DIType)\n+                                             -> DIDerivedType;\n+\n+    pub fn LLVMRustDIBuilderCreateLexicalBlock(Builder: DIBuilderRef,\n+                                               Scope: DIScope,\n+                                               File: DIFile,\n+                                               Line: c_uint,\n+                                               Col: c_uint)\n+                                               -> DILexicalBlock;\n+\n+    pub fn LLVMRustDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n+                                                 Context: DIScope,\n+                                                 Name: *const c_char,\n+                                                 LinkageName: *const c_char,\n+                                                 File: DIFile,\n+                                                 LineNo: c_uint,\n+                                                 Ty: DIType,\n+                                                 isLocalToUnit: bool,\n+                                                 Val: ValueRef,\n+                                                 Decl: DIDescriptor)\n+                                                 -> DIGlobalVariable;\n+\n+    pub fn LLVMRustDIBuilderCreateVariable(Builder: DIBuilderRef,\n+                                           Tag: c_uint,\n+                                           Scope: DIDescriptor,\n+                                           Name: *const c_char,\n+                                           File: DIFile,\n+                                           LineNo: c_uint,\n+                                           Ty: DIType,\n+                                           AlwaysPreserve: bool,\n+                                           Flags: c_uint,\n+                                           AddrOps: *const i64,\n+                                           AddrOpsCount: c_uint,\n+                                           ArgNo: c_uint)\n+                                           -> DIVariable;\n+\n+    pub fn LLVMRustDIBuilderCreateArrayType(Builder: DIBuilderRef,\n+                                            Size: u64,\n+                                            AlignInBits: u64,\n+                                            Ty: DIType,\n+                                            Subscripts: DIArray)\n+                                            -> DIType;\n+\n+    pub fn LLVMRustDIBuilderCreateVectorType(Builder: DIBuilderRef,\n+                                             Size: u64,\n+                                             AlignInBits: u64,\n+                                             Ty: DIType,\n+                                             Subscripts: DIArray)\n+                                             -> DIType;\n+\n+    pub fn LLVMRustDIBuilderGetOrCreateSubrange(Builder: DIBuilderRef,\n+                                                Lo: i64,\n+                                                Count: i64)\n+                                                -> DISubrange;\n+\n+    pub fn LLVMRustDIBuilderGetOrCreateArray(Builder: DIBuilderRef,\n+                                             Ptr: *const DIDescriptor,\n+                                             Count: c_uint)\n+                                             -> DIArray;\n+\n+    pub fn LLVMRustDIBuilderInsertDeclareAtEnd(Builder: DIBuilderRef,\n+                                               Val: ValueRef,\n+                                               VarInfo: DIVariable,\n+                                               AddrOps: *const i64,\n+                                               AddrOpsCount: c_uint,\n+                                               DL: ValueRef,\n+                                               InsertAtEnd: BasicBlockRef)\n+                                               -> ValueRef;\n+\n+    pub fn LLVMRustDIBuilderInsertDeclareBefore(Builder: DIBuilderRef,\n+                                                Val: ValueRef,\n+                                                VarInfo: DIVariable,\n+                                                AddrOps: *const i64,\n+                                                AddrOpsCount: c_uint,\n+                                                DL: ValueRef,\n+                                                InsertBefore: ValueRef)\n+                                                -> ValueRef;\n+\n+    pub fn LLVMRustDIBuilderCreateEnumerator(Builder: DIBuilderRef,\n+                                             Name: *const c_char,\n+                                             Val: u64)\n+                                             -> DIEnumerator;\n+\n+    pub fn LLVMRustDIBuilderCreateEnumerationType(Builder: DIBuilderRef,\n+                                                  Scope: DIScope,\n+                                                  Name: *const c_char,\n+                                                  File: DIFile,\n+                                                  LineNumber: c_uint,\n+                                                  SizeInBits: u64,\n+                                                  AlignInBits: u64,\n+                                                  Elements: DIArray,\n+                                                  ClassType: DIType)\n+                                                  -> DIType;\n+\n+    pub fn LLVMRustDIBuilderCreateUnionType(Builder: DIBuilderRef,\n+                                            Scope: DIScope,\n+                                            Name: *const c_char,\n+                                            File: DIFile,\n+                                            LineNumber: c_uint,\n+                                            SizeInBits: u64,\n+                                            AlignInBits: u64,\n+                                            Flags: c_uint,\n+                                            Elements: DIArray,\n+                                            RunTimeLang: c_uint,\n+                                            UniqueId: *const c_char)\n+                                            -> DIType;\n+\n+    pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n+\n+    pub fn LLVMRustDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n+                                                        Scope: DIScope,\n+                                                        Name: *const c_char,\n+                                                        Ty: DIType,\n+                                                        File: DIFile,\n+                                                        LineNo: c_uint,\n+                                                        ColumnNo: c_uint)\n+                                                        -> DITemplateTypeParameter;\n+\n+\n+    pub fn LLVMRustDIBuilderCreateNameSpace(Builder: DIBuilderRef,\n+                                            Scope: DIScope,\n+                                            Name: *const c_char,\n+                                            File: DIFile,\n+                                            LineNo: c_uint)\n+                                            -> DINameSpace;\n+    pub fn LLVMRustDICompositeTypeSetTypeArray(Builder: DIBuilderRef,\n+                                               CompositeType: DIType,\n+                                               TypeArray: DIArray);\n+\n+\n+    pub fn LLVMRustDIBuilderCreateDebugLocation(Context: ContextRef,\n+                                                Line: c_uint,\n+                                                Column: c_uint,\n+                                                Scope: DIScope,\n+                                                InlinedAt: MetadataRef)\n+                                                -> ValueRef;\n+    pub fn LLVMRustDIBuilderCreateOpDeref() -> i64;\n+    pub fn LLVMRustDIBuilderCreateOpPlus() -> i64;\n+\n+    pub fn LLVMRustWriteTypeToString(Type: TypeRef, s: RustStringRef);\n+    pub fn LLVMRustWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n+\n+    pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n+\n+    pub fn LLVMIsAAllocaInst(value_ref: ValueRef) -> ValueRef;\n+    pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n+\n+    pub fn LLVMRustPassKind(Pass: PassRef) -> PassKind;\n+    pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> PassRef;\n+    pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: PassRef);\n+\n+    pub fn LLVMRustHasFeature(T: TargetMachineRef,\n+                              s: *const c_char) -> bool;\n+\n+    pub fn LLVMRustPrintTargetCPUs(T: TargetMachineRef);\n+    pub fn LLVMRustPrintTargetFeatures(T: TargetMachineRef);\n+\n+    pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n+                                       CPU: *const c_char,\n+                                       Features: *const c_char,\n+                                       Model: CodeModel,\n+                                       Reloc: RelocMode,\n+                                       Level: CodeGenOptLevel,\n+                                       UseSoftFP: bool,\n+                                       PositionIndependentExecutable: bool,\n+                                       FunctionSections: bool,\n+                                       DataSections: bool) -> TargetMachineRef;\n+    pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n+    pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef,\n+                                     PM: PassManagerRef,\n+                                     M: ModuleRef);\n+    pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n+                                         M: ModuleRef,\n+                                         DisableSimplifyLibCalls: bool);\n+    pub fn LLVMRustConfigurePassManagerBuilder(PMB: PassManagerBuilderRef,\n+                                               OptLevel: CodeGenOptLevel,\n+                                               MergeFunctions: bool,\n+                                               SLPVectorize: bool,\n+                                               LoopVectorize: bool);\n+    pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef, M: ModuleRef,\n+                                  DisableSimplifyLibCalls: bool);\n+    pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n+    pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n+                                   PM: PassManagerRef,\n+                                   M: ModuleRef,\n+                                   Output: *const c_char,\n+                                   FileType: FileType)\n+                                   -> LLVMRustResult;\n+    pub fn LLVMRustPrintModule(PM: PassManagerRef,\n+                               M: ModuleRef,\n+                               Output: *const c_char);\n+    pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n+    pub fn LLVMRustPrintPasses();\n+    pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n+    pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n+                                       AddLifetimes: bool);\n+    pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef,\n+                                         bc: *const c_char,\n+                                         len: size_t) -> bool;\n+    pub fn LLVMRustRunRestrictionPass(M: ModuleRef,\n+                                      syms: *const *const c_char,\n+                                      len: size_t);\n+    pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n+\n+    pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n+    pub fn LLVMRustArchiveIteratorNew(AR: ArchiveRef) -> ArchiveIteratorRef;\n+    pub fn LLVMRustArchiveIteratorNext(AIR: ArchiveIteratorRef) -> ArchiveChildRef;\n+    pub fn LLVMRustArchiveChildName(ACR: ArchiveChildRef,\n+                                    size: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildData(ACR: ArchiveChildRef,\n+                                    size: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildFree(ACR: ArchiveChildRef);\n+    pub fn LLVMRustArchiveIteratorFree(AIR: ArchiveIteratorRef);\n+    pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n+\n+    pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n+                                  data: *mut *const c_char) -> size_t;\n+\n+    pub fn LLVMRustWriteTwineToString(T: TwineRef, s: RustStringRef);\n+\n+    pub fn LLVMContextSetDiagnosticHandler(C: ContextRef,\n+                                           Handler: DiagnosticHandler,\n+                                           DiagnosticContext: *mut c_void);\n+\n+    pub fn LLVMRustUnpackOptimizationDiagnostic(DI: DiagnosticInfoRef,\n+                                                pass_name_out: *mut *const c_char,\n+                                                function_out: *mut ValueRef,\n+                                                debugloc_out: *mut DebugLocRef,\n+                                                message_out: *mut TwineRef);\n+    pub fn LLVMRustUnpackInlineAsmDiagnostic(DI: DiagnosticInfoRef,\n+                                             cookie_out: *mut c_uint,\n+                                             message_out: *mut TwineRef,\n+                                             instruction_out: *mut ValueRef);\n+\n+    pub fn LLVMRustWriteDiagnosticInfoToString(DI: DiagnosticInfoRef,\n+                                               s: RustStringRef);\n+    pub fn LLVMGetDiagInfoSeverity(DI: DiagnosticInfoRef) -> DiagnosticSeverity;\n+    pub fn LLVMRustGetDiagInfoKind(DI: DiagnosticInfoRef) -> DiagnosticKind;\n+\n+    pub fn LLVMRustWriteDebugLocToString(C: ContextRef,\n+                                         DL: DebugLocRef,\n+                                         s: RustStringRef);\n+\n+    pub fn LLVMRustSetInlineAsmDiagnosticHandler(C: ContextRef,\n+                                                 H: InlineAsmDiagHandler,\n+                                                 CX: *mut c_void);\n+\n+    pub fn LLVMRustWriteSMDiagnosticToString(d: SMDiagnosticRef, s: RustStringRef);\n+\n+    pub fn LLVMRustWriteArchive(Dst: *const c_char,\n+                                NumMembers: size_t,\n+                                Members: *const RustArchiveMemberRef,\n+                                WriteSymbtab: bool,\n+                                Kind: ArchiveKind) ->\n+                                LLVMRustResult;\n+    pub fn LLVMRustArchiveMemberNew(Filename: *const c_char,\n+                                    Name: *const c_char,\n+                                    Child: ArchiveChildRef) -> RustArchiveMemberRef;\n+    pub fn LLVMRustArchiveMemberFree(Member: RustArchiveMemberRef);\n+\n+    pub fn LLVMRustSetDataLayoutFromTargetMachine(M: ModuleRef,\n+                                                  TM: TargetMachineRef);\n+    pub fn LLVMRustGetModuleDataLayout(M: ModuleRef) -> TargetDataRef;\n+\n+    pub fn LLVMRustBuildOperandBundleDef(Name: *const c_char,\n+                                         Inputs: *const ValueRef,\n+                                         NumInputs: c_uint)\n+                                         -> OperandBundleDefRef;\n+    pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n+\n+    pub fn LLVMRustPositionBuilderAtStart(B: BuilderRef, BB: BasicBlockRef);\n+\n+    pub fn LLVMRustSetComdat(M: ModuleRef, V: ValueRef, Name: *const c_char);\n+    pub fn LLVMRustUnsetComdat(V: ValueRef);\n+    pub fn LLVMRustSetModulePIELevel(M: ModuleRef);\n+}\n+\n+\n+// LLVM requires symbols from this library, but apparently they're not printed\n+// during llvm-config?\n+#[cfg(windows)]\n+#[link(name = \"ole32\")]\n+extern {}"}, {"sha": "6c4e1a54ea7281b4ff3d0ae55f9c3ac7c9337e76", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 90, "deletions": 2082, "changes": 2172, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -33,157 +33,35 @@\n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n \n-pub use self::AttributeSet::*;\n pub use self::IntPredicate::*;\n pub use self::RealPredicate::*;\n pub use self::TypeKind::*;\n-pub use self::AtomicBinOp::*;\n-pub use self::AtomicOrdering::*;\n-pub use self::SynchronizationScope::*;\n-pub use self::FileType::*;\n+pub use self::AtomicRmwBinOp::*;\n pub use self::MetadataType::*;\n-pub use self::AsmDialect::*;\n-pub use self::CodeGenOptLevel::*;\n pub use self::CodeGenOptSize::*;\n-pub use self::RelocMode::*;\n-pub use self::CodeGenModel::*;\n pub use self::DiagnosticKind::*;\n pub use self::CallConv::*;\n-pub use self::Visibility::*;\n pub use self::DiagnosticSeverity::*;\n pub use self::Linkage::*;\n-pub use self::DLLStorageClassTypes::*;\n \n use std::str::FromStr;\n+use std::slice;\n use std::ffi::{CString, CStr};\n use std::cell::RefCell;\n-use std::slice;\n-use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n-use libc::{c_longlong, c_ulonglong, c_void};\n-use debuginfo::{DIBuilderRef, DIDescriptor,\n-                DIFile, DILexicalBlock, DISubprogram, DIType,\n-                DIBasicType, DIDerivedType, DICompositeType, DIScope,\n-                DIVariable, DIGlobalVariable, DIArray, DISubrange,\n-                DITemplateTypeParameter, DIEnumerator, DINameSpace};\n+use libc::{c_uint, c_char, size_t};\n \n pub mod archive_ro;\n pub mod diagnostic;\n+pub mod ffi;\n \n-pub type Opcode = u32;\n-pub type Bool = c_uint;\n-\n-pub const True: Bool = 1 as Bool;\n-pub const False: Bool = 0 as Bool;\n-\n-// Consts for the LLVM CallConv type, pre-cast to usize.\n-\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum CallConv {\n-    CCallConv = 0,\n-    FastCallConv = 8,\n-    ColdCallConv = 9,\n-    X86StdcallCallConv = 64,\n-    X86FastcallCallConv = 65,\n-    X86_64_Win64 = 79,\n-    X86_VectorCall = 80\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum Visibility {\n-    LLVMDefaultVisibility = 0,\n-    HiddenVisibility = 1,\n-    ProtectedVisibility = 2,\n-}\n-\n-// This enum omits the obsolete (and no-op) linkage types DLLImportLinkage,\n-// DLLExportLinkage, GhostLinkage and LinkOnceODRAutoHideLinkage.\n-// LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n-// they've been removed in upstream LLVM commit r203866.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum Linkage {\n-    ExternalLinkage = 0,\n-    AvailableExternallyLinkage = 1,\n-    LinkOnceAnyLinkage = 2,\n-    LinkOnceODRLinkage = 3,\n-    WeakAnyLinkage = 5,\n-    WeakODRLinkage = 6,\n-    AppendingLinkage = 7,\n-    InternalLinkage = 8,\n-    PrivateLinkage = 9,\n-    ExternalWeakLinkage = 12,\n-    CommonLinkage = 14,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone, Debug)]\n-pub enum DiagnosticSeverity {\n-    Error,\n-    Warning,\n-    Remark,\n-    Note,\n-}\n-\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum DLLStorageClassTypes {\n-    DefaultStorageClass = 0,\n-    DLLImportStorageClass = 1,\n-    DLLExportStorageClass = 2,\n-}\n-\n-bitflags! {\n-    #[derive(Default, Debug)]\n-    flags Attribute : u64 {\n-        const ZExt            = 1 << 0,\n-        const SExt            = 1 << 1,\n-        const NoReturn        = 1 << 2,\n-        const InReg           = 1 << 3,\n-        const StructRet       = 1 << 4,\n-        const NoUnwind        = 1 << 5,\n-        const NoAlias         = 1 << 6,\n-        const ByVal           = 1 << 7,\n-        const Nest            = 1 << 8,\n-        const ReadNone        = 1 << 9,\n-        const ReadOnly        = 1 << 10,\n-        const NoInline        = 1 << 11,\n-        const AlwaysInline    = 1 << 12,\n-        const OptimizeForSize = 1 << 13,\n-        const StackProtect    = 1 << 14,\n-        const StackProtectReq = 1 << 15,\n-        const NoCapture       = 1 << 21,\n-        const NoRedZone       = 1 << 22,\n-        const NoImplicitFloat = 1 << 23,\n-        const Naked           = 1 << 24,\n-        const InlineHint      = 1 << 25,\n-        const ReturnsTwice    = 1 << 29,\n-        const UWTable         = 1 << 30,\n-        const NonLazyBind     = 1 << 31,\n+pub use ffi::*;\n \n-        // Some of these are missing from the LLVM C API, the rest are\n-        // present, but commented out, and preceded by the following warning:\n-        // FIXME: These attributes are currently not included in the C API as\n-        // a temporary measure until the API/ABI impact to the C API is understood\n-        // and the path forward agreed upon.\n-        const SanitizeAddress = 1 << 32,\n-        const MinSize         = 1 << 33,\n-        const NoDuplicate     = 1 << 34,\n-        const StackProtectStrong = 1 << 35,\n-        const SanitizeThread  = 1 << 36,\n-        const SanitizeMemory  = 1 << 37,\n-        const NoBuiltin       = 1 << 38,\n-        const Returned        = 1 << 39,\n-        const Cold            = 1 << 40,\n-        const Builtin         = 1 << 41,\n-        const OptimizeNone    = 1 << 42,\n-        const InAlloca        = 1 << 43,\n-        const NonNull         = 1 << 44,\n-        const JumpTable       = 1 << 45,\n-        const Convergent      = 1 << 46,\n-        const SafeStack       = 1 << 47,\n-        const NoRecurse       = 1 << 48,\n-        const InaccessibleMemOnly         = 1 << 49,\n-        const InaccessibleMemOrArgMemOnly = 1 << 50,\n+impl LLVMRustResult {\n+    pub fn into_result(self) -> Result<(), ()> {\n+        match self {\n+            LLVMRustResult::Success => Ok(()),\n+            LLVMRustResult::Failure => Err(()),\n+        }\n     }\n }\n \n@@ -214,167 +92,64 @@ impl Attributes {\n         self\n     }\n \n-    pub fn apply_llfn(&self, idx: usize, llfn: ValueRef) {\n+    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n         unsafe {\n-            LLVMAddFunctionAttribute(llfn, idx as c_uint, self.regular.bits());\n+            self.regular.apply_llfn(idx, llfn);\n             if self.dereferenceable_bytes != 0 {\n-                LLVMAddDereferenceableAttr(llfn, idx as c_uint,\n-                                           self.dereferenceable_bytes);\n+                LLVMRustAddDereferenceableAttr(\n+                    llfn,\n+                    idx.as_uint(),\n+                    self.dereferenceable_bytes);\n             }\n         }\n     }\n \n-    pub fn apply_callsite(&self, idx: usize, callsite: ValueRef) {\n+    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n         unsafe {\n-            LLVMAddCallSiteAttribute(callsite, idx as c_uint, self.regular.bits());\n+            self.regular.apply_callsite(idx, callsite);\n             if self.dereferenceable_bytes != 0 {\n-                LLVMAddDereferenceableCallSiteAttr(callsite, idx as c_uint,\n-                                                   self.dereferenceable_bytes);\n+                LLVMRustAddDereferenceableCallSiteAttr(\n+                    callsite,\n+                    idx.as_uint(),\n+                    self.dereferenceable_bytes);\n             }\n         }\n     }\n }\n \n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum AttributeSet {\n-    ReturnIndex = 0,\n-    FunctionIndex = !0\n-}\n-\n-// enum for the LLVM IntPredicate type\n-#[derive(Copy, Clone)]\n-pub enum IntPredicate {\n-    IntEQ = 32,\n-    IntNE = 33,\n-    IntUGT = 34,\n-    IntUGE = 35,\n-    IntULT = 36,\n-    IntULE = 37,\n-    IntSGT = 38,\n-    IntSGE = 39,\n-    IntSLT = 40,\n-    IntSLE = 41,\n-}\n-\n-// enum for the LLVM RealPredicate type\n-#[derive(Copy, Clone)]\n-pub enum RealPredicate {\n-    RealPredicateFalse = 0,\n-    RealOEQ = 1,\n-    RealOGT = 2,\n-    RealOGE = 3,\n-    RealOLT = 4,\n-    RealOLE = 5,\n-    RealONE = 6,\n-    RealORD = 7,\n-    RealUNO = 8,\n-    RealUEQ = 9,\n-    RealUGT = 10,\n-    RealUGE = 11,\n-    RealULT = 12,\n-    RealULE = 13,\n-    RealUNE = 14,\n-    RealPredicateTrue = 15,\n-}\n-\n-// The LLVM TypeKind type - must stay in sync with the def of\n-// LLVMTypeKind in llvm/include/llvm-c/Core.h\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-#[repr(C)]\n-pub enum TypeKind {\n-    Void      = 0,\n-    Half      = 1,\n-    Float     = 2,\n-    Double    = 3,\n-    X86_FP80  = 4,\n-    FP128     = 5,\n-    PPC_FP128 = 6,\n-    Label     = 7,\n-    Integer   = 8,\n-    Function  = 9,\n-    Struct    = 10,\n-    Array     = 11,\n-    Pointer   = 12,\n-    Vector    = 13,\n-    Metadata  = 14,\n-    X86_MMX   = 15,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum AtomicBinOp {\n-    AtomicXchg = 0,\n-    AtomicAdd  = 1,\n-    AtomicSub  = 2,\n-    AtomicAnd  = 3,\n-    AtomicNand = 4,\n-    AtomicOr   = 5,\n-    AtomicXor  = 6,\n-    AtomicMax  = 7,\n-    AtomicMin  = 8,\n-    AtomicUMax = 9,\n-    AtomicUMin = 10,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum AtomicOrdering {\n-    NotAtomic = 0,\n-    Unordered = 1,\n-    Monotonic = 2,\n-    // Consume = 3,  // Not specified yet.\n-    Acquire = 4,\n-    Release = 5,\n-    AcquireRelease = 6,\n-    SequentiallyConsistent = 7\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum SynchronizationScope {\n-    SingleThread = 0,\n-    CrossThread = 1\n+pub fn AddFunctionAttrStringValue(\n+    llfn: ValueRef,\n+    idx: AttributePlace,\n+    attr: &'static str,\n+    value: &'static str\n+) {\n+    unsafe {\n+        LLVMRustAddFunctionAttrStringValue(\n+            llfn,\n+            idx.as_uint(),\n+            attr.as_ptr() as *const _,\n+            value.as_ptr() as *const _)\n+    }\n }\n \n-// Consts for the LLVMCodeGenFileType type (in include/llvm/c/TargetMachine.h)\n #[repr(C)]\n #[derive(Copy, Clone)]\n-pub enum FileType {\n-    AssemblyFileType = 0,\n-    ObjectFileType = 1\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum MetadataType {\n-    MD_dbg = 0,\n-    MD_tbaa = 1,\n-    MD_prof = 2,\n-    MD_fpmath = 3,\n-    MD_range = 4,\n-    MD_tbaa_struct = 5,\n-    MD_invariant_load = 6,\n-    MD_alias_scope = 7,\n-    MD_noalias = 8,\n-    MD_nontemporal = 9,\n-    MD_mem_parallel_loop_access = 10,\n-    MD_nonnull = 11,\n+pub enum AttributePlace {\n+    Argument(u32),\n+    Function,\n }\n \n-// Inline Asm Dialect\n-#[derive(Copy, Clone)]\n-pub enum AsmDialect {\n-    AD_ATT   = 0,\n-    AD_Intel = 1\n-}\n+impl AttributePlace {\n+    pub fn ReturnValue() -> Self {\n+        AttributePlace::Argument(0)\n+    }\n \n-#[derive(Copy, Clone, PartialEq)]\n-#[repr(C)]\n-pub enum CodeGenOptLevel {\n-    CodeGenLevelNone = 0,\n-    CodeGenLevelLess = 1,\n-    CodeGenLevelDefault = 2,\n-    CodeGenLevelAggressive = 3,\n+    fn as_uint(self) -> c_uint {\n+        match self {\n+            AttributePlace::Function => !0,\n+            AttributePlace::Argument(i) => i,\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -385,48 +160,6 @@ pub enum CodeGenOptSize {\n     CodeGenOptSizeAggressive = 2,\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n-#[repr(C)]\n-pub enum RelocMode {\n-    RelocDefault = 0,\n-    RelocStatic = 1,\n-    RelocPIC = 2,\n-    RelocDynamicNoPic = 3,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum CodeGenModel {\n-    CodeModelDefault = 0,\n-    CodeModelJITDefault = 1,\n-    CodeModelSmall = 2,\n-    CodeModelKernel = 3,\n-    CodeModelMedium = 4,\n-    CodeModelLarge = 5,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum DiagnosticKind {\n-    DK_InlineAsm = 0,\n-    DK_StackSize,\n-    DK_DebugMetadataVersion,\n-    DK_SampleProfile,\n-    DK_OptimizationRemark,\n-    DK_OptimizationRemarkMissed,\n-    DK_OptimizationRemarkAnalysis,\n-    DK_OptimizationFailure,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum ArchiveKind {\n-    K_GNU,\n-    K_MIPS64,\n-    K_BSD,\n-    K_COFF,\n-}\n-\n impl FromStr for ArchiveKind {\n     type Err = ();\n \n@@ -441,1731 +174,22 @@ impl FromStr for ArchiveKind {\n     }\n }\n \n-/// Represents the different LLVM passes Rust supports\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-#[repr(C)]\n-pub enum SupportedPassKind {\n-    Function,\n-    Module,\n-    Unsupported,\n-}\n-\n-// Opaque pointer types\n-#[allow(missing_copy_implementations)]\n-pub enum Module_opaque {}\n-pub type ModuleRef = *mut Module_opaque;\n #[allow(missing_copy_implementations)]\n-pub enum Context_opaque {}\n-pub type ContextRef = *mut Context_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Type_opaque {}\n-pub type TypeRef = *mut Type_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Value_opaque {}\n-pub type ValueRef = *mut Value_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Metadata_opaque {}\n-pub type MetadataRef = *mut Metadata_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum BasicBlock_opaque {}\n-pub type BasicBlockRef = *mut BasicBlock_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Builder_opaque {}\n-pub type BuilderRef = *mut Builder_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum ExecutionEngine_opaque {}\n-pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum MemoryBuffer_opaque {}\n-pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum PassManager_opaque {}\n-pub type PassManagerRef = *mut PassManager_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum PassManagerBuilder_opaque {}\n-pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Use_opaque {}\n-pub type UseRef = *mut Use_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum TargetData_opaque {}\n-pub type TargetDataRef = *mut TargetData_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum ObjectFile_opaque {}\n-pub type ObjectFileRef = *mut ObjectFile_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum SectionIterator_opaque {}\n-pub type SectionIteratorRef = *mut SectionIterator_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Pass_opaque {}\n-pub type PassRef = *mut Pass_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum TargetMachine_opaque {}\n-pub type TargetMachineRef = *mut TargetMachine_opaque;\n-pub enum Archive_opaque {}\n-pub type ArchiveRef = *mut Archive_opaque;\n-pub enum ArchiveIterator_opaque {}\n-pub type ArchiveIteratorRef = *mut ArchiveIterator_opaque;\n-pub enum ArchiveChild_opaque {}\n-pub type ArchiveChildRef = *mut ArchiveChild_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Twine_opaque {}\n-pub type TwineRef = *mut Twine_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum DiagnosticInfo_opaque {}\n-pub type DiagnosticInfoRef = *mut DiagnosticInfo_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum DebugLoc_opaque {}\n-pub type DebugLocRef = *mut DebugLoc_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum SMDiagnostic_opaque {}\n-pub type SMDiagnosticRef = *mut SMDiagnostic_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum RustArchiveMember_opaque {}\n-pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum OperandBundleDef_opaque {}\n-pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n-\n-pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n-pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n-\n-pub mod debuginfo {\n-    pub use self::DIDescriptorFlags::*;\n-    use super::{MetadataRef};\n-\n-    #[allow(missing_copy_implementations)]\n-    pub enum DIBuilder_opaque {}\n-    pub type DIBuilderRef = *mut DIBuilder_opaque;\n-\n-    pub type DIDescriptor = MetadataRef;\n-    pub type DIScope = DIDescriptor;\n-    pub type DILocation = DIDescriptor;\n-    pub type DIFile = DIScope;\n-    pub type DILexicalBlock = DIScope;\n-    pub type DISubprogram = DIScope;\n-    pub type DINameSpace = DIScope;\n-    pub type DIType = DIDescriptor;\n-    pub type DIBasicType = DIType;\n-    pub type DIDerivedType = DIType;\n-    pub type DICompositeType = DIDerivedType;\n-    pub type DIVariable = DIDescriptor;\n-    pub type DIGlobalVariable = DIDescriptor;\n-    pub type DIArray = DIDescriptor;\n-    pub type DISubrange = DIDescriptor;\n-    pub type DIEnumerator = DIDescriptor;\n-    pub type DITemplateTypeParameter = DIDescriptor;\n-\n-    #[derive(Copy, Clone)]\n-    pub enum DIDescriptorFlags {\n-      FlagPrivate            = 1 << 0,\n-      FlagProtected          = 1 << 1,\n-      FlagFwdDecl            = 1 << 2,\n-      FlagAppleBlock         = 1 << 3,\n-      FlagBlockByrefStruct   = 1 << 4,\n-      FlagVirtual            = 1 << 5,\n-      FlagArtificial         = 1 << 6,\n-      FlagExplicit           = 1 << 7,\n-      FlagPrototyped         = 1 << 8,\n-      FlagObjcClassComplete  = 1 << 9,\n-      FlagObjectPointer      = 1 << 10,\n-      FlagVector             = 1 << 11,\n-      FlagStaticMember       = 1 << 12,\n-      FlagIndirectVariable   = 1 << 13,\n-      FlagLValueReference    = 1 << 14,\n-      FlagRValueReference    = 1 << 15\n-    }\n-}\n-\n-\n-// Link to our native llvm bindings (things that we need to use the C++ api\n-// for) and because llvm is written in C++ we need to link against libstdc++\n-//\n-// You'll probably notice that there is an omission of all LLVM libraries\n-// from this location. This is because the set of LLVM libraries that we\n-// link to is mostly defined by LLVM, and the `llvm-config` tool is used to\n-// figure out the exact set of libraries. To do this, the build system\n-// generates an llvmdeps.rs file next to this one which will be\n-// automatically updated whenever LLVM is updated to include an up-to-date\n-// set of the libraries we need to link to LLVM for.\n-#[link(name = \"rustllvm\", kind = \"static\")]\n-#[cfg(not(cargobuild))]\n-extern {}\n-\n-#[linked_from = \"rustllvm\"] // not quite true but good enough\n-extern {\n-    /* Create and destroy contexts. */\n-    pub fn LLVMContextCreate() -> ContextRef;\n-    pub fn LLVMContextDispose(C: ContextRef);\n-    pub fn LLVMGetMDKindIDInContext(C: ContextRef,\n-                                    Name: *const c_char,\n-                                    SLen: c_uint)\n-                                    -> c_uint;\n-\n-    /* Create and destroy modules. */\n-    pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char,\n-                                             C: ContextRef)\n-                                             -> ModuleRef;\n-    pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n-    pub fn LLVMCloneModule(M: ModuleRef) -> ModuleRef;\n-    pub fn LLVMDisposeModule(M: ModuleRef);\n-\n-    /// Data layout. See Module::getDataLayout.\n-    pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n-    pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n-\n-    /// Target triple. See Module::getTargetTriple.\n-    pub fn LLVMGetTarget(M: ModuleRef) -> *const c_char;\n-    pub fn LLVMSetTarget(M: ModuleRef, Triple: *const c_char);\n-\n-    /// See Module::dump.\n-    pub fn LLVMDumpModule(M: ModuleRef);\n-\n-    /// See Module::setModuleInlineAsm.\n-    pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n-\n-    /// See llvm::LLVMTypeKind::getTypeID.\n-    pub fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n-\n-    /// See llvm::LLVMType::getContext.\n-    pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n-\n-    /* Operations on integer types */\n-    pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint)\n-                                -> TypeRef;\n-\n-    pub fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n-\n-    /* Operations on real types */\n-    pub fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n-\n-    /* Operations on function types */\n-    pub fn LLVMFunctionType(ReturnType: TypeRef,\n-                            ParamTypes: *const TypeRef,\n-                            ParamCount: c_uint,\n-                            IsVarArg: Bool)\n-                            -> TypeRef;\n-    pub fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n-    pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n-    pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *mut TypeRef);\n-\n-    /* Operations on struct types */\n-    pub fn LLVMStructTypeInContext(C: ContextRef,\n-                                   ElementTypes: *const TypeRef,\n-                                   ElementCount: c_uint,\n-                                   Packed: Bool)\n-                                   -> TypeRef;\n-    pub fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetStructElementTypes(StructTy: TypeRef,\n-                                     Dest: *mut TypeRef);\n-    pub fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n-\n-    /* Operations on array, pointer, and vector types (sequence types) */\n-    pub fn LLVMRustArrayType(ElementType: TypeRef, ElementCount: u64) -> TypeRef;\n-    pub fn LLVMPointerType(ElementType: TypeRef, AddressSpace: c_uint)\n-                           -> TypeRef;\n-    pub fn LLVMVectorType(ElementType: TypeRef, ElementCount: c_uint)\n-                          -> TypeRef;\n-\n-    pub fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n-    pub fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef, V: ValueRef)\n-                                  -> *const c_void;\n-    pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n-\n-    /* Operations on other types */\n-    pub fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n-\n-    /* Operations on all values */\n-    pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n-    pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n-    pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n-    pub fn LLVMDumpValue(Val: ValueRef);\n-    pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n-    pub fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n-    pub fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint) -> ValueRef;\n-    pub fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n-\n-    /* Operations on Uses */\n-    pub fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n-    pub fn LLVMGetNextUse(U: UseRef) -> UseRef;\n-    pub fn LLVMGetUser(U: UseRef) -> ValueRef;\n-    pub fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n-\n-    /* Operations on Users */\n-    pub fn LLVMGetNumOperands(Val: ValueRef) -> c_int;\n-    pub fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n-    pub fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n-\n-    /* Operations on constants of any type */\n-    pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n-    /* all zeroes */\n-    pub fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMConstICmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstFCmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n-                         -> ValueRef;\n-    /* only for isize/vector */\n-    pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMIsConstant(Val: ValueRef) -> Bool;\n-    pub fn LLVMIsNull(Val: ValueRef) -> Bool;\n-    pub fn LLVMIsUndef(Val: ValueRef) -> Bool;\n-    pub fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n-\n-    /* Operations on metadata */\n-    pub fn LLVMMDStringInContext(C: ContextRef,\n-                                 Str: *const c_char,\n-                                 SLen: c_uint)\n-                                 -> ValueRef;\n-    pub fn LLVMMDNodeInContext(C: ContextRef,\n-                               Vals: *const ValueRef,\n-                               Count: c_uint)\n-                               -> ValueRef;\n-    pub fn LLVMAddNamedMetadataOperand(M: ModuleRef,\n-                                       Str: *const c_char,\n-                                       Val: ValueRef);\n-\n-    /* Operations on scalar constants */\n-    pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool)\n-                        -> ValueRef;\n-    pub fn LLVMConstIntOfString(IntTy: TypeRef, Text: *const c_char, Radix: u8)\n-                                -> ValueRef;\n-    pub fn LLVMConstIntOfStringAndSize(IntTy: TypeRef,\n-                                       Text: *const c_char,\n-                                       SLen: c_uint,\n-                                       Radix: u8)\n-                                       -> ValueRef;\n-    pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n-    pub fn LLVMConstRealOfString(RealTy: TypeRef, Text: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMConstRealOfStringAndSize(RealTy: TypeRef,\n-                                        Text: *const c_char,\n-                                        SLen: c_uint)\n-                                        -> ValueRef;\n-    pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n-    pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n-\n-\n-    /* Operations on composite constants */\n-    pub fn LLVMConstStringInContext(C: ContextRef,\n-                                    Str: *const c_char,\n-                                    Length: c_uint,\n-                                    DontNullTerminate: Bool)\n-                                    -> ValueRef;\n-    pub fn LLVMConstStructInContext(C: ContextRef,\n-                                    ConstantVals: *const ValueRef,\n-                                    Count: c_uint,\n-                                    Packed: Bool)\n-                                    -> ValueRef;\n-\n-    pub fn LLVMConstArray(ElementTy: TypeRef,\n-                          ConstantVals: *const ValueRef,\n-                          Length: c_uint)\n-                          -> ValueRef;\n-    pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint)\n-                           -> ValueRef;\n-\n-    /* Constant expressions */\n-    pub fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstNSWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstNUWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstNSWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstNUWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstNSWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstNUWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstUDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstSDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n-                              RHSConstant: ValueRef)\n-                              -> ValueRef;\n-    pub fn LLVMConstFDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstURem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstSRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstFRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstAnd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstOr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                       -> ValueRef;\n-    pub fn LLVMConstXor(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                        -> ValueRef;\n-    pub fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstGEP(ConstantVal: ValueRef,\n-                        ConstantIndices: *const ValueRef,\n-                        NumIndices: c_uint)\n-                        -> ValueRef;\n-    pub fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n-                                ConstantIndices: *const ValueRef,\n-                                NumIndices: c_uint)\n-                                -> ValueRef;\n-    pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n-                          -> ValueRef;\n-    pub fn LLVMConstSExt(ConstantVal: ValueRef, ToType: TypeRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef)\n-                         -> ValueRef;\n-    pub fn LLVMConstFPTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n-                            -> ValueRef;\n-    pub fn LLVMConstFPExt(ConstantVal: ValueRef, ToType: TypeRef)\n-                          -> ValueRef;\n-    pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: TypeRef)\n-                             -> ValueRef;\n-    pub fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: TypeRef)\n-                             -> ValueRef;\n-    pub fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                            -> ValueRef;\n-    pub fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                  -> ValueRef;\n-    pub fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                  -> ValueRef;\n-    pub fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                   -> ValueRef;\n-    pub fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                -> ValueRef;\n-    pub fn LLVMConstIntCast(ConstantVal: ValueRef,\n-                            ToType: TypeRef,\n-                            isSigned: Bool)\n-                            -> ValueRef;\n-    pub fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstSelect(ConstantCondition: ValueRef,\n-                           ConstantIfTrue: ValueRef,\n-                           ConstantIfFalse: ValueRef)\n-                           -> ValueRef;\n-    pub fn LLVMConstExtractElement(VectorConstant: ValueRef,\n-                                   IndexConstant: ValueRef)\n-                                   -> ValueRef;\n-    pub fn LLVMConstInsertElement(VectorConstant: ValueRef,\n-                                  ElementValueConstant: ValueRef,\n-                                  IndexConstant: ValueRef)\n-                                  -> ValueRef;\n-    pub fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n-                                  VectorBConstant: ValueRef,\n-                                  MaskConstant: ValueRef)\n-                                  -> ValueRef;\n-    pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n-                                 IdxList: *const c_uint,\n-                                 NumIdx: c_uint)\n-                                 -> ValueRef;\n-    pub fn LLVMConstInsertValue(AggConstant: ValueRef,\n-                                ElementValueConstant: ValueRef,\n-                                IdxList: *const c_uint,\n-                                NumIdx: c_uint)\n-                                -> ValueRef;\n-    pub fn LLVMConstInlineAsm(Ty: TypeRef,\n-                              AsmString: *const c_char,\n-                              Constraints: *const c_char,\n-                              HasSideEffects: Bool,\n-                              IsAlignStack: Bool)\n-                              -> ValueRef;\n-    pub fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n-\n-\n-\n-    /* Operations on global variables, functions, and aliases (globals) */\n-    pub fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n-    pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n-    pub fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n-    pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n-    pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n-    pub fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n-    pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n-\n-\n-    /* Operations on global variables */\n-    pub fn LLVMIsAGlobalVariable(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n-                                       Ty: TypeRef,\n-                                       Name: *const c_char,\n-                                       AddressSpace: c_uint)\n-                                       -> ValueRef;\n-    pub fn LLVMGetNamedGlobal(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMGetOrInsertGlobal(M: ModuleRef, Name: *const c_char, T: TypeRef) -> ValueRef;\n-    pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n-    pub fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMSetInitializer(GlobalVar: ValueRef,\n-                              ConstantVal: ValueRef);\n-    pub fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n-    pub fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n-    pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n-    pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n-    pub fn LLVMGetNamedValue(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-\n-    /* Operations on aliases */\n-    pub fn LLVMAddAlias(M: ModuleRef,\n-                        Ty: TypeRef,\n-                        Aliasee: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-\n-    /* Operations on functions */\n-    pub fn LLVMAddFunction(M: ModuleRef,\n-                           Name: *const c_char,\n-                           FunctionTy: TypeRef)\n-                           -> ValueRef;\n-    pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMDeleteFunction(Fn: ValueRef);\n-    pub fn LLVMGetOrInsertFunction(M: ModuleRef,\n-                                   Name: *const c_char,\n-                                   FunctionTy: TypeRef)\n-                                   -> ValueRef;\n-    pub fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n-    pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n-    pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n-    pub fn LLVMAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: uint64_t);\n-    pub fn LLVMAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: uint64_t);\n-    pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n-    pub fn LLVMAddFunctionAttrStringValue(Fn: ValueRef, index: c_uint,\n-                                          Name: *const c_char,\n-                                          Value: *const c_char);\n-    pub fn LLVMRemoveFunctionAttributes(Fn: ValueRef, index: c_uint, attr: uint64_t);\n-    pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n-    pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMRemoveFunctionAttr(Fn: ValueRef, val: c_uint);\n-\n-    /* Operations on parameters */\n-    pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMGetParams(Fn: ValueRef, Params: *const ValueRef);\n-    pub fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n-    pub fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n-    pub fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n-    pub fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n-    pub fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n-    pub fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n-    pub fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n-\n-    /* Operations on basic blocks */\n-    pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n-    pub fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *const ValueRef);\n-    pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n-    pub fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n-    pub fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-\n-    pub fn LLVMAppendBasicBlockInContext(C: ContextRef,\n-                                         Fn: ValueRef,\n-                                         Name: *const c_char)\n-                                         -> BasicBlockRef;\n-    pub fn LLVMInsertBasicBlockInContext(C: ContextRef,\n-                                         BB: BasicBlockRef,\n-                                         Name: *const c_char)\n-                                         -> BasicBlockRef;\n-    pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n-\n-    pub fn LLVMMoveBasicBlockAfter(BB: BasicBlockRef,\n-                                   MoveAfter: BasicBlockRef);\n-\n-    pub fn LLVMMoveBasicBlockBefore(BB: BasicBlockRef,\n-                                    MoveBefore: BasicBlockRef);\n-\n-    /* Operations on instructions */\n-    pub fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n-\n-    /* Operations on call sites */\n-    pub fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n-    pub fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n-    pub fn LLVMAddInstrAttribute(Instr: ValueRef,\n-                                 index: c_uint,\n-                                 IA: c_uint);\n-    pub fn LLVMRemoveInstrAttribute(Instr: ValueRef,\n-                                    index: c_uint,\n-                                    IA: c_uint);\n-    pub fn LLVMSetInstrParamAlignment(Instr: ValueRef,\n-                                      index: c_uint,\n-                                      align: c_uint);\n-    pub fn LLVMAddCallSiteAttribute(Instr: ValueRef,\n-                                    index: c_uint,\n-                                    Val: uint64_t);\n-    pub fn LLVMAddDereferenceableCallSiteAttr(Instr: ValueRef,\n-                                              index: c_uint,\n-                                              bytes: uint64_t);\n-\n-    /* Operations on call instructions (only) */\n-    pub fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n-    pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n-\n-    /* Operations on load/store instructions (only) */\n-    pub fn LLVMGetVolatile(MemoryAccessInst: ValueRef) -> Bool;\n-    pub fn LLVMSetVolatile(MemoryAccessInst: ValueRef, volatile: Bool);\n-\n-    /* Operations on phi nodes */\n-    pub fn LLVMAddIncoming(PhiNode: ValueRef,\n-                           IncomingValues: *const ValueRef,\n-                           IncomingBlocks: *const BasicBlockRef,\n-                           Count: c_uint);\n-    pub fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n-    pub fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: c_uint)\n-                                -> ValueRef;\n-    pub fn LLVMGetIncomingBlock(PhiNode: ValueRef, Index: c_uint)\n-                                -> BasicBlockRef;\n-\n-    /* Instruction builders */\n-    pub fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n-    pub fn LLVMPositionBuilder(Builder: BuilderRef,\n-                               Block: BasicBlockRef,\n-                               Instr: ValueRef);\n-    pub fn LLVMPositionBuilderBefore(Builder: BuilderRef,\n-                                     Instr: ValueRef);\n-    pub fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n-                                    Block: BasicBlockRef);\n-    pub fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n-    pub fn LLVMClearInsertionPosition(Builder: BuilderRef);\n-    pub fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n-    pub fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n-                                         Instr: ValueRef,\n-                                         Name: *const c_char);\n-    pub fn LLVMDisposeBuilder(Builder: BuilderRef);\n-\n-    /* Execution engine */\n-    pub fn LLVMBuildExecutionEngine(Mod: ModuleRef) -> ExecutionEngineRef;\n-    pub fn LLVMDisposeExecutionEngine(EE: ExecutionEngineRef);\n-    pub fn LLVMExecutionEngineFinalizeObject(EE: ExecutionEngineRef);\n-    pub fn LLVMRustLoadDynamicLibrary(path: *const c_char) -> Bool;\n-    pub fn LLVMExecutionEngineAddModule(EE: ExecutionEngineRef, M: ModuleRef);\n-    pub fn LLVMExecutionEngineRemoveModule(EE: ExecutionEngineRef, M: ModuleRef)\n-                                           -> Bool;\n-\n-    /* Metadata */\n-    pub fn LLVMSetCurrentDebugLocation(Builder: BuilderRef, L: ValueRef);\n-    pub fn LLVMGetCurrentDebugLocation(Builder: BuilderRef) -> ValueRef;\n-    pub fn LLVMSetInstDebugLocation(Builder: BuilderRef, Inst: ValueRef);\n-\n-    /* Terminators */\n-    pub fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n-    pub fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildAggregateRet(B: BuilderRef,\n-                                 RetVals: *const ValueRef,\n-                                 N: c_uint)\n-                                 -> ValueRef;\n-    pub fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMBuildCondBr(B: BuilderRef,\n-                           If: ValueRef,\n-                           Then: BasicBlockRef,\n-                           Else: BasicBlockRef)\n-                           -> ValueRef;\n-    pub fn LLVMBuildSwitch(B: BuilderRef,\n-                           V: ValueRef,\n-                           Else: BasicBlockRef,\n-                           NumCases: c_uint)\n-                           -> ValueRef;\n-    pub fn LLVMBuildIndirectBr(B: BuilderRef,\n-                               Addr: ValueRef,\n-                               NumDests: c_uint)\n-                               -> ValueRef;\n-    pub fn LLVMRustBuildInvoke(B: BuilderRef,\n-                               Fn: ValueRef,\n-                               Args: *const ValueRef,\n-                               NumArgs: c_uint,\n-                               Then: BasicBlockRef,\n-                               Catch: BasicBlockRef,\n-                               Bundle: OperandBundleDefRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-    pub fn LLVMRustBuildLandingPad(B: BuilderRef,\n-                                   Ty: TypeRef,\n-                                   PersFn: ValueRef,\n-                                   NumClauses: c_uint,\n-                                   Name: *const c_char,\n-                                   F: ValueRef)\n-                                   -> ValueRef;\n-    pub fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n-\n-    pub fn LLVMRustBuildCleanupPad(B: BuilderRef,\n-                                   ParentPad: ValueRef,\n-                                   ArgCnt: c_uint,\n-                                   Args: *const ValueRef,\n-                                   Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustBuildCleanupRet(B: BuilderRef,\n-                                   CleanupPad: ValueRef,\n-                                   UnwindBB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMRustBuildCatchPad(B: BuilderRef,\n-                                 ParentPad: ValueRef,\n-                                 ArgCnt: c_uint,\n-                                 Args: *const ValueRef,\n-                                 Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustBuildCatchRet(B: BuilderRef,\n-                                 Pad: ValueRef,\n-                                 BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMRustBuildCatchSwitch(Builder: BuilderRef,\n-                                    ParentPad: ValueRef,\n-                                    BB: BasicBlockRef,\n-                                    NumHandlers: c_uint,\n-                                    Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustAddHandler(CatchSwitch: ValueRef,\n-                              Handler: BasicBlockRef);\n-    pub fn LLVMRustSetPersonalityFn(B: BuilderRef, Pers: ValueRef);\n-\n-    /* Add a case to the switch instruction */\n-    pub fn LLVMAddCase(Switch: ValueRef,\n-                       OnVal: ValueRef,\n-                       Dest: BasicBlockRef);\n-\n-    /* Add a destination to the indirectbr instruction */\n-    pub fn LLVMAddDestination(IndirectBr: ValueRef, Dest: BasicBlockRef);\n-\n-    /* Add a clause to the landing pad instruction */\n-    pub fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n-\n-    /* Set the cleanup on a landing pad instruction */\n-    pub fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n-\n-    /* Arithmetic */\n-    pub fn LLVMBuildAdd(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWAdd(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWAdd(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFAdd(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSub(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWSub(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWSub(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFSub(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildMul(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWMul(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWMul(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFMul(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildUDiv(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSDiv(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildExactSDiv(B: BuilderRef,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildFDiv(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildURem(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSRem(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFRem(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildShl(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildLShr(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildAShr(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildAnd(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildOr(B: BuilderRef,\n-                       LHS: ValueRef,\n-                       RHS: ValueRef,\n-                       Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildXor(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildBinOp(B: BuilderRef,\n-                          Op: Opcode,\n-                          LHS: ValueRef,\n-                          RHS: ValueRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMRustSetHasUnsafeAlgebra(Instr: ValueRef);\n-\n-    /* Memory */\n-    pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildLoad(B: BuilderRef,\n-                         PointerVal: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-\n-    pub fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef)\n-                          -> ValueRef;\n-\n-    pub fn LLVMBuildGEP(B: BuilderRef,\n-                        Pointer: ValueRef,\n-                        Indices: *const ValueRef,\n-                        NumIndices: c_uint,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildInBoundsGEP(B: BuilderRef,\n-                                Pointer: ValueRef,\n-                                Indices: *const ValueRef,\n-                                NumIndices: c_uint,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-    pub fn LLVMBuildStructGEP(B: BuilderRef,\n-                              Pointer: ValueRef,\n-                              Idx: c_uint,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildGlobalString(B: BuilderRef,\n-                                 Str: *const c_char,\n-                                 Name: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n-                                    Str: *const c_char,\n-                                    Name: *const c_char)\n-                                    -> ValueRef;\n-\n-    /* Casts */\n-    pub fn LLVMBuildTrunc(B: BuilderRef,\n-                          Val: ValueRef,\n-                          DestTy: TypeRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildZExt(B: BuilderRef,\n-                         Val: ValueRef,\n-                         DestTy: TypeRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSExt(B: BuilderRef,\n-                         Val: ValueRef,\n-                         DestTy: TypeRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFPToUI(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFPToSI(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildUIToFP(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildSIToFP(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFPTrunc(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-    pub fn LLVMBuildFPExt(B: BuilderRef,\n-                          Val: ValueRef,\n-                          DestTy: TypeRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildPtrToInt(B: BuilderRef,\n-                             Val: ValueRef,\n-                             DestTy: TypeRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildIntToPtr(B: BuilderRef,\n-                             Val: ValueRef,\n-                             DestTy: TypeRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildBitCast(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-    pub fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n-                                  Val: ValueRef,\n-                                  DestTy: TypeRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n-                                  Val: ValueRef,\n-                                  DestTy: TypeRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n-                                   Val: ValueRef,\n-                                   DestTy: TypeRef,\n-                                   Name: *const c_char)\n-                                   -> ValueRef;\n-    pub fn LLVMBuildCast(B: BuilderRef,\n-                         Op: Opcode,\n-                         Val: ValueRef,\n-                         DestTy: TypeRef,\n-                         Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildPointerCast(B: BuilderRef,\n-                                Val: ValueRef,\n-                                DestTy: TypeRef,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-    pub fn LLVMBuildIntCast(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-    pub fn LLVMBuildFPCast(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-\n-    /* Comparisons */\n-    pub fn LLVMBuildICmp(B: BuilderRef,\n-                         Op: c_uint,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFCmp(B: BuilderRef,\n-                         Op: c_uint,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-\n-    /* Miscellaneous instructions */\n-    pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMRustBuildCall(B: BuilderRef,\n-                             Fn: ValueRef,\n-                             Args: *const ValueRef,\n-                             NumArgs: c_uint,\n-                             Bundle: OperandBundleDefRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildSelect(B: BuilderRef,\n-                           If: ValueRef,\n-                           Then: ValueRef,\n-                           Else: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildVAArg(B: BuilderRef,\n-                          list: ValueRef,\n-                          Ty: TypeRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildExtractElement(B: BuilderRef,\n-                                   VecVal: ValueRef,\n-                                   Index: ValueRef,\n-                                   Name: *const c_char)\n-                                   -> ValueRef;\n-    pub fn LLVMBuildInsertElement(B: BuilderRef,\n-                                  VecVal: ValueRef,\n-                                  EltVal: ValueRef,\n-                                  Index: ValueRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildShuffleVector(B: BuilderRef,\n-                                  V1: ValueRef,\n-                                  V2: ValueRef,\n-                                  Mask: ValueRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildExtractValue(B: BuilderRef,\n-                                 AggVal: ValueRef,\n-                                 Index: c_uint,\n-                                 Name: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMBuildInsertValue(B: BuilderRef,\n-                                AggVal: ValueRef,\n-                                EltVal: ValueRef,\n-                                Index: c_uint,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-\n-    pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildPtrDiff(B: BuilderRef,\n-                            LHS: ValueRef,\n-                            RHS: ValueRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-\n-    /* Atomic Operations */\n-    pub fn LLVMBuildAtomicLoad(B: BuilderRef,\n-                               PointerVal: ValueRef,\n-                               Name: *const c_char,\n-                               Order: AtomicOrdering,\n-                               Alignment: c_uint)\n-                               -> ValueRef;\n-\n-    pub fn LLVMBuildAtomicStore(B: BuilderRef,\n-                                Val: ValueRef,\n-                                Ptr: ValueRef,\n-                                Order: AtomicOrdering,\n-                                Alignment: c_uint)\n-                                -> ValueRef;\n-\n-    pub fn LLVMBuildAtomicCmpXchg(B: BuilderRef,\n-                                  LHS: ValueRef,\n-                                  CMP: ValueRef,\n-                                  RHS: ValueRef,\n-                                  Order: AtomicOrdering,\n-                                  FailureOrder: AtomicOrdering,\n-                                  Weak: Bool)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildAtomicRMW(B: BuilderRef,\n-                              Op: AtomicBinOp,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n-                              Order: AtomicOrdering,\n-                              SingleThreaded: Bool)\n-                              -> ValueRef;\n-\n-    pub fn LLVMBuildAtomicFence(B: BuilderRef,\n-                                Order: AtomicOrdering,\n-                                Scope: SynchronizationScope);\n-\n-\n-    /* Selected entries from the downcasts. */\n-    pub fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n-\n-    /// Writes a module to the specified path. Returns 0 on success.\n-    pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n-\n-    /// Creates target data from a target layout string.\n-    pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n-    /// Adds the target data to the given pass manager. The pass manager\n-    /// references the target data only weakly.\n-    pub fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n-    /// Number of bytes clobbered when doing a Store to *T.\n-    pub fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n-                               -> c_ulonglong;\n-\n-    /// Number of bytes clobbered when doing a Store to *T.\n-    pub fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n-                                -> c_ulonglong;\n-\n-    /// Distance between successive elements in an array of T. Includes ABI padding.\n-    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n-\n-    /// Returns the preferred alignment of a type.\n-    pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                        -> c_uint;\n-    /// Returns the minimum alignment of a type.\n-    pub fn LLVMABIAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                  -> c_uint;\n-\n-    /// Computes the byte offset of the indexed struct element for a\n-    /// target.\n-    pub fn LLVMOffsetOfElement(TD: TargetDataRef,\n-                               StructTy: TypeRef,\n-                               Element: c_uint)\n-                               -> c_ulonglong;\n-\n-    /// Returns the minimum alignment of a type when part of a call frame.\n-    pub fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                        -> c_uint;\n-\n-    /// Disposes target data.\n-    pub fn LLVMDisposeTargetData(TD: TargetDataRef);\n-\n-    /// Creates a pass manager.\n-    pub fn LLVMCreatePassManager() -> PassManagerRef;\n-\n-    /// Creates a function-by-function pass manager\n-    pub fn LLVMCreateFunctionPassManagerForModule(M: ModuleRef)\n-                                                  -> PassManagerRef;\n-\n-    /// Disposes a pass manager.\n-    pub fn LLVMDisposePassManager(PM: PassManagerRef);\n-\n-    /// Runs a pass manager on a module.\n-    pub fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n-\n-    /// Runs the function passes on the provided function.\n-    pub fn LLVMRunFunctionPassManager(FPM: PassManagerRef, F: ValueRef)\n-                                      -> Bool;\n-\n-    /// Initializes all the function passes scheduled in the manager\n-    pub fn LLVMInitializeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n-\n-    /// Finalizes all the function passes scheduled in the manager\n-    pub fn LLVMFinalizeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n-\n-    pub fn LLVMInitializePasses();\n-\n-    /// Adds a verification pass.\n-    pub fn LLVMAddVerifierPass(PM: PassManagerRef);\n-\n-    pub fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n-    pub fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n-    pub fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n-    pub fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n-    pub fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n-    pub fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n-    pub fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n-    pub fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n-    pub fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n-    pub fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n-    pub fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n-    pub fn LLVMAddReassociatePass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n-    pub fn LLVMAddLICMPass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n-    pub fn LLVMAddGVNPass(PM: PassManagerRef);\n-    pub fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n-    pub fn LLVMAddSCCPPass(PM: PassManagerRef);\n-    pub fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n-    pub fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n-    pub fn LLVMAddConstantMergePass(PM: PassManagerRef);\n-    pub fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n-    pub fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n-    pub fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n-    pub fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n-    pub fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n-    pub fn LLVMAddCorrelatedValuePropagationPass(PM: PassManagerRef);\n-    pub fn LLVMAddPruneEHPass(PM: PassManagerRef);\n-    pub fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n-    pub fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n-    pub fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n-    pub fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n-    pub fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n-\n-    pub fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n-    pub fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n-    pub fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n-                                             OptimizationLevel: c_uint);\n-    pub fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n-                                              Value: Bool);\n-    pub fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n-        PMB: PassManagerBuilderRef,\n-        Value: Bool);\n-    pub fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n-        PMB: PassManagerBuilderRef,\n-        Value: Bool);\n-    pub fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls(\n-        PMB: PassManagerBuilderRef,\n-        Value: Bool);\n-    pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(\n-        PMB: PassManagerBuilderRef,\n-        threshold: c_uint);\n-    pub fn LLVMPassManagerBuilderPopulateModulePassManager(\n-        PMB: PassManagerBuilderRef,\n-        PM: PassManagerRef);\n-\n-    pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n-        PMB: PassManagerBuilderRef,\n-        PM: PassManagerRef);\n-    pub fn LLVMPassManagerBuilderPopulateLTOPassManager(\n-        PMB: PassManagerBuilderRef,\n-        PM: PassManagerRef,\n-        Internalize: Bool,\n-        RunInliner: Bool);\n-\n-    /// Destroys a memory buffer.\n-    pub fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n-\n-\n-    /* Stuff that's in rustllvm/ because it's not upstream yet. */\n-\n-    /// Opens an object file.\n-    pub fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n-    /// Closes an object file.\n-    pub fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n-\n-    /// Enumerates the sections in an object file.\n-    pub fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n-    /// Destroys a section iterator.\n-    pub fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n-    /// Returns true if the section iterator is at the end of the section\n-    /// list:\n-    pub fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n-                                      SI: SectionIteratorRef)\n-                                      -> Bool;\n-    /// Moves the section iterator to point to the next section.\n-    pub fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n-    /// Returns the current section size.\n-    pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n-    /// Returns the current section contents as a string buffer.\n-    pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *const c_char;\n-\n-    /// Reads the given file and returns it as a memory buffer. Use\n-    /// LLVMDisposeMemoryBuffer() to get rid of it.\n-    pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *const c_char)\n-                                                        -> MemoryBufferRef;\n-    /// Borrows the contents of the memory buffer (doesn't copy it)\n-    pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *const c_char,\n-                                                 InputDataLength: size_t,\n-                                                 BufferName: *const c_char,\n-                                                 RequiresNull: Bool)\n-                                                 -> MemoryBufferRef;\n-    pub fn LLVMCreateMemoryBufferWithMemoryRangeCopy(InputData: *const c_char,\n-                                                     InputDataLength: size_t,\n-                                                     BufferName: *const c_char)\n-                                                     -> MemoryBufferRef;\n-\n-    pub fn LLVMIsMultithreaded() -> Bool;\n-    pub fn LLVMStartMultithreaded() -> Bool;\n-\n-    /// Returns a string describing the last error caused by an LLVMRust* call.\n-    pub fn LLVMRustGetLastError() -> *const c_char;\n-\n-    /// Print the pass timings since static dtors aren't picking them up.\n-    pub fn LLVMRustPrintPassTimings();\n-\n-    pub fn LLVMStructCreateNamed(C: ContextRef, Name: *const c_char) -> TypeRef;\n-\n-    pub fn LLVMStructSetBody(StructTy: TypeRef,\n-                             ElementTypes: *const TypeRef,\n-                             ElementCount: c_uint,\n-                             Packed: Bool);\n-\n-    pub fn LLVMConstNamedStruct(S: TypeRef,\n-                                ConstantVals: *const ValueRef,\n-                                Count: c_uint)\n-                                -> ValueRef;\n-\n-    /// Enables LLVM debug output.\n-    pub fn LLVMSetDebug(Enabled: c_int);\n-\n-    /// Prepares inline assembly.\n-    pub fn LLVMInlineAsm(Ty: TypeRef,\n-                         AsmString: *const c_char,\n-                         Constraints: *const c_char,\n-                         SideEffects: Bool,\n-                         AlignStack: Bool,\n-                         Dialect: c_uint)\n-                         -> ValueRef;\n-\n-    pub fn LLVMRustDebugMetadataVersion() -> u32;\n-    pub fn LLVMVersionMajor() -> u32;\n-    pub fn LLVMVersionMinor() -> u32;\n-\n-    pub fn LLVMRustAddModuleFlag(M: ModuleRef,\n-                                 name: *const c_char,\n-                                 value: u32);\n-\n-    pub fn LLVMDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n-\n-    pub fn LLVMDIBuilderDispose(Builder: DIBuilderRef);\n-\n-    pub fn LLVMDIBuilderFinalize(Builder: DIBuilderRef);\n-\n-    pub fn LLVMDIBuilderCreateCompileUnit(Builder: DIBuilderRef,\n-                                          Lang: c_uint,\n-                                          File: *const c_char,\n-                                          Dir: *const c_char,\n-                                          Producer: *const c_char,\n-                                          isOptimized: bool,\n-                                          Flags: *const c_char,\n-                                          RuntimeVer: c_uint,\n-                                          SplitName: *const c_char)\n-                                          -> DIDescriptor;\n-\n-    pub fn LLVMDIBuilderCreateFile(Builder: DIBuilderRef,\n-                                   Filename: *const c_char,\n-                                   Directory: *const c_char)\n-                                   -> DIFile;\n-\n-    pub fn LLVMDIBuilderCreateSubroutineType(Builder: DIBuilderRef,\n-                                             File: DIFile,\n-                                             ParameterTypes: DIArray)\n-                                             -> DICompositeType;\n-\n-    pub fn LLVMDIBuilderCreateFunction(Builder: DIBuilderRef,\n-                                       Scope: DIDescriptor,\n-                                       Name: *const c_char,\n-                                       LinkageName: *const c_char,\n-                                       File: DIFile,\n-                                       LineNo: c_uint,\n-                                       Ty: DIType,\n-                                       isLocalToUnit: bool,\n-                                       isDefinition: bool,\n-                                       ScopeLine: c_uint,\n-                                       Flags: c_uint,\n-                                       isOptimized: bool,\n-                                       Fn: ValueRef,\n-                                       TParam: DIArray,\n-                                       Decl: DIDescriptor)\n-                                       -> DISubprogram;\n-\n-    pub fn LLVMDIBuilderCreateBasicType(Builder: DIBuilderRef,\n-                                        Name: *const c_char,\n-                                        SizeInBits: c_ulonglong,\n-                                        AlignInBits: c_ulonglong,\n-                                        Encoding: c_uint)\n-                                        -> DIBasicType;\n-\n-    pub fn LLVMDIBuilderCreatePointerType(Builder: DIBuilderRef,\n-                                          PointeeTy: DIType,\n-                                          SizeInBits: c_ulonglong,\n-                                          AlignInBits: c_ulonglong,\n-                                          Name: *const c_char)\n-                                          -> DIDerivedType;\n-\n-    pub fn LLVMDIBuilderCreateStructType(Builder: DIBuilderRef,\n-                                         Scope: DIDescriptor,\n-                                         Name: *const c_char,\n-                                         File: DIFile,\n-                                         LineNumber: c_uint,\n-                                         SizeInBits: c_ulonglong,\n-                                         AlignInBits: c_ulonglong,\n-                                         Flags: c_uint,\n-                                         DerivedFrom: DIType,\n-                                         Elements: DIArray,\n-                                         RunTimeLang: c_uint,\n-                                         VTableHolder: DIType,\n-                                         UniqueId: *const c_char)\n-                                         -> DICompositeType;\n-\n-    pub fn LLVMDIBuilderCreateMemberType(Builder: DIBuilderRef,\n-                                         Scope: DIDescriptor,\n-                                         Name: *const c_char,\n-                                         File: DIFile,\n-                                         LineNo: c_uint,\n-                                         SizeInBits: c_ulonglong,\n-                                         AlignInBits: c_ulonglong,\n-                                         OffsetInBits: c_ulonglong,\n-                                         Flags: c_uint,\n-                                         Ty: DIType)\n-                                         -> DIDerivedType;\n-\n-    pub fn LLVMDIBuilderCreateLexicalBlock(Builder: DIBuilderRef,\n-                                           Scope: DIScope,\n-                                           File: DIFile,\n-                                           Line: c_uint,\n-                                           Col: c_uint)\n-                                           -> DILexicalBlock;\n-\n-    pub fn LLVMDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n-                                             Context: DIScope,\n-                                             Name: *const c_char,\n-                                             LinkageName: *const c_char,\n-                                             File: DIFile,\n-                                             LineNo: c_uint,\n-                                             Ty: DIType,\n-                                             isLocalToUnit: bool,\n-                                             Val: ValueRef,\n-                                             Decl: DIDescriptor)\n-                                             -> DIGlobalVariable;\n-\n-    pub fn LLVMDIBuilderCreateVariable(Builder: DIBuilderRef,\n-                                            Tag: c_uint,\n-                                            Scope: DIDescriptor,\n-                                            Name: *const c_char,\n-                                            File: DIFile,\n-                                            LineNo: c_uint,\n-                                            Ty: DIType,\n-                                            AlwaysPreserve: bool,\n-                                            Flags: c_uint,\n-                                            AddrOps: *const i64,\n-                                            AddrOpsCount: c_uint,\n-                                            ArgNo: c_uint)\n-                                            -> DIVariable;\n-\n-    pub fn LLVMDIBuilderCreateArrayType(Builder: DIBuilderRef,\n-                                        Size: c_ulonglong,\n-                                        AlignInBits: c_ulonglong,\n-                                        Ty: DIType,\n-                                        Subscripts: DIArray)\n-                                        -> DIType;\n-\n-    pub fn LLVMDIBuilderCreateVectorType(Builder: DIBuilderRef,\n-                                         Size: c_ulonglong,\n-                                         AlignInBits: c_ulonglong,\n-                                         Ty: DIType,\n-                                         Subscripts: DIArray)\n-                                         -> DIType;\n-\n-    pub fn LLVMDIBuilderGetOrCreateSubrange(Builder: DIBuilderRef,\n-                                            Lo: c_longlong,\n-                                            Count: c_longlong)\n-                                            -> DISubrange;\n-\n-    pub fn LLVMDIBuilderGetOrCreateArray(Builder: DIBuilderRef,\n-                                         Ptr: *const DIDescriptor,\n-                                         Count: c_uint)\n-                                         -> DIArray;\n-\n-    pub fn LLVMDIBuilderInsertDeclareAtEnd(Builder: DIBuilderRef,\n-                                           Val: ValueRef,\n-                                           VarInfo: DIVariable,\n-                                           AddrOps: *const i64,\n-                                           AddrOpsCount: c_uint,\n-                                           DL: ValueRef,\n-                                           InsertAtEnd: BasicBlockRef)\n-                                           -> ValueRef;\n-\n-    pub fn LLVMDIBuilderInsertDeclareBefore(Builder: DIBuilderRef,\n-                                            Val: ValueRef,\n-                                            VarInfo: DIVariable,\n-                                            AddrOps: *const i64,\n-                                            AddrOpsCount: c_uint,\n-                                            DL: ValueRef,\n-                                            InsertBefore: ValueRef)\n-                                            -> ValueRef;\n-\n-    pub fn LLVMDIBuilderCreateEnumerator(Builder: DIBuilderRef,\n-                                         Name: *const c_char,\n-                                         Val: c_ulonglong)\n-                                         -> DIEnumerator;\n-\n-    pub fn LLVMDIBuilderCreateEnumerationType(Builder: DIBuilderRef,\n-                                              Scope: DIScope,\n-                                              Name: *const c_char,\n-                                              File: DIFile,\n-                                              LineNumber: c_uint,\n-                                              SizeInBits: c_ulonglong,\n-                                              AlignInBits: c_ulonglong,\n-                                              Elements: DIArray,\n-                                              ClassType: DIType)\n-                                              -> DIType;\n-\n-    pub fn LLVMDIBuilderCreateUnionType(Builder: DIBuilderRef,\n-                                        Scope: DIScope,\n-                                        Name: *const c_char,\n-                                        File: DIFile,\n-                                        LineNumber: c_uint,\n-                                        SizeInBits: c_ulonglong,\n-                                        AlignInBits: c_ulonglong,\n-                                        Flags: c_uint,\n-                                        Elements: DIArray,\n-                                        RunTimeLang: c_uint,\n-                                        UniqueId: *const c_char)\n-                                        -> DIType;\n-\n-    pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n-\n-    pub fn LLVMDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n-                                                    Scope: DIScope,\n-                                                    Name: *const c_char,\n-                                                    Ty: DIType,\n-                                                    File: DIFile,\n-                                                    LineNo: c_uint,\n-                                                    ColumnNo: c_uint)\n-                                                    -> DITemplateTypeParameter;\n-\n-    pub fn LLVMDIBuilderCreateOpDeref() -> i64;\n-\n-    pub fn LLVMDIBuilderCreateOpPlus() -> i64;\n-\n-    pub fn LLVMDIBuilderCreateNameSpace(Builder: DIBuilderRef,\n-                                        Scope: DIScope,\n-                                        Name: *const c_char,\n-                                        File: DIFile,\n-                                        LineNo: c_uint)\n-                                        -> DINameSpace;\n-\n-    pub fn LLVMDIBuilderCreateDebugLocation(Context: ContextRef,\n-                                            Line: c_uint,\n-                                            Column: c_uint,\n-                                            Scope: DIScope,\n-                                            InlinedAt: MetadataRef)\n-                                            -> ValueRef;\n-\n-    pub fn LLVMDICompositeTypeSetTypeArray(Builder: DIBuilderRef,\n-                                           CompositeType: DIType,\n-                                           TypeArray: DIArray);\n-    pub fn LLVMWriteTypeToString(Type: TypeRef, s: RustStringRef);\n-    pub fn LLVMWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n-\n-    pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n-\n-    pub fn LLVMIsAAllocaInst(value_ref: ValueRef) -> ValueRef;\n-    pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n-\n-    pub fn LLVMRustPassKind(Pass: PassRef) -> SupportedPassKind;\n-    pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> PassRef;\n-    pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: PassRef);\n-\n-    pub fn LLVMRustHasFeature(T: TargetMachineRef,\n-                              s: *const c_char) -> bool;\n-\n-    pub fn LLVMRustPrintTargetCPUs(T: TargetMachineRef);\n-    pub fn LLVMRustPrintTargetFeatures(T: TargetMachineRef);\n-\n-    pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n-                                       CPU: *const c_char,\n-                                       Features: *const c_char,\n-                                       Model: CodeGenModel,\n-                                       Reloc: RelocMode,\n-                                       Level: CodeGenOptLevel,\n-                                       UseSoftFP: bool,\n-                                       PositionIndependentExecutable: bool,\n-                                       FunctionSections: bool,\n-                                       DataSections: bool) -> TargetMachineRef;\n-    pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n-    pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef,\n-                                     PM: PassManagerRef,\n-                                     M: ModuleRef);\n-    pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n-                                         M: ModuleRef,\n-                                         DisableSimplifyLibCalls: bool);\n-    pub fn LLVMRustConfigurePassManagerBuilder(PMB: PassManagerBuilderRef,\n-                                               OptLevel: CodeGenOptLevel,\n-                                               MergeFunctions: bool,\n-                                               SLPVectorize: bool,\n-                                               LoopVectorize: bool);\n-    pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef, M: ModuleRef,\n-                                  DisableSimplifyLibCalls: bool);\n-    pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n-    pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n-                                   PM: PassManagerRef,\n-                                   M: ModuleRef,\n-                                   Output: *const c_char,\n-                                   FileType: FileType) -> bool;\n-    pub fn LLVMRustPrintModule(PM: PassManagerRef,\n-                               M: ModuleRef,\n-                               Output: *const c_char);\n-    pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n-    pub fn LLVMRustPrintPasses();\n-    pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n-    pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n-                                       AddLifetimes: bool);\n-    pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef,\n-                                         bc: *const c_char,\n-                                         len: size_t) -> bool;\n-    pub fn LLVMRustRunRestrictionPass(M: ModuleRef,\n-                                      syms: *const *const c_char,\n-                                      len: size_t);\n-    pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n-\n-    pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n-    pub fn LLVMRustArchiveIteratorNew(AR: ArchiveRef) -> ArchiveIteratorRef;\n-    pub fn LLVMRustArchiveIteratorNext(AIR: ArchiveIteratorRef) -> ArchiveChildRef;\n-    pub fn LLVMRustArchiveChildName(ACR: ArchiveChildRef,\n-                                    size: *mut size_t) -> *const c_char;\n-    pub fn LLVMRustArchiveChildData(ACR: ArchiveChildRef,\n-                                    size: *mut size_t) -> *const c_char;\n-    pub fn LLVMRustArchiveChildFree(ACR: ArchiveChildRef);\n-    pub fn LLVMRustArchiveIteratorFree(AIR: ArchiveIteratorRef);\n-    pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n-\n-    pub fn LLVMRustSetDLLStorageClass(V: ValueRef,\n-                                      C: DLLStorageClassTypes);\n-\n-    pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n-                                  data: *mut *const c_char) -> c_int;\n-\n-    pub fn LLVMWriteTwineToString(T: TwineRef, s: RustStringRef);\n-\n-    pub fn LLVMContextSetDiagnosticHandler(C: ContextRef,\n-                                           Handler: DiagnosticHandler,\n-                                           DiagnosticContext: *mut c_void);\n-\n-    pub fn LLVMUnpackOptimizationDiagnostic(DI: DiagnosticInfoRef,\n-                                            pass_name_out: *mut *const c_char,\n-                                            function_out: *mut ValueRef,\n-                                            debugloc_out: *mut DebugLocRef,\n-                                            message_out: *mut TwineRef);\n-    pub fn LLVMUnpackInlineAsmDiagnostic(DI: DiagnosticInfoRef,\n-                                            cookie_out: *mut c_uint,\n-                                            message_out: *mut TwineRef,\n-                                            instruction_out: *mut ValueRef);\n-\n-    pub fn LLVMWriteDiagnosticInfoToString(DI: DiagnosticInfoRef, s: RustStringRef);\n-    pub fn LLVMGetDiagInfoSeverity(DI: DiagnosticInfoRef) -> DiagnosticSeverity;\n-    pub fn LLVMGetDiagInfoKind(DI: DiagnosticInfoRef) -> DiagnosticKind;\n-\n-    pub fn LLVMWriteDebugLocToString(C: ContextRef, DL: DebugLocRef, s: RustStringRef);\n-\n-    pub fn LLVMSetInlineAsmDiagnosticHandler(C: ContextRef,\n-                                             H: InlineAsmDiagHandler,\n-                                             CX: *mut c_void);\n-\n-    pub fn LLVMWriteSMDiagnosticToString(d: SMDiagnosticRef, s: RustStringRef);\n-\n-    pub fn LLVMRustWriteArchive(Dst: *const c_char,\n-                                NumMembers: size_t,\n-                                Members: *const RustArchiveMemberRef,\n-                                WriteSymbtab: bool,\n-                                Kind: ArchiveKind) -> c_int;\n-    pub fn LLVMRustArchiveMemberNew(Filename: *const c_char,\n-                                    Name: *const c_char,\n-                                    Child: ArchiveChildRef) -> RustArchiveMemberRef;\n-    pub fn LLVMRustArchiveMemberFree(Member: RustArchiveMemberRef);\n-\n-    pub fn LLVMRustSetDataLayoutFromTargetMachine(M: ModuleRef,\n-                                                  TM: TargetMachineRef);\n-    pub fn LLVMRustGetModuleDataLayout(M: ModuleRef) -> TargetDataRef;\n-\n-    pub fn LLVMRustBuildOperandBundleDef(Name: *const c_char,\n-                                         Inputs: *const ValueRef,\n-                                         NumInputs: c_uint)\n-                                         -> OperandBundleDefRef;\n-    pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n+pub enum RustString_opaque {}\n+pub type RustStringRef = *mut RustString_opaque;\n+type RustStringRepr = *mut RefCell<Vec<u8>>;\n \n-    pub fn LLVMRustPositionBuilderAtStart(B: BuilderRef, BB: BasicBlockRef);\n+/// Appending to a Rust string -- used by raw_rust_string_ostream.\n+#[no_mangle]\n+pub unsafe extern \"C\" fn rust_llvm_string_write_impl(sr: RustStringRef,\n+                                                     ptr: *const c_char,\n+                                                     size: size_t) {\n+    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n \n-    pub fn LLVMRustSetComdat(M: ModuleRef, V: ValueRef, Name: *const c_char);\n-    pub fn LLVMRustUnsetComdat(V: ValueRef);\n+    let sr = sr as RustStringRepr;\n+    (*sr).borrow_mut().extend_from_slice(slice);\n }\n \n-// LLVM requires symbols from this library, but apparently they're not printed\n-// during llvm-config?\n-#[cfg(windows)]\n-#[link(name = \"ole32\")]\n-extern {}\n-\n pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n     unsafe {\n         LLVMSetInstructionCallConv(instr, cc as c_uint);\n@@ -2176,11 +200,6 @@ pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n         LLVMSetFunctionCallConv(fn_, cc as c_uint);\n     }\n }\n-pub fn SetLinkage(global: ValueRef, link: Linkage) {\n-    unsafe {\n-        LLVMSetLinkage(global, link as c_uint);\n-    }\n-}\n \n // Externally visible symbols that might appear in multiple translation units need to appear in\n // their own comdat section so that the duplicates can be discarded at link time. This can for\n@@ -2200,12 +219,6 @@ pub fn UnsetComdat(val: ValueRef) {\n     }\n }\n \n-pub fn SetDLLStorageClass(global: ValueRef, class: DLLStorageClassTypes) {\n-    unsafe {\n-        LLVMRustSetDLLStorageClass(global, class);\n-    }\n-}\n-\n pub fn SetUnnamedAddr(global: ValueRef, unnamed: bool) {\n     unsafe {\n         LLVMSetUnnamedAddr(global, unnamed as Bool);\n@@ -2218,29 +231,40 @@ pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n     }\n }\n \n-pub fn ConstICmp(pred: IntPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n-    unsafe {\n-        LLVMConstICmp(pred as c_ushort, v1, v2)\n+impl Attribute {\n+    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+        unsafe {\n+            LLVMRustAddFunctionAttribute(\n+                llfn, idx.as_uint(), self.bits())\n+        }\n     }\n-}\n-pub fn ConstFCmp(pred: RealPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n-    unsafe {\n-        LLVMConstFCmp(pred as c_ushort, v1, v2)\n+\n+    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n+        unsafe {\n+            LLVMRustAddCallSiteAttribute(\n+                callsite, idx.as_uint(), self.bits())\n+        }\n     }\n-}\n \n-pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n-    unsafe {\n-        LLVMAddFunctionAttribute(fn_, FunctionIndex as c_uint,\n-                                 attr.bits() as uint64_t)\n+    pub fn unapply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+        unsafe {\n+            LLVMRustRemoveFunctionAttributes(\n+                llfn, idx.as_uint(), self.bits())\n+        }\n     }\n-}\n \n-pub fn RemoveFunctionAttributes(fn_: ValueRef, attr: Attribute) {\n-    unsafe {\n-        LLVMRemoveFunctionAttributes(fn_, FunctionIndex as c_uint,\n-                                           attr.bits() as uint64_t)\n+    pub fn toggle_llfn(&self,\n+                       idx: AttributePlace,\n+                       llfn: ValueRef,\n+                       set: bool)\n+    {\n+        if set {\n+            self.apply_llfn(idx, llfn);\n+        } else {\n+            self.unapply_llfn(idx, llfn);\n+        }\n     }\n+\n }\n \n /* Memory-managed interface to target data. */\n@@ -2337,35 +361,19 @@ pub fn get_params(llfn: ValueRef) -> Vec<ValueRef> {\n     }\n }\n \n-#[allow(missing_copy_implementations)]\n-pub enum RustString_opaque {}\n-pub type RustStringRef = *mut RustString_opaque;\n-type RustStringRepr = *mut RefCell<Vec<u8>>;\n-\n-/// Appending to a Rust string -- used by raw_rust_string_ostream.\n-#[no_mangle]\n-pub unsafe extern \"C\" fn rust_llvm_string_write_impl(sr: RustStringRef,\n-                                                     ptr: *const c_char,\n-                                                     size: size_t) {\n-    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n-\n-    let sr = sr as RustStringRepr;\n-    (*sr).borrow_mut().extend_from_slice(slice);\n-}\n-\n pub fn build_string<F>(f: F) -> Option<String> where F: FnOnce(RustStringRef){\n     let mut buf = RefCell::new(Vec::new());\n     f(&mut buf as RustStringRepr as RustStringRef);\n     String::from_utf8(buf.into_inner()).ok()\n }\n \n pub unsafe fn twine_to_string(tr: TwineRef) -> String {\n-    build_string(|s| LLVMWriteTwineToString(tr, s))\n+    build_string(|s| LLVMRustWriteTwineToString(tr, s))\n         .expect(\"got a non-UTF8 Twine from LLVM\")\n }\n \n pub unsafe fn debug_loc_to_string(c: ContextRef, tr: DebugLocRef) -> String {\n-    build_string(|s| LLVMWriteDebugLocToString(c, tr, s))\n+    build_string(|s| LLVMRustWriteDebugLocToString(c, tr, s))\n         .expect(\"got a non-UTF8 DebugLoc from LLVM\")\n }\n "}, {"sha": "c39ad414492ed637fd0faa29134e7e504ccea3d7", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -18,7 +18,7 @@ use rustc::session::Session;\n use rustc::hir;\n use rustc::hir::fold;\n use rustc::hir::fold::Folder;\n-use rustc::hir::intravisit::{IdRange, IdRangeComputingVisitor, IdVisitingOperation};\n+use rustc::hir::intravisit::{Visitor, IdRangeComputingVisitor, IdRange};\n \n use common as c;\n use cstore;\n@@ -88,8 +88,9 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n            rbml_w.writer.seek(SeekFrom::Current(0)));\n \n     // Folding could be avoided with a smarter encoder.\n-    let ii = simplify_ast(ii);\n+    let (ii, expected_id_range) = simplify_ast(ii);\n     let id_range = inlined_item_id_range(&ii);\n+    assert_eq!(expected_id_range, id_range);\n \n     rbml_w.start_tag(c::tag_ast as usize);\n     id_range.encode(rbml_w);\n@@ -186,6 +187,10 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n         // from_id_range should be non-empty\n         assert!(!self.from_id_range.empty());\n+        // Make sure that translating the NodeId will actually yield a\n+        // meaningful result\n+        assert!(self.from_id_range.contains(id));\n+\n         // Use wrapping arithmetic because otherwise it introduces control flow.\n         // Maybe we should just have the control flow? -- aatch\n         (id.wrapping_sub(self.from_id_range.min).wrapping_add(self.to_id_range.min))\n@@ -279,9 +284,23 @@ fn encode_ast(rbml_w: &mut Encoder, item: &InlinedItem) {\n     rbml_w.end_tag();\n }\n \n-struct NestedItemsDropper;\n+struct NestedItemsDropper {\n+    id_range: IdRange\n+}\n \n impl Folder for NestedItemsDropper {\n+\n+    // The unit tests below run on HIR with NodeIds not properly assigned. That\n+    // causes an integer overflow. So we just don't track the id_range when\n+    // building the unit tests.\n+    #[cfg(not(test))]\n+    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n+        // Record the range of NodeIds we are visiting, so we can do a sanity\n+        // check later\n+        self.id_range.add(id);\n+        id\n+    }\n+\n     fn fold_block(&mut self, blk: P<hir::Block>) -> P<hir::Block> {\n         blk.and_then(|hir::Block {id, stmts, expr, rules, span, ..}| {\n             let stmts_sans_items = stmts.into_iter().filter_map(|stmt| {\n@@ -322,10 +341,12 @@ impl Folder for NestedItemsDropper {\n // As it happens, trans relies on the fact that we do not export\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n-fn simplify_ast(ii: InlinedItemRef) -> InlinedItem {\n-    let mut fld = NestedItemsDropper;\n+fn simplify_ast(ii: InlinedItemRef) -> (InlinedItem, IdRange) {\n+    let mut fld = NestedItemsDropper {\n+        id_range: IdRange::max()\n+    };\n \n-    match ii {\n+    let ii = match ii {\n         // HACK we're not dropping items.\n         InlinedItemRef::Item(i) => {\n             InlinedItem::Item(P(fold::noop_fold_item(i.clone(), &mut fld)))\n@@ -339,7 +360,9 @@ fn simplify_ast(ii: InlinedItemRef) -> InlinedItem {\n         InlinedItemRef::Foreign(i) => {\n             InlinedItem::Foreign(P(fold::noop_fold_foreign_item(i.clone(), &mut fld)))\n         }\n-    }\n+    };\n+\n+    (ii, fld.id_range)\n }\n \n fn decode_ast(item_doc: rbml::Doc) -> InlinedItem {\n@@ -361,8 +384,18 @@ impl tr for Def {\n         match *self {\n           Def::Fn(did) => Def::Fn(did.tr(dcx)),\n           Def::Method(did) => Def::Method(did.tr(dcx)),\n-          Def::SelfTy(opt_did, impl_id) => { Def::SelfTy(opt_did.map(|did| did.tr(dcx)),\n-                                                         impl_id.map(|id| dcx.tr_id(id))) }\n+          Def::SelfTy(opt_did, impl_id) => {\n+              // Since the impl_id will never lie within the reserved range of\n+              // imported NodeIds, it does not make sense to translate it.\n+              // The result would not make any sense within the importing crate.\n+              // We also don't allow for impl items to be inlined (just their\n+              // members), so even if we had a DefId here, we wouldn't be able\n+              // to do much with it.\n+              // So, we set the id to DUMMY_NODE_ID. That way we make it\n+              // explicit that this is no usable NodeId.\n+              Def::SelfTy(opt_did.map(|did| did.tr(dcx)),\n+                          impl_id.map(|_| ast::DUMMY_NODE_ID))\n+          }\n           Def::Mod(did) => { Def::Mod(did.tr(dcx)) }\n           Def::ForeignMod(did) => { Def::ForeignMod(did.tr(dcx)) }\n           Def::Static(did, m) => { Def::Static(did.tr(dcx), m) }\n@@ -693,7 +726,7 @@ struct SideTableEncodingIdVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n     rbml_w: &'a mut Encoder<'b>,\n }\n \n-impl<'a, 'b, 'c, 'tcx> IdVisitingOperation for\n+impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for\n         SideTableEncodingIdVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_id(&mut self, id: ast::NodeId) {\n         encode_side_tables_for_id(self.ecx, self.rbml_w, id)\n@@ -704,7 +737,7 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              rbml_w: &mut Encoder,\n                              ii: &InlinedItem) {\n     rbml_w.start_tag(c::tag_table as usize);\n-    ii.visit_ids(&mut SideTableEncodingIdVisitor {\n+    ii.visit(&mut SideTableEncodingIdVisitor {\n         ecx: ecx,\n         rbml_w: rbml_w\n     });\n@@ -1242,9 +1275,9 @@ fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n     }\n }\n \n-fn inlined_item_id_range(v: &InlinedItem) -> IdRange {\n+fn inlined_item_id_range(ii: &InlinedItem) -> IdRange {\n     let mut visitor = IdRangeComputingVisitor::new();\n-    v.visit_ids(&mut visitor);\n+    ii.visit(&mut visitor);\n     visitor.result()\n }\n \n@@ -1361,7 +1394,7 @@ fn test_simplification() {\n     with_testing_context(|lcx| {\n         let hir_item = lcx.lower_item(&item);\n         let item_in = InlinedItemRef::Item(&hir_item);\n-        let item_out = simplify_ast(item_in);\n+        let (item_out, _) = simplify_ast(item_in);\n         let item_exp = InlinedItem::Item(P(lcx.lower_item(&quote_item!(&cx,\n             fn new_int_alist<B>() -> alist<isize, B> {\n                 return alist {eq_fn: eq_int, data: Vec::new()};"}, {"sha": "0b60fc386a7bbd8a84d2392fadc448499ae00851", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -243,7 +243,7 @@ impl<'a> CrateReader<'a> {\n \n         // Check for (potential) conflicts with the local crate\n         if self.local_crate_name == crate_name &&\n-           self.sess.crate_disambiguator.get().as_str() == disambiguator {\n+           self.sess.local_crate_disambiguator() == disambiguator {\n             span_fatal!(self.sess, span, E0519,\n                         \"the current crate is indistinguishable from one of its \\\n                          dependencies: it has the same crate-name `{}` and was \\"}, {"sha": "862245b9b78694bcb22cba1271a98ced9ba0c0e2", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 141, "deletions": 6, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -14,7 +14,7 @@ use decoder;\n use encoder;\n use loader;\n \n-use middle::cstore::{CrateStore, CrateSource, ChildItem, ExternCrate, FoundAst, DefLike};\n+use middle::cstore::{InlinedItem, CrateStore, CrateSource, ChildItem, ExternCrate, DefLike};\n use middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n use rustc::hir::def;\n use middle::lang_items;\n@@ -482,12 +482,146 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> FoundAst<'tcx>\n+    fn maybe_get_item_ast<'a>(&'tcx self,\n+                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              def_id: DefId)\n+                              -> Option<(&'tcx InlinedItem, ast::NodeId)>\n     {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::maybe_get_item_ast(&cdata, tcx, def.index)\n+        self.dep_graph.read(DepNode::MetaData(def_id));\n+\n+        match self.inlined_item_cache.borrow().get(&def_id) {\n+            Some(&None) => {\n+                return None; // Not inlinable\n+            }\n+            Some(&Some(ref cached_inlined_item)) => {\n+                // Already inline\n+                debug!(\"maybe_get_item_ast({}): already inline as node id {}\",\n+                          tcx.item_path_str(def_id), cached_inlined_item.item_id);\n+                return Some((tcx.map.expect_inlined_item(cached_inlined_item.inlined_root),\n+                             cached_inlined_item.item_id));\n+            }\n+            None => {\n+                // Not seen yet\n+            }\n+        }\n+\n+        debug!(\"maybe_get_item_ast({}): inlining item\", tcx.item_path_str(def_id));\n+\n+        let cdata = self.get_crate_data(def_id.krate);\n+        let inlined = decoder::maybe_get_item_ast(&cdata, tcx, def_id.index);\n+\n+        let cache_inlined_item = |original_def_id, inlined_item_id, inlined_root_node_id| {\n+            let cache_entry = cstore::CachedInlinedItem {\n+                inlined_root: inlined_root_node_id,\n+                item_id: inlined_item_id,\n+            };\n+            self.inlined_item_cache\n+                .borrow_mut()\n+                .insert(original_def_id, Some(cache_entry));\n+            self.defid_for_inlined_node\n+                .borrow_mut()\n+                .insert(inlined_item_id, original_def_id);\n+        };\n+\n+        let find_inlined_item_root = |inlined_item_id| {\n+            let mut node = inlined_item_id;\n+            let mut path = Vec::with_capacity(10);\n+\n+            // If we can't find the inline root after a thousand hops, we can\n+            // be pretty sure there's something wrong with the HIR map.\n+            for _ in 0 .. 1000 {\n+                path.push(node);\n+                let parent_node = tcx.map.get_parent_node(node);\n+                if parent_node == node {\n+                    return node;\n+                }\n+                node = parent_node;\n+            }\n+            bug!(\"cycle in HIR map parent chain\")\n+        };\n+\n+        match inlined {\n+            decoder::FoundAst::NotFound => {\n+                self.inlined_item_cache\n+                    .borrow_mut()\n+                    .insert(def_id, None);\n+            }\n+            decoder::FoundAst::Found(&InlinedItem::Item(ref item)) => {\n+                let inlined_root_node_id = find_inlined_item_root(item.id);\n+                cache_inlined_item(def_id, item.id, inlined_root_node_id);\n+            }\n+            decoder::FoundAst::Found(&InlinedItem::Foreign(ref item)) => {\n+                let inlined_root_node_id = find_inlined_item_root(item.id);\n+                cache_inlined_item(def_id, item.id, inlined_root_node_id);\n+            }\n+            decoder::FoundAst::FoundParent(parent_did, item) => {\n+                let inlined_root_node_id = find_inlined_item_root(item.id);\n+                cache_inlined_item(parent_did, item.id, inlined_root_node_id);\n+\n+                match item.node {\n+                    hir::ItemEnum(ref ast_def, _) => {\n+                        let ast_vs = &ast_def.variants;\n+                        let ty_vs = &tcx.lookup_adt_def(parent_did).variants;\n+                        assert_eq!(ast_vs.len(), ty_vs.len());\n+                        for (ast_v, ty_v) in ast_vs.iter().zip(ty_vs.iter()) {\n+                            cache_inlined_item(ty_v.did,\n+                                               ast_v.node.data.id(),\n+                                               inlined_root_node_id);\n+                        }\n+                    }\n+                    hir::ItemStruct(ref struct_def, _) => {\n+                        if struct_def.is_struct() {\n+                            bug!(\"instantiate_inline: called on a non-tuple struct\")\n+                        } else {\n+                            cache_inlined_item(def_id,\n+                                               struct_def.id(),\n+                                               inlined_root_node_id);\n+                        }\n+                    }\n+                    _ => bug!(\"instantiate_inline: item has a \\\n+                               non-enum, non-struct parent\")\n+                }\n+            }\n+            decoder::FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n+                let inlined_root_node_id = find_inlined_item_root(trait_item.id);\n+                cache_inlined_item(def_id, trait_item.id, inlined_root_node_id);\n+\n+                // Associated consts already have to be evaluated in `typeck`, so\n+                // the logic to do that already exists in `middle`. In order to\n+                // reuse that code, it needs to be able to look up the traits for\n+                // inlined items.\n+                let ty_trait_item = tcx.impl_or_trait_item(def_id).clone();\n+                let trait_item_def_id = tcx.map.local_def_id(trait_item.id);\n+                tcx.impl_or_trait_items.borrow_mut()\n+                   .insert(trait_item_def_id, ty_trait_item);\n+            }\n+            decoder::FoundAst::Found(&InlinedItem::ImplItem(_, ref impl_item)) => {\n+                let inlined_root_node_id = find_inlined_item_root(impl_item.id);\n+                cache_inlined_item(def_id, impl_item.id, inlined_root_node_id);\n+            }\n+        }\n+\n+        // We can be sure to hit the cache now\n+        return self.maybe_get_item_ast(tcx, def_id);\n+    }\n+\n+    fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId> {\n+        assert!(!def_id.is_local());\n+        match self.inlined_item_cache.borrow().get(&def_id) {\n+            Some(&Some(ref cached_inlined_item)) => {\n+                Some(cached_inlined_item.item_id)\n+            }\n+            Some(&None) => {\n+                None\n+            }\n+            _ => {\n+                bug!(\"Trying to lookup inlined NodeId for unexpected item\");\n+            }\n+        }\n+    }\n+\n+    fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId> {\n+        self.defid_for_inlined_node.borrow().get(&node_id).map(|x| *x)\n     }\n \n     fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -634,3 +768,4 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         visible_parent_map\n     }\n }\n+"}, {"sha": "d786cc5ba0eb7865bbc58e4f2e3c267a1417e58b", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -25,7 +25,7 @@ use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::{DefIndex, DefId};\n use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::{ExternCrate};\n+use rustc::middle::cstore::ExternCrate;\n use rustc::session::config::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n@@ -96,6 +96,13 @@ pub struct CrateMetadata {\n     pub explicitly_linked: Cell<bool>,\n }\n \n+pub struct CachedInlinedItem {\n+    /// The NodeId of the RootInlinedParent HIR map entry\n+    pub inlined_root: ast::NodeId,\n+    /// The local NodeId of the inlined entity\n+    pub item_id: ast::NodeId,\n+}\n+\n pub struct CStore {\n     pub dep_graph: DepGraph,\n     metas: RefCell<FnvHashMap<ast::CrateNum, Rc<CrateMetadata>>>,\n@@ -105,6 +112,8 @@ pub struct CStore {\n     used_libraries: RefCell<Vec<(String, NativeLibraryKind)>>,\n     used_link_args: RefCell<Vec<String>>,\n     statically_included_foreign_items: RefCell<NodeSet>,\n+    pub inlined_item_cache: RefCell<DefIdMap<Option<CachedInlinedItem>>>,\n+    pub defid_for_inlined_node: RefCell<NodeMap<DefId>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n }\n \n@@ -119,6 +128,8 @@ impl CStore {\n             used_link_args: RefCell::new(Vec::new()),\n             statically_included_foreign_items: RefCell::new(NodeSet()),\n             visible_parent_map: RefCell::new(FnvHashMap()),\n+            inlined_item_cache: RefCell::new(FnvHashMap()),\n+            defid_for_inlined_node: RefCell::new(FnvHashMap()),\n         }\n     }\n "}, {"sha": "d8fd25d62774af11721a3db8b604a6ff6c0f4400", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -30,7 +30,7 @@ use rustc::util::nodemap::FnvHashMap;\n use rustc::hir;\n use rustc::session::config::PanicStrategy;\n \n-use middle::cstore::{FoundAst, InlinedItem, LinkagePreference};\n+use middle::cstore::{InlinedItem, LinkagePreference};\n use middle::cstore::{DefLike, DlDef, DlField, DlImpl, tls};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex};\n@@ -55,7 +55,6 @@ use rustc_serialize::Decodable;\n use syntax::attr;\n use syntax::parse::token;\n use syntax::ast;\n-use syntax::abi::Abi;\n use syntax::codemap;\n use syntax::print::pprust;\n use syntax::ptr::P;\n@@ -756,6 +755,12 @@ pub fn maybe_get_item_name(cdata: Cmd, id: DefIndex) -> Option<ast::Name> {\n     maybe_item_name(cdata.lookup_item(id))\n }\n \n+pub enum FoundAst<'ast> {\n+    Found(&'ast InlinedItem),\n+    FoundParent(DefId, &'ast hir::Item),\n+    NotFound,\n+}\n+\n pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n                                     -> FoundAst<'tcx> {\n     debug!(\"Looking up item: {:?}\", id);\n@@ -1160,15 +1165,7 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n                 // an attribute\n                 assert_eq!(meta_items.len(), 1);\n                 let meta_item = meta_items.into_iter().nth(0).unwrap();\n-                codemap::Spanned {\n-                    node: ast::Attribute_ {\n-                        id: attr::mk_attr_id(),\n-                        style: ast::AttrStyle::Outer,\n-                        value: meta_item,\n-                        is_sugared_doc: is_sugared_doc,\n-                    },\n-                    span: syntax_pos::DUMMY_SP\n-                }\n+                attr::mk_doc_attr_outer(attr::mk_attr_id(), meta_item, is_sugared_doc)\n             }).collect()\n         },\n         None => vec![],\n@@ -1542,13 +1539,9 @@ pub fn is_extern_item<'a, 'tcx>(cdata: Cmd,\n     let applicable = match item_family(item_doc) {\n         ImmStatic | MutStatic => true,\n         Fn => {\n-            let ty::TypeScheme { generics, ty } = get_type(cdata, id, tcx);\n+            let ty::TypeScheme { generics, .. } = get_type(cdata, id, tcx);\n             let no_generics = generics.types.is_empty();\n-            match ty.sty {\n-                ty::TyFnDef(_, _, fn_ty) | ty::TyFnPtr(fn_ty)\n-                    if fn_ty.abi != Abi::Rust => return no_generics,\n-                _ => no_generics,\n-            }\n+            no_generics\n         },\n         _ => false,\n     };"}, {"sha": "732c256a1910f18ca8e8b629d158d5476512f286", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -44,7 +44,7 @@ use std::rc::Rc;\n use std::u32;\n use syntax::abi::Abi;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n-use syntax::attr;\n+use syntax::attr::{self,AttrMetaMethods,AttributeMethods};\n use errors::Handler;\n use syntax;\n use syntax_pos::BytePos;\n@@ -1431,31 +1431,28 @@ fn encode_item_index(rbml_w: &mut Encoder, index: IndexData) {\n }\n \n fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n-    match mi.node {\n-      ast::MetaItemKind::Word(ref name) => {\n+    if mi.is_word() {\n+        let name = mi.name();\n         rbml_w.start_tag(tag_meta_item_word);\n-        rbml_w.wr_tagged_str(tag_meta_item_name, name);\n+        rbml_w.wr_tagged_str(tag_meta_item_name, &name);\n         rbml_w.end_tag();\n-      }\n-      ast::MetaItemKind::NameValue(ref name, ref value) => {\n-        match value.node {\n-          ast::LitKind::Str(ref value, _) => {\n-            rbml_w.start_tag(tag_meta_item_name_value);\n-            rbml_w.wr_tagged_str(tag_meta_item_name, name);\n-            rbml_w.wr_tagged_str(tag_meta_item_value, value);\n-            rbml_w.end_tag();\n-          }\n-          _ => {/* FIXME (#623): encode other variants */ }\n-        }\n-      }\n-      ast::MetaItemKind::List(ref name, ref items) => {\n+    } else if mi.is_value_str() {\n+        let name = mi.name();\n+        /* FIXME (#623): support other literal kinds */\n+        let value = mi.value_str().unwrap();\n+        rbml_w.start_tag(tag_meta_item_name_value);\n+        rbml_w.wr_tagged_str(tag_meta_item_name, &name);\n+        rbml_w.wr_tagged_str(tag_meta_item_value, &value);\n+        rbml_w.end_tag();\n+    } else { // it must be a list\n+        let name = mi.name();\n+        let items = mi.meta_item_list().unwrap();\n         rbml_w.start_tag(tag_meta_item_list);\n-        rbml_w.wr_tagged_str(tag_meta_item_name, name);\n+        rbml_w.wr_tagged_str(tag_meta_item_name, &name);\n         for inner_item in items {\n             encode_meta_item(rbml_w, &inner_item);\n         }\n         rbml_w.end_tag();\n-      }\n     }\n }\n \n@@ -1464,7 +1461,7 @@ fn encode_attributes(rbml_w: &mut Encoder, attrs: &[ast::Attribute]) {\n     for attr in attrs {\n         rbml_w.start_tag(tag_attribute);\n         rbml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n-        encode_meta_item(rbml_w, &attr.node.value);\n+        encode_meta_item(rbml_w, attr.meta());\n         rbml_w.end_tag();\n     }\n     rbml_w.end_tag();\n@@ -1893,7 +1890,7 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n     encode_crate_name(rbml_w, &ecx.link_meta.crate_name);\n     encode_crate_triple(rbml_w, &ecx.tcx.sess.opts.target_triple);\n     encode_hash(rbml_w, &ecx.link_meta.crate_hash);\n-    encode_crate_disambiguator(rbml_w, &ecx.tcx.sess.crate_disambiguator.get().as_str());\n+    encode_crate_disambiguator(rbml_w, &ecx.tcx.sess.local_crate_disambiguator());\n     encode_dylib_dependency_formats(rbml_w, &ecx);\n     encode_panic_strategy(rbml_w, &ecx);\n "}, {"sha": "4be044c1df30720770e913e41b70d10328937a77", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -60,10 +60,10 @@ impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n                     }\n                     if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n                         for attr in names {\n-                            if let ast::MetaItemKind::Word(ref name) = attr.node {\n-                                sel.insert(name.clone(), attr.span);\n+                            if attr.is_word() {\n+                                sel.insert(attr.name().clone(), attr.span());\n                             } else {\n-                                span_err!(self.sess, attr.span, E0466, \"bad macro import\");\n+                                span_err!(self.sess, attr.span(), E0466, \"bad macro import\");\n                             }\n                         }\n                     }\n@@ -78,10 +78,10 @@ impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n                     };\n \n                     for attr in names {\n-                        if let ast::MetaItemKind::Word(ref name) = attr.node {\n-                            reexport.insert(name.clone(), attr.span);\n+                        if attr.is_word() {\n+                            reexport.insert(attr.name().clone(), attr.span());\n                         } else {\n-                            call_bad_macro_reexport(self.sess, attr.span);\n+                            call_bad_macro_reexport(self.sess, attr.span());\n                         }\n                     }\n                 }"}, {"sha": "11d6b0779275ee40f6f6a56ae6728fdb9d0c687f", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -250,7 +250,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n             build::construct_fn(cx, id, arguments, fn_sig.output, body)\n         });\n \n-        intravisit::walk_fn(self, fk, decl, body, span);\n+        intravisit::walk_fn(self, fk, decl, body, span, id);\n     }\n }\n "}, {"sha": "d1b88ddda0c674987bb3e605b315b9cc20330b36", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -19,6 +19,7 @@ use std::fmt::Display;\n use std::fs;\n use std::io::{self, Write};\n use syntax::ast::NodeId;\n+use std::path::{PathBuf, Path};\n \n const INDENT: &'static str = \"    \";\n /// Alignment for lining up comments following MIR statements\n@@ -66,9 +67,15 @@ pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _ => String::new()\n     };\n \n+    let mut file_path = PathBuf::new();\n+    if let Some(ref file_dir) = tcx.sess.opts.debugging_opts.dump_mir_dir {\n+        let p = Path::new(file_dir);\n+        file_path.push(p);\n+    };\n     let file_name = format!(\"rustc.node{}{}.{}.{}.mir\",\n                             node_id, promotion_id, pass_name, disambiguator);\n-    let _ = fs::File::create(&file_name).and_then(|mut file| {\n+    file_path.push(&file_name);\n+    let _ = fs::File::create(&file_path).and_then(|mut file| {\n         try!(writeln!(file, \"// MIR for `{}`\", node_path));\n         try!(writeln!(file, \"// node_id = {}\", node_id));\n         try!(writeln!(file, \"// pass_name = {}\", pass_name));\n@@ -195,7 +202,7 @@ fn write_basic_block(tcx: TyCtxt,\n              ALIGN,\n              comment(tcx, data.terminator().source_info))?;\n \n-    writeln!(w, \"{}}}\\n\", INDENT)\n+    writeln!(w, \"{}}}\", INDENT)\n }\n \n fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {"}, {"sha": "fccd4a607fdcf1cd2e9a520b7ee0efe7b2d5cecb", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TyCtxt;\n+use rustc::mir::repr::*;\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc::ty::VariantKind;\n+\n+pub struct Deaggregator;\n+\n+impl Pass for Deaggregator {}\n+\n+impl<'tcx> MirPass<'tcx> for Deaggregator {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    source: MirSource, mir: &mut Mir<'tcx>) {\n+        let node_id = source.item_id();\n+        let node_path = tcx.item_path_str(tcx.map.local_def_id(node_id));\n+        debug!(\"running on: {:?}\", node_path);\n+        // we only run when mir_opt_level > 1\n+        match tcx.sess.opts.debugging_opts.mir_opt_level {\n+            Some(0) |\n+            Some(1) |\n+            None => { return; },\n+            _ => {}\n+        };\n+\n+        // Do not trigger on constants.  Could be revised in future\n+        if let MirSource::Fn(_) = source {} else { return; }\n+        // In fact, we might not want to trigger in other cases.\n+        // Ex: when we could use SROA.  See issue #35259\n+\n+        let mut curr: usize = 0;\n+        for bb in mir.basic_blocks_mut() {\n+            let idx = match get_aggregate_statement(curr, &bb.statements) {\n+                Some(idx) => idx,\n+                None => continue,\n+            };\n+            // do the replacement\n+            debug!(\"removing statement {:?}\", idx);\n+            let src_info = bb.statements[idx].source_info;\n+            let suffix_stmts = bb.statements.split_off(idx+1);\n+            let orig_stmt = bb.statements.pop().unwrap();\n+            let StatementKind::Assign(ref lhs, ref rhs) = orig_stmt.kind;\n+            let (agg_kind, operands) = match rhs {\n+                &Rvalue::Aggregate(ref agg_kind, ref operands) => (agg_kind, operands),\n+                _ => span_bug!(src_info.span, \"expected aggregate, not {:?}\", rhs),\n+            };\n+            let (adt_def, variant, substs) = match agg_kind {\n+                &AggregateKind::Adt(adt_def, variant, substs) => (adt_def, variant, substs),\n+                _ => span_bug!(src_info.span, \"expected struct, not {:?}\", rhs),\n+            };\n+            let n = bb.statements.len();\n+            bb.statements.reserve(n + operands.len() + suffix_stmts.len());\n+            for (i, op) in operands.iter().enumerate() {\n+                let ref variant_def = adt_def.variants[variant];\n+                let ty = variant_def.fields[i].ty(tcx, substs);\n+                let rhs = Rvalue::Use(op.clone());\n+\n+                // since we don't handle enums, we don't need a cast\n+                let lhs_cast = lhs.clone();\n+\n+                // FIXME we cannot deaggregate enums issue: #35186\n+\n+                let lhs_proj = Lvalue::Projection(Box::new(LvalueProjection {\n+                    base: lhs_cast,\n+                    elem: ProjectionElem::Field(Field::new(i), ty),\n+                }));\n+                let new_statement = Statement {\n+                    source_info: src_info,\n+                    kind: StatementKind::Assign(lhs_proj, rhs),\n+                };\n+                debug!(\"inserting: {:?} @ {:?}\", new_statement, idx + i);\n+                bb.statements.push(new_statement);\n+            }\n+            curr = bb.statements.len();\n+            bb.statements.extend(suffix_stmts);\n+        }\n+    }\n+}\n+\n+fn get_aggregate_statement<'a, 'tcx, 'b>(curr: usize,\n+                                         statements: &Vec<Statement<'tcx>>)\n+                                         -> Option<usize> {\n+    for i in curr..statements.len() {\n+        let ref statement = statements[i];\n+        let StatementKind::Assign(_, ref rhs) = statement.kind;\n+        let (kind, operands) = match rhs {\n+            &Rvalue::Aggregate(ref kind, ref operands) => (kind, operands),\n+            _ => continue,\n+        };\n+        let (adt_def, variant) = match kind {\n+            &AggregateKind::Adt(adt_def, variant, _) => (adt_def, variant),\n+            _ => continue,\n+        };\n+        if operands.len() == 0 || adt_def.variants.len() > 1 {\n+            // don't deaggregate ()\n+            // don't deaggregate enums ... for now\n+            continue;\n+        }\n+        debug!(\"getting variant {:?}\", variant);\n+        debug!(\"for adt_def {:?}\", adt_def);\n+        let variant_def = &adt_def.variants[variant];\n+        if variant_def.kind == VariantKind::Struct {\n+            return Some(i);\n+        }\n+    };\n+    None\n+}"}, {"sha": "c3485b8256da1fa0c8b1178309f5b978faf9f615", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -17,3 +17,4 @@ pub mod add_call_guards;\n pub mod promote_consts;\n pub mod qualify_consts;\n pub mod dump_mir;\n+pub mod deaggregator;"}, {"sha": "d2cf48eddebac2de42b84571262075df045d4af7", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -55,6 +55,17 @@ impl<'a> AstValidator<'a> {\n             err.emit();\n         }\n     }\n+\n+    fn check_decl_no_pat<ReportFn: Fn(Span, bool)>(&self, decl: &FnDecl, report_err: ReportFn) {\n+        for arg in &decl.inputs {\n+            match arg.pat.node {\n+                PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), _, None) |\n+                PatKind::Wild => {}\n+                PatKind::Ident(..) => report_err(arg.pat.span, true),\n+                _ => report_err(arg.pat.span, false),\n+            }\n+        }\n+    }\n }\n \n impl<'a> Visitor for AstValidator<'a> {\n@@ -82,6 +93,23 @@ impl<'a> Visitor for AstValidator<'a> {\n         visit::walk_expr(self, expr)\n     }\n \n+    fn visit_ty(&mut self, ty: &Ty) {\n+        match ty.node {\n+            TyKind::BareFn(ref bfty) => {\n+                self.check_decl_no_pat(&bfty.decl, |span, _| {\n+                    let mut err = struct_span_err!(self.session, span, E0561,\n+                                            \"patterns aren't allowed in function pointer types\");\n+                    err.span_note(span, \"this is a recent error, see \\\n+                                         issue #35203 for more details\");\n+                    err.emit();\n+                });\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_ty(self, ty)\n+    }\n+\n     fn visit_path(&mut self, path: &Path, id: NodeId) {\n         if path.global && path.segments.len() > 0 {\n             let ident = path.segments[0].identifier;\n@@ -135,6 +163,25 @@ impl<'a> Visitor for AstValidator<'a> {\n         visit::walk_item(self, item)\n     }\n \n+    fn visit_foreign_item(&mut self, fi: &ForeignItem) {\n+        match fi.node {\n+            ForeignItemKind::Fn(ref decl, _) => {\n+                self.check_decl_no_pat(decl, |span, is_recent| {\n+                    let mut err = struct_span_err!(self.session, span, E0130,\n+                                        \"patterns aren't allowed in foreign function declarations\");\n+                    if is_recent {\n+                        err.span_note(span, \"this is a recent error, see \\\n+                                             issue #35203 for more details\");\n+                    }\n+                    err.emit();\n+                });\n+            }\n+            ForeignItemKind::Static(..) => {}\n+        }\n+\n+        visit::walk_foreign_item(self, fi)\n+    }\n+\n     fn visit_variant_data(&mut self, vdata: &VariantData, _: Ident,\n                           _: &Generics, _: NodeId, span: Span) {\n         if vdata.fields().is_empty() {"}, {"sha": "1030a4b0116de5a07572ffa53fa974d909f4b6b7", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -40,6 +40,7 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::ProjectionMode;\n+use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc::middle::const_qualif::ConstQualif;\n use rustc::lint::builtin::CONST_ERR;\n@@ -116,7 +117,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n                 _ => self.tcx.sess.add_lint(CONST_ERR, expr.id, expr.span,\n                                          format!(\"constant evaluation error: {}. This will \\\n                                                  become a HARD ERROR in the future\",\n-                                                 err.description())),\n+                                                 err.description().into_oneline())),\n             }\n         }\n         self.with_mode(mode, |this| {\n@@ -157,7 +158,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n         let qualif = self.with_mode(mode, |this| {\n             this.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, b));\n-            intravisit::walk_fn(this, fk, fd, b, s);\n+            intravisit::walk_fn(this, fk, fd, b, s, fn_id);\n             this.qualif\n         });\n \n@@ -211,15 +212,6 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n             }\n         }\n     }\n-\n-    fn msg(&self) -> &'static str {\n-        match self.mode {\n-            Mode::Const => \"constant\",\n-            Mode::ConstFn => \"constant function\",\n-            Mode::StaticMut | Mode::Static => \"static\",\n-            Mode::Var => bug!(),\n-        }\n-    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n@@ -289,18 +281,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 self.global_expr(Mode::Const, &start);\n                 self.global_expr(Mode::Const, &end);\n \n-                match compare_lit_exprs(self.tcx, start, end) {\n-                    Some(Ordering::Less) |\n-                    Some(Ordering::Equal) => {}\n-                    Some(Ordering::Greater) => {\n+                match compare_lit_exprs(self.tcx, p.span, start, end) {\n+                    Ok(Ordering::Less) |\n+                    Ok(Ordering::Equal) => {}\n+                    Ok(Ordering::Greater) => {\n                         span_err!(self.tcx.sess, start.span, E0030,\n                             \"lower range bound must be less than or equal to upper\");\n                     }\n-                    None => {\n-                        span_err!(self.tcx.sess, p.span, E0014,\n-                                  \"paths in {}s may only refer to constants\",\n-                                  self.msg());\n-                    }\n+                    Err(ErrorReported) => {}\n                 }\n             }\n             _ => intravisit::walk_pat(self, p)\n@@ -429,7 +417,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 Err(msg) => {\n                     self.tcx.sess.add_lint(CONST_ERR, ex.id,\n                                            msg.span,\n-                                           msg.description().into_owned())\n+                                           msg.description().into_oneline().into_owned())\n                 }\n             }\n         }"}, {"sha": "3e2dd477bccf089f0e40b0598246ce9c120b39e2", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_snake_case)]\n \n register_long_diagnostics! {\n-\n+/*\n E0014: r##\"\n Constants can only be initialized by a constant value or, in a future\n version of Rust, a call to a const function. This error indicates the use\n@@ -30,7 +30,7 @@ const FOO: i32 = { const X : i32 = 0; X };\n const FOO2: i32 = { 0 }; // but brackets are useless here\n ```\n \"##,\n-\n+*/\n E0030: r##\"\n When matching against a range, the compiler verifies that the range is\n non-empty.  Range patterns include both end-points, so this is equivalent to\n@@ -49,6 +49,39 @@ match 5u32 {\n ```\n \"##,\n \n+E0130: r##\"\n+You declared a pattern as an argument in a foreign function declaration.\n+Erroneous code example:\n+\n+```compile_fail\n+extern {\n+    fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign\n+                                //        function declarations\n+}\n+```\n+\n+Please replace the pattern argument with a regular one. Example:\n+\n+```\n+struct SomeStruct {\n+    a: u32,\n+    b: u32,\n+}\n+\n+extern {\n+    fn foo(s: SomeStruct); // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+extern {\n+    fn foo(a: (u32, u32)); // ok!\n+}\n+```\n+\"##,\n+\n E0161: r##\"\n A value was moved. However, its size was not known at compile time, and only\n values of a known size can be moved.\n@@ -187,4 +220,5 @@ pub impl Foo for Bar {\n \n register_diagnostics! {\n     E0472, // asm! is unsupported on this target\n+    E0561, // patterns aren't allowed in function pointer types\n }"}, {"sha": "2a5dc50cae92f4682044ffae57dc069e04ce409c", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n             euv.walk_fn(fd, b);\n         });\n-        intravisit::walk_fn(self, fk, fd, b, s)\n+        intravisit::walk_fn(self, fk, fd, b, s, fn_id)\n     }\n }\n "}, {"sha": "793e52d37920354be1a9373fbdd672920c0eaba5", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -291,7 +291,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             }\n         }\n \n-        intravisit::walk_mod(self, m);\n+        intravisit::walk_mod(self, m, id);\n     }\n \n     fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {"}, {"sha": "b26e3b3819ce2ef3767d3ec3e47441c3abdd14d7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 28, "deletions": 43, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -219,7 +219,13 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              name)\n         }\n         ResolutionError::IsNotATrait(name) => {\n-            struct_span_err!(resolver.session, span, E0404, \"`{}` is not a trait\", name)\n+            let mut err = struct_span_err!(resolver.session,\n+                                           span,\n+                                           E0404,\n+                                           \"`{}` is not a trait\",\n+                                           name);\n+            err.span_label(span, &format!(\"not a trait\"));\n+            err\n         }\n         ResolutionError::UndeclaredTraitName(name, candidates) => {\n             let mut err = struct_span_err!(resolver.session,\n@@ -825,8 +831,6 @@ enum NameBindingKind<'a> {\n     Import {\n         binding: &'a NameBinding<'a>,\n         directive: &'a ImportDirective<'a>,\n-        // Some(error) if using this imported name causes the import to be a privacy error\n-        privacy_error: Option<Box<PrivacyError<'a>>>,\n     },\n }\n \n@@ -1206,16 +1210,11 @@ impl<'a> Resolver<'a> {\n             self.used_crates.insert(krate);\n         }\n \n-        let (directive, privacy_error) = match binding.kind {\n-            NameBindingKind::Import { directive, ref privacy_error, .. } =>\n-                (directive, privacy_error),\n+        let directive = match binding.kind {\n+            NameBindingKind::Import { directive, .. } => directive,\n             _ => return,\n         };\n \n-        if let Some(error) = privacy_error.as_ref() {\n-            self.privacy_errors.push((**error).clone());\n-        }\n-\n         if !self.make_glob_map {\n             return;\n         }\n@@ -1814,39 +1813,25 @@ impl<'a> Resolver<'a> {\n                                path_depth: usize)\n                                -> Result<PathResolution, ()> {\n         self.resolve_path(id, trait_path, path_depth, TypeNS).and_then(|path_res| {\n-            if let Def::Trait(_) = path_res.base_def {\n-                debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n-                Ok(path_res)\n-            } else {\n-                let mut err =\n-                    resolve_struct_error(self,\n-                                  trait_path.span,\n-                                  ResolutionError::IsNotATrait(&path_names_to_string(trait_path,\n-                                                                                      path_depth)));\n-\n-                // If it's a typedef, give a note\n-                if let Def::TyAlias(..) = path_res.base_def {\n-                    let trait_name = trait_path.segments.last().unwrap().identifier.name;\n-                    err.span_label(trait_path.span,\n-                                   &format!(\"`{}` is not a trait\", trait_name));\n-\n-                    let definition_site = {\n-                        let segments = &trait_path.segments;\n-                        if trait_path.global {\n-                            self.resolve_crate_relative_path(trait_path.span, segments, TypeNS)\n-                        } else {\n-                            self.resolve_module_relative_path(trait_path.span, segments, TypeNS)\n-                        }.map(|binding| binding.span).unwrap_or(syntax_pos::DUMMY_SP)\n-                    };\n-\n-                    if definition_site != syntax_pos::DUMMY_SP {\n-                        err.span_label(definition_site,\n-                                       &format!(\"type aliases cannot be used for traits\"));\n-                    }\n+            match path_res.base_def {\n+                Def::Trait(_) => {\n+                    debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n+                    return Ok(path_res);\n                 }\n-                err.emit();\n-                Err(true)\n+                Def::Err => return Err(true),\n+                _ => {}\n+            }\n+\n+            let mut err = resolve_struct_error(self, trait_path.span, {\n+                ResolutionError::IsNotATrait(&path_names_to_string(trait_path, path_depth))\n+            });\n+\n+            // If it's a typedef, give a note\n+            if let Def::TyAlias(..) = path_res.base_def {\n+                err.note(&format!(\"type aliases cannot be used for traits\"));\n             }\n+            err.emit();\n+            Err(true)\n         }).map_err(|error_reported| {\n             if error_reported { return }\n \n@@ -2274,7 +2259,7 @@ impl<'a> Resolver<'a> {\n         let resolution = if let Some(resolution) = self.resolve_possibly_assoc_item(pat_id,\n                                                                         qself, path, namespace) {\n             if resolution.depth == 0 {\n-                if expected_fn(resolution.base_def) {\n+                if expected_fn(resolution.base_def) || resolution.base_def == Def::Err {\n                     resolution\n                 } else {\n                     resolve_error(\n@@ -2345,7 +2330,7 @@ impl<'a> Resolver<'a> {\n                                 );\n                                 None\n                             }\n-                            Def::Local(..) | Def::Upvar(..) | Def::Fn(..) => {\n+                            Def::Local(..) | Def::Upvar(..) | Def::Fn(..) | Def::Err => {\n                                 // These entities are explicitly allowed\n                                 // to be shadowed by fresh bindings.\n                                 None"}, {"sha": "fc5e2a48e876ccc2eaf5391dd85a4e399f7ec2ee", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -73,13 +73,11 @@ pub struct ImportDirective<'a> {\n impl<'a> ImportDirective<'a> {\n     // Given the binding to which this directive resolves in a particular namespace,\n     // this returns the binding for the name this directive defines in that namespace.\n-    fn import(&'a self, binding: &'a NameBinding<'a>, privacy_error: Option<Box<PrivacyError<'a>>>)\n-              -> NameBinding<'a> {\n+    fn import(&'a self, binding: &'a NameBinding<'a>) -> NameBinding<'a> {\n         NameBinding {\n             kind: NameBindingKind::Import {\n                 binding: binding,\n                 directive: self,\n-                privacy_error: privacy_error,\n             },\n             span: self.span,\n             vis: self.vis,\n@@ -328,7 +326,7 @@ impl<'a> ::ModuleS<'a> {\n     fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n         if !binding.is_importable() || !binding.is_pseudo_public() { return }\n         for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n-            let _ = importer.try_define_child(name, ns, directive.import(binding, None));\n+            let _ = importer.try_define_child(name, ns, directive.import(binding));\n         }\n     }\n }\n@@ -409,7 +407,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             });\n-            let dummy_binding = directive.import(dummy_binding, None);\n+            let dummy_binding = directive.import(dummy_binding);\n \n             let _ = source_module.try_define_child(target, ValueNS, dummy_binding.clone());\n             let _ = source_module.try_define_child(target, TypeNS, dummy_binding);\n@@ -494,38 +492,37 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             self.resolver.resolve_name_in_module(target_module, source, TypeNS, false, true);\n \n         let module_ = self.resolver.current_module;\n+        let mut privacy_error = true;\n         for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n                                            (TypeNS, &type_result, type_determined)] {\n-            if determined.get() { continue }\n-            if let Indeterminate = *result { continue }\n-\n-            determined.set(true);\n-            if let Success(binding) = *result {\n-                if !binding.is_importable() {\n+            match *result {\n+                Failed(..) if !determined.get() => {\n+                    determined.set(true);\n+                    module_.update_resolution(target, ns, |resolution| {\n+                        resolution.single_imports.directive_failed()\n+                    });\n+                }\n+                Success(binding) if !binding.is_importable() => {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n                     span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n                     // Do not import this illegal binding. Import a dummy binding and pretend\n                     // everything is fine\n                     self.import_dummy_binding(module_, directive);\n                     return Success(());\n                 }\n-\n-                let privacy_error = if !self.resolver.is_accessible(binding.vis) {\n-                    Some(Box::new(PrivacyError(directive.span, source, binding)))\n-                } else {\n-                    None\n-                };\n-\n-                let imported_binding = directive.import(binding, privacy_error);\n-                let conflict = module_.try_define_child(target, ns, imported_binding);\n-                if let Err(old_binding) = conflict {\n-                    let binding = &directive.import(binding, None);\n-                    self.resolver.report_conflict(module_, target, ns, binding, old_binding);\n+                Success(binding) if !self.resolver.is_accessible(binding.vis) => {}\n+                Success(binding) if !determined.get() => {\n+                    determined.set(true);\n+                    let imported_binding = directive.import(binding);\n+                    let conflict = module_.try_define_child(target, ns, imported_binding);\n+                    if let Err(old_binding) = conflict {\n+                        let binding = &directive.import(binding);\n+                        self.resolver.report_conflict(module_, target, ns, binding, old_binding);\n+                    }\n+                    privacy_error = false;\n                 }\n-            } else {\n-                module_.update_resolution(target, ns, |resolution| {\n-                    resolution.single_imports.directive_failed();\n-                });\n+                Success(_) => privacy_error = false,\n+                _ => {}\n             }\n         }\n \n@@ -556,6 +553,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => (),\n         }\n \n+        if privacy_error {\n+            for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n+                let binding = match *result { Success(binding) => binding, _ => continue };\n+                self.resolver.privacy_errors.push(PrivacyError(directive.span, source, binding));\n+                let _ = module_.try_define_child(target, ns, directive.import(binding));\n+            }\n+        }\n+\n         match (&value_result, &type_result) {\n             (&Success(binding), _) if !binding.pseudo_vis()\n                                               .is_at_least(directive.vis, self.resolver) &&\n@@ -592,19 +597,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => {}\n         }\n \n-        // Report a privacy error here if all successful namespaces are privacy errors.\n-        let mut privacy_error = None;\n-        for &ns in &[ValueNS, TypeNS] {\n-            privacy_error = match module_.resolve_name(target, ns, true) {\n-                Success(&NameBinding {\n-                    kind: NameBindingKind::Import { ref privacy_error, .. }, ..\n-                }) => privacy_error.as_ref().map(|error| (**error).clone()),\n-                _ => continue,\n-            };\n-            if privacy_error.is_none() { break }\n-        }\n-        privacy_error.map(|error| self.resolver.privacy_errors.push(error));\n-\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n@@ -652,7 +644,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n             if binding.is_importable() && binding.is_pseudo_public() {\n-                let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n+                let _ = module_.try_define_child(name, ns, directive.import(binding));\n             }\n         }\n "}, {"sha": "0fd95500422ff193af8a29aa1f8ea615657eb775", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -427,7 +427,7 @@ fn make_values_str(pairs: &[(&'static str, &str)]) -> String {\n }\n \n fn span_extent_str(span: SpanData) -> String {\n-    format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},byte_start,{}\\\n+    format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},byte_start,{},\\\n              file_line_end,{},file_col_end,{},byte_end,{}\",\n              span.file_name, span.line_start, span.column_start, span.byte_start,\n              span.line_end, span.column_end, span.byte_end)"}, {"sha": "f7fd970f37f2f89e1a4686f541ef9ea5984343bc", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -190,7 +190,7 @@ use self::FailureHandler::*;\n \n use llvm::{ValueRef, BasicBlockRef};\n use rustc_const_eval::check_match::{self, Constructor, StaticInliner};\n-use rustc_const_eval::{compare_lit_exprs, eval_const_expr};\n+use rustc_const_eval::{compare_lit_exprs, eval_const_expr, fatal_const_eval_err};\n use rustc::hir::def::{Def, DefMap};\n use rustc::hir::def_id::DefId;\n use middle::expr_use_visitor as euv;\n@@ -239,9 +239,9 @@ struct ConstantExpr<'a>(&'a hir::Expr);\n \n impl<'a> ConstantExpr<'a> {\n     fn eq<'b, 'tcx>(self, other: ConstantExpr<'a>, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> bool {\n-        match compare_lit_exprs(tcx, self.0, other.0) {\n-            Some(result) => result == Ordering::Equal,\n-            None => bug!(\"compare_list_exprs: type mismatch\"),\n+        match compare_lit_exprs(tcx, self.0.span, self.0, other.0) {\n+            Ok(result) => result == Ordering::Equal,\n+            Err(_) => bug!(\"compare_list_exprs: type mismatch\"),\n         }\n     }\n }\n@@ -288,7 +288,9 @@ impl<'a, 'b, 'tcx> Opt<'a, 'tcx> {\n                 let expr = consts::const_expr(ccx, &lit_expr, bcx.fcx.param_substs, None, Yes);\n                 let llval = match expr {\n                     Ok((llval, _)) => llval,\n-                    Err(err) => bcx.ccx().sess().span_fatal(lit_expr.span, &err.description()),\n+                    Err(err) => {\n+                        fatal_const_eval_err(bcx.tcx(), err.as_inner(), lit_expr.span, \"pattern\");\n+                    }\n                 };\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n@@ -297,11 +299,11 @@ impl<'a, 'b, 'tcx> Opt<'a, 'tcx> {\n             ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n                 let l1 = match consts::const_expr(ccx, &l1, bcx.fcx.param_substs, None, Yes) {\n                     Ok((l1, _)) => l1,\n-                    Err(err) => bcx.ccx().sess().span_fatal(l1.span, &err.description()),\n+                    Err(err) => fatal_const_eval_err(bcx.tcx(), err.as_inner(), l1.span, \"pattern\"),\n                 };\n                 let l2 = match consts::const_expr(ccx, &l2, bcx.fcx.param_substs, None, Yes) {\n                     Ok((l2, _)) => l2,\n-                    Err(err) => bcx.ccx().sess().span_fatal(l2.span, &err.description()),\n+                    Err(err) => fatal_const_eval_err(bcx.tcx(), err.as_inner(), l2.span, \"pattern\"),\n                 };\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }"}, {"sha": "587c03af3abb6d6eaae9fbdd1c73a2650912049e", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -552,13 +552,13 @@ impl FnType {\n     pub fn apply_attrs_llfn(&self, llfn: ValueRef) {\n         let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n         if !self.ret.is_ignore() {\n-            self.ret.attrs.apply_llfn(i, llfn);\n+            self.ret.attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n         }\n         i += 1;\n         for arg in &self.args {\n             if !arg.is_ignore() {\n                 if arg.pad.is_some() { i += 1; }\n-                arg.attrs.apply_llfn(i, llfn);\n+                arg.attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n                 i += 1;\n             }\n         }\n@@ -567,13 +567,13 @@ impl FnType {\n     pub fn apply_attrs_callsite(&self, callsite: ValueRef) {\n         let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n         if !self.ret.is_ignore() {\n-            self.ret.attrs.apply_callsite(i, callsite);\n+            self.ret.attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n         }\n         i += 1;\n         for arg in &self.args {\n             if !arg.is_ignore() {\n                 if arg.pad.is_some() { i += 1; }\n-                arg.attrs.apply_callsite(i, callsite);\n+                arg.attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n                 i += 1;\n             }\n         }"}, {"sha": "5514fb0f4efc37b067b21439af683cf9d6a8f754", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -83,8 +83,8 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     let dialect = match ia.dialect {\n-        AsmDialect::Att   => llvm::AD_ATT,\n-        AsmDialect::Intel => llvm::AD_Intel\n+        AsmDialect::Att   => llvm::AsmDialect::Att,\n+        AsmDialect::Intel => llvm::AsmDialect::Intel,\n     };\n \n     let asm = CString::new(ia.asm.as_bytes()).unwrap();"}, {"sha": "e0532e7476f511545d0bf7ac2ae98ac307d4548c", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -0,0 +1,149 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass is only used for UNIT TESTS related to incremental\n+//! compilation. It tests whether a particular `.o` file will be re-used\n+//! from a previous compilation or whether it must be regenerated.\n+//!\n+//! The user adds annotations to the crate of the following form:\n+//!\n+//! ```\n+//! #![rustc_partition_reused(module=\"spike\", cfg=\"rpass2\")]\n+//! #![rustc_partition_translated(module=\"spike-x\", cfg=\"rpass2\")]\n+//! ```\n+//!\n+//! The first indicates (in the cfg `rpass2`) that `spike.o` will be\n+//! reused, the second that `spike-x.o` will be recreated. If these\n+//! annotations are inaccurate, errors are reported.\n+//!\n+//! The reason that we use `cfg=...` and not `#[cfg_attr]` is so that\n+//! the HIR doesn't change as a result of the annotations, which might\n+//! perturb the reuse results.\n+\n+use rustc::ty::TyCtxt;\n+use syntax::ast;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::parse::token::InternedString;\n+\n+use {ModuleSource, ModuleTranslation};\n+\n+const PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n+const PARTITION_TRANSLATED: &'static str = \"rustc_partition_translated\";\n+\n+const MODULE: &'static str = \"module\";\n+const CFG: &'static str = \"cfg\";\n+\n+#[derive(Debug, PartialEq)]\n+enum Disposition { Reused, Translated }\n+\n+pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       modules: &[ModuleTranslation]) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+\n+    if tcx.sess.opts.incremental.is_none() {\n+        return;\n+    }\n+\n+    let ams = AssertModuleSource { tcx: tcx, modules: modules };\n+    for attr in &tcx.map.krate().attrs {\n+        ams.check_attr(attr);\n+    }\n+}\n+\n+struct AssertModuleSource<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    modules: &'a [ModuleTranslation],\n+}\n+\n+impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n+    fn check_attr(&self, attr: &ast::Attribute) {\n+        let disposition = if attr.check_name(PARTITION_REUSED) {\n+            Disposition::Reused\n+        } else if attr.check_name(PARTITION_TRANSLATED) {\n+            Disposition::Translated\n+        } else {\n+            return;\n+        };\n+\n+        if !self.check_config(attr) {\n+            debug!(\"check_attr: config does not match, ignoring attr\");\n+            return;\n+        }\n+\n+        let mname = self.field(attr, MODULE);\n+        let mtrans = self.modules.iter().find(|mtrans| &mtrans.name[..] == &mname[..]);\n+        let mtrans = match mtrans {\n+            Some(m) => m,\n+            None => {\n+                debug!(\"module name `{}` not found amongst:\", mname);\n+                for mtrans in self.modules {\n+                    debug!(\"module named `{}` with disposition {:?}\",\n+                           mtrans.name,\n+                           self.disposition(mtrans));\n+                }\n+\n+                self.tcx.sess.span_err(\n+                    attr.span,\n+                    &format!(\"no module named `{}`\", mname));\n+                return;\n+            }\n+        };\n+\n+        let mtrans_disposition = self.disposition(mtrans);\n+        if disposition != mtrans_disposition {\n+            self.tcx.sess.span_err(\n+                attr.span,\n+                &format!(\"expected module named `{}` to be {:?} but is {:?}\",\n+                         mname,\n+                         disposition,\n+                         mtrans_disposition));\n+        }\n+    }\n+\n+    fn disposition(&self, mtrans: &ModuleTranslation) -> Disposition {\n+        match mtrans.source {\n+            ModuleSource::Preexisting(_) => Disposition::Reused,\n+            ModuleSource::Translated(_) => Disposition::Translated,\n+        }\n+    }\n+\n+    fn field(&self, attr: &ast::Attribute, name: &str) -> InternedString {\n+        for item in attr.meta_item_list().unwrap_or(&[]) {\n+            if item.check_name(name) {\n+                if let Some(value) = item.value_str() {\n+                    return value;\n+                } else {\n+                    self.tcx.sess.span_fatal(\n+                        item.span,\n+                        &format!(\"associated value expected for `{}`\", name));\n+                }\n+            }\n+        }\n+\n+        self.tcx.sess.span_fatal(\n+            attr.span,\n+            &format!(\"no field `{}`\", name));\n+    }\n+\n+    /// Scan for a `cfg=\"foo\"` attribute and check whether we have a\n+    /// cfg flag called `foo`.\n+    fn check_config(&self, attr: &ast::Attribute) -> bool {\n+        let config = &self.tcx.map.krate().config;\n+        let value = self.field(attr, CFG);\n+        debug!(\"check_config(config={:?}, value={:?})\", config, value);\n+        if config.iter().any(|c| c.check_name(&value[..])) {\n+            debug!(\"check_config: matched\");\n+            return true;\n+        }\n+        debug!(\"check_config: no match found\");\n+        return false;\n+    }\n+\n+}"}, {"sha": "62eac35e0abd9766d64b7b471c6cf2022e15e182", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 21, "deletions": 41, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n //! Set and unset common attributes on LLVM values.\n \n-use libc::c_uint;\n-use llvm::{self, ValueRef};\n+use llvm::{self, Attribute, ValueRef};\n+use llvm::AttributePlace::Function;\n pub use syntax::attr::InlineAttr;\n use syntax::ast;\n use context::CrateContext;\n@@ -20,71 +20,52 @@ use context::CrateContext;\n pub fn inline(val: ValueRef, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n-        Hint   => llvm::SetFunctionAttribute(val, llvm::Attribute::InlineHint),\n-        Always => llvm::SetFunctionAttribute(val, llvm::Attribute::AlwaysInline),\n-        Never  => llvm::SetFunctionAttribute(val, llvm::Attribute::NoInline),\n+        Hint   => Attribute::InlineHint.apply_llfn(Function, val),\n+        Always => Attribute::AlwaysInline.apply_llfn(Function, val),\n+        Never  => Attribute::NoInline.apply_llfn(Function, val),\n         None   => {\n-            let attr = llvm::Attribute::InlineHint |\n-                       llvm::Attribute::AlwaysInline |\n-                       llvm::Attribute::NoInline;\n-            llvm::RemoveFunctionAttributes(val, attr)\n+            let attr = Attribute::InlineHint |\n+                       Attribute::AlwaysInline |\n+                       Attribute::NoInline;\n+            attr.unapply_llfn(Function, val)\n         },\n     };\n }\n \n /// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n #[inline]\n pub fn emit_uwtable(val: ValueRef, emit: bool) {\n-    if emit {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::UWTable);\n-    } else {\n-        llvm::RemoveFunctionAttributes(val, llvm::Attribute::UWTable);\n-    }\n+    Attribute::UWTable.toggle_llfn(Function, val, emit);\n }\n \n /// Tell LLVM whether the function can or cannot unwind.\n #[inline]\n pub fn unwind(val: ValueRef, can_unwind: bool) {\n-    if can_unwind {\n-        llvm::RemoveFunctionAttributes(val, llvm::Attribute::NoUnwind);\n-    } else {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::NoUnwind);\n-    }\n+    Attribute::NoUnwind.toggle_llfn(Function, val, !can_unwind);\n }\n \n /// Tell LLVM whether it should optimise function for size.\n #[inline]\n #[allow(dead_code)] // possibly useful function\n pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n-    if optimize {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::OptimizeForSize);\n-    } else {\n-        llvm::RemoveFunctionAttributes(val, llvm::Attribute::OptimizeForSize);\n-    }\n+    Attribute::OptimizeForSize.toggle_llfn(Function, val, optimize);\n }\n \n /// Tell LLVM if this function should be 'naked', i.e. skip the epilogue and prologue.\n #[inline]\n pub fn naked(val: ValueRef, is_naked: bool) {\n-    if is_naked {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::Naked);\n-    } else {\n-        llvm::RemoveFunctionAttributes(val, llvm::Attribute::Naked);\n-    }\n+    Attribute::Naked.toggle_llfn(Function, val, is_naked);\n }\n \n pub fn set_frame_pointer_elimination(ccx: &CrateContext, llfn: ValueRef) {\n     // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a\n     // parameter.\n     if ccx.sess().must_not_eliminate_frame_pointers() {\n-        unsafe {\n-            let attr = \"no-frame-pointer-elim\\0\".as_ptr() as *const _;\n-            let val = \"true\\0\".as_ptr() as *const _;\n-            llvm::LLVMAddFunctionAttrStringValue(llfn,\n-                                                 llvm::FunctionIndex as c_uint,\n-                                                 attr,\n-                                                 val);\n-        }\n+        llvm::AddFunctionAttrStringValue(\n+            llfn,\n+            llvm::AttributePlace::Function,\n+            \"no-frame-pointer-elim\\0\",\n+            \"true\\0\")\n     }\n }\n \n@@ -98,13 +79,12 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n \n     for attr in attrs {\n         if attr.check_name(\"cold\") {\n-            llvm::Attributes::default().set(llvm::Attribute::Cold)\n-                .apply_llfn(llvm::FunctionIndex as usize, llfn)\n+            Attribute::Cold.apply_llfn(Function, llfn);\n         } else if attr.check_name(\"naked\") {\n             naked(llfn, true);\n         } else if attr.check_name(\"allocator\") {\n-            llvm::Attributes::default().set(llvm::Attribute::NoAlias)\n-                .apply_llfn(llvm::ReturnIndex as usize, llfn)\n+            Attribute::NoAlias.apply_llfn(\n+                llvm::AttributePlace::ReturnValue(), llfn);\n         } else if attr.check_name(\"unwind\") {\n             unwind(llfn, true);\n         }"}, {"sha": "e063209799f16b0ba4641cf4fdcb524b6473f431", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -293,7 +293,7 @@ impl<'a> ArchiveBuilder<'a> {\n                                                members.as_ptr(),\n                                                self.should_update_symbols,\n                                                kind);\n-            let ret = if r != 0 {\n+            let ret = if r.into_result().is_err() {\n                 let err = llvm::LLVMRustGetLastError();\n                 let msg = if err.is_null() {\n                     \"failed to write archive\".to_string()"}, {"sha": "4e6c6013576f6beac379f8b429e11fabaf614ab6", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 104, "deletions": 59, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -10,18 +10,21 @@\n \n use back::lto;\n use back::link::{get_linker, remove};\n+use rustc_incremental::save_trans_partition;\n use session::config::{OutputFilenames, Passes, SomePasses, AllPasses};\n use session::Session;\n use session::config::{self, OutputType};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef, ContextRef};\n use llvm::SMDiagnosticRef;\n-use {CrateTranslation, ModuleTranslation};\n+use {CrateTranslation, ModuleLlvm, ModuleSource, ModuleTranslation};\n use util::common::time;\n use util::common::path2cstr;\n+use util::fs::link_or_copy;\n use errors::{self, Handler, Level, DiagnosticBuilder};\n use errors::emitter::Emitter;\n use syntax_pos::MultiSpan;\n+use context::{is_pie_binary, get_reloc_model};\n \n use std::collections::HashMap;\n use std::ffi::{CStr, CString};\n@@ -34,18 +37,18 @@ use std::thread;\n use libc::{c_uint, c_void};\n \n pub const RELOC_MODEL_ARGS : [(&'static str, llvm::RelocMode); 4] = [\n-    (\"pic\", llvm::RelocPIC),\n-    (\"static\", llvm::RelocStatic),\n-    (\"default\", llvm::RelocDefault),\n-    (\"dynamic-no-pic\", llvm::RelocDynamicNoPic),\n+    (\"pic\", llvm::RelocMode::PIC),\n+    (\"static\", llvm::RelocMode::Static),\n+    (\"default\", llvm::RelocMode::Default),\n+    (\"dynamic-no-pic\", llvm::RelocMode::DynamicNoPic),\n ];\n \n-pub const CODE_GEN_MODEL_ARGS : [(&'static str, llvm::CodeGenModel); 5] = [\n-    (\"default\", llvm::CodeModelDefault),\n-    (\"small\", llvm::CodeModelSmall),\n-    (\"kernel\", llvm::CodeModelKernel),\n-    (\"medium\", llvm::CodeModelMedium),\n-    (\"large\", llvm::CodeModelLarge),\n+pub const CODE_GEN_MODEL_ARGS : [(&'static str, llvm::CodeModel); 5] = [\n+    (\"default\", llvm::CodeModel::Default),\n+    (\"small\", llvm::CodeModel::Small),\n+    (\"kernel\", llvm::CodeModel::Kernel),\n+    (\"medium\", llvm::CodeModel::Medium),\n+    (\"large\", llvm::CodeModel::Large),\n ];\n \n pub fn llvm_err(handler: &errors::Handler, msg: String) -> ! {\n@@ -66,7 +69,7 @@ pub fn write_output_file(\n         let output_c = path2cstr(output);\n         let result = llvm::LLVMRustWriteOutputFile(\n                 target, pm, m, output_c.as_ptr(), file_type);\n-        if !result {\n+        if result.into_result().is_err() {\n             llvm_err(handler, format!(\"could not write output to {}\", output.display()));\n         }\n     }\n@@ -150,11 +153,11 @@ fn target_feature(sess: &Session) -> String {\n \n fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n     match optimize {\n-      config::OptLevel::No => llvm::CodeGenLevelNone,\n-      config::OptLevel::Less => llvm::CodeGenLevelLess,\n-      config::OptLevel::Default => llvm::CodeGenLevelDefault,\n-      config::OptLevel::Aggressive => llvm::CodeGenLevelAggressive,\n-      _ => llvm::CodeGenLevelDefault,\n+      config::OptLevel::No => llvm::CodeGenOptLevel::None,\n+      config::OptLevel::Less => llvm::CodeGenOptLevel::Less,\n+      config::OptLevel::Default => llvm::CodeGenOptLevel::Default,\n+      config::OptLevel::Aggressive => llvm::CodeGenOptLevel::Aggressive,\n+      _ => llvm::CodeGenOptLevel::Default,\n     }\n }\n \n@@ -167,30 +170,11 @@ fn get_llvm_opt_size(optimize: config::OptLevel) -> llvm::CodeGenOptSize {\n }\n \n pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n-    let reloc_model_arg = match sess.opts.cg.relocation_model {\n-        Some(ref s) => &s[..],\n-        None => &sess.target.target.options.relocation_model[..],\n-    };\n-    let reloc_model = match RELOC_MODEL_ARGS.iter().find(\n-        |&&arg| arg.0 == reloc_model_arg) {\n-        Some(x) => x.1,\n-        _ => {\n-            sess.err(&format!(\"{:?} is not a valid relocation mode\",\n-                             sess.opts\n-                                 .cg\n-                                 .relocation_model));\n-            sess.abort_if_errors();\n-            bug!();\n-        }\n-    };\n+    let reloc_model = get_reloc_model(sess);\n \n     let opt_level = get_llvm_opt_level(sess.opts.optimize);\n     let use_softfp = sess.opts.cg.soft_float;\n \n-    let any_library = sess.crate_types.borrow().iter().any(|ty| {\n-        *ty != config::CrateTypeExecutable\n-    });\n-\n     let ffunction_sections = sess.target.target.options.function_sections;\n     let fdata_sections = ffunction_sections;\n \n@@ -228,7 +212,7 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             reloc_model,\n             opt_level,\n             use_softfp,\n-            !any_library && reloc_model == llvm::RelocPIC,\n+            is_pie_binary(sess),\n             ffunction_sections,\n             fdata_sections,\n         )\n@@ -345,6 +329,8 @@ struct CodegenContext<'a> {\n     remark: Passes,\n     // Worker thread number\n     worker: usize,\n+    // Directory where incremental data is stored (if any)\n+    incremental: Option<PathBuf>,\n }\n \n impl<'a> CodegenContext<'a> {\n@@ -355,6 +341,7 @@ impl<'a> CodegenContext<'a> {\n             plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n             remark: sess.opts.cg.remark.clone(),\n             worker: 0,\n+            incremental: sess.opts.incremental.clone(),\n         }\n     }\n }\n@@ -390,7 +377,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n                                         cookie: c_uint) {\n     let HandlerFreeVars { cgcx, .. } = *(user as *const HandlerFreeVars);\n \n-    let msg = llvm::build_string(|s| llvm::LLVMWriteSMDiagnosticToString(diag, s))\n+    let msg = llvm::build_string(|s| llvm::LLVMRustWriteSMDiagnosticToString(diag, s))\n         .expect(\"non-UTF8 SMDiagnostic\");\n \n     report_inline_asm(cgcx, &msg[..], cookie);\n@@ -432,10 +419,11 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n // Unsafe due to LLVM calls.\n unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                                mtrans: ModuleTranslation,\n+                               mllvm: ModuleLlvm,\n                                config: ModuleConfig,\n                                output_names: OutputFilenames) {\n-    let llmod = mtrans.llmod;\n-    let llcx = mtrans.llcx;\n+    let llmod = mllvm.llmod;\n+    let llcx = mllvm.llcx;\n     let tm = config.tm;\n \n     // llcx doesn't outlive this function, so we can put this on the stack.\n@@ -445,7 +433,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     };\n     let fv = &fv as *const HandlerFreeVars as *mut c_void;\n \n-    llvm::LLVMSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, fv);\n+    llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, fv);\n     llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, fv);\n \n     let module_name = Some(&mtrans.name[..]);\n@@ -473,9 +461,9 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                 return false;\n             }\n             let pass_manager = match llvm::LLVMRustPassKind(pass) {\n-                llvm::SupportedPassKind::Function => fpm,\n-                llvm::SupportedPassKind::Module => mpm,\n-                llvm::SupportedPassKind::Unsupported => {\n+                llvm::PassKind::Function => fpm,\n+                llvm::PassKind::Module => mpm,\n+                llvm::PassKind::Other => {\n                     cgcx.handler.err(\"Encountered LLVM pass kind we can't handle\");\n                     return true\n                 },\n@@ -603,7 +591,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path,\n-                                  llvm::AssemblyFileType);\n+                                  llvm::FileType::AssemblyFile);\n             });\n             if config.emit_obj {\n                 llvm::LLVMDisposeModule(llmod);\n@@ -612,14 +600,15 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n         if write_obj {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &obj_out, llvm::ObjectFileType);\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &obj_out,\n+                                  llvm::FileType::ObjectFile);\n             });\n         }\n     });\n \n     if copy_bc_to_obj {\n         debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n-        if let Err(e) = fs::copy(&bc_out, &obj_out) {\n+        if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n             cgcx.handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n         }\n     }\n@@ -638,8 +627,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n pub fn cleanup_llvm(trans: &CrateTranslation) {\n     for module in trans.modules.iter() {\n         unsafe {\n-            llvm::LLVMDisposeModule(module.llmod);\n-            llvm::LLVMContextDispose(module.llcx);\n+            match module.source {\n+                ModuleSource::Translated(llvm) => {\n+                    llvm::LLVMDisposeModule(llvm.llmod);\n+                    llvm::LLVMContextDispose(llvm.llcx);\n+                }\n+                ModuleSource::Preexisting(_) => {\n+                }\n+            }\n         }\n     }\n }\n@@ -753,6 +748,23 @@ pub fn run_passes(sess: &Session,\n         run_work_multithreaded(sess, work_items, num_workers);\n     }\n \n+    // If in incr. comp. mode, preserve the `.o` files for potential re-use\n+    for mtrans in trans.modules.iter() {\n+        let mut files = vec![];\n+\n+        if modules_config.emit_obj {\n+            let path = crate_output.temp_path(OutputType::Object, Some(&mtrans.name));\n+            files.push((OutputType::Object, path));\n+        }\n+\n+        if modules_config.emit_bc {\n+            let path = crate_output.temp_path(OutputType::Bitcode, Some(&mtrans.name));\n+            files.push((OutputType::Bitcode, path));\n+        }\n+\n+        save_trans_partition(sess, &mtrans.name, mtrans.symbol_name_hash, &files);\n+    }\n+\n     // All codegen is finished.\n     unsafe {\n         llvm::LLVMRustDisposeTargetMachine(tm);\n@@ -926,10 +938,37 @@ fn build_work_item(sess: &Session,\n fn execute_work_item(cgcx: &CodegenContext,\n                      work_item: WorkItem) {\n     unsafe {\n-        optimize_and_codegen(cgcx,\n-                             work_item.mtrans,\n-                             work_item.config,\n-                             work_item.output_names);\n+        match work_item.mtrans.source {\n+            ModuleSource::Translated(mllvm) => {\n+                debug!(\"llvm-optimizing {:?}\", work_item.mtrans.name);\n+                optimize_and_codegen(cgcx,\n+                                     work_item.mtrans,\n+                                     mllvm,\n+                                     work_item.config,\n+                                     work_item.output_names);\n+            }\n+            ModuleSource::Preexisting(wp) => {\n+                let incremental = cgcx.incremental.as_ref().unwrap();\n+                let name = &work_item.mtrans.name;\n+                for (kind, saved_file) in wp.saved_files {\n+                    let obj_out = work_item.output_names.temp_path(kind, Some(name));\n+                    let source_file = incremental.join(&saved_file);\n+                    debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n+                           work_item.mtrans.name,\n+                           source_file,\n+                           obj_out.display());\n+                    match link_or_copy(&source_file, &obj_out) {\n+                        Ok(()) => { }\n+                        Err(err) => {\n+                            cgcx.handler.err(&format!(\"unable to copy {} to {}: {}\",\n+                                                      source_file.display(),\n+                                                      obj_out.display(),\n+                                                      err));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -965,6 +1004,8 @@ fn run_work_multithreaded(sess: &Session,\n         let mut tx = Some(tx);\n         futures.push(rx);\n \n+        let incremental = sess.opts.incremental.clone();\n+\n         thread::Builder::new().name(format!(\"codegen-{}\", i)).spawn(move || {\n             let diag_handler = Handler::with_emitter(true, false, box diag_emitter);\n \n@@ -976,6 +1017,7 @@ fn run_work_multithreaded(sess: &Session,\n                 plugin_passes: plugin_passes,\n                 remark: remark,\n                 worker: i,\n+                incremental: incremental,\n             };\n \n             loop {\n@@ -1049,7 +1091,7 @@ pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n     // reasonable defaults and prepare it to actually populate the pass\n     // manager.\n     let builder = llvm::LLVMPassManagerBuilderCreate();\n-    let opt_level = config.opt_level.unwrap_or(llvm::CodeGenLevelNone);\n+    let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n     let opt_size = config.opt_size.unwrap_or(llvm::CodeGenOptSizeNone);\n     let inline_threshold = config.inline_threshold;\n \n@@ -1073,7 +1115,7 @@ pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n         (_, _, Some(t)) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, t as u32);\n         }\n-        (llvm::CodeGenLevelAggressive, _, _) => {\n+        (llvm::CodeGenOptLevel::Aggressive, _, _) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 275);\n         }\n         (_, llvm::CodeGenOptSizeDefault, _) => {\n@@ -1082,15 +1124,18 @@ pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n         (_, llvm::CodeGenOptSizeAggressive, _) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 25);\n         }\n-        (llvm::CodeGenLevelNone, _, _) => {\n+        (llvm::CodeGenOptLevel::None, _, _) => {\n             llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n         }\n-        (llvm::CodeGenLevelLess, _, _) => {\n+        (llvm::CodeGenOptLevel::Less, _, _) => {\n             llvm::LLVMRustAddAlwaysInlinePass(builder, true);\n         }\n-        (llvm::CodeGenLevelDefault, _, _) => {\n+        (llvm::CodeGenOptLevel::Default, _, _) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n         }\n+        (llvm::CodeGenOptLevel::Other, _, _) => {\n+            bug!(\"CodeGenOptLevel::Other selected\")\n+        }\n     }\n \n     f(builder);"}, {"sha": "1077cb296c1ac307e2e5a07535ed1eaf11166825", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 171, "deletions": 61, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -26,8 +26,11 @@\n #![allow(non_camel_case_types)]\n \n use super::CrateTranslation;\n+use super::ModuleLlvm;\n+use super::ModuleSource;\n use super::ModuleTranslation;\n \n+use assert_module_sources;\n use back::link;\n use back::linker::LinkerInfo;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n@@ -40,7 +43,7 @@ use rustc::ty::subst::{self, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use rustc::mir::mir_map::MirMap;\n@@ -89,13 +92,14 @@ use value::Value;\n use Disr;\n use util::common::indenter;\n use util::sha2::Sha256;\n-use util::nodemap::{NodeMap, NodeSet};\n+use util::nodemap::{NodeMap, NodeSet, FnvHashSet};\n \n use arena::TypedArena;\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n+use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::ptr;\n use std::rc::Rc;\n use std::str;\n@@ -1914,9 +1918,9 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n-    let instance = inline::maybe_inline_instance(ccx, instance);\n+    let local_instance = inline::maybe_inline_instance(ccx, instance);\n \n-    let fn_node_id = ccx.tcx().map.as_local_node_id(instance.def).unwrap();\n+    let fn_node_id = ccx.tcx().map.as_local_node_id(local_instance.def).unwrap();\n \n     let _s = StatRecorder::new(ccx, ccx.tcx().node_path_str(fn_node_id));\n     debug!(\"trans_instance(instance={:?})\", instance);\n@@ -1932,7 +1936,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     let sig = ccx.tcx().normalize_associated_type(&sig);\n     let abi = fn_ty.fn_abi();\n \n-    let lldecl = match ccx.instances().borrow().get(&instance) {\n+    let lldecl = match ccx.instances().borrow().get(&local_instance) {\n         Some(&val) => val,\n         None => bug!(\"Instance `{:?}` not already declared\", instance)\n     };\n@@ -2132,7 +2136,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n \n     let instance = Instance::mono(ccx.shared(), main_def_id);\n \n-    if !ccx.codegen_unit().items.contains_key(&TransItem::Fn(instance)) {\n+    if !ccx.codegen_unit().contains_item(&TransItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n         return;\n@@ -2256,12 +2260,28 @@ fn write_metadata(cx: &SharedCrateContext,\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n-fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n+fn internalize_symbols<'a, 'tcx>(sess: &Session,\n+                                 ccxs: &CrateContextList<'a, 'tcx>,\n+                                 symbol_map: &SymbolMap<'tcx>,\n+                                 reachable: &FnvHashSet<&str>) {\n+    let scx = ccxs.shared();\n+    let tcx = scx.tcx();\n+\n+    // In incr. comp. mode, we can't necessarily see all refs since we\n+    // don't generate LLVM IR for reused modules, so skip this\n+    // step. Later we should get smarter.\n+    if sess.opts.debugging_opts.incremental.is_some() {\n+        return;\n+    }\n+\n+    // 'unsafe' because we are holding on to CStr's from the LLVM module within\n+    // this block.\n     unsafe {\n-        let mut declared = HashSet::new();\n+        let mut referenced_somewhere = FnvHashSet();\n \n-        // Collect all external declarations in all compilation units.\n-        for ccx in cx.iter() {\n+        // Collect all symbols that need to stay externally visible because they\n+        // are referenced via a declaration in some other codegen unit.\n+        for ccx in ccxs.iter_need_trans() {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n                 // We only care about external declarations (not definitions)\n@@ -2270,39 +2290,68 @@ fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n                 let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n \n                 if is_decl || is_available_externally {\n-                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                    declared.insert(name);\n+                    let symbol_name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+                    referenced_somewhere.insert(symbol_name);\n                 }\n             }\n         }\n \n+        // Also collect all symbols for which we cannot adjust linkage, because\n+        // it is fixed by some directive in the source code (e.g. #[no_mangle]).\n+        let linkage_fixed_explicitly: FnvHashSet<_> = scx\n+            .translation_items()\n+            .borrow()\n+            .iter()\n+            .cloned()\n+            .filter(|trans_item|{\n+                let def_id = match *trans_item {\n+                    TransItem::DropGlue(..) => {\n+                        return false\n+                    },\n+                    TransItem::Fn(ref instance) => {\n+                        instance.def\n+                    }\n+                    TransItem::Static(node_id) => {\n+                        tcx.map.local_def_id(node_id)\n+                    }\n+                };\n+\n+                trans_item.explicit_linkage(tcx).is_some() ||\n+                attr::contains_extern_indicator(tcx.sess.diagnostic(),\n+                                                &tcx.get_attrs(def_id))\n+            })\n+            .map(|trans_item| symbol_map.get_or_compute(scx, trans_item))\n+            .collect();\n+\n         // Examine each external definition.  If the definition is not used in\n         // any other compilation unit, and is not reachable from other crates,\n         // then give it internal linkage.\n-        for ccx in cx.iter() {\n+        for ccx in ccxs.iter_need_trans() {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n \n                 let is_externally_visible = (linkage == llvm::ExternalLinkage as c_uint) ||\n                                             (linkage == llvm::LinkOnceODRLinkage as c_uint) ||\n                                             (linkage == llvm::WeakODRLinkage as c_uint);\n-                let is_definition = llvm::LLVMIsDeclaration(val) != 0;\n+                let is_definition = llvm::LLVMIsDeclaration(val) == 0;\n \n                 // If this is a definition (as opposed to just a declaration)\n                 // and externally visible, check if we can internalize it\n                 if is_definition && is_externally_visible {\n                     let name_cstr = CStr::from_ptr(llvm::LLVMGetValueName(val));\n                     let name_str = name_cstr.to_str().unwrap();\n+                    let name_cow = Cow::Borrowed(name_str);\n \n-                    let is_referenced_somewhere = declared.contains(&name_cstr);\n-                    let is_reachable = reachable.contains(name_str);\n+                    let is_referenced_somewhere = referenced_somewhere.contains(&name_cstr);\n+                    let is_reachable = reachable.contains(&name_str);\n+                    let has_fixed_linkage = linkage_fixed_explicitly.contains(&name_cow);\n \n-                    if !is_referenced_somewhere && !is_reachable {\n-                        llvm::SetLinkage(val, llvm::InternalLinkage);\n-                        llvm::SetDLLStorageClass(val, llvm::DefaultStorageClass);\n+                    if !is_referenced_somewhere && !is_reachable && !has_fixed_linkage {\n+                        llvm::LLVMSetLinkage(val, llvm::InternalLinkage);\n+                        llvm::LLVMSetDLLStorageClass(val,\n+                                                     llvm::DLLStorageClass::Default);\n                         llvm::UnsetComdat(val);\n                     }\n-\n                 }\n             }\n         }\n@@ -2325,7 +2374,7 @@ fn create_imps(cx: &CrateContextList) {\n         \"\\x01__imp_\"\n     };\n     unsafe {\n-        for ccx in cx.iter() {\n+        for ccx in cx.iter_need_trans() {\n             let exported: Vec<_> = iter_globals(ccx.llmod())\n                                        .filter(|&val| {\n                                            llvm::LLVMGetLinkage(val) ==\n@@ -2345,7 +2394,7 @@ fn create_imps(cx: &CrateContextList) {\n                                               imp_name.as_ptr() as *const _);\n                 let init = llvm::LLVMConstBitCast(val, i8p_ty.to_ref());\n                 llvm::LLVMSetInitializer(imp, init);\n-                llvm::SetLinkage(imp, llvm::ExternalLinkage);\n+                llvm::LLVMSetLinkage(imp, llvm::ExternalLinkage);\n             }\n         }\n     }\n@@ -2477,8 +2526,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let metadata_module = ModuleTranslation {\n         name: \"metadata\".to_string(),\n-        llcx: shared_ccx.metadata_llcx(),\n-        llmod: shared_ccx.metadata_llmod(),\n+        symbol_name_hash: 0, // we always rebuild metadata, at least for now\n+        source: ModuleSource::Translated(ModuleLlvm {\n+            llcx: shared_ccx.metadata_llcx(),\n+            llmod: shared_ccx.metadata_llmod(),\n+        }),\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n@@ -2488,17 +2540,34 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let symbol_map = Rc::new(symbol_map);\n \n+    let previous_work_products = trans_reuse_previous_work_products(tcx,\n+                                                                    &codegen_units,\n+                                                                    &symbol_map);\n+\n     let crate_context_list = CrateContextList::new(&shared_ccx,\n                                                    codegen_units,\n+                                                   previous_work_products,\n                                                    symbol_map.clone());\n-    let modules = crate_context_list.iter()\n-        .map(|ccx| ModuleTranslation {\n-            name: String::from(&ccx.codegen_unit().name[..]),\n-            llcx: ccx.llcx(),\n-            llmod: ccx.llmod()\n+    let modules: Vec<_> = crate_context_list.iter_all()\n+        .map(|ccx| {\n+            let source = match ccx.previous_work_product() {\n+                Some(buf) => ModuleSource::Preexisting(buf.clone()),\n+                None => ModuleSource::Translated(ModuleLlvm {\n+                    llcx: ccx.llcx(),\n+                    llmod: ccx.llmod(),\n+                }),\n+            };\n+\n+            ModuleTranslation {\n+                name: String::from(ccx.codegen_unit().name()),\n+                symbol_name_hash: ccx.codegen_unit().compute_symbol_name_hash(tcx, &symbol_map),\n+                source: source,\n+            }\n         })\n         .collect();\n \n+    assert_module_sources::assert_module_sources(tcx, &modules);\n+\n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.no_trans {\n         let linker_info = LinkerInfo::new(&shared_ccx, &[]);\n@@ -2514,41 +2583,44 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     // Instantiate translation items without filling out definitions yet...\n-    for ccx in crate_context_list.iter() {\n-        let trans_items = ccx.codegen_unit()\n-                             .items_in_deterministic_order(tcx, &symbol_map);\n+    for ccx in crate_context_list.iter_need_trans() {\n+        let cgu = ccx.codegen_unit();\n+        let trans_items = cgu.items_in_deterministic_order(tcx, &symbol_map);\n \n-        for (trans_item, linkage) in trans_items {\n-            trans_item.predefine(&ccx, linkage);\n-        }\n+        tcx.dep_graph.with_task(cgu.work_product_dep_node(), || {\n+            for (trans_item, linkage) in trans_items {\n+                trans_item.predefine(&ccx, linkage);\n+            }\n+        });\n     }\n \n     // ... and now that we have everything pre-defined, fill out those definitions.\n-    for ccx in crate_context_list.iter() {\n-        let trans_items = ccx.codegen_unit()\n-                             .items_in_deterministic_order(tcx, &symbol_map);\n-\n-        for (trans_item, _) in trans_items {\n-           trans_item.define(&ccx);\n-        }\n+    for ccx in crate_context_list.iter_need_trans() {\n+        let cgu = ccx.codegen_unit();\n+        let trans_items = cgu.items_in_deterministic_order(tcx, &symbol_map);\n+        tcx.dep_graph.with_task(cgu.work_product_dep_node(), || {\n+            for (trans_item, _) in trans_items {\n+                trans_item.define(&ccx);\n+            }\n \n-        // If this codegen unit contains the main function, also create the\n-        // wrapper here\n-        maybe_create_entry_wrapper(&ccx);\n+            // If this codegen unit contains the main function, also create the\n+            // wrapper here\n+            maybe_create_entry_wrapper(&ccx);\n \n-        // Run replace-all-uses-with for statics that need it\n-        for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n-            unsafe {\n-                let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n-                llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n-                llvm::LLVMDeleteGlobal(old_g);\n+            // Run replace-all-uses-with for statics that need it\n+            for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n+                unsafe {\n+                    let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n+                    llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n+                    llvm::LLVMDeleteGlobal(old_g);\n+                }\n             }\n-        }\n \n-        // Finalize debuginfo\n-        if ccx.sess().opts.debuginfo != NoDebugInfo {\n-            debuginfo::finalize(&ccx);\n-        }\n+            // Finalize debuginfo\n+            if ccx.sess().opts.debuginfo != NoDebugInfo {\n+                debuginfo::finalize(&ccx);\n+            }\n+        });\n     }\n \n     symbol_names_test::report_symbol_names(&shared_ccx);\n@@ -2616,8 +2688,14 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }));\n     }\n \n-    internalize_symbols(&crate_context_list,\n-                        &reachable_symbols.iter().map(|x| &x[..]).collect());\n+    time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n+        internalize_symbols(sess,\n+                            &crate_context_list,\n+                            &symbol_map,\n+                            &reachable_symbols.iter()\n+                                              .map(|s| &s[..])\n+                                              .collect())\n+    });\n \n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n@@ -2637,6 +2715,38 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+/// For each CGU, identify if we can reuse an existing object file (or\n+/// maybe other context).\n+fn trans_reuse_previous_work_products(tcx: TyCtxt,\n+                                      codegen_units: &[CodegenUnit],\n+                                      symbol_map: &SymbolMap)\n+                                      -> Vec<Option<WorkProduct>> {\n+    debug!(\"trans_reuse_previous_work_products()\");\n+    codegen_units\n+        .iter()\n+        .map(|cgu| {\n+            let id = cgu.work_product_id();\n+\n+            let hash = cgu.compute_symbol_name_hash(tcx, symbol_map);\n+\n+            debug!(\"trans_reuse_previous_work_products: id={:?} hash={}\", id, hash);\n+\n+            if let Some(work_product) = tcx.dep_graph.previous_work_product(&id) {\n+                if work_product.input_hash == hash {\n+                    debug!(\"trans_reuse_previous_work_products: reusing {:?}\", work_product);\n+                    return Some(work_product);\n+                } else {\n+                    debug!(\"trans_reuse_previous_work_products: \\\n+                            not reusing {:?} because hash changed to {:?}\",\n+                           work_product, hash);\n+                }\n+            }\n+\n+            None\n+        })\n+        .collect()\n+}\n+\n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n                                                      -> (Vec<CodegenUnit<'tcx>>, SymbolMap<'tcx>) {\n     let time_passes = scx.sess().time_passes();\n@@ -2697,10 +2807,10 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         let mut item_to_cgus = HashMap::new();\n \n         for cgu in &codegen_units {\n-            for (&trans_item, &linkage) in &cgu.items {\n+            for (&trans_item, &linkage) in cgu.items() {\n                 item_to_cgus.entry(trans_item)\n                             .or_insert(Vec::new())\n-                            .push((cgu.name.clone(), linkage));\n+                            .push((cgu.name().clone(), linkage));\n             }\n         }\n "}, {"sha": "8cd47bd148d0cf597e5241a65bc6b0b511a7635f", "filename": "src/librustc_trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuild.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -12,7 +12,7 @@\n #![allow(non_snake_case)]\n \n use llvm;\n-use llvm::{AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n+use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate};\n use llvm::{ValueRef, BasicBlockRef};\n use common::*;\n@@ -1117,7 +1117,7 @@ pub fn AtomicCmpXchg(cx: Block, dst: ValueRef,\n                      weak: llvm::Bool) -> ValueRef {\n     B(cx).atomic_cmpxchg(dst, cmp, src, order, failure_order, weak)\n }\n-pub fn AtomicRMW(cx: Block, op: AtomicBinOp,\n+pub fn AtomicRMW(cx: Block, op: AtomicRmwBinOp,\n                  dst: ValueRef, src: ValueRef,\n                  order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_rmw(op, dst, src, order)"}, {"sha": "90f96af5496915527d9a71c0271dc2b61b64056b", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_code)] // FFI wrappers\n \n use llvm;\n-use llvm::{AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n+use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use base;\n@@ -503,8 +503,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         unsafe {\n             let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n             let align = llalign_of_pref(self.ccx, ty.element_type());\n-            llvm::LLVMBuildAtomicLoad(self.llbuilder, ptr, noname(), order,\n-                                      align as c_uint)\n+            llvm::LLVMRustBuildAtomicLoad(self.llbuilder, ptr, noname(), order,\n+                                          align as c_uint)\n         }\n     }\n \n@@ -565,7 +565,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         unsafe {\n             let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n             let align = llalign_of_pref(self.ccx, ty.element_type());\n-            llvm::LLVMBuildAtomicStore(self.llbuilder, val, ptr, order, align as c_uint);\n+            llvm::LLVMRustBuildAtomicStore(self.llbuilder, val, ptr, order, align as c_uint);\n         }\n     }\n \n@@ -840,8 +840,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"Asm Output Type: {:?}\", output);\n         let fty = Type::func(&argtys[..], &output);\n         unsafe {\n-            let v = llvm::LLVMInlineAsm(\n-                fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n+            let v = llvm::LLVMRustInlineAsm(\n+                fty.to_ref(), asm, cons, volatile, alignstack, dia);\n             self.call(v, inputs, None)\n         }\n     }\n@@ -1083,11 +1083,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                          failure_order: AtomicOrdering,\n                          weak: llvm::Bool) -> ValueRef {\n         unsafe {\n-            llvm::LLVMBuildAtomicCmpXchg(self.llbuilder, dst, cmp, src,\n+            llvm::LLVMRustBuildAtomicCmpXchg(self.llbuilder, dst, cmp, src,\n                                          order, failure_order, weak)\n         }\n     }\n-    pub fn atomic_rmw(&self, op: AtomicBinOp,\n+    pub fn atomic_rmw(&self, op: AtomicRmwBinOp,\n                      dst: ValueRef, src: ValueRef,\n                      order: AtomicOrdering) -> ValueRef {\n         unsafe {\n@@ -1097,7 +1097,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     pub fn atomic_fence(&self, order: AtomicOrdering, scope: SynchronizationScope) {\n         unsafe {\n-            llvm::LLVMBuildAtomicFence(self.llbuilder, order, scope);\n+            llvm::LLVMRustBuildAtomicFence(self.llbuilder, order, scope);\n         }\n     }\n }"}, {"sha": "e53a5edfc668519f2f305e8f63687419c7ebb83a", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -181,6 +181,41 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     llfn\n }\n \n+fn translating_closure_body_via_mir_will_fail(ccx: &CrateContext,\n+                                              closure_def_id: DefId)\n+                                              -> bool {\n+    let default_to_mir = ccx.sess().opts.debugging_opts.orbit;\n+    let invert = if default_to_mir { \"rustc_no_mir\" } else { \"rustc_mir\" };\n+    let use_mir = default_to_mir ^ ccx.tcx().has_attr(closure_def_id, invert);\n+\n+    !use_mir\n+}\n+\n+pub fn trans_closure_body_via_mir<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                            closure_def_id: DefId,\n+                                            closure_substs: ty::ClosureSubsts<'tcx>) {\n+    use syntax::ast::DUMMY_NODE_ID;\n+    use syntax_pos::DUMMY_SP;\n+    use syntax::ptr::P;\n+\n+    trans_closure_expr(Dest::Ignore(ccx),\n+                       &hir::FnDecl {\n+                           inputs: P::new(),\n+                           output: hir::NoReturn(DUMMY_SP),\n+                           variadic: false\n+                       },\n+                       &hir::Block {\n+                           stmts: P::new(),\n+                           expr: None,\n+                           id: DUMMY_NODE_ID,\n+                           rules: hir::DefaultBlock,\n+                           span: DUMMY_SP\n+                       },\n+                       DUMMY_NODE_ID,\n+                       closure_def_id,\n+                       closure_substs);\n+}\n+\n pub enum Dest<'a, 'tcx: 'a> {\n     SaveIn(Block<'a, 'tcx>, ValueRef),\n     Ignore(&'a CrateContext<'a, 'tcx>)\n@@ -213,8 +248,15 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // If we have not done so yet, translate this closure's body\n     if  !ccx.instances().borrow().contains_key(&instance) {\n         let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n-        llvm::SetLinkage(llfn, llvm::WeakODRLinkage);\n-        llvm::SetUniqueComdat(ccx.llmod(), llfn);\n+\n+        unsafe {\n+            if ccx.sess().target.target.options.allows_weak_linkage {\n+                llvm::LLVMSetLinkage(llfn, llvm::WeakODRLinkage);\n+                llvm::SetUniqueComdat(ccx.llmod(), llfn);\n+            } else {\n+                llvm::LLVMSetLinkage(llfn, llvm::InternalLinkage);\n+            }\n+        }\n \n         // set an inline hint for all closures\n         attributes::inline(llfn, attributes::InlineAttr::Hint);\n@@ -296,6 +338,39 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     // If this is a closure, redirect to it.\n     let llfn = get_or_create_closure_declaration(ccx, closure_def_id, substs);\n \n+    // If weak linkage is not allowed, we have to make sure that a local,\n+    // private copy of the closure is available in this codegen unit\n+    if !ccx.sess().target.target.options.allows_weak_linkage &&\n+       !ccx.sess().opts.single_codegen_unit() {\n+\n+        if let Some(node_id) = ccx.tcx().map.as_local_node_id(closure_def_id) {\n+            // If the closure is defined in the local crate, we can always just\n+            // translate it.\n+            let (decl, body) = match ccx.tcx().map.expect_expr(node_id).node {\n+                hir::ExprClosure(_, ref decl, ref body, _) => (decl, body),\n+                _ => { unreachable!() }\n+            };\n+\n+            trans_closure_expr(Dest::Ignore(ccx),\n+                               decl,\n+                               body,\n+                               node_id,\n+                               closure_def_id,\n+                               substs);\n+        } else {\n+            // If the closure is defined in an upstream crate, we can only\n+            // translate it if MIR-trans is active.\n+\n+            if translating_closure_body_via_mir_will_fail(ccx, closure_def_id) {\n+                ccx.sess().fatal(\"You have run into a known limitation of the \\\n+                                  MingW toolchain. Either compile with -Zorbit or \\\n+                                  with -Ccodegen-units=1 to work around it.\");\n+            }\n+\n+            trans_closure_body_via_mir(ccx, closure_def_id, substs);\n+        }\n+    }\n+\n     // If the closure is a Fn closure, but a FnOnce is needed (etc),\n     // then adapt the self type\n     let llfn_closure_kind = ccx.tcx().closure_kind(closure_def_id);"}, {"sha": "a1783e9c0a3829960035925d7f39d6183b28f4cb", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -980,7 +980,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n         });\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n-        llvm::SetLinkage(g, llvm::InternalLinkage);\n+        llvm::LLVMSetLinkage(g, llvm::InternalLinkage);\n \n         cx.const_cstr_cache().borrow_mut().insert(s, g);\n         g\n@@ -1235,7 +1235,6 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      inlined_vid: ast::NodeId)\n                                      -> ty::VariantDef<'tcx>\n {\n-\n     let ctor_ty = ccx.tcx().node_id_to_type(inlined_vid);\n     debug!(\"inlined_variant_def: ctor_ty={:?} inlined_vid={:?}\", ctor_ty,\n            inlined_vid);\n@@ -1245,13 +1244,18 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }), ..}) => ty,\n         _ => ctor_ty\n     }.ty_adt_def().unwrap();\n-    let inlined_vid_def_id = ccx.tcx().map.local_def_id(inlined_vid);\n-    adt_def.variants.iter().find(|v| {\n-        inlined_vid_def_id == v.did ||\n-            ccx.external().borrow().get(&v.did) == Some(&Some(inlined_vid))\n-    }).unwrap_or_else(|| {\n-        bug!(\"no variant for {:?}::{}\", adt_def, inlined_vid)\n-    })\n+    let variant_def_id = if ccx.tcx().map.is_inlined(inlined_vid) {\n+        ccx.defid_for_inlined_node(inlined_vid).unwrap()\n+    } else {\n+        ccx.tcx().map.local_def_id(inlined_vid)\n+    };\n+\n+    adt_def.variants\n+           .iter()\n+           .find(|v| variant_def_id == v.did)\n+           .unwrap_or_else(|| {\n+                bug!(\"no variant for {:?}::{}\", adt_def, inlined_vid)\n+            })\n }\n \n // To avoid UB from LLVM, these two functions mask RHS with an"}, {"sha": "7afb5257258ec38f5c5b26100e7ececad4bbff9f", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -10,11 +10,11 @@\n \n \n use llvm;\n-use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n+use llvm::{SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::const_qualif::ConstQualif;\n use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, lookup_const_by_id, ErrKind};\n-use rustc_const_eval::eval_repeat_count;\n+use rustc_const_eval::{eval_length, report_const_eval_err, note_const_eval_err};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n@@ -44,7 +44,6 @@ use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n use rustc::hir;\n \n use std::ffi::{CStr, CString};\n-use std::borrow::Cow;\n use libc::c_uint;\n use syntax::ast::{self, LitKind};\n use syntax::attr::{self, AttrMetaMethods};\n@@ -126,7 +125,7 @@ pub fn addr_of_mut(ccx: &CrateContext,\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetAlignment(gv, align);\n-        SetLinkage(gv, InternalLinkage);\n+        llvm::LLVMSetLinkage(gv, InternalLinkage);\n         SetUnnamedAddr(gv, true);\n         gv\n     }\n@@ -250,10 +249,11 @@ impl ConstEvalFailure {\n             Compiletime(e) => e,\n         }\n     }\n-    pub fn description(&self) -> Cow<str> {\n+\n+    pub fn as_inner(&self) -> &ConstEvalErr {\n         match self {\n-            &Runtime(ref e) => e.description(),\n-            &Compiletime(ref e) => e.description(),\n+            &Runtime(ref e) => e,\n+            &Compiletime(ref e) => e,\n         }\n     }\n }\n@@ -274,7 +274,7 @@ fn get_const_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n     match get_const_expr_as_global(ccx, expr, ConstQualif::empty(), empty_substs, TrueConst::Yes) {\n         Err(Runtime(err)) => {\n-            ccx.tcx().sess.span_err(expr.span, &err.description());\n+            report_const_eval_err(ccx.tcx(), &err, expr.span, \"expression\").emit();\n             Err(Compiletime(err))\n         },\n         other => other,\n@@ -526,12 +526,15 @@ pub fn const_err<T>(cx: &CrateContext,\n         (Ok(x), _) => Ok(x),\n         (Err(err), TrueConst::Yes) => {\n             let err = ConstEvalErr{ span: span, kind: err };\n-            cx.tcx().sess.span_err(span, &err.description());\n+            report_const_eval_err(cx.tcx(), &err, span, \"expression\").emit();\n             Err(Compiletime(err))\n         },\n         (Err(err), TrueConst::No) => {\n             let err = ConstEvalErr{ span: span, kind: err };\n-            cx.tcx().sess.span_warn(span, &err.description());\n+            let mut diag = cx.tcx().sess.struct_span_warn(\n+                span, \"this expression will panic at run-time\");\n+            note_const_eval_err(cx.tcx(), &err, span, \"expression\", &mut diag);\n+            diag.emit();\n             Err(Runtime(err))\n         },\n     }\n@@ -634,10 +637,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 hir::BiEq | hir::BiNe | hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe => {\n                     if is_float {\n                         let cmp = base::bin_op_to_fcmp_predicate(b.node);\n-                        ConstFCmp(cmp, te1, te2)\n+                        llvm::LLVMConstFCmp(cmp, te1, te2)\n                     } else {\n                         let cmp = base::bin_op_to_icmp_predicate(b.node, signed);\n-                        ConstICmp(cmp, te1, te2)\n+                        llvm::LLVMConstICmp(cmp, te1, te2)\n                     }\n                 },\n             } } // unsafe { match b.node {\n@@ -875,7 +878,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprRepeat(ref elem, ref count) => {\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = eval_repeat_count(cx.tcx(), count);\n+            let n = eval_length(cx.tcx(), count, \"repeat count\").unwrap();\n             let unit_val = const_expr(cx, &elem, param_substs, fn_args, trueconst)?.0;\n             let vs = vec![unit_val; n];\n             if val_ty(unit_val) != llunitty {\n@@ -1023,10 +1026,10 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                              .get(TransItem::Static(id))\n                              .expect(\"Local statics should always be in the SymbolMap\");\n                 // Make sure that this is never executed for something inlined.\n-                assert!(!ccx.external_srcs().borrow().contains_key(&id));\n+                assert!(!ccx.tcx().map.is_inlined(id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n-                                                         .items\n+                                                         .items()\n                                                          .contains_key(&TransItem::Static(id));\n                 if defined_in_current_codegen_unit {\n                     if declare::get_declared_value(ccx, sym).is_none() {\n@@ -1069,7 +1072,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                     unsafe {\n                         // Declare a symbol `foo` with the desired linkage.\n                         let g1 = declare::declare_global(ccx, &sym, llty2);\n-                        llvm::SetLinkage(g1, linkage);\n+                        llvm::LLVMSetLinkage(g1, linkage);\n \n                         // Declare an internal global `extern_with_linkage_foo` which\n                         // is initialized with the address of `foo`.  If `foo` is\n@@ -1083,7 +1086,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                             ccx.sess().span_fatal(span,\n                                 &format!(\"symbol `{}` is already defined\", &sym))\n                         });\n-                        llvm::SetLinkage(g2, llvm::InternalLinkage);\n+                        llvm::LLVMSetLinkage(g2, llvm::InternalLinkage);\n                         llvm::LLVMSetInitializer(g2, g1);\n                         g2\n                     }\n@@ -1123,7 +1126,9 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n             }\n         }\n         if ccx.use_dll_storage_attrs() {\n-            llvm::SetDLLStorageClass(g, llvm::DLLImportStorageClass);\n+            unsafe {\n+                llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+            }\n         }\n         g\n     };\n@@ -1179,7 +1184,7 @@ pub fn trans_static(ccx: &CrateContext,\n             let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(datum.val));\n             let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n             llvm::LLVMSetValueName(datum.val, empty_string.as_ptr());\n-            let new_g = llvm::LLVMGetOrInsertGlobal(\n+            let new_g = llvm::LLVMRustGetOrInsertGlobal(\n                 ccx.llmod(), name_string.as_ptr(), val_llty.to_ref());\n             // To avoid breaking any invariants, we leave around the old\n             // global for the moment; we'll replace all references to it"}, {"sha": "246c037c030b21272b88b3a50b5e6d73858828cb", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 116, "deletions": 31, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -10,7 +10,7 @@\n \n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef, BuilderRef};\n-use rustc::dep_graph::{DepNode, DepTrackingMap, DepTrackingMapConfig};\n+use rustc::dep_graph::{DepNode, DepTrackingMap, DepTrackingMapConfig, WorkProduct};\n use middle::cstore::LinkMeta;\n use rustc::hir::def::ExportMap;\n use rustc::hir::def_id::DefId;\n@@ -34,9 +34,10 @@ use rustc::ty::subst::{Substs, VecPerParamSpace};\n use rustc::ty::{self, Ty, TyCtxt};\n use session::config::NoDebugInfo;\n use session::Session;\n+use session::config;\n use symbol_map::SymbolMap;\n use util::sha2::Sha256;\n-use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n@@ -95,16 +96,12 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n+    previous_work_product: Option<WorkProduct>,\n     tn: TypeNames, // FIXME: This seems to be largely unused.\n     codegen_unit: CodegenUnit<'tcx>,\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n     drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n-    /// Track mapping of external ids to local items imported for inlining\n-    external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n-    /// Backwards version of the `external` map (inlined items to where they\n-    /// came from)\n-    external_srcs: RefCell<NodeMap<DefId>>,\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<usize>>,\n@@ -198,24 +195,39 @@ pub struct CrateContextList<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n-\n     pub fn new(shared_ccx: &'a SharedCrateContext<'a, 'tcx>,\n                codegen_units: Vec<CodegenUnit<'tcx>>,\n+               previous_work_products: Vec<Option<WorkProduct>>,\n                symbol_map: Rc<SymbolMap<'tcx>>)\n                -> CrateContextList<'a, 'tcx> {\n         CrateContextList {\n             shared: shared_ccx,\n-            local_ccxs: codegen_units.into_iter().map(|codegen_unit| {\n-                LocalCrateContext::new(shared_ccx, codegen_unit, symbol_map.clone())\n+            local_ccxs: codegen_units.into_iter().zip(previous_work_products).map(|(cgu, wp)| {\n+                LocalCrateContext::new(shared_ccx, cgu, wp, symbol_map.clone())\n             }).collect()\n         }\n     }\n \n-    pub fn iter<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n+    /// Iterate over all crate contexts, whether or not they need\n+    /// translation.  That is, whether or not a `.o` file is available\n+    /// for re-use from a previous incr. comp.).\n+    pub fn iter_all<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n         CrateContextIterator {\n             shared: self.shared,\n             index: 0,\n-            local_ccxs: &self.local_ccxs[..]\n+            local_ccxs: &self.local_ccxs[..],\n+            filter_to_previous_work_product_unavail: false,\n+        }\n+    }\n+\n+    /// Iterator over all CCX that need translation (cannot reuse results from\n+    /// previous incr. comp.).\n+    pub fn iter_need_trans<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n+        CrateContextIterator {\n+            shared: self.shared,\n+            index: 0,\n+            local_ccxs: &self.local_ccxs[..],\n+            filter_to_previous_work_product_unavail: true,\n         }\n     }\n \n@@ -239,24 +251,38 @@ pub struct CrateContextIterator<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n     local_ccxs: &'a [LocalCrateContext<'tcx>],\n     index: usize,\n+\n+    /// if true, only return results where `previous_work_product` is none\n+    filter_to_previous_work_product_unavail: bool,\n }\n \n impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n     type Item = CrateContext<'a, 'tcx>;\n \n     fn next(&mut self) -> Option<CrateContext<'a, 'tcx>> {\n-        if self.index >= self.local_ccxs.len() {\n-            return None;\n-        }\n+        loop {\n+            if self.index >= self.local_ccxs.len() {\n+                return None;\n+            }\n \n-        let index = self.index;\n-        self.index += 1;\n+            let index = self.index;\n+            self.index += 1;\n \n-        Some(CrateContext {\n-            shared: self.shared,\n-            index: index,\n-            local_ccxs: self.local_ccxs,\n-        })\n+            let ccx = CrateContext {\n+                shared: self.shared,\n+                index: index,\n+                local_ccxs: self.local_ccxs,\n+            };\n+\n+            if\n+                self.filter_to_previous_work_product_unavail &&\n+                ccx.previous_work_product().is_some()\n+            {\n+                continue;\n+            }\n+\n+            return Some(ccx);\n+        }\n     }\n }\n \n@@ -292,6 +318,36 @@ impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n     }\n }\n \n+pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n+    let reloc_model_arg = match sess.opts.cg.relocation_model {\n+        Some(ref s) => &s[..],\n+        None => &sess.target.target.options.relocation_model[..],\n+    };\n+\n+    match ::back::write::RELOC_MODEL_ARGS.iter().find(\n+        |&&arg| arg.0 == reloc_model_arg) {\n+        Some(x) => x.1,\n+        _ => {\n+            sess.err(&format!(\"{:?} is not a valid relocation mode\",\n+                             sess.opts\n+                                 .cg\n+                                 .code_model));\n+            sess.abort_if_errors();\n+            bug!();\n+        }\n+    }\n+}\n+\n+fn is_any_library(sess: &Session) -> bool {\n+    sess.crate_types.borrow().iter().any(|ty| {\n+        *ty != config::CrateTypeExecutable\n+    })\n+}\n+\n+pub fn is_pie_binary(sess: &Session) -> bool {\n+    !is_any_library(sess) && get_reloc_model(sess) == llvm::RelocMode::PIC\n+}\n+\n unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n     let llcx = llvm::LLVMContextCreate();\n     let mod_name = CString::new(mod_name).unwrap();\n@@ -307,7 +363,25 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n         let data_layout = str::from_utf8(CStr::from_ptr(data_layout).to_bytes())\n             .ok().expect(\"got a non-UTF8 data-layout from LLVM\");\n \n-        if sess.target.target.data_layout != data_layout {\n+        // Unfortunately LLVM target specs change over time, and right now we\n+        // don't have proper support to work with any more than one\n+        // `data_layout` than the one that is in the rust-lang/rust repo. If\n+        // this compiler is configured against a custom LLVM, we may have a\n+        // differing data layout, even though we should update our own to use\n+        // that one.\n+        //\n+        // As an interim hack, if CFG_LLVM_ROOT is not an empty string then we\n+        // disable this check entirely as we may be configured with something\n+        // that has a different target layout.\n+        //\n+        // Unsure if this will actually cause breakage when rustc is configured\n+        // as such.\n+        //\n+        // FIXME(#34960)\n+        let cfg_llvm_root = option_env!(\"CFG_LLVM_ROOT\").unwrap_or(\"\");\n+        let custom_llvm_used = cfg_llvm_root.trim() != \"\";\n+\n+        if !custom_llvm_used && sess.target.target.data_layout != data_layout {\n             bug!(\"data-layout for builtin `{}` target, `{}`, \\\n                   differs from LLVM default, `{}`\",\n                  sess.target.target.llvm_target,\n@@ -322,6 +396,11 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n     let llvm_target = sess.target.target.llvm_target.as_bytes();\n     let llvm_target = CString::new(llvm_target).unwrap();\n     llvm::LLVMRustSetNormalizedTarget(llmod, llvm_target.as_ptr());\n+\n+    if is_pie_binary(sess) {\n+        llvm::LLVMRustSetModulePIELevel(llmod);\n+    }\n+\n     (llcx, llmod)\n }\n \n@@ -510,6 +589,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n impl<'tcx> LocalCrateContext<'tcx> {\n     fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n                codegen_unit: CodegenUnit<'tcx>,\n+               previous_work_product: Option<WorkProduct>,\n                symbol_map: Rc<SymbolMap<'tcx>>)\n            -> LocalCrateContext<'tcx> {\n         unsafe {\n@@ -521,27 +601,28 @@ impl<'tcx> LocalCrateContext<'tcx> {\n             // crashes if the module identifier is same as other symbols\n             // such as a function name in the module.\n             // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-            let llmod_id = format!(\"{}.rs\", codegen_unit.name);\n+            let llmod_id = format!(\"{}.rs\", codegen_unit.name());\n \n             let (llcx, llmod) = create_context_and_module(&shared.tcx.sess,\n                                                           &llmod_id[..]);\n \n             let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n-                Some(debuginfo::CrateDebugContext::new(llmod))\n+                let dctx = debuginfo::CrateDebugContext::new(llmod);\n+                debuginfo::metadata::compile_unit_metadata(shared, &dctx, shared.tcx.sess);\n+                Some(dctx)\n             } else {\n                 None\n             };\n \n             let local_ccx = LocalCrateContext {\n                 llmod: llmod,\n                 llcx: llcx,\n+                previous_work_product: previous_work_product,\n                 codegen_unit: codegen_unit,\n                 tn: TypeNames::new(),\n                 needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n                 fn_pointer_shims: RefCell::new(FnvHashMap()),\n                 drop_glues: RefCell::new(FnvHashMap()),\n-                external: RefCell::new(DefIdMap()),\n-                external_srcs: RefCell::new(NodeMap()),\n                 instances: RefCell::new(FnvHashMap()),\n                 monomorphizing: RefCell::new(DefIdMap()),\n                 vtables: RefCell::new(FnvHashMap()),\n@@ -694,6 +775,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().llcx\n     }\n \n+    pub fn previous_work_product(&self) -> Option<&WorkProduct> {\n+        self.local().previous_work_product.as_ref()\n+    }\n+\n     pub fn codegen_unit(&self) -> &CodegenUnit<'tcx> {\n         &self.local().codegen_unit\n     }\n@@ -731,12 +816,12 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().drop_glues\n     }\n \n-    pub fn external<'a>(&'a self) -> &'a RefCell<DefIdMap<Option<ast::NodeId>>> {\n-        &self.local().external\n+    pub fn local_node_for_inlined_defid<'a>(&'a self, def_id: DefId) -> Option<ast::NodeId> {\n+        self.sess().cstore.local_node_for_inlined_defid(def_id)\n     }\n \n-    pub fn external_srcs<'a>(&'a self) -> &'a RefCell<NodeMap<DefId>> {\n-        &self.local().external_srcs\n+    pub fn defid_for_inlined_node<'a>(&'a self, node_id: ast::NodeId) -> Option<DefId> {\n+        self.sess().cstore.defid_for_inlined_node(node_id)\n     }\n \n     pub fn instances<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {"}, {"sha": "fe6a48d4c559dac732df51158504bdb562f3f466", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -133,7 +133,7 @@ fn make_mir_scope(ccx: &CrateContext,\n     let loc = span_start(ccx, scope_data.span);\n     scopes[scope] = unsafe {\n     let file_metadata = file_metadata(ccx, &loc.file.name, &loc.file.abs_path);\n-        llvm::LLVMDIBuilderCreateLexicalBlock(\n+        llvm::LLVMRustDIBuilderCreateLexicalBlock(\n             DIB(ccx),\n             parent_scope,\n             file_metadata,\n@@ -156,7 +156,7 @@ fn with_new_scope<F>(cx: &CrateContext,\n     let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n     let scope_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateLexicalBlock(\n+        llvm::LLVMRustDIBuilderCreateLexicalBlock(\n             DIB(cx),\n             parent_scope,\n             file_metadata,\n@@ -272,7 +272,7 @@ fn walk_pattern(cx: &CrateContext,\n                 let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                 let scope_metadata = unsafe {\n-                    llvm::LLVMDIBuilderCreateLexicalBlock(\n+                    llvm::LLVMRustDIBuilderCreateLexicalBlock(\n                         DIB(cx),\n                         parent_scope,\n                         file_metadata,"}, {"sha": "0a8d490dcd2dd3e54601a69484f44d1eddf7aaea", "filename": "src/librustc_trans/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727", "patch": "@@ -77,7 +77,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n             llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n             llvm::LLVMSetUnnamedAddr(section_var, llvm::True);\n-            llvm::SetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);\n+            llvm::LLVMSetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);\n             // This should make sure that the whole section is not larger than\n             // the string it contains. Otherwise we get a warning from GDB.\n             llvm::LLVMSetAlignment(section_var, 1);"}, {"sha": "8011347d3eb12c76770dd9c447b03147653d5214", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "464c32c3cc725b78992f1bc7ca1844fd6808b01c", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "5953ec4aaedfa3cb492de9d8a61f9fa4cf05beac", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "d288b9dcef70bb379c2c89a6fecbd99da6d485f1", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "5734a12394113fe86a2c825652c0aa11540f1a9c", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "324e8697ecae695ab61e3a6e550cdf085fa85fd2", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "2a60dd17446717eae78d1a971c48dc81e6ee541a", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "6bc48546dfa8c7c9b7b9f4454d0218d7618c8137", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "8581fccf10ab53b0d2c783567a4e403ea894e60f", "filename": "src/librustc_trans/inline.rs", "status": "modified", "additions": 6, "deletions": 100, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Finline.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "2f27aed065d80f17b926d937a1d2ee473c2e1b4e", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "81a1dbeb7fe74db7431b49909611326134d1d58c", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "9bfdb511c623c97f34974b9711b443978ffcea3b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "00db19d2739c3953d95615af8801e6169acb13ae", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "8f723d288c9eb4718cb4bb77580396bbf122b4ac", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "97d65ce9c53614bf1a2600fd48e6c0fb1f15f3cc", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 36, "deletions": 44, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "e9aacaa0f954f2e4fc20daa8d50ba442bcabc0b8", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "ade6e8abeb32a5ac07d27eba578131c015c9cac4", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 62, "deletions": 22, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "35bb0481c8e979e6f82248a111fa18254fb078eb", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "92a2d3787bfd6b60bc5184233f24893e10e91ab3", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "d191591e082adedef8e9d7a0bfd00cd3cef875bd", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "79e0c11515fc49f34fe6cb5ed716a2fd8d1378a6", "filename": "src/librustc_trans/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_trans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fvalue.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "a11df5ae05d6fca6e56f74db4e67c04ede6d847a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "aae6e3ad36dfe7ee2ba7b1ec173cd2d3f8193a82", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "265422468fe2a1c4a18b6ca9f790f005d2f539d5", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "bd2c05ba66d47188d77729c08c5cf874832c79b9", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "7a4cc09a7d5064d3a9ac408103df64cdf885dca3", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "9844377d0bd32f5241c1e0cb948f48597c1d5673", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "1f3a83ebc1d567da7a2ae7174213e62feaafd451", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "8a53c59b4c7fad08dafbe1215cb6d8bf52914885", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "346449d0a51331465bde2b99b5eec3048bb74e7c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "97788c9fb33997e8c8dd54e23d98a462708647d4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "63487683ec3b990feff4aa0fc1687b465cc916f0", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "030491b521d95679e38b0f72cfdc975a7ba468ae", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "34a91b22981e15b298c5e8752f7710ecfe011c52", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "2d14b0dacf24cdad759aaf5f63222a698082bd63", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "54bd141304d7816e21966f600a6c7c3878e1096f", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "cb9c0496246d5ee4286dd1c254f7138cdbd88b25", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "7909584bfabdf560b4c11ffe97b08f3133a2667d", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 42, "deletions": 66, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "64b27857d2c610b50e6cc04850585b46ba4275ca", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 153, "deletions": 170, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "6f0892cdcdf1619f62e74198f5af4940c129a215", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "81856cb87c7c40cdb1debe42f633caaec0ad43f9", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "3ae905eba279b7f3c1cce0607a0d75190f51094f", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "3e510bdc9002e2cbbc5b0089a1c53386a205d439", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "d609ad84a83831dd8920ab84b60e9791231f93f3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "6cb79d6e8630f570d0ff065b37db361ed2c1795d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "e4e886c85334771b60c5a655ca0340e6d5e38579", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "de0457592fc8834cfa5bbc62cf38bd2c1182f2fc", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "3ce6841fdd4c6a1d4d1448047e1b5848ee21f5df", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "9018e48d06bd1a2da7b32bbad80b836643f00497", "filename": "src/libstd/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "fd7b0a2e6bbf6d9b0d8834c911e7dca320c7c298", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 251, "deletions": 6, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "d6d62ce79d4e6ff94aa780736adcce7d8b9da3ba", "filename": "src/libstd/env.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}, {"sha": "f800a6e228e9ba0f96bcf56f20e4ef63964cb3e8", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb88faad77d2c9d3de07a1e4b676f95c6780727/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=cbb88faad77d2c9d3de07a1e4b676f95c6780727"}]}