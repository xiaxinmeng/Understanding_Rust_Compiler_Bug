{"sha": "5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMzJiNGEzNGZjNmZiZDc4ZTI5M2IxNmY3YmE3ZDA2Y2FjYTdhNDg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T22:34:08Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T22:34:08Z"}, "message": "rollup merge of #22491: Gankro/into_iter\n\nConflicts:\n\tsrc/libcollections/bit.rs\n\tsrc/libcollections/linked_list.rs\n\tsrc/libcollections/vec_deque.rs\n\tsrc/libstd/sys/common/wtf8.rs", "tree": {"sha": "ea0ee2df4161fb0578705cd5f26635db5f3b4a1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea0ee2df4161fb0578705cd5f26635db5f3b4a1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "html_url": "https://github.com/rust-lang/rust/commit/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9aee389b6e5a58eb867f4d035729f39e694f51ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/9aee389b6e5a58eb867f4d035729f39e694f51ec", "html_url": "https://github.com/rust-lang/rust/commit/9aee389b6e5a58eb867f4d035729f39e694f51ec"}, {"sha": "66613e26b95438c02e2f5c273c557515454121f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/66613e26b95438c02e2f5c273c557515454121f7", "html_url": "https://github.com/rust-lang/rust/commit/66613e26b95438c02e2f5c273c557515454121f7"}], "stats": {"total": 1928, "additions": 990, "deletions": 938}, "files": [{"sha": "9f549fd7237711dce941f7ef0d37e0eec9e8db73", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -650,8 +650,8 @@ impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n-    fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BinaryHeap<T> {\n-        BinaryHeap::from_vec(iter.collect())\n+    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> BinaryHeap<T> {\n+        BinaryHeap::from_vec(iter.into_iter().collect())\n     }\n }\n \n@@ -677,7 +677,8 @@ impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n-    fn extend<Iter: Iterator<Item=T>>(&mut self, iter: Iter) {\n+    fn extend<I: IntoIterator<Item=T>>(&mut self, iterable: I) {\n+        let iter = iterable.into_iter();\n         let (lower, _) = iter.size_hint();\n \n         self.reserve(lower);"}, {"sha": "d9c2290e68cedd91e30aa3d516d7586309f37a27", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 533, "deletions": 524, "changes": 1057, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME(Gankro): Bitv and BitvSet are very tightly coupled. Ideally (for\n-// maintenance), they should be in separate files/modules, with BitvSet only\n-// using Bitv's public API. This will be hard for performance though, because\n-// `Bitv` will not want to leak its internal representation while its internal\n+// FIXME(Gankro): BitVec and BitSet are very tightly coupled. Ideally (for\n+// maintenance), they should be in separate files/modules, with BitSet only\n+// using BitVec's public API. This will be hard for performance though, because\n+// `BitVec` will not want to leak its internal representation while its internal\n // representation as `u32`s must be assumed for best performance.\n \n-// FIXME(tbu-): `Bitv`'s methods shouldn't be `union`, `intersection`, but\n+// FIXME(tbu-): `BitVec`'s methods shouldn't be `union`, `intersection`, but\n // rather `or` and `and`.\n \n // (1) Be careful, most things can overflow here because the amount of bits in\n@@ -25,8 +25,8 @@\n //     methods rely on it (for *CORRECTNESS*).\n // (3) Make sure that the unused bits in the last word are zeroed out, again\n //     other methods rely on it for *CORRECTNESS*.\n-// (4) `BitvSet` is tightly coupled with `Bitv`, so any changes you make in\n-// `Bitv` will need to be reflected in `BitvSet`.\n+// (4) `BitSet` is tightly coupled with `BitVec`, so any changes you make in\n+// `BitVec` will need to be reflected in `BitSet`.\n \n //! Collections implemented with bit vectors.\n //!\n@@ -38,17 +38,17 @@\n //! [sieve]: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n //!\n //! ```\n-//! use std::collections::{BitvSet, Bitv};\n+//! use std::collections::{BitSet, BitVec};\n //! use std::num::Float;\n //! use std::iter;\n //!\n //! let max_prime = 10000;\n //!\n-//! // Store the primes as a BitvSet\n+//! // Store the primes as a BitSet\n //! let primes = {\n //!     // Assume all numbers are prime to begin, and then we\n //!     // cross off non-primes progressively\n-//!     let mut bv = Bitv::from_elem(max_prime, true);\n+//!     let mut bv = BitVec::from_elem(max_prime, true);\n //!\n //!     // Neither 0 nor 1 are prime\n //!     bv.set(0, false);\n@@ -62,7 +62,7 @@\n //!             for j in iter::range_step(i * i, max_prime, i) { bv.set(j, false) }\n //!         }\n //!     }\n-//!     BitvSet::from_bitv(bv)\n+//!     BitSet::from_bit_vec(bv)\n //! };\n //!\n //! // Simple primality tests below our max bound\n@@ -75,7 +75,7 @@\n //! }\n //! println!(\"\");\n //!\n-//! // We can manipulate the internal Bitv\n+//! // We can manipulate the internal BitVec\n //! let num_primes = primes.get_ref().iter().filter(|x| *x).count();\n //! println!(\"There are {} primes below {}\", num_primes, max_prime);\n //! ```\n@@ -94,7 +94,7 @@ use core::num::Int;\n use core::ops::Index;\n use core::slice;\n use core::{u8, u32, usize};\n-use bitv_set; //so meta\n+use bit_set; //so meta\n \n use Vec;\n \n@@ -112,7 +112,7 @@ fn reverse_bits(byte: u8) -> u8 {\n \n // Take two BitV's, and return iterators of their words, where the shorter one\n // has been padded with 0's\n-fn match_words <'a,'b>(a: &'a Bitv, b: &'b Bitv) -> (MatchWords<'a>, MatchWords<'b>) {\n+fn match_words <'a,'b>(a: &'a BitVec, b: &'b BitVec) -> (MatchWords<'a>, MatchWords<'b>) {\n     let a_len = a.storage.len();\n     let b_len = b.storage.len();\n \n@@ -134,9 +134,9 @@ static FALSE: bool = false;\n /// # Examples\n ///\n /// ```rust\n-/// use std::collections::Bitv;\n+/// use std::collections::BitVec;\n ///\n-/// let mut bv = Bitv::from_elem(10, false);\n+/// let mut bv = BitVec::from_elem(10, false);\n ///\n /// // insert all primes less than 10\n /// bv.set(2, true);\n@@ -158,15 +158,15 @@ static FALSE: bool = false;\n /// ```\n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n-pub struct Bitv {\n+pub struct BitVec {\n     /// Internal representation of the bit vector\n     storage: Vec<u32>,\n     /// The number of valid bits in the internal representation\n     nbits: usize\n }\n \n // FIXME(Gankro): NopeNopeNopeNopeNope (wait for IndexGet to be a thing)\n-impl Index<usize> for Bitv {\n+impl Index<usize> for BitVec {\n     type Output = bool;\n \n     #[inline]\n@@ -202,12 +202,12 @@ fn mask_for_bits(bits: usize) -> u32 {\n     !0u32 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n }\n \n-impl Bitv {\n+impl BitVec {\n     /// Applies the given operation to the blocks of self and other, and sets\n     /// self to be the result. This relies on the caller not to corrupt the\n     /// last word.\n     #[inline]\n-    fn process<F>(&mut self, other: &Bitv, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 {\n+    fn process<F>(&mut self, other: &BitVec, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 {\n         assert_eq!(self.len(), other.len());\n         // This could theoretically be a `debug_assert!`.\n         assert_eq!(self.storage.len(), other.storage.len());\n@@ -235,7 +235,7 @@ impl Bitv {\n     }\n \n     /// An operation might screw up the unused bits in the last block of the\n-    /// `Bitv`. As per (3), it's assumed to be all 0s. This method fixes it up.\n+    /// `BitVec`. As per (3), it's assumed to be all 0s. This method fixes it up.\n     fn fix_last_block(&mut self) {\n         let extra_bits = self.len() % u32::BITS;\n         if extra_bits > 0 {\n@@ -245,83 +245,83 @@ impl Bitv {\n         }\n     }\n \n-    /// Creates an empty `Bitv`.\n+    /// Creates an empty `BitVec`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n-    /// let mut bv = Bitv::new();\n+    /// use std::collections::BitVec;\n+    /// let mut bv = BitVec::new();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> Bitv {\n-        Bitv { storage: Vec::new(), nbits: 0 }\n+    pub fn new() -> BitVec {\n+        BitVec { storage: Vec::new(), nbits: 0 }\n     }\n \n-    /// Creates a `Bitv` that holds `nbits` elements, setting each element\n+    /// Creates a `BitVec` that holds `nbits` elements, setting each element\n     /// to `bit`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(10, false);\n+    /// let mut bv = BitVec::from_elem(10, false);\n     /// assert_eq!(bv.len(), 10);\n     /// for x in bv.iter() {\n     ///     assert_eq!(x, false);\n     /// }\n     /// ```\n-    pub fn from_elem(nbits: usize, bit: bool) -> Bitv {\n+    pub fn from_elem(nbits: usize, bit: bool) -> BitVec {\n         let nblocks = blocks_for_bits(nbits);\n-        let mut bitv = Bitv {\n+        let mut bit_vec = BitVec {\n             storage: repeat(if bit { !0u32 } else { 0u32 }).take(nblocks).collect(),\n             nbits: nbits\n         };\n-        bitv.fix_last_block();\n-        bitv\n+        bit_vec.fix_last_block();\n+        bit_vec\n     }\n \n-    /// Constructs a new, empty `Bitv` with the specified capacity.\n+    /// Constructs a new, empty `BitVec` with the specified capacity.\n     ///\n     /// The bitvector will be able to hold at least `capacity` bits without\n     /// reallocating. If `capacity` is 0, it will not allocate.\n     ///\n     /// It is important to note that this function does not specify the\n     /// *length* of the returned bitvector, but only the *capacity*.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(nbits: usize) -> Bitv {\n-        Bitv {\n+    pub fn with_capacity(nbits: usize) -> BitVec {\n+        BitVec {\n             storage: Vec::with_capacity(blocks_for_bits(nbits)),\n             nbits: 0,\n         }\n     }\n \n-    /// Transforms a byte-vector into a `Bitv`. Each byte becomes eight bits,\n+    /// Transforms a byte-vector into a `BitVec`. Each byte becomes eight bits,\n     /// with the most significant bits of each byte coming first. Each\n     /// bit becomes `true` if equal to 1 or `false` if equal to 0.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b10100000, 0b00010010]);\n+    /// let bv = BitVec::from_bytes(&[0b10100000, 0b00010010]);\n     /// assert!(bv.eq_vec(&[true, false, true, false,\n     ///                     false, false, false, false,\n     ///                     false, false, false, true,\n     ///                     false, false, true, false]));\n     /// ```\n-    pub fn from_bytes(bytes: &[u8]) -> Bitv {\n+    pub fn from_bytes(bytes: &[u8]) -> BitVec {\n         let len = bytes.len().checked_mul(u8::BITS).expect(\"capacity overflow\");\n-        let mut bitv = Bitv::with_capacity(len);\n+        let mut bit_vec = BitVec::with_capacity(len);\n         let complete_words = bytes.len() / 4;\n         let extra_bytes = bytes.len() % 4;\n \n-        bitv.nbits = len;\n+        bit_vec.nbits = len;\n \n         for i in 0..complete_words {\n-            bitv.storage.push(\n+            bit_vec.storage.push(\n                 ((reverse_bits(bytes[i * 4 + 0]) as u32) << 0) |\n                 ((reverse_bits(bytes[i * 4 + 1]) as u32) << 8) |\n                 ((reverse_bits(bytes[i * 4 + 2]) as u32) << 16) |\n@@ -334,39 +334,39 @@ impl Bitv {\n             for (i, &byte) in bytes[complete_words*4..].iter().enumerate() {\n                 last_word |= (reverse_bits(byte) as u32) << (i * 8);\n             }\n-            bitv.storage.push(last_word);\n+            bit_vec.storage.push(last_word);\n         }\n \n-        bitv\n+        bit_vec\n     }\n \n-    /// Creates a `Bitv` of the specified length where the value at each index\n+    /// Creates a `BitVec` of the specified length where the value at each index\n     /// is `f(index)`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_fn(5, |i| { i % 2 == 0 });\n+    /// let bv = BitVec::from_fn(5, |i| { i % 2 == 0 });\n     /// assert!(bv.eq_vec(&[true, false, true, false, true]));\n     /// ```\n-    pub fn from_fn<F>(len: usize, mut f: F) -> Bitv where F: FnMut(usize) -> bool {\n-        let mut bitv = Bitv::from_elem(len, false);\n+    pub fn from_fn<F>(len: usize, mut f: F) -> BitVec where F: FnMut(usize) -> bool {\n+        let mut bit_vec = BitVec::from_elem(len, false);\n         for i in 0..len {\n-            bitv.set(i, f(i));\n+            bit_vec.set(i, f(i));\n         }\n-        bitv\n+        bit_vec\n     }\n \n     /// Retrieves the value at index `i`, or `None` if the index is out of bounds.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b01100000]);\n+    /// let bv = BitVec::from_bytes(&[0b01100000]);\n     /// assert_eq!(bv.get(0), Some(false));\n     /// assert_eq!(bv.get(1), Some(true));\n     /// assert_eq!(bv.get(100), None);\n@@ -396,9 +396,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(5, false);\n+    /// let mut bv = BitVec::from_elem(5, false);\n     /// bv.set(3, true);\n     /// assert_eq!(bv[3], true);\n     /// ```\n@@ -420,14 +420,14 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let before = 0b01100000;\n     /// let after  = 0b11111111;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[before]);\n+    /// let mut bv = BitVec::from_bytes(&[before]);\n     /// bv.set_all();\n-    /// assert_eq!(bv, Bitv::from_bytes(&[after]));\n+    /// assert_eq!(bv, BitVec::from_bytes(&[after]));\n     /// ```\n     #[inline]\n     pub fn set_all(&mut self) {\n@@ -440,14 +440,14 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let before = 0b01100000;\n     /// let after  = 0b10011111;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[before]);\n+    /// let mut bv = BitVec::from_bytes(&[before]);\n     /// bv.negate();\n-    /// assert_eq!(bv, Bitv::from_bytes(&[after]));\n+    /// assert_eq!(bv, BitVec::from_bytes(&[after]));\n     /// ```\n     #[inline]\n     pub fn negate(&mut self) {\n@@ -468,20 +468,20 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let res = 0b01111110;\n     ///\n-    /// let mut a = Bitv::from_bytes(&[a]);\n-    /// let b = Bitv::from_bytes(&[b]);\n+    /// let mut a = BitVec::from_bytes(&[a]);\n+    /// let b = BitVec::from_bytes(&[b]);\n     ///\n     /// assert!(a.union(&b));\n-    /// assert_eq!(a, Bitv::from_bytes(&[res]));\n+    /// assert_eq!(a, BitVec::from_bytes(&[res]));\n     /// ```\n     #[inline]\n-    pub fn union(&mut self, other: &Bitv) -> bool {\n+    pub fn union(&mut self, other: &BitVec) -> bool {\n         self.process(other, |w1, w2| w1 | w2)\n     }\n \n@@ -498,20 +498,20 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let res = 0b01000000;\n     ///\n-    /// let mut a = Bitv::from_bytes(&[a]);\n-    /// let b = Bitv::from_bytes(&[b]);\n+    /// let mut a = BitVec::from_bytes(&[a]);\n+    /// let b = BitVec::from_bytes(&[b]);\n     ///\n     /// assert!(a.intersect(&b));\n-    /// assert_eq!(a, Bitv::from_bytes(&[res]));\n+    /// assert_eq!(a, BitVec::from_bytes(&[res]));\n     /// ```\n     #[inline]\n-    pub fn intersect(&mut self, other: &Bitv) -> bool {\n+    pub fn intersect(&mut self, other: &BitVec) -> bool {\n         self.process(other, |w1, w2| w1 & w2)\n     }\n \n@@ -528,27 +528,27 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let a_b = 0b00100100; // a - b\n     /// let b_a = 0b00011010; // b - a\n     ///\n-    /// let mut bva = Bitv::from_bytes(&[a]);\n-    /// let bvb = Bitv::from_bytes(&[b]);\n+    /// let mut bva = BitVec::from_bytes(&[a]);\n+    /// let bvb = BitVec::from_bytes(&[b]);\n     ///\n     /// assert!(bva.difference(&bvb));\n-    /// assert_eq!(bva, Bitv::from_bytes(&[a_b]));\n+    /// assert_eq!(bva, BitVec::from_bytes(&[a_b]));\n     ///\n-    /// let bva = Bitv::from_bytes(&[a]);\n-    /// let mut bvb = Bitv::from_bytes(&[b]);\n+    /// let bva = BitVec::from_bytes(&[a]);\n+    /// let mut bvb = BitVec::from_bytes(&[b]);\n     ///\n     /// assert!(bvb.difference(&bva));\n-    /// assert_eq!(bvb, Bitv::from_bytes(&[b_a]));\n+    /// assert_eq!(bvb, BitVec::from_bytes(&[b_a]));\n     /// ```\n     #[inline]\n-    pub fn difference(&mut self, other: &Bitv) -> bool {\n+    pub fn difference(&mut self, other: &BitVec) -> bool {\n         self.process(other, |w1, w2| w1 & !w2)\n     }\n \n@@ -557,9 +557,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(5, true);\n+    /// let mut bv = BitVec::from_elem(5, true);\n     /// assert_eq!(bv.all(), true);\n     ///\n     /// bv.set(1, false);\n@@ -581,25 +581,25 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b01110100, 0b10010010]);\n+    /// let bv = BitVec::from_bytes(&[0b01110100, 0b10010010]);\n     /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter {\n-        Iter { bitv: self, next_idx: 0, end_idx: self.nbits }\n+        Iter { bit_vec: self, next_idx: 0, end_idx: self.nbits }\n     }\n \n     /// Returns `true` if all bits are 0.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(10, false);\n+    /// let mut bv = BitVec::from_elem(10, false);\n     /// assert_eq!(bv.none(), true);\n     ///\n     /// bv.set(3, true);\n@@ -614,9 +614,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(10, false);\n+    /// let mut bv = BitVec::from_elem(10, false);\n     /// assert_eq!(bv.any(), false);\n     ///\n     /// bv.set(3, true);\n@@ -628,33 +628,33 @@ impl Bitv {\n     }\n \n     /// Organises the bits into bytes, such that the first bit in the\n-    /// `Bitv` becomes the high-order bit of the first byte. If the\n-    /// size of the `Bitv` is not a multiple of eight then trailing bits\n+    /// `BitVec` becomes the high-order bit of the first byte. If the\n+    /// size of the `BitVec` is not a multiple of eight then trailing bits\n     /// will be filled-in with `false`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(3, true);\n+    /// let mut bv = BitVec::from_elem(3, true);\n     /// bv.set(1, false);\n     ///\n     /// assert_eq!(bv.to_bytes(), vec!(0b10100000));\n     ///\n-    /// let mut bv = Bitv::from_elem(9, false);\n+    /// let mut bv = BitVec::from_elem(9, false);\n     /// bv.set(2, true);\n     /// bv.set(8, true);\n     ///\n     /// assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n     /// ```\n     pub fn to_bytes(&self) -> Vec<u8> {\n-        fn bit(bitv: &Bitv, byte: usize, bit: usize) -> u8 {\n+        fn bit(bit_vec: &BitVec, byte: usize, bit: usize) -> u8 {\n             let offset = byte * 8 + bit;\n-            if offset >= bitv.nbits {\n+            if offset >= bit_vec.nbits {\n                 0\n             } else {\n-                (bitv[offset] as u8) << (7 - bit)\n+                (bit_vec[offset] as u8) << (7 - bit)\n             }\n         }\n \n@@ -672,19 +672,19 @@ impl Bitv {\n         ).collect()\n     }\n \n-    /// Compares a `Bitv` to a slice of `bool`s.\n-    /// Both the `Bitv` and slice must have the same length.\n+    /// Compares a `BitVec` to a slice of `bool`s.\n+    /// Both the `BitVec` and slice must have the same length.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the `Bitv` and slice are of different length.\n+    /// Panics if the `BitVec` and slice are of different length.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b10100000]);\n+    /// let bv = BitVec::from_bytes(&[0b10100000]);\n     ///\n     /// assert!(bv.eq_vec(&[true, false, true, false,\n     ///                     false, false, false, false]));\n@@ -694,17 +694,17 @@ impl Bitv {\n         iter::order::eq(self.iter(), v.iter().cloned())\n     }\n \n-    /// Shortens a `Bitv`, dropping excess elements.\n+    /// Shortens a `BitVec`, dropping excess elements.\n     ///\n     /// If `len` is greater than the vector's current length, this has no\n     /// effect.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[0b01001011]);\n+    /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n     /// bv.truncate(2);\n     /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n@@ -719,7 +719,7 @@ impl Bitv {\n     }\n \n     /// Reserves capacity for at least `additional` more bits to be inserted in the given\n-    /// `Bitv`. The collection may reserve more space to avoid frequent reallocations.\n+    /// `BitVec`. The collection may reserve more space to avoid frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -728,9 +728,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(3, false);\n+    /// let mut bv = BitVec::from_elem(3, false);\n     /// bv.reserve(10);\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n@@ -745,7 +745,7 @@ impl Bitv {\n     }\n \n     /// Reserves the minimum capacity for exactly `additional` more bits to be inserted in the\n-    /// given `Bitv`. Does nothing if the capacity is already sufficient.\n+    /// given `BitVec`. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n     /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n@@ -758,9 +758,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(3, false);\n+    /// let mut bv = BitVec::from_elem(3, false);\n     /// bv.reserve(10);\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n@@ -780,9 +780,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::new();\n+    /// let mut bv = BitVec::new();\n     /// bv.reserve(10);\n     /// assert!(bv.capacity() >= 10);\n     /// ```\n@@ -792,7 +792,7 @@ impl Bitv {\n         self.storage.capacity().checked_mul(u32::BITS).unwrap_or(usize::MAX)\n     }\n \n-    /// Grows the `Bitv` in-place, adding `n` copies of `value` to the `Bitv`.\n+    /// Grows the `BitVec` in-place, adding `n` copies of `value` to the `BitVec`.\n     ///\n     /// # Panics\n     ///\n@@ -801,9 +801,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[0b01001011]);\n+    /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n     /// bv.grow(2, true);\n     /// assert_eq!(bv.len(), 10);\n     /// assert_eq!(bv.to_bytes(), vec!(0b01001011, 0b11000000));\n@@ -846,14 +846,14 @@ impl Bitv {\n         self.fix_last_block();\n     }\n \n-    /// Removes the last bit from the Bitv, and returns it. Returns None if the Bitv is empty.\n+    /// Removes the last bit from the BitVec, and returns it. Returns None if the BitVec is empty.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[0b01001001]);\n+    /// let mut bv = BitVec::from_bytes(&[0b01001001]);\n     /// assert_eq!(bv.pop(), Some(true));\n     /// assert_eq!(bv.pop(), Some(false));\n     /// assert_eq!(bv.len(), 6);\n@@ -881,9 +881,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::new();\n+    /// let mut bv = BitVec::new();\n     /// bv.push(true);\n     /// bv.push(false);\n     /// assert!(bv.eq_vec(&[true, false]));\n@@ -917,24 +917,25 @@ impl Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for Bitv {\n+impl Default for BitVec {\n     #[inline]\n-    fn default() -> Bitv { Bitv::new() }\n+    fn default() -> BitVec { BitVec::new() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromIterator<bool> for Bitv {\n-    fn from_iter<I:Iterator<Item=bool>>(iterator: I) -> Bitv {\n+impl FromIterator<bool> for BitVec {\n+    fn from_iter<I: IntoIterator<Item=bool>>(iter: I) -> BitVec {\n         let mut ret = Bitv::new();\n-        ret.extend(iterator);\n+        ret.extend(iter);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Extend<bool> for Bitv {\n+impl Extend<bool> for BitVec {\n     #[inline]\n-    fn extend<I: Iterator<Item=bool>>(&mut self, iterator: I) {\n+    fn extend<I: IntoIterator<Item=bool>>(&mut self, iterable: I) {\n+        let iterator = iterable.into_iter();\n         let (min, _) = iterator.size_hint();\n         self.reserve(min);\n         for element in iterator {\n@@ -944,37 +945,37 @@ impl Extend<bool> for Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for Bitv {\n+impl Clone for BitVec {\n     #[inline]\n-    fn clone(&self) -> Bitv {\n-        Bitv { storage: self.storage.clone(), nbits: self.nbits }\n+    fn clone(&self) -> BitVec {\n+        BitVec { storage: self.storage.clone(), nbits: self.nbits }\n     }\n \n     #[inline]\n-    fn clone_from(&mut self, source: &Bitv) {\n+    fn clone_from(&mut self, source: &BitVec) {\n         self.nbits = source.nbits;\n         self.storage.clone_from(&source.storage);\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for Bitv {\n+impl PartialOrd for BitVec {\n     #[inline]\n-    fn partial_cmp(&self, other: &Bitv) -> Option<Ordering> {\n+    fn partial_cmp(&self, other: &BitVec) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for Bitv {\n+impl Ord for BitVec {\n     #[inline]\n-    fn cmp(&self, other: &Bitv) -> Ordering {\n+    fn cmp(&self, other: &BitVec) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Bitv {\n+impl fmt::Debug for BitVec {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self {\n             try!(write!(fmt, \"{}\", if bit { 1u32 } else { 0u32 }));\n@@ -985,7 +986,7 @@ impl fmt::Debug for Bitv {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitVec {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n         for elem in self.blocks() {\n@@ -995,7 +996,7 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg(not(stage0))]\n-impl hash::Hash for Bitv {\n+impl hash::Hash for BitVec {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         self.nbits.hash(state);\n         for elem in self.blocks() {\n@@ -1005,9 +1006,9 @@ impl hash::Hash for Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::PartialEq for Bitv {\n+impl cmp::PartialEq for BitVec {\n     #[inline]\n-    fn eq(&self, other: &Bitv) -> bool {\n+    fn eq(&self, other: &BitVec) -> bool {\n         if self.nbits != other.nbits {\n             return false;\n         }\n@@ -1016,13 +1017,13 @@ impl cmp::PartialEq for Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Eq for Bitv {}\n+impl cmp::Eq for BitVec {}\n \n-/// An iterator for `Bitv`.\n+/// An iterator for `BitVec`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Iter<'a> {\n-    bitv: &'a Bitv,\n+    bit_vec: &'a BitVec,\n     next_idx: usize,\n     end_idx: usize,\n }\n@@ -1036,7 +1037,7 @@ impl<'a> Iterator for Iter<'a> {\n         if self.next_idx != self.end_idx {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n-            Some(self.bitv[idx])\n+            Some(self.bit_vec[idx])\n         } else {\n             None\n         }\n@@ -1054,7 +1055,7 @@ impl<'a> DoubleEndedIterator for Iter<'a> {\n     fn next_back(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n             self.end_idx -= 1;\n-            Some(self.bitv[self.end_idx])\n+            Some(self.bit_vec[self.end_idx])\n         } else {\n             None\n         }\n@@ -1076,13 +1077,13 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n         if index >= self.indexable() {\n             None\n         } else {\n-            Some(self.bitv[index])\n+            Some(self.bit_vec[index])\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> IntoIterator for &'a Bitv {\n+impl<'a> IntoIterator for &'a BitVec {\n     type Item = bool;\n     type IntoIter = Iter<'a>;\n \n@@ -1101,10 +1102,10 @@ impl<'a> IntoIterator for &'a Bitv {\n /// # Examples\n ///\n /// ```\n-/// use std::collections::{BitvSet, Bitv};\n+/// use std::collections::{BitSet, BitVec};\n ///\n /// // It's a regular set\n-/// let mut s = BitvSet::new();\n+/// let mut s = BitSet::new();\n /// s.insert(0);\n /// s.insert(3);\n /// s.insert(7);\n@@ -1115,8 +1116,8 @@ impl<'a> IntoIterator for &'a Bitv {\n ///     println!(\"There is no 7\");\n /// }\n ///\n-/// // Can initialize from a `Bitv`\n-/// let other = BitvSet::from_bitv(Bitv::from_bytes(&[0b11010000]));\n+/// // Can initialize from a `BitVec`\n+/// let other = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11010000]));\n ///\n /// s.union_with(&other);\n ///\n@@ -1125,124 +1126,132 @@ impl<'a> IntoIterator for &'a Bitv {\n ///     println!(\"{}\", x);\n /// }\n ///\n-/// // Can convert back to a `Bitv`\n-/// let bv: Bitv = s.into_bitv();\n+/// // Can convert back to a `BitVec`\n+/// let bv: BitVec = s.into_bit_vec();\n /// assert!(bv[3]);\n /// ```\n #[derive(Clone)]\n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n-pub struct BitvSet {\n-    bitv: Bitv,\n+pub struct BitSet {\n+    bit_vec: BitVec,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for BitvSet {\n+impl Default for BitSet {\n     #[inline]\n-    fn default() -> BitvSet { BitvSet::new() }\n+    fn default() -> BitSet { BitSet::new() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromIterator<usize> for BitvSet {\n-    fn from_iter<I:Iterator<Item=usize>>(iterator: I) -> BitvSet {\n+impl FromIterator<usize> for BitSet {\n+    fn from_iter<I: IntoIterator<Item=usize>>(iter: I) -> BitSet {\n         let mut ret = BitvSet::new();\n-        ret.extend(iterator);\n+        ret.extend(iter);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Extend<usize> for BitvSet {\n+impl Extend<usize> for BitSet {\n     #[inline]\n-    fn extend<I: Iterator<Item=usize>>(&mut self, iterator: I) {\n-        for i in iterator {\n+    fn extend<I: IntoIterator<Item=usize>>(&mut self, iter: I) {\n+        for i in iter {\n             self.insert(i);\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for BitvSet {\n+impl PartialOrd for BitSet {\n     #[inline]\n-    fn partial_cmp(&self, other: &BitvSet) -> Option<Ordering> {\n+    fn partial_cmp(&self, other: &BitSet) -> Option<Ordering> {\n         let (a_iter, b_iter) = match_words(self.get_ref(), other.get_ref());\n         iter::order::partial_cmp(a_iter, b_iter)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for BitvSet {\n+impl Ord for BitSet {\n     #[inline]\n-    fn cmp(&self, other: &BitvSet) -> Ordering {\n+    fn cmp(&self, other: &BitSet) -> Ordering {\n         let (a_iter, b_iter) = match_words(self.get_ref(), other.get_ref());\n         iter::order::cmp(a_iter, b_iter)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::PartialEq for BitvSet {\n+impl cmp::PartialEq for BitSet {\n     #[inline]\n-    fn eq(&self, other: &BitvSet) -> bool {\n+    fn eq(&self, other: &BitSet) -> bool {\n         let (a_iter, b_iter) = match_words(self.get_ref(), other.get_ref());\n         iter::order::eq(a_iter, b_iter)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Eq for BitvSet {}\n+impl cmp::Eq for BitSet {}\n \n-impl BitvSet {\n-    /// Creates a new empty `BitvSet`.\n+impl BitSet {\n+    /// Creates a new empty `BitSet`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BitvSet {\n-        BitvSet { bitv: Bitv::new() }\n+    pub fn new() -> BitSet {\n+        BitSet { bit_vec: BitVec::new() }\n     }\n \n-    /// Creates a new `BitvSet` with initially no contents, able to\n+    /// Creates a new `BitSet` with initially no contents, able to\n     /// hold `nbits` elements without resizing.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::with_capacity(100);\n+    /// let mut s = BitSet::with_capacity(100);\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(nbits: usize) -> BitvSet {\n-        let bitv = Bitv::from_elem(nbits, false);\n-        BitvSet::from_bitv(bitv)\n+    pub fn with_capacity(nbits: usize) -> BitSet {\n+        let bit_vec = BitVec::from_elem(nbits, false);\n+        BitSet::from_bit_vec(bit_vec)\n     }\n \n-    /// Creates a new `BitvSet` from the given bit vector.\n+    /// Creates a new `BitSet` from the given bit vector.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{Bitv, BitvSet};\n+    /// use std::collections::{BitVec, BitSet};\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b01100000]);\n-    /// let s = BitvSet::from_bitv(bv);\n+    /// let bv = BitVec::from_bytes(&[0b01100000]);\n+    /// let s = BitSet::from_bit_vec(bv);\n     ///\n     /// // Print 1, 2 in arbitrary order\n     /// for x in s.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n     #[inline]\n-    pub fn from_bitv(bitv: Bitv) -> BitvSet {\n-        BitvSet { bitv: bitv }\n+    pub fn from_bit_vec(bit_vec: BitVec) -> BitSet {\n+        BitSet { bit_vec: bit_vec }\n+    }\n+\n+    /// Deprecated: use `from_bit_vec`.\n+    #[inline]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to from_bit_vec\")]\n+    #[unstable(feature = \"collections\")]\n+    pub fn from_bitv(bit_vec: BitVec) -> BitSet {\n+        BitSet { bit_vec: bit_vec }\n     }\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n@@ -1251,19 +1260,19 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::with_capacity(100);\n+    /// let mut s = BitSet::with_capacity(100);\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.bitv.capacity()\n+        self.bit_vec.capacity()\n     }\n \n-    /// Reserves capacity for the given `BitvSet` to contain `len` distinct elements. In the case\n-    /// of `BitvSet` this means reallocations will not occur as long as all inserted elements\n+    /// Reserves capacity for the given `BitSet` to contain `len` distinct elements. In the case\n+    /// of `BitSet` this means reallocations will not occur as long as all inserted elements\n     /// are less than `len`.\n     ///\n     /// The collection may reserve more space to avoid frequent reallocations.\n@@ -1272,22 +1281,22 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.reserve_len(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len(&mut self, len: usize) {\n-        let cur_len = self.bitv.len();\n+        let cur_len = self.bit_vec.len();\n         if len >= cur_len {\n-            self.bitv.reserve(len - cur_len);\n+            self.bit_vec.reserve(len - cur_len);\n         }\n     }\n \n-    /// Reserves the minimum capacity for the given `BitvSet` to contain `len` distinct elements.\n-    /// In the case of `BitvSet` this means reallocations will not occur as long as all inserted\n+    /// Reserves the minimum capacity for the given `BitSet` to contain `len` distinct elements.\n+    /// In the case of `BitSet` this means reallocations will not occur as long as all inserted\n     /// elements are less than `len`.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n@@ -1298,17 +1307,17 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.reserve_len_exact(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len_exact(&mut self, len: usize) {\n-        let cur_len = self.bitv.len();\n+        let cur_len = self.bit_vec.len();\n         if len >= cur_len {\n-            self.bitv.reserve_exact(len - cur_len);\n+            self.bit_vec.reserve_exact(len - cur_len);\n         }\n     }\n \n@@ -1318,64 +1327,64 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.insert(0);\n     /// s.insert(3);\n     ///\n-    /// let bv = s.into_bitv();\n+    /// let bv = s.into_bit_vec();\n     /// assert!(bv[0]);\n     /// assert!(bv[3]);\n     /// ```\n     #[inline]\n-    pub fn into_bitv(self) -> Bitv {\n-        self.bitv\n+    pub fn into_bit_vec(self) -> BitVec {\n+        self.bit_vec\n     }\n \n     /// Returns a reference to the underlying bit vector.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.insert(0);\n     ///\n     /// let bv = s.get_ref();\n     /// assert_eq!(bv[0], true);\n     /// ```\n     #[inline]\n-    pub fn get_ref(&self) -> &Bitv {\n-        &self.bitv\n+    pub fn get_ref(&self) -> &BitVec {\n+        &self.bit_vec\n     }\n \n     #[inline]\n-    fn other_op<F>(&mut self, other: &BitvSet, mut f: F) where F: FnMut(u32, u32) -> u32 {\n-        // Unwrap Bitvs\n-        let self_bitv = &mut self.bitv;\n-        let other_bitv = &other.bitv;\n+    fn other_op<F>(&mut self, other: &BitSet, mut f: F) where F: FnMut(u32, u32) -> u32 {\n+        // Unwrap BitVecs\n+        let self_bit_vec = &mut self.bit_vec;\n+        let other_bit_vec = &other.bit_vec;\n \n-        let self_len = self_bitv.len();\n-        let other_len = other_bitv.len();\n+        let self_len = self_bit_vec.len();\n+        let other_len = other_bit_vec.len();\n \n         // Expand the vector if necessary\n         if self_len < other_len {\n-            self_bitv.grow(other_len - self_len, false);\n+            self_bit_vec.grow(other_len - self_len, false);\n         }\n \n         // virtually pad other with 0's for equal lengths\n         let other_words = {\n-            let (_, result) = match_words(self_bitv, other_bitv);\n+            let (_, result) = match_words(self_bit_vec, other_bit_vec);\n             result\n         };\n \n         // Apply values found in other\n         for (i, w) in other_words {\n-            let old = self_bitv.storage[i];\n+            let old = self_bit_vec.storage[i];\n             let new = f(old, w);\n-            self_bitv.storage[i] = new;\n+            self_bit_vec.storage[i] = new;\n         }\n     }\n \n@@ -1384,9 +1393,9 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.insert(32183231);\n     /// s.remove(&32183231);\n     ///\n@@ -1400,25 +1409,25 @@ impl BitvSet {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n-        let bitv = &mut self.bitv;\n+        let bit_vec = &mut self.bit_vec;\n         // Obtain original length\n-        let old_len = bitv.storage.len();\n+        let old_len = bit_vec.storage.len();\n         // Obtain coarse trailing zero length\n-        let n = bitv.storage.iter().rev().take_while(|&&n| n == 0).count();\n+        let n = bit_vec.storage.iter().rev().take_while(|&&n| n == 0).count();\n         // Truncate\n         let trunc_len = cmp::max(old_len - n, 1);\n-        bitv.storage.truncate(trunc_len);\n-        bitv.nbits = trunc_len * u32::BITS;\n+        bit_vec.storage.truncate(trunc_len);\n+        bit_vec.nbits = trunc_len * u32::BITS;\n     }\n \n-    /// Iterator over each u32 stored in the `BitvSet`.\n+    /// Iterator over each u32 stored in the `BitSet`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{Bitv, BitvSet};\n+    /// use std::collections::{BitVec, BitSet};\n     ///\n-    /// let s = BitvSet::from_bitv(Bitv::from_bytes(&[0b01001010]));\n+    /// let s = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01001010]));\n     ///\n     /// // Print 1, 4, 6 in arbitrary order\n     /// for x in s.iter() {\n@@ -1427,7 +1436,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> bitv_set::Iter {\n+    pub fn iter(&self) -> bit_set::Iter {\n         SetIter {set: self, next_idx: 0}\n     }\n \n@@ -1437,10 +1446,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{Bitv, BitvSet};\n+    /// use std::collections::{BitVec, BitSet};\n     ///\n-    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 0, 1, 2, 4 in arbitrary order\n     /// for x in a.union(&b) {\n@@ -1449,7 +1458,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn union<'a>(&'a self, other: &'a BitvSet) -> Union<'a> {\n+    pub fn union<'a>(&'a self, other: &'a BitSet) -> Union<'a> {\n         fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n \n         Union(TwoBitPositions {\n@@ -1467,10 +1476,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{Bitv, BitvSet};\n+    /// use std::collections::{BitVec, BitSet};\n     ///\n-    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 2\n     /// for x in a.intersection(&b) {\n@@ -1479,9 +1488,9 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Intersection<'a> {\n+    pub fn intersection<'a>(&'a self, other: &'a BitSet) -> Intersection<'a> {\n         fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n-        let min = cmp::min(self.bitv.len(), other.bitv.len());\n+        let min = cmp::min(self.bit_vec.len(), other.bit_vec.len());\n         Intersection(TwoBitPositions {\n             set: self,\n             other: other,\n@@ -1497,10 +1506,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n-    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 1, 4 in arbitrary order\n     /// for x in a.difference(&b) {\n@@ -1516,7 +1525,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn difference<'a>(&'a self, other: &'a BitvSet) -> Difference<'a> {\n+    pub fn difference<'a>(&'a self, other: &'a BitSet) -> Difference<'a> {\n         fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n \n         Difference(TwoBitPositions {\n@@ -1535,10 +1544,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n-    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 0, 1, 4 in arbitrary order\n     /// for x in a.symmetric_difference(&b) {\n@@ -1547,7 +1556,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> SymmetricDifference<'a> {\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a BitSet) -> SymmetricDifference<'a> {\n         fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n \n         SymmetricDifference(TwoBitPositions {\n@@ -1564,21 +1573,21 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b11101000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n+    /// let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n+    /// let res = BitSet::from_bit_vec(BitVec::from_bytes(&[res]));\n     ///\n     /// a.union_with(&b);\n     /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n-    pub fn union_with(&mut self, other: &BitvSet) {\n+    pub fn union_with(&mut self, other: &BitSet) {\n         self.other_op(other, |w1, w2| w1 | w2);\n     }\n \n@@ -1587,21 +1596,21 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b00100000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n+    /// let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n+    /// let res = BitSet::from_bit_vec(BitVec::from_bytes(&[res]));\n     ///\n     /// a.intersect_with(&b);\n     /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n-    pub fn intersect_with(&mut self, other: &BitvSet) {\n+    pub fn intersect_with(&mut self, other: &BitSet) {\n         self.other_op(other, |w1, w2| w1 & w2);\n     }\n \n@@ -1611,29 +1620,29 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let a_b = 0b01001000; // a - b\n     /// let b_a = 0b10000000; // b - a\n     ///\n-    /// let mut bva = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let bvb = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n-    /// let bva_b = BitvSet::from_bitv(Bitv::from_bytes(&[a_b]));\n-    /// let bvb_a = BitvSet::from_bitv(Bitv::from_bytes(&[b_a]));\n+    /// let mut bva = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let bvb = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n+    /// let bva_b = BitSet::from_bit_vec(BitVec::from_bytes(&[a_b]));\n+    /// let bvb_a = BitSet::from_bit_vec(BitVec::from_bytes(&[b_a]));\n     ///\n     /// bva.difference_with(&bvb);\n     /// assert_eq!(bva, bva_b);\n     ///\n-    /// let bva = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let mut bvb = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n+    /// let bva = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let mut bvb = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n     ///\n     /// bvb.difference_with(&bva);\n     /// assert_eq!(bvb, bvb_a);\n     /// ```\n     #[inline]\n-    pub fn difference_with(&mut self, other: &BitvSet) {\n+    pub fn difference_with(&mut self, other: &BitSet) {\n         self.other_op(other, |w1, w2| w1 & !w2);\n     }\n \n@@ -1643,79 +1652,79 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b11001000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n+    /// let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n+    /// let res = BitSet::from_bit_vec(BitVec::from_bytes(&[res]));\n     ///\n     /// a.symmetric_difference_with(&b);\n     /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n-    pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n+    pub fn symmetric_difference_with(&mut self, other: &BitSet) {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n \n     /// Return the number of set bits in this set.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize  {\n-        self.bitv.blocks().fold(0, |acc, n| acc + n.count_ones())\n+        self.bit_vec.blocks().fold(0, |acc, n| acc + n.count_ones())\n     }\n \n     /// Returns whether there are no bits set in this set\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.bitv.none()\n+        self.bit_vec.none()\n     }\n \n     /// Clears all bits in this set\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        self.bitv.clear();\n+        self.bit_vec.clear();\n     }\n \n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains(&self, value: &usize) -> bool {\n-        let bitv = &self.bitv;\n-        *value < bitv.nbits && bitv[*value]\n+        let bit_vec = &self.bit_vec;\n+        *value < bit_vec.nbits && bit_vec[*value]\n     }\n \n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_disjoint(&self, other: &BitvSet) -> bool {\n+    pub fn is_disjoint(&self, other: &BitSet) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n     /// Returns `true` if the set is a subset of another.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_subset(&self, other: &BitvSet) -> bool {\n-        let self_bitv = &self.bitv;\n-        let other_bitv = &other.bitv;\n-        let other_blocks = blocks_for_bits(other_bitv.len());\n+    pub fn is_subset(&self, other: &BitSet) -> bool {\n+        let self_bit_vec = &self.bit_vec;\n+        let other_bit_vec = &other.bit_vec;\n+        let other_blocks = blocks_for_bits(other_bit_vec.len());\n \n         // Check that `self` intersect `other` is self\n-        self_bitv.blocks().zip(other_bitv.blocks()).all(|(w1, w2)| w1 & w2 == w1) &&\n+        self_bit_vec.blocks().zip(other_bit_vec.blocks()).all(|(w1, w2)| w1 & w2 == w1) &&\n         // Make sure if `self` has any more blocks than `other`, they're all 0\n-        self_bitv.blocks().skip(other_blocks).all(|w| w == 0)\n+        self_bit_vec.blocks().skip(other_blocks).all(|w| w == 0)\n     }\n \n     /// Returns `true` if the set is a superset of another.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_superset(&self, other: &BitvSet) -> bool {\n+    pub fn is_superset(&self, other: &BitSet) -> bool {\n         other.is_subset(self)\n     }\n \n@@ -1728,12 +1737,12 @@ impl BitvSet {\n         }\n \n         // Ensure we have enough space to hold the new element\n-        let len = self.bitv.len();\n+        let len = self.bit_vec.len();\n         if value >= len {\n-            self.bitv.grow(value - len + 1, false)\n+            self.bit_vec.grow(value - len + 1, false)\n         }\n \n-        self.bitv.set(value, true);\n+        self.bit_vec.set(value, true);\n         return true;\n     }\n \n@@ -1745,16 +1754,16 @@ impl BitvSet {\n             return false;\n         }\n \n-        self.bitv.set(*value, false);\n+        self.bit_vec.set(*value, false);\n \n         return true;\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for BitvSet {\n+impl fmt::Debug for BitSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"BitvSet {{\"));\n+        try!(write!(fmt, \"BitSet {{\"));\n         let mut first = true;\n         for n in self {\n             if !first {\n@@ -1768,7 +1777,7 @@ impl fmt::Debug for BitvSet {\n }\n \n #[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitSet {\n     fn hash(&self, state: &mut S) {\n         for pos in self {\n             pos.hash(state);\n@@ -1777,27 +1786,27 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg(not(stage0))]\n-impl hash::Hash for BitvSet {\n+impl hash::Hash for BitSet {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         for pos in self {\n             pos.hash(state);\n         }\n     }\n }\n \n-/// An iterator for `BitvSet`.\n+/// An iterator for `BitSet`.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SetIter<'a> {\n-    set: &'a BitvSet,\n+    set: &'a BitSet,\n     next_idx: usize\n }\n \n-/// An iterator combining two `BitvSet` iterators.\n+/// An iterator combining two `BitSet` iterators.\n #[derive(Clone)]\n struct TwoBitPositions<'a> {\n-    set: &'a BitvSet,\n-    other: &'a BitvSet,\n+    set: &'a BitSet,\n+    other: &'a BitSet,\n     merge: fn(u32, u32) -> u32,\n     current_word: u32,\n     next_idx: usize\n@@ -1817,7 +1826,7 @@ impl<'a> Iterator for SetIter<'a> {\n     type Item = usize;\n \n     fn next(&mut self) -> Option<usize> {\n-        while self.next_idx < self.set.bitv.len() {\n+        while self.next_idx < self.set.bit_vec.len() {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n \n@@ -1831,7 +1840,7 @@ impl<'a> Iterator for SetIter<'a> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.set.bitv.len() - self.next_idx))\n+        (0, Some(self.set.bit_vec.len() - self.next_idx))\n     }\n }\n \n@@ -1840,20 +1849,20 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n     type Item = usize;\n \n     fn next(&mut self) -> Option<usize> {\n-        while self.next_idx < self.set.bitv.len() ||\n-              self.next_idx < self.other.bitv.len() {\n+        while self.next_idx < self.set.bit_vec.len() ||\n+              self.next_idx < self.other.bit_vec.len() {\n             let bit_idx = self.next_idx % u32::BITS;\n             if bit_idx == 0 {\n-                let s_bitv = &self.set.bitv;\n-                let o_bitv = &self.other.bitv;\n+                let s_bit_vec = &self.set.bit_vec;\n+                let o_bit_vec = &self.other.bit_vec;\n                 // Merging the two words is a bit of an awkward dance since\n-                // one Bitv might be longer than the other\n+                // one BitVec might be longer than the other\n                 let word_idx = self.next_idx / u32::BITS;\n-                let w1 = if word_idx < s_bitv.storage.len() {\n-                             s_bitv.storage[word_idx]\n+                let w1 = if word_idx < s_bit_vec.storage.len() {\n+                             s_bit_vec.storage[word_idx]\n                          } else { 0 };\n-                let w2 = if word_idx < o_bitv.storage.len() {\n-                             o_bitv.storage[word_idx]\n+                let w2 = if word_idx < o_bit_vec.storage.len() {\n+                             o_bit_vec.storage[word_idx]\n                          } else { 0 };\n                 self.current_word = (self.merge)(w1, w2);\n             }\n@@ -1868,7 +1877,7 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let cap = cmp::max(self.set.bitv.len(), self.other.bitv.len());\n+        let cap = cmp::max(self.set.bit_vec.len(), self.other.bit_vec.len());\n         (0, Some(cap - self.next_idx))\n     }\n }\n@@ -1906,7 +1915,7 @@ impl<'a> Iterator for SymmetricDifference<'a> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> IntoIterator for &'a BitvSet {\n+impl<'a> IntoIterator for &'a BitSet {\n     type Item = usize;\n     type IntoIter = SetIter<'a>;\n \n@@ -1920,38 +1929,38 @@ mod tests {\n     use prelude::*;\n     use core::u32;\n \n-    use super::Bitv;\n+    use super::BitVec;\n \n     #[test]\n     fn test_to_str() {\n-        let zerolen = Bitv::new();\n+        let zerolen = BitVec::new();\n         assert_eq!(format!(\"{:?}\", zerolen), \"\");\n \n-        let eightbits = Bitv::from_elem(8, false);\n+        let eightbits = BitVec::from_elem(8, false);\n         assert_eq!(format!(\"{:?}\", eightbits), \"00000000\")\n     }\n \n     #[test]\n     fn test_0_elements() {\n-        let act = Bitv::new();\n+        let act = BitVec::new();\n         let exp = Vec::new();\n         assert!(act.eq_vec(&exp));\n         assert!(act.none() && act.all());\n     }\n \n     #[test]\n     fn test_1_element() {\n-        let mut act = Bitv::from_elem(1, false);\n+        let mut act = BitVec::from_elem(1, false);\n         assert!(act.eq_vec(&[false]));\n         assert!(act.none() && !act.all());\n-        act = Bitv::from_elem(1, true);\n+        act = BitVec::from_elem(1, true);\n         assert!(act.eq_vec(&[true]));\n         assert!(!act.none() && act.all());\n     }\n \n     #[test]\n     fn test_2_elements() {\n-        let mut b = Bitv::from_elem(2, false);\n+        let mut b = BitVec::from_elem(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert_eq!(format!(\"{:?}\", b), \"10\");\n@@ -1963,18 +1972,18 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(10, false);\n+        act = BitVec::from_elem(10, false);\n         assert!((act.eq_vec(\n                     &[false, false, false, false, false, false, false, false, false, false])));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(10, true);\n+        act = BitVec::from_elem(10, true);\n         assert!((act.eq_vec(&[true, true, true, true, true, true, true, true, true, true])));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10, false);\n+        act = BitVec::from_elem(10, false);\n         act.set(0, true);\n         act.set(1, true);\n         act.set(2, true);\n@@ -1984,7 +1993,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10, false);\n+        act = BitVec::from_elem(10, false);\n         act.set(5, true);\n         act.set(6, true);\n         act.set(7, true);\n@@ -1994,7 +2003,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10, false);\n+        act = BitVec::from_elem(10, false);\n         act.set(0, true);\n         act.set(3, true);\n         act.set(6, true);\n@@ -2008,23 +2017,23 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(31, true);\n+        act = BitVec::from_elem(31, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         act.set(0, true);\n         act.set(1, true);\n         act.set(2, true);\n@@ -2040,7 +2049,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         act.set(16, true);\n         act.set(17, true);\n         act.set(18, true);\n@@ -2056,7 +2065,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         act.set(24, true);\n         act.set(25, true);\n         act.set(26, true);\n@@ -2071,7 +2080,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         act.set(3, true);\n         act.set(17, true);\n         act.set(30, true);\n@@ -2087,23 +2096,23 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(32, true);\n+        act = BitVec::from_elem(32, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         act.set(0, true);\n         act.set(1, true);\n         act.set(2, true);\n@@ -2119,7 +2128,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         act.set(16, true);\n         act.set(17, true);\n         act.set(18, true);\n@@ -2135,7 +2144,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         act.set(24, true);\n         act.set(25, true);\n         act.set(26, true);\n@@ -2151,7 +2160,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         act.set(3, true);\n         act.set(17, true);\n         act.set(30, true);\n@@ -2168,23 +2177,23 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(33, true);\n+        act = BitVec::from_elem(33, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         act.set(0, true);\n         act.set(1, true);\n         act.set(2, true);\n@@ -2200,7 +2209,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         act.set(16, true);\n         act.set(17, true);\n         act.set(18, true);\n@@ -2216,7 +2225,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         act.set(24, true);\n         act.set(25, true);\n         act.set(26, true);\n@@ -2232,7 +2241,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         act.set(3, true);\n         act.set(17, true);\n         act.set(30, true);\n@@ -2247,37 +2256,37 @@ mod tests {\n \n     #[test]\n     fn test_equal_differing_sizes() {\n-        let v0 = Bitv::from_elem(10, false);\n-        let v1 = Bitv::from_elem(11, false);\n+        let v0 = BitVec::from_elem(10, false);\n+        let v1 = BitVec::from_elem(11, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_greatly_differing_sizes() {\n-        let v0 = Bitv::from_elem(10, false);\n-        let v1 = Bitv::from_elem(110, false);\n+        let v0 = BitVec::from_elem(10, false);\n+        let v1 = BitVec::from_elem(110, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_sneaky_small() {\n-        let mut a = Bitv::from_elem(1, false);\n+        let mut a = BitVec::from_elem(1, false);\n         a.set(0, true);\n \n-        let mut b = Bitv::from_elem(1, true);\n+        let mut b = BitVec::from_elem(1, true);\n         b.set(0, true);\n \n         assert_eq!(a, b);\n     }\n \n     #[test]\n     fn test_equal_sneaky_big() {\n-        let mut a = Bitv::from_elem(100, false);\n+        let mut a = BitVec::from_elem(100, false);\n         for i in 0..100 {\n             a.set(i, true);\n         }\n \n-        let mut b = Bitv::from_elem(100, true);\n+        let mut b = BitVec::from_elem(100, true);\n         for i in 0..100 {\n             b.set(i, true);\n         }\n@@ -2287,18 +2296,18 @@ mod tests {\n \n     #[test]\n     fn test_from_bytes() {\n-        let bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+        let bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n         let str = concat!(\"10110110\", \"00000000\", \"11111111\");\n-        assert_eq!(format!(\"{:?}\", bitv), str);\n+        assert_eq!(format!(\"{:?}\", bit_vec), str);\n     }\n \n     #[test]\n     fn test_to_bytes() {\n-        let mut bv = Bitv::from_elem(3, true);\n+        let mut bv = BitVec::from_elem(3, true);\n         bv.set(1, false);\n         assert_eq!(bv.to_bytes(), vec!(0b10100000));\n \n-        let mut bv = Bitv::from_elem(9, false);\n+        let mut bv = BitVec::from_elem(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n         assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n@@ -2307,32 +2316,32 @@ mod tests {\n     #[test]\n     fn test_from_bools() {\n         let bools = vec![true, false, true, true];\n-        let bitv: Bitv = bools.iter().cloned().collect();\n-        assert_eq!(format!(\"{:?}\", bitv), \"1011\");\n+        let bit_vec: BitVec = bools.iter().map(|n| *n).collect();\n+        assert_eq!(format!(\"{:?}\", bit_vec), \"1011\");\n     }\n \n     #[test]\n     fn test_to_bools() {\n         let bools = vec![false, false, true, false, false, true, true, false];\n-        assert_eq!(Bitv::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n+        assert_eq!(BitVec::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n     }\n \n     #[test]\n-    fn test_bitv_iterator() {\n+    fn test_bit_vec_iterator() {\n         let bools = vec![true, false, true, true];\n-        let bitv: Bitv = bools.iter().cloned().collect();\n+        let bit_vec: BitVec = bools.iter().map(|n| *n).collect();\n \n-        assert_eq!(bitv.iter().collect::<Vec<bool>>(), bools);\n+        assert_eq!(bit_vec.iter().collect::<Vec<bool>>(), bools);\n \n         let long: Vec<_> = (0i32..10000).map(|i| i % 2 == 0).collect();\n-        let bitv: Bitv = long.iter().cloned().collect();\n-        assert_eq!(bitv.iter().collect::<Vec<bool>>(), long)\n+        let bit_vec: BitVec = long.iter().map(|n| *n).collect();\n+        assert_eq!(bit_vec.iter().collect::<Vec<bool>>(), long)\n     }\n \n     #[test]\n     fn test_small_difference() {\n-        let mut b1 = Bitv::from_elem(3, false);\n-        let mut b2 = Bitv::from_elem(3, false);\n+        let mut b1 = BitVec::from_elem(3, false);\n+        let mut b2 = BitVec::from_elem(3, false);\n         b1.set(0, true);\n         b1.set(1, true);\n         b2.set(1, true);\n@@ -2345,8 +2354,8 @@ mod tests {\n \n     #[test]\n     fn test_big_difference() {\n-        let mut b1 = Bitv::from_elem(100, false);\n-        let mut b2 = Bitv::from_elem(100, false);\n+        let mut b1 = BitVec::from_elem(100, false);\n+        let mut b2 = BitVec::from_elem(100, false);\n         b1.set(0, true);\n         b1.set(40, true);\n         b2.set(40, true);\n@@ -2359,24 +2368,24 @@ mod tests {\n \n     #[test]\n     fn test_small_clear() {\n-        let mut b = Bitv::from_elem(14, true);\n+        let mut b = BitVec::from_elem(14, true);\n         assert!(!b.none() && b.all());\n         b.clear();\n         assert!(b.none() && !b.all());\n     }\n \n     #[test]\n     fn test_big_clear() {\n-        let mut b = Bitv::from_elem(140, true);\n+        let mut b = BitVec::from_elem(140, true);\n         assert!(!b.none() && b.all());\n         b.clear();\n         assert!(b.none() && !b.all());\n     }\n \n     #[test]\n-    fn test_bitv_lt() {\n-        let mut a = Bitv::from_elem(5, false);\n-        let mut b = Bitv::from_elem(5, false);\n+    fn test_bit_vec_lt() {\n+        let mut a = BitVec::from_elem(5, false);\n+        let mut b = BitVec::from_elem(5, false);\n \n         assert!(!(a < b) && !(b < a));\n         b.set(2, true);\n@@ -2391,8 +2400,8 @@ mod tests {\n \n     #[test]\n     fn test_ord() {\n-        let mut a = Bitv::from_elem(5, false);\n-        let mut b = Bitv::from_elem(5, false);\n+        let mut a = BitVec::from_elem(5, false);\n+        let mut b = BitVec::from_elem(5, false);\n \n         assert!(a <= b && a >= b);\n         a.set(1, true);\n@@ -2406,42 +2415,42 @@ mod tests {\n \n \n     #[test]\n-    fn test_small_bitv_tests() {\n-        let v = Bitv::from_bytes(&[0]);\n+    fn test_small_bit_vec_tests() {\n+        let v = BitVec::from_bytes(&[0]);\n         assert!(!v.all());\n         assert!(!v.any());\n         assert!(v.none());\n \n-        let v = Bitv::from_bytes(&[0b00010100]);\n+        let v = BitVec::from_bytes(&[0b00010100]);\n         assert!(!v.all());\n         assert!(v.any());\n         assert!(!v.none());\n \n-        let v = Bitv::from_bytes(&[0xFF]);\n+        let v = BitVec::from_bytes(&[0xFF]);\n         assert!(v.all());\n         assert!(v.any());\n         assert!(!v.none());\n     }\n \n     #[test]\n-    fn test_big_bitv_tests() {\n-        let v = Bitv::from_bytes(&[ // 88 bits\n+    fn test_big_bit_vec_tests() {\n+        let v = BitVec::from_bytes(&[ // 88 bits\n             0, 0, 0, 0,\n             0, 0, 0, 0,\n             0, 0, 0]);\n         assert!(!v.all());\n         assert!(!v.any());\n         assert!(v.none());\n \n-        let v = Bitv::from_bytes(&[ // 88 bits\n+        let v = BitVec::from_bytes(&[ // 88 bits\n             0, 0, 0b00010100, 0,\n             0, 0, 0, 0b00110100,\n             0, 0, 0]);\n         assert!(!v.all());\n         assert!(v.any());\n         assert!(!v.none());\n \n-        let v = Bitv::from_bytes(&[ // 88 bits\n+        let v = BitVec::from_bytes(&[ // 88 bits\n             0xFF, 0xFF, 0xFF, 0xFF,\n             0xFF, 0xFF, 0xFF, 0xFF,\n             0xFF, 0xFF, 0xFF]);\n@@ -2451,8 +2460,8 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitv_push_pop() {\n-        let mut s = Bitv::from_elem(5 * u32::BITS - 2, false);\n+    fn test_bit_vec_push_pop() {\n+        let mut s = BitVec::from_elem(5 * u32::BITS - 2, false);\n         assert_eq!(s.len(), 5 * u32::BITS - 2);\n         assert_eq!(s[5 * u32::BITS - 3], false);\n         s.push(true);\n@@ -2474,29 +2483,29 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitv_truncate() {\n-        let mut s = Bitv::from_elem(5 * u32::BITS, true);\n+    fn test_bit_vec_truncate() {\n+        let mut s = BitVec::from_elem(5 * u32::BITS, true);\n \n-        assert_eq!(s, Bitv::from_elem(5 * u32::BITS, true));\n+        assert_eq!(s, BitVec::from_elem(5 * u32::BITS, true));\n         assert_eq!(s.len(), 5 * u32::BITS);\n         s.truncate(4 * u32::BITS);\n-        assert_eq!(s, Bitv::from_elem(4 * u32::BITS, true));\n+        assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n         assert_eq!(s.len(), 4 * u32::BITS);\n         // Truncating to a size > s.len() should be a noop\n         s.truncate(5 * u32::BITS);\n-        assert_eq!(s, Bitv::from_elem(4 * u32::BITS, true));\n+        assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n         assert_eq!(s.len(), 4 * u32::BITS);\n         s.truncate(3 * u32::BITS - 10);\n-        assert_eq!(s, Bitv::from_elem(3 * u32::BITS - 10, true));\n+        assert_eq!(s, BitVec::from_elem(3 * u32::BITS - 10, true));\n         assert_eq!(s.len(), 3 * u32::BITS - 10);\n         s.truncate(0);\n-        assert_eq!(s, Bitv::from_elem(0, true));\n+        assert_eq!(s, BitVec::from_elem(0, true));\n         assert_eq!(s.len(), 0);\n     }\n \n     #[test]\n-    fn test_bitv_reserve() {\n-        let mut s = Bitv::from_elem(5 * u32::BITS, true);\n+    fn test_bit_vec_reserve() {\n+        let mut s = BitVec::from_elem(5 * u32::BITS, true);\n         // Check capacity\n         assert!(s.capacity() >= 5 * u32::BITS);\n         s.reserve(2 * u32::BITS);\n@@ -2519,25 +2528,25 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitv_grow() {\n-        let mut bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n-        bitv.grow(32, true);\n-        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+    fn test_bit_vec_grow() {\n+        let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n+        bit_vec.grow(32, true);\n+        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n                                      0xFF, 0xFF, 0xFF, 0xFF]));\n-        bitv.grow(64, false);\n-        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+        bit_vec.grow(64, false);\n+        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n                                      0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n-        bitv.grow(16, true);\n-        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+        bit_vec.grow(16, true);\n+        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n                                      0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n     }\n \n     #[test]\n-    fn test_bitv_extend() {\n-        let mut bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n-        let ext = Bitv::from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n-        bitv.extend(ext.iter());\n-        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n+    fn test_bit_vec_extend() {\n+        let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+        let ext = BitVec::from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n+        bit_vec.extend(ext.iter());\n+        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n                                      0b01001001, 0b10010010, 0b10111101]));\n     }\n }\n@@ -2546,14 +2555,14 @@ mod tests {\n \n \n #[cfg(test)]\n-mod bitv_bench {\n+mod bit_vec_bench {\n     use std::prelude::v1::*;\n     use std::rand;\n     use std::rand::Rng;\n     use std::u32;\n     use test::{Bencher, black_box};\n \n-    use super::Bitv;\n+    use super::BitVec;\n \n     static BENCH_BITS : usize = 1 << 14;\n \n@@ -2565,67 +2574,67 @@ mod bitv_bench {\n     #[bench]\n     fn bench_usize_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = 0 as usize;\n+        let mut bit_vec = 0 as usize;\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv |= 1 << ((r.next_u32() as usize) % u32::BITS);\n+                bit_vec |= 1 << ((r.next_u32() as usize) % u32::BITS);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitv_set_big_fixed(b: &mut Bencher) {\n+    fn bench_bit_set_big_fixed(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n+        let mut bit_vec = BitVec::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.set((r.next_u32() as usize) % BENCH_BITS, true);\n+                bit_vec.set((r.next_u32() as usize) % BENCH_BITS, true);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitv_set_big_variable(b: &mut Bencher) {\n+    fn bench_bit_set_big_variable(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n+        let mut bit_vec = BitVec::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.set((r.next_u32() as usize) % BENCH_BITS, r.gen());\n+                bit_vec.set((r.next_u32() as usize) % BENCH_BITS, r.gen());\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitv_set_small(b: &mut Bencher) {\n+    fn bench_bit_set_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::from_elem(u32::BITS, false);\n+        let mut bit_vec = BitVec::from_elem(u32::BITS, false);\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.set((r.next_u32() as usize) % u32::BITS, true);\n+                bit_vec.set((r.next_u32() as usize) % u32::BITS, true);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitv_big_union(b: &mut Bencher) {\n-        let mut b1 = Bitv::from_elem(BENCH_BITS, false);\n-        let b2 = Bitv::from_elem(BENCH_BITS, false);\n+    fn bench_bit_vec_big_union(b: &mut Bencher) {\n+        let mut b1 = BitVec::from_elem(BENCH_BITS, false);\n+        let b2 = BitVec::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             b1.union(&b2)\n         })\n     }\n \n     #[bench]\n-    fn bench_bitv_small_iter(b: &mut Bencher) {\n-        let bitv = Bitv::from_elem(u32::BITS, false);\n+    fn bench_bit_vec_small_iter(b: &mut Bencher) {\n+        let bit_vec = BitVec::from_elem(u32::BITS, false);\n         b.iter(|| {\n             let mut sum = 0;\n             for _ in 0..10 {\n-                for pres in &bitv {\n+                for pres in &bit_vec {\n                     sum += pres as usize;\n                 }\n             }\n@@ -2634,11 +2643,11 @@ mod bitv_bench {\n     }\n \n     #[bench]\n-    fn bench_bitv_big_iter(b: &mut Bencher) {\n-        let bitv = Bitv::from_elem(BENCH_BITS, false);\n+    fn bench_bit_vec_big_iter(b: &mut Bencher) {\n+        let bit_vec = BitVec::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             let mut sum = 0;\n-            for pres in &bitv {\n+            for pres in &bit_vec {\n                 sum += pres as usize;\n             }\n             sum\n@@ -2653,55 +2662,55 @@ mod bitv_bench {\n \n \n #[cfg(test)]\n-mod bitv_set_test {\n+mod bit_set_test {\n     use prelude::*;\n     use std::iter::range_step;\n \n-    use super::{Bitv, BitvSet};\n+    use super::{BitVec, BitSet};\n \n     #[test]\n-    fn test_bitv_set_show() {\n-        let mut s = BitvSet::new();\n+    fn test_bit_set_show() {\n+        let mut s = BitSet::new();\n         s.insert(1);\n         s.insert(10);\n         s.insert(50);\n         s.insert(2);\n-        assert_eq!(\"BitvSet {1, 2, 10, 50}\", format!(\"{:?}\", s));\n+        assert_eq!(\"BitSet {1, 2, 10, 50}\", format!(\"{:?}\", s));\n     }\n \n     #[test]\n-    fn test_bitv_set_from_usizes() {\n+    fn test_bit_set_from_usizes() {\n         let usizes = vec![0, 2, 2, 3];\n-        let a: BitvSet = usizes.into_iter().collect();\n-        let mut b = BitvSet::new();\n+        let a: BitSet = usizes.into_iter().collect();\n+        let mut b = BitSet::new();\n         b.insert(0);\n         b.insert(2);\n         b.insert(3);\n         assert_eq!(a, b);\n     }\n \n     #[test]\n-    fn test_bitv_set_iterator() {\n+    fn test_bit_set_iterator() {\n         let usizes = vec![0, 2, 2, 3];\n-        let bitv: BitvSet = usizes.into_iter().collect();\n+        let bit_vec: BitSet = usizes.into_iter().collect();\n \n-        let idxs: Vec<_> = bitv.iter().collect();\n+        let idxs: Vec<_> = bit_vec.iter().collect();\n         assert_eq!(idxs, vec![0, 2, 3]);\n \n-        let long: BitvSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n+        let long: BitSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n         let real: Vec<_> = range_step(0, 10000, 2).collect();\n \n         let idxs: Vec<_> = long.iter().collect();\n         assert_eq!(idxs, real);\n     }\n \n     #[test]\n-    fn test_bitv_set_frombitv_init() {\n+    fn test_bit_set_frombit_vec_init() {\n         let bools = [true, false];\n         let lengths = [10, 64, 100];\n         for &b in &bools {\n             for &l in &lengths {\n-                let bitset = BitvSet::from_bitv(Bitv::from_elem(l, b));\n+                let bitset = BitSet::from_bit_vec(BitVec::from_elem(l, b));\n                 assert_eq!(bitset.contains(&1), b);\n                 assert_eq!(bitset.contains(&(l-1)), b);\n                 assert!(!bitset.contains(&l));\n@@ -2710,9 +2719,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_masking() {\n-        let b = Bitv::from_elem(140, true);\n-        let mut bs = BitvSet::from_bitv(b);\n+    fn test_bit_vec_masking() {\n+        let b = BitVec::from_elem(140, true);\n+        let mut bs = BitSet::from_bit_vec(b);\n         assert!(bs.contains(&139));\n         assert!(!bs.contains(&140));\n         assert!(bs.insert(150));\n@@ -2723,8 +2732,8 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_basic() {\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_basic() {\n+        let mut b = BitSet::new();\n         assert!(b.insert(3));\n         assert!(!b.insert(3));\n         assert!(b.contains(&3));\n@@ -2738,9 +2747,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_intersection() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_intersection() {\n+        let mut a = BitSet::new();\n+        let mut b = BitSet::new();\n \n         assert!(a.insert(11));\n         assert!(a.insert(1));\n@@ -2761,9 +2770,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_difference() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_difference() {\n+        let mut a = BitSet::new();\n+        let mut b = BitSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.insert(3));\n@@ -2780,9 +2789,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_symmetric_difference() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_symmetric_difference() {\n+        let mut a = BitSet::new();\n+        let mut b = BitSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.insert(3));\n@@ -2801,9 +2810,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_union() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_union() {\n+        let mut a = BitSet::new();\n+        let mut b = BitSet::new();\n         assert!(a.insert(1));\n         assert!(a.insert(3));\n         assert!(a.insert(5));\n@@ -2826,9 +2835,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_subset() {\n-        let mut set1 = BitvSet::new();\n-        let mut set2 = BitvSet::new();\n+    fn test_bit_set_subset() {\n+        let mut set1 = BitSet::new();\n+        let mut set2 = BitSet::new();\n \n         assert!(set1.is_subset(&set2)); //  {}  {}\n         set2.insert(100);\n@@ -2852,11 +2861,11 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_is_disjoint() {\n-        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01000000]));\n-        let c = BitvSet::new();\n-        let d = BitvSet::from_bitv(Bitv::from_bytes(&[0b00110000]));\n+    fn test_bit_set_is_disjoint() {\n+        let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01000000]));\n+        let c = BitSet::new();\n+        let d = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00110000]));\n \n         assert!(!a.is_disjoint(&d));\n         assert!(!d.is_disjoint(&a));\n@@ -2870,19 +2879,19 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_union_with() {\n+    fn test_bit_set_union_with() {\n         //a should grow to include larger elements\n-        let mut a = BitvSet::new();\n+        let mut a = BitSet::new();\n         a.insert(0);\n-        let mut b = BitvSet::new();\n+        let mut b = BitSet::new();\n         b.insert(5);\n-        let expected = BitvSet::from_bitv(Bitv::from_bytes(&[0b10000100]));\n+        let expected = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10000100]));\n         a.union_with(&b);\n         assert_eq!(a, expected);\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.union_with(&b);\n         b.union_with(&c);\n@@ -2891,28 +2900,28 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_intersect_with() {\n+    fn test_bit_set_intersect_with() {\n         // Explicitly 0'ed bits\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n         assert!(a.is_empty());\n         assert!(b.is_empty());\n \n         // Uninitialized bits should behave like 0's\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::new();\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::new();\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n         assert!(a.is_empty());\n         assert!(b.is_empty());\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n@@ -2921,22 +2930,22 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_difference_with() {\n+    fn test_bit_set_difference_with() {\n         // Explicitly 0'ed bits\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n         a.difference_with(&b);\n         assert!(a.is_empty());\n \n         // Uninitialized bits should behave like 0's\n-        let mut a = BitvSet::new();\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b11111111]));\n+        let mut a = BitSet::new();\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11111111]));\n         a.difference_with(&b);\n         assert!(a.is_empty());\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.difference_with(&b);\n         b.difference_with(&c);\n@@ -2945,27 +2954,27 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_symmetric_difference_with() {\n+    fn test_bit_set_symmetric_difference_with() {\n         //a should grow to include larger elements\n-        let mut a = BitvSet::new();\n+        let mut a = BitSet::new();\n         a.insert(0);\n         a.insert(1);\n-        let mut b = BitvSet::new();\n+        let mut b = BitSet::new();\n         b.insert(1);\n         b.insert(5);\n-        let expected = BitvSet::from_bitv(Bitv::from_bytes(&[0b10000100]));\n+        let expected = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10000100]));\n         a.symmetric_difference_with(&b);\n         assert_eq!(a, expected);\n \n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let b = BitvSet::new();\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let b = BitSet::new();\n         let c = a.clone();\n         a.symmetric_difference_with(&b);\n         assert_eq!(a, c);\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b11100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101010]));\n         let c = a.clone();\n         a.symmetric_difference_with(&b);\n         b.symmetric_difference_with(&c);\n@@ -2974,10 +2983,10 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_eq() {\n-        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n-        let c = BitvSet::new();\n+    fn test_bit_set_eq() {\n+        let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+        let c = BitSet::new();\n \n         assert!(a == a);\n         assert!(a != b);\n@@ -2988,10 +2997,10 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_cmp() {\n-        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n-        let c = BitvSet::new();\n+    fn test_bit_set_cmp() {\n+        let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+        let c = BitSet::new();\n \n         assert_eq!(a.cmp(&b), Greater);\n         assert_eq!(a.cmp(&c), Greater);\n@@ -3002,8 +3011,8 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_remove() {\n-        let mut a = BitvSet::new();\n+    fn test_bit_vec_remove() {\n+        let mut a = BitSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.remove(&1));\n@@ -3017,8 +3026,8 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_clone() {\n-        let mut a = BitvSet::new();\n+    fn test_bit_vec_clone() {\n+        let mut a = BitSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.insert(100));\n@@ -3041,14 +3050,14 @@ mod bitv_set_test {\n \n \n #[cfg(test)]\n-mod bitv_set_bench {\n+mod bit_set_bench {\n     use std::prelude::v1::*;\n     use std::rand;\n     use std::rand::Rng;\n     use std::u32;\n     use test::{Bencher, black_box};\n \n-    use super::{Bitv, BitvSet};\n+    use super::{BitVec, BitSet};\n \n     static BENCH_BITS : usize = 1 << 14;\n \n@@ -3058,36 +3067,36 @@ mod bitv_set_bench {\n     }\n \n     #[bench]\n-    fn bench_bitvset_small(b: &mut Bencher) {\n+    fn bench_bit_vecset_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = BitvSet::new();\n+        let mut bit_vec = BitSet::new();\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.insert((r.next_u32() as usize) % u32::BITS);\n+                bit_vec.insert((r.next_u32() as usize) % u32::BITS);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitvset_big(b: &mut Bencher) {\n+    fn bench_bit_vecset_big(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = BitvSet::new();\n+        let mut bit_vec = BitSet::new();\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.insert((r.next_u32() as usize) % BENCH_BITS);\n+                bit_vec.insert((r.next_u32() as usize) % BENCH_BITS);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitvset_iter(b: &mut Bencher) {\n-        let bitv = BitvSet::from_bitv(Bitv::from_fn(BENCH_BITS,\n+    fn bench_bit_vecset_iter(b: &mut Bencher) {\n+        let bit_vec = BitSet::from_bit_vec(BitVec::from_fn(BENCH_BITS,\n                                               |idx| {idx % 3 == 0}));\n         b.iter(|| {\n             let mut sum = 0;\n-            for idx in &bitv {\n+            for idx in &bit_vec {\n                 sum += idx as usize;\n             }\n             sum"}, {"sha": "a985a24f7aee714beb1662f741982c8273ac76ce", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -29,7 +29,7 @@ use core::ops::{Index, IndexMut};\n use core::{iter, fmt, mem};\n use Bound::{self, Included, Excluded, Unbounded};\n \n-use ring_buf::RingBuf;\n+use vec_deque::VecDeque;\n \n use self::Continuation::{Continue, Finished};\n use self::StackOp::*;\n@@ -75,7 +75,7 @@ pub struct BTreeMap<K, V> {\n \n /// An abstract base over-which all other BTree iterators are built.\n struct AbsIter<T> {\n-    traversals: RingBuf<T>,\n+    traversals: VecDeque<T>,\n     size: usize,\n }\n \n@@ -826,7 +826,7 @@ mod stack {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n-    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n+    fn from_iter<T: IntoIterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n         map.extend(iter);\n         map\n@@ -836,7 +836,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n-    fn extend<T: Iterator<Item=(K, V)>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -1199,7 +1199,7 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn iter(&self) -> Iter<K, V> {\n         let len = self.len();\n         // NB. The initial capacity for ringbuf is large enough to avoid reallocs in many cases.\n-        let mut lca = RingBuf::new();\n+        let mut lca = VecDeque::new();\n         lca.push_back(Traverse::traverse(&self.root));\n         Iter {\n             inner: AbsIter {\n@@ -1231,7 +1231,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         let len = self.len();\n-        let mut lca = RingBuf::new();\n+        let mut lca = VecDeque::new();\n         lca.push_back(Traverse::traverse(&mut self.root));\n         IterMut {\n             inner: AbsIter {\n@@ -1260,7 +1260,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n-        let mut lca = RingBuf::new();\n+        let mut lca = VecDeque::new();\n         lca.push_back(Traverse::traverse(self.root));\n         IntoIter {\n             inner: AbsIter {\n@@ -1352,7 +1352,7 @@ macro_rules! range_impl {\n             // A deque that encodes two search paths containing (left-to-right):\n             // a series of truncated-from-the-left iterators, the LCA's doubly-truncated iterator,\n             // and a series of truncated-from-the-right iterators.\n-            let mut traversals = RingBuf::new();\n+            let mut traversals = VecDeque::new();\n             let (root, min, max) = ($root, $min, $max);\n \n             let mut leftmost = None;"}, {"sha": "614971866231480fcfdbbbd6a642a90a16a9758e", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -473,7 +473,7 @@ impl<T: Ord> BTreeSet<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n-    fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BTreeSet<T> {\n+    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> BTreeSet<T> {\n         let mut set = BTreeSet::new();\n         set.extend(iter);\n         set\n@@ -503,7 +503,7 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n-    fn extend<Iter: Iterator<Item=T>>(&mut self, iter: Iter) {\n+    fn extend<Iter: IntoIterator<Item=T>>(&mut self, iter: Iter) {\n         for elem in iter {\n             self.insert(elem);\n         }"}, {"sha": "140c9edb5a3a7f5c34c292d0f6659d990597d574", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -250,9 +250,9 @@ impl<E:CLike> Iterator for Iter<E> {\n }\n \n impl<E:CLike> FromIterator<E> for EnumSet<E> {\n-    fn from_iter<I:Iterator<Item=E>>(iterator: I) -> EnumSet<E> {\n+    fn from_iter<I: IntoIterator<Item=E>>(iter: I) -> EnumSet<E> {\n         let mut ret = EnumSet::new();\n-        ret.extend(iterator);\n+        ret.extend(iter);\n         ret\n     }\n }\n@@ -268,8 +268,8 @@ impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n }\n \n impl<E:CLike> Extend<E> for EnumSet<E> {\n-    fn extend<I: Iterator<Item=E>>(&mut self, iterator: I) {\n-        for element in iterator {\n+    fn extend<I: IntoIterator<Item=E>>(&mut self, iter: I) {\n+        for element in iter {\n             self.insert(element);\n         }\n     }"}, {"sha": "335b15c434034b7541f68385e857e5b238a6a202", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -48,17 +48,33 @@ extern crate alloc;\n #[cfg(test)] #[macro_use] extern crate log;\n \n pub use binary_heap::BinaryHeap;\n-pub use bitv::Bitv;\n-pub use bitv_set::BitvSet;\n+pub use bit_vec::BitVec;\n+pub use bit_set::BitSet;\n pub use btree_map::BTreeMap;\n pub use btree_set::BTreeSet;\n-pub use dlist::DList;\n+pub use linked_list::LinkedList;\n pub use enum_set::EnumSet;\n-pub use ring_buf::RingBuf;\n+pub use vec_deque::VecDeque;\n pub use string::String;\n pub use vec::Vec;\n pub use vec_map::VecMap;\n \n+#[deprecated(since = \"1.0.0\", reason = \"renamed to vec_deque\")]\n+#[unstable(feature = \"collections\")]\n+pub use vec_deque as ring_buf;\n+\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to linked_list\")]\n+#[unstable(feature = \"collections\")]\n+pub use linked_list as dlist;\n+\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to bit_vec\")]\n+#[unstable(feature = \"collections\")]\n+pub use bit_vec as bitv;\n+\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to bit_set\")]\n+#[unstable(feature = \"collections\")]\n+pub use bit_set as bitv_set;\n+\n // Needed for the vec! macro\n pub use alloc::boxed;\n \n@@ -70,10 +86,10 @@ mod macros;\n pub mod binary_heap;\n mod bit;\n mod btree;\n-pub mod dlist;\n+pub mod linked_list;\n pub mod enum_set;\n pub mod fmt;\n-pub mod ring_buf;\n+pub mod vec_deque;\n pub mod slice;\n pub mod str;\n pub mod string;\n@@ -82,15 +98,23 @@ pub mod vec_map;\n \n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n-pub mod bitv {\n-    pub use bit::{Bitv, Iter};\n+pub mod bit_vec {\n+    pub use bit::{BitVec, Iter};\n+\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to BitVec\")]\n+    #[unstable(feature = \"collections\")]\n+    pub use bit::BitVec as Bitv;\n }\n \n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n-pub mod bitv_set {\n-    pub use bit::{BitvSet, Union, Intersection, Difference, SymmetricDifference};\n+pub mod bit_set {\n+    pub use bit::{BitSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n+\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to BitSet\")]\n+    #[unstable(feature = \"collections\")]\n+    pub use bit::BitSet as BitvSet;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "1c4b34b4650f7684ef81cbe8e58591bdcf8d767c", "filename": "src/libcollections/linked_list.rs", "status": "renamed", "additions": 121, "deletions": 117, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -10,13 +10,13 @@\n \n //! A doubly-linked list with owned nodes.\n //!\n-//! The `DList` allows pushing and popping elements at either end and is thus\n+//! The `LinkedList` allows pushing and popping elements at either end and is thus\n //! efficiently usable as a double-ended queue.\n \n-// DList is constructed like a singly-linked list over the field `next`.\n+// LinkedList is constructed like a singly-linked list over the field `next`.\n // including the last link being None; each Node owns its `next` field.\n //\n-// Backlinks over DList::prev are raw pointers that form a full chain in\n+// Backlinks over LinkedList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -34,9 +34,13 @@ use core::iter::{self, FromIterator, IntoIterator};\n use core::mem;\n use core::ptr;\n \n+#[deprecated(since = \"1.0.0\", reason = \"renamed to LinkedList\")]\n+#[unstable(feature = \"collections\")]\n+pub use LinkedList as DList;\n+\n /// A doubly-linked list.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct DList<T> {\n+pub struct LinkedList<T> {\n     length: usize,\n     list_head: Link<T>,\n     list_tail: Rawlink<Node<T>>,\n@@ -58,7 +62,7 @@ struct Node<T> {\n     value: T,\n }\n \n-/// An iterator over references to the items of a `DList`.\n+/// An iterator over references to the items of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n@@ -78,20 +82,20 @@ impl<'a, T> Clone for Iter<'a, T> {\n     }\n }\n \n-/// An iterator over mutable references to the items of a `DList`.\n+/// An iterator over mutable references to the items of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n-    list: &'a mut DList<T>,\n+    list: &'a mut LinkedList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n     nelem: usize,\n }\n \n-/// An iterator over mutable references to the items of a `DList`.\n+/// An iterator over mutable references to the items of a `LinkedList`.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    list: DList<T>\n+    list: LinkedList<T>\n }\n \n /// Rawlink is a type like Option<T> but for holding a raw pointer\n@@ -149,7 +153,7 @@ fn link_with_prev<T>(mut next: Box<Node<T>>, prev: Rawlink<Node<T>>)\n }\n \n // private methods\n-impl<T> DList<T> {\n+impl<T> LinkedList<T> {\n     /// Add a Node first in the list\n     #[inline]\n     fn push_front_node(&mut self, mut new_head: Box<Node<T>>) {\n@@ -209,18 +213,18 @@ impl<T> DList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Default for DList<T> {\n+impl<T> Default for LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn default() -> DList<T> { DList::new() }\n+    fn default() -> LinkedList<T> { LinkedList::new() }\n }\n \n-impl<T> DList<T> {\n-    /// Creates an empty `DList`.\n+impl<T> LinkedList<T> {\n+    /// Creates an empty `LinkedList`.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> DList<T> {\n-        DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n+    pub fn new() -> LinkedList<T> {\n+        LinkedList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n \n     /// Moves all elements from `other` to the end of the list.\n@@ -233,10 +237,10 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut a = DList::new();\n-    /// let mut b = DList::new();\n+    /// let mut a = LinkedList::new();\n+    /// let mut b = LinkedList::new();\n     /// a.push_back(1);\n     /// a.push_back(2);\n     /// b.push_back(3);\n@@ -249,7 +253,7 @@ impl<T> DList<T> {\n     /// }\n     /// println!(\"{}\", b.len()); // prints 0\n     /// ```\n-    pub fn append(&mut self, other: &mut DList<T>) {\n+    pub fn append(&mut self, other: &mut LinkedList<T>) {\n         match self.list_tail.resolve() {\n             None => {\n                 self.length = other.length;\n@@ -303,16 +307,16 @@ impl<T> DList<T> {\n         IntoIter{list: self}\n     }\n \n-    /// Returns `true` if the `DList` is empty.\n+    /// Returns `true` if the `LinkedList` is empty.\n     ///\n     /// This operation should compute in O(1) time.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert!(dl.is_empty());\n     ///\n     /// dl.push_front(\"foo\");\n@@ -324,16 +328,16 @@ impl<T> DList<T> {\n         self.list_head.is_none()\n     }\n \n-    /// Returns the length of the `DList`.\n+    /// Returns the length of the `LinkedList`.\n     ///\n     /// This operation should compute in O(1) time.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     ///\n     /// dl.push_front(2);\n     /// assert_eq!(dl.len(), 1);\n@@ -351,16 +355,16 @@ impl<T> DList<T> {\n         self.length\n     }\n \n-    /// Removes all elements from the `DList`.\n+    /// Removes all elements from the `LinkedList`.\n     ///\n     /// This operation should compute in O(n) time.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     ///\n     /// dl.push_front(2);\n     /// dl.push_front(1);\n@@ -375,7 +379,7 @@ impl<T> DList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        *self = DList::new()\n+        *self = LinkedList::new()\n     }\n \n     /// Provides a reference to the front element, or `None` if the list is\n@@ -384,9 +388,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert_eq!(dl.front(), None);\n     ///\n     /// dl.push_front(1);\n@@ -405,9 +409,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert_eq!(dl.front(), None);\n     ///\n     /// dl.push_front(1);\n@@ -432,9 +436,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert_eq!(dl.back(), None);\n     ///\n     /// dl.push_back(1);\n@@ -453,9 +457,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert_eq!(dl.back(), None);\n     ///\n     /// dl.push_back(1);\n@@ -481,9 +485,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     ///\n     /// dl.push_front(2);\n     /// assert_eq!(dl.front().unwrap(), &2);\n@@ -505,9 +509,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = DList::new();\n+    /// let mut d = LinkedList::new();\n     /// assert_eq!(d.pop_front(), None);\n     ///\n     /// d.push_front(1);\n@@ -528,9 +532,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = DList::new();\n+    /// let mut d = LinkedList::new();\n     /// d.push_back(1);\n     /// d.push_back(3);\n     /// assert_eq!(3, *d.back().unwrap());\n@@ -546,9 +550,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = DList::new();\n+    /// let mut d = LinkedList::new();\n     /// assert_eq!(d.pop_back(), None);\n     /// d.push_back(1);\n     /// d.push_back(3);\n@@ -571,9 +575,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = DList::new();\n+    /// let mut d = LinkedList::new();\n     ///\n     /// d.push_front(1);\n     /// d.push_front(2);\n@@ -585,13 +589,13 @@ impl<T> DList<T> {\n     /// assert_eq!(splitted.pop_front(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn split_off(&mut self, at: usize) -> DList<T> {\n+    pub fn split_off(&mut self, at: usize) -> LinkedList<T> {\n         let len = self.len();\n         assert!(at <= len, \"Cannot split off at a nonexistent index\");\n         if at == 0 {\n-            return mem::replace(self, DList::new());\n+            return mem::replace(self, LinkedList::new());\n         } else if at == len {\n-            return DList::new();\n+            return LinkedList::new();\n         }\n \n         // Below, we iterate towards the `i-1`th node, either from the start or the end,\n@@ -614,7 +618,7 @@ impl<T> DList<T> {\n             iter.tail\n         };\n \n-        let mut splitted_list = DList {\n+        let mut splitted_list = LinkedList {\n             list_head: None,\n             list_tail: self.list_tail,\n             length: len - at\n@@ -630,9 +634,9 @@ impl<T> DList<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for DList<T> {\n+impl<T> Drop for LinkedList<T> {\n     fn drop(&mut self) {\n-        // Dissolve the dlist in backwards direction\n+        // Dissolve the linked_list in backwards direction\n         // Just dropping the list_head can lead to stack exhaustion\n         // when length is >> 1_000_000\n         let mut tail = self.list_tail;\n@@ -763,9 +767,9 @@ impl<'a, A> IterMut<'a, A> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut list: DList<_> = vec![1, 3, 4].into_iter().collect();\n+    /// let mut list: LinkedList<_> = vec![1, 3, 4].into_iter().collect();\n     ///\n     /// {\n     ///     let mut it = list.iter_mut();\n@@ -790,9 +794,9 @@ impl<'a, A> IterMut<'a, A> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut list: DList<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let mut list: LinkedList<_> = vec![1, 2, 3].into_iter().collect();\n     ///\n     /// let mut it = list.iter_mut();\n     /// assert_eq!(it.next().unwrap(), &1);\n@@ -831,16 +835,16 @@ impl<A> DoubleEndedIterator for IntoIter<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> FromIterator<A> for DList<A> {\n-    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> DList<A> {\n+impl<A> FromIterator<A> for LinkedList<A> {\n+    fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> LinkedList<A> {\n         let mut ret = DList::new();\n-        ret.extend(iterator);\n+        ret.extend(iter);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IntoIterator for DList<T> {\n+impl<T> IntoIterator for LinkedList<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n@@ -850,7 +854,7 @@ impl<T> IntoIterator for DList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a DList<T> {\n+impl<'a, T> IntoIterator for &'a LinkedList<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -859,7 +863,7 @@ impl<'a, T> IntoIterator for &'a DList<T> {\n     }\n }\n \n-impl<'a, T> IntoIterator for &'a mut DList<T> {\n+impl<'a, T> IntoIterator for &'a mut LinkedList<T> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n@@ -869,54 +873,54 @@ impl<'a, T> IntoIterator for &'a mut DList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Extend<A> for DList<A> {\n-    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T) {\n-        for elt in iterator { self.push_back(elt); }\n+impl<A> Extend<A> for LinkedList<A> {\n+    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T) {\n+        for elt in iter { self.push_back(elt); }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialEq> PartialEq for DList<A> {\n-    fn eq(&self, other: &DList<A>) -> bool {\n+impl<A: PartialEq> PartialEq for LinkedList<A> {\n+    fn eq(&self, other: &LinkedList<A>) -> bool {\n         self.len() == other.len() &&\n             iter::order::eq(self.iter(), other.iter())\n     }\n \n-    fn ne(&self, other: &DList<A>) -> bool {\n+    fn ne(&self, other: &LinkedList<A>) -> bool {\n         self.len() != other.len() ||\n             iter::order::ne(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Eq> Eq for DList<A> {}\n+impl<A: Eq> Eq for LinkedList<A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialOrd> PartialOrd for DList<A> {\n-    fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> {\n+impl<A: PartialOrd> PartialOrd for LinkedList<A> {\n+    fn partial_cmp(&self, other: &LinkedList<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Ord> Ord for DList<A> {\n+impl<A: Ord> Ord for LinkedList<A> {\n     #[inline]\n-    fn cmp(&self, other: &DList<A>) -> Ordering {\n+    fn cmp(&self, other: &LinkedList<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Clone> Clone for DList<A> {\n-    fn clone(&self) -> DList<A> {\n+impl<A: Clone> Clone for LinkedList<A> {\n+    fn clone(&self) -> LinkedList<A> {\n         self.iter().cloned().collect()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: fmt::Debug> fmt::Debug for DList<A> {\n+impl<A: fmt::Debug> fmt::Debug for LinkedList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"DList [\"));\n+        try!(write!(f, \"LinkedList [\"));\n \n         for (i, e) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -929,7 +933,7 @@ impl<A: fmt::Debug> fmt::Debug for DList<A> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg(stage0)]\n-impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n+impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for LinkedList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n         for elt in self {\n@@ -939,7 +943,7 @@ impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg(not(stage0))]\n-impl<A: Hash> Hash for DList<A> {\n+impl<A: Hash> Hash for LinkedList<A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.len().hash(state);\n         for elt in self {\n@@ -957,9 +961,9 @@ mod tests {\n     use test::Bencher;\n     use test;\n \n-    use super::{DList, Node};\n+    use super::{LinkedList, Node};\n \n-    pub fn check_links<T>(list: &DList<T>) {\n+    pub fn check_links<T>(list: &LinkedList<T>) {\n         let mut len = 0;\n         let mut last_ptr: Option<&Node<T>> = None;\n         let mut node_ptr: &Node<T>;\n@@ -993,7 +997,7 @@ mod tests {\n \n     #[test]\n     fn test_basic() {\n-        let mut m = DList::new();\n+        let mut m = LinkedList::new();\n         assert_eq!(m.pop_front(), None);\n         assert_eq!(m.pop_back(), None);\n         assert_eq!(m.pop_front(), None);\n@@ -1012,7 +1016,7 @@ mod tests {\n         m.push_back(box 7);\n         assert_eq!(m.pop_front(), Some(box 1));\n \n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         n.push_front(2);\n         n.push_front(3);\n         {\n@@ -1032,7 +1036,7 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn generate_test() -> DList<i32> {\n+    fn generate_test() -> LinkedList<i32> {\n         list_from(&[0,1,2,3,4,5,6])\n     }\n \n@@ -1045,17 +1049,17 @@ mod tests {\n     fn test_append() {\n         // Empty to empty\n         {\n-            let mut m = DList::<i32>::new();\n-            let mut n = DList::new();\n+            let mut m = LinkedList::<i32>::new();\n+            let mut n = LinkedList::new();\n             m.append(&mut n);\n             check_links(&m);\n             assert_eq!(m.len(), 0);\n             assert_eq!(n.len(), 0);\n         }\n         // Non-empty to empty\n         {\n-            let mut m = DList::new();\n-            let mut n = DList::new();\n+            let mut m = LinkedList::new();\n+            let mut n = LinkedList::new();\n             n.push_back(2);\n             m.append(&mut n);\n             check_links(&m);\n@@ -1066,8 +1070,8 @@ mod tests {\n         }\n         // Empty to non-empty\n         {\n-            let mut m = DList::new();\n-            let mut n = DList::new();\n+            let mut m = LinkedList::new();\n+            let mut n = LinkedList::new();\n             m.push_back(2);\n             m.append(&mut n);\n             check_links(&m);\n@@ -1102,7 +1106,7 @@ mod tests {\n     fn test_split_off() {\n         // singleton\n         {\n-            let mut m = DList::new();\n+            let mut m = LinkedList::new();\n             m.push_back(1);\n \n             let p = m.split_off(0);\n@@ -1143,7 +1147,7 @@ mod tests {\n \n         // no-op on the last index\n         {\n-            let mut m = DList::new();\n+            let mut m = LinkedList::new();\n             m.push_back(1);\n \n             let p = m.split_off(1);\n@@ -1161,7 +1165,7 @@ mod tests {\n         for (i, elt) in m.iter().enumerate() {\n             assert_eq!(i as i32, *elt);\n         }\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert_eq!(n.iter().next(), None);\n         n.push_front(4);\n         let mut it = n.iter();\n@@ -1173,7 +1177,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_clone() {\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         n.push_back(2);\n         n.push_back(3);\n         n.push_back(4);\n@@ -1187,7 +1191,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_double_end() {\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert_eq!(n.iter().next(), None);\n         n.push_front(4);\n         n.push_front(5);\n@@ -1209,7 +1213,7 @@ mod tests {\n         for (i, elt) in m.iter().rev().enumerate() {\n             assert_eq!((6 - i) as i32, *elt);\n         }\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert_eq!(n.iter().rev().next(), None);\n         n.push_front(4);\n         let mut it = n.iter().rev();\n@@ -1228,7 +1232,7 @@ mod tests {\n             len -= 1;\n         }\n         assert_eq!(len, 0);\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert!(n.iter_mut().next().is_none());\n         n.push_front(4);\n         n.push_back(5);\n@@ -1242,7 +1246,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_mut_double_end() {\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert!(n.iter_mut().next_back().is_none());\n         n.push_front(4);\n         n.push_front(5);\n@@ -1291,7 +1295,7 @@ mod tests {\n         for (i, elt) in m.iter_mut().rev().enumerate() {\n             assert_eq!((6 - i) as i32, *elt);\n         }\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert!(n.iter_mut().rev().next().is_none());\n         n.push_front(4);\n         let mut it = n.iter_mut().rev();\n@@ -1326,8 +1330,8 @@ mod tests {\n \n     #[test]\n     fn test_hash() {\n-      let mut x = DList::new();\n-      let mut y = DList::new();\n+      let mut x = LinkedList::new();\n+      let mut y = LinkedList::new();\n \n       assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n \n@@ -1395,16 +1399,16 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let list: DList<_> = (0..10).collect();\n-        assert_eq!(format!(\"{:?}\", list), \"DList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        let list: LinkedList<_> = (0..10).collect();\n+        assert_eq!(format!(\"{:?}\", list), \"LinkedList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-        let list: DList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n-        assert_eq!(format!(\"{:?}\", list), \"DList [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+        let list: LinkedList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n+        assert_eq!(format!(\"{:?}\", list), \"LinkedList [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[cfg(test)]\n     fn fuzz_test(sz: i32) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         let mut v = vec![];\n         for i in 0..sz {\n             check_links(&m);\n@@ -1445,29 +1449,29 @@ mod tests {\n     fn bench_collect_into(b: &mut test::Bencher) {\n         let v = &[0; 64];\n         b.iter(|| {\n-            let _: DList<_> = v.iter().cloned().collect();\n+            let _: LinkedList<_> = v.iter().cloned().collect();\n         })\n     }\n \n     #[bench]\n     fn bench_push_front(b: &mut test::Bencher) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         b.iter(|| {\n             m.push_front(0);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back(b: &mut test::Bencher) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         b.iter(|| {\n             m.push_back(0);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::Bencher) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         b.iter(|| {\n             m.push_back(0);\n             m.pop_back();\n@@ -1476,7 +1480,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front_pop_front(b: &mut test::Bencher) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         b.iter(|| {\n             m.push_front(0);\n             m.pop_front();\n@@ -1486,31 +1490,31 @@ mod tests {\n     #[bench]\n     fn bench_iter(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let m: DList<_> = v.iter().cloned().collect();\n+        let m: LinkedList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let mut m: DList<_> = v.iter().cloned().collect();\n+        let mut m: LinkedList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter_mut().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let m: DList<_> = v.iter().cloned().collect();\n+        let m: LinkedList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter().rev().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let mut m: DList<_> = v.iter().cloned().collect();\n+        let mut m: LinkedList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter_mut().rev().count() == 128);\n         })", "previous_filename": "src/libcollections/dlist.rs"}, {"sha": "94d81c74cd36ac409dd8bb3e3727f95c21ded225", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -68,7 +68,7 @@ use core::slice::AsSlice;\n use core::str as core_str;\n use unicode::str::{UnicodeStr, Utf16Encoder};\n \n-use ring_buf::RingBuf;\n+use vec_deque::VecDeque;\n use slice::SliceExt;\n use string::String;\n use unicode;\n@@ -261,7 +261,7 @@ enum RecompositionState {\n pub struct Recompositions<'a> {\n     iter: Decompositions<'a>,\n     state: RecompositionState,\n-    buffer: RingBuf<char>,\n+    buffer: VecDeque<char>,\n     composee: Option<char>,\n     last_ccc: Option<u8>\n }\n@@ -496,7 +496,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         Recompositions {\n             iter: self.nfd_chars(),\n             state: Composing,\n-            buffer: RingBuf::new(),\n+            buffer: VecDeque::new(),\n             composee: None,\n             last_ccc: None\n         }\n@@ -511,7 +511,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         Recompositions {\n             iter: self.nfkd_chars(),\n             state: Composing,\n-            buffer: RingBuf::new(),\n+            buffer: VecDeque::new(),\n             composee: None,\n             last_ccc: None\n         }"}, {"sha": "db889725abdae7f246eb27cfa0e40029ec9f41b9", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -21,7 +21,7 @@ use core::default::Default;\n use core::error::Error;\n use core::fmt;\n use core::hash;\n-use core::iter::FromIterator;\n+use core::iter::{IntoIterator, FromIterator};\n use core::mem;\n use core::ops::{self, Deref, Add, Index};\n use core::ptr;\n@@ -709,26 +709,27 @@ impl Error for FromUtf16Error {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<char> for String {\n-    fn from_iter<I:Iterator<Item=char>>(iterator: I) -> String {\n+    fn from_iter<I: IntoIterator<Item=char>>(iter: I) -> String {\n         let mut buf = String::new();\n-        buf.extend(iterator);\n+        buf.extend(iter);\n         buf\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> FromIterator<&'a str> for String {\n-    fn from_iter<I:Iterator<Item=&'a str>>(iterator: I) -> String {\n+    fn from_iter<I: IntoIterator<Item=&'a str>>(iter: I) -> String {\n         let mut buf = String::new();\n-        buf.extend(iterator);\n+        buf.extend(iter);\n         buf\n     }\n }\n \n #[unstable(feature = \"collections\",\n            reason = \"waiting on Extend stabilization\")]\n impl Extend<char> for String {\n-    fn extend<I:Iterator<Item=char>>(&mut self, iterator: I) {\n+    fn extend<I: IntoIterator<Item=char>>(&mut self, iterable: I) {\n+        let iterator = iterable.into_iter();\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n         for ch in iterator {\n@@ -740,7 +741,8 @@ impl Extend<char> for String {\n #[unstable(feature = \"collections\",\n            reason = \"waiting on Extend stabilization\")]\n impl<'a> Extend<&'a str> for String {\n-    fn extend<I: Iterator<Item=&'a str>>(&mut self, iterator: I) {\n+    fn extend<I: IntoIterator<Item=&'a str>>(&mut self, iterable: I) {\n+        let iterator = iterable.into_iter();\n         // A guess that at least one byte per iterator element will be needed.\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);"}, {"sha": "c77a6b9e8e50203cdccb0bc1906039690f05e230", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -1417,7 +1417,8 @@ impl<T> ops::DerefMut for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n-    fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> {\n+    fn from_iter<I: IntoIterator<Item=T>>(iterable: I) -> Vec<T> {\n+        let mut iterator = iterable.into_iter();\n         let (lower, _) = iterator.size_hint();\n         let mut vector = Vec::with_capacity(lower);\n \n@@ -1490,7 +1491,8 @@ impl<'a, T> IntoIterator for &'a mut Vec<T> {\n #[unstable(feature = \"collections\", reason = \"waiting on Extend stability\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n-    fn extend<I: Iterator<Item=T>>(&mut self, iterator: I) {\n+    fn extend<I: IntoIterator<Item=T>>(&mut self, iterable: I) {\n+        let iterator = iterable.into_iter();\n         let (lower, _) = iterator.size_hint();\n         self.reserve(lower);\n         for element in iterator {\n@@ -1664,7 +1666,7 @@ pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n \n #[unstable(feature = \"collections\")]\n impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n-    fn from_iter<I: Iterator<Item=T>>(it: I) -> CowVec<'a, T> {\n+    fn from_iter<I: IntoIterator<Item=T>>(it: I) -> CowVec<'a, T> {\n         Cow::Owned(FromIterator::from_iter(it))\n     }\n }"}, {"sha": "712695841a2632f93d580fc42e5f647b9a76bb81", "filename": "src/libcollections/vec_deque.rs", "status": "renamed", "additions": 190, "deletions": 184, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! RingBuf is a double-ended queue, which is implemented with the help of a\n-//! growing circular buffer.\n+//! VecDeque is a double-ended queue, which is implemented with the help of a\n+//! growing ring buffer.\n //!\n //! This queue has `O(1)` amortized inserts and removals from both ends of the\n //! container. It also has `O(1)` indexing like a vector. The contained elements\n@@ -37,12 +37,17 @@ use core::cmp;\n \n use alloc::heap;\n \n+#[deprecated(since = \"1.0.0\", reason = \"renamed to VecDeque\")]\n+#[unstable(feature = \"collections\")]\n+pub use VecDeque as RingBuf;\n+\n static INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n static MINIMUM_CAPACITY: usize = 1; // 2 - 1\n \n-/// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n+/// `VecDeque` is a growable ring buffer, which can be used as a\n+/// double-ended queue efficiently.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RingBuf<T> {\n+pub struct VecDeque<T> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points\n     // to where data should be written.\n@@ -56,21 +61,21 @@ pub struct RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for RingBuf<T> {}\n+unsafe impl<T: Send> Send for VecDeque<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for RingBuf<T> {}\n+unsafe impl<T: Sync> Sync for VecDeque<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone> Clone for RingBuf<T> {\n-    fn clone(&self) -> RingBuf<T> {\n+impl<T: Clone> Clone for VecDeque<T> {\n+    fn clone(&self) -> VecDeque<T> {\n         self.iter().cloned().collect()\n     }\n }\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for RingBuf<T> {\n+impl<T> Drop for VecDeque<T> {\n     fn drop(&mut self) {\n         self.clear();\n         unsafe {\n@@ -84,12 +89,12 @@ impl<T> Drop for RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Default for RingBuf<T> {\n+impl<T> Default for VecDeque<T> {\n     #[inline]\n-    fn default() -> RingBuf<T> { RingBuf::new() }\n+    fn default() -> VecDeque<T> { VecDeque::new() }\n }\n \n-impl<T> RingBuf<T> {\n+impl<T> VecDeque<T> {\n     /// Turn ptr into a slice\n     #[inline]\n     unsafe fn buffer_as_slice(&self) -> &[T] {\n@@ -150,16 +155,16 @@ impl<T> RingBuf<T> {\n     }\n }\n \n-impl<T> RingBuf<T> {\n-    /// Creates an empty `RingBuf`.\n+impl<T> VecDeque<T> {\n+    /// Creates an empty `VecDeque`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> RingBuf<T> {\n-        RingBuf::with_capacity(INITIAL_CAPACITY)\n+    pub fn new() -> VecDeque<T> {\n+        VecDeque::with_capacity(INITIAL_CAPACITY)\n     }\n \n-    /// Creates an empty `RingBuf` with space for at least `n` elements.\n+    /// Creates an empty `VecDeque` with space for at least `n` elements.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(n: usize) -> RingBuf<T> {\n+    pub fn with_capacity(n: usize) -> VecDeque<T> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n         assert!(cap > n, \"capacity overflow\");\n@@ -176,22 +181,22 @@ impl<T> RingBuf<T> {\n             heap::EMPTY as *mut T\n         };\n \n-        RingBuf {\n+        VecDeque {\n             tail: 0,\n             head: 0,\n             cap: cap,\n             ptr: ptr\n         }\n     }\n \n-    /// Retrieves an element in the `RingBuf` by index.\n+    /// Retrieves an element in the `VecDeque` by index.\n     ///\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n@@ -207,14 +212,14 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Retrieves an element in the `RingBuf` mutably by index.\n+    /// Retrieves an element in the `VecDeque` mutably by index.\n     ///\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n@@ -246,9 +251,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n@@ -267,23 +272,23 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Returns the number of elements the `RingBuf` can hold without\n+    /// Returns the number of elements the `VecDeque` can hold without\n     /// reallocating.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let buf: RingBuf<i32> = RingBuf::with_capacity(10);\n+    /// let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n     /// assert!(buf.capacity() >= 10);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize { self.cap - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `RingBuf`. Does nothing if the capacity is already sufficient.\n+    /// given `VecDeque`. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n     /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n@@ -296,9 +301,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: RingBuf<i32> = vec![1].into_iter().collect();\n+    /// let mut buf: VecDeque<i32> = vec![1].into_iter().collect();\n     /// buf.reserve_exact(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n@@ -317,9 +322,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: RingBuf<i32> = vec![1].into_iter().collect();\n+    /// let mut buf: VecDeque<i32> = vec![1].into_iter().collect();\n     /// buf.reserve(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n@@ -391,9 +396,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::with_capacity(15);\n+    /// let mut buf = VecDeque::with_capacity(15);\n     /// buf.extend(0..4);\n     /// assert_eq!(buf.capacity(), 15);\n     /// buf.shrink_to_fit();\n@@ -476,9 +481,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(15);\n@@ -499,9 +504,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n@@ -522,9 +527,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n@@ -554,7 +559,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n-    /// `RingBuf`.\n+    /// `VecDeque`.\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n@@ -574,7 +579,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n-    /// `RingBuf`.\n+    /// `VecDeque`.\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n@@ -597,14 +602,14 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Returns the number of elements in the `RingBuf`.\n+    /// Returns the number of elements in the `VecDeque`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = RingBuf::new();\n+    /// let mut v = VecDeque::new();\n     /// assert_eq!(v.len(), 0);\n     /// v.push_back(1);\n     /// assert_eq!(v.len(), 1);\n@@ -617,25 +622,25 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = RingBuf::new();\n+    /// let mut v = VecDeque::new();\n     /// assert!(v.is_empty());\n     /// v.push_front(1);\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n-    /// Creates a draining iterator that clears the `RingBuf` and iterates over\n+    /// Creates a draining iterator that clears the `VecDeque` and iterates over\n     /// the removed items from start to end.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = RingBuf::new();\n+    /// let mut v = VecDeque::new();\n     /// v.push_back(1);\n     /// assert_eq!(v.drain().next(), Some(1));\n     /// assert!(v.is_empty());\n@@ -654,9 +659,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = RingBuf::new();\n+    /// let mut v = VecDeque::new();\n     /// v.push_back(1);\n     /// v.clear();\n     /// assert!(v.is_empty());\n@@ -673,9 +678,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// assert_eq!(d.front(), None);\n     ///\n     /// d.push_back(1);\n@@ -693,9 +698,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// assert_eq!(d.front_mut(), None);\n     ///\n     /// d.push_back(1);\n@@ -717,9 +722,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// assert_eq!(d.back(), None);\n     ///\n     /// d.push_back(1);\n@@ -737,9 +742,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// assert_eq!(d.back(), None);\n     ///\n     /// d.push_back(1);\n@@ -762,9 +767,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// d.push_back(1);\n     /// d.push_back(2);\n     ///\n@@ -788,9 +793,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// d.push_front(1);\n     /// d.push_front(2);\n     /// assert_eq!(d.front(), Some(&2));\n@@ -812,9 +817,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(1);\n     /// buf.push_back(3);\n     /// assert_eq!(3, *buf.back().unwrap());\n@@ -837,9 +842,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// assert_eq!(buf.pop_back(), None);\n     /// buf.push_back(1);\n     /// buf.push_back(3);\n@@ -871,9 +876,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// assert_eq!(buf.swap_back_remove(0), None);\n     /// buf.push_back(5);\n     /// buf.push_back(99);\n@@ -904,9 +909,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// assert_eq!(buf.swap_front_remove(0), None);\n     /// buf.push_back(15);\n     /// buf.push_back(5);\n@@ -937,9 +942,9 @@ impl<T> RingBuf<T> {\n     ///\n     /// # Examples\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(10);\n     /// buf.push_back(12);\n     /// buf.insert(1,11);\n@@ -1139,9 +1144,9 @@ impl<T> RingBuf<T> {\n     ///\n     /// # Examples\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(12);\n@@ -1310,9 +1315,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: RingBuf<_> = vec![1,2,3].into_iter().collect();\n+    /// let mut buf: VecDeque<_> = vec![1,2,3].into_iter().collect();\n     /// let buf2 = buf.split_off(1);\n     /// // buf = [1], buf2 = [2, 3]\n     /// assert_eq!(buf.len(), 1);\n@@ -1326,7 +1331,7 @@ impl<T> RingBuf<T> {\n         assert!(at <= len, \"`at` out of bounds\");\n \n         let other_len = len - at;\n-        let mut other = RingBuf::with_capacity(other_len);\n+        let mut other = VecDeque::with_capacity(other_len);\n \n         unsafe {\n             let (first_half, second_half) = self.as_slices();\n@@ -1372,10 +1377,10 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: RingBuf<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let mut buf2: RingBuf<_> = vec![4, 5, 6].into_iter().collect();\n+    /// let mut buf: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let mut buf2: VecDeque<_> = vec![4, 5, 6].into_iter().collect();\n     /// buf.append(&mut buf2);\n     /// assert_eq!(buf.len(), 6);\n     /// assert_eq!(buf2.len(), 0);\n@@ -1389,16 +1394,16 @@ impl<T> RingBuf<T> {\n     }\n }\n \n-impl<T: Clone> RingBuf<T> {\n+impl<T: Clone> VecDeque<T> {\n     /// Modifies the ringbuf in-place so that `len()` is equal to new_len,\n     /// either by removing excess elements or by appending copies of a value to the back.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(15);\n@@ -1435,7 +1440,7 @@ fn count(tail: usize, head: usize, size: usize) -> usize {\n     (head - tail) & (size - 1)\n }\n \n-/// `RingBuf` iterator.\n+/// `VecDeque` iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n@@ -1512,7 +1517,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n // FIXME This was implemented differently from Iter because of a problem\n //       with returning the mutable reference. I couldn't find a way to\n //       make the lifetime checker happy so, but there should be a way.\n-/// `RingBuf` mutable iterator.\n+/// `VecDeque` mutable iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n@@ -1564,10 +1569,10 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n-/// A by-value RingBuf iterator\n+/// A by-value VecDeque iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    inner: RingBuf<T>,\n+    inner: VecDeque<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1597,11 +1602,11 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n-/// A draining RingBuf iterator\n+/// A draining VecDeque iterator\n #[unstable(feature = \"collections\",\n            reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, T: 'a> {\n-    inner: &'a mut RingBuf<T>,\n+    inner: &'a mut VecDeque<T>,\n }\n \n #[unsafe_destructor]\n@@ -1642,34 +1647,34 @@ impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialEq> PartialEq for RingBuf<A> {\n-    fn eq(&self, other: &RingBuf<A>) -> bool {\n+impl<A: PartialEq> PartialEq for VecDeque<A> {\n+    fn eq(&self, other: &VecDeque<A>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Eq> Eq for RingBuf<A> {}\n+impl<A: Eq> Eq for VecDeque<A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialOrd> PartialOrd for RingBuf<A> {\n-    fn partial_cmp(&self, other: &RingBuf<A>) -> Option<Ordering> {\n+impl<A: PartialOrd> PartialOrd for VecDeque<A> {\n+    fn partial_cmp(&self, other: &VecDeque<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Ord> Ord for RingBuf<A> {\n+impl<A: Ord> Ord for VecDeque<A> {\n     #[inline]\n-    fn cmp(&self, other: &RingBuf<A>) -> Ordering {\n+    fn cmp(&self, other: &VecDeque<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg(stage0)]\n-impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n+impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for VecDeque<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n         for elt in self {\n@@ -1679,7 +1684,7 @@ impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg(not(stage0))]\n-impl<A: Hash> Hash for RingBuf<A> {\n+impl<A: Hash> Hash for VecDeque<A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.len().hash(state);\n         for elt in self {\n@@ -1689,7 +1694,7 @@ impl<A: Hash> Hash for RingBuf<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Index<usize> for RingBuf<A> {\n+impl<A> Index<usize> for VecDeque<A> {\n     type Output = A;\n \n     #[inline]\n@@ -1699,25 +1704,26 @@ impl<A> Index<usize> for RingBuf<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> IndexMut<usize> for RingBuf<A> {\n+impl<A> IndexMut<usize> for VecDeque<A> {\n     #[inline]\n     fn index_mut(&mut self, i: &usize) -> &mut A {\n         self.get_mut(*i).expect(\"Out of bounds access\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> FromIterator<A> for RingBuf<A> {\n-    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> RingBuf<A> {\n+impl<A> FromIterator<A> for VecDeque<A> {\n+    fn from_iter<T: IntoIterator<Item=A>>(iterable: T) -> VecDeque<A> {\n+        let iterator = iterable.into_iter();\n         let (lower, _) = iterator.size_hint();\n-        let mut deq = RingBuf::with_capacity(lower);\n+        let mut deq = VecDeque::with_capacity(lower);\n         deq.extend(iterator);\n         deq\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IntoIterator for RingBuf<T> {\n+impl<T> IntoIterator for VecDeque<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n@@ -1727,7 +1733,7 @@ impl<T> IntoIterator for RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a RingBuf<T> {\n+impl<'a, T> IntoIterator for &'a VecDeque<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -1737,7 +1743,7 @@ impl<'a, T> IntoIterator for &'a RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n+impl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n@@ -1747,18 +1753,18 @@ impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Extend<A> for RingBuf<A> {\n-    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T) {\n-        for elt in iterator {\n+impl<A> Extend<A> for VecDeque<A> {\n+    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T) {\n+        for elt in iter {\n             self.push_back(elt);\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for RingBuf<T> {\n+impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"RingBuf [\"));\n+        try!(write!(f, \"VecDeque [\"));\n \n         for (i, e) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -1780,12 +1786,12 @@ mod tests {\n     use test::Bencher;\n     use test;\n \n-    use super::RingBuf;\n+    use super::VecDeque;\n \n     #[test]\n     #[allow(deprecated)]\n     fn test_simple() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert_eq!(d.len(), 0);\n         d.push_front(17);\n         d.push_front(42);\n@@ -1824,7 +1830,7 @@ mod tests {\n \n     #[cfg(test)]\n     fn test_parameterized<T:Clone + PartialEq + Debug>(a: T, b: T, c: T, d: T) {\n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         assert_eq!(deq.len(), 0);\n         deq.push_front(a.clone());\n         deq.push_front(b.clone());\n@@ -1855,7 +1861,7 @@ mod tests {\n \n     #[test]\n     fn test_push_front_grow() {\n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         for i in 0..66 {\n             deq.push_front(i);\n         }\n@@ -1865,7 +1871,7 @@ mod tests {\n             assert_eq!(deq[i], 65 - i);\n         }\n \n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         for i in 0..66 {\n             deq.push_back(i);\n         }\n@@ -1877,7 +1883,7 @@ mod tests {\n \n     #[test]\n     fn test_index() {\n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         for i in 1..4 {\n             deq.push_front(i);\n         }\n@@ -1887,7 +1893,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_index_out_of_bounds() {\n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         for i in 1..4 {\n             deq.push_front(i);\n         }\n@@ -1897,14 +1903,14 @@ mod tests {\n     #[bench]\n     fn bench_new(b: &mut test::Bencher) {\n         b.iter(|| {\n-            let ring: RingBuf<i32> = RingBuf::new();\n+            let ring: VecDeque<i32> = VecDeque::new();\n             test::black_box(ring);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back_100(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::with_capacity(101);\n+        let mut deq = VecDeque::with_capacity(101);\n         b.iter(|| {\n             for i in 0..100 {\n                 deq.push_back(i);\n@@ -1916,7 +1922,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front_100(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::with_capacity(101);\n+        let mut deq = VecDeque::with_capacity(101);\n         b.iter(|| {\n             for i in 0..100 {\n                 deq.push_front(i);\n@@ -1928,7 +1934,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq= RingBuf::<i32>::with_capacity(101);\n+        let mut deq= VecDeque::<i32>::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -1941,7 +1947,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_front_100(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::<i32>::with_capacity(101);\n+        let mut deq = VecDeque::<i32>::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -1955,7 +1961,7 @@ mod tests {\n     #[bench]\n     fn bench_grow_1025(b: &mut test::Bencher) {\n         b.iter(|| {\n-            let mut deq = RingBuf::new();\n+            let mut deq = VecDeque::new();\n             for i in 0..1025 {\n                 deq.push_front(i);\n             }\n@@ -1965,7 +1971,7 @@ mod tests {\n \n     #[bench]\n     fn bench_iter_1000(b: &mut test::Bencher) {\n-        let ring: RingBuf<_> = (0..1000).collect();\n+        let ring: VecDeque<_> = (0..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1978,7 +1984,7 @@ mod tests {\n \n     #[bench]\n     fn bench_mut_iter_1000(b: &mut test::Bencher) {\n-        let mut ring: RingBuf<_> = (0..1000).collect();\n+        let mut ring: VecDeque<_> = (0..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -2039,17 +2045,17 @@ mod tests {\n \n     #[test]\n     fn test_with_capacity() {\n-        let mut d = RingBuf::with_capacity(0);\n+        let mut d = VecDeque::with_capacity(0);\n         d.push_back(1);\n         assert_eq!(d.len(), 1);\n-        let mut d = RingBuf::with_capacity(50);\n+        let mut d = VecDeque::with_capacity(50);\n         d.push_back(1);\n         assert_eq!(d.len(), 1);\n     }\n \n     #[test]\n     fn test_with_capacity_non_power_two() {\n-        let mut d3 = RingBuf::with_capacity(3);\n+        let mut d3 = VecDeque::with_capacity(3);\n         d3.push_back(1);\n \n         // X = None, | = lo\n@@ -2074,7 +2080,7 @@ mod tests {\n \n         d3.push_back(15);\n         // There used to be a bug here about how the\n-        // RingBuf made growth assumptions about the\n+        // VecDeque made growth assumptions about the\n         // underlying Vec which didn't hold and lead\n         // to corruption.\n         // (Vec grows to next power of two)\n@@ -2090,31 +2096,31 @@ mod tests {\n \n     #[test]\n     fn test_reserve_exact() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         d.push_back(0);\n         d.reserve_exact(50);\n         assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n     fn test_reserve() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         d.push_back(0);\n         d.reserve(50);\n         assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n     fn test_swap() {\n-        let mut d: RingBuf<_> = (0..5).collect();\n+        let mut d: VecDeque<_> = (0..5).collect();\n         d.pop_front();\n         d.swap(0, 3);\n         assert_eq!(d.iter().cloned().collect::<Vec<_>>(), vec!(4, 2, 3, 1));\n     }\n \n     #[test]\n     fn test_iter() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert_eq!(d.iter().next(), None);\n         assert_eq!(d.iter().size_hint(), (0, Some(0)));\n \n@@ -2146,7 +2152,7 @@ mod tests {\n \n     #[test]\n     fn test_rev_iter() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert_eq!(d.iter().rev().next(), None);\n \n         for i in 0..5 {\n@@ -2166,7 +2172,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_rev_iter_wrap() {\n-        let mut d = RingBuf::with_capacity(3);\n+        let mut d = VecDeque::with_capacity(3);\n         assert!(d.iter_mut().rev().next().is_none());\n \n         d.push_back(1);\n@@ -2181,7 +2187,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_iter() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert!(d.iter_mut().next().is_none());\n \n         for i in 0..3 {\n@@ -2204,7 +2210,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_rev_iter() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert!(d.iter_mut().rev().next().is_none());\n \n         for i in 0..3 {\n@@ -2230,7 +2236,7 @@ mod tests {\n \n         // Empty iter\n         {\n-            let d: RingBuf<i32> = RingBuf::new();\n+            let d: VecDeque<i32> = VecDeque::new();\n             let mut iter = d.into_iter();\n \n             assert_eq!(iter.size_hint(), (0, Some(0)));\n@@ -2240,7 +2246,7 @@ mod tests {\n \n         // simple iter\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2251,7 +2257,7 @@ mod tests {\n \n         // wrapped iter\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2265,7 +2271,7 @@ mod tests {\n \n         // partially used\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2289,7 +2295,7 @@ mod tests {\n \n         // Empty iter\n         {\n-            let mut d: RingBuf<i32> = RingBuf::new();\n+            let mut d: VecDeque<i32> = VecDeque::new();\n \n             {\n                 let mut iter = d.drain();\n@@ -2304,7 +2310,7 @@ mod tests {\n \n         // simple iter\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2315,7 +2321,7 @@ mod tests {\n \n         // wrapped iter\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2329,7 +2335,7 @@ mod tests {\n \n         // partially used\n         {\n-            let mut d: RingBuf<_> = RingBuf::new();\n+            let mut d: VecDeque<_> = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2355,12 +2361,12 @@ mod tests {\n     fn test_from_iter() {\n         use core::iter;\n         let v = vec!(1,2,3,4,5,6,7);\n-        let deq: RingBuf<_> = v.iter().cloned().collect();\n+        let deq: VecDeque<_> = v.iter().cloned().collect();\n         let u: Vec<_> = deq.iter().cloned().collect();\n         assert_eq!(u, v);\n \n         let seq = iter::count(0, 2).take(256);\n-        let deq: RingBuf<_> = seq.collect();\n+        let deq: VecDeque<_> = seq.collect();\n         for (i, &x) in deq.iter().enumerate() {\n             assert_eq!(2*i, x);\n         }\n@@ -2369,7 +2375,7 @@ mod tests {\n \n     #[test]\n     fn test_clone() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         d.push_front(17);\n         d.push_front(42);\n         d.push_back(137);\n@@ -2386,13 +2392,13 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        let mut d = RingBuf::new();\n-        assert!(d == RingBuf::with_capacity(0));\n+        let mut d = VecDeque::new();\n+        assert!(d == VecDeque::with_capacity(0));\n         d.push_front(137);\n         d.push_front(17);\n         d.push_front(42);\n         d.push_back(137);\n-        let mut e = RingBuf::with_capacity(0);\n+        let mut e = VecDeque::with_capacity(0);\n         e.push_back(42);\n         e.push_back(17);\n         e.push_back(137);\n@@ -2402,13 +2408,13 @@ mod tests {\n         e.push_back(0);\n         assert!(e != d);\n         e.clear();\n-        assert!(e == RingBuf::new());\n+        assert!(e == VecDeque::new());\n     }\n \n     #[test]\n     fn test_hash() {\n-      let mut x = RingBuf::new();\n-      let mut y = RingBuf::new();\n+      let mut x = VecDeque::new();\n+      let mut y = VecDeque::new();\n \n       x.push_back(1);\n       x.push_back(2);\n@@ -2425,8 +2431,8 @@ mod tests {\n \n     #[test]\n     fn test_ord() {\n-        let x = RingBuf::new();\n-        let mut y = RingBuf::new();\n+        let x = VecDeque::new();\n+        let mut y = VecDeque::new();\n         y.push_back(1);\n         y.push_back(2);\n         y.push_back(3);\n@@ -2438,13 +2444,13 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let ringbuf: RingBuf<_> = (0..10).collect();\n-        assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        let ringbuf: VecDeque<_> = (0..10).collect();\n+        assert_eq!(format!(\"{:?}\", ringbuf), \"VecDeque [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-        let ringbuf: RingBuf<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n+        let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                         .cloned()\n                                                                         .collect();\n-        assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+        assert_eq!(format!(\"{:?}\", ringbuf), \"VecDeque [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[test]\n@@ -2457,7 +2463,7 @@ mod tests {\n             }\n         }\n \n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(Elem);\n         ring.push_front(Elem);\n         ring.push_back(Elem);\n@@ -2477,7 +2483,7 @@ mod tests {\n             }\n         }\n \n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(Elem);\n         ring.push_front(Elem);\n         ring.push_back(Elem);\n@@ -2501,7 +2507,7 @@ mod tests {\n             }\n         }\n \n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(Elem);\n         ring.push_front(Elem);\n         ring.push_back(Elem);\n@@ -2517,7 +2523,7 @@ mod tests {\n     fn test_reserve_grow() {\n         // test growth path A\n         // [T o o H] -> [T o o H . . . . ]\n-        let mut ring = RingBuf::with_capacity(4);\n+        let mut ring = VecDeque::with_capacity(4);\n         for i in 0..3 {\n             ring.push_back(i);\n         }\n@@ -2528,7 +2534,7 @@ mod tests {\n \n         // test growth path B\n         // [H T o o] -> [. T o o H . . . ]\n-        let mut ring = RingBuf::with_capacity(4);\n+        let mut ring = VecDeque::with_capacity(4);\n         for i in 0..1 {\n             ring.push_back(i);\n             assert_eq!(ring.pop_front(), Some(i));\n@@ -2543,7 +2549,7 @@ mod tests {\n \n         // test growth path C\n         // [o o H T] -> [o o H . . . . T ]\n-        let mut ring = RingBuf::with_capacity(4);\n+        let mut ring = VecDeque::with_capacity(4);\n         for i in 0..3 {\n             ring.push_back(i);\n             assert_eq!(ring.pop_front(), Some(i));\n@@ -2559,7 +2565,7 @@ mod tests {\n \n     #[test]\n     fn test_get() {\n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(0);\n         assert_eq!(ring.get(0), Some(&0));\n         assert_eq!(ring.get(1), None);\n@@ -2591,7 +2597,7 @@ mod tests {\n \n     #[test]\n     fn test_get_mut() {\n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         for i in 0..3 {\n             ring.push_back(i);\n         }\n@@ -2617,7 +2623,7 @@ mod tests {\n         fn test(back: bool) {\n             // This test checks that every single combination of tail position and length is tested.\n             // Capacity 15 should be large enough to cover every case.\n-            let mut tester = RingBuf::with_capacity(15);\n+            let mut tester = VecDeque::with_capacity(15);\n             let usable_cap = tester.capacity();\n             let final_len = usable_cap / 2;\n \n@@ -2661,7 +2667,7 @@ mod tests {\n         // This test checks that every single combination of tail position, length, and\n         // insertion position is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(15);\n+        let mut tester = VecDeque::with_capacity(15);\n         // can't guarantee we got 15, so have to get what we got.\n         // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n@@ -2695,7 +2701,7 @@ mod tests {\n         // This test checks that every single combination of tail position, length, and\n         // removal position is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(15);\n+        let mut tester = VecDeque::with_capacity(15);\n         // can't guarantee we got 15, so have to get what we got.\n         // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n@@ -2732,7 +2738,7 @@ mod tests {\n         // This test checks that every single combination of head and tail position,\n         // is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(15);\n+        let mut tester = VecDeque::with_capacity(15);\n         // can't guarantee we got 15, so have to get what we got.\n         // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n@@ -2761,7 +2767,7 @@ mod tests {\n \n     #[test]\n     fn test_front() {\n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(10);\n         ring.push_back(20);\n         assert_eq!(ring.front(), Some(&10));\n@@ -2773,7 +2779,7 @@ mod tests {\n \n     #[test]\n     fn test_as_slices() {\n-        let mut ring: RingBuf<i32> = RingBuf::with_capacity(127);\n+        let mut ring: VecDeque<i32> = VecDeque::with_capacity(127);\n         let cap = ring.capacity() as i32;\n         let first = cap/2;\n         let last  = cap - first;\n@@ -2801,7 +2807,7 @@ mod tests {\n \n     #[test]\n     fn test_as_mut_slices() {\n-        let mut ring: RingBuf<i32> = RingBuf::with_capacity(127);\n+        let mut ring: VecDeque<i32> = VecDeque::with_capacity(127);\n         let cap = ring.capacity() as i32;\n         let first = cap/2;\n         let last  = cap - first;\n@@ -2832,7 +2838,7 @@ mod tests {\n         // This test checks that every single combination of tail position, length, and\n         // split position is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(15);\n+        let mut tester = VecDeque::with_capacity(15);\n         // can't guarantee we got 15, so have to get what we got.\n         // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n@@ -2867,8 +2873,8 @@ mod tests {\n \n     #[test]\n     fn test_append() {\n-        let mut a: RingBuf<_> = vec![1, 2, 3].into_iter().collect();\n-        let mut b: RingBuf<_> = vec![4, 5, 6].into_iter().collect();\n+        let mut a: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n+        let mut b: VecDeque<_> = vec![4, 5, 6].into_iter().collect();\n \n         // normal append\n         a.append(&mut b);", "previous_filename": "src/libcollections/ring_buf.rs"}, {"sha": "9f0489a4f960a2bcc72cd7b95d47efa0eb1cfad1", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -678,7 +678,7 @@ impl<V: fmt::Debug> fmt::Debug for VecMap<V> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> FromIterator<(usize, V)> for VecMap<V> {\n-    fn from_iter<Iter: Iterator<Item=(usize, V)>>(iter: Iter) -> VecMap<V> {\n+    fn from_iter<I: IntoIterator<Item=(usize, V)>>(iter: I) -> VecMap<V> {\n         let mut map = VecMap::new();\n         map.extend(iter);\n         map\n@@ -717,7 +717,7 @@ impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Extend<(usize, V)> for VecMap<V> {\n-    fn extend<Iter: Iterator<Item=(usize, V)>>(&mut self, iter: Iter) {\n+    fn extend<I: IntoIterator<Item=(usize, V)>>(&mut self, iter: I) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }"}, {"sha": "7a6c3a0077233346c0912742146022ca3518e4fb", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -113,9 +113,9 @@ impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {\n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n                           built from an iterator over elements of type `{A}`\"]\n pub trait FromIterator<A> {\n-    /// Build a container with elements from an external iterator.\n+    /// Build a container with elements from something iterable.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n+    fn from_iter<T: IntoIterator<Item=A>>(iterator: T) -> Self;\n }\n \n /// Conversion into an `Iterator`\n@@ -147,7 +147,7 @@ impl<I: Iterator> IntoIterator for I {\n pub trait Extend<A> {\n     /// Extend a container with the elements yielded by an arbitrary iterator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T);\n+    fn extend<T: IntoIterator<Item=A>>(&mut self, iterable: T);\n }\n \n /// An extension trait providing numerous methods applicable to all iterators."}, {"sha": "abfef72a5dbc33b735a67416a191f2e1b093600c", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -149,7 +149,7 @@ use clone::Clone;\n use cmp::{Eq, Ord};\n use default::Default;\n use iter::{ExactSizeIterator};\n-use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator};\n+use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator, IntoIterator};\n use mem;\n use ops::{Deref, FnOnce};\n use result::Result::{Ok, Err};\n@@ -909,7 +909,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn from_iter<I: Iterator<Item=Option<A>>>(iter: I) -> Option<V> {\n+    fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n@@ -934,7 +934,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n             }\n         }\n \n-        let mut adapter = Adapter { iter: iter, found_none: false };\n+        let mut adapter = Adapter { iter: iter.into_iter(), found_none: false };\n         let v: V = FromIterator::from_iter(adapter.by_ref());\n \n         if adapter.found_none {"}, {"sha": "23e936a75d7097e04f972a3da25796a285090711", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -230,7 +230,8 @@ use self::Result::{Ok, Err};\n \n use clone::Clone;\n use fmt;\n-use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator, ExactSizeIterator};\n+use iter::{Iterator, IteratorExt, DoubleEndedIterator,\n+           FromIterator, ExactSizeIterator, IntoIterator};\n use ops::{FnMut, FnOnce};\n use option::Option::{self, None, Some};\n use slice::AsSlice;\n@@ -906,7 +907,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// assert!(res == Ok(vec!(2, 3)));\n     /// ```\n     #[inline]\n-    fn from_iter<I: Iterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {\n+    fn from_iter<I: IntoIterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n@@ -931,7 +932,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n             }\n         }\n \n-        let mut adapter = Adapter { iter: iter, err: None };\n+        let mut adapter = Adapter { iter: iter.into_iter(), err: None };\n         let v: V = FromIterator::from_iter(adapter.by_ref());\n \n         match adapter.err {"}, {"sha": "582cd4f384f317b904a72185bb9c66c5df4b85a7", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -37,7 +37,7 @@ use util::ppaux::{ty_to_string};\n use util::nodemap::{FnvHashMap, NodeSet};\n use lint::{Level, Context, LintPass, LintArray, Lint};\n \n-use std::collections::BitvSet;\n+use std::collections::BitSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::num::SignedInt;\n use std::{cmp, slice};\n@@ -1792,7 +1792,7 @@ impl LintPass for UnconditionalRecursion {\n         let mut work_queue = vec![cfg.entry];\n         let mut reached_exit_without_self_call = false;\n         let mut self_call_spans = vec![];\n-        let mut visited = BitvSet::new();\n+        let mut visited = BitSet::new();\n \n         while let Some(idx) = work_queue.pop() {\n             let cfg_id = idx.node_id();"}, {"sha": "6f515450a126913029049ae160e3761ff3e1822c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -25,7 +25,7 @@ use middle::ty::*;\n use middle::ty;\n use std::cmp::Ordering;\n use std::fmt;\n-use std::iter::{range_inclusive, AdditiveIterator, FromIterator, repeat};\n+use std::iter::{range_inclusive, AdditiveIterator, FromIterator, IntoIterator, repeat};\n use std::num::Float;\n use std::slice;\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId, Pat};\n@@ -94,8 +94,8 @@ impl<'a> fmt::Debug for Matrix<'a> {\n }\n \n impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n-    fn from_iter<T: Iterator<Item=Vec<&'a Pat>>>(iterator: T) -> Matrix<'a> {\n-        Matrix(iterator.collect())\n+    fn from_iter<T: IntoIterator<Item=Vec<&'a Pat>>>(iter: T) -> Matrix<'a> {\n+        Matrix(iter.into_iter().collect())\n     }\n }\n "}, {"sha": "436f04fc9e9cf9744f7d484757c9022146e47883", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -34,7 +34,7 @@\n \n use std::fmt::{Formatter, Error, Debug};\n use std::usize;\n-use std::collections::BitvSet;\n+use std::collections::BitSet;\n \n pub struct Graph<N,E> {\n     nodes: Vec<Node<N>> ,\n@@ -292,15 +292,15 @@ impl<N,E> Graph<N,E> {\n         DepthFirstTraversal {\n             graph: self,\n             stack: vec![start],\n-            visited: BitvSet::new()\n+            visited: BitSet::new()\n         }\n     }\n }\n \n pub struct DepthFirstTraversal<'g, N:'g, E:'g> {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n-    visited: BitvSet\n+    visited: BitSet\n }\n \n impl<'g, N, E> Iterator for DepthFirstTraversal<'g, N, E> {"}, {"sha": "10cf02f85e818579e5ed811acaa424ee4e65b251", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -17,12 +17,12 @@ use std::hash::Hash;\n use std::collections::hash_state::HashState;\n \n use {Decodable, Encodable, Decoder, Encoder};\n-use std::collections::{DList, RingBuf, BTreeMap, BTreeSet, HashMap, HashSet, VecMap};\n+use std::collections::{LinkedList, VecDeque, BTreeMap, BTreeSet, HashMap, HashSet, VecMap};\n use collections::enum_set::{EnumSet, CLike};\n \n impl<\n     T: Encodable\n-> Encodable for DList<T> {\n+> Encodable for LinkedList<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -33,10 +33,10 @@ impl<\n     }\n }\n \n-impl<T:Decodable> Decodable for DList<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<DList<T>, D::Error> {\n+impl<T:Decodable> Decodable for LinkedList<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<LinkedList<T>, D::Error> {\n         d.read_seq(|d, len| {\n-            let mut list = DList::new();\n+            let mut list = LinkedList::new();\n             for i in 0..len {\n                 list.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n@@ -45,7 +45,7 @@ impl<T:Decodable> Decodable for DList<T> {\n     }\n }\n \n-impl<T: Encodable> Encodable for RingBuf<T> {\n+impl<T: Encodable> Encodable for VecDeque<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -56,10 +56,10 @@ impl<T: Encodable> Encodable for RingBuf<T> {\n     }\n }\n \n-impl<T:Decodable> Decodable for RingBuf<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<RingBuf<T>, D::Error> {\n+impl<T:Decodable> Decodable for VecDeque<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n         d.read_seq(|d, len| {\n-            let mut deque: RingBuf<T> = RingBuf::new();\n+            let mut deque: VecDeque<T> = VecDeque::new();\n             for i in 0..len {\n                 deque.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }"}, {"sha": "04f8bb0b0db649bed4dd7df08560336a4e546633", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -1534,7 +1534,8 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\n     where K: Eq + Hash, S: HashState + Default\n {\n-    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, S> {\n+    fn from_iter<T: IntoIterator<Item=(K, V)>>(iterable: T) -> HashMap<K, V, S> {\n+        let iter = iterable.into_iter();\n         let lower = iter.size_hint().0;\n         let mut map = HashMap::with_capacity_and_hash_state(lower,\n                                                             Default::default());\n@@ -1547,7 +1548,7 @@ impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\n impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\n     where K: Eq + Hash, S: HashState\n {\n-    fn extend<T: Iterator<Item=(K, V)>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }"}, {"sha": "751dc86f533e845e5471a942513da2d9d8f0813c", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -614,7 +614,8 @@ impl<T, S> FromIterator<T> for HashSet<T, S>\n     where T: Eq + Hash,\n           S: HashState + Default,\n {\n-    fn from_iter<I: Iterator<Item=T>>(iter: I) -> HashSet<T, S> {\n+    fn from_iter<I: IntoIterator<Item=T>>(iterable: I) -> HashSet<T, S> {\n+        let iter = iterable.into_iter();\n         let lower = iter.size_hint().0;\n         let mut set = HashSet::with_capacity_and_hash_state(lower, Default::default());\n         set.extend(iter);\n@@ -627,7 +628,7 @@ impl<T, S> Extend<T> for HashSet<T, S>\n     where T: Eq + Hash,\n           S: HashState,\n {\n-    fn extend<I: Iterator<Item=T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item=T>>(&mut self, iter: I) {\n         for k in iter {\n             self.insert(k);\n         }"}, {"sha": "0e64370df60ecbdc8b24ff51abc1a506ba83b8a2", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -23,7 +23,7 @@\n //!\n //! Rust's collections can be grouped into four major categories:\n //!\n-//! * Sequences: `Vec`, `RingBuf`, `DList`, `BitV`\n+//! * Sequences: `Vec`, `VecDeque`, `LinkedList`, `BitV`\n //! * Maps: `HashMap`, `BTreeMap`, `VecMap`\n //! * Sets: `HashSet`, `BTreeSet`, `BitVSet`\n //! * Misc: `BinaryHeap`\n@@ -43,13 +43,13 @@\n //! * You want a resizable array.\n //! * You want a heap-allocated array.\n //!\n-//! ### Use a `RingBuf` when:\n+//! ### Use a `VecDeque` when:\n //! * You want a `Vec` that supports efficient insertion at both ends of the sequence.\n //! * You want a queue.\n //! * You want a double-ended queue (deque).\n //!\n-//! ### Use a `DList` when:\n-//! * You want a `Vec` or `RingBuf` of unknown size, and can't tolerate amortization.\n+//! ### Use a `LinkedList` when:\n+//! * You want a `Vec` or `VecDeque` of unknown size, and can't tolerate amortization.\n //! * You want to efficiently split and append lists.\n //! * You are *absolutely* certain you *really*, *truly*, want a doubly linked list.\n //!\n@@ -75,7 +75,7 @@\n //!\n //! ### Use a `BitV` when:\n //! * You want to store an unbounded number of booleans in a small space.\n-//! * You want a bitvector.\n+//! * You want a bit vector.\n //!\n //! ### Use a `BitVSet` when:\n //! * You want a `VecSet`.\n@@ -106,20 +106,20 @@\n //!\n //! ## Sequences\n //!\n-//! |         | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n-//! |---------|----------------|-----------------|----------------|--------|----------------|\n-//! | Vec     | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n-//! | RingBuf | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n-//! | DList   | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n-//! | Bitv    | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n+//! |              | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n+//! |--------------|----------------|-----------------|----------------|--------|----------------|\n+//! | Vec          | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n+//! | VecDeque     | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n+//! | LinkedList   | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n+//! | BitVec       | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n //!\n-//! Note that where ties occur, Vec is generally going to be faster than RingBuf, and RingBuf\n-//! is generally going to be faster than DList. Bitv is not a general purpose collection, and\n+//! Note that where ties occur, Vec is generally going to be faster than VecDeque, and VecDeque\n+//! is generally going to be faster than LinkedList. BitVec is not a general purpose collection, and\n //! therefore cannot reasonably be compared.\n //!\n //! ## Maps\n //!\n-//! For Sets, all operations have the cost of the equivalent Map operation. For BitvSet,\n+//! For Sets, all operations have the cost of the equivalent Map operation. For BitSet,\n //! refer to VecMap.\n //!\n //! |          | get       | insert   | remove   | predecessor |\n@@ -166,7 +166,7 @@\n //!\n //! Any `with_capacity` constructor will instruct the collection to allocate enough space\n //! for the specified number of elements. Ideally this will be for exactly that many\n-//! elements, but some implementation details may prevent this. `Vec` and `RingBuf` can\n+//! elements, but some implementation details may prevent this. `Vec` and `VecDeque` can\n //! be relied on to allocate exactly the requested amount, though. Use `with_capacity`\n //! when you know exactly how many elements will be inserted, or at least have a\n //! reasonable upper-bound on that number.\n@@ -240,10 +240,10 @@\n //! ```\n //!\n //! ```\n-//! use std::collections::RingBuf;\n+//! use std::collections::VecDeque;\n //!\n //! let vec = vec![1, 2, 3, 4];\n-//! let buf: RingBuf<_> = vec.into_iter().collect();\n+//! let buf: VecDeque<_> = vec.into_iter().collect();\n //! ```\n //!\n //! Iterators also provide a series of *adapter* methods for performing common tasks to\n@@ -362,11 +362,11 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n pub use core_collections::Bound;\n-pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n-pub use core_collections::{DList, RingBuf, VecMap};\n+pub use core_collections::{BinaryHeap, BitVec, BitSet, BTreeMap, BTreeSet};\n+pub use core_collections::{LinkedList, VecDeque, VecMap};\n \n-pub use core_collections::{binary_heap, bitv, bitv_set, btree_map, btree_set};\n-pub use core_collections::{dlist, ring_buf, vec_map};\n+pub use core_collections::{binary_heap, bit_vec, bit_set, btree_map, btree_set};\n+pub use core_collections::{linked_list, vec_deque, vec_map};\n \n pub use self::hash_map::HashMap;\n pub use self::hash_set::HashSet;"}, {"sha": "2ad07462f20f71033973708f600787e713e2e746", "filename": "src/libstd/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -110,7 +110,7 @@ use core::prelude::*;\n use ascii::*;\n use borrow::BorrowFrom;\n use cmp;\n-use iter;\n+use iter::{self, IntoIterator};\n use mem;\n use ops::{self, Deref};\n use string::CowString;\n@@ -953,15 +953,15 @@ impl PathBuf {\n }\n \n impl<'a, P: ?Sized + 'a> iter::FromIterator<&'a P> for PathBuf where P: AsPath {\n-    fn from_iter<I: Iterator<Item = &'a P>>(iter: I) -> PathBuf {\n+    fn from_iter<I: IntoIterator<Item = &'a P>>(iter: I) -> PathBuf {\n         let mut buf = PathBuf::new(\"\");\n         buf.extend(iter);\n         buf\n     }\n }\n \n impl<'a, P: ?Sized + 'a> iter::Extend<&'a P> for PathBuf where P: AsPath {\n-    fn extend<I: Iterator<Item = &'a P>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a P>>(&mut self, iter: I) {\n         for p in iter {\n             self.push(p)\n         }"}, {"sha": "ca3ae1a7a34360fa158012705feba28fbba07b83", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -33,7 +33,7 @@ use cmp;\n use fmt;\n use hash::{Hash, Hasher};\n #[cfg(stage0)] use hash::Writer;\n-use iter::FromIterator;\n+use iter::{FromIterator, IntoIterator};\n use mem;\n use num::Int;\n use ops;\n@@ -357,9 +357,9 @@ impl Wtf8Buf {\n /// This replaces surrogate code point pairs with supplementary code points,\n /// like concatenating ill-formed UTF-16 strings effectively would.\n impl FromIterator<CodePoint> for Wtf8Buf {\n-    fn from_iter<T: Iterator<Item=CodePoint>>(iterator: T) -> Wtf8Buf {\n+    fn from_iter<T: IntoIterator<Item=CodePoint>>(iter: T) -> Wtf8Buf {\n         let mut string = Wtf8Buf::new();\n-        string.extend(iterator);\n+        string.extend(iter);\n         string\n     }\n }\n@@ -369,7 +369,8 @@ impl FromIterator<CodePoint> for Wtf8Buf {\n /// This replaces surrogate code point pairs with supplementary code points,\n /// like concatenating ill-formed UTF-16 strings effectively would.\n impl Extend<CodePoint> for Wtf8Buf {\n-    fn extend<T: Iterator<Item=CodePoint>>(&mut self, iterator: T) {\n+    fn extend<T: IntoIterator<Item=CodePoint>>(&mut self, iterable: T) {\n+        let iterator = iterable.into_iter();\n         let (low, _high) = iterator.size_hint();\n         // Lower bound of one byte per code point (ASCII only)\n         self.bytes.reserve(low);"}, {"sha": "56efa5e0c935d49ce7624293361796037946ca15", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -26,11 +26,11 @@ use parse::token;\n use ptr::P;\n \n use std::cell::{RefCell, Cell};\n-use std::collections::BitvSet;\n+use std::collections::BitSet;\n use std::collections::HashSet;\n use std::fmt;\n \n-thread_local! { static USED_ATTRS: RefCell<BitvSet> = RefCell::new(BitvSet::new()) }\n+thread_local! { static USED_ATTRS: RefCell<BitSet> = RefCell::new(BitSet::new()) }\n \n pub fn mark_used(attr: &Attribute) {\n     let AttrId(id) = attr.node.id;"}, {"sha": "f5201d4a8bc68f73ea9f46c07e6bca61330a561e", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -10,7 +10,7 @@\n \n use std::default::Default;\n use std::fmt;\n-use std::iter::FromIterator;\n+use std::iter::{IntoIterator, FromIterator};\n use std::ops::Deref;\n use std::vec;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -77,8 +77,8 @@ impl<T: Clone> Clone for OwnedSlice<T> {\n }\n \n impl<T> FromIterator<T> for OwnedSlice<T> {\n-    fn from_iter<I: Iterator<Item=T>>(iter: I) -> OwnedSlice<T> {\n-        OwnedSlice::from_vec(iter.collect())\n+    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> OwnedSlice<T> {\n+        OwnedSlice::from_vec(iter.into_iter().collect())\n     }\n }\n "}, {"sha": "0a39d3809045a2e56f745255e6b204bc5d43f8d0", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -11,7 +11,7 @@\n use self::SmallVectorRepr::*;\n use self::IntoIterRepr::*;\n \n-use std::iter::FromIterator;\n+use std::iter::{IntoIterator, FromIterator};\n use std::mem;\n use std::slice;\n use std::vec;\n@@ -30,15 +30,15 @@ enum SmallVectorRepr<T> {\n }\n \n impl<T> FromIterator<T> for SmallVector<T> {\n-    fn from_iter<I: Iterator<Item=T>>(iter: I) -> SmallVector<T> {\n+    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> SmallVector<T> {\n         let mut v = SmallVector::zero();\n         v.extend(iter);\n         v\n     }\n }\n \n impl<T> Extend<T> for SmallVector<T> {\n-    fn extend<I: Iterator<Item=T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item=T>>(&mut self, iter: I) {\n         for val in iter {\n             self.push(val);\n         }"}, {"sha": "994c9605fc375ccbaec7c386c6612f9a951b62b5", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=5a32b4a34fc6fbd78e293b16f7ba7d06caca7a48", "patch": "@@ -16,7 +16,7 @@ extern crate collections;\n extern crate rand;\n \n use std::collections::BTreeSet;\n-use std::collections::BitvSet;\n+use std::collections::BitSet;\n use std::collections::HashSet;\n use std::hash::Hash;\n use std::env;\n@@ -52,7 +52,7 @@ impl<T: Ord> MutableSet<T> for BTreeSet<T> {\n     fn remove(&mut self, k: &T) -> bool { self.remove(k) }\n     fn contains(&self, k: &T) -> bool { self.contains(k) }\n }\n-impl MutableSet<usize> for BitvSet {\n+impl MutableSet<usize> for BitSet {\n     fn insert(&mut self, k: usize) { self.insert(k); }\n     fn remove(&mut self, k: &usize) -> bool { self.remove(k) }\n     fn contains(&self, k: &usize) -> bool { self.contains(k) }\n@@ -221,7 +221,7 @@ fn main() {\n     {\n         let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n         let mut results = empty_results();\n-        results.bench_int(&mut rng, num_keys, max, || BitvSet::new());\n-        write_results(\"collections::bitv::BitvSet\", &results);\n+        results.bench_int(&mut rng, num_keys, max, || BitSet::new());\n+        write_results(\"collections::bit_vec::BitSet\", &results);\n     }\n }"}]}