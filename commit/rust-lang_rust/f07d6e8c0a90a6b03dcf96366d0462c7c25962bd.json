{"sha": "f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "node_id": "C_kwDOAAsO6NoAKGYwN2Q2ZThjMGE5MGE2YjAzZGNmOTYzNjZkMDQ2MmM3YzI1OTYyYmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-30T23:43:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-30T23:43:33Z"}, "message": "Auto merge of #99102 - JakobDegen:reorder-generators, r=oli-obk\n\nRework definition of MIR phases to more closely reflect semantic concerns\n\nImplements most of rust-lang/compiler-team#522 .\n\nI tried my best to restrict this PR to the \"core\" parts of the MCP. In other words, this includes just enough changes to make the new definition of `MirPhase` make sense. That means there are a couple of FIXMEs lying around. Depending on what reviewers prefer, I can either fix them in this PR or send follow up PRs. There are also a couple other refactorings of the `rustc_mir_transform/src/lib.rs` file that I want to do in follow ups that I didn't leave explicit FIXMEs for.", "tree": {"sha": "002d3328a7a6fb75aa3a2db64b59bd320d4879d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/002d3328a7a6fb75aa3a2db64b59bd320d4879d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "html_url": "https://github.com/rust-lang/rust/commit/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02654a0844f5c8d29bac318c3c6c666da3d8543d", "url": "https://api.github.com/repos/rust-lang/rust/commits/02654a0844f5c8d29bac318c3c6c666da3d8543d", "html_url": "https://github.com/rust-lang/rust/commit/02654a0844f5c8d29bac318c3c6c666da3d8543d"}, {"sha": "d56751cc3405ec5c90d3edddf489e5cb16cf7344", "url": "https://api.github.com/repos/rust-lang/rust/commits/d56751cc3405ec5c90d3edddf489e5cb16cf7344", "html_url": "https://github.com/rust-lang/rust/commit/d56751cc3405ec5c90d3edddf489e5cb16cf7344"}], "stats": {"total": 509, "additions": 301, "deletions": 208}, "files": [{"sha": "f5ba408bee0e132955e38c978f7a03e5a1c478ba", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -41,7 +41,7 @@ pub struct PromoteTemps<'tcx> {\n \n impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n     fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::ConstsPromoted)\n+        Some(MirPhase::Analysis(AnalysisPhase::Initial))\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n@@ -964,7 +964,7 @@ pub fn promote_candidates<'tcx>(\n         let mut scope = body.source_scopes[body.source_info(candidate.location).scope].clone();\n         scope.parent_scope = None;\n \n-        let promoted = Body::new(\n+        let mut promoted = Body::new(\n             body.source, // `promoted` gets filled in below\n             IndexVec::new(),\n             IndexVec::from_elem_n(scope, 1),\n@@ -976,6 +976,7 @@ pub fn promote_candidates<'tcx>(\n             body.generator_kind(),\n             body.tainted_by_errors,\n         );\n+        promoted.phase = MirPhase::Analysis(AnalysisPhase::Initial);\n \n         let promoter = Promoter {\n             promoted,"}, {"sha": "b662513e70fbe6ee0d57ec27d50c651bd691c5c1", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -8,8 +8,8 @@ use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n     traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, CastKind, Local, Location,\n-    MirPass, MirPhase, Operand, Place, PlaceElem, PlaceRef, ProjectionElem, Rvalue, SourceScope,\n-    Statement, StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n+    MirPass, MirPhase, Operand, Place, PlaceElem, PlaceRef, ProjectionElem, RuntimePhase, Rvalue,\n+    SourceScope, Statement, StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n };\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::subst::Subst;\n@@ -221,7 +221,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n \n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         // This check is somewhat expensive, so only run it when -Zvalidate-mir is passed.\n-        if self.tcx.sess.opts.unstable_opts.validate_mir && self.mir_phase < MirPhase::DropsLowered\n+        if self.tcx.sess.opts.unstable_opts.validate_mir\n+            && self.mir_phase < MirPhase::Runtime(RuntimePhase::Initial)\n         {\n             // `Operand::Copy` is only supposed to be used with `Copy` types.\n             if let Operand::Copy(place) = operand {\n@@ -252,7 +253,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.fail(location, format!(\"bad index ({:?} != usize)\", index_ty))\n                 }\n             }\n-            ProjectionElem::Deref if self.mir_phase >= MirPhase::GeneratorsLowered => {\n+            ProjectionElem::Deref\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::PostCleanup) =>\n+            {\n                 let base_ty = Place::ty_from(local, proj_base, &self.body.local_decls, self.tcx).ty;\n \n                 if base_ty.is_box() {\n@@ -360,7 +363,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n         // Set off any `bug!`s in the type computation code\n         let _ = place.ty(&self.body.local_decls, self.tcx);\n \n-        if self.mir_phase >= MirPhase::Derefered\n+        if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial)\n             && place.projection.len() > 1\n             && cntxt != PlaceContext::NonUse(VarDebugInfo)\n             && place.projection[1..].contains(&ProjectionElem::Deref)\n@@ -384,8 +387,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             Rvalue::Aggregate(agg_kind, _) => {\n                 let disallowed = match **agg_kind {\n                     AggregateKind::Array(..) => false,\n-                    AggregateKind::Generator(..) => self.mir_phase >= MirPhase::GeneratorsLowered,\n-                    _ => self.mir_phase >= MirPhase::Deaggregated,\n+                    _ => self.mir_phase >= MirPhase::Runtime(RuntimePhase::PostCleanup),\n                 };\n                 if disallowed {\n                     self.fail(\n@@ -395,10 +397,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             Rvalue::Ref(_, BorrowKind::Shallow, _) => {\n-                if self.mir_phase >= MirPhase::DropsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n-                        \"`Assign` statement with a `Shallow` borrow should have been removed after drop lowering phase\",\n+                        \"`Assign` statement with a `Shallow` borrow should have been removed in runtime MIR\",\n                     );\n                 }\n             }\n@@ -612,15 +614,15 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             StatementKind::AscribeUserType(..) => {\n-                if self.mir_phase >= MirPhase::DropsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n                         \"`AscribeUserType` should have been removed after drop lowering phase\",\n                     );\n                 }\n             }\n             StatementKind::FakeRead(..) => {\n-                if self.mir_phase >= MirPhase::DropsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n                         \"`FakeRead` should have been removed after drop lowering phase\",\n@@ -664,7 +666,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             StatementKind::SetDiscriminant { place, .. } => {\n-                if self.mir_phase < MirPhase::Deaggregated {\n+                if self.mir_phase < MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(location, \"`SetDiscriminant`is not allowed until deaggregation\");\n                 }\n                 let pty = place.ty(&self.body.local_decls, self.tcx).ty.kind();\n@@ -679,7 +681,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             StatementKind::Deinit(..) => {\n-                if self.mir_phase < MirPhase::Deaggregated {\n+                if self.mir_phase < MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(location, \"`Deinit`is not allowed until deaggregation\");\n                 }\n             }\n@@ -759,7 +761,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::DropAndReplace { target, unwind, .. } => {\n-                if self.mir_phase >= MirPhase::DropsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n                         \"`DropAndReplace` should have been removed during drop elaboration\",\n@@ -830,7 +832,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 if self.body.generator.is_none() {\n                     self.fail(location, \"`Yield` cannot appear outside generator bodies\");\n                 }\n-                if self.mir_phase >= MirPhase::GeneratorsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(location, \"`Yield` should have been replaced by generator lowering\");\n                 }\n                 self.check_edge(location, *resume, EdgeKind::Normal);\n@@ -839,7 +841,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::FalseEdge { real_target, imaginary_target } => {\n-                if self.mir_phase >= MirPhase::DropsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n                         \"`FalseEdge` should have been removed after drop elaboration\",\n@@ -849,7 +851,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 self.check_edge(location, *imaginary_target, EdgeKind::Normal);\n             }\n             TerminatorKind::FalseUnwind { real_target, unwind } => {\n-                if self.mir_phase >= MirPhase::DropsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n                         \"`FalseUnwind` should have been removed after drop elaboration\",\n@@ -872,7 +874,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 if self.body.generator.is_none() {\n                     self.fail(location, \"`GeneratorDrop` cannot appear outside generator bodies\");\n                 }\n-                if self.mir_phase >= MirPhase::GeneratorsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n                         \"`GeneratorDrop` should have been replaced by generator lowering\","}, {"sha": "7784449d605e7f476758a708dd0bb353f958f8d1", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -128,8 +128,20 @@ pub trait MirPass<'tcx> {\n \n impl MirPhase {\n     /// Gets the index of the current MirPhase within the set of all `MirPhase`s.\n+    ///\n+    /// FIXME(JakobDegen): Return a `(usize, usize)` instead.\n     pub fn phase_index(&self) -> usize {\n-        *self as usize\n+        const BUILT_PHASE_COUNT: usize = 1;\n+        const ANALYSIS_PHASE_COUNT: usize = 2;\n+        match self {\n+            MirPhase::Built => 1,\n+            MirPhase::Analysis(analysis_phase) => {\n+                1 + BUILT_PHASE_COUNT + (*analysis_phase as usize)\n+            }\n+            MirPhase::Runtime(runtime_phase) => {\n+                1 + BUILT_PHASE_COUNT + ANALYSIS_PHASE_COUNT + (*runtime_phase as usize)\n+            }\n+        }\n     }\n }\n "}, {"sha": "3426f5f43f0bad4878b8b88d778a526eefd13b57", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 89, "deletions": 54, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -23,75 +23,110 @@ use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n \n-/// The various \"big phases\" that MIR goes through.\n+/// Represents the \"flavors\" of MIR.\n ///\n-/// These phases all describe dialects of MIR. Since all MIR uses the same datastructures, the\n-/// dialects forbid certain variants or values in certain phases. The sections below summarize the\n-/// changes, but do not document them thoroughly. The full documentation is found in the appropriate\n-/// documentation for the thing the change is affecting.\n+/// All flavors of MIR use the same data structure, but there are some important differences. These\n+/// differences come in two forms: Dialects and phases.\n ///\n-/// Warning: ordering of variants is significant.\n+/// Dialects represent a stronger distinction than phases. This is because the transitions between\n+/// dialects are semantic changes, and therefore technically *lowerings* between distinct IRs. In\n+/// other words, the same [`Body`](crate::mir::Body) might be well-formed for multiple dialects, but\n+/// have different semantic meaning and different behavior at runtime.\n+///\n+/// Each dialect additionally has a number of phases. However, phase changes never involve semantic\n+/// changes. If some MIR is well-formed both before and after a phase change, it is also guaranteed\n+/// that it has the same semantic meaning. In this sense, phase changes can only add additional\n+/// restrictions on what MIR is well-formed.\n+///\n+/// When adding phases, remember to update [`MirPhase::phase_index`].\n #[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n #[derive(HashStable)]\n pub enum MirPhase {\n-    /// The dialect of MIR used during all phases before `DropsLowered` is the same. This is also\n-    /// the MIR that analysis such as borrowck uses.\n-    ///\n-    /// One important thing to remember about the behavior of this section of MIR is that drop terminators\n-    /// (including drop and replace) are *conditional*. The elaborate drops pass will then replace each\n-    /// instance of a drop terminator with a nop, an unconditional drop, or a drop conditioned on a drop\n-    /// flag. Of course, this means that it is important that the drop elaboration can accurately recognize\n-    /// when things are initialized and when things are de-initialized. That means any code running on this\n-    /// version of MIR must be sure to produce output that drop elaboration can reason about. See the\n-    /// section on the drop terminatorss for more details.\n-    Built = 0,\n-    // FIXME(oli-obk): it's unclear whether we still need this phase (and its corresponding query).\n-    // We used to have this for pre-miri MIR based const eval.\n-    Const = 1,\n-    /// This phase checks the MIR for promotable elements and takes them out of the main MIR body\n-    /// by creating a new MIR body per promoted element. After this phase (and thus the termination\n-    /// of the `mir_promoted` query), these promoted elements are available in the `promoted_mir`\n-    /// query.\n-    ConstsPromoted = 2,\n-    /// After this projections may only contain deref projections as the first element.\n-    Derefered = 3,\n-    /// Beginning with this phase, the following variants are disallowed:\n-    /// * [`TerminatorKind::DropAndReplace`]\n+    /// The MIR that is generated by MIR building.\n+    ///\n+    /// The only things that operate on this dialect are unsafeck, the various MIR lints, and const\n+    /// qualifs.\n+    ///\n+    /// This has no distinct phases.\n+    Built,\n+    /// The MIR used for most analysis.\n+    ///\n+    /// The only semantic change between analysis and built MIR is constant promotion. In built MIR,\n+    /// sequences of statements that would generally be subject to constant promotion are\n+    /// semantically constants, while in analysis MIR all constants are explicit.\n+    ///\n+    /// The result of const promotion is available from the `mir_promoted` and `promoted_mir` queries.\n+    ///\n+    /// This is the version of MIR used by borrowck and friends.\n+    Analysis(AnalysisPhase),\n+    /// The MIR used for CTFE, optimizations, and codegen.\n+    ///\n+    /// The semantic changes that occur in the lowering from analysis to runtime MIR are as follows:\n+    ///\n+    ///  - Drops: In analysis MIR, `Drop` terminators represent *conditional* drops; roughly speaking,\n+    ///    if dataflow analysis determines that the place being dropped is uninitialized, the drop will\n+    ///    not be executed. The exact semantics of this aren't written down anywhere, which means they\n+    ///    are essentially \"what drop elaboration does.\" In runtime MIR, the drops are unconditional;\n+    ///    when a `Drop` terminator is reached, if the type has drop glue that drop glue is always\n+    ///    executed. This may be UB if the underlying place is not initialized.\n+    ///  - Packed drops: Places might in general be misaligned - in most cases this is UB, the exception\n+    ///    is fields of packed structs. In analysis MIR, `Drop(P)` for a `P` that might be misaligned\n+    ///    for this reason implicitly moves `P` to a temporary before dropping. Runtime MIR has no such\n+    ///    rules, and dropping a misaligned place is simply UB.\n+    ///  - Unwinding: in analysis MIR, unwinding from a function which may not unwind aborts. In runtime\n+    ///    MIR, this is UB.\n+    ///  - Retags: If `-Zmir-emit-retag` is enabled, analysis MIR has \"implicit\" retags in the same way\n+    ///    that Rust itself has them. Where exactly these are is generally subject to change, and so we\n+    ///    don't document this here. Runtime MIR has all retags explicit.\n+    ///  - Generator bodies: In analysis MIR, locals may actually be behind a pointer that user code has\n+    ///    access to. This occurs in generator bodies. Such locals do not behave like other locals,\n+    ///    because they eg may be aliased in surprising ways. Runtime MIR has no such special locals -\n+    ///    all generator bodies are lowered and so all places that look like locals really are locals.\n+    ///  - Const prop lints: The lint pass which reports eg `200_u8 + 200_u8` as an error is run as a\n+    ///    part of analysis to runtime MIR lowering. This means that transformations which may supress\n+    ///    such errors may not run on analysis MIR.\n+    Runtime(RuntimePhase),\n+}\n+\n+/// See [`MirPhase::Analysis`].\n+#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(HashStable)]\n+pub enum AnalysisPhase {\n+    Initial = 0,\n+    /// Beginning in this phase, the following variants are disallowed:\n     /// * [`TerminatorKind::FalseUnwind`]\n     /// * [`TerminatorKind::FalseEdge`]\n     /// * [`StatementKind::FakeRead`]\n     /// * [`StatementKind::AscribeUserType`]\n     /// * [`Rvalue::Ref`] with `BorrowKind::Shallow`\n     ///\n-    /// And the following variant is allowed:\n-    /// * [`StatementKind::Retag`]\n-    ///\n-    /// Furthermore, `Drop` now uses explicit drop flags visible in the MIR and reaching a `Drop`\n-    /// terminator means that the auto-generated drop glue will be invoked. Also, `Copy` operands\n-    /// are allowed for non-`Copy` types.\n-    DropsLowered = 4,\n-    /// Beginning with this phase, the following variant is disallowed:\n+    /// Furthermore, `Deref` projections must be the first projection within any place (if they\n+    /// appear at all)\n+    PostCleanup = 1,\n+}\n+\n+/// See [`MirPhase::Runtime`].\n+#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(HashStable)]\n+pub enum RuntimePhase {\n+    /// In addition to the semantic changes, beginning with this phase, the following variants are\n+    /// disallowed:\n+    /// * [`TerminatorKind::DropAndReplace`]\n+    /// * [`TerminatorKind::Yield`]\n+    /// * [`TerminatorKind::GeneratorDrop`]\n     /// * [`Rvalue::Aggregate`] for any `AggregateKind` except `Array`\n     ///\n-    /// And the following variant is allowed:\n+    /// And the following variants are allowed:\n+    /// * [`StatementKind::Retag`]\n     /// * [`StatementKind::SetDiscriminant`]\n-    Deaggregated = 5,\n-    /// Before this phase, generators are in the \"source code\" form, featuring `yield` statements\n-    /// and such. With this phase change, they are transformed into a proper state machine. Running\n-    /// optimizations before this change can be potentially dangerous because the source code is to\n-    /// some extent a \"lie.\" In particular, `yield` terminators effectively make the value of all\n-    /// locals visible to the caller. This means that dead store elimination before them, or code\n-    /// motion across them, is not correct in general. This is also exasperated by type checking\n-    /// having pre-computed a list of the types that it thinks are ok to be live across a yield\n-    /// point - this is necessary to decide eg whether autotraits are implemented. Introducing new\n-    /// types across a yield point will lead to ICEs becaues of this.\n-    ///\n-    /// Beginning with this phase, the following variants are disallowed:\n-    /// * [`TerminatorKind::Yield`]\n-    /// * [`TerminatorKind::GeneratorDrop`]\n+    /// * [`StatementKind::Deinit`]\n+    ///\n+    /// Furthermore, `Copy` operands are allowed for non-`Copy` types.\n+    Initial = 0,\n+    /// Beginning with this phase, the following variant is disallowed:\n     /// * [`ProjectionElem::Deref`] of `Box`\n-    GeneratorsLowered = 6,\n-    Optimized = 7,\n+    PostCleanup = 1,\n+    Optimized = 2,\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "fe272de20f8d085e7d0c88548f16382791209e0a", "filename": "compiler/rustc_mir_transform/src/deaggregator.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -6,10 +6,6 @@ use rustc_middle::ty::TyCtxt;\n pub struct Deaggregator;\n \n impl<'tcx> MirPass<'tcx> for Deaggregator {\n-    fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::Deaggregated)\n-    }\n-\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let basic_blocks = body.basic_blocks.as_mut_preserves_cfg();\n         for bb in basic_blocks {"}, {"sha": "7508df92df1d5bd1537f4740d48fed7ac8c0bc50", "filename": "compiler/rustc_mir_transform/src/deref_separator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Fderef_separator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Fderef_separator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fderef_separator.rs?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -82,6 +82,5 @@ pub fn deref_finder<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n impl<'tcx> MirPass<'tcx> for Derefer {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         deref_finder(tcx, body);\n-        body.phase = MirPhase::Derefered;\n     }\n }"}, {"sha": "65f4956d23acd5e7722e75caf517269a838b21d7", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -21,10 +21,6 @@ use std::fmt;\n pub struct ElaborateDrops;\n \n impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n-    fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::DropsLowered)\n-    }\n-\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"elaborate_drops({:?} @ {:?})\", body.source, body.span);\n "}, {"sha": "dbff4a6bd696e01df9595a630fd99fe625efa71b", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -1240,10 +1240,6 @@ fn create_cases<'tcx>(\n }\n \n impl<'tcx> MirPass<'tcx> for StateTransform {\n-    fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::GeneratorsLowered)\n-    }\n-\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let Some(yield_ty) = body.yield_ty() else {\n             // This only applies to generators"}, {"sha": "0b674b38f32826f5a78cc2a561ea0eeed53888dd", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 63, "deletions": 36, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -26,7 +26,9 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::Visitor as _;\n-use rustc_middle::mir::{traversal, Body, ConstQualifs, MirPass, MirPhase, Promoted};\n+use rustc_middle::mir::{\n+    traversal, AnalysisPhase, Body, ConstQualifs, MirPass, MirPhase, Promoted, RuntimePhase,\n+};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n \n@@ -200,6 +202,8 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) ->\n }\n \n /// Make MIR ready for const evaluation. This is run on all MIR, not just on consts!\n+/// FIXME(oli-obk): it's unclear whether we still need this phase (and its corresponding query).\n+/// We used to have this for pre-miri MIR based const eval.\n fn mir_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n@@ -235,7 +239,6 @@ fn mir_const<'tcx>(\n             // What we need to do constant evaluation.\n             &simplify::SimplifyCfg::new(\"initial\"),\n             &rustc_peek::SanityCheck, // Just a lint\n-            &marker::PhaseChange(MirPhase::Const),\n         ],\n     );\n     tcx.alloc_steal_mir(body)\n@@ -341,7 +344,10 @@ fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -\n             pm::run_passes(\n                 tcx,\n                 &mut body,\n-                &[&const_prop::ConstProp, &marker::PhaseChange(MirPhase::Optimized)],\n+                &[\n+                    &const_prop::ConstProp,\n+                    &marker::PhaseChange(MirPhase::Runtime(RuntimePhase::Optimized)),\n+                ],\n             );\n         }\n     }\n@@ -381,38 +387,61 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n         body.tainted_by_errors = Some(error_reported);\n     }\n \n-    // IMPORTANT\n-    pm::run_passes(tcx, &mut body, &[&remove_false_edges::RemoveFalseEdges]);\n+    run_analysis_to_runtime_passes(tcx, &mut body);\n+\n+    tcx.alloc_steal_mir(body)\n+}\n+\n+fn run_analysis_to_runtime_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    assert!(body.phase == MirPhase::Analysis(AnalysisPhase::Initial));\n+    let did = body.source.def_id();\n+\n+    debug!(\"analysis_mir_cleanup({:?})\", did);\n+    run_analysis_cleanup_passes(tcx, body);\n+    assert!(body.phase == MirPhase::Analysis(AnalysisPhase::PostCleanup));\n \n     // Do a little drop elaboration before const-checking if `const_precise_live_drops` is enabled.\n     if check_consts::post_drop_elaboration::checking_enabled(&ConstCx::new(tcx, &body)) {\n         pm::run_passes(\n             tcx,\n-            &mut body,\n+            body,\n             &[\n-                &simplify::SimplifyCfg::new(\"remove-false-edges\"),\n                 &remove_uninit_drops::RemoveUninitDrops,\n+                &simplify::SimplifyCfg::new(\"remove-false-edges\"),\n             ],\n         );\n         check_consts::post_drop_elaboration::check_live_drops(tcx, &body); // FIXME: make this a MIR lint\n     }\n \n-    run_post_borrowck_cleanup_passes(tcx, &mut body);\n-    assert!(body.phase == MirPhase::Deaggregated);\n-    tcx.alloc_steal_mir(body)\n+    debug!(\"runtime_mir_lowering({:?})\", did);\n+    run_runtime_lowering_passes(tcx, body);\n+    assert!(body.phase == MirPhase::Runtime(RuntimePhase::Initial));\n+\n+    debug!(\"runtime_mir_cleanup({:?})\", did);\n+    run_runtime_cleanup_passes(tcx, body);\n+    assert!(body.phase == MirPhase::Runtime(RuntimePhase::PostCleanup));\n }\n \n-/// After this series of passes, no lifetime analysis based on borrowing can be done.\n-fn run_post_borrowck_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-    debug!(\"post_borrowck_cleanup({:?})\", body.source.def_id());\n+// FIXME(JakobDegen): Can we make these lists of passes consts?\n \n-    let post_borrowck_cleanup: &[&dyn MirPass<'tcx>] = &[\n-        // Remove all things only needed by analysis\n+/// After this series of passes, no lifetime analysis based on borrowing can be done.\n+fn run_analysis_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let passes: &[&dyn MirPass<'tcx>] = &[\n+        &remove_false_edges::RemoveFalseEdges,\n         &simplify_branches::SimplifyConstCondition::new(\"initial\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &cleanup_post_borrowck::CleanupNonCodegenStatements,\n         &simplify::SimplifyCfg::new(\"early-opt\"),\n         &deref_separator::Derefer,\n+        &marker::PhaseChange(MirPhase::Analysis(AnalysisPhase::PostCleanup)),\n+    ];\n+\n+    pm::run_passes(tcx, body, passes);\n+}\n+\n+/// Returns the sequence of passes that lowers analysis to runtime MIR.\n+fn run_runtime_lowering_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let passes: &[&dyn MirPass<'tcx>] = &[\n         // These next passes must be executed together\n         &add_call_guards::CriticalCallEdges,\n         &elaborate_drops::ElaborateDrops,\n@@ -426,26 +455,35 @@ fn run_post_borrowck_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tc\n         // `AddRetag` needs to run after `ElaborateDrops`. Otherwise it should run fairly late,\n         // but before optimizations begin.\n         &elaborate_box_derefs::ElaborateBoxDerefs,\n+        &generator::StateTransform,\n         &add_retag::AddRetag,\n-        &lower_intrinsics::LowerIntrinsics,\n-        &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n-        // `Deaggregator` is conceptually part of MIR building, some backends rely on it happening\n-        // and it can help optimizations.\n+        // Deaggregator is necessary for const prop. We may want to consider implementing\n+        // CTFE support for aggregates.\n         &deaggregator::Deaggregator,\n         &Lint(const_prop_lint::ConstProp),\n+        &marker::PhaseChange(MirPhase::Runtime(RuntimePhase::Initial)),\n+    ];\n+    pm::run_passes_no_validate(tcx, body, passes);\n+}\n+\n+/// Returns the sequence of passes that do the initial cleanup of runtime MIR.\n+fn run_runtime_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let passes: &[&dyn MirPass<'tcx>] = &[\n+        &elaborate_box_derefs::ElaborateBoxDerefs,\n+        &lower_intrinsics::LowerIntrinsics,\n+        &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n+        &marker::PhaseChange(MirPhase::Runtime(RuntimePhase::PostCleanup)),\n     ];\n \n-    pm::run_passes(tcx, body, post_borrowck_cleanup);\n+    pm::run_passes(tcx, body, passes);\n }\n \n fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     fn o1<T>(x: T) -> WithMinOptLevel<T> {\n         WithMinOptLevel(1, x)\n     }\n \n-    // Lowering generator control-flow and variables has to happen before we do anything else\n-    // to them. We run some optimizations before that, because they may be harder to do on the state\n-    // machine than on MIR with async primitives.\n+    // The main optimizations that we do on MIR.\n     pm::run_passes(\n         tcx,\n         body,\n@@ -457,17 +495,6 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             &uninhabited_enum_branching::UninhabitedEnumBranching,\n             &o1(simplify::SimplifyCfg::new(\"after-uninhabited-enum-branching\")),\n             &inline::Inline,\n-            &generator::StateTransform,\n-        ],\n-    );\n-\n-    assert!(body.phase == MirPhase::GeneratorsLowered);\n-\n-    // The main optimizations that we do on MIR.\n-    pm::run_passes(\n-        tcx,\n-        body,\n-        &[\n             &remove_storage_markers::RemoveStorageMarkers,\n             &remove_zsts::RemoveZsts,\n             &const_goto::ConstGoto,\n@@ -499,7 +526,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             &deduplicate_blocks::DeduplicateBlocks,\n             // Some cleanup necessary at least for LLVM and potentially other codegen backends.\n             &add_call_guards::CriticalCallEdges,\n-            &marker::PhaseChange(MirPhase::Optimized),\n+            &marker::PhaseChange(MirPhase::Runtime(RuntimePhase::Optimized)),\n             // Dump the end result for testing and debugging purposes.\n             &dump_mir::Marker(\"PreCodegen\"),\n         ],\n@@ -558,7 +585,7 @@ fn promoted_mir<'tcx>(\n         if let Some(error_reported) = tainted_by_errors {\n             body.tainted_by_errors = Some(error_reported);\n         }\n-        run_post_borrowck_cleanup_passes(tcx, body);\n+        run_analysis_to_runtime_passes(tcx, body);\n     }\n \n     debug_assert!(!promoted.has_free_regions(), \"Free regions in promoted MIR\");"}, {"sha": "67ea5cfdb3c006a038bd9fffc4ae1d2842ef1f87", "filename": "compiler/rustc_mir_transform/src/pass_manager.rs", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -1,6 +1,6 @@\n use std::borrow::Cow;\n \n-use rustc_middle::mir::{self, Body, MirPhase};\n+use rustc_middle::mir::{self, Body, MirPhase, RuntimePhase};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n \n@@ -72,64 +72,73 @@ where\n     }\n }\n \n+/// Run the sequence of passes without validating the MIR after each pass. The MIR is still\n+/// validated at the end.\n+pub fn run_passes_no_validate<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    passes: &[&dyn MirPass<'tcx>],\n+) {\n+    run_passes_inner(tcx, body, passes, false);\n+}\n+\n pub fn run_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, passes: &[&dyn MirPass<'tcx>]) {\n+    run_passes_inner(tcx, body, passes, true);\n+}\n+\n+fn run_passes_inner<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    passes: &[&dyn MirPass<'tcx>],\n+    validate_each: bool,\n+) {\n     let start_phase = body.phase;\n     let mut cnt = 0;\n \n-    let validate = tcx.sess.opts.unstable_opts.validate_mir;\n+    let validate = validate_each & tcx.sess.opts.unstable_opts.validate_mir;\n     let overridden_passes = &tcx.sess.opts.unstable_opts.mir_enable_passes;\n     trace!(?overridden_passes);\n \n-    if validate {\n-        validate_body(tcx, body, format!(\"start of phase transition from {:?}\", start_phase));\n-    }\n-\n     for pass in passes {\n         let name = pass.name();\n \n-        if let Some((_, polarity)) = overridden_passes.iter().rev().find(|(s, _)| s == &*name) {\n-            trace!(\n-                pass = %name,\n-                \"{} as requested by flag\",\n-                if *polarity { \"Running\" } else { \"Not running\" },\n-            );\n-            if !polarity {\n-                continue;\n-            }\n-        } else {\n-            if !pass.is_enabled(&tcx.sess) {\n-                continue;\n-            }\n-        }\n-        let dump_enabled = pass.is_mir_dump_enabled();\n+        // Gather information about what we should be doing for this pass\n+        let overriden =\n+            overridden_passes.iter().rev().find(|(s, _)| s == &*name).map(|(_name, polarity)| {\n+                trace!(\n+                    pass = %name,\n+                    \"{} as requested by flag\",\n+                    if *polarity { \"Running\" } else { \"Not running\" },\n+                );\n+                *polarity\n+            });\n+        let is_enabled = overriden.unwrap_or_else(|| pass.is_enabled(&tcx.sess));\n+        let new_phase = pass.phase_change();\n+        let dump_enabled = (is_enabled && pass.is_mir_dump_enabled()) || new_phase.is_some();\n+        let validate = (validate && is_enabled)\n+            || new_phase == Some(MirPhase::Runtime(RuntimePhase::Optimized));\n \n         if dump_enabled {\n             dump_mir(tcx, body, start_phase, &name, cnt, false);\n         }\n-\n-        pass.run_pass(tcx, body);\n-\n+        if is_enabled {\n+            pass.run_pass(tcx, body);\n+        }\n         if dump_enabled {\n             dump_mir(tcx, body, start_phase, &name, cnt, true);\n             cnt += 1;\n         }\n-\n         if let Some(new_phase) = pass.phase_change() {\n             if body.phase >= new_phase {\n                 panic!(\"Invalid MIR phase transition from {:?} to {:?}\", body.phase, new_phase);\n             }\n \n             body.phase = new_phase;\n         }\n-\n         if validate {\n-            validate_body(tcx, body, format!(\"after pass {}\", pass.name()));\n+            validate_body(tcx, body, format!(\"after pass {}\", name));\n         }\n     }\n-\n-    if validate || body.phase == MirPhase::Optimized {\n-        validate_body(tcx, body, format!(\"end of phase transition to {:?}\", body.phase));\n-    }\n }\n \n pub fn validate_body<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, when: String) {\n@@ -144,7 +153,7 @@ pub fn dump_mir<'tcx>(\n     cnt: usize,\n     is_after: bool,\n ) {\n-    let phase_index = phase as u32;\n+    let phase_index = phase.phase_index();\n \n     mir::dump_mir(\n         tcx,"}, {"sha": "2b21fbe0a617ff4496fa208fbf44e1988e41ed81", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -17,8 +17,8 @@ use std::iter;\n \n use crate::util::expand_aggregate;\n use crate::{\n-    abort_unwinding_calls, add_call_guards, add_moves_for_packed_drops, marker, pass_manager as pm,\n-    remove_noop_landing_pads, simplify,\n+    abort_unwinding_calls, add_call_guards, add_moves_for_packed_drops, deref_separator, marker,\n+    pass_manager as pm, remove_noop_landing_pads, simplify,\n };\n use rustc_middle::mir::patch::MirPatch;\n use rustc_mir_dataflow::elaborate_drops::{self, DropElaborator, DropFlagMode, DropStyle};\n@@ -92,11 +92,12 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n         &mut result,\n         &[\n             &add_moves_for_packed_drops::AddMovesForPackedDrops,\n+            &deref_separator::Derefer,\n             &remove_noop_landing_pads::RemoveNoopLandingPads,\n             &simplify::SimplifyCfg::new(\"make_shim\"),\n             &add_call_guards::CriticalCallEdges,\n             &abort_unwinding_calls::AbortUnwindingCalls,\n-            &marker::PhaseChange(MirPhase::Const),\n+            &marker::PhaseChange(MirPhase::Runtime(RuntimePhase::Optimized)),\n         ],\n     );\n "}, {"sha": "94f4a5a63178d73fd591ada5e72c9872b3e6cf03", "filename": "src/test/mir-opt/generator_storage_dead_unwind.main-{closure#0}.StateTransform.before.mir", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/src%2Ftest%2Fmir-opt%2Fgenerator_storage_dead_unwind.main-%7Bclosure%230%7D.StateTransform.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/src%2Ftest%2Fmir-opt%2Fgenerator_storage_dead_unwind.main-%7Bclosure%230%7D.StateTransform.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator_storage_dead_unwind.main-%7Bclosure%230%7D.StateTransform.before.mir?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -21,15 +21,13 @@ yields ()\n \n     bb0: {\n         StorageLive(_3);                 // scope 0 at $DIR/generator-storage-dead-unwind.rs:23:13: 23:14\n-        Deinit(_3);                      // scope 0 at $DIR/generator-storage-dead-unwind.rs:23:17: 23:23\n-        (_3.0: i32) = const 5_i32;       // scope 0 at $DIR/generator-storage-dead-unwind.rs:23:17: 23:23\n+        _3 = Foo(const 5_i32);           // scope 0 at $DIR/generator-storage-dead-unwind.rs:23:17: 23:23\n         StorageLive(_4);                 // scope 1 at $DIR/generator-storage-dead-unwind.rs:24:13: 24:14\n-        Deinit(_4);                      // scope 1 at $DIR/generator-storage-dead-unwind.rs:24:17: 24:23\n-        (_4.0: i32) = const 6_i32;       // scope 1 at $DIR/generator-storage-dead-unwind.rs:24:17: 24:23\n+        _4 = Bar(const 6_i32);           // scope 1 at $DIR/generator-storage-dead-unwind.rs:24:17: 24:23\n         StorageLive(_5);                 // scope 2 at $DIR/generator-storage-dead-unwind.rs:25:9: 25:14\n         StorageLive(_6);                 // scope 2 at $DIR/generator-storage-dead-unwind.rs:25:9: 25:14\n-        Deinit(_6);                      // scope 2 at $DIR/generator-storage-dead-unwind.rs:25:9: 25:14\n-        _5 = yield(move _6) -> [resume: bb1, drop: bb5]; // scope 2 at $DIR/generator-storage-dead-unwind.rs:25:9: 25:14\n+        _6 = ();                         // scope 2 at $DIR/generator-storage-dead-unwind.rs:25:9: 25:14\n+        _5 = yield(move _6) -> [resume: bb1, drop: bb6]; // scope 2 at $DIR/generator-storage-dead-unwind.rs:25:9: 25:14\n     }\n \n     bb1: {\n@@ -38,7 +36,7 @@ yields ()\n         StorageLive(_7);                 // scope 2 at $DIR/generator-storage-dead-unwind.rs:26:9: 26:16\n         StorageLive(_8);                 // scope 2 at $DIR/generator-storage-dead-unwind.rs:26:14: 26:15\n         _8 = move _3;                    // scope 2 at $DIR/generator-storage-dead-unwind.rs:26:14: 26:15\n-        _7 = take::<Foo>(move _8) -> [return: bb2, unwind: bb9]; // scope 2 at $DIR/generator-storage-dead-unwind.rs:26:9: 26:16\n+        _7 = take::<Foo>(move _8) -> [return: bb2, unwind: bb10]; // scope 2 at $DIR/generator-storage-dead-unwind.rs:26:9: 26:16\n                                          // mir::Constant\n                                          // + span: $DIR/generator-storage-dead-unwind.rs:26:9: 26:13\n                                          // + literal: Const { ty: fn(Foo) {take::<Foo>}, val: Value(<ZST>) }\n@@ -50,7 +48,7 @@ yields ()\n         StorageLive(_9);                 // scope 2 at $DIR/generator-storage-dead-unwind.rs:27:9: 27:16\n         StorageLive(_10);                // scope 2 at $DIR/generator-storage-dead-unwind.rs:27:14: 27:15\n         _10 = move _4;                   // scope 2 at $DIR/generator-storage-dead-unwind.rs:27:14: 27:15\n-        _9 = take::<Bar>(move _10) -> [return: bb3, unwind: bb8]; // scope 2 at $DIR/generator-storage-dead-unwind.rs:27:9: 27:16\n+        _9 = take::<Bar>(move _10) -> [return: bb3, unwind: bb9]; // scope 2 at $DIR/generator-storage-dead-unwind.rs:27:9: 27:16\n                                          // mir::Constant\n                                          // + span: $DIR/generator-storage-dead-unwind.rs:27:9: 27:13\n                                          // + literal: Const { ty: fn(Bar) {take::<Bar>}, val: Value(<ZST>) }\n@@ -61,54 +59,66 @@ yields ()\n         StorageDead(_9);                 // scope 2 at $DIR/generator-storage-dead-unwind.rs:27:16: 27:17\n         _0 = const ();                   // scope 0 at $DIR/generator-storage-dead-unwind.rs:22:19: 28:6\n         StorageDead(_4);                 // scope 1 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n-        StorageDead(_3);                 // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n-        drop(_1) -> [return: bb4, unwind: bb11]; // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n+        goto -> bb4;                     // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n     }\n \n     bb4: {\n-        return;                          // scope 0 at $DIR/generator-storage-dead-unwind.rs:+0:18: +0:18\n+        StorageDead(_3);                 // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n+        drop(_1) -> [return: bb5, unwind: bb14]; // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n     }\n \n     bb5: {\n+        return;                          // scope 0 at $DIR/generator-storage-dead-unwind.rs:+0:18: +0:18\n+    }\n+\n+    bb6: {\n         StorageDead(_6);                 // scope 2 at $DIR/generator-storage-dead-unwind.rs:25:13: 25:14\n         StorageDead(_5);                 // scope 2 at $DIR/generator-storage-dead-unwind.rs:25:14: 25:15\n         StorageDead(_4);                 // scope 1 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n-        drop(_3) -> [return: bb6, unwind: bb12]; // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n+        drop(_3) -> [return: bb7, unwind: bb15]; // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n     }\n \n-    bb6: {\n+    bb7: {\n         StorageDead(_3);                 // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n-        drop(_1) -> [return: bb7, unwind: bb11]; // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n+        drop(_1) -> [return: bb8, unwind: bb14]; // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n     }\n \n-    bb7: {\n+    bb8: {\n         generator_drop;                  // scope 0 at $DIR/generator-storage-dead-unwind.rs:+0:16: +0:18\n     }\n \n-    bb8 (cleanup): {\n+    bb9 (cleanup): {\n         StorageDead(_10);                // scope 2 at $DIR/generator-storage-dead-unwind.rs:27:15: 27:16\n         StorageDead(_9);                 // scope 2 at $DIR/generator-storage-dead-unwind.rs:27:16: 27:17\n-        goto -> bb10;                    // scope 2 at no-location\n+        goto -> bb12;                    // scope 2 at no-location\n     }\n \n-    bb9 (cleanup): {\n+    bb10 (cleanup): {\n+        goto -> bb11;                    // scope 2 at $DIR/generator-storage-dead-unwind.rs:26:15: 26:16\n+    }\n+\n+    bb11 (cleanup): {\n         StorageDead(_8);                 // scope 2 at $DIR/generator-storage-dead-unwind.rs:26:15: 26:16\n         StorageDead(_7);                 // scope 2 at $DIR/generator-storage-dead-unwind.rs:26:16: 26:17\n-        goto -> bb10;                    // scope 2 at no-location\n+        goto -> bb12;                    // scope 2 at no-location\n     }\n \n-    bb10 (cleanup): {\n+    bb12 (cleanup): {\n         StorageDead(_4);                 // scope 1 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n+        goto -> bb13;                    // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n+    }\n+\n+    bb13 (cleanup): {\n         StorageDead(_3);                 // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n-        drop(_1) -> bb11;                // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n+        drop(_1) -> bb14;                // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n     }\n \n-    bb11 (cleanup): {\n+    bb14 (cleanup): {\n         resume;                          // scope 0 at $DIR/generator-storage-dead-unwind.rs:+0:16: +0:18\n     }\n \n-    bb12 (cleanup): {\n+    bb15 (cleanup): {\n         StorageDead(_3);                 // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n-        drop(_1) -> bb11;                // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n+        drop(_1) -> bb14;                // scope 0 at $DIR/generator-storage-dead-unwind.rs:28:5: 28:6\n     }\n }"}, {"sha": "927f10242d2fee913e8ebecac4c0e3a43e47b19e", "filename": "src/test/mir-opt/generator_tiny.main-{closure#0}.generator_resume.0.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/src%2Ftest%2Fmir-opt%2Fgenerator_tiny.main-%7Bclosure%230%7D.generator_resume.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/src%2Ftest%2Fmir-opt%2Fgenerator_tiny.main-%7Bclosure%230%7D.generator_resume.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator_tiny.main-%7Bclosure%230%7D.generator_resume.0.mir?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -38,15 +38,15 @@ fn main::{closure#0}(_1: Pin<&mut [generator@$DIR/generator-tiny.rs:19:16: 19:24\n     bb1: {\n         _10 = move _2;                   // scope 0 at $DIR/generator-tiny.rs:+0:16: +0:24\n         nop;                             // scope 0 at $DIR/generator-tiny.rs:20:13: 20:15\n-        Deinit((((*(_1.0: &mut [generator@$DIR/generator-tiny.rs:19:16: 19:24])) as variant#3).0: HasDrop)); // scope 0 at $DIR/generator-tiny.rs:20:18: 20:25\n+        (((*(_1.0: &mut [generator@$DIR/generator-tiny.rs:19:16: 19:24])) as variant#3).0: HasDrop) = HasDrop; // scope 0 at $DIR/generator-tiny.rs:20:18: 20:25\n         StorageLive(_4);                 // scope 1 at $DIR/generator-tiny.rs:21:9: 24:10\n         goto -> bb2;                     // scope 1 at $DIR/generator-tiny.rs:21:9: 24:10\n     }\n \n     bb2: {\n         StorageLive(_6);                 // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n         StorageLive(_7);                 // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n-        Deinit(_7);                      // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n+        _7 = ();                         // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n         Deinit(_0);                      // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n         ((_0 as Yielded).0: ()) = move _7; // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18\n         discriminant(_0) = 0;            // scope 1 at $DIR/generator-tiny.rs:22:13: 22:18"}, {"sha": "f9ed1036f0060ef1680f5da15f96c57132cf4355", "filename": "src/test/mir-opt/packed_struct_drop_aligned.main.SimplifyCfg-elaborate-drops.after.32bit.mir", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/src%2Ftest%2Fmir-opt%2Fpacked_struct_drop_aligned.main.SimplifyCfg-elaborate-drops.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/src%2Ftest%2Fmir-opt%2Fpacked_struct_drop_aligned.main.SimplifyCfg-elaborate-drops.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fpacked_struct_drop_aligned.main.SimplifyCfg-elaborate-drops.after.32bit.mir?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -16,15 +16,20 @@ fn main() -> () {\n         StorageLive(_1);                 // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:9: +1:14\n         StorageLive(_2);                 // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:24: +1:42\n         StorageLive(_3);                 // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:32: +1:41\n-        _3 = Droppy(const 0_usize);      // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:32: +1:41\n-        _2 = Aligned(move _3);           // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:24: +1:42\n+        Deinit(_3);                      // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:32: +1:41\n+        (_3.0: usize) = const 0_usize;   // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:32: +1:41\n+        Deinit(_2);                      // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:24: +1:42\n+        (_2.0: Droppy) = move _3;        // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:24: +1:42\n         StorageDead(_3);                 // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:41: +1:42\n-        _1 = Packed(move _2);            // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:17: +1:43\n+        Deinit(_1);                      // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:17: +1:43\n+        (_1.0: Aligned) = move _2;       // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:17: +1:43\n         StorageDead(_2);                 // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:42: +1:43\n         StorageLive(_4);                 // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:11: +2:29\n         StorageLive(_5);                 // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:19: +2:28\n-        _5 = Droppy(const 0_usize);      // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:19: +2:28\n-        _4 = Aligned(move _5);           // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:11: +2:29\n+        Deinit(_5);                      // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:19: +2:28\n+        (_5.0: usize) = const 0_usize;   // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:19: +2:28\n+        Deinit(_4);                      // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:11: +2:29\n+        (_4.0: Droppy) = move _5;        // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:11: +2:29\n         StorageDead(_5);                 // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:28: +2:29\n         StorageLive(_6);                 // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:5: +2:8\n         _6 = move (_1.0: Aligned);       // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:5: +2:8"}, {"sha": "f9ed1036f0060ef1680f5da15f96c57132cf4355", "filename": "src/test/mir-opt/packed_struct_drop_aligned.main.SimplifyCfg-elaborate-drops.after.64bit.mir", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/src%2Ftest%2Fmir-opt%2Fpacked_struct_drop_aligned.main.SimplifyCfg-elaborate-drops.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/src%2Ftest%2Fmir-opt%2Fpacked_struct_drop_aligned.main.SimplifyCfg-elaborate-drops.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fpacked_struct_drop_aligned.main.SimplifyCfg-elaborate-drops.after.64bit.mir?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -16,15 +16,20 @@ fn main() -> () {\n         StorageLive(_1);                 // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:9: +1:14\n         StorageLive(_2);                 // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:24: +1:42\n         StorageLive(_3);                 // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:32: +1:41\n-        _3 = Droppy(const 0_usize);      // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:32: +1:41\n-        _2 = Aligned(move _3);           // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:24: +1:42\n+        Deinit(_3);                      // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:32: +1:41\n+        (_3.0: usize) = const 0_usize;   // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:32: +1:41\n+        Deinit(_2);                      // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:24: +1:42\n+        (_2.0: Droppy) = move _3;        // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:24: +1:42\n         StorageDead(_3);                 // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:41: +1:42\n-        _1 = Packed(move _2);            // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:17: +1:43\n+        Deinit(_1);                      // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:17: +1:43\n+        (_1.0: Aligned) = move _2;       // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:17: +1:43\n         StorageDead(_2);                 // scope 0 at $DIR/packed-struct-drop-aligned.rs:+1:42: +1:43\n         StorageLive(_4);                 // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:11: +2:29\n         StorageLive(_5);                 // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:19: +2:28\n-        _5 = Droppy(const 0_usize);      // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:19: +2:28\n-        _4 = Aligned(move _5);           // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:11: +2:29\n+        Deinit(_5);                      // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:19: +2:28\n+        (_5.0: usize) = const 0_usize;   // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:19: +2:28\n+        Deinit(_4);                      // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:11: +2:29\n+        (_4.0: Droppy) = move _5;        // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:11: +2:29\n         StorageDead(_5);                 // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:28: +2:29\n         StorageLive(_6);                 // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:5: +2:8\n         _6 = move (_1.0: Aligned);       // scope 1 at $DIR/packed-struct-drop-aligned.rs:+2:5: +2:8"}, {"sha": "8ea61533d073d22b04e9b0ffd3f8e0586d5a0439", "filename": "src/test/mir-opt/retag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -128,7 +128,9 @@ fn array_casts() -> () {\n         Retag(_35);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _18 = &(*_35);                   // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Retag(_18);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        _13 = (move _14, move _18);      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        Deinit(_13);                     // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        (_13.0: &usize) = move _14;      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        (_13.1: &usize) = move _18;      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Retag(_13);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageDead(_18);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageDead(_14);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n@@ -154,7 +156,8 @@ fn array_casts() -> () {\n \n     bb3: {\n         StorageLive(_27);                // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        _27 = core::panicking::AssertKind::Eq; // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        Deinit(_27);                     // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        discriminant(_27) = 0;           // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_28);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_29);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _29 = move _27;                  // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n@@ -171,7 +174,8 @@ fn array_casts() -> () {\n         _32 = &(*_33);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Retag(_32);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_34);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        _34 = Option::<Arguments>::None; // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        Deinit(_34);                     // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        discriminant(_34) = 0;           // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Retag(_34);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _28 = core::panicking::assert_failed::<usize, usize>(move _29, move _30, move _32, move _34); // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                          // mir::Constant"}, {"sha": "e4a06554f1a6b2b17228d75ee140f62e4c584cfb", "filename": "src/test/mir-opt/retag.main.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f07d6e8c0a90a6b03dcf96366d0462c7c25962bd/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir?ref=f07d6e8c0a90a6b03dcf96366d0462c7c25962bd", "patch": "@@ -62,7 +62,8 @@ fn main() -> () {\n         StorageLive(_3);                 // scope 1 at $DIR/retag.rs:+3:13: +3:14\n         StorageLive(_4);                 // scope 1 at $DIR/retag.rs:+3:17: +3:36\n         StorageLive(_5);                 // scope 1 at $DIR/retag.rs:+3:17: +3:24\n-        _5 = Test(const 0_i32);          // scope 1 at $DIR/retag.rs:+3:17: +3:24\n+        Deinit(_5);                      // scope 1 at $DIR/retag.rs:+3:17: +3:24\n+        (_5.0: i32) = const 0_i32;       // scope 1 at $DIR/retag.rs:+3:17: +3:24\n         _4 = &_5;                        // scope 1 at $DIR/retag.rs:+3:17: +3:36\n         Retag(_4);                       // scope 1 at $DIR/retag.rs:+3:17: +3:36\n         StorageLive(_6);                 // scope 1 at $DIR/retag.rs:+3:29: +3:35\n@@ -111,14 +112,7 @@ fn main() -> () {\n         StorageDead(_2);                 // scope 1 at $DIR/retag.rs:+8:5: +8:6\n         StorageLive(_13);                // scope 1 at $DIR/retag.rs:+11:9: +11:10\n         StorageLive(_14);                // scope 1 at $DIR/retag.rs:+11:31: +14:6\n-        _14 = [closure@main::{closure#0}]; // scope 1 at $DIR/retag.rs:+11:31: +14:6\n-                                         // closure\n-                                         // + def_id: DefId(0:14 ~ retag[4622]::main::{closure#0})\n-                                         // + substs: [\n-                                         //     i8,\n-                                         //     for<'r> extern \"rust-call\" fn((&'r i32,)) -> &'r i32,\n-                                         //     (),\n-                                         // ]\n+        Deinit(_14);                     // scope 1 at $DIR/retag.rs:+11:31: +14:6\n         Retag(_14);                      // scope 1 at $DIR/retag.rs:+11:31: +14:6\n         _13 = move _14 as for<'r> fn(&'r i32) -> &'r i32 (Pointer(ClosureFnPointer(Normal))); // scope 1 at $DIR/retag.rs:+11:31: +14:6\n         StorageDead(_14);                // scope 1 at $DIR/retag.rs:+11:47: +11:48\n@@ -142,7 +136,8 @@ fn main() -> () {\n         StorageLive(_19);                // scope 7 at $DIR/retag.rs:+18:5: +18:24\n         StorageLive(_20);                // scope 7 at $DIR/retag.rs:+18:5: +18:24\n         StorageLive(_21);                // scope 7 at $DIR/retag.rs:+18:5: +18:12\n-        _21 = Test(const 0_i32);         // scope 7 at $DIR/retag.rs:+18:5: +18:12\n+        Deinit(_21);                     // scope 7 at $DIR/retag.rs:+18:5: +18:12\n+        (_21.0: i32) = const 0_i32;      // scope 7 at $DIR/retag.rs:+18:5: +18:12\n         _20 = &_21;                      // scope 7 at $DIR/retag.rs:+18:5: +18:24\n         Retag(_20);                      // scope 7 at $DIR/retag.rs:+18:5: +18:24\n         StorageLive(_22);                // scope 7 at $DIR/retag.rs:+18:21: +18:23"}]}