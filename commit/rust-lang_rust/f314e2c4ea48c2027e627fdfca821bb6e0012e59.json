{"sha": "f314e2c4ea48c2027e627fdfca821bb6e0012e59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMTRlMmM0ZWE0OGMyMDI3ZTYyN2ZkZmNhODIxYmI2ZTAwMTJlNTk=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-01-01T03:48:39Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-01-06T02:21:13Z"}, "message": "creader: Load parts of plugin metadata on demand", "tree": {"sha": "26d83d97f04f460583535c604b78b4c7515c4105", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26d83d97f04f460583535c604b78b4c7515c4105"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f314e2c4ea48c2027e627fdfca821bb6e0012e59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f314e2c4ea48c2027e627fdfca821bb6e0012e59", "html_url": "https://github.com/rust-lang/rust/commit/f314e2c4ea48c2027e627fdfca821bb6e0012e59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f314e2c4ea48c2027e627fdfca821bb6e0012e59/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "677b7cad3d0ca1347f65ae9b409078343a5f302e", "url": "https://api.github.com/repos/rust-lang/rust/commits/677b7cad3d0ca1347f65ae9b409078343a5f302e", "html_url": "https://github.com/rust-lang/rust/commit/677b7cad3d0ca1347f65ae9b409078343a5f302e"}], "stats": {"total": 207, "additions": 125, "deletions": 82}, "files": [{"sha": "34e7200806612feed249bae9d374a2cf7504984f", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 98, "deletions": 50, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/f314e2c4ea48c2027e627fdfca821bb6e0012e59/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f314e2c4ea48c2027e627fdfca821bb6e0012e59/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=f314e2c4ea48c2027e627fdfca821bb6e0012e59", "patch": "@@ -16,11 +16,10 @@ use back::svh::Svh;\n use session::{config, Session};\n use session::search_paths::PathKind;\n use metadata::cstore;\n-use metadata::cstore::{CStore, CrateSource};\n+use metadata::cstore::{CStore, CrateSource, MetadataBlob};\n use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n-use plugin::load::PluginMetadata;\n use util::nodemap::FnvHashMap;\n \n use std::rc::Rc;\n@@ -154,6 +153,29 @@ fn register_native_lib(sess: &Session,\n     sess.cstore.add_used_library(name, kind);\n }\n \n+pub struct PluginMetadata<'a> {\n+    sess: &'a Session,\n+    metadata: PMDSource,\n+    dylib: Option<Path>,\n+    info: CrateInfo,\n+    vi_span: Span,\n+    target_only: bool,\n+}\n+\n+enum PMDSource {\n+    Registered(Rc<cstore::crate_metadata>),\n+    Owned(MetadataBlob),\n+}\n+\n+impl PMDSource {\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n+        match *self {\n+            PMDSource::Registered(ref cmd) => cmd.data(),\n+            PMDSource::Owned(ref mdb) => mdb.as_slice(),\n+        }\n+    }\n+}\n+\n impl<'a> CrateReader<'a> {\n     pub fn new(sess: &'a Session) -> CrateReader<'a> {\n         CrateReader {\n@@ -450,17 +472,20 @@ impl<'a> CrateReader<'a> {\n         }).collect()\n     }\n \n-    pub fn read_plugin_metadata(&mut self,\n-                                krate: &ast::ViewItem) -> PluginMetadata {\n-        let info = self.extract_crate_info(krate).unwrap();\n+    pub fn read_plugin_metadata<'b>(&'b mut self,\n+                                    vi: &'b ast::ViewItem) -> PluginMetadata<'b> {\n+        let info = self.extract_crate_info(vi).unwrap();\n         let target_triple = self.sess.opts.target_triple[];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n+        let mut target_only = false;\n+        let ident = info.ident.clone();\n+        let name = info.name.clone();\n         let mut load_ctxt = loader::Context {\n             sess: self.sess,\n-            span: krate.span,\n-            ident: info.ident[],\n-            crate_name: info.name[],\n+            span: vi.span,\n+            ident: ident[],\n+            crate_name: name[],\n             hash: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             triple: config::host_triple(),\n@@ -472,32 +497,49 @@ impl<'a> CrateReader<'a> {\n         let library = match load_ctxt.maybe_load_library_crate() {\n             Some(l) => l,\n             None if is_cross => {\n-                // try loading from target crates (only valid if there are\n-                // no syntax extensions)\n+                // Try loading from target crates. This will abort later if we try to\n+                // load a plugin registrar function,\n+                target_only = true;\n+                should_link = info.should_link;\n+\n                 load_ctxt.triple = target_triple;\n                 load_ctxt.filesearch = self.sess.target_filesearch(PathKind::Crate);\n-                let lib = load_ctxt.load_library_crate();\n-                if decoder::get_plugin_registrar_fn(lib.metadata.as_slice()).is_some() {\n-                    let message = format!(\"crate `{}` contains a plugin_registrar fn but \\\n-                                           only a version for triple `{}` could be found (need {})\",\n-                                           info.ident, target_triple, config::host_triple());\n-                    self.sess.span_err(krate.span, message[]);\n-                    // need to abort now because the syntax expansion\n-                    // code will shortly attempt to load and execute\n-                    // code from the found library.\n-                    self.sess.abort_if_errors();\n-                }\n-                should_link = info.should_link;\n-                lib\n+                load_ctxt.load_library_crate()\n             }\n             None => { load_ctxt.report_load_errs(); unreachable!() },\n         };\n \n-        // Read exported macros\n-        let imported_from = Some(token::intern(info.ident[]).ident());\n-        let source_name = format!(\"<{} macros>\", info.ident[]);\n+        let dylib = library.dylib.clone();\n+        let register = should_link && self.existing_match(info.name[], None).is_none();\n+        let metadata = if register {\n+            // Register crate now to avoid double-reading metadata\n+            let (_, cmd, _) = self.register_crate(&None, info.ident[],\n+                                info.name[], vi.span, library);\n+            PMDSource::Registered(cmd)\n+        } else {\n+            // Not registering the crate; just hold on to the metadata\n+            PMDSource::Owned(library.metadata)\n+        };\n+\n+        PluginMetadata {\n+            sess: self.sess,\n+            metadata: metadata,\n+            dylib: dylib,\n+            info: info,\n+            vi_span: vi.span,\n+            target_only: target_only,\n+        }\n+    }\n+}\n+\n+impl<'a> PluginMetadata<'a> {\n+    /// Read exported macros\n+    pub fn exported_macros(&self) -> Vec<ast::MacroDef> {\n+        let imported_from = Some(token::intern(self.info.ident[]).ident());\n+        let source_name = format!(\"<{} macros>\", self.info.ident[]);\n         let mut macros = vec![];\n-        decoder::each_exported_macro(library.metadata.as_slice(), &*self.sess.cstore.intr,\n+        decoder::each_exported_macro(self.metadata.as_slice(),\n+                                     &*self.sess.cstore.intr,\n             |name, attrs, body| {\n                 // NB: Don't use parse::parse_tts_from_source_str because it parses with\n                 // quote_depth > 0.\n@@ -520,31 +562,37 @@ impl<'a> CrateReader<'a> {\n                 true\n             }\n         );\n+        macros\n+    }\n \n-        // Look for a plugin registrar\n-        let registrar = decoder::get_plugin_registrar_fn(library.metadata.as_slice()).map(|id| {\n-            decoder::get_symbol(library.metadata.as_slice(), id)\n-        });\n-        if library.dylib.is_none() && registrar.is_some() {\n-            let message = format!(\"plugin crate `{}` only found in rlib format, \\\n-                                   but must be available in dylib format\",\n-                                   info.ident);\n-            self.sess.span_err(krate.span, message[]);\n-            // No need to abort because the loading code will just ignore this\n-            // empty dylib.\n+    /// Look for a plugin registrar. Returns library path and symbol name.\n+    pub fn plugin_registrar(&self) -> Option<(Path, String)> {\n+        if self.target_only {\n+            // Need to abort before syntax expansion.\n+            let message = format!(\"plugin crate `{}` is not available for triple `{}` \\\n+                                   (only found {})\",\n+                                  self.info.ident,\n+                                  config::host_triple(),\n+                                  self.sess.opts.target_triple);\n+            self.sess.span_err(self.vi_span, message[]);\n+            self.sess.abort_if_errors();\n         }\n-        let pc = PluginMetadata {\n-            macros: macros,\n-            registrar: match (library.dylib.as_ref(), registrar) {\n-                (Some(dylib), Some(reg)) => Some((dylib.clone(), reg)),\n-                _ => None,\n-            },\n-        };\n-        if should_link && self.existing_match(info.name[], None).is_none() {\n-            // register crate now to avoid double-reading metadata\n-            self.register_crate(&None, info.ident[],\n-                                info.name[], krate.span, library);\n+\n+        let registrar = decoder::get_plugin_registrar_fn(self.metadata.as_slice())\n+            .map(|id| decoder::get_symbol(self.metadata.as_slice(), id));\n+\n+        match (self.dylib.as_ref(), registrar) {\n+            (Some(dylib), Some(reg)) => Some((dylib.clone(), reg)),\n+            (None, Some(_)) => {\n+                let message = format!(\"plugin crate `{}` only found in rlib format, \\\n+                                       but must be available in dylib format\",\n+                                       self.info.ident);\n+                self.sess.span_err(self.vi_span, message[]);\n+                // No need to abort because the loading code will just ignore this\n+                // empty dylib.\n+                None\n+            }\n+            _ => None,\n         }\n-        pc\n     }\n }"}, {"sha": "78730defc7fd60d6797f6e4cc38dfbaca4ff8240", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f314e2c4ea48c2027e627fdfca821bb6e0012e59/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f314e2c4ea48c2027e627fdfca821bb6e0012e59/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=f314e2c4ea48c2027e627fdfca821bb6e0012e59", "patch": "@@ -23,14 +23,6 @@ use syntax::visit;\n use syntax::visit::Visitor;\n use syntax::attr::AttrMetaMethods;\n \n-/// Metadata for a single plugin crate.\n-pub struct PluginMetadata {\n-    /// Macros exported by the crate.\n-    pub macros: Vec<ast::MacroDef>,\n-    /// Path to the shared library file, and registrar function symbol.\n-    pub registrar: Option<(Path, String)>,\n-}\n-\n /// Pointer to a registrar function.\n pub type PluginRegistrarFun =\n     fn(&mut Registry);\n@@ -86,37 +78,40 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n // note that macros aren't expanded yet, and therefore macros can't add plugins.\n impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n     fn visit_view_item(&mut self, vi: &ast::ViewItem) {\n+        // We're only interested in `extern crate`.\n         match vi.node {\n-            ast::ViewItemExternCrate(_, _, _) => {\n-                let mut plugin_phase = false;\n-\n-                for attr in vi.attrs.iter().filter(|a| a.check_name(\"phase\")) {\n-                    let phases = attr.meta_item_list().unwrap_or(&[]);\n-                    if attr::contains_name(phases, \"plugin\") {\n-                        plugin_phase = true;\n-                    }\n-                    if attr::contains_name(phases, \"syntax\") {\n-                        plugin_phase = true;\n-                        self.sess.span_warn(attr.span,\n-                            \"phase(syntax) is a deprecated synonym for phase(plugin)\");\n-                    }\n-                }\n+            ast::ViewItemExternCrate(..) => (),\n+            _ => return,\n+        }\n \n-                if !plugin_phase { return; }\n+        let mut plugin_phase = false;\n+        for attr in vi.attrs.iter().filter(|a| a.check_name(\"phase\")) {\n+            let phases = attr.meta_item_list().unwrap_or(&[]);\n+            if attr::contains_name(phases, \"plugin\") {\n+                plugin_phase = true;\n+            }\n+            if attr::contains_name(phases, \"syntax\") {\n+                plugin_phase = true;\n+                self.sess.span_warn(attr.span,\n+                    \"phase(syntax) is a deprecated synonym for phase(plugin)\");\n+            }\n+        }\n \n-                let PluginMetadata { macros, registrar } =\n-                    self.reader.read_plugin_metadata(vi);\n+        let mut macros = vec![];\n+        let mut registrar = None;\n \n-                self.plugins.macros.extend(macros.into_iter());\n+        if plugin_phase {\n+            let pmd = self.reader.read_plugin_metadata(vi);\n+            macros = pmd.exported_macros();\n+            registrar = pmd.plugin_registrar();\n+        }\n \n-                match registrar {\n-                    Some((lib, symbol)) => self.dylink_registrar(vi, lib, symbol),\n-                    _ => (),\n-                }\n-            }\n-            _ => (),\n+        self.plugins.macros.extend(macros.into_iter());\n+        if let Some((lib, symbol)) = registrar {\n+            self.dylink_registrar(vi, lib, symbol);\n         }\n     }\n+\n     fn visit_mac(&mut self, _: &ast::Mac) {\n         // bummer... can't see plugins inside macros.\n         // do nothing."}]}