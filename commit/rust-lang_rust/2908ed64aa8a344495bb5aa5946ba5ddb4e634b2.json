{"sha": "2908ed64aa8a344495bb5aa5946ba5ddb4e634b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MDhlZDY0YWE4YTM0NDQ5NWJiNWFhNTk0NmJhNWRkYjRlNjM0YjI=", "commit": {"author": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2020-09-02T22:22:40Z"}, "committer": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2020-09-02T22:22:40Z"}, "message": "Use intra-doc links in `core::marker`", "tree": {"sha": "918270473d8035ed4c55589cf78e9ddb02fce856", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/918270473d8035ed4c55589cf78e9ddb02fce856"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2908ed64aa8a344495bb5aa5946ba5ddb4e634b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2908ed64aa8a344495bb5aa5946ba5ddb4e634b2", "html_url": "https://github.com/rust-lang/rust/commit/2908ed64aa8a344495bb5aa5946ba5ddb4e634b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2908ed64aa8a344495bb5aa5946ba5ddb4e634b2/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80fc9b0ecb29050d45b17c64af004200afd3cfc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/80fc9b0ecb29050d45b17c64af004200afd3cfc2", "html_url": "https://github.com/rust-lang/rust/commit/80fc9b0ecb29050d45b17c64af004200afd3cfc2"}], "stats": {"total": 61, "additions": 27, "deletions": 34}, "files": [{"sha": "6f4b6d0fd9cc2ad7a332f8d542908511bc2a4bb9", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2908ed64aa8a344495bb5aa5946ba5ddb4e634b2/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2908ed64aa8a344495bb5aa5946ba5ddb4e634b2/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=2908ed64aa8a344495bb5aa5946ba5ddb4e634b2", "patch": "@@ -111,13 +111,13 @@ pub trait Sized {\n ///   - `T` is not part of the type of any other fields\n ///   - `Bar<T>: Unsize<Bar<U>>`, if the last field of `Foo` has type `Bar<T>`\n ///\n-/// `Unsize` is used along with [`ops::CoerceUnsized`][coerceunsized] to allow\n-/// \"user-defined\" containers such as [`rc::Rc`][rc] to contain dynamically-sized\n+/// `Unsize` is used along with [`ops::CoerceUnsized`] to allow\n+/// \"user-defined\" containers such as [`Rc`] to contain dynamically-sized\n /// types. See the [DST coercion RFC][RFC982] and [the nomicon entry on coercion][nomicon-coerce]\n /// for more details.\n ///\n-/// [coerceunsized]: ../ops/trait.CoerceUnsized.html\n-/// [rc]: ../../std/rc/struct.Rc.html\n+/// [`ops::CoerceUnsized`]: crate::ops::CoerceUnsized\n+/// [`Rc`]: ../../std/rc/struct.Rc.html\n /// [RFC982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n /// [nomicon-coerce]: ../../nomicon/coercions.html\n #[unstable(feature = \"unsize\", issue = \"27732\")]\n@@ -368,11 +368,7 @@ pub trait StructuralEq {\n ///\n /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n /// [`String`]: ../../std/string/struct.String.html\n-/// [`Drop`]: ../../std/ops/trait.Drop.html\n-/// [`size_of::<T>`]: ../../std/mem/fn.size_of.html\n-/// [`Clone`]: ../clone/trait.Clone.html\n-/// [`String`]: ../../std/string/struct.String.html\n-/// [`i32`]: ../../std/primitive.i32.html\n+/// [`size_of::<T>`]: crate::mem::size_of\n /// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n@@ -400,18 +396,18 @@ pub macro Copy($item:item) {\n /// This trait is automatically implemented when the compiler determines\n /// it's appropriate.\n ///\n-/// The precise definition is: a type `T` is `Sync` if and only if `&T` is\n-/// [`Send`][send]. In other words, if there is no possibility of\n+/// The precise definition is: a type `T` is [`Sync`] if and only if `&T` is\n+/// [`Send`]. In other words, if there is no possibility of\n /// [undefined behavior][ub] (including data races) when passing\n /// `&T` references between threads.\n ///\n-/// As one would expect, primitive types like [`u8`][u8] and [`f64`][f64]\n-/// are all `Sync`, and so are simple aggregate types containing them,\n-/// like tuples, structs and enums. More examples of basic `Sync`\n+/// As one would expect, primitive types like [`u8`] and [`f64`]\n+/// are all [`Sync`], and so are simple aggregate types containing them,\n+/// like tuples, structs and enums. More examples of basic [`Sync`]\n /// types include \"immutable\" types like `&T`, and those with simple\n /// inherited mutability, such as [`Box<T>`][box], [`Vec<T>`][vec] and\n-/// most other collection types. (Generic parameters need to be `Sync`\n-/// for their container to be `Sync`.)\n+/// most other collection types. (Generic parameters need to be [`Sync`]\n+/// for their container to be [`Sync`].)\n ///\n /// A somewhat surprising consequence of the definition is that `&mut T`\n /// is `Sync` (if `T` is `Sync`) even though it seems like that might\n@@ -421,48 +417,45 @@ pub macro Copy($item:item) {\n /// of a data race.\n ///\n /// Types that are not `Sync` are those that have \"interior\n-/// mutability\" in a non-thread-safe form, such as [`cell::Cell`][cell]\n-/// and [`cell::RefCell`][refcell]. These types allow for mutation of\n+/// mutability\" in a non-thread-safe form, such as [`Cell`][cell]\n+/// and [`RefCell`][refcell]. These types allow for mutation of\n /// their contents even through an immutable, shared reference. For\n /// example the `set` method on [`Cell<T>`][cell] takes `&self`, so it requires\n /// only a shared reference [`&Cell<T>`][cell]. The method performs no\n /// synchronization, thus [`Cell`][cell] cannot be `Sync`.\n ///\n /// Another example of a non-`Sync` type is the reference-counting\n-/// pointer [`rc::Rc`][rc]. Given any reference [`&Rc<T>`][rc], you can clone\n+/// pointer [`Rc`][rc]. Given any reference [`&Rc<T>`][rc], you can clone\n /// a new [`Rc<T>`][rc], modifying the reference counts in a non-atomic way.\n ///\n /// For cases when one does need thread-safe interior mutability,\n /// Rust provides [atomic data types], as well as explicit locking via\n /// [`sync::Mutex`][mutex] and [`sync::RwLock`][rwlock]. These types\n /// ensure that any mutation cannot cause data races, hence the types\n /// are `Sync`. Likewise, [`sync::Arc`][arc] provides a thread-safe\n-/// analogue of [`Rc`][rc].\n+/// analogue of [`Rc`].\n ///\n /// Any types with interior mutability must also use the\n /// [`cell::UnsafeCell`][unsafecell] wrapper around the value(s) which\n /// can be mutated through a shared reference. Failing to doing this is\n /// [undefined behavior][ub]. For example, [`transmute`][transmute]-ing\n /// from `&T` to `&mut T` is invalid.\n ///\n-/// See [the Nomicon](../../nomicon/send-and-sync.html) for more\n-/// details about `Sync`.\n+/// See [the Nomicon][nomicon-send-and-sync] for more details about `Sync`.\n ///\n-/// [send]: trait.Send.html\n-/// [u8]: ../../std/primitive.u8.html\n-/// [f64]: ../../std/primitive.f64.html\n /// [box]: ../../std/boxed/struct.Box.html\n /// [vec]: ../../std/vec/struct.Vec.html\n-/// [cell]: ../cell/struct.Cell.html\n-/// [refcell]: ../cell/struct.RefCell.html\n+/// [cell]: crate::cell::Cell\n+/// [refcell]: crate::cell::RefCell\n /// [rc]: ../../std/rc/struct.Rc.html\n /// [arc]: ../../std/sync/struct.Arc.html\n-/// [atomic data types]: ../sync/atomic/index.html\n+/// [atomic data types]: crate::sync::atomic\n /// [mutex]: ../../std/sync/struct.Mutex.html\n /// [rwlock]: ../../std/sync/struct.RwLock.html\n-/// [unsafecell]: ../cell/struct.UnsafeCell.html\n+/// [unsafecell]: crate::cell::UnsafeCell\n /// [ub]: ../../reference/behavior-considered-undefined.html\n-/// [transmute]: ../../std/mem/fn.transmute.html\n+/// [transmute]: crate::mem::transmute\n+/// [nomicon-send-and-sync]: ../../nomicon/send-and-sync.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"sync_trait\")]\n #[lang = \"sync\"]\n@@ -698,7 +691,7 @@ mod impls {\n /// guarantees to [`mem::Discriminant`]. It is **undefined behavior** to transmute\n /// between `DiscriminantKind::Discriminant` and `mem::Discriminant`.\n ///\n-/// [`mem::Discriminant`]: https://doc.rust-lang.org/stable/core/mem/struct.Discriminant.html\n+/// [`mem::Discriminant`]: crate::mem::Discriminant\n #[unstable(\n     feature = \"discriminant_kind\",\n     issue = \"none\",\n@@ -733,7 +726,7 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n ///\n /// The [`Pin`][Pin] type is used instead to prevent moves through the type\n /// system. Pointers `P<T>` wrapped in the [`Pin<P<T>>`][Pin] wrapper can't be\n-/// moved out of. See the [`pin module`] documentation for more information on\n+/// moved out of. See the [`pin` module] documentation for more information on\n /// pinning.\n ///\n /// Implementing the `Unpin` trait for `T` lifts the restrictions of pinning off\n@@ -764,9 +757,9 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n ///\n /// This trait is automatically implemented for almost every type.\n ///\n-/// [`mem::replace`]: ../../std/mem/fn.replace.html\n+/// [`mem::replace`]: crate::mem::replace\n /// [Pin]: crate::pin::Pin\n-/// [`pin module`]: crate::pin\n+/// [`pin` module]: crate::pin\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n #[rustc_on_unimplemented(\n     on(_Self = \"std::future::Future\", note = \"consider using `Box::pin`\",),"}]}