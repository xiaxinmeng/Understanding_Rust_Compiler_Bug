{"sha": "91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYTVhMWFiNGFkMDU0YzhkY2NmNDlmNmY0MDk1NDJmODI2ODNjZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-23T20:47:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-23T20:47:30Z"}, "message": "Auto merge of #22724 - Manishearth:rollup, r=alexcrichton\n\nSeems to pass `check-stage1`, but I had to tweak some things so it's going through the test gauntlet again.", "tree": {"sha": "1c2a90b8e1aac6793a0fbf6350778a5b9ac65dae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c2a90b8e1aac6793a0fbf6350778a5b9ac65dae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "html_url": "https://github.com/rust-lang/rust/commit/91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0f7ca27de6b4e03f30012656dad270cda55a363", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0f7ca27de6b4e03f30012656dad270cda55a363", "html_url": "https://github.com/rust-lang/rust/commit/f0f7ca27de6b4e03f30012656dad270cda55a363"}, {"sha": "ee6f2a1ad6ab79ed954cd96fff6eaddcdfb6a043", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee6f2a1ad6ab79ed954cd96fff6eaddcdfb6a043", "html_url": "https://github.com/rust-lang/rust/commit/ee6f2a1ad6ab79ed954cd96fff6eaddcdfb6a043"}], "stats": {"total": 2227, "additions": 1375, "deletions": 852}, "files": [{"sha": "c88c237cbee896985663697ed030b018393d8e89", "filename": "README.md", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -15,28 +15,34 @@ Read [\"Installing Rust\"] from [The Book].\n ## Building from Source\n \n 1. Make sure you have installed the dependencies:\n-    * `g++` 4.7 or `clang++` 3.x\n-    * `python` 2.6 or later (but not 3.x)\n-    * GNU `make` 3.81 or later\n-    * `curl`\n-    * `git`\n+\n+   * `g++` 4.7 or `clang++` 3.x\n+   * `python` 2.6 or later (but not 3.x)\n+   * GNU `make` 3.81 or later\n+   * `curl`\n+   * `git`\n \n 2. Clone the [source] with `git`:\n \n-        $ git clone https://github.com/rust-lang/rust.git\n-        $ cd rust\n+   ```sh\n+   $ git clone https://github.com/rust-lang/rust.git\n+   $ cd rust\n+   ```\n \n [source]: https://github.com/rust-lang/rust\n \n 3. Build and install:\n \n-        $ ./configure\n-        $ make && make install\n+    ```sh\n+    $ ./configure\n+    $ make && make install\n+    ```\n \n-    > ***Note:*** You may need to use `sudo make install` if you do not normally have\n-    > permission to modify the destination directory. The install locations can\n-    > be adjusted by passing a `--prefix` argument to `configure`. Various other\n-    > options are also supported, pass `--help` for more information on them.\n+    > ***Note:*** You may need to use `sudo make install` if you do not\n+    > normally have permission to modify the destination directory. The\n+    > install locations can be adjusted by passing a `--prefix` argument\n+    > to `configure`. Various other options are also supported \u2013 pass\n+    > `--help` for more information on them.\n \n     When complete, `make install` will place several programs into\n     `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n@@ -47,27 +53,30 @@ Read [\"Installing Rust\"] from [The Book].\n \n ### Building on Windows\n \n-To easily build on windows we can use [MSYS2](http://msys2.github.io/):\n+[MSYS2](http://msys2.github.io/) can be used to easily build Rust on Windows:\n \n 1. Grab the latest MSYS2 installer and go through the installer.\n-2. Now from the MSYS2 terminal we want to install the mingw64 toolchain and the other\n-   tools we need.\n \n-```bash\n-# choose one based on platform\n-$ pacman -S mingw-w64-i686-toolchain\n-$ pacman -S mingw-w64-x86_64-toolchain\n+2. From the MSYS2 terminal, install the `mingw64` toolchain and other required\n+   tools.\n+\n+   ```sh\n+   # Choose one based on platform:\n+   $ pacman -S mingw-w64-i686-toolchain\n+   $ pacman -S mingw-w64-x86_64-toolchain\n+   \n+   $ pacman -S base-devel\n+   ```\n \n-$ pacman -S base-devel\n-```\n+3. Run `mingw32_shell.bat` or `mingw64_shell.bat` from wherever you installed\n+   MYSY2 (i.e. `C:\\msys`), depending on whether you want 32-bit or 64-bit Rust.\n \n-3. With that now start `mingw32_shell.bat` or `mingw64_shell.bat`\n-   from where you installed MSYS2 (i.e. `C:\\msys`). Which one you\n-   choose depends on if you want 32 or 64 bit Rust.\n-4. From there just navigate to where you have Rust's source code, configure and build it:\n+4. Navigate to Rust's source code, configure and build it:\n \n-        $ ./configure\n-        $ make && make install\n+   ```sh\n+   $ ./configure\n+   $ make && make install\n+   ```\n \n ## Notes\n \n@@ -92,15 +101,15 @@ There is more advice about hacking on Rust in [CONTRIBUTING.md].\n \n [CONTRIBUTING.md]: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md\n \n-## Getting help\n+## Getting Help\n \n The Rust community congregates in a few places:\n \n-* [StackOverflow] - Direct questions about using the language here.\n-* [users.rust-lang.org] - General discussion, broader questions.\n+* [Stack Overflow] - Direct questions about using the language.\n+* [users.rust-lang.org] - General discussion and broader questions.\n * [/r/rust] - News and general discussion.\n \n-[StackOverflow]: http://stackoverflow.com/questions/tagged/rust\n+[Stack Overflow]: http://stackoverflow.com/questions/tagged/rust\n [/r/rust]: http://reddit.com/r/rust\n [users.rust-lang.org]: http://users.rust-lang.org/\n \n@@ -111,7 +120,7 @@ To contribute to Rust, please see [CONTRIBUTING.md](CONTRIBUTING.md).\n Rust has an [IRC] culture and most real-time collaboration happens in a\n variety of channels on Mozilla's IRC network, irc.mozilla.org. The\n most popular channel is [#rust], a venue for general discussion about\n-Rust, and a good place to ask for help,\n+Rust, and a good place to ask for help.\n \n [IRC]: https://en.wikipedia.org/wiki/Internet_Relay_Chat\n [#rust]: irc://irc.mozilla.org/rust"}, {"sha": "417e050c8b8b35e6d9ff0cf98322aa247de46c50", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -268,7 +268,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         logfile: config.logfile.clone(),\n         run_tests: true,\n         run_benchmarks: true,\n-        nocapture: false,\n+        nocapture: env::var(\"RUST_TEST_NOCAPTURE\").is_ok(),\n         color: test::AutoColor,\n     }\n }"}, {"sha": "e5570fe0b8fb0c84cd0dd0121e9f445f0c84f702", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::env;\n+\n use common::Config;\n use common;\n use util;\n@@ -125,6 +127,16 @@ pub fn load_props(testfile: &Path) -> TestProps {\n         true\n     });\n \n+    for key in vec![\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_TASKS\"] {\n+        match env::var(key) {\n+            Ok(val) =>\n+                if exec_env.iter().find(|&&(ref x, _)| *x == key.to_string()).is_none() {\n+                    exec_env.push((key.to_string(), val))\n+                },\n+            Err(..) => {}\n+        }\n+    }\n+\n     TestProps {\n         error_patterns: error_patterns,\n         compile_flags: compile_flags,"}, {"sha": "85bbd2cb42e6983ce121cefe047f9ce431dae786", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -89,7 +89,7 @@ fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let proc_res = compile_test(config, props, testfile);\n \n     if proc_res.status.success() {\n-        fatal_proc_rec(&format!(\"{} test compiled successfully!\", config.mode)[],\n+        fatal_proc_rec(&format!(\"{} test compiled successfully!\", config.mode)[..],\n                       &proc_res);\n     }\n \n@@ -398,7 +398,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             for line in breakpoint_lines.iter() {\n                 script_str.push_str(&format!(\"break {:?}:{}\\n\",\n                                              testfile.filename_display(),\n-                                             *line)[]);\n+                                             *line)[..]);\n             }\n             script_str.push_str(&cmds);\n             script_str.push_str(\"quit\\n\");\n@@ -553,17 +553,17 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             script_str.push_str(\"set print pretty off\\n\");\n \n             // Add the pretty printer directory to GDB's source-file search path\n-            script_str.push_str(&format!(\"directory {}\\n\", rust_pp_module_abs_path)[]);\n+            script_str.push_str(&format!(\"directory {}\\n\", rust_pp_module_abs_path)[..]);\n \n             // Load the target executable\n             script_str.push_str(&format!(\"file {}\\n\",\n-                                         exe_file.as_str().unwrap().replace(\"\\\\\", \"\\\\\\\\\"))[]);\n+                                         exe_file.as_str().unwrap().replace(\"\\\\\", \"\\\\\\\\\"))[..]);\n \n             // Add line breakpoints\n             for line in &breakpoint_lines {\n                 script_str.push_str(&format!(\"break '{}':{}\\n\",\n                                              testfile.filename_display(),\n-                                             *line)[]);\n+                                             *line)[..]);\n             }\n \n             script_str.push_str(&cmds);\n@@ -689,7 +689,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n                                                .unwrap()\n                                                .to_string();\n \n-    script_str.push_str(&format!(\"command script import {}\\n\", &rust_pp_module_abs_path[..])[]);\n+    script_str.push_str(&format!(\"command script import {}\\n\", &rust_pp_module_abs_path[..])[..]);\n     script_str.push_str(\"type summary add --no-value \");\n     script_str.push_str(\"--python-function lldb_rust_formatters.print_val \");\n     script_str.push_str(\"-x \\\".*\\\" --category Rust\\n\");"}, {"sha": "c9d834ee123bb55f6bce8e16dff8ef94ef89d8ba", "filename": "src/doc/intro.md", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -426,39 +426,33 @@ use std::thread::Thread;\n fn main() {\n     let mut numbers = vec![1, 2, 3];\n \n-    for i in 0..3 {\n-        Thread::spawn(move || {\n+    let guards: Vec<_> = (0..3).map(|i| {\n+        Thread::scoped(move || {\n             for j in 0..3 { numbers[j] += 1 }\n         });\n-    }\n+    }).collect();\n }\n ```\n \n It gives us this error:\n \n ```text\n-6:71 error: capture of moved value: `numbers`\n-    for j in 0..3 { numbers[j] += 1 }\n-                    ^~~~~~~\n-7:50 note: `numbers` moved into closure environment here\n-    spawn(move || {\n-        for j in 0..3 { numbers[j] += 1 }\n-    });\n-6:79 error: cannot assign to immutable dereference (dereference is implicit, due to indexing)\n-        for j in 0..3 { numbers[j] += 1 }\n-                        ^~~~~~~~~~~~~~~\n+7:29: 9:10 error: cannot move out of captured outer variable in an `FnMut` closure\n+7         Thread::scoped(move || {\n+8             for j in 0..3 { numbers[j] += 1 }\n+9         });\n ```\n \n-It mentions that \"numbers moved into closure environment\". Because we\n-declared the closure as a moving closure, and it referred to\n-`numbers`, the closure will try to take ownership of the vector. But\n-the closure itself is created in a loop, and hence we will actually\n-create three closures, one for every iteration of the loop. This means\n-that all three of those closures would try to own `numbers`, which is\n-impossible -- `numbers` must have just one owner. Rust detects this\n-and gives us the error: we claim that `numbers` has ownership, but our\n-code tries to make three owners. This may cause a safety problem, so\n-Rust disallows it.\n+It mentions that \"captured outer variable in an `FnMut` closure\".\n+Because we declared the closure as a moving closure, and it referred\n+to `numbers`, the closure will try to take ownership of the\n+vector. But the closure itself is created in a loop, and hence we will\n+actually create three closures, one for every iteration of the\n+loop. This means that all three of those closures would try to own\n+`numbers`, which is impossible -- `numbers` must have just one\n+owner. Rust detects this and gives us the error: we claim that\n+`numbers` has ownership, but our code tries to make three owners. This\n+may cause a safety problem, so Rust disallows it.\n \n What to do here? Rust has two types that helps us: `Arc<T>` and `Mutex<T>`.\n *Arc* stands for \"atomically reference counted\". In other words, an Arc will\n@@ -480,14 +474,14 @@ use std::sync::{Arc,Mutex};\n fn main() {\n     let numbers = Arc::new(Mutex::new(vec![1, 2, 3]));\n \n-    for i in 0..3 {\n+    let guards: Vec<_> = (0..3).map(|i| {\n         let number = numbers.clone();\n-        Thread::spawn(move || {\n+        Thread::scoped(move || {\n             let mut array = number.lock().unwrap();\n             array[i] += 1;\n             println!(\"numbers[{}] is {}\", i, array[i]);\n         });\n-    }\n+    }).collect();\n }\n ```\n \n@@ -516,8 +510,10 @@ numbers[1] is 3\n numbers[0] is 2\n ```\n \n-Each time, we get a slightly different output, because each thread works in a\n-different order. You may not get the same output as this sample, even.\n+Each time, we can get a slithtly different output because the threads\n+are not quaranteed to run in any set order. If you get the same order\n+every time it is because each of these threads are very small and\n+complete too fast for their indeterminate behavior to surface.\n \n The important part here is that the Rust compiler was able to use ownership to\n give us assurance _at compile time_ that we weren't doing something incorrect\n@@ -539,13 +535,13 @@ safety check that makes this an error about moved values:\n use std::thread::Thread;\n \n fn main() {\n-    let vec = vec![1, 2, 3];\n-\n-    for i in 0..3 {\n-        Thread::spawn(move || {\n-            println!(\"{}\", vec[i]);\n+    let numbers = vec![1, 2, 3];\n+    \n+    let guards: Vec<_> = (0..3).map(|i| {\n+        Thread::scoped(move || {\n+            println!(\"{}\", numbers[i]);\n         });\n-    }\n+    }).collect();\n }\n ```\n "}, {"sha": "357ff813fef3fcbea0297eb40eb0f0f82790124e", "filename": "src/doc/reference.md", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -515,6 +515,9 @@ This last example is different because it is not possible to use the suffix\n syntax with a floating point literal ending in a period. `2.f64` would attempt\n to call a method named `f64` on `2`.\n \n+The representation semantics of floating-point numbers are described in\n+[\"Machine Types\"](#machine-types).\n+\n #### Boolean literals\n \n The two values of the boolean type are written `true` and `false`.\n@@ -3554,7 +3557,8 @@ Tuple types and values are denoted by listing the types or values of their\n elements, respectively, in a parenthesized, comma-separated list.\n \n Because tuple elements don't have a name, they can only be accessed by\n-pattern-matching.\n+pattern-matching or by using `N` directly as a field to access the\n+`N`th element.\n \n An example of a tuple type and its use:\n \n@@ -3563,6 +3567,7 @@ type Pair<'a> = (i32, &'a str);\n let p: Pair<'static> = (10, \"hello\");\n let (a, b) = p;\n assert!(b != \"world\");\n+assert!(p.0 == 10);\n ```\n \n ### Array, and Slice types"}, {"sha": "f3c0195855c3436baecae176038888e748f96b96", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -12,7 +12,7 @@ Rust has two distinct terms that relate to the module system: *crate* and\n *module*. A crate is synonymous with a *library* or *package* in other\n languages. Hence \"Cargo\" as the name of Rust's package management tool: you\n ship your crates to others with Cargo. Crates can produce an executable or a\n-shared library, depending on the project.\n+library, depending on the project.\n \n Each crate has an implicit *root module* that contains the code for that crate.\n You can then define a tree of sub-modules under that root module. Modules allow"}, {"sha": "33dc1ba07ca86e63cd26fa2d8ce99d3d0e9f232c", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -57,14 +57,13 @@ for i in 0..nums.len() {\n }\n ```\n \n-This is strictly worse than using an actual iterator. The `.iter()` method on\n-vectors returns an iterator which iterates through a reference to each element\n-of the vector in turn. So write this:\n+This is strictly worse than using an actual iterator. You can iterate over vectors\n+directly, so write this:\n \n ```rust\n let nums = vec![1, 2, 3];\n \n-for num in nums.iter() {\n+for num in &nums {\n     println!(\"{}\", num);\n }\n ```\n@@ -86,16 +85,17 @@ see it. This code works fine too:\n ```rust\n let nums = vec![1, 2, 3];\n \n-for num in nums.iter() {\n+for num in &nums {\n     println!(\"{}\", *num);\n }\n ```\n \n-Now we're explicitly dereferencing `num`. Why does `iter()` give us references?\n-Well, if it gave us the data itself, we would have to be its owner, which would\n-involve making a copy of the data and giving us the copy. With references,\n-we're just borrowing a reference to the data, and so it's just passing\n-a reference, without needing to do the copy.\n+Now we're explicitly dereferencing `num`. Why does `&nums` give us\n+references?  Firstly, because we explicitly asked it to with\n+`&`. Secondly, if it gave us the data itself, we would have to be its\n+owner, which would involve making a copy of the data and giving us the\n+copy. With references, we're just borrowing a reference to the data,\n+and so it's just passing a reference, without needing to do the move.\n \n So, now that we've established that ranges are often not what you want, let's\n talk about what you do want instead.\n@@ -230,9 +230,9 @@ let nums = (1..100).collect::<Vec<i32>>();\n Now, `collect()` will require that the range gives it some numbers, and so\n it will do the work of generating the sequence.\n \n-Ranges are one of two basic iterators that you'll see. The other is `iter()`,\n-which you've used before. `iter()` can turn a vector into a simple iterator\n-that gives you each element in turn:\n+Ranges are one of two basic iterators that you'll see. The other is `iter()`.\n+`iter()` can turn a vector into a simple iterator that gives you each element\n+in turn:\n \n ```rust\n let nums = [1, 2, 3];"}, {"sha": "a2a558094e1963c8f4b0c46423f3f69ef0eea45e", "filename": "src/doc/trpl/more-strings.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -38,8 +38,9 @@ string literal or a `String`.\n \n # String\n \n-A `String` is a heap-allocated string. This string is growable, and is also\n-guaranteed to be UTF-8.\n+A `String` is a heap-allocated string. This string is growable, and is\n+also guaranteed to be UTF-8. `String`s are commonly created by\n+converting from a string slice using the `to_string` method.\n \n ```\n let mut s = \"Hello\".to_string();\n@@ -49,7 +50,7 @@ s.push_str(\", world.\");\n println!(\"{}\", s);\n ```\n \n-You can coerce a `String` into a `&str` by dereferencing it:\n+A reference to a `String` will automatically coerce to a string slice:\n \n ```\n fn takes_slice(slice: &str) {\n@@ -58,7 +59,7 @@ fn takes_slice(slice: &str) {\n \n fn main() {\n     let s = \"Hello\".to_string();\n-    takes_slice(&*s);\n+    takes_slice(&s);\n }\n ```\n "}, {"sha": "1baf41329f561356238a63a37251744dd13046b2", "filename": "src/doc/trpl/static-and-dynamic-dispatch.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -79,10 +79,11 @@ fn main() {\n }\n ```\n \n-This has some upsides: static dispatching of any method calls, allowing for\n-inlining and hence usually higher performance. It also has some downsides:\n-causing code bloat due to many copies of the same function existing in the\n-binary, one for each type.\n+This has a great upside: static dispatch allows function calls to be\n+inlined because the callee is known at compile time, and inlining is\n+the key to good optimization. Static dispatch is fast, but it comes at\n+a tradeoff: 'code bloat', due to many copies of the same function\n+existing in the binary, one for each type.\n \n Furthermore, compilers aren\u2019t perfect and may \u201coptimize\u201d code to become slower.\n For example, functions inlined too eagerly will bloat the instruction cache"}, {"sha": "2c2e6a8c7c5acdf8079163bf675163a0ea7aff84", "filename": "src/doc/trpl/strings.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Ftrpl%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fdoc%2Ftrpl%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstrings.md?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -25,8 +25,10 @@ compiled program, and exists for the entire duration it runs. The `string`\n binding is a reference to this statically allocated string. String slices\n have a fixed size, and cannot be mutated.\n \n-A `String`, on the other hand, is an in-memory string.  This string is\n-growable, and is also guaranteed to be UTF-8.\n+A `String`, on the other hand, is a heap-allocated string. This string\n+is growable, and is also guaranteed to be UTF-8. `String`s are\n+commonly created by converting from a string slice using the\n+`to_string` method.\n \n ```{rust}\n let mut s = \"Hello\".to_string(); // mut s: String"}, {"sha": "a93872dfe36bd8d522bd9fa3e56e10715f386605", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -105,15 +105,16 @@ impl<T : ?Sized> Box<T> {\n     /// After this function call, pointer is owned by resulting box.\n     /// In particular, it means that `Box` destructor calls destructor\n     /// of `T` and releases memory. Since the way `Box` allocates and\n-    /// releases memory is unspecified, so the only valid pointer to\n-    /// pass to this function is the one taken from another `Box` with\n-    /// `box::into_raw` function.\n+    /// releases memory is unspecified, the only valid pointer to pass\n+    /// to this function is the one taken from another `Box` with\n+    /// `boxed::into_raw` function.\n     ///\n     /// Function is unsafe, because improper use of this function may\n     /// lead to memory problems like double-free, for example if the\n     /// function is called twice on the same raw pointer.\n     #[unstable(feature = \"alloc\",\n                reason = \"may be renamed or moved out of Box scope\")]\n+    #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n         mem::transmute(raw)\n     }\n@@ -141,6 +142,7 @@ impl<T : ?Sized> Box<T> {\n /// ```\n #[unstable(feature = \"alloc\",\n            reason = \"may be renamed\")]\n+#[inline]\n pub unsafe fn into_raw<T : ?Sized>(b: Box<T>) -> *mut T {\n     mem::transmute(b)\n }\n@@ -248,11 +250,12 @@ impl BoxAny for Box<Any> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n+                let raw = into_raw(self);\n                 let to: TraitObject =\n-                    mem::transmute::<Box<Any>, TraitObject>(self);\n+                    mem::transmute::<*mut Any, TraitObject>(raw);\n \n                 // Extract the data pointer\n-                Ok(mem::transmute(to.data))\n+                Ok(Box::from_raw(to.data as *mut T))\n             }\n         } else {\n             Err(self)"}, {"sha": "f57286bbf11c9af56ee608e8b9af720ddf00eaa4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -143,15 +143,18 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n+#[cfg(not(test))]\n+use boxed;\n+#[cfg(test)]\n+use std::boxed;\n use core::cell::Cell;\n use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::marker;\n-use core::mem::{transmute, min_align_of, size_of, forget};\n+use core::mem::{min_align_of, size_of, forget};\n use core::nonzero::NonZero;\n use core::ops::{Deref, Drop};\n use core::option::Option;\n@@ -201,7 +204,7 @@ impl<T> Rc<T> {\n                 // there is an implicit weak pointer owned by all the strong pointers, which\n                 // ensures that the weak destructor never frees the allocation while the strong\n                 // destructor is running, even if the weak pointer is stored inside the strong one.\n-                _ptr: NonZero::new(transmute(box RcBox {\n+                _ptr: NonZero::new(boxed::into_raw(box RcBox {\n                     value: value,\n                     strong: Cell::new(1),\n                     weak: Cell::new(1)"}, {"sha": "f28f9976f0c5dae9373c54a806522a63bff58a26", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -110,7 +110,7 @@ fn reverse_bits(byte: u8) -> u8 {\n     result\n }\n \n-// Take two BitV's, and return iterators of their words, where the shorter one\n+// Take two BitVec's, and return iterators of their words, where the shorter one\n // has been padded with 0's\n fn match_words <'a,'b>(a: &'a BitVec, b: &'b BitVec) -> (MatchWords<'a>, MatchWords<'b>) {\n     let a_len = a.storage.len();"}, {"sha": "f3b2e9738979c8c2a6022912b2e0eae2986b48c9", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 440, "deletions": 274, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -10,44 +10,39 @@\n //\n // ignore-lexer-test FIXME #15679\n \n-//! Unicode string manipulation (`str` type)\n+//! Unicode string manipulation (the `str` type).\n //!\n-//! # Basic Usage\n+//! Rust's `str` type is one of the core primitive types of the language. `&str` is the borrowed\n+//! string type. This type of string can only be created from other strings, unless it is a static\n+//! string (see below). As the word \"borrowed\" implies, this type of string is owned elsewhere, and\n+//! this string cannot be moved out of.\n //!\n-//! Rust's string type is one of the core primitive types of the language. While\n-//! represented by the name `str`, the name `str` is not actually a valid type in\n-//! Rust. Each string must also be decorated with a pointer. `String` is used\n-//! for an owned string, so there is only one commonly-used `str` type in Rust:\n-//! `&str`.\n+//! # Examples\n //!\n-//! `&str` is the borrowed string type. This type of string can only be created\n-//! from other strings, unless it is a static string (see below). As the word\n-//! \"borrowed\" implies, this type of string is owned elsewhere, and this string\n-//! cannot be moved out of.\n+//! Here's some code that uses a `&str`:\n //!\n-//! As an example, here's some code that uses a string.\n-//!\n-//! ```rust\n-//! fn main() {\n-//!     let borrowed_string = \"This string is borrowed with the 'static lifetime\";\n-//! }\n //! ```\n+//! let s = \"Hello, world.\";\n+//! ```\n+//!\n+//! This `&str` is a `&'static str`, which is the type of string literals. They're `'static`\n+//! because literals are available for the entire lifetime of the program.\n //!\n-//! From the example above, you can guess that Rust's string literals have the\n-//! `'static` lifetime. This is akin to C's concept of a static string.\n-//! More precisely, string literals are immutable views with a 'static lifetime\n-//! (otherwise known as the lifetime of the entire program), and thus have the\n-//! type `&'static str`.\n+//! You can get a non-`'static` `&str` by taking a slice of a `String`:\n+//!\n+//! ```\n+//! # let some_string = \"Hello, world.\".to_string();\n+//! let s = &some_string;\n+//! ```\n //!\n //! # Representation\n //!\n-//! Rust's string type, `str`, is a sequence of Unicode scalar values encoded as a\n-//! stream of UTF-8 bytes. All [strings](../../reference.html#literals) are\n-//! guaranteed to be validly encoded UTF-8 sequences. Additionally, strings are\n-//! not null-terminated and can thus contain null bytes.\n+//! Rust's string type, `str`, is a sequence of Unicode scalar values encoded as a stream of UTF-8\n+//! bytes. All [strings](../../reference.html#literals) are guaranteed to be validly encoded UTF-8\n+//! sequences. Additionally, strings are not null-terminated and can thus contain null bytes.\n //!\n-//! The actual representation of strings have direct mappings to slices: `&str`\n-//! is the same as `&[u8]`.\n+//! The actual representation of `str`s have direct mappings to slices: `&str` is the same as\n+//! `&[u8]`.\n \n #![doc(primitive = \"str\")]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -166,8 +161,9 @@ enum DecompositionType {\n     Compatible\n }\n \n-/// External iterator for a string's decomposition's characters.\n-/// Use with the `std::iter` module.\n+/// External iterator for a string decomposition's characters.\n+///\n+/// For use with the `std::iter` module.\n #[derive(Clone)]\n #[unstable(feature = \"collections\")]\n pub struct Decompositions<'a> {\n@@ -256,8 +252,9 @@ enum RecompositionState {\n     Finished\n }\n \n-/// External iterator for a string's recomposition's characters.\n-/// Use with the `std::iter` module.\n+/// External iterator for a string recomposition's characters.\n+///\n+/// For use with the `std::iter` module.\n #[derive(Clone)]\n #[unstable(feature = \"collections\")]\n pub struct Recompositions<'a> {\n@@ -354,7 +351,8 @@ impl<'a> Iterator for Recompositions<'a> {\n }\n \n /// External iterator for a string's UTF16 codeunits.\n-/// Use with the `std::iter` module.\n+///\n+/// For use with the `std::iter` module.\n #[derive(Clone)]\n #[unstable(feature = \"collections\")]\n pub struct Utf16Units<'a> {\n@@ -430,23 +428,21 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n \n     /// Replaces all occurrences of one string with another.\n     ///\n-    /// # Arguments\n-    ///\n-    /// * `from` - The string to replace\n-    /// * `to` - The replacement string\n-    ///\n-    /// # Return value\n-    ///\n-    /// The original string with all occurrences of `from` replaced with `to`.\n+    /// `replace` takes two arguments, a sub-`&str` to find in `self`, and a second `&str` to\n+    /// replace it with. If the original `&str` isn't found, no change occurs.\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = \"this is old\";\n     ///\n     /// assert_eq!(s.replace(\"old\", \"new\"), \"this is new\");\n+    /// ```\n+    ///\n+    /// When a `&str` isn't found:\n     ///\n-    /// // not found, so no change.\n+    /// ```\n+    /// let s = \"this is old\";\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -520,59 +516,56 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         }\n     }\n \n-    /// Returns true if a string contains a string pattern.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// - pat - The string pattern to look for\n+    /// Returns `true` if `self` contains another `&str`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert!(\"bananas\".contains(\"nana\"));\n+    ///\n+    /// assert!(!\"bananas\".contains(\"foobar\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n         core_str::StrExt::contains(&self[..], pat)\n     }\n \n-    /// Returns true if a string contains a char pattern.\n+    /// Returns `true` if `self` contains a `char`.\n     ///\n-    /// # Arguments\n-    ///\n-    /// - pat - The char pattern to look for\n-    ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert!(\"hello\".contains_char('e'));\n+    ///\n+    /// assert!(!\"hello\".contains_char('z'));\n     /// ```\n     #[unstable(feature = \"collections\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use `contains()` with a char\")]\n     fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n         core_str::StrExt::contains_char(&self[..], pat)\n     }\n \n-    /// An iterator over the characters of `self`. Note, this iterates\n-    /// over Unicode code-points, not Unicode graphemes.\n+    /// An iterator over the codepoints of `self`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n+    ///\n     /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chars(&self) -> Chars {\n         core_str::StrExt::chars(&self[..])\n     }\n \n-    /// An iterator over the bytes of `self`\n+    /// An iterator over the bytes of `self`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v: Vec<u8> = \"bors\".bytes().collect();\n+    ///\n     /// assert_eq!(v, b\"bors\".to_vec());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -581,47 +574,66 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     }\n \n     /// An iterator over the characters of `self` and their byte offsets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v: Vec<(usize, char)> = \"abc\".char_indices().collect();\n+    /// let b = vec![(0, 'a'), (1, 'b'), (2, 'c')];\n+    ///\n+    /// assert_eq!(v, b);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn char_indices(&self) -> CharIndices {\n         core_str::StrExt::char_indices(&self[..])\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n-    /// matched by the pattern `pat`.\n+    /// matched by a pattern.\n     ///\n-    /// # Example\n+    /// The pattern can be a simple `&str`, or a closure that determines\n+    /// the split.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n+    /// let v: Vec<&str> = \"\".split('X').collect();\n+    /// assert_eq!(v, vec![\"\"]);\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n     /// assert_eq!(v, vec![\"lion\", \"\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".split('X').collect();\n-    /// assert_eq!(v, vec![\"\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n         core_str::StrExt::split(&self[..], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by the pattern `pat`, restricted to splitting at most `count`\n-    /// times.\n+    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n+    /// restricted to splitting at most `count` times.\n     ///\n-    /// # Example\n+    /// The pattern can be a simple `&str`, or a closure that determines\n+    /// the split.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n     /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n-    ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"lion\", \"\", \"tigerXleopard\"]);\n     ///\n@@ -631,72 +643,89 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n         core_str::StrExt::splitn(&self[..], count, pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n-    /// matched by the pattern `pat`.\n+    /// matched by a pattern.\n     ///\n-    /// Equivalent to `split`, except that the trailing substring\n-    /// is skipped if empty (terminator semantics).\n+    /// Equivalent to `split`, except that the trailing substring is skipped if empty.\n     ///\n-    /// # Example\n+    /// The pattern can be a simple `&str`, or a closure that determines\n+    /// the split.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n     /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n     /// assert_eq!(v, vec![\"A\", \"B\"]);\n     ///\n     /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n     /// assert_eq!(v, vec![\"A\", \"\", \"B\", \"\"]);\n+    /// ```\n     ///\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').rev().collect();\n-    /// assert_eq!(v, vec![\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).rev().collect();\n-    /// assert_eq!(v, vec![\"ghi\", \"def\", \"abc\"]);\n+    /// More complex patterns with a lambda:\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n-    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi3\".split_terminator(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n         core_str::StrExt::split_terminator(&self[..], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by the pattern `pat`, starting from the end of the string.\n+    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n+    /// starting from the end of the string.\n+    ///\n     /// Restricted to splitting at most `count` times.\n     ///\n-    /// # Example\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n-    ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n         core_str::StrExt::rsplitn(&self[..], count, pat)\n     }\n \n-    /// An iterator over the start and end indices of the disjoint\n-    /// matches of the pattern `pat` within `self`.\n+    /// An iterator over the start and end indices of the disjoint matches of a `&str` within\n+    /// `self`.\n     ///\n-    /// That is, each returned value `(start, end)` satisfies\n-    /// `self.slice(start, end) == sep`. For matches of `sep` within\n-    /// `self` that overlap, only the indices corresponding to the\n-    /// first match are returned.\n+    /// That is, each returned value `(start, end)` satisfies `self.slice(start, end) == sep`. For\n+    /// matches of `sep` within `self` that overlap, only the indices corresponding to the first\n+    /// match are returned.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n     /// assert_eq!(v, vec![(0,3), (6,9), (12,15)]);\n     ///\n@@ -714,11 +743,11 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::match_indices(&self[..], pat)\n     }\n \n-    /// An iterator over the substrings of `self` separated by the pattern `sep`.\n+    /// An iterator over the substrings of `self` separated by a `&str`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n     /// assert_eq!(v, vec![\"\", \"XXX\", \"YYY\", \"\"]);\n     ///\n@@ -731,31 +760,51 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::split_str(&self[..], pat)\n     }\n \n-    /// An iterator over the lines of a string (subsequences separated\n-    /// by `\\n`). This does not include the empty string after a\n-    /// trailing `\\n`.\n+    /// An iterator over the lines of a string, separated by `\\n`.\n     ///\n-    /// # Example\n+    /// This does not include the empty string after a trailing `\\n`.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let four_lines = \"foo\\nbar\\n\\nbaz\";\n+    /// let v: Vec<&str> = four_lines.lines().collect();\n+    ///\n+    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    ///\n+    /// Leaving off the trailing character:\n+    ///\n+    /// ```\n     /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n     /// let v: Vec<&str> = four_lines.lines().collect();\n+    ///\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(&self) -> Lines {\n         core_str::StrExt::lines(&self[..])\n     }\n \n-    /// An iterator over the lines of a string, separated by either\n-    /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n-    /// empty trailing line.\n+    /// An iterator over the lines of a string, separated by either `\\n` or `\\r\\n`.\n     ///\n-    /// # Example\n+    /// As with `.lines()`, this does not include an empty trailing line.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\";\n+    /// let v: Vec<&str> = four_lines.lines_any().collect();\n+    ///\n+    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    ///\n+    /// Leaving off the trailing character:\n+    ///\n+    /// ```\n     /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n     /// let v: Vec<&str> = four_lines.lines_any().collect();\n+    ///\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -781,26 +830,25 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[deprecated(since = \"1.0.0\", reason = \"use slice notation [..a] instead\")]\n     fn slice_to(&self, end: usize) -> &str;\n \n-    /// Returns a slice of the string from the character range\n-    /// [`begin`..`end`).\n+    /// Returns a slice of the string from the character range [`begin`..`end`).\n     ///\n-    /// That is, start at the `begin`-th code point of the string and\n-    /// continue to the `end`-th code point. This does not detect or\n-    /// handle edge cases such as leaving a combining character as the\n-    /// first code point of the string.\n+    /// That is, start at the `begin`-th code point of the string and continue to the `end`-th code\n+    /// point. This does not detect or handle edge cases such as leaving a combining character as\n+    /// the first code point of the string.\n     ///\n-    /// Due to the design of UTF-8, this operation is `O(end)`.\n-    /// See `slice`, `slice_to` and `slice_from` for `O(1)`\n-    /// variants that use byte indices rather than code point\n-    /// indices.\n+    /// Due to the design of UTF-8, this operation is `O(end)`. See `slice`, `slice_to` and\n+    /// `slice_from` for `O(1)` variants that use byte indices rather than code point indices.\n     ///\n-    /// Panics if `begin` > `end` or the either `begin` or `end` are\n-    /// beyond the last character of the string.\n+    /// # Panics\n     ///\n-    /// # Example\n+    /// Panics if `begin` > `end` or the either `begin` or `end` are beyond the last character of\n+    /// the string.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n     /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n     /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n     /// ```\n@@ -810,32 +858,44 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::slice_chars(&self[..], begin, end)\n     }\n \n-    /// Takes a bytewise (not UTF-8) slice from a string.\n+    /// Takes a bytewise slice from a string.\n     ///\n     /// Returns the substring from [`begin`..`end`).\n     ///\n-    /// Caller must check both UTF-8 character boundaries and the boundaries of\n-    /// the entire slice as well.\n+    /// # Unsafety\n+    ///\n+    /// Caller must check both UTF-8 character boundaries and the boundaries of the entire slice as\n+    /// well.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(s.slice_unchecked(0, 21), \"L\u00f6we \u8001\u864e L\u00e9opard\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n         core_str::StrExt::slice_unchecked(&self[..], begin, end)\n     }\n \n-    /// Returns true if the pattern `pat` is a prefix of the string.\n+    /// Returns `true` if the given `&str` is a prefix of the string.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert!(\"banana\".starts_with(\"ba\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n         core_str::StrExt::starts_with(&self[..], pat)\n     }\n \n-    /// Returns true if the pattern `pat` is a suffix of the string.\n+    /// Returns true if the given `&str` is a suffix of the string.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// assert!(\"banana\".ends_with(\"nana\"));\n@@ -847,19 +907,24 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::ends_with(&self[..], pat)\n     }\n \n-    /// Returns a string with all pre- and suffixes that match\n-    /// the pattern `pat` repeatedly removed.\n+    /// Returns a string with all pre- and suffixes that match a pattern repeatedly removed.\n     ///\n-    /// # Arguments\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// * pat - a string pattern\n+    /// # Examples\n     ///\n-    /// # Example\n+    /// Simple `&str` patterns:\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n+    ///\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n     /// assert_eq!(\"123foo1bar123\".trim_matches(|c: char| c.is_numeric()), \"foo1bar\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -869,39 +934,48 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::trim_matches(&self[..], pat)\n     }\n \n-    /// Returns a string with all prefixes that match\n-    /// the pattern `pat` repeatedly removed.\n+    /// Returns a string with all prefixes that match a pattern repeatedly removed.\n     ///\n-    /// # Arguments\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// * pat - a string pattern\n+    /// # Examples\n     ///\n-    /// # Example\n+    /// Simple `&str` patterns:\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n+    ///\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n     /// assert_eq!(\"123foo1bar123\".trim_left_matches(|c: char| c.is_numeric()), \"foo1bar123\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n         core_str::StrExt::trim_left_matches(&self[..], pat)\n     }\n \n-    /// Returns a string with all suffixes that match\n-    /// the pattern `pat` repeatedly removed.\n+    /// Returns a string with all suffixes that match a pattern repeatedly removed.\n     ///\n-    /// # Arguments\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// * pat - a string pattern\n+    /// # Examples\n     ///\n-    /// # Example\n+    /// Simple `&str` patterns:\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n     /// assert_eq!(\"123foo1bar123\".trim_right_matches(|c: char| c.is_numeric()), \"123foo1bar\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -911,17 +985,18 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::trim_right_matches(&self[..], pat)\n     }\n \n-    /// Check that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n+    /// Check that `index`-th byte lies at the start and/or end of a UTF-8 code point sequence.\n     ///\n-    /// The start and end of the string (when `index == self.len()`)\n-    /// are considered to be boundaries.\n+    /// The start and end of the string (when `index == self.len()`) are considered to be\n+    /// boundaries.\n+    ///\n+    /// # Panics\n     ///\n     /// Panics if `index` is greater than `self.len()`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// assert!(s.is_char_boundary(0));\n     /// // start of `\u8001`\n@@ -940,19 +1015,21 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::is_char_boundary(&self[..], index)\n     }\n \n-    /// Pluck a character out of a string and return the index of the next\n-    /// character.\n+    /// Given a byte position, return the next char and its index.\n     ///\n-    /// This function can be used to iterate over the Unicode characters of a\n-    /// string.\n+    /// This can be used to iterate over the Unicode characters of a string.\n     ///\n-    /// # Example\n+    /// # Panics\n     ///\n-    /// This example manually iterates through the characters of a\n-    /// string; this should normally be done by `.chars()` or\n-    /// `.char_indices`.\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// This example manually iterates through the characters of a string; this should normally be\n+    /// done by `.chars()` or `.char_indices()`.\n+    ///\n+    /// ```\n     /// use std::str::CharRange;\n     ///\n     /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -978,28 +1055,13 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// 14: a\n     /// 15: m\n     /// ```\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - The string\n-    /// * i - The byte offset of the char to extract\n-    ///\n-    /// # Return value\n-    ///\n-    /// A record {ch: char, next: usize} containing the char value and the byte\n-    /// index of the next Unicode character.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at(&self[..], start)\n     }\n \n-    /// Given a byte position and a str, return the previous char and its position.\n+    /// Given a byte position, return the previous `char` and its position.\n     ///\n     /// This function can be used to iterate over a Unicode string in reverse.\n     ///\n@@ -1009,106 +1071,168 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This example manually iterates through the characters of a string; this should normally be\n+    /// done by `.chars().rev()` or `.char_indices()`.\n+    ///\n+    /// ```\n+    /// use std::str::CharRange;\n+    ///\n+    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let mut i = s.len();\n+    /// while i < 0 {\n+    ///     let CharRange {ch, next} = s.char_range_at_reverse(i);\n+    ///     println!(\"{}: {}\", i, ch);\n+    ///     i = next;\n+    /// }\n+    /// ```\n+    ///\n+    /// This outputs:\n+    ///\n+    /// ```text\n+    /// 16: m\n+    /// 15: a\n+    /// 14: N\n+    /// 13:\n+    /// 12: t\n+    /// 11: \u1ec7\n+    /// 8: i\n+    /// 7: V\n+    /// 6: \u534e\n+    /// 3: \u4e2d\n+    /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(&self[..], start)\n     }\n \n-    /// Plucks the character starting at the `i`th byte of a string.\n+    /// Given a byte position, return the `char` at that position.\n     ///\n-    /// # Example\n+    /// # Panics\n     ///\n-    /// ```rust\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n     /// let s = \"ab\u03c0c\";\n     /// assert_eq!(s.char_at(1), 'b');\n     /// assert_eq!(s.char_at(2), '\u03c0');\n-    /// assert_eq!(s.char_at(4), 'c');\n     /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_at(&self, i: usize) -> char {\n         core_str::StrExt::char_at(&self[..], i)\n     }\n \n-    /// Plucks the character ending at the `i`th byte of a string.\n+    /// Given a byte position, return the `char` at that position, counting from the end.\n     ///\n     /// # Panics\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"ab\u03c0c\";\n+    /// assert_eq!(s.char_at_reverse(1), 'a');\n+    /// assert_eq!(s.char_at_reverse(2), 'b');\n+    /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_at_reverse(&self, i: usize) -> char {\n         core_str::StrExt::char_at_reverse(&self[..], i)\n     }\n \n-    /// Work with the byte buffer of a string as a byte slice.\n+    /// Convert `self` to a byte slice.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_bytes(&self) -> &[u8] {\n         core_str::StrExt::as_bytes(&self[..])\n     }\n \n-    /// Returns the byte index of the first character of `self` that\n-    /// matches the pattern `pat`.\n+    /// Returns the byte index of the first character of `self` that matches the pattern, if it\n+    /// exists.\n     ///\n-    /// # Return value\n+    /// Returns `None` if it doesn't exist.\n     ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.find('L'), Some(0));\n     /// assert_eq!(s.find('\u00e9'), Some(14));\n     ///\n-    /// // the first space\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n     /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n+    /// ```\n     ///\n-    /// // neither are found\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// let x: &[_] = &['1', '2'];\n+    ///\n     /// assert_eq!(s.find(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n         core_str::StrExt::find(&self[..], pat)\n     }\n \n-    /// Returns the byte index of the last character of `self` that\n-    /// matches the pattern `pat`.\n+    /// Returns the byte index of the last character of `self` that matches the pattern, if it\n+    /// exists.\n     ///\n-    /// # Return value\n+    /// Returns `None` if it doesn't exist.\n     ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match.\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.rfind('L'), Some(13));\n     /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n-    /// // the second space\n     /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n     ///\n-    /// // searches for an occurrence of either `1` or `2`, but neither are found\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// let x: &[_] = &['1', '2'];\n+    ///\n     /// assert_eq!(s.rfind(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1118,20 +1242,15 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::rfind(&self[..], pat)\n     }\n \n-    /// Returns the byte index of the first matching substring\n+    /// Returns the byte index of the first matching substring if it exists.\n     ///\n-    /// # Arguments\n+    /// Returns `None` if it doesn't exist.\n     ///\n-    /// * `needle` - The string to search for\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the first matching substring\n-    /// or `None` if there is no match.\n-    ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n@@ -1143,21 +1262,24 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::find_str(&self[..], needle)\n     }\n \n-    /// Retrieves the first character from a string slice and returns\n-    /// it. This does not allocate a new string; instead, it returns a\n-    /// slice that point one character beyond the character that was\n-    /// shifted. If the string does not contain any characters,\n-    /// None is returned instead.\n+    /// Retrieves the first character from a `&str` and returns it.\n     ///\n-    /// # Example\n+    /// This does not allocate a new string; instead, it returns a slice that points one character\n+    /// beyond the character that was shifted.\n     ///\n-    /// ```rust\n+    /// If the slice does not contain any characters, None is returned instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// let (c, s1) = s.slice_shift_char().unwrap();\n+    ///\n     /// assert_eq!(c, 'L');\n     /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n     ///\n     /// let (c, s2) = s1.slice_shift_char().unwrap();\n+    ///\n     /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n@@ -1169,11 +1291,13 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n \n     /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n     ///\n+    /// # Panics\n+    ///\n     /// Panics if `inner` is not a direct slice contained within self.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let string = \"a\\nb\\nc\";\n     /// let lines: Vec<&str> = string.lines().collect();\n     ///\n@@ -1187,11 +1311,17 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::subslice_offset(&self[..], inner)\n     }\n \n-    /// Return an unsafe pointer to the strings buffer.\n+    /// Return an unsafe pointer to the `&str`'s buffer.\n+    ///\n+    /// The caller must ensure that the string outlives this pointer, and that it is not\n+    /// reallocated (e.g. by pushing to the string).\n     ///\n-    /// The caller must ensure that the string outlives this pointer,\n-    /// and that it is not reallocated (e.g. by pushing to the\n-    /// string).\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"Hello\";\n+    /// let p = s.as_ptr();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n@@ -1205,23 +1335,23 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         Utf16Units { encoder: Utf16Encoder::new(self[..].chars()) }\n     }\n \n-    /// Return the number of bytes in this string\n+    /// Returns the length of `self` in bytes.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// assert_eq!(\"foo\".len(), 3);\n-    /// assert_eq!(\"\u0192oo\".len(), 4);\n+    /// assert_eq!(\"\u0192oo\".len(), 4); // fancy f!\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn len(&self) -> usize {\n         core_str::StrExt::len(&self[..])\n     }\n \n-    /// Returns true if this slice contains no bytes\n+    /// Returns true if this slice has a length of zero bytes.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// assert!(\"\".is_empty());\n@@ -1232,12 +1362,21 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::is_empty(&self[..])\n     }\n \n-    /// Parse this string into the specified type.\n+    /// Parses `self` into the specified type.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Will return `Err` if it's not possible to parse `self` into the type.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// assert_eq!(\"4\".parse::<u32>(), Ok(4));\n+    /// ```\n+    ///\n+    /// Failing:\n+    ///\n+    /// ```\n     /// assert!(\"j\".parse::<u32>().is_err());\n     /// ```\n     #[inline]\n@@ -1246,23 +1385,26 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::parse(&self[..])\n     }\n \n-    /// Returns an iterator over the\n-    /// [grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n-    /// of the string.\n+    /// Returns an iterator over the [grapheme clusters][graphemes] of `self`.\n+    ///\n+    /// [graphemes]: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n     ///\n     /// If `is_extended` is true, the iterator is over the *extended grapheme clusters*;\n     /// otherwise, the iterator is over the *legacy grapheme clusters*.\n     /// [UAX#29](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n     /// recommends extended grapheme cluster boundaries for general processing.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let gr1 = \"a\\u{310}e\\u{301}o\\u{308}\\u{332}\".graphemes(true).collect::<Vec<&str>>();\n     /// let b: &[_] = &[\"a\\u{310}\", \"e\\u{301}\", \"o\\u{308}\\u{332}\"];\n+    ///\n     /// assert_eq!(gr1.as_slice(), b);\n+    ///\n     /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n     /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n+    ///\n     /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n     #[unstable(feature = \"collections\",\n@@ -1271,14 +1413,15 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         UnicodeStr::graphemes(&self[..], is_extended)\n     }\n \n-    /// Returns an iterator over the grapheme clusters of self and their byte offsets.\n-    /// See `graphemes()` method for more information.\n+    /// Returns an iterator over the grapheme clusters of `self` and their byte offsets. See\n+    /// `graphemes()` for more information.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n     /// let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+    ///\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n     #[unstable(feature = \"collections\",\n@@ -1287,15 +1430,17 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         UnicodeStr::grapheme_indices(&self[..], is_extended)\n     }\n \n-    /// An iterator over the words of a string (subsequences separated\n-    /// by any sequence of whitespace). Sequences of whitespace are\n-    /// collapsed, so empty \"words\" are not included.\n+    /// An iterator over the non-empty words of `self`.\n     ///\n-    /// # Example\n+    /// A 'word' is a subsequence separated by any sequence of whitespace. Sequences of whitespace\n+    /// are collapsed, so empty \"words\" are not included.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// ```\n     /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n     /// let v: Vec<&str> = some_words.words().collect();\n+    ///\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n     #[unstable(feature = \"str_words\",\n@@ -1304,34 +1449,55 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         UnicodeStr::words(&self[..])\n     }\n \n-    /// Returns a string's displayed width in columns, treating control\n-    /// characters as zero-width.\n+    /// Returns a string's displayed width in columns.\n+    ///\n+    /// Control characters have zero width.\n     ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n-    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n-    /// In CJK locales, `is_cjk` should be `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n-    /// recommends that these characters be treated as 1 column (i.e.,\n-    /// `is_cjk` = `false`) if the locale is unknown.\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category: if `is_cjk` is\n+    /// `true`, these are 2 columns wide; otherwise, they are 1. In CJK locales, `is_cjk` should be\n+    /// `true`, else it should be `false`. [Unicode Standard Annex\n+    /// #11](http://www.unicode.org/reports/tr11/) recommends that these characters be treated as 1\n+    /// column (i.e., `is_cjk` = `false`) if the locale is unknown.\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn width(&self, is_cjk: bool) -> usize {\n         UnicodeStr::width(&self[..], is_cjk)\n     }\n \n-    /// Returns a string with leading and trailing whitespace removed.\n+    /// Returns a `&str` with leading and trailing whitespace removed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(s.trim(), \"Hello\\tworld\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim(&self) -> &str {\n         UnicodeStr::trim(&self[..])\n     }\n \n-    /// Returns a string with leading whitespace removed.\n+    /// Returns a `&str` with leading whitespace removed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(s.trim_left(), \"Hello\\tworld\\t\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left(&self) -> &str {\n         UnicodeStr::trim_left(&self[..])\n     }\n \n-    /// Returns a string with trailing whitespace removed.\n+    /// Returns a `&str` with trailing whitespace removed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(s.trim_right(), \" Hello\\tworld\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right(&self) -> &str {\n         UnicodeStr::trim_right(&self[..])"}, {"sha": "3f5f92889166fd544b33cd9d5e001be63b157dc1", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 25, "deletions": 60, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -388,7 +388,7 @@ impl<T> Vec<T> {\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         self.shrink_to_fit();\n         unsafe {\n-            let xs: Box<[T]> = mem::transmute(&mut *self);\n+            let xs: Box<[T]> = Box::from_raw(&mut *self);\n             mem::forget(self);\n             xs\n         }\n@@ -1493,69 +1493,34 @@ impl<T> Extend<T> for Vec<T> {\n     }\n }\n \n-impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> {\n-    #[inline]\n-    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-macro_rules! impl_eq {\n-    ($lhs:ty, $rhs:ty) => {\n-        impl<'b, A, B> PartialEq<$rhs> for $lhs where A: PartialEq<B> {\n-            #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-\n-        impl<'b, A, B> PartialEq<$lhs> for $rhs where B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n+__impl_slice_eq1! { Vec<A>, Vec<B> }\n+__impl_slice_eq2! { Vec<A>, &'b [B] }\n+__impl_slice_eq2! { Vec<A>, &'b mut [B] }\n+__impl_slice_eq2! { CowVec<'a, A>, &'b [B], Clone }\n+__impl_slice_eq2! { CowVec<'a, A>, &'b mut [B], Clone }\n+__impl_slice_eq2! { CowVec<'a, A>, Vec<B>, Clone }\n+\n+macro_rules! array_impls {\n+    ($($N: expr)+) => {\n+        $(\n+            // NOTE: some less important impls are omitted to reduce code bloat\n+            __impl_slice_eq2! { Vec<A>, [B; $N] }\n+            __impl_slice_eq2! { Vec<A>, &'b [B; $N] }\n+            // __impl_slice_eq2! { Vec<A>, &'b mut [B; $N] }\n+            // __impl_slice_eq2! { CowVec<'a, A>, [B; $N], Clone }\n+            // __impl_slice_eq2! { CowVec<'a, A>, &'b [B; $N], Clone }\n+            // __impl_slice_eq2! { CowVec<'a, A>, &'b mut [B; $N], Clone }\n+        )+\n     }\n }\n \n-impl_eq! { Vec<A>, &'b [B] }\n-impl_eq! { Vec<A>, &'b mut [B] }\n-\n-impl<'a, A, B> PartialEq<Vec<B>> for Cow<'a, [A]> where A: PartialEq<B> + Clone {\n-    #[inline]\n-    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n+array_impls! {\n+     0  1  2  3  4  5  6  7  8  9\n+    10 11 12 13 14 15 16 17 18 19\n+    20 21 22 23 24 25 26 27 28 29\n+    30 31 32\n }\n \n-impl<'a, A, B> PartialEq<Cow<'a, [A]>> for Vec<B> where A: Clone, B: PartialEq<A> {\n-    #[inline]\n-    fn eq(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-macro_rules! impl_eq_for_cowvec {\n-    ($rhs:ty) => {\n-        impl<'a, 'b, A, B> PartialEq<$rhs> for Cow<'a, [A]> where A: PartialEq<B> + Clone {\n-            #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-\n-        impl<'a, 'b, A, B> PartialEq<Cow<'a, [A]>> for $rhs where A: Clone, B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-    }\n-}\n-\n-impl_eq_for_cowvec! { &'b [B] }\n-impl_eq_for_cowvec! { &'b mut [B] }\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n@@ -2470,7 +2435,7 @@ mod tests {\n     fn test_into_boxed_slice() {\n         let xs = vec![1, 2, 3];\n         let ys = xs.into_boxed_slice();\n-        assert_eq!(ys, [1, 2, 3]);\n+        assert_eq!(&*ys, [1, 2, 3]);\n     }\n \n     #[test]"}, {"sha": "d92249379fa8fc36adf9100163b368069495eb20", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 170, "deletions": 2, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -17,13 +17,13 @@ use self::Entry::*;\n \n use core::prelude::*;\n \n-use core::cmp::Ordering;\n+use core::cmp::{max, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::iter::{Enumerate, FilterMap, Map, FromIterator, IntoIterator};\n use core::iter;\n-use core::mem::replace;\n+use core::mem::{replace, swap};\n use core::ops::{Index, IndexMut};\n \n use {vec, slice};\n@@ -320,6 +320,95 @@ impl<V> VecMap<V> {\n         IntoIter { iter: self.v.into_iter().enumerate().filter_map(filter) }\n     }\n \n+    /// Moves all elements from `other` into the map while overwriting existing keys.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecMap;\n+    ///\n+    /// let mut a = VecMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    ///\n+    /// let mut b = VecMap::new();\n+    /// b.insert(3, \"c\");\n+    /// b.insert(4, \"d\");\n+    ///\n+    /// a.append(&mut b);\n+    ///\n+    /// assert_eq!(a.len(), 4);\n+    /// assert_eq!(b.len(), 0);\n+    /// assert_eq!(a[1], \"a\");\n+    /// assert_eq!(a[2], \"b\");\n+    /// assert_eq!(a[3], \"c\");\n+    /// assert_eq!(a[4], \"d\");\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"recently added as part of collections reform 2\")]\n+    pub fn append(&mut self, other: &mut Self) {\n+        self.extend(other.drain());\n+    }\n+\n+    /// Splits the collection into two at the given key.\n+    ///\n+    /// Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n+    /// and the returned `Self` contains elements `[at, max_key)`.\n+    ///\n+    /// Note that the capacity of `self` does not change.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecMap;\n+    ///\n+    /// let mut a = VecMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"d\");\n+    ///\n+    /// let b = a.split_off(3);\n+    ///\n+    /// assert_eq!(a[1], \"a\");\n+    /// assert_eq!(a[2], \"b\");\n+    ///\n+    /// assert_eq!(b[3], \"c\");\n+    /// assert_eq!(b[4], \"d\");\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"recently added as part of collections reform 2\")]\n+    pub fn split_off(&mut self, at: usize) -> Self {\n+        let mut other = VecMap::new();\n+\n+        if at == 0 {\n+            // Move all elements to other\n+            swap(self, &mut other);\n+            return other\n+        } else if at > self.v.len() {\n+            // No elements to copy\n+            return other;\n+        }\n+\n+        // Look up the index of the first non-None item\n+        let first_index = self.v.iter().position(|el| el.is_some());\n+        let start_index = match first_index {\n+            Some(index) => max(at, index),\n+            None => {\n+                // self has no elements\n+                return other;\n+            }\n+        };\n+\n+        // Fill the new VecMap with `None`s until `start_index`\n+        other.v.extend((0..start_index).map(|_| None));\n+\n+        // Move elements beginning with `start_index` from `self` into `other`\n+        other.v.extend(self.v[start_index..].iter_mut().map(|el| el.take()));\n+\n+        other\n+    }\n+\n     /// Returns an iterator visiting all key-value pairs in ascending order of\n     /// the keys, emptying (but not consuming) the original `VecMap`.\n     /// The iterator's element type is `(usize, &'r V)`. Keeps the allocated memory for reuse.\n@@ -1141,6 +1230,85 @@ mod test_map {\n         assert_eq!(map.len(), 0);\n     }\n \n+    #[test]\n+    fn test_append() {\n+        let mut a = VecMap::new();\n+        a.insert(1, \"a\");\n+        a.insert(2, \"b\");\n+        a.insert(3, \"c\");\n+\n+        let mut b = VecMap::new();\n+        b.insert(3, \"d\");  // Overwrite element from a\n+        b.insert(4, \"e\");\n+        b.insert(5, \"f\");\n+\n+        a.append(&mut b);\n+\n+        assert_eq!(a.len(), 5);\n+        assert_eq!(b.len(), 0);\n+        // Capacity shouldn't change for possible reuse\n+        assert!(b.capacity() >= 4);\n+\n+        assert_eq!(a[1], \"a\");\n+        assert_eq!(a[2], \"b\");\n+        assert_eq!(a[3], \"d\");\n+        assert_eq!(a[4], \"e\");\n+        assert_eq!(a[5], \"f\");\n+    }\n+\n+    #[test]\n+    fn test_split_off() {\n+        // Split within the key range\n+        let mut a = VecMap::new();\n+        a.insert(1, \"a\");\n+        a.insert(2, \"b\");\n+        a.insert(3, \"c\");\n+        a.insert(4, \"d\");\n+\n+        let b = a.split_off(3);\n+\n+        assert_eq!(a.len(), 2);\n+        assert_eq!(b.len(), 2);\n+\n+        assert_eq!(a[1], \"a\");\n+        assert_eq!(a[2], \"b\");\n+\n+        assert_eq!(b[3], \"c\");\n+        assert_eq!(b[4], \"d\");\n+\n+        // Split at 0\n+        a.clear();\n+        a.insert(1, \"a\");\n+        a.insert(2, \"b\");\n+        a.insert(3, \"c\");\n+        a.insert(4, \"d\");\n+\n+        let b = a.split_off(0);\n+\n+        assert_eq!(a.len(), 0);\n+        assert_eq!(b.len(), 4);\n+        assert_eq!(b[1], \"a\");\n+        assert_eq!(b[2], \"b\");\n+        assert_eq!(b[3], \"c\");\n+        assert_eq!(b[4], \"d\");\n+\n+        // Split behind max_key\n+        a.clear();\n+        a.insert(1, \"a\");\n+        a.insert(2, \"b\");\n+        a.insert(3, \"c\");\n+        a.insert(4, \"d\");\n+\n+        let b = a.split_off(5);\n+\n+        assert_eq!(a.len(), 4);\n+        assert_eq!(b.len(), 0);\n+        assert_eq!(a[1], \"a\");\n+        assert_eq!(a[2], \"b\");\n+        assert_eq!(a[3], \"c\");\n+        assert_eq!(a[4], \"d\");\n+    }\n+\n     #[test]\n     fn test_show() {\n         let mut map = VecMap::new();"}, {"sha": "0d98cff7e6a5e58b9ceea647a80a08490d56e293", "filename": "src/libcore/array.rs", "status": "modified", "additions": 8, "deletions": 43, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -19,8 +19,7 @@ use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;\n use hash::{Hash, self};\n use iter::IntoIterator;\n-use marker::Copy;\n-use ops::Deref;\n+use marker::{Copy, Sized};\n use option::Option;\n use slice::{Iter, IterMut, SliceExt};\n \n@@ -69,47 +68,13 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n-                #[inline]\n-                fn eq(&self, other: &[B; $N]) -> bool {\n-                    &self[..] == &other[..]\n-                }\n-                #[inline]\n-                fn ne(&self, other: &[B; $N]) -> bool {\n-                    &self[..] != &other[..]\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<'a, A, B, Rhs> PartialEq<Rhs> for [A; $N] where\n-                A: PartialEq<B>,\n-                Rhs: Deref<Target=[B]>,\n-            {\n-                #[inline(always)]\n-                fn eq(&self, other: &Rhs) -> bool {\n-                    PartialEq::eq(&self[..], &**other)\n-                }\n-                #[inline(always)]\n-                fn ne(&self, other: &Rhs) -> bool {\n-                    PartialEq::ne(&self[..], &**other)\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<'a, A, B, Lhs> PartialEq<[B; $N]> for Lhs where\n-                A: PartialEq<B>,\n-                Lhs: Deref<Target=[A]>\n-            {\n-                #[inline(always)]\n-                fn eq(&self, other: &[B; $N]) -> bool {\n-                    PartialEq::eq(&**self, &other[..])\n-                }\n-                #[inline(always)]\n-                fn ne(&self, other: &[B; $N]) -> bool {\n-                    PartialEq::ne(&**self, &other[..])\n-                }\n-            }\n+            // NOTE: some less important impls are omitted to reduce code bloat\n+            __impl_slice_eq1! { [A; $N], [B; $N] }\n+            __impl_slice_eq2! { [A; $N], [B] }\n+            __impl_slice_eq2! { [A; $N], &'b [B] }\n+            __impl_slice_eq2! { [A; $N], &'b mut [B] }\n+            // __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n+            // __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Eq> Eq for [T; $N] { }"}, {"sha": "18357bac9e6f685bf7739ce91e4c223917ba1500", "filename": "src/libcore/cmp_macros.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcore%2Fcmp_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcore%2Fcmp_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp_macros.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Utility macros for implementing PartialEq on slice-like types\n+\n+#![doc(hidden)]\n+\n+#[macro_export]\n+macro_rules! __impl_slice_eq1 {\n+    ($Lhs: ty, $Rhs: ty) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, 'b, A, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+            #[inline]\n+            fn eq(&self, other: &$Rhs) -> bool { &self[..] == &other[..] }\n+            #[inline]\n+            fn ne(&self, other: &$Rhs) -> bool { &self[..] != &other[..] }\n+        }\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! __impl_slice_eq2 {\n+    ($Lhs: ty, $Rhs: ty) => {\n+        __impl_slice_eq2! { $Lhs, $Rhs, Sized }\n+    };\n+    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+            #[inline]\n+            fn eq(&self, other: &$Rhs) -> bool { &self[..] == &other[..] }\n+            #[inline]\n+            fn ne(&self, other: &$Rhs) -> bool { &self[..] != &other[..] }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, 'b, A: $Bound, B> PartialEq<$Lhs> for $Rhs where B: PartialEq<A> {\n+            #[inline]\n+            fn eq(&self, other: &$Lhs) -> bool { &self[..] == &other[..] }\n+            #[inline]\n+            fn ne(&self, other: &$Lhs) -> bool { &self[..] != &other[..] }\n+        }\n+    }\n+}"}, {"sha": "7f52f071080d0c2908de083cdd952c917f2cb72d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -72,6 +72,9 @@\n #[macro_use]\n mod macros;\n \n+#[macro_use]\n+mod cmp_macros;\n+\n #[path = \"num/float_macros.rs\"]\n #[macro_use]\n mod float_macros;"}, {"sha": "5e80bc5db2e41967512edd22373b6cf53f74ba81", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -167,6 +167,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![deny(missing_docs)]\n \n+#![feature(alloc)]\n #![feature(staged_api)]\n #![feature(box_syntax)]\n #![feature(int_uint)]\n@@ -175,6 +176,7 @@\n #![feature(std_misc)]\n #![feature(env)]\n \n+use std::boxed;\n use std::cell::RefCell;\n use std::fmt;\n use std::old_io::LineBufferedWriter;\n@@ -205,11 +207,11 @@ const DEFAULT_LOG_LEVEL: u32 = 1;\n /// logging statement should be run.\n static mut LOG_LEVEL: u32 = MAX_LOG_LEVEL;\n \n-static mut DIRECTIVES: *const Vec<directive::LogDirective> =\n-    0 as *const Vec<directive::LogDirective>;\n+static mut DIRECTIVES: *mut Vec<directive::LogDirective> =\n+    0 as *mut Vec<directive::LogDirective>;\n \n /// Optional filter.\n-static mut FILTER: *const String = 0 as *const _;\n+static mut FILTER: *mut String = 0 as *mut _;\n \n /// Debug log level\n pub const DEBUG: u32 = 4;\n@@ -419,23 +421,23 @@ fn init() {\n \n         assert!(FILTER.is_null());\n         match filter {\n-            Some(f) => FILTER = mem::transmute(box f),\n+            Some(f) => FILTER = boxed::into_raw(box f),\n             None => {}\n         }\n \n         assert!(DIRECTIVES.is_null());\n-        DIRECTIVES = mem::transmute(box directives);\n+        DIRECTIVES = boxed::into_raw(box directives);\n \n         // Schedule the cleanup for the globals for when the runtime exits.\n         rt::at_exit(move || {\n             assert!(!DIRECTIVES.is_null());\n             let _directives: Box<Vec<directive::LogDirective>> =\n-                mem::transmute(DIRECTIVES);\n-            DIRECTIVES = ptr::null();\n+                Box::from_raw(DIRECTIVES);\n+            DIRECTIVES = ptr::null_mut();\n \n             if !FILTER.is_null() {\n-                let _filter: Box<String> = mem::transmute(FILTER);\n-                FILTER = 0 as *const _;\n+                let _filter: Box<String> = Box::from_raw(FILTER);\n+                FILTER = 0 as *mut _;\n             }\n         });\n     }"}, {"sha": "46155925b3c72dab922b635ad1b00fd6a67d6f31", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -81,6 +81,8 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     };\n     if s.len() == 0 {\n         err(\"crate name must not be empty\");\n+    } else if s.char_at(0) == '-' {\n+        err(&format!(\"crate name cannot start with a hyphen: {}\", s));\n     }\n     for c in s.chars() {\n         if c.is_alphanumeric() { continue }"}, {"sha": "bb7fd40ced55f18ed587e1a850139650c4247077", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -861,7 +861,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_attributes(rbml_w, &ast_method.attrs);\n             let scheme = ty::lookup_item_type(ecx.tcx, m.def_id);\n             let any_types = !scheme.generics.types.is_empty();\n-            if any_types || is_default_impl || should_inline(&ast_method.attrs) {\n+            if any_types || is_default_impl || attr::requests_inline(&ast_method.attrs) {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n                                                                ast_item_opt.unwrap()));\n             }\n@@ -954,14 +954,6 @@ const FN_FAMILY: char = 'f';\n const STATIC_METHOD_FAMILY: char = 'F';\n const METHOD_FAMILY: char = 'h';\n \n-fn should_inline(attrs: &[ast::Attribute]) -> bool {\n-    use syntax::attr::*;\n-    match find_inline_attr(attrs) {\n-        InlineNone | InlineNever  => false,\n-        InlineHint | InlineAlways => true\n-    }\n-}\n-\n // Encodes the inherent implementations of a structure, enumeration, or trait.\n fn encode_inherent_implementations(ecx: &EncodeContext,\n                                    rbml_w: &mut Encoder,\n@@ -1067,7 +1059,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n-        if tps_len > 0 || should_inline(&item.attrs) {\n+        if tps_len > 0 || attr::requests_inline(&item.attrs) {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n         if tps_len == 0 {"}, {"sha": "7d789bedc50b5c7f869ff943cda25c3315dfec65", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -465,7 +465,8 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n      * Replace all regions bound by `binder` with skolemized regions and\n      * return a map indicating which bound-region was replaced with what\n      * skolemized region. This is the first step of checking subtyping\n-     * when higher-ranked things are involved. See `doc.rs` for more details.\n+     * when higher-ranked things are involved. See `README.md` for more\n+     * details.\n      */\n \n     let (result, map) = ty::replace_late_bound_regions(infcx.tcx, binder, |br| {\n@@ -490,7 +491,7 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n      * and checks to determine whether any of the skolemized regions created\n      * in `skol_map` would \"escape\" -- meaning that they are related to\n      * other regions in some way. If so, the higher-ranked subtyping doesn't\n-     * hold. See `doc.rs` for more details.\n+     * hold. See `README.md` for more details.\n      */\n \n     debug!(\"leak_check: skol_map={}\",\n@@ -533,7 +534,7 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n /// passed; currently, it's used in the trait matching code to create\n /// a set of nested obligations frmo an impl that matches against\n /// something higher-ranked.  More details can be found in\n-/// `middle::traits::doc.rs`.\n+/// `librustc/middle/traits/README.md`.\n ///\n /// As a brief example, consider the obligation `for<'a> Fn(&'a int)\n /// -> &'a int`, and the impl:"}, {"sha": "7800d99f8ed4ce7206bbe9b020b9255ae20d7a70", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See doc.rs\n+//! See README.md\n \n pub use self::Constraint::*;\n pub use self::Verify::*;"}, {"sha": "4fd5a02b05216a4293eb404cbbc8cce2df2db56a", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -26,20 +26,10 @@ use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{is_local, PostExpansionMethod};\n-use syntax::attr::{InlineAlways, InlineHint, InlineNever, InlineNone};\n use syntax::attr;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-// Returns true if the given set of attributes contains the `#[inline]`\n-// attribute.\n-fn attributes_specify_inlining(attrs: &[ast::Attribute]) -> bool {\n-    match attr::find_inline_attr(attrs) {\n-        InlineNone | InlineNever => false,\n-        InlineAlways | InlineHint => true,\n-    }\n-}\n-\n // Returns true if the given set of generics implies that the item it's\n // associated with must be inlined.\n fn generics_require_inlining(generics: &ast::Generics) -> bool {\n@@ -50,7 +40,7 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n fn item_might_be_inlined(item: &ast::Item) -> bool {\n-    if attributes_specify_inlining(&item.attrs) {\n+    if attr::requests_inline(&item.attrs) {\n         return true\n     }\n \n@@ -65,7 +55,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n-    if attributes_specify_inlining(&method.attrs) ||\n+    if attr::requests_inline(&method.attrs) ||\n         generics_require_inlining(method.pe_generics()) {\n         return true\n     }\n@@ -201,8 +191,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match *impl_item {\n                     ast::MethodImplItem(ref method) => {\n                         if generics_require_inlining(method.pe_generics()) ||\n-                                attributes_specify_inlining(\n-                                    &method.attrs) {\n+                                attr::requests_inline(&method.attrs) {\n                             true\n                         } else {\n                             let impl_did = self.tcx"}, {"sha": "7db1138ac72f6e58a168ce6ca3fb08719141208b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -852,7 +852,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n                 // The idea is that call.callee_id represents *the time when\n                 // the invoked function is actually running* and call.id\n                 // represents *the time to prepare the arguments and make the\n-                // call*.  See the section \"Borrows in Calls\" borrowck/doc.rs\n+                // call*.  See the section \"Borrows in Calls\" borrowck/README.md\n                 // for an extended explanation of why this distinction is\n                 // important.\n                 //"}, {"sha": "9ef4a436b8d027b7093178d05c11338bc37ba9f0", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See `doc.rs` for high-level documentation\n+//! See `README.md` for high-level documentation\n \n use super::Normalized;\n use super::SelectionContext;"}, {"sha": "2ce8eeb8f5a9583fc0aab4b74ab91b2234f1eb9d", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See `doc.rs` for high-level documentation\n+//! See `README.md` for high-level documentation\n #![allow(dead_code)] // FIXME -- just temporarily\n \n pub use self::MethodMatchResult::*;\n@@ -547,7 +547,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     //\n     // The selection process begins by examining all in-scope impls,\n     // caller obligations, and so forth and assembling a list of\n-    // candidates. See `doc.rs` and the `Candidate` type for more details.\n+    // candidates. See `README.md` and the `Candidate` type for more\n+    // details.\n \n     fn candidate_from_obligation<'o>(&mut self,\n                                      stack: &TraitObligationStack<'o, 'tcx>)\n@@ -1619,7 +1620,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     //\n     // Confirmation unifies the output type parameters of the trait\n     // with the values found in the obligation, possibly yielding a\n-    // type error.  See `doc.rs` for more details.\n+    // type error.  See `README.md` for more details.\n \n     fn confirm_candidate(&mut self,\n                          obligation: &TraitObligation<'tcx>,"}, {"sha": "ca740f53782192de205ca915ea630785cd62bc1d", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -212,7 +212,7 @@ pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) ->\n           F: FnOnce(T) -> U,\n {\n     let key = arg.clone();\n-    let result = cache.borrow().get(&key).map(|result| result.clone());\n+    let result = cache.borrow().get(&key).cloned();\n     match result {\n         Some(result) => result,\n         None => {"}, {"sha": "08f0897e7617e918e320dedd16d3ae3201cdd45b", "filename": "src/librustc_borrowck/borrowck/README.md", "status": "modified", "additions": 75, "deletions": 126, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -53,8 +53,8 @@ Here `x` represents some variable, `LV.f` is a field reference,\n and `*LV` is a pointer dereference. There is no auto-deref or other\n niceties. This means that if you have a type like:\n \n-```text\n-struct S { f: uint }\n+```rust\n+struct S { f: i32 }\n ```\n \n and a variable `a: Box<S>`, then the rust expression `a.f` would correspond\n@@ -63,8 +63,8 @@ to an `LV` of `(*a).f`.\n Here is the formal grammar for the types we'll consider:\n \n ```text\n-TY = () | S<'LT...> | Box<TY> | & 'LT MQ TY\n-MQ = mut | imm | const\n+TY = i32 | bool | S<'LT...> | Box<TY> | & 'LT MQ TY\n+MQ = mut | imm\n ```\n \n Most of these types should be pretty self explanatory. Here `S` is a\n@@ -82,13 +82,13 @@ SD = struct S<'LT...> { (f: TY)... }\n \n Now, imagine we had a program like this:\n \n-```text\n-struct Foo { f: uint, g: uint }\n+```rust\n+struct Foo { f: i32, g: i32 }\n ...\n 'a: {\n-  let mut x: Box<Foo> = ...;\n-  let y = &mut (*x).f;\n-  x = ...;\n+    let mut x: Box<Foo> = ...;\n+    let y = &mut (*x).f;\n+    x = ...;\n }\n ```\n \n@@ -198,7 +198,7 @@ The kinds of expressions which in-scope loans can render illegal are:\n \n Now that we hopefully have some kind of intuitive feeling for how the\n borrow checker works, let's look a bit more closely now at the precise\n-conditions that it uses. For simplicity I will ignore const loans.\n+conditions that it uses.\n \n I will present the rules in a modified form of standard inference\n rules, which looks as follows:\n@@ -261,12 +261,11 @@ that will go into the final loan. We'll discuss in more detail below.\n ## Checking mutability\n \n Checking mutability is fairly straightforward. We just want to prevent\n-immutable data from being borrowed as mutable. Note that it is ok to\n-borrow mutable data as immutable, since that is simply a\n-freeze. Formally we define a predicate `MUTABLE(LV, MQ)` which, if\n-defined, means that \"borrowing `LV` with mutability `MQ` is ok. The\n-Rust code corresponding to this predicate is the function\n-`check_mutability` in `middle::borrowck::gather_loans`.\n+immutable data from being borrowed as mutable. Note that it is ok to borrow\n+mutable data as immutable, since that is simply a freeze. The judgement\n+`MUTABILITY(LV, MQ)` means the mutability of `LV` is compatible with a borrow\n+of mutability `MQ`. The Rust code corresponding to this predicate is the\n+function `check_mutability` in `middle::borrowck::gather_loans`.\n \n ### Checking mutability of variables\n \n@@ -275,15 +274,14 @@ but also the code in `mem_categorization`.\n \n Let's begin with the rules for variables, which state that if a\n variable is declared as mutable, it may be borrowed any which way, but\n-otherwise the variable must be borrowed as immutable or const:\n+otherwise the variable must be borrowed as immutable:\n \n ```text\n MUTABILITY(X, MQ)                   // M-Var-Mut\n   DECL(X) = mut\n \n-MUTABILITY(X, MQ)                   // M-Var-Imm\n+MUTABILITY(X, imm)                  // M-Var-Imm\n   DECL(X) = imm\n-  MQ = imm | const\n ```\n \n ### Checking mutability of owned content\n@@ -304,12 +302,11 @@ MUTABILITY(*LV, MQ)                 // M-Deref-Unique\n ### Checking mutability of immutable pointer types\n \n Immutable pointer types like `&T` can only\n-be borrowed if MQ is immutable or const:\n+be borrowed if MQ is immutable:\n \n ```text\n-MUTABILITY(*LV, MQ)                // M-Deref-Borrowed-Imm\n+MUTABILITY(*LV, imm)               // M-Deref-Borrowed-Imm\n   TYPE(LV) = &Ty\n-  MQ == imm | const\n ```\n \n ### Checking mutability of mutable pointer types\n@@ -323,12 +320,11 @@ MUTABILITY(*LV, MQ)                 // M-Deref-Borrowed-Mut\n \n ## Checking aliasability\n \n-The goal of the aliasability check is to ensure that we never permit\n-`&mut` borrows of aliasable data. Formally we define a predicate\n-`ALIASABLE(LV, MQ)` which if defined means that\n-\"borrowing `LV` with mutability `MQ` is ok\". The\n-Rust code corresponding to this predicate is the function\n-`check_aliasability()` in `middle::borrowck::gather_loans`.\n+The goal of the aliasability check is to ensure that we never permit `&mut`\n+borrows of aliasable data. The judgement `ALIASABLE(LV, MQ)` means the\n+aliasability of `LV` is compatible with a borrow of mutability `MQ`. The Rust\n+code corresponding to this predicate is the function `check_aliasability()` in\n+`middle::borrowck::gather_loans`.\n \n ### Checking aliasability of variables\n \n@@ -379,48 +375,14 @@ Formally, we define a predicate `LIFETIME(LV, LT, MQ)`, which states that\n `MQ`\". The Rust code corresponding to this predicate is the module\n `middle::borrowck::gather_loans::lifetime`.\n \n-### The Scope function\n-\n-Several of the rules refer to a helper function `SCOPE(LV)=LT`.  The\n-`SCOPE(LV)` yields the lifetime `LT` for which the lvalue `LV` is\n-guaranteed to exist, presuming that no mutations occur.\n-\n-The scope of a local variable is the block where it is declared:\n-\n-```text\n-  SCOPE(X) = block where X is declared\n-```\n-\n-The scope of a field is the scope of the struct:\n-\n-```text\n-  SCOPE(LV.f) = SCOPE(LV)\n-```\n-\n-The scope of a unique referent is the scope of the pointer, since\n-(barring mutation or moves) the pointer will not be freed until\n-the pointer itself `LV` goes out of scope:\n-\n-```text\n-  SCOPE(*LV) = SCOPE(LV) if LV has type Box<T>\n-```\n-\n-The scope of a borrowed referent is the scope associated with the\n-pointer.  This is a conservative approximation, since the data that\n-the pointer points at may actually live longer:\n-\n-```text\n-  SCOPE(*LV) = LT if LV has type &'LT T or &'LT mut T\n-```\n-\n ### Checking lifetime of variables\n \n The rule for variables states that a variable can only be borrowed a\n lifetime `LT` that is a subregion of the variable's scope:\n \n ```text\n LIFETIME(X, LT, MQ)                 // L-Local\n-  LT <= SCOPE(X)\n+  LT <= block where X is declared\n ```\n \n ### Checking lifetime for owned content\n@@ -466,15 +428,12 @@ are computed based on the kind of borrow:\n ```text\n &mut LV =>   RESTRICTIONS(LV, LT, MUTATE|CLAIM|FREEZE)\n &LV =>       RESTRICTIONS(LV, LT, MUTATE|CLAIM)\n-&const LV => RESTRICTIONS(LV, LT, [])\n ```\n \n The reasoning here is that a mutable borrow must be the only writer,\n therefore it prevents other writes (`MUTATE`), mutable borrows\n (`CLAIM`), and immutable borrows (`FREEZE`). An immutable borrow\n permits other immutable borrows but forbids writes and mutable borrows.\n-Finally, a const borrow just wants to be sure that the value is not\n-moved out from under it, so no actions are forbidden.\n \n ### Restrictions for loans of a local variable\n \n@@ -548,8 +507,8 @@ specify that the lifetime of the loan must be less than the lifetime\n of the `&Ty` pointer. In simple cases, this clause is redundant, since\n the `LIFETIME()` function will already enforce the required rule:\n \n-```\n-fn foo(point: &'a Point) -> &'static f32 {\n+```rust\n+fn foo(point: &'a Point) -> &'static i32 {\n     &point.x // Error\n }\n ```\n@@ -558,8 +517,8 @@ The above example fails to compile both because of clause (1) above\n but also by the basic `LIFETIME()` check. However, in more advanced\n examples involving multiple nested pointers, clause (1) is needed:\n \n-```\n-fn foo(point: &'a &'b mut Point) -> &'b f32 {\n+```rust\n+fn foo(point: &'a &'b mut Point) -> &'b i32 {\n     &point.x // Error\n }\n ```\n@@ -577,8 +536,8 @@ which is only `'a`, not `'b`. Hence this example yields an error.\n As a final twist, consider the case of two nested *immutable*\n pointers, rather than a mutable pointer within an immutable one:\n \n-```\n-fn foo(point: &'a &'b Point) -> &'b f32 {\n+```rust\n+fn foo(point: &'a &'b Point) -> &'b i32 {\n     &point.x // OK\n }\n ```\n@@ -599,8 +558,8 @@ The rules pertaining to `LIFETIME` exist to ensure that we don't\n create a borrowed pointer that outlives the memory it points at. So\n `LIFETIME` prevents a function like this:\n \n-```\n-fn get_1<'a>() -> &'a int {\n+```rust\n+fn get_1<'a>() -> &'a i32 {\n     let x = 1;\n     &x\n }\n@@ -619,8 +578,8 @@ after we return and hence the remaining code in `'a` cannot possibly\n mutate it. This distinction is important for type checking functions\n like this one:\n \n-```\n-fn inc_and_get<'a>(p: &'a mut Point) -> &'a int {\n+```rust\n+fn inc_and_get<'a>(p: &'a mut Point) -> &'a i32 {\n     p.x += 1;\n     &p.x\n }\n@@ -641,19 +600,6 @@ in terms of capability, the caller passed in the ability to mutate\n `*p` is borrowed since that would be a move of `p`, as `&mut` pointers\n are affine.)\n \n-### Restrictions for loans of const aliasable referents\n-\n-Freeze pointers are read-only. There may be `&mut` or `&` aliases, and\n-we can not prevent *anything* but moves in that case. So the\n-`RESTRICTIONS` function is only defined if `ACTIONS` is the empty set.\n-Because moves from a `&const` lvalue are never legal, it is not\n-necessary to add any restrictions at all to the final result.\n-\n-```text\n-    RESTRICTIONS(*LV, LT, []) = []                // R-Deref-Freeze-Borrowed\n-      TYPE(LV) = &const Ty\n-```\n-\n ### Restrictions for loans of mutable borrowed referents\n \n Mutable borrowed pointers are guaranteed to be the only way to mutate\n@@ -685,7 +631,7 @@ maximum of `LT'`.\n \n Here is a concrete example of a bug this rule prevents:\n \n-```\n+```rust\n // Test region-reborrow-from-shorter-mut-ref.rs:\n fn copy_pointer<'a,'b,T>(x: &'a mut &'b mut T) -> &'b mut T {\n     &mut **p // ERROR due to clause (1)\n@@ -713,10 +659,10 @@ ways to violate the rules is to move the base pointer to a new name\n and access it via that new name, thus bypassing the restrictions on\n the old name. Here is an example:\n \n-```\n+```rust\n // src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n-fn foo(t0: &mut int) {\n-    let p: &int = &*t0; // Freezes `*t0`\n+fn foo(t0: &mut i32) {\n+    let p: &i32 = &*t0; // Freezes `*t0`\n     let t1 = t0;        //~ ERROR cannot move out of `t0`\n     *t1 = 22;           // OK, not a write through `*t0`\n }\n@@ -733,11 +679,11 @@ danger is to mutably borrow the base path. This can lead to two bad\n scenarios. The most obvious is that the mutable borrow itself becomes\n another path to access the same data, as shown here:\n \n-```\n+```rust\n // src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut int,\n-           mut t1: &'a mut int) {\n-    let p: &int = &*t0;     // Freezes `*t0`\n+fn foo<'a>(mut t0: &'a mut i32,\n+           mut t1: &'a mut i32) {\n+    let p: &i32 = &*t0;     // Freezes `*t0`\n     let mut t2 = &mut t0;   //~ ERROR cannot borrow `t0`\n     **t2 += 1;              // Mutates `*t0`\n }\n@@ -754,11 +700,11 @@ of `t0`. Hence the claim `&mut t0` is illegal.\n Another danger with an `&mut` pointer is that we could swap the `t0`\n value away to create a new path:\n \n-```\n+```rust\n // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut int,\n-           mut t1: &'a mut int) {\n-    let p: &int = &*t0;     // Freezes `*t0`\n+fn foo<'a>(mut t0: &'a mut i32,\n+           mut t1: &'a mut i32) {\n+    let p: &i32 = &*t0;     // Freezes `*t0`\n     swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n     *t1 = 22;\n }\n@@ -772,37 +718,37 @@ careful to ensure this example is still illegal.\n referent is claimed, even freezing the base pointer can be dangerous,\n as shown in the following example:\n \n-```\n+```rust\n // src/test/compile-fail/borrowck-borrow-of-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut int,\n-           mut t1: &'a mut int) {\n-    let p: &mut int = &mut *t0; // Claims `*t0`\n+fn foo<'a>(mut t0: &'a mut i32,\n+           mut t1: &'a mut i32) {\n+    let p: &mut i32 = &mut *t0; // Claims `*t0`\n     let mut t2 = &t0;           //~ ERROR cannot borrow `t0`\n-    let q: &int = &*t2;         // Freezes `*t0` but not through `*p`\n+    let q: &i32 = &*t2;         // Freezes `*t0` but not through `*p`\n     *p += 1;                    // violates type of `*q`\n }\n ```\n \n Here the problem is that `*t0` is claimed by `p`, and hence `p` wants\n to be the controlling pointer through which mutation or freezes occur.\n-But `t2` would -- if it were legal -- have the type `& &mut int`, and\n+But `t2` would -- if it were legal -- have the type `& &mut i32`, and\n hence would be a mutable pointer in an aliasable location, which is\n considered frozen (since no one can write to `**t2` as it is not a\n-unique path). Therefore, we could reasonably create a frozen `&int`\n+unique path). Therefore, we could reasonably create a frozen `&i32`\n pointer pointing at `*t0` that coexists with the mutable pointer `p`,\n which is clearly unsound.\n \n However, it is not always unsafe to freeze the base pointer. In\n particular, if the referent is frozen, there is no harm in it:\n \n-```\n+```rust\n // src/test/run-pass/borrowck-borrow-of-mut-base-ptr-safe.rs\n-fn foo<'a>(mut t0: &'a mut int,\n-           mut t1: &'a mut int) {\n-    let p: &int = &*t0; // Freezes `*t0`\n+fn foo<'a>(mut t0: &'a mut i32,\n+           mut t1: &'a mut i32) {\n+    let p: &i32 = &*t0; // Freezes `*t0`\n     let mut t2 = &t0;\n-    let q: &int = &*t2; // Freezes `*t0`, but that's ok...\n-    let r: &int = &*t0; // ...after all, could do same thing directly.\n+    let q: &i32 = &*t2; // Freezes `*t0`, but that's ok...\n+    let r: &i32 = &*t0; // ...after all, could do same thing directly.\n }\n ```\n \n@@ -811,11 +757,11 @@ thing `t2` can be used for is to further freeze `*t0`, which is\n already frozen. In particular, we cannot assign to `*t0` through the\n new alias `t2`, as demonstrated in this test case:\n \n-```\n+```rust\n // src/test/run-pass/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs\n-fn foo(t0: & &mut int) {\n+fn foo(t0: & &mut i32) {\n     let t1 = t0;\n-    let p: &int = &**t0;\n+    let p: &i32 = &**t0;\n     **t1 = 22; //~ ERROR cannot assign\n }\n ```\n@@ -855,6 +801,9 @@ prohibited from both freezes and claims. This would avoid the need to\n prevent `const` borrows of the base pointer when the referent is\n borrowed.\n \n+[ Previous revisions of this document discussed `&const` in more detail.\n+See the revision history. ]\n+\n # Moves and initialization\n \n The borrow checker is also in charge of ensuring that:\n@@ -881,9 +830,9 @@ moves/uninitializations of the variable that is being used.\n \n Let's look at a simple example:\n \n-```\n-fn foo(a: Box<int>) {\n-    let b: Box<int>;   // Gen bit 0.\n+```rust\n+fn foo(a: Box<i32>) {\n+    let b: Box<i32>;   // Gen bit 0.\n \n     if cond {          // Bits: 0\n         use(&*a);\n@@ -897,7 +846,7 @@ fn foo(a: Box<int>) {\n     use(&*b);          // Error.\n }\n \n-fn use(a: &int) { }\n+fn use(a: &i32) { }\n ```\n \n In this example, the variable `b` is created uninitialized. In one\n@@ -1028,8 +977,8 @@ not) the destructor invocation for that path.\n A simple example of this is the following:\n \n ```rust\n-struct D { p: int }\n-impl D { fn new(x: int) -> D { ... }\n+struct D { p: i32 }\n+impl D { fn new(x: i32) -> D { ... }\n impl Drop for D { ... }\n \n fn foo(a: D, b: D, t: || -> bool) {\n@@ -1142,7 +1091,7 @@ the elements of an array that has been passed by value, such as\n the following:\n \n ```rust\n-fn foo(a: [D; 10], i: uint) -> D {\n+fn foo(a: [D; 10], i: i32) -> D {\n     a[i]\n }\n ```\n@@ -1158,7 +1107,7 @@ all-but-one element of the array.  A place where that distinction\n would arise is the following:\n \n ```rust\n-fn foo(a: [D; 10], b: [D; 10], i: uint, t: bool) -> D {\n+fn foo(a: [D; 10], b: [D; 10], i: i32, t: bool) -> D {\n     if t {\n         a[i]\n     } else {\n@@ -1173,7 +1122,7 @@ fn foo(a: [D; 10], b: [D; 10], i: uint, t: bool) -> D {\n \n There are a number of ways that the trans backend could choose to\n compile this (e.g. a `[bool; 10]` array for each such moved array;\n-or an `Option<uint>` for each moved array).  From the viewpoint of the\n+or an `Option<usize>` for each moved array).  From the viewpoint of the\n borrow-checker, the important thing is to record what kind of fragment\n is implied by the relevant moves.\n "}, {"sha": "8cb4090bf39290ed2330f78d21527e05790d449f", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -10,7 +10,7 @@\n \n //! Helper routines used for fragmenting structural paths due to moves for\n //! tracking drop obligations. Please see the extensive comments in the\n-//! section \"Structural fragments\" in `doc.rs`.\n+//! section \"Structural fragments\" in `README.md`.\n \n use self::Fragment::*;\n "}, {"sha": "9f7b4cf26e1c47fa60dabc40b6bdc37abb10c293", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -106,8 +106,6 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         //! lvalue `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n \n-        // See the SCOPE(LV) function in doc.rs\n-\n         match cmt.cat {\n             mc::cat_rvalue(temp_scope) => {\n                 temp_scope"}, {"sha": "d51ad6e0c97b5f3b9a44b73454add2b96f471eae", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -173,7 +173,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n }\n \n-/// Implements the A-* rules in doc.rs.\n+/// Implements the A-* rules in README.md.\n fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 borrow_span: Span,\n                                 loan_cause: euv::LoanCause,\n@@ -375,7 +375,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                                       cmt: mc::cmt<'tcx>,\n                                       req_kind: ty::BorrowKind)\n                                       -> Result<(),()> {\n-            //! Implements the M-* rules in doc.rs.\n+            //! Implements the M-* rules in README.md.\n \n             match req_kind {\n                 ty::UniqueImmBorrow | ty::ImmBorrow => {"}, {"sha": "fd7880212f10b24e292a738d94fdcaaec4a36993", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -295,7 +295,7 @@ impl<'tcx> PartialEq for LoanPath<'tcx> {\n \n #[derive(PartialEq, Eq, Hash, Debug)]\n pub enum LoanPathKind<'tcx> {\n-    LpVar(ast::NodeId),                         // `x` in doc.rs\n+    LpVar(ast::NodeId),                         // `x` in README.md\n     LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n     LpDowncast(Rc<LoanPath<'tcx>>, ast::DefId), // `x` downcast to particular enum variant\n     LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem)\n@@ -336,8 +336,8 @@ impl ToInteriorKind for mc::InteriorKind {\n \n #[derive(Copy, PartialEq, Eq, Hash, Debug)]\n pub enum LoanPathElem {\n-    LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n-    LpInterior(InteriorKind),    // `LV.f` in doc.rs\n+    LpDeref(mc::PointerKind),    // `*LV` in README.md\n+    LpInterior(InteriorKind),    // `LV.f` in README.md\n }\n \n pub fn closure_to_block(closure_id: ast::NodeId,"}, {"sha": "0f7f8e61e37e0a1788c2a20ae0d79a48fd14ff22", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //! Data structures used for tracking moves. Please see the extensive\n-//! comments in the section \"Moves and initialization\" in `doc.rs`.\n+//! comments in the section \"Moves and initialization\" in `README.md`.\n \n pub use self::MoveKind::*;\n \n@@ -33,7 +33,7 @@ use syntax::codemap::Span;\n pub mod fragments;\n \n pub struct MoveData<'tcx> {\n-    /// Move paths. See section \"Move paths\" in `doc.rs`.\n+    /// Move paths. See section \"Move paths\" in `README.md`.\n     pub paths: RefCell<Vec<MovePath<'tcx>>>,\n \n     /// Cache of loan path to move path index, for easy lookup.\n@@ -464,7 +464,7 @@ impl<'tcx> MoveData<'tcx> {\n     /// assignments into the provided data flow contexts.\n     /// Moves are generated by moves and killed by assignments and\n     /// scoping. Assignments are generated by assignment to variables and\n-    /// killed by scoping. See `doc.rs` for more details.\n+    /// killed by scoping. See `README.md` for more details.\n     fn add_gen_kills(&self,\n                      tcx: &ty::ctxt<'tcx>,\n                      dfcx_moves: &mut MoveDataFlow,"}, {"sha": "59fca4b03188662d5146b6ad5228e4a6ca3b2d94", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -663,23 +663,21 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         match typ.node {\n             // Common case impl for a struct or something basic.\n             ast::TyPath(ref path, id) => {\n-                match self.lookup_type_ref(id) {\n-                    Some(id) => {\n-                        let sub_span = self.span.sub_span_for_type_name(path.span);\n-                        self.fmt.ref_str(recorder::TypeRef,\n-                                         path.span,\n-                                         sub_span,\n-                                         id,\n-                                         self.cur_scope);\n-                        self.fmt.impl_str(path.span,\n-                                          sub_span,\n-                                          item.id,\n-                                          Some(id),\n-                                          trait_id,\n-                                          self.cur_scope);\n-                    },\n-                    None => ()\n-                }\n+                let sub_span = self.span.sub_span_for_type_name(path.span);\n+                let self_id = self.lookup_type_ref(id).map(|id| {\n+                    self.fmt.ref_str(recorder::TypeRef,\n+                                     path.span,\n+                                     sub_span,\n+                                     id,\n+                                     self.cur_scope);\n+                    id\n+                });\n+                self.fmt.impl_str(path.span,\n+                                  sub_span,\n+                                  item.id,\n+                                  self_id,\n+                                  trait_id,\n+                                  self.cur_scope);\n             },\n             _ => {\n                 // Less useful case, impl for a compound type.\n@@ -1002,28 +1000,39 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             ast::PatStruct(ref path, ref fields, _) => {\n                 self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n                 visit::walk_path(self, path);\n-                let struct_def = match self.lookup_type_ref(p.id) {\n-                    Some(sd) => sd,\n-                    None => {\n-                        self.sess.span_bug(p.span,\n-                                           &format!(\"Could not find struct_def for `{}`\",\n-                                                   self.span.snippet(p.span)));\n+\n+                let def = self.analysis.ty_cx.def_map.borrow()[p.id];\n+                let struct_def = match def {\n+                    def::DefConst(..) => None,\n+                    def::DefVariant(_, variant_id, _) => Some(variant_id),\n+                    _ => {\n+                        match ty::ty_to_def_id(ty::node_id_to_type(&self.analysis.ty_cx, p.id)) {\n+                            None => {\n+                                self.sess.span_bug(p.span,\n+                                                   &format!(\"Could not find struct_def for `{}`\",\n+                                                            self.span.snippet(p.span)));\n+                            }\n+                            Some(def_id) => Some(def_id),\n+                        }\n                     }\n                 };\n-                for &Spanned { node: ref field, span } in fields {\n-                    let sub_span = self.span.span_for_first_ident(span);\n-                    let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n-                    for f in fields {\n-                        if f.name == field.ident.name {\n-                            self.fmt.ref_str(recorder::VarRef,\n-                                             span,\n-                                             sub_span,\n-                                             f.id,\n-                                             self.cur_scope);\n-                            break;\n+\n+                if let Some(struct_def) = struct_def {\n+                    let struct_fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n+                    for &Spanned { node: ref field, span } in fields {\n+                        let sub_span = self.span.span_for_first_ident(span);\n+                        for f in &struct_fields {\n+                            if f.name == field.ident.name {\n+                                self.fmt.ref_str(recorder::VarRef,\n+                                                 span,\n+                                                 sub_span,\n+                                                 f.id,\n+                                                 self.cur_scope);\n+                                break;\n+                            }\n                         }\n+                        self.visit_pat(&*field.pat);\n                     }\n-                    self.visit_pat(&*field.pat);\n                 }\n             }\n             ast::PatEnum(ref path, _) => {"}, {"sha": "35b6ca7f0f5114770e90555d0b47926c6bcad8d4", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -301,7 +301,7 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                    self_type.repr(ccx.tcx()));\n             (&function_type.sig, RustCall, Some(llenvironment_type))\n         }\n-        _ => panic!(\"expected closure or fn\")\n+        _ => ccx.sess().bug(\"expected closure or fn\")\n     };\n \n     let sig = ty::erase_late_bound_regions(ccx.tcx(), sig);\n@@ -435,7 +435,7 @@ pub fn set_inline_hint(f: ValueRef) {\n pub fn set_llvm_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRef) {\n     use syntax::attr::*;\n     // Set the inline hint if there is one\n-    match find_inline_attr(attrs) {\n+    match find_inline_attr(Some(ccx.sess().diagnostic()), attrs) {\n         InlineHint   => set_inline_hint(llfn),\n         InlineAlways => set_always_inline(llfn),\n         InlineNever  => set_no_inline(llfn),\n@@ -2410,12 +2410,15 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                          node_id: ast::NodeId,\n                          node_type: Ty<'tcx>)\n                          -> ValueRef {\n-    match node_type.sty {\n-        ty::ty_bare_fn(_, ref f) => {\n-            assert!(f.abi == Rust || f.abi == RustCall);\n+    if let ty::ty_bare_fn(_, ref f) = node_type.sty {\n+        if f.abi != Rust && f.abi != RustCall {\n+            ccx.sess().span_bug(sp, &format!(\"only the `{}` or `{}` calling conventions are valid \\\n+                                              for this function; `{}` was specified\",\n+                                              Rust.name(), RustCall.name(), f.abi.name()));\n         }\n-        _ => panic!(\"expected bare rust fn\")\n-    };\n+    } else {\n+        ccx.sess().span_bug(sp, \"expected bare rust function\")\n+    }\n \n     let llfn = decl_rust_fn(ccx, node_type, &sym[..]);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n@@ -2802,7 +2805,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     llfn\n                 }\n \n-                _ => panic!(\"get_item_val: weird result in table\")\n+                _ => ccx.sess().bug(\"get_item_val: weird result in table\")\n             };\n \n             match attr::first_attr_value_str_by_name(&i.attrs,\n@@ -2866,7 +2869,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let args = match v.node.kind {\n                 ast::TupleVariantKind(ref args) => args,\n                 ast::StructVariantKind(_) => {\n-                    panic!(\"struct variant kind unexpected in get_item_val\")\n+                    ccx.sess().bug(\"struct variant kind unexpected in get_item_val\")\n                 }\n             };\n             assert!(args.len() != 0);\n@@ -2882,7 +2885,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 ast::ItemEnum(_, _) => {\n                     register_fn(ccx, (*v).span, sym, id, ty)\n                 }\n-                _ => panic!(\"NodeVariant, shouldn't happen\")\n+                _ => ccx.sess().bug(\"NodeVariant, shouldn't happen\")\n             };\n             set_inline_hint(llfn);\n             llfn\n@@ -2935,9 +2938,17 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n \n     let sym = exported_name(ccx, id, mty, &m.attrs);\n \n-    let llfn = register_fn(ccx, m.span, sym, id, mty);\n-    set_llvm_fn_attrs(ccx, &m.attrs, llfn);\n-    llfn\n+    if let ty::ty_bare_fn(_, ref f) = mty.sty {\n+        let llfn = if f.abi == Rust || f.abi == RustCall {\n+            register_fn(ccx, m.span, sym, id, mty)\n+        } else {\n+            foreign::register_rust_fn_with_foreign_abi(ccx, m.span, sym, id)\n+        };\n+        set_llvm_fn_attrs(ccx, &m.attrs, llfn);\n+        return llfn;\n+    } else {\n+        ccx.sess().span_bug(m.span, \"expected bare rust function\");\n+    }\n }\n \n pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'tcx>,"}, {"sha": "25568db814824da35738eaa01acc4b99b2e61cd6", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -765,8 +765,16 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     if is_rust_fn {\n         let mut llargs = Vec::new();\n \n-        if let (ty::FnConverging(ret_ty), Some(llretslot)) = (ret_ty, opt_llretslot) {\n+        if let (ty::FnConverging(ret_ty), Some(mut llretslot)) = (ret_ty, opt_llretslot) {\n             if type_of::return_uses_outptr(ccx, ret_ty) {\n+                let llformal_ret_ty = type_of::type_of(ccx, ret_ty).ptr_to();\n+                let llret_ty = common::val_ty(llretslot);\n+                if llformal_ret_ty != llret_ty {\n+                    // this could happen due to e.g. subtyping\n+                    debug!(\"casting actual return type ({}) to match formal ({})\",\n+                        bcx.llty_str(llret_ty), bcx.llty_str(llformal_ret_ty));\n+                    llretslot = PointerCast(bcx, llretslot, llformal_ret_ty);\n+                }\n                 llargs.push(llretslot);\n             }\n         }"}, {"sha": "e0598583a1954f61ac2e33854f95f64fa81b684c", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -122,7 +122,7 @@ use syntax::codemap::DUMMY_SP;\n /// A `Datum` encapsulates the result of evaluating an expression.  It\n /// describes where the value is stored, what Rust type the value has,\n /// whether it is addressed by reference, and so forth. Please refer\n-/// the section on datums in `doc.rs` for more details.\n+/// the section on datums in `README.md` for more details.\n #[derive(Clone, Copy)]\n pub struct Datum<'tcx, K> {\n     /// The llvm value.  This is either a pointer to the Rust value or"}, {"sha": "256cd415a33afbf9a07ea87a8042cdd794e8f328", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Method lookup: the secret sauce of Rust. See `doc.rs`.\n+//! Method lookup: the secret sauce of Rust. See `README.md`.\n \n use astconv::AstConv;\n use check::{FnCtxt};"}, {"sha": "df2fb538c0a5080d034e72fd0fac78f5cb71cf25", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -203,7 +203,7 @@ fn test_resize_policy() {\n // produces identical results to a linear naive reinsertion from the same\n // element.\n //\n-// FIXME(Gankro, pczarn): review the proof and put it all in a separate doc.rs\n+// FIXME(Gankro, pczarn): review the proof and put it all in a separate README.md\n \n /// A hash map implementation which uses linear probing with Robin\n /// Hood bucket stealing."}, {"sha": "100d3e6ed4aa9c5c6afb095c293b3e1c6ee8fe7e", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -23,9 +23,9 @@\n //!\n //! Rust's collections can be grouped into four major categories:\n //!\n-//! * Sequences: `Vec`, `VecDeque`, `LinkedList`, `BitV`\n+//! * Sequences: `Vec`, `VecDeque`, `LinkedList`, `BitVec`\n //! * Maps: `HashMap`, `BTreeMap`, `VecMap`\n-//! * Sets: `HashSet`, `BTreeSet`, `BitVSet`\n+//! * Sets: `HashSet`, `BTreeSet`, `BitSet`\n //! * Misc: `BinaryHeap`\n //!\n //! # When Should You Use Which Collection?\n@@ -73,11 +73,11 @@\n //! * There is no meaningful value to associate with your keys.\n //! * You just want a set.\n //!\n-//! ### Use a `BitV` when:\n+//! ### Use a `BitVec` when:\n //! * You want to store an unbounded number of booleans in a small space.\n //! * You want a bit vector.\n //!\n-//! ### Use a `BitVSet` when:\n+//! ### Use a `BitSet` when:\n //! * You want a `VecSet`.\n //!\n //! ### Use a `BinaryHeap` when:"}, {"sha": "69bcc82f6827570f61226dc0e241a0b4de023d5c", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -224,7 +224,7 @@ impl CString {\n     /// Returns the contents of this `CString` as a slice of bytes.\n     ///\n     /// The returned slice does **not** contain the trailing nul separator and\n-    /// it is guaranteet to not have any interior nul bytes.\n+    /// it is guaranteed to not have any interior nul bytes.\n     pub fn as_bytes(&self) -> &[u8] {\n         &self.inner[..self.inner.len() - 1]\n     }\n@@ -333,7 +333,7 @@ impl CStr {\n     /// Return the inner pointer to this C string.\n     ///\n     /// The returned pointer will be valid for as long as `self` is and points\n-    /// to a continguous region of memory terminated with a 0 byte to represent\n+    /// to a contiguous region of memory terminated with a 0 byte to represent\n     /// the end of the string.\n     pub fn as_ptr(&self) -> *const libc::c_char {\n         self.inner.as_ptr()\n@@ -371,7 +371,7 @@ impl CStr {\n \n impl PartialEq for CStr {\n     fn eq(&self, other: &CStr) -> bool {\n-        self.to_bytes().eq(&other.to_bytes())\n+        self.to_bytes().eq(other.to_bytes())\n     }\n }\n impl Eq for CStr {}"}, {"sha": "3b4e15953c4613958adfea8d2015625ae32e0017", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -669,13 +669,33 @@ impl<T> Take<T> {\n \n impl<T: Read> Read for Take<T> {\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n+        // Don't call into inner reader at all at EOF because it may still block\n+        if self.limit == 0 {\n+            return Ok(0);\n+        }\n+\n         let max = cmp::min(buf.len() as u64, self.limit) as usize;\n         let n = try!(self.inner.read(&mut buf[..max]));\n         self.limit -= n as u64;\n         Ok(n)\n     }\n }\n \n+impl<T: BufRead> BufRead for Take<T> {\n+    fn fill_buf(&mut self) -> Result<&[u8]> {\n+        let buf = try!(self.inner.fill_buf());\n+        let cap = cmp::min(buf.len() as u64, self.limit) as usize;\n+        Ok(&buf[..cap])\n+    }\n+\n+    fn consume(&mut self, amt: usize) {\n+        // Don't let callers reset the limit by passing an overlarge value\n+        let amt = cmp::min(amt as u64, self.limit) as usize;\n+        self.limit -= amt as u64;\n+        self.inner.consume(amt);\n+    }\n+}\n+\n /// An adaptor which will emit all read data to a specified writer as well.\n ///\n /// For more information see `ReadExt::tee`\n@@ -846,6 +866,7 @@ impl<B: BufRead> Iterator for Lines<B> {\n mod tests {\n     use prelude::v1::*;\n     use io::prelude::*;\n+    use io;\n     use super::Cursor;\n \n     #[test]\n@@ -943,4 +964,18 @@ mod tests {\n         let mut v = String::new();\n         assert!(c.read_to_string(&mut v).is_err());\n     }\n+\n+    #[test]\n+    fn take_eof() {\n+        struct R;\n+\n+        impl Read for R {\n+            fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+                Err(io::Error::new(io::ErrorKind::Other, \"\", None))\n+            }\n+        }\n+\n+        let mut buf = [0; 1];\n+        assert_eq!(Ok(0), R.take(0).read(&mut buf));\n+    }\n }"}, {"sha": "caaedeeb2fc5469a2cbdb5ec75a4fbaccc0fdb15", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -122,6 +122,7 @@\n #![feature(unsafe_destructor)]\n #![feature(unsafe_no_drop_flag)]\n #![feature(macro_reexport)]\n+#![feature(hash)]\n #![cfg_attr(test, feature(test, rustc_private, env))]\n \n // Don't link to std. We are std."}, {"sha": "15ae8b027e128a20451ebc5c8a408ae008f5b42e", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -1751,6 +1751,72 @@ mod tests {\n         assert_pow!((8,     3 ) => 512);\n         assert_pow!((2u64,   50) => 1125899906842624);\n     }\n+\n+    #[test]\n+    fn test_uint_to_str_overflow() {\n+        let mut u8_val: u8 = 255_u8;\n+        assert_eq!(u8_val.to_string(), \"255\");\n+\n+        u8_val += 1 as u8;\n+        assert_eq!(u8_val.to_string(), \"0\");\n+\n+        let mut u16_val: u16 = 65_535_u16;\n+        assert_eq!(u16_val.to_string(), \"65535\");\n+\n+        u16_val += 1 as u16;\n+        assert_eq!(u16_val.to_string(), \"0\");\n+\n+        let mut u32_val: u32 = 4_294_967_295_u32;\n+        assert_eq!(u32_val.to_string(), \"4294967295\");\n+\n+        u32_val += 1 as u32;\n+        assert_eq!(u32_val.to_string(), \"0\");\n+\n+        let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n+        assert_eq!(u64_val.to_string(), \"18446744073709551615\");\n+\n+        u64_val += 1 as u64;\n+        assert_eq!(u64_val.to_string(), \"0\");\n+    }\n+\n+    fn from_str<T: ::str::FromStr>(t: &str) -> Option<T> {\n+        ::str::FromStr::from_str(t).ok()\n+    }\n+\n+    #[test]\n+    fn test_uint_from_str_overflow() {\n+        let mut u8_val: u8 = 255_u8;\n+        assert_eq!(from_str::<u8>(\"255\"), Some(u8_val));\n+        assert_eq!(from_str::<u8>(\"256\"), None);\n+\n+        u8_val += 1 as u8;\n+        assert_eq!(from_str::<u8>(\"0\"), Some(u8_val));\n+        assert_eq!(from_str::<u8>(\"-1\"), None);\n+\n+        let mut u16_val: u16 = 65_535_u16;\n+        assert_eq!(from_str::<u16>(\"65535\"), Some(u16_val));\n+        assert_eq!(from_str::<u16>(\"65536\"), None);\n+\n+        u16_val += 1 as u16;\n+        assert_eq!(from_str::<u16>(\"0\"), Some(u16_val));\n+        assert_eq!(from_str::<u16>(\"-1\"), None);\n+\n+        let mut u32_val: u32 = 4_294_967_295_u32;\n+        assert_eq!(from_str::<u32>(\"4294967295\"), Some(u32_val));\n+        assert_eq!(from_str::<u32>(\"4294967296\"), None);\n+\n+        u32_val += 1 as u32;\n+        assert_eq!(from_str::<u32>(\"0\"), Some(u32_val));\n+        assert_eq!(from_str::<u32>(\"-1\"), None);\n+\n+        let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n+        assert_eq!(from_str::<u64>(\"18446744073709551615\"), Some(u64_val));\n+        assert_eq!(from_str::<u64>(\"18446744073709551616\"), None);\n+\n+        u64_val += 1 as u64;\n+        assert_eq!(from_str::<u64>(\"0\"), Some(u64_val));\n+        assert_eq!(from_str::<u64>(\"-1\"), None);\n+    }\n }\n \n "}, {"sha": "c9e6a8f66d1d25cb01e50a4a67c9f20873cdfbbb", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -48,68 +48,6 @@ mod tests {\n         assert_eq!(FromStrRadix::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n         assert_eq!(FromStrRadix::from_str_radix(\"_\", 2).ok(), None::<$T>);\n     }\n-\n-    #[test]\n-    fn test_uint_to_str_overflow() {\n-        let mut u8_val: u8 = 255_u8;\n-        assert_eq!(u8_val.to_string(), \"255\");\n-\n-        u8_val += 1 as u8;\n-        assert_eq!(u8_val.to_string(), \"0\");\n-\n-        let mut u16_val: u16 = 65_535_u16;\n-        assert_eq!(u16_val.to_string(), \"65535\");\n-\n-        u16_val += 1 as u16;\n-        assert_eq!(u16_val.to_string(), \"0\");\n-\n-        let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert_eq!(u32_val.to_string(), \"4294967295\");\n-\n-        u32_val += 1 as u32;\n-        assert_eq!(u32_val.to_string(), \"0\");\n-\n-        let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert_eq!(u64_val.to_string(), \"18446744073709551615\");\n-\n-        u64_val += 1 as u64;\n-        assert_eq!(u64_val.to_string(), \"0\");\n-    }\n-\n-    #[test]\n-    fn test_uint_from_str_overflow() {\n-        let mut u8_val: u8 = 255_u8;\n-        assert_eq!(from_str::<u8>(\"255\"), Some(u8_val));\n-        assert_eq!(from_str::<u8>(\"256\"), None);\n-\n-        u8_val += 1 as u8;\n-        assert_eq!(from_str::<u8>(\"0\"), Some(u8_val));\n-        assert_eq!(from_str::<u8>(\"-1\"), None);\n-\n-        let mut u16_val: u16 = 65_535_u16;\n-        assert_eq!(from_str::<u16>(\"65535\"), Some(u16_val));\n-        assert_eq!(from_str::<u16>(\"65536\"), None);\n-\n-        u16_val += 1 as u16;\n-        assert_eq!(from_str::<u16>(\"0\"), Some(u16_val));\n-        assert_eq!(from_str::<u16>(\"-1\"), None);\n-\n-        let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert_eq!(from_str::<u32>(\"4294967295\"), Some(u32_val));\n-        assert_eq!(from_str::<u32>(\"4294967296\"), None);\n-\n-        u32_val += 1 as u32;\n-        assert_eq!(from_str::<u32>(\"0\"), Some(u32_val));\n-        assert_eq!(from_str::<u32>(\"-1\"), None);\n-\n-        let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert_eq!(from_str::<u64>(\"18446744073709551615\"), Some(u64_val));\n-        assert_eq!(from_str::<u64>(\"18446744073709551616\"), None);\n-\n-        u64_val += 1 as u64;\n-        assert_eq!(from_str::<u64>(\"0\"), Some(u64_val));\n-        assert_eq!(from_str::<u64>(\"-1\"), None);\n-    }\n }\n \n ) }"}, {"sha": "56a707c24a6c9789c5c8b751e31759d91c7fef5f", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -27,6 +27,7 @@\n \n use self::StdSource::*;\n \n+use boxed;\n use boxed::Box;\n use cell::RefCell;\n use clone::Clone;\n@@ -218,7 +219,7 @@ impl Reader for StdinReader {\n /// See `stdout()` for more notes about this function.\n pub fn stdin() -> StdinReader {\n     // We're following the same strategy as kimundi's lazy_static library\n-    static mut STDIN: *const StdinReader = 0 as *const StdinReader;\n+    static mut STDIN: *mut StdinReader = 0 as *mut StdinReader;\n     static ONCE: Once = ONCE_INIT;\n \n     unsafe {\n@@ -235,12 +236,12 @@ pub fn stdin() -> StdinReader {\n             let stdin = StdinReader {\n                 inner: Arc::new(Mutex::new(RaceBox(stdin)))\n             };\n-            STDIN = mem::transmute(box stdin);\n+            STDIN = boxed::into_raw(box stdin);\n \n             // Make sure to free it at exit\n             rt::at_exit(|| {\n-                mem::transmute::<_, Box<StdinReader>>(STDIN);\n-                STDIN = ptr::null();\n+                Box::from_raw(STDIN);\n+                STDIN = ptr::null_mut();\n             });\n         });\n "}, {"sha": "08755ba829f8f9af3958b4a18ff1fb2d31bfda23", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -14,9 +14,9 @@\n \n use core::prelude::*;\n \n+use boxed;\n use boxed::Box;\n use vec::Vec;\n-use mem;\n use thunk::Thunk;\n use sys_common::mutex::{Mutex, MUTEX_INIT};\n \n@@ -32,7 +32,7 @@ static mut QUEUE: *mut Queue = 0 as *mut Queue;\n unsafe fn init() {\n     if QUEUE.is_null() {\n         let state: Box<Queue> = box Vec::new();\n-        QUEUE = mem::transmute(state);\n+        QUEUE = boxed::into_raw(state);\n     } else {\n         // can't re-init after a cleanup\n         rtassert!(QUEUE as uint != 1);\n@@ -57,7 +57,7 @@ pub fn cleanup() {\n \n         // If we never called init, not need to cleanup!\n         if queue as uint != 0 {\n-            let queue: Box<Queue> = mem::transmute(queue);\n+            let queue: Box<Queue> = Box::from_raw(queue);\n             for to_run in *queue {\n                 to_run.invoke(());\n             }"}, {"sha": "4dda3ea8c998800e94cde11c237296ab2ee502da", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -60,6 +60,7 @@\n use prelude::v1::*;\n \n use any::Any;\n+use boxed;\n use cell::Cell;\n use cmp;\n use panicking;\n@@ -173,15 +174,16 @@ fn rust_panic(cause: Box<Any + Send + 'static>) -> ! {\n             },\n             cause: Some(cause),\n         };\n-        let error = uw::_Unwind_RaiseException(mem::transmute(exception));\n+        let exception_param = boxed::into_raw(exception) as *mut uw::_Unwind_Exception;\n+        let error = uw::_Unwind_RaiseException(exception_param);\n         rtabort!(\"Could not unwind stack, error = {}\", error as int)\n     }\n \n     extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n                                 exception: *mut uw::_Unwind_Exception) {\n         rtdebug!(\"exception_cleanup()\");\n         unsafe {\n-            let _: Box<Exception> = mem::transmute(exception);\n+            let _: Box<Exception> = Box::from_raw(exception as *mut Exception);\n         }\n     }\n }"}, {"sha": "59fa2e6bc9a91c31dc28cc60f8e3ad8b0dfd9861", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -44,8 +44,8 @@ pub use self::PopResult::*;\n \n use core::prelude::*;\n \n+use alloc::boxed;\n use alloc::boxed::Box;\n-use core::mem;\n use core::ptr;\n use core::cell::UnsafeCell;\n \n@@ -82,7 +82,7 @@ unsafe impl<T: Send> Sync for Queue<T> { }\n \n impl<T> Node<T> {\n     unsafe fn new(v: Option<T>) -> *mut Node<T> {\n-        mem::transmute(box Node {\n+        boxed::into_raw(box Node {\n             next: AtomicPtr::new(ptr::null_mut()),\n             value: v,\n         })\n@@ -129,7 +129,7 @@ impl<T: Send> Queue<T> {\n                 assert!((*tail).value.is_none());\n                 assert!((*next).value.is_some());\n                 let ret = (*next).value.take().unwrap();\n-                let _: Box<Node<T>> = mem::transmute(tail);\n+                let _: Box<Node<T>> = Box::from_raw(tail);\n                 return Data(ret);\n             }\n \n@@ -146,7 +146,7 @@ impl<T: Send> Drop for Queue<T> {\n             let mut cur = *self.tail.get();\n             while !cur.is_null() {\n                 let next = (*cur).next.load(Ordering::Relaxed);\n-                let _: Box<Node<T>> = mem::transmute(cur);\n+                let _: Box<Node<T>> = Box::from_raw(cur);\n                 cur = next;\n             }\n         }"}, {"sha": "7b5c614536df98617c32c33af432ad9b7c75e7c7", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -37,8 +37,8 @@\n \n use core::prelude::*;\n \n+use alloc::boxed;\n use alloc::boxed::Box;\n-use core::mem;\n use core::ptr;\n use core::cell::UnsafeCell;\n \n@@ -81,7 +81,7 @@ unsafe impl<T: Send> Sync for Queue<T> { }\n impl<T: Send> Node<T> {\n     fn new() -> *mut Node<T> {\n         unsafe {\n-            mem::transmute(box Node {\n+            boxed::into_raw(box Node {\n                 value: None,\n                 next: AtomicPtr::new(ptr::null_mut::<Node<T>>()),\n             })\n@@ -200,7 +200,7 @@ impl<T: Send> Queue<T> {\n                           .next.store(next, Ordering::Relaxed);\n                     // We have successfully erased all references to 'tail', so\n                     // now we can safely drop it.\n-                    let _: Box<Node<T>> = mem::transmute(tail);\n+                    let _: Box<Node<T>> = Box::from_raw(tail);\n                 }\n             }\n             return ret;\n@@ -233,7 +233,7 @@ impl<T: Send> Drop for Queue<T> {\n             let mut cur = *self.first.get();\n             while !cur.is_null() {\n                 let next = (*cur).next.load(Ordering::Relaxed);\n-                let _n: Box<Node<T>> = mem::transmute(cur);\n+                let _n: Box<Node<T>> = Box::from_raw(cur);\n                 cur = next;\n             }\n         }"}, {"sha": "5faaa928ee973893d345e29aab91b8446f1947a1", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -22,8 +22,8 @@\n \n use prelude::v1::*;\n \n+use boxed;\n use cell::UnsafeCell;\n-use mem;\n use ptr;\n use rt;\n use sync::{StaticMutex, StaticCondvar};\n@@ -88,7 +88,7 @@ impl<M: Send> Helper<M> {\n             let _guard = self.lock.lock().unwrap();\n             if !*self.initialized.get() {\n                 let (tx, rx) = channel();\n-                *self.chan.get() = mem::transmute(box tx);\n+                *self.chan.get() = boxed::into_raw(box tx);\n                 let (receive, send) = helper_signal::new();\n                 *self.signal.get() = send as uint;\n \n@@ -132,7 +132,7 @@ impl<M: Send> Helper<M> {\n             let mut guard = self.lock.lock().unwrap();\n \n             // Close the channel by destroying it\n-            let chan: Box<Sender<M>> = mem::transmute(*self.chan.get());\n+            let chan: Box<Sender<M>> = Box::from_raw(*self.chan.get());\n             *self.chan.get() = ptr::null_mut();\n             drop(chan);\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);"}, {"sha": "731617858e95fe3f9185048414d59e6c60189e77", "filename": "src/libstd/sys/common/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -27,7 +27,7 @@ pub fn start_thread(main: *mut libc::c_void) -> thread::rust_thread_return {\n     unsafe {\n         stack::record_os_managed_stack_bounds(0, usize::MAX);\n         let handler = stack_overflow::Handler::new();\n-        let f: Box<Thunk> = mem::transmute(main);\n+        let f: Box<Thunk> = Box::from_raw(main as *mut Thunk);\n         f.invoke(());\n         drop(handler);\n         mem::transmute(0 as thread::rust_thread_return)"}, {"sha": "f4791d39da19055e6925db6d923ed98527eb4097", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -11,6 +11,7 @@\n use core::prelude::*;\n \n use io;\n+use boxed;\n use boxed::Box;\n use cmp;\n use mem;\n@@ -241,13 +242,15 @@ pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n         },\n     };\n \n-    let arg: *mut libc::c_void = mem::transmute(box p); // must box since sizeof(p)=2*uint\n+    // must box since sizeof(p)=2*uint\n+    let raw_p = boxed::into_raw(box p);\n+    let arg = raw_p as *mut libc::c_void;\n     let ret = pthread_create(&mut native, &attr, thread_start, arg);\n     assert_eq!(pthread_attr_destroy(&mut attr), 0);\n \n     if ret != 0 {\n         // be sure to not leak the closure\n-        let _p: Box<Box<FnOnce()+Send>> = mem::transmute(arg);\n+        let _p: Box<Thunk> = Box::from_raw(raw_p);\n         Err(io::Error::from_os_error(ret))\n     } else {\n         Ok(native)"}, {"sha": "aa22b6b1307a340247269dbb02c16f4bc177a620", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -10,9 +10,9 @@\n \n use prelude::v1::*;\n \n+use boxed;\n use cmp;\n use io;\n-use mem;\n use ptr;\n use libc;\n use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n@@ -45,7 +45,8 @@ pub mod guard {\n }\n \n pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n-    let arg: *mut libc::c_void = mem::transmute(box p);\n+    let raw_p = boxed::into_raw(box p);\n+    let arg = raw_p as *mut libc::c_void;\n     // FIXME On UNIX, we guard against stack sizes that are too small but\n     // that's because pthreads enforces that stacks are at least\n     // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n@@ -61,7 +62,7 @@ pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n \n     if ret as uint == 0 {\n         // be sure to not leak the closure\n-        let _p: Box<Thunk> = mem::transmute(arg);\n+        let _p: Box<Thunk> = Box::from_raw(raw_p);\n         Err(io::Error::last_os_error())\n     } else {\n         Ok(ret)"}, {"sha": "30c483ac52fa261a4c3a0b6d4052b038ef6cd374", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -12,7 +12,7 @@ use prelude::v1::*;\n \n use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n \n-use mem;\n+use boxed;\n use ptr;\n use rt;\n use sys_common::mutex::{MUTEX_INIT, Mutex};\n@@ -133,13 +133,13 @@ unsafe fn init_dtors() {\n     if !DTORS.is_null() { return }\n \n     let dtors = box Vec::<(Key, Dtor)>::new();\n-    DTORS = mem::transmute(dtors);\n+    DTORS = boxed::into_raw(dtors);\n \n     rt::at_exit(move|| {\n         DTOR_LOCK.lock();\n         let dtors = DTORS;\n         DTORS = ptr::null_mut();\n-        mem::transmute::<_, Box<Vec<(Key, Dtor)>>>(dtors);\n+        Box::from_raw(dtors);\n         assert!(DTORS.is_null()); // can't re-init after destructing\n         DTOR_LOCK.unlock();\n     });"}, {"sha": "cdd71d440fe4f014f82fce90fd2475bb5612f56b", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -388,6 +388,7 @@ mod imp {\n     // Due to rust-lang/rust#18804, make sure this is not generic!\n     #[cfg(target_os = \"linux\")]\n     unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+        use boxed;\n         use mem;\n         use libc;\n         use sys_common::thread_local as os;\n@@ -422,14 +423,14 @@ mod imp {\n         type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n         if DTORS.get().is_null() {\n             let v: Box<List> = box Vec::new();\n-            DTORS.set(mem::transmute(v));\n+            DTORS.set(boxed::into_raw(v) as *mut u8);\n         }\n         let list: &mut List = &mut *(DTORS.get() as *mut List);\n         list.push((t, dtor));\n \n         unsafe extern fn run_dtors(mut ptr: *mut u8) {\n             while !ptr.is_null() {\n-                let list: Box<List> = mem::transmute(ptr);\n+                let list: Box<List> = Box::from_raw(ptr as *mut List);\n                 for &(ptr, dtor) in &*list {\n                     dtor(ptr);\n                 }\n@@ -467,6 +468,7 @@ mod imp {\n mod imp {\n     use prelude::v1::*;\n \n+    use alloc::boxed;\n     use cell::UnsafeCell;\n     use mem;\n     use ptr;\n@@ -517,7 +519,7 @@ mod imp {\n                 key: self,\n                 value: mem::transmute_copy(&self.inner),\n             };\n-            let ptr: *mut Value<T> = mem::transmute(ptr);\n+            let ptr: *mut Value<T> = boxed::into_raw(ptr);\n             self.os.set(ptr as *mut u8);\n             Some(&mut (*ptr).value as *mut T)\n         }\n@@ -533,7 +535,7 @@ mod imp {\n         //\n         // Note that to prevent an infinite loop we reset it back to null right\n         // before we return from the destructor ourselves.\n-        let ptr: Box<Value<T>> = mem::transmute(ptr);\n+        let ptr: Box<Value<T>> = Box::from_raw(ptr as *mut Value<T>);\n         let key = ptr.key;\n         key.os.set(1 as *mut u8);\n         drop(ptr);"}, {"sha": "4fc08c0c2b28caaccfcabe40924c848cbcf917ac", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -292,7 +292,7 @@ pub enum InlineAttr {\n }\n \n /// Determine what `#[inline]` attribute is present in `attrs`, if any.\n-pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n+pub fn find_inline_attr(diagnostic: Option<&SpanHandler>, attrs: &[Attribute]) -> InlineAttr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n     attrs.iter().fold(InlineNone, |ia,attr| {\n         match attr.node.value.node {\n@@ -302,12 +302,16 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n             }\n             MetaList(ref n, ref items) if *n == \"inline\" => {\n                 mark_used(attr);\n-                if contains_name(&items[..], \"always\") {\n+                if items.len() != 1 {\n+                    diagnostic.map(|d|{ d.span_err(attr.span, \"expected one argument\"); });\n+                    InlineNone\n+                } else if contains_name(&items[..], \"always\") {\n                     InlineAlways\n                 } else if contains_name(&items[..], \"never\") {\n                     InlineNever\n                 } else {\n-                    InlineHint\n+                    diagnostic.map(|d|{ d.span_err((*items[0]).span, \"invalid argument\"); });\n+                    InlineNone\n                 }\n             }\n             _ => ia\n@@ -317,7 +321,7 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n \n /// True if `#[inline]` or `#[inline(always)]` is present in `attrs`.\n pub fn requests_inline(attrs: &[Attribute]) -> bool {\n-    match find_inline_attr(attrs) {\n+    match find_inline_attr(None, attrs) {\n         InlineHint | InlineAlways => true,\n         InlineNone | InlineNever => false,\n     }"}, {"sha": "7977574b02b15cdf81d6e39a039bdab856270a83", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -3494,6 +3494,9 @@ impl<'a> Parser<'a> {\n                     };\n                     pat = PatIdent(BindByValue(MutImmutable), pth1, sub);\n                 }\n+            } else if self.look_ahead(1, |t| *t == token::Lt) {\n+                self.bump();\n+                self.unexpected()\n             } else {\n                 // parse an enum pat\n                 let enum_path = self.parse_path(LifetimeAndTypesWithColons);"}, {"sha": "3c116aa860bca9c10c1cf285832dde4f028ca07b", "filename": "src/rustbook/book.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Frustbook%2Fbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Frustbook%2Fbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbook.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -50,14 +50,14 @@ impl<'a> Iterator for BookItems<'a> {\n \n                 let mut section = \"\".to_string();\n                 for &(_, idx) in &self.stack {\n-                    section.push_str(&(idx + 1).to_string()[]);\n+                    section.push_str(&(idx + 1).to_string()[..]);\n                     section.push('.');\n                 }\n-                section.push_str(&(self.cur_idx + 1).to_string()[]);\n+                section.push_str(&(self.cur_idx + 1).to_string()[..]);\n                 section.push('.');\n \n                 self.stack.push((self.cur_items, self.cur_idx));\n-                self.cur_items = &cur.children[];\n+                self.cur_items = &cur.children[..];\n                 self.cur_idx = 0;\n                 return Some((section, cur))\n             }\n@@ -68,7 +68,7 @@ impl<'a> Iterator for BookItems<'a> {\n impl Book {\n     pub fn iter(&self) -> BookItems {\n         BookItems {\n-            cur_items: &self.chapters[],\n+            cur_items: &self.chapters[..],\n             cur_idx: 0,\n             stack: Vec::new(),\n         }"}, {"sha": "9f35bdaa367e5ee5d6d31d4f517cbfecdbc31cbe", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -10,7 +10,6 @@\n \n //! Implementation of the `build` subcommand, used to compile a book.\n \n-use std::os;\n use std::env;\n use std::old_io;\n use std::old_io::{fs, File, BufferedWriter, TempDir, IoResult};\n@@ -41,7 +40,7 @@ fn write_toc(book: &Book, path_to_root: &Path, out: &mut Writer) -> IoResult<()>\n                   path_to_root: &Path,\n                   out: &mut Writer) -> IoResult<()> {\n         for (i, item) in items.iter().enumerate() {\n-            try!(walk_item(item, &format!(\"{}{}.\", section, i + 1)[], path_to_root, out));\n+            try!(walk_item(item, &format!(\"{}{}.\", section, i + 1)[..], path_to_root, out));\n         }\n         Ok(())\n     }\n@@ -55,7 +54,7 @@ fn write_toc(book: &Book, path_to_root: &Path, out: &mut Writer) -> IoResult<()>\n                  item.title));\n         if !item.children.is_empty() {\n             try!(writeln!(out, \"<ul class='section'>\"));\n-            let _ = walk_items(&item.children[], section, path_to_root, out);\n+            let _ = walk_items(&item.children[..], section, path_to_root, out);\n             try!(writeln!(out, \"</ul>\"));\n         }\n         try!(writeln!(out, \"</li>\"));\n@@ -65,7 +64,7 @@ fn write_toc(book: &Book, path_to_root: &Path, out: &mut Writer) -> IoResult<()>\n \n     try!(writeln!(out, \"<div id='toc' class='mobile-hidden'>\"));\n     try!(writeln!(out, \"<ul class='chapter'>\"));\n-    try!(walk_items(&book.chapters[], \"\", path_to_root, out));\n+    try!(walk_items(&book.chapters[..], \"\", path_to_root, out));\n     try!(writeln!(out, \"</ul>\"));\n     try!(writeln!(out, \"</div>\"));\n \n@@ -82,7 +81,7 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n \n         let src;\n         if env::args().len() < 3 {\n-            src = os::getcwd().unwrap().clone();\n+            src = env::current_dir().unwrap().clone();\n         } else {\n             src = Path::new(env::args().nth(2).unwrap().clone());\n         }\n@@ -150,7 +149,7 @@ impl Subcommand for Build {\n     }\n     fn usage(&self) {}\n     fn execute(&mut self, term: &mut Term) -> CommandResult<()> {\n-        let cwd = os::getcwd().unwrap();\n+        let cwd = env::current_dir().unwrap();\n         let src;\n         let tgt;\n \n@@ -179,7 +178,7 @@ impl Subcommand for Build {\n             Err(errors) => {\n                 let n = errors.len();\n                 for err in errors {\n-                    term.err(&format!(\"error: {}\", err)[]);\n+                    term.err(&format!(\"error: {}\", err)[..]);\n                 }\n \n                 Err(box format!(\"{} errors occurred\", n) as Box<Error>)"}, {"sha": "68e4ba54d94c168fdf5c22305288056dd2a93c48", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -12,7 +12,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(old_io)]\n-#![feature(os)]\n #![feature(env)]\n #![feature(old_path)]\n #![feature(rustdoc)]\n@@ -54,16 +53,16 @@ fn main() {\n     if cmd.len() <= 1 {\n         help::usage()\n     } else {\n-        match subcommand::parse_name(&cmd[1][]) {\n+        match subcommand::parse_name(&cmd[1][..]) {\n             Some(mut subcmd) => {\n                 match subcmd.parse_args(cmd.tail()) {\n                     Ok(_) => {\n                         match subcmd.execute(&mut term) {\n                             Ok(_) => (),\n                             Err(err) => {\n-                                term.err(&format!(\"error: {}\", err.description())[]);\n+                                term.err(&format!(\"error: {}\", err.description())[..]);\n                                 err.detail().map(|detail| {\n-                                    term.err(&format!(\"detail: {}\", detail)[]);\n+                                    term.err(&format!(\"detail: {}\", detail)[..]);\n                                 });\n                             }\n                         }"}, {"sha": "bff366163dc2f974f6c95792a1a7e5e534ac80c9", "filename": "src/rustbook/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Frustbook%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Frustbook%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ftest.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -17,7 +17,7 @@ use error::Error;\n use term::Term;\n use book;\n use std::old_io::{Command, File};\n-use std::os;\n+use std::env;\n \n struct Test;\n \n@@ -35,7 +35,7 @@ impl Subcommand for Test {\n     }\n     fn usage(&self) {}\n     fn execute(&mut self, term: &mut Term) -> CommandResult<()> {\n-        let cwd = os::getcwd().unwrap();\n+        let cwd = env::current_dir().unwrap();\n         let src = cwd.clone();\n \n         let summary = File::open(&src.join(\"SUMMARY.md\"));\n@@ -50,8 +50,8 @@ impl Subcommand for Test {\n                         Ok(output) => {\n                             if !output.status.success() {\n                                 term.err(&format!(\"{}\\n{}\",\n-                                         String::from_utf8_lossy(&output.output[]),\n-                                         String::from_utf8_lossy(&output.error[]))[]);\n+                                         String::from_utf8_lossy(&output.output[..]),\n+                                         String::from_utf8_lossy(&output.error[..]))[..]);\n                                 return Err(box \"Some tests failed.\" as Box<Error>);\n                             }\n "}, {"sha": "d60751eddc7bc201866255cb0b129c90744be516", "filename": "src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -11,7 +11,7 @@\n // Test that attempt to reborrow an `&mut` pointer in an aliasable\n // location yields an error.\n //\n-// Example from src/middle/borrowck/doc.rs\n+// Example from src/librustc_borrowck/borrowck/README.md\n \n fn foo(t0: & &mut isize) {\n     let t1 = t0;"}, {"sha": "2fb89e6364bb1e8b24a8607cd18d46f9329fe502", "filename": "src/test/compile-fail/borrowck-move-mut-base-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -11,7 +11,7 @@\n // Test that attempt to move `&mut` pointer while pointee is borrowed\n // yields an error.\n //\n-// Example from src/middle/borrowck/doc.rs\n+// Example from src/librustc_borrowck/borrowck/README.md\n \n fn foo(t0: &mut isize) {\n     let p: &isize = &*t0; // Freezes `*t0`"}, {"sha": "bdeb7ea69bdfb84d416420bc26f3474e373d6c90", "filename": "src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-borrow-of-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-borrow-of-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-borrow-of-mut-base-ptr.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -11,7 +11,7 @@\n // Test that attempt to mutably borrow `&mut` pointer while pointee is\n // borrowed yields an error.\n //\n-// Example from src/middle/borrowck/doc.rs\n+// Example from src/librustc_borrowck/borrowck/README.md\n \n fn foo<'a>(mut t0: &'a mut isize,\n            mut t1: &'a mut isize) {"}, {"sha": "552fcec8e2858e921fd6a8842b3981667986e5a0", "filename": "src/test/compile-fail/borrowck-swap-mut-base-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -11,7 +11,7 @@\n // Test that attempt to swap `&mut` pointer while pointee is borrowed\n // yields an error.\n //\n-// Example from src/middle/borrowck/doc.rs\n+// Example from src/librustc_borrowck/borrowck/README.md\n \n use std::mem::swap;\n "}, {"sha": "ad89087d660201ab865620e0ce76aae566c95b6c", "filename": "src/test/compile-fail/invalid-inline.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Finvalid-inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Finvalid-inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finvalid-inline.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(dead_code)]\n+\n+#[inline(please_no)] //~ ERROR invalid argument\n+fn a() {\n+}\n+\n+#[inline(please,no)] //~ ERROR expected one argument\n+fn b() {\n+}\n+\n+#[inline()] //~ ERROR expected one argument\n+fn c() {\n+}\n+\n+fn main() {}"}, {"sha": "f026a5db551e4ab69f785fe05bb1af35fdeed215", "filename": "src/test/compile-fail/issue-22426-1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fissue-22426-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fissue-22426-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22426-1.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+  match 42 {\n+    x < 7 => (),\n+   //~^ error: unexpected token: `<`\n+    _ => ()\n+  }\n+}"}, {"sha": "ea5180e3eec61f67273a57ad6c6edd96caef8e3e", "filename": "src/test/compile-fail/issue-22426-2.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fissue-22426-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fissue-22426-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22426-2.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn a(B<) {}\n+   //~^ error: unexpected token: `<`"}, {"sha": "2e0b5d6b80fa7f6a7888065c6b0e430a043fe4a6", "filename": "src/test/compile-fail/issue-22426-3.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fissue-22426-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fissue-22426-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22426-3.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<T>(T, T);\n+\n+impl<T> Foo<T> {\n+    fn foo(&self) {\n+        match *self {\n+            Foo<T>(x, y) => {\n+            //~^ error: unexpected token: `<`\n+              println!(\"Goodbye, World!\")\n+            }\n+        }\n+    }\n+}"}, {"sha": "fafae0cb705a891e3e89f40fe2abc91d01e8e583", "filename": "src/test/compile-fail/retslot-cast.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fretslot-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Fcompile-fail%2Fretslot-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fretslot-cast.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(warnings)]\n+\n+pub fn fail(x: Option<& (Iterator+Send)>) -> Option<&Iterator> {\n+    // This call used to trigger an LLVM assertion because the return slot had type\n+    // \"Option<&Iterator>\"* instead of \"Option<&(Iterator+Send)>\"*\n+    inner(x)\n+}\n+\n+pub fn inner(x: Option<& (Iterator+Send)>) -> Option<&(Iterator+Send)> {\n+    x\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "3d57a2263e1ef188994635c0ad1698b81b04d4db", "filename": "src/test/run-make/weird-output-filenames/Makefile", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-make%2Fweird-output-filenames%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-make%2Fweird-output-filenames%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fweird-output-filenames%2FMakefile?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -10,3 +10,6 @@ all:\n \tcp foo.rs $(TMPDIR)/+foo+bar\n \t$(RUSTC) $(TMPDIR)/+foo+bar 2>&1 \\\n \t\t| grep \"invalid character.*in crate name:\"\n+\tcp foo.rs $(TMPDIR)/-foo.rs\n+\t$(RUSTC) $(TMPDIR)/-foo.rs 2>&1 \\\n+\t\t| grep \"crate name cannot start with a hyphen:\""}, {"sha": "48129f2b6ddc3ebe2b1251bca6e41085c305bc45", "filename": "src/test/run-pass/borrowck-borrow-of-mut-base-ptr-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-pass%2Fborrowck-borrow-of-mut-base-ptr-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-pass%2Fborrowck-borrow-of-mut-base-ptr-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-of-mut-base-ptr-safe.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -11,7 +11,7 @@\n // Test that freezing an `&mut` pointer while referent is\n // frozen is legal.\n //\n-// Example from src/middle/borrowck/doc.rs\n+// Example from src/librustc_borrowck/borrowck/README.md\n \n fn foo<'a>(mut t0: &'a mut int,\n            mut t1: &'a mut int) {"}, {"sha": "8fe69e4002494d96dfe6212ed0b023206be73d85", "filename": "src/test/run-pass/extern-methods.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-pass%2Fextern-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-pass%2Fextern-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-methods.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::MarkerTrait;\n+\n+trait A : MarkerTrait {\n+    extern \"fastcall\" fn test1(i: i32);\n+    extern fn test2(i: i32);\n+}\n+\n+struct S;\n+impl S {\n+    extern \"stdcall\" fn test3(i: i32) {\n+        assert_eq!(i, 3);\n+    }\n+}\n+\n+impl A for S {\n+    extern \"fastcall\" fn test1(i: i32) {\n+        assert_eq!(i, 1);\n+    }\n+    extern fn test2(i: i32) {\n+        assert_eq!(i, 2);\n+    }\n+}\n+\n+fn main() {\n+    <S as A>::test1(1);\n+    <S as A>::test2(2);\n+    S::test3(3);\n+}"}, {"sha": "b1c8f9c23c5d0ed11a7570d7bb59e73a34700c29", "filename": "src/test/run-pass/issue-22426.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-pass%2Fissue-22426.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-pass%2Fissue-22426.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22426.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+  match 42 {\n+    x if x < 7 => (),\n+    _ => ()\n+  }\n+}"}, {"sha": "6f5ded6c475b6f3f058a094b52767753e5baa242", "filename": "src/test/run-pass/lang-item-public.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-pass%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-pass%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flang-item-public.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -10,7 +10,6 @@\n \n // aux-build:lang-item-public.rs\n // ignore-android\n-// ignore-windows #13361\n \n #![feature(lang_items, start, no_std)]\n #![no_std]"}, {"sha": "449e500edbe846345be09cb01ef50404d9f6aef9", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -37,7 +37,8 @@ fn f(tx: Sender<bool>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _t = thread::spawn(move|| f(tx.clone()));\n+    let t = thread::spawn(move|| f(tx.clone()));\n     println!(\"hiiiiiiiii\");\n     assert!(rx.recv().unwrap());\n+    drop(t.join());\n }"}, {"sha": "4d90f71c830ba6db56bf83758047fb6119f50d78", "filename": "src/test/run-pass/unwind-unique.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a5a1ab4ad054c8dccf49f6f409542f82683cfc/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-unique.rs?ref=91a5a1ab4ad054c8dccf49f6f409542f82683cfc", "patch": "@@ -19,5 +19,6 @@ fn f() {\n }\n \n pub fn main() {\n-    let _t = thread::spawn(f);\n+    let t = thread::spawn(f);\n+    drop(t.join());\n }"}]}