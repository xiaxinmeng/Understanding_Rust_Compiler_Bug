{"sha": "f32e6781b2932aed55342ad8a4a7f1023acb30b4", "node_id": "C_kwDOAAsO6NoAKGYzMmU2NzgxYjI5MzJhZWQ1NTM0MmFkOGE0YTdmMTAyM2FjYjMwYjQ", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-03T00:31:07Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-03T00:58:11Z"}, "message": "Rename some variables.\n\nThese have been bugging me for a while.\n\n- `literal_text`: `src` is also used and is shorter and better.\n- `first_char`: used even when \"first\" doesn't make sense; `c` is\n  shorter and better.\n- `curr`: `c` is shorter and better.\n- `unescaped_char`: `result` is also used and is shorter and better.\n- `second_char`: these have a single use and can be elided.", "tree": {"sha": "ef7aa0f3de2a88b89f110d201a990b2890150213", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef7aa0f3de2a88b89f110d201a990b2890150213"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f32e6781b2932aed55342ad8a4a7f1023acb30b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f32e6781b2932aed55342ad8a4a7f1023acb30b4", "html_url": "https://github.com/rust-lang/rust/commit/f32e6781b2932aed55342ad8a4a7f1023acb30b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f32e6781b2932aed55342ad8a4a7f1023acb30b4/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d726c8467c06088d5d4488edf6b015ec9698c1ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/d726c8467c06088d5d4488edf6b015ec9698c1ea", "html_url": "https://github.com/rust-lang/rust/commit/d726c8467c06088d5d4488edf6b015ec9698c1ea"}], "stats": {"total": 70, "additions": 32, "deletions": 38}, "files": [{"sha": "a6752c82bd3c5e60cdff8a021cefc13e42147b84", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f32e6781b2932aed55342ad8a4a7f1023acb30b4/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f32e6781b2932aed55342ad8a4a7f1023acb30b4/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=f32e6781b2932aed55342ad8a4a7f1023acb30b4", "patch": "@@ -78,54 +78,52 @@ impl EscapeError {\n /// Takes a contents of a literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n /// Values are returned through invoking of the provided callback.\n-pub fn unescape_literal<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+pub fn unescape_literal<F>(src: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n     match mode {\n         Mode::Char | Mode::Byte => {\n-            let mut chars = literal_text.chars();\n+            let mut chars = src.chars();\n             let result = unescape_char_or_byte(&mut chars, mode);\n             // The Chars iterator moved forward.\n-            callback(0..(literal_text.len() - chars.as_str().len()), result);\n+            callback(0..(src.len() - chars.as_str().len()), result);\n         }\n-        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(literal_text, mode, callback),\n+        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(src, mode, callback),\n         // NOTE: Raw strings do not perform any explicit character escaping, here we\n         // only translate CRLF to LF and produce errors on bare CR.\n-        Mode::RawStr | Mode::RawByteStr => {\n-            unescape_raw_str_or_raw_byte_str(literal_text, mode, callback)\n-        }\n+        Mode::RawStr | Mode::RawByteStr => unescape_raw_str_or_raw_byte_str(src, mode, callback),\n     }\n }\n \n /// Takes a contents of a byte, byte string or raw byte string (without quotes)\n /// and produces a sequence of bytes or errors.\n /// Values are returned through invoking of the provided callback.\n-pub fn unescape_byte_literal<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+pub fn unescape_byte_literal<F>(src: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<u8, EscapeError>),\n {\n     debug_assert!(mode.is_bytes());\n-    unescape_literal(literal_text, mode, &mut |range, result| {\n+    unescape_literal(src, mode, &mut |range, result| {\n         callback(range, result.map(byte_from_char));\n     })\n }\n \n /// Takes a contents of a char literal (without quotes), and returns an\n /// unescaped char or an error\n-pub fn unescape_char(literal_text: &str) -> Result<char, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n+pub fn unescape_char(src: &str) -> Result<char, (usize, EscapeError)> {\n+    let mut chars = src.chars();\n     unescape_char_or_byte(&mut chars, Mode::Char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n+        .map_err(|err| (src.len() - chars.as_str().len(), err))\n }\n \n /// Takes a contents of a byte literal (without quotes), and returns an\n /// unescaped byte or an error.\n-pub fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n+pub fn unescape_byte(src: &str) -> Result<u8, (usize, EscapeError)> {\n+    let mut chars = src.chars();\n     unescape_char_or_byte(&mut chars, Mode::Byte)\n         .map(byte_from_char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n+        .map_err(|err| (src.len() - chars.as_str().len(), err))\n }\n \n /// What kind of literal do we parse.\n@@ -157,10 +155,7 @@ impl Mode {\n \n fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n     // Previous character was '\\\\', unescape what follows.\n-\n-    let second_char = chars.next().ok_or(EscapeError::LoneSlash)?;\n-\n-    let res = match second_char {\n+    let res = match chars.next().ok_or(EscapeError::LoneSlash)? {\n         '\"' => '\"',\n         'n' => '\\n',\n         'r' => '\\r',\n@@ -249,23 +244,23 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n }\n \n #[inline]\n-fn ascii_check(first_char: char, mode: Mode) -> Result<char, EscapeError> {\n-    if mode.is_bytes() && !first_char.is_ascii() {\n+fn ascii_check(c: char, mode: Mode) -> Result<char, EscapeError> {\n+    if mode.is_bytes() && !c.is_ascii() {\n         // Byte literal can't be a non-ascii character.\n         Err(EscapeError::NonAsciiCharInByte)\n     } else {\n-        Ok(first_char)\n+        Ok(c)\n     }\n }\n \n fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n     debug_assert!(mode == Mode::Char || mode == Mode::Byte);\n-    let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n-    let res = match first_char {\n+    let c = chars.next().ok_or(EscapeError::ZeroChars)?;\n+    let res = match c {\n         '\\\\' => scan_escape(chars, mode),\n         '\\n' | '\\t' | '\\'' => Err(EscapeError::EscapeOnlyChar),\n         '\\r' => Err(EscapeError::BareCarriageReturn),\n-        _ => ascii_check(first_char, mode),\n+        _ => ascii_check(c, mode),\n     }?;\n     if chars.next().is_some() {\n         return Err(EscapeError::MoreThanOneChar);\n@@ -282,13 +277,12 @@ where\n     debug_assert!(mode == Mode::Str || mode == Mode::ByteStr);\n     let initial_len = src.len();\n     let mut chars = src.chars();\n-    while let Some(first_char) = chars.next() {\n-        let start = initial_len - chars.as_str().len() - first_char.len_utf8();\n+    while let Some(c) = chars.next() {\n+        let start = initial_len - chars.as_str().len() - c.len_utf8();\n \n-        let unescaped_char = match first_char {\n+        let result = match c {\n             '\\\\' => {\n-                let second_char = chars.clone().next();\n-                match second_char {\n+                match chars.clone().next() {\n                     Some('\\n') => {\n                         // Rust language specification requires us to skip whitespaces\n                         // if unescaped '\\' character is followed by '\\n'.\n@@ -304,10 +298,10 @@ where\n             '\\t' => Ok('\\t'),\n             '\"' => Err(EscapeError::EscapeOnlyChar),\n             '\\r' => Err(EscapeError::BareCarriageReturn),\n-            _ => ascii_check(first_char, mode),\n+            _ => ascii_check(c, mode),\n         };\n         let end = initial_len - chars.as_str().len();\n-        callback(start..end, unescaped_char);\n+        callback(start..end, result);\n     }\n \n     fn skip_ascii_whitespace<F>(chars: &mut Chars<'_>, start: usize, callback: &mut F)\n@@ -341,18 +335,18 @@ where\n /// sequence of characters or errors.\n /// NOTE: Raw strings do not perform any explicit character escaping, here we\n /// only translate CRLF to LF and produce errors on bare CR.\n-fn unescape_raw_str_or_raw_byte_str<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+fn unescape_raw_str_or_raw_byte_str<F>(src: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n     debug_assert!(mode == Mode::RawStr || mode == Mode::RawByteStr);\n-    let initial_len = literal_text.len();\n+    let initial_len = src.len();\n \n-    let mut chars = literal_text.chars();\n-    while let Some(curr) = chars.next() {\n-        let start = initial_len - chars.as_str().len() - curr.len_utf8();\n+    let mut chars = src.chars();\n+    while let Some(c) = chars.next() {\n+        let start = initial_len - chars.as_str().len() - c.len_utf8();\n \n-        let result = match curr {\n+        let result = match c {\n             '\\r' => Err(EscapeError::BareCarriageReturnInRawString),\n             c if mode.is_bytes() && !c.is_ascii() => Err(EscapeError::NonAsciiCharInByteString),\n             c => Ok(c),"}]}