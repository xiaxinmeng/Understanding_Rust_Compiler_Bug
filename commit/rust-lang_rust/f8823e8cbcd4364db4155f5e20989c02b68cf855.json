{"sha": "f8823e8cbcd4364db4155f5e20989c02b68cf855", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ODIzZThjYmNkNDM2NGRiNDE1NWY1ZTIwOTg5YzAyYjY4Y2Y4NTU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-12-08T22:30:51Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-12-09T08:22:41Z"}, "message": "Properly fetch inner and outer docs on hir-level", "tree": {"sha": "098de556093b2b8361dd2265511182f2c09ea460", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/098de556093b2b8361dd2265511182f2c09ea460"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8823e8cbcd4364db4155f5e20989c02b68cf855", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8823e8cbcd4364db4155f5e20989c02b68cf855", "html_url": "https://github.com/rust-lang/rust/commit/f8823e8cbcd4364db4155f5e20989c02b68cf855", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8823e8cbcd4364db4155f5e20989c02b68cf855/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eac77997bfedd55fa572e3fdcf0058f12a0ebb63", "url": "https://api.github.com/repos/rust-lang/rust/commits/eac77997bfedd55fa572e3fdcf0058f12a0ebb63", "html_url": "https://github.com/rust-lang/rust/commit/eac77997bfedd55fa572e3fdcf0058f12a0ebb63"}], "stats": {"total": 50, "additions": 33, "deletions": 17}, "files": [{"sha": "228d706db99715e4226b5516e5321c4eb14e6115", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f8823e8cbcd4364db4155f5e20989c02b68cf855/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8823e8cbcd4364db4155f5e20989c02b68cf855/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=f8823e8cbcd4364db4155f5e20989c02b68cf855", "patch": "@@ -110,7 +110,17 @@ impl Attrs {\n     }\n \n     pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Attrs {\n-        let outer_docs = ast::CommentIter::from_syntax_node(owner.syntax()).map(|docs_text| {\n+        let (inner_attrs, inner_docs) = inner_attributes(owner.syntax())\n+            .map_or((None, None), |(attrs, docs)| ((Some(attrs), Some(docs))));\n+\n+        let outer_attrs = owner.attrs().filter(|attr| attr.excl_token().is_none());\n+        let attrs = outer_attrs\n+            .chain(inner_attrs.into_iter().flatten())\n+            .map(|attr| (attr.syntax().text_range().start(), Attr::from_src(attr, hygiene)));\n+\n+        let outer_docs =\n+            ast::CommentIter::from_syntax_node(owner.syntax()).filter(ast::Comment::is_outer);\n+        let docs = outer_docs.chain(inner_docs.into_iter().flatten()).map(|docs_text| {\n             (\n                 docs_text.syntax().text_range().start(),\n                 docs_text.doc_comment().map(|doc| Attr {\n@@ -119,13 +129,8 @@ impl Attrs {\n                 }),\n             )\n         });\n-        let outer_attrs = owner.attrs().filter(|attr| attr.excl_token().is_none());\n-        let inner_attrs = inner_attributes(owner.syntax()).into_iter().flatten();\n-        let attrs = outer_attrs\n-            .chain(inner_attrs)\n-            .map(|attr| (attr.syntax().text_range().start(), Attr::from_src(attr, hygiene)));\n         // sort here by syntax node offset because the source can have doc attributes and doc strings be interleaved\n-        let attrs: Vec<_> = outer_docs.chain(attrs).sorted_by_key(|&(offset, _)| offset).collect();\n+        let attrs: Vec<_> = docs.chain(attrs).sorted_by_key(|&(offset, _)| offset).collect();\n         let entries = if attrs.is_empty() {\n             // Avoid heap allocation\n             None\n@@ -186,36 +191,39 @@ impl Attrs {\n     }\n }\n \n-fn inner_attributes(syntax: &SyntaxNode) -> Option<impl Iterator<Item = ast::Attr>> {\n-    let (attrs, _docs) = match_ast! {\n+fn inner_attributes(\n+    syntax: &SyntaxNode,\n+) -> Option<(impl Iterator<Item = ast::Attr>, impl Iterator<Item = ast::Comment>)> {\n+    let (attrs, docs) = match_ast! {\n         match syntax {\n-            ast::SourceFile(it) => (it.attrs(), None::<ast::Comment>),\n+            ast::SourceFile(it) => (it.attrs(), ast::CommentIter::from_syntax_node(it.syntax())),\n             ast::ExternBlock(it) => {\n                 let extern_item_list = it.extern_item_list()?;\n-                (extern_item_list.attrs(), None)\n+                (extern_item_list.attrs(), ast::CommentIter::from_syntax_node(extern_item_list.syntax()))\n             },\n             ast::Fn(it) => {\n                 let body = it.body()?;\n-                (body.attrs(), None)\n+                (body.attrs(), ast::CommentIter::from_syntax_node(body.syntax()))\n             },\n             ast::Impl(it) => {\n                 let assoc_item_list = it.assoc_item_list()?;\n-                (assoc_item_list.attrs(), None)\n+                (assoc_item_list.attrs(), ast::CommentIter::from_syntax_node(assoc_item_list.syntax()))\n             },\n             ast::Module(it) => {\n                 let item_list = it.item_list()?;\n-                (item_list.attrs(), None)\n+                (item_list.attrs(), ast::CommentIter::from_syntax_node(item_list.syntax()))\n             },\n             // FIXME: BlockExpr's only accept inner attributes in specific cases\n             // Excerpt from the reference:\n-                // Block expressions accept outer and inner attributes, but only when they are the outer\n-                // expression of an expression statement or the final expression of another block expression.\n+            // Block expressions accept outer and inner attributes, but only when they are the outer\n+            // expression of an expression statement or the final expression of another block expression.\n             ast::BlockExpr(it) => return None,\n             _ => return None,\n         }\n     };\n     let attrs = attrs.filter(|attr| attr.excl_token().is_some());\n-    Some(attrs)\n+    let docs = docs.filter(|doc| doc.is_inner());\n+    Some((attrs, docs))\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "52b7285dde29d3b8cec10d13dea3cb2ff4ecd3f6", "filename": "crates/syntax/src/ast/token_ext.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8823e8cbcd4364db4155f5e20989c02b68cf855/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8823e8cbcd4364db4155f5e20989c02b68cf855/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs?ref=f8823e8cbcd4364db4155f5e20989c02b68cf855", "patch": "@@ -17,6 +17,14 @@ impl ast::Comment {\n         CommentKind::from_text(self.text())\n     }\n \n+    pub fn is_inner(&self) -> bool {\n+        self.kind().doc == Some(CommentPlacement::Inner)\n+    }\n+\n+    pub fn is_outer(&self) -> bool {\n+        self.kind().doc == Some(CommentPlacement::Outer)\n+    }\n+\n     pub fn prefix(&self) -> &'static str {\n         let &(prefix, _kind) = CommentKind::BY_PREFIX\n             .iter()"}]}