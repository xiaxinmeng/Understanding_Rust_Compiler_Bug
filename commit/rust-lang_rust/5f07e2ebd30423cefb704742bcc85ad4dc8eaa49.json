{"sha": "5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMDdlMmViZDMwNDIzY2VmYjcwNDc0MmJjYzg1YWQ0ZGM4ZWFhNDk=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-05-09T01:31:28Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-05-09T01:31:28Z"}, "message": "Merge branch 'new-data-layout'", "tree": {"sha": "df0a3ade20c7eb0adfa5b3e5c7f0a3a2f477e41a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df0a3ade20c7eb0adfa5b3e5c7f0a3a2f477e41a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "html_url": "https://github.com/rust-lang/rust/commit/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71bdabcdd9a61a58b6854eb05deda545783880d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/71bdabcdd9a61a58b6854eb05deda545783880d2", "html_url": "https://github.com/rust-lang/rust/commit/71bdabcdd9a61a58b6854eb05deda545783880d2"}, {"sha": "d825ef1bf11c1b4005e6fc2c7cd135695f84104b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d825ef1bf11c1b4005e6fc2c7cd135695f84104b", "html_url": "https://github.com/rust-lang/rust/commit/d825ef1bf11c1b4005e6fc2c7cd135695f84104b"}], "stats": {"total": 579, "additions": 271, "deletions": 308}, "files": [{"sha": "e152db5422709cb975e2ba159e72c1bb1d4fe756", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -1,6 +1,6 @@\n language: rust\n rust:\n-- nightly-2016-04-11\n+- nightly-2016-04-21\n - nightly\n matrix:\n   allow_failures:"}, {"sha": "26d1278ceb846e24eda6ff6b2fc5cc5be704d6e7", "filename": "README.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -15,26 +15,26 @@ I currently recommend that you install [multirust][multirust] and then use it to\n install the current rustc nightly version that works with Miri:\n \n ```sh\n-multirust update nightly-2016-04-11\n+multirust update nightly-2016-04-21\n ```\n \n ## Build\n \n ```sh\n-multirust run nightly-2016-04-11 cargo build\n+multirust run nightly-2016-04-21 cargo build\n ```\n \n ## Run a test\n \n ```sh\n-multirust run nightly-2016-04-11 cargo run -- \\\n-  --sysroot $HOME/.multirust/toolchains/nightly-2016-04-11 \\\n+multirust run nightly-2016-04-21 cargo run -- \\\n+  --sysroot $HOME/.multirust/toolchains/nightly-2016-04-21 \\\n   test/filename.rs\n ```\n \n If you are using [rustup][rustup] (the name of the multirust rewrite in Rust),\n the `sysroot` path will also include your build target (e.g.\n-`$HOME/.multirust/toolchains/nightly-2016-04-11-x86_64-apple-darwin`). You can\n+`$HOME/.multirust/toolchains/nightly-2016-04-21-x86_64-apple-darwin`). You can\n see the current toolchain's directory by running `rustup which cargo` (ignoring\n the trailing `/bin/cargo`).\n "}, {"sha": "5dc7d51ea7f86a0048ad6c264afb6cdce6b610a2", "filename": "src/interpreter.rs", "status": "modified", "additions": 205, "deletions": 210, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -1,15 +1,14 @@\n-use arena::TypedArena;\n use rustc::infer;\n use rustc::middle::const_val;\n use rustc::hir::def_id::DefId;\n use rustc::mir::mir_map::MirMap;\n use rustc::mir::repr as mir;\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::layout::{self, Layout, Size};\n use rustc::ty::subst::{self, Subst, Substs};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::DefIdMap;\n-use rustc_data_structures::fnv::FnvHashMap;\n use std::cell::RefCell;\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -19,12 +18,12 @@ use syntax::attr;\n use syntax::codemap::{self, DUMMY_SP};\n \n use error::{EvalError, EvalResult};\n-use memory::{FieldRepr, Memory, Pointer, Repr};\n+use memory::{Memory, Pointer};\n use primval::{self, PrimVal};\n \n const TRACE_EXECUTION: bool = false;\n \n-struct Interpreter<'a, 'tcx: 'a, 'arena> {\n+struct Interpreter<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n     tcx: &'a TyCtxt<'tcx>,\n \n@@ -34,12 +33,6 @@ struct Interpreter<'a, 'tcx: 'a, 'arena> {\n     /// A local cache from DefIds to Mir for non-crate-local items.\n     mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n \n-    /// An arena allocator for type representations.\n-    repr_arena: &'arena TypedArena<Repr>,\n-\n-    /// A cache for in-memory representations of types.\n-    repr_cache: RefCell<FnvHashMap<ty::Ty<'tcx>, &'arena Repr>>,\n-\n     /// The virtual memory system.\n     memory: Memory,\n \n@@ -91,7 +84,8 @@ struct Lvalue {\n enum LvalueExtra {\n     None,\n     Length(u64),\n-    // Vtable(memory::AllocId),\n+    // TODO(tsion): Vtable(memory::AllocId),\n+    DowncastVariant(usize),\n }\n \n #[derive(Clone)]\n@@ -112,16 +106,12 @@ enum TerminatorTarget {\n     Return,\n }\n \n-impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n-    fn new(tcx: &'a TyCtxt<'tcx>, mir_map: &'a MirMap<'tcx>, repr_arena: &'arena TypedArena<Repr>)\n-        -> Self\n-    {\n+impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n+    fn new(tcx: &'a TyCtxt<'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n         Interpreter {\n             tcx: tcx,\n             mir_map: mir_map,\n             mir_cache: RefCell::new(DefIdMap()),\n-            repr_arena: repr_arena,\n-            repr_cache: RefCell::new(FnvHashMap()),\n             memory: Memory::new(),\n             stack: Vec::new(),\n             substs_stack: Vec::new(),\n@@ -242,7 +232,10 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n                 let discr_ptr = try!(self.eval_lvalue(discr)).to_ptr();\n-                let discr_size = self.lvalue_repr(discr).size();\n+                let discr_size = self\n+                    .type_layout(self.lvalue_ty(discr))\n+                    .size(&self.tcx.data_layout)\n+                    .bytes() as usize;\n                 let discr_val = try!(self.memory.read_uint(discr_ptr, discr_size));\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n@@ -262,19 +255,35 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n \n             Switch { ref discr, ref targets, adt_def } => {\n                 let adt_ptr = try!(self.eval_lvalue(discr)).to_ptr();\n-                let adt_repr = self.lvalue_repr(discr);\n-                let discr_size = match *adt_repr {\n-                    Repr::Aggregate { discr_size, .. } => discr_size,\n-                    _ => panic!(\"attmpted to switch on non-aggregate type\"),\n-                };\n-                let discr_val = try!(self.memory.read_uint(adt_ptr, discr_size));\n+                let adt_layout = self.type_layout(self.lvalue_ty(discr));\n \n-                let matching = adt_def.variants.iter()\n-                    .position(|v| discr_val == v.disr_val.to_u64_unchecked());\n+                 match *adt_layout {\n+                    Layout::General { discr, .. } | Layout::CEnum { discr, .. } => {\n+                        let discr_size = discr.size().bytes();\n+                        let discr_val = try!(self.memory.read_uint(adt_ptr, discr_size as usize));\n \n-                match matching {\n-                    Some(i) => TerminatorTarget::Block(targets[i]),\n-                    None => return Err(EvalError::InvalidDiscriminant),\n+                        let matching = adt_def.variants.iter()\n+                            .position(|v| discr_val == v.disr_val.to_u64_unchecked());\n+\n+                        match matching {\n+                            Some(i) => TerminatorTarget::Block(targets[i]),\n+                            None => return Err(EvalError::InvalidDiscriminant),\n+                        }\n+                    }\n+\n+                    Layout::RawNullablePointer { nndiscr, .. } => {\n+                        let is_null = match self.memory.read_usize(adt_ptr) {\n+                            Ok(0) => true,\n+                            Ok(_) | Err(EvalError::ReadPointerAsBytes) => false,\n+                            Err(e) => return Err(e),\n+                        };\n+\n+                        assert!(nndiscr == 0 || nndiscr == 1);\n+                        let target = if is_null { 1 - nndiscr } else { nndiscr };\n+                        TerminatorTarget::Block(targets[target as usize])\n+                    }\n+\n+                    _ => panic!(\"attempted to switch on non-aggregate type\"),\n                 }\n             }\n \n@@ -328,13 +337,15 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                                     let last_arg = args.last().unwrap();\n                                     let last = try!(self.eval_operand(last_arg));\n                                     let last_ty = self.operand_ty(last_arg);\n-                                    let last_repr = self.type_repr(last_ty);\n-                                    match (&last_ty.sty, last_repr) {\n+                                    let last_layout = self.type_layout(last_ty);\n+                                    match (&last_ty.sty, last_layout) {\n                                         (&ty::TyTuple(ref fields),\n-                                         &Repr::Aggregate { discr_size: 0, ref variants, .. }) => {\n-                                            assert_eq!(variants.len(), 1);\n-                                            for (repr, ty) in variants[0].iter().zip(fields) {\n-                                                let src = last.offset(repr.offset as isize);\n+                                         &Layout::Univariant { ref variant, .. }) => {\n+                                            let offsets = iter::once(0)\n+                                                .chain(variant.offset_after_field.iter()\n+                                                    .map(|s| s.bytes()));\n+                                            for (offset, ty) in offsets.zip(fields) {\n+                                                let src = last.offset(offset as isize);\n                                                 arg_srcs.push((src, ty));\n                                             }\n                                         }\n@@ -578,28 +589,17 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         Ok(TerminatorTarget::Call)\n     }\n \n-    fn assign_to_aggregate(\n+    fn assign_fields<I: IntoIterator<Item = u64>>(\n         &mut self,\n         dest: Pointer,\n-        dest_repr: &Repr,\n-        variant: usize,\n-        discr: Option<u64>,\n+        offsets: I,\n         operands: &[mir::Operand<'tcx>],\n     ) -> EvalResult<()> {\n-        match *dest_repr {\n-            Repr::Aggregate { discr_size, ref variants, .. } => {\n-                if discr_size > 0 {\n-                    try!(self.memory.write_uint(dest, discr.unwrap(), discr_size));\n-                }\n-                let after_discr = dest.offset(discr_size as isize);\n-                for (field, operand) in variants[variant].iter().zip(operands) {\n-                    let src = try!(self.eval_operand(operand));\n-                    let src_ty = self.operand_ty(operand);\n-                    let field_dest = after_discr.offset(field.offset as isize);\n-                    try!(self.move_(src, field_dest, src_ty));\n-                }\n-            }\n-            _ => panic!(\"expected Repr::Aggregate target\"),\n+        for (offset, operand) in offsets.into_iter().zip(operands) {\n+            let src = try!(self.eval_operand(operand));\n+            let src_ty = self.operand_ty(operand);\n+            let field_dest = dest.offset(offset as isize);\n+            try!(self.move_(src, field_dest, src_ty));\n         }\n         Ok(())\n     }\n@@ -609,7 +609,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n     {\n         let dest = try!(self.eval_lvalue(lvalue)).to_ptr();\n         let dest_ty = self.lvalue_ty(lvalue);\n-        let dest_repr = self.lvalue_repr(lvalue);\n+        let dest_layout = self.type_layout(dest_ty);\n \n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n@@ -639,39 +639,85 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             }\n \n             Aggregate(ref kind, ref operands) => {\n-                use rustc::mir::repr::AggregateKind::*;\n-                match *kind {\n-                    Tuple | Closure(..) =>\n-                        try!(self.assign_to_aggregate(dest, &dest_repr, 0, None, operands)),\n-\n-                    Adt(adt_def, variant, _) => {\n-                        let discr = Some(adt_def.variants[variant].disr_val.to_u64_unchecked());\n-                        try!(self.assign_to_aggregate(dest, &dest_repr, variant, discr, operands));\n+                use rustc::ty::layout::Layout::*;\n+                match *dest_layout {\n+                    Univariant { ref variant, .. } => {\n+                        let offsets = iter::once(0)\n+                            .chain(variant.offset_after_field.iter().map(|s| s.bytes()));\n+                        try!(self.assign_fields(dest, offsets, operands));\n+                    }\n+\n+                    Array { .. } => {\n+                        let elem_size = match dest_ty.sty {\n+                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty) as u64,\n+                            _ => panic!(\"tried to assign {:?} to non-array type {:?}\",\n+                                        kind, dest_ty),\n+                        };\n+                        let offsets = (0..).map(|i| i * elem_size);\n+                        try!(self.assign_fields(dest, offsets, operands));\n                     }\n \n-                    Vec => if let Repr::Array { elem_size, length } = *dest_repr {\n-                        assert_eq!(length, operands.len());\n-                        for (i, operand) in operands.iter().enumerate() {\n-                            let src = try!(self.eval_operand(operand));\n-                            let src_ty = self.operand_ty(operand);\n-                            let elem_dest = dest.offset((i * elem_size) as isize);\n-                            try!(self.move_(src, elem_dest, src_ty));\n+                    General { discr, ref variants, .. } => {\n+                        if let mir::AggregateKind::Adt(adt_def, variant, _) = *kind {\n+                            let discr_val = adt_def.variants[variant].disr_val.to_u64_unchecked();\n+                            let discr_size = discr.size().bytes() as usize;\n+                            try!(self.memory.write_uint(dest, discr_val, discr_size));\n+\n+                            let offsets = variants[variant].offset_after_field.iter()\n+                                .map(|s| s.bytes());\n+                            try!(self.assign_fields(dest, offsets, operands));\n+                        } else {\n+                            panic!(\"tried to assign {:?} to Layout::General\", kind);\n                         }\n-                    } else {\n-                        panic!(\"expected Repr::Array target\");\n-                    },\n+                    }\n+\n+                    RawNullablePointer { nndiscr, .. } => {\n+                        if let mir::AggregateKind::Adt(_, variant, _) = *kind {\n+                            if nndiscr == variant as u64 {\n+                                assert_eq!(operands.len(), 1);\n+                                let operand = &operands[0];\n+                                let src = try!(self.eval_operand(operand));\n+                                let src_ty = self.operand_ty(operand);\n+                                try!(self.move_(src, dest, src_ty));\n+                            } else {\n+                                assert_eq!(operands.len(), 0);\n+                                try!(self.memory.write_isize(dest, 0));\n+                            }\n+                        } else {\n+                            panic!(\"tried to assign {:?} to Layout::RawNullablePointer\", kind);\n+                        }\n+                    }\n+\n+                    CEnum { discr, signed, min, max } => {\n+                        assert_eq!(operands.len(), 0);\n+                        if let mir::AggregateKind::Adt(adt_def, variant, _) = *kind {\n+                            if signed {\n+                                unimplemented!()\n+                            } else {\n+                                let val = adt_def.variants[variant].disr_val.to_u64().unwrap();\n+                                let size = discr.size().bytes() as usize;\n+                                try!(self.memory.write_uint(dest, val, size));\n+                            }\n+                        } else {\n+                            panic!(\"tried to assign {:?} to Layout::CEnum\", kind);\n+                        }\n+                    }\n+\n+                    _ => panic!(\"can't handle destination layout {:?} when assigning {:?}\",\n+                                dest_layout, kind),\n                 }\n             }\n \n             Repeat(ref operand, _) => {\n-                if let Repr::Array { elem_size, length } = *dest_repr {\n-                    let src = try!(self.eval_operand(operand));\n-                    for i in 0..length {\n-                        let elem_dest = dest.offset((i * elem_size) as isize);\n-                        try!(self.memory.copy(src, elem_dest, elem_size));\n-                    }\n-                } else {\n-                    panic!(\"expected Repr::Array target\");\n+                let (elem_size, length) = match dest_ty.sty {\n+                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty), n),\n+                    _ => panic!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n+                };\n+\n+                let src = try!(self.eval_operand(operand));\n+                for i in 0..length {\n+                    let elem_dest = dest.offset((i * elem_size) as isize);\n+                    try!(self.memory.copy(src, elem_dest, elem_size));\n                 }\n             }\n \n@@ -699,6 +745,8 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                         let len_ptr = dest.offset(self.memory.pointer_size as isize);\n                         try!(self.memory.write_usize(len_ptr, len));\n                     }\n+                    LvalueExtra::DowncastVariant(..) =>\n+                        panic!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 }\n             }\n \n@@ -731,7 +779,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n \n                     Misc => {\n                         // FIXME(tsion): Wrong for almost everything.\n-                        let size = dest_repr.size();\n+                        let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n                         try!(self.memory.copy(src, dest, size));\n                     }\n \n@@ -747,42 +795,20 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n     }\n \n     fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<Pointer> {\n-        self.eval_operand_and_repr(op).map(|(p, _)| p)\n-    }\n-\n-    fn eval_operand_and_repr(&mut self, op: &mir::Operand<'tcx>)\n-        -> EvalResult<(Pointer, &'arena Repr)>\n-    {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n             Consume(ref lvalue) =>\n-                Ok((try!(self.eval_lvalue(lvalue)).to_ptr(), self.lvalue_repr(lvalue))),\n-            Constant(mir::Constant { ref literal, ty, .. }) => {\n+                Ok(try!(self.eval_lvalue(lvalue)).to_ptr()),\n+            Constant(mir::Constant { ref literal, .. }) => {\n                 use rustc::mir::repr::Literal::*;\n                 match *literal {\n-                    Value { ref value } => Ok((\n-                        try!(self.const_to_ptr(value)),\n-                        self.type_repr(ty),\n-                    )),\n+                    Value { ref value } => Ok(try!(self.const_to_ptr(value))),\n                     Item { .. } => unimplemented!(),\n                 }\n             }\n         }\n     }\n \n-    // TODO(tsion): Replace this inefficient hack with a wrapper like LvalueTy (e.g. LvalueRepr).\n-    fn lvalue_repr(&self, lvalue: &mir::Lvalue<'tcx>) -> &'arena Repr {\n-        use rustc::mir::tcx::LvalueTy;\n-        match self.mir().lvalue_ty(self.tcx, lvalue) {\n-            LvalueTy::Ty { ty } => self.type_repr(ty),\n-            LvalueTy::Downcast { adt_def, substs, variant_index } => {\n-                let field_tys = adt_def.variants[variant_index].fields.iter()\n-                    .map(|f| f.ty(self.tcx, substs));\n-                self.repr_arena.alloc(self.make_aggregate_repr(iter::once(field_tys)))\n-            }\n-        }\n-    }\n-\n     fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<Lvalue> {\n         use rustc::mir::repr::Lvalue::*;\n         let ptr = match *lvalue {\n@@ -795,30 +821,50 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             Static(_def_id) => unimplemented!(),\n \n             Projection(ref proj) => {\n-                let base_ptr = try!(self.eval_lvalue(&proj.base)).to_ptr();\n-                let base_repr = self.lvalue_repr(&proj.base);\n+                let base = try!(self.eval_lvalue(&proj.base));\n                 let base_ty = self.lvalue_ty(&proj.base);\n+                let base_layout = self.type_layout(base_ty);\n+\n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n-                    Field(field, _) => match *base_repr {\n-                        Repr::Aggregate { discr_size: 0, ref variants, .. } => {\n-                            let fields = &variants[0];\n-                            base_ptr.offset(fields[field.index()].offset as isize)\n-                        }\n-                        _ => panic!(\"field access on non-product type: {:?}\", base_repr),\n+                    Field(field, _) => {\n+                        let variant = match *base_layout {\n+                            Layout::Univariant { ref variant, .. } => variant,\n+                            Layout::General { ref variants, .. } => {\n+                                if let LvalueExtra::DowncastVariant(variant_idx) = base.extra {\n+                                    &variants[variant_idx]\n+                                } else {\n+                                    panic!(\"field access on enum had no variant index\");\n+                                }\n+                            }\n+                            Layout::RawNullablePointer { .. } => {\n+                                assert_eq!(field.index(), 0);\n+                                return Ok(base);\n+                            }\n+                            _ => panic!(\"field access on non-product type: {:?}\", base_layout),\n+                        };\n+\n+                        let offset = variant.field_offset(field.index()).bytes();\n+                        base.ptr.offset(offset as isize)\n                     },\n \n-                    Downcast(..) => match *base_repr {\n-                        Repr::Aggregate { discr_size, .. } => base_ptr.offset(discr_size as isize),\n-                        _ => panic!(\"variant downcast on non-aggregate type: {:?}\", base_repr),\n+                    Downcast(_, variant) => match *base_layout {\n+                        Layout::General { discr, .. } => {\n+                            return Ok(Lvalue {\n+                                ptr: base.ptr.offset(discr.size().bytes() as isize),\n+                                extra: LvalueExtra::DowncastVariant(variant),\n+                            });\n+                        }\n+                        Layout::RawNullablePointer { .. } => return Ok(base),\n+                        _ => panic!(\"variant downcast on non-aggregate type: {:?}\", base_layout),\n                     },\n \n                     Deref => {\n                         let pointee_ty = pointee_type(base_ty).expect(\"Deref of non-pointer\");\n-                        let ptr = try!(self.memory.read_ptr(base_ptr));\n+                        let ptr = try!(self.memory.read_ptr(base.ptr));\n                         let extra = match pointee_ty.sty {\n                             ty::TySlice(_) | ty::TyStr => {\n-                                let len_ptr = base_ptr.offset(self.memory.pointer_size as isize);\n+                                let len_ptr = base.ptr.offset(self.memory.pointer_size as isize);\n                                 let len = try!(self.memory.read_usize(len_ptr));\n                                 LvalueExtra::Length(len)\n                             }\n@@ -836,7 +882,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                         };\n                         let n_ptr = try!(self.eval_operand(operand));\n                         let n = try!(self.memory.read_usize(n_ptr));\n-                        base_ptr.offset(n as isize * elem_size as isize)\n+                        base.ptr.offset(n as isize * elem_size as isize)\n                     }\n \n                     ConstantIndex { .. } => unimplemented!(),\n@@ -921,99 +967,17 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n     }\n \n     fn type_size(&self, ty: ty::Ty<'tcx>) -> usize {\n-        self.type_repr(ty).size()\n+        self.type_layout(ty).size(&self.tcx.data_layout).bytes() as usize\n     }\n \n-    fn type_repr(&self, ty: ty::Ty<'tcx>) -> &'arena Repr {\n+    fn type_layout(&self, ty: ty::Ty<'tcx>) -> &'tcx Layout {\n+        // TODO(tsion): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty);\n \n-        if let Some(repr) = self.repr_cache.borrow().get(ty) {\n-            return repr;\n-        }\n-\n-        use syntax::ast::{IntTy, UintTy};\n-        let repr = match ty.sty {\n-            ty::TyBool => Repr::Primitive { size: 1 },\n-\n-            ty::TyInt(IntTy::I8)  | ty::TyUint(UintTy::U8)  => Repr::Primitive { size: 1 },\n-            ty::TyInt(IntTy::I16) | ty::TyUint(UintTy::U16) => Repr::Primitive { size: 2 },\n-            ty::TyInt(IntTy::I32) | ty::TyUint(UintTy::U32) => Repr::Primitive { size: 4 },\n-            ty::TyInt(IntTy::I64) | ty::TyUint(UintTy::U64) => Repr::Primitive { size: 8 },\n-\n-            ty::TyInt(IntTy::Is) | ty::TyUint(UintTy::Us) =>\n-                Repr::Primitive { size: self.memory.pointer_size },\n-\n-            ty::TyTuple(ref fields) =>\n-                self.make_aggregate_repr(iter::once(fields.iter().cloned())),\n-\n-            ty::TyEnum(adt_def, substs) | ty::TyStruct(adt_def, substs) => {\n-                let variants = adt_def.variants.iter().map(|v| {\n-                    v.fields.iter().map(|f| f.ty(self.tcx, substs))\n-                });\n-                self.make_aggregate_repr(variants)\n-            }\n-\n-            ty::TyArray(elem_ty, length) => Repr::Array {\n-                elem_size: self.type_size(elem_ty),\n-                length: length,\n-            },\n-\n-            ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-            ty::TyBox(ty) => {\n-                if self.type_is_sized(ty) {\n-                    Repr::Primitive { size: self.memory.pointer_size }\n-                } else {\n-                    Repr::Primitive { size: self.memory.pointer_size * 2 }\n-                }\n-            }\n-\n-            ty::TyFnPtr(..) => Repr::Primitive { size: self.memory.pointer_size },\n-\n-            ty::TyClosure(_, ref closure_substs) =>\n-                self.make_aggregate_repr(iter::once(closure_substs.upvar_tys.iter().cloned())),\n-\n-            ref t => panic!(\"can't convert type to repr: {:?}\", t),\n-        };\n-\n-        let repr_ref = self.repr_arena.alloc(repr);\n-        self.repr_cache.borrow_mut().insert(ty, repr_ref);\n-        repr_ref\n-    }\n-\n-    fn make_aggregate_repr<V>(&self, variant_fields: V) -> Repr\n-        where V: IntoIterator, V::Item: IntoIterator<Item = ty::Ty<'tcx>>\n-    {\n-        let mut variants = Vec::new();\n-        let mut max_variant_size = 0;\n-\n-        for field_tys in variant_fields {\n-            let mut fields = Vec::new();\n-            let mut size = 0;\n-\n-            for ty in field_tys {\n-                let field_size = self.type_size(ty);\n-                let offest = size;\n-                size += field_size;\n-                fields.push(FieldRepr { offset: offest, size: field_size });\n-            }\n-\n-            if size > max_variant_size { max_variant_size = size; }\n-            variants.push(fields);\n-        }\n+        let infcx = infer::normalizing_infer_ctxt(self.tcx, &self.tcx.tables, ProjectionMode::Any);\n \n-        let discr_size = match variants.len() as u64 {\n-            n if n <= 1       => 0,\n-            n if n <= 1 << 8  => 1,\n-            n if n <= 1 << 16 => 2,\n-            n if n <= 1 << 32 => 4,\n-            _                 => 8,\n-        };\n-        Repr::Aggregate {\n-            discr_size: discr_size,\n-            size: max_variant_size + discr_size,\n-            variants: variants,\n-        }\n+        // TODO(tsion): Report this error properly.\n+        ty.layout(&infcx).unwrap()\n     }\n \n     pub fn read_primval(&mut self, ptr: Pointer, ty: ty::Ty<'tcx>) -> EvalResult<PrimVal> {\n@@ -1235,8 +1199,7 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n \n                 println!(\"Interpreting: {}\", item.name);\n \n-                let repr_arena = TypedArena::new();\n-                let mut miri = Interpreter::new(tcx, mir_map, &repr_arena);\n+                let mut miri = Interpreter::new(tcx, mir_map);\n                 let return_ptr = match mir.return_ty {\n                     ty::FnConverging(ty) => {\n                         let size = miri.type_size(ty);\n@@ -1257,3 +1220,35 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n         }\n     }\n }\n+\n+// TODO(tsion): Upstream these methods into rustc::ty::layout.\n+\n+trait IntegerExt {\n+    fn size(self) -> Size;\n+}\n+\n+impl IntegerExt for layout::Integer {\n+    fn size(self) -> Size {\n+        use rustc::ty::layout::Integer::*;\n+        match self {\n+            I1 | I8 => Size::from_bits(8),\n+            I16 => Size::from_bits(16),\n+            I32 => Size::from_bits(32),\n+            I64 => Size::from_bits(64),\n+        }\n+    }\n+}\n+\n+trait StructExt {\n+    fn field_offset(&self, index: usize) -> Size;\n+}\n+\n+impl StructExt for layout::Struct {\n+    fn field_offset(&self, index: usize) -> Size {\n+        if index == 0 {\n+            Size::from_bytes(0)\n+        } else {\n+            self.offset_after_field[index - 1]\n+        }\n+    }\n+}"}, {"sha": "0bf7dfb87d14c533c2d16db7621308ffa36821c9", "filename": "src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -8,9 +8,7 @@\n )]\n \n // From rustc.\n-extern crate arena;\n #[macro_use] extern crate rustc;\n-extern crate rustc_data_structures;\n extern crate rustc_mir;\n extern crate syntax;\n "}, {"sha": "45f8b392c0060ad72e0b0f954b196d0e9bf8d56f", "filename": "src/memory.rs", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -6,54 +6,6 @@ use std::{fmt, iter, mem, ptr};\n use error::{EvalError, EvalResult};\n use primval::PrimVal;\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Value representations\n-////////////////////////////////////////////////////////////////////////////////\n-\n-#[derive(Clone, Debug, Eq, PartialEq)]\n-pub enum Repr {\n-    /// Representation for a non-aggregate type such as a boolean, integer, character or pointer.\n-    Primitive {\n-        size: usize\n-    },\n-\n-    /// The representation for aggregate types including structs, enums, and tuples.\n-    Aggregate {\n-        /// The size of the discriminant (an integer). Should be between 0 and 8. Always 0 for\n-        /// structs and tuples.\n-        discr_size: usize,\n-\n-        /// The size of the entire aggregate, including the discriminant.\n-        size: usize,\n-\n-        /// The representations of the contents of each variant.\n-        variants: Vec<Vec<FieldRepr>>,\n-    },\n-\n-    Array {\n-        elem_size: usize,\n-\n-        /// Number of elements.\n-        length: usize,\n-    },\n-}\n-\n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub struct FieldRepr {\n-    pub offset: usize,\n-    pub size: usize,\n-}\n-\n-impl Repr {\n-    pub fn size(&self) -> usize {\n-        match *self {\n-            Repr::Primitive { size } |\n-            Repr::Aggregate { size, .. } => size,\n-            Repr::Array { elem_size, length } => elem_size * length,\n-        }\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////\n@@ -451,7 +403,7 @@ impl Memory {\n     // Undefined bytes\n     ////////////////////////////////////////////////////////////////////////////////\n \n-    // FIXME(tsino): This is a very naive, slow version.\n+    // FIXME(tsion): This is a very naive, slow version.\n     fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         let mut v = Vec::with_capacity(size);"}, {"sha": "ad96fbe7d41997c20e4c8052077fc250c8614bde", "filename": "src/primval.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -14,10 +14,11 @@ pub enum PrimVal {\n }\n \n pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResult<PrimVal> {\n+    use rustc::mir::repr::BinOp::*;\n+    use self::PrimVal::*;\n+\n     macro_rules! int_binops {\n         ($v:ident, $l:ident, $r:ident) => ({\n-            use rustc::mir::repr::BinOp::*;\n-            use self::PrimVal::*;\n             match bin_op {\n                 Add    => $v($l + $r),\n                 Sub    => $v($l - $r),\n@@ -52,7 +53,6 @@ pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResul\n         }\n     }\n \n-    use self::PrimVal::*;\n     let val = match (left, right) {\n         (I8(l),  I8(r))  => int_binops!(I8, l, r),\n         (I16(l), I16(r)) => int_binops!(I16, l, r),\n@@ -63,6 +63,22 @@ pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResul\n         (U32(l), U32(r)) => int_binops!(U32, l, r),\n         (U64(l), U64(r)) => int_binops!(U64, l, r),\n \n+        (Bool(l), Bool(r)) => {\n+            Bool(match bin_op {\n+                Eq => l == r,\n+                Ne => l != r,\n+                Lt => l < r,\n+                Le => l <= r,\n+                Gt => l > r,\n+                Ge => l >= r,\n+                BitOr => l | r,\n+                BitXor => l ^ r,\n+                BitAnd => l & r,\n+                Add | Sub | Mul | Div | Rem | Shl | Shr =>\n+                    panic!(\"invalid binary operation on booleans: {:?}\", bin_op),\n+            })\n+        }\n+\n         (IntegerPtr(l), IntegerPtr(r)) => int_binops!(IntegerPtr, l, r),\n \n         (AbstractPtr(_), IntegerPtr(_)) | (IntegerPtr(_), AbstractPtr(_)) =>\n@@ -76,7 +92,6 @@ pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResul\n             let l = l_ptr.offset;\n             let r = r_ptr.offset;\n \n-            use rustc::mir::repr::BinOp::*;\n             match bin_op {\n                 Eq => Bool(l == r),\n                 Ne => Bool(l != r),"}, {"sha": "52a76247ca46841a7382584360ebb3c459893b28", "filename": "tests/compile-fail/bugs/slice_index.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71bdabcdd9a61a58b6854eb05deda545783880d2/tests%2Fcompile-fail%2Fbugs%2Fslice_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bdabcdd9a61a58b6854eb05deda545783880d2/tests%2Fcompile-fail%2Fbugs%2Fslice_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbugs%2Fslice_index.rs?ref=71bdabcdd9a61a58b6854eb05deda545783880d2", "patch": "@@ -1,12 +0,0 @@\n-#![feature(custom_attribute)]\n-#![allow(dead_code, unused_attributes)]\n-\n-// error-pattern:assertion failed\n-\n-#[miri_run]\n-fn slice() -> u8 {\n-    let arr: &[_] = &[101, 102, 103, 104, 105, 106];\n-    arr[5]\n-}\n-\n-fn main() {}"}, {"sha": "880ca42d45557942593f61e4377775b47ee5a234", "filename": "tests/compile-fail/bugs/struct_wrapped_nullable_pointer.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tests%2Fcompile-fail%2Fbugs%2Fstruct_wrapped_nullable_pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tests%2Fcompile-fail%2Fbugs%2Fstruct_wrapped_nullable_pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbugs%2Fstruct_wrapped_nullable_pointer.rs?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -0,0 +1,23 @@\n+#![feature(custom_attribute, box_syntax)]\n+#![allow(dead_code, unused_attributes)]\n+\n+// error-pattern:can't handle destination layout StructWrappedNullablePointer\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+struct Loop(Rc<RefCell<Option<Loop>>>);\n+\n+#[miri_run]\n+fn rc_reference_cycle() -> Loop {\n+    let a = Rc::new(RefCell::new(None));\n+    let b = a.clone();\n+    *a.borrow_mut() = Some(Loop(b));\n+    Loop(a)\n+}\n+\n+#[miri_run]\n+fn main() {\n+    let x = rc_reference_cycle().0;\n+    assert!(x.borrow().is_some());\n+}"}, {"sha": "1fbf24b46684e66fc6d4b94a9af207af499b88a8", "filename": "tests/run-pass/arrays.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tests%2Frun-pass%2Farrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tests%2Frun-pass%2Farrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Farrays.rs?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -38,11 +38,18 @@ fn array_repeat() -> [u8; 8] {\n     [42; 8]\n }\n \n+#[miri_run]\n+fn slice_index() -> u8 {\n+    let arr: &[_] = &[101, 102, 103, 104, 105, 106];\n+    arr[5]\n+}\n+\n #[miri_run]\n fn main() {\n     //assert_eq!(empty_array(), []);\n     assert_eq!(index_unsafe(), 20);\n     assert_eq!(index(), 20);\n+    assert_eq!(slice_index(), 106);\n     /*\n     assert_eq!(big_array(), [5, 4, 3, 2, 1]);\n     assert_eq!(array_array(), [[5, 4], [3, 2], [1, 0]]);"}, {"sha": "55beb11edd4497c26dcd8f1c2384d5c057bb80bf", "filename": "tests/run-pass/option_box_transmute_ptr.rs", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tests%2Frun-pass%2Foption_box_transmute_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tests%2Frun-pass%2Foption_box_transmute_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Foption_box_transmute_ptr.rs?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -1,11 +1,13 @@\n #![feature(custom_attribute)]\n #![allow(dead_code, unused_attributes)]\n \n+// This tests that the size of Option<Box<i32>> is the same as *const i32.\n+\n #[miri_run]\n fn option_box_deref() -> i32 {\n     let val = Some(Box::new(42));\n     unsafe {\n-        let ptr: *const i32 = std::mem::transmute(val); //~ ERROR: pointer offset outside bounds of allocation\n+        let ptr: *const i32 = std::mem::transmute::<Option<Box<i32>>, *const i32>(val);\n         *ptr\n     }\n }", "previous_filename": "tests/compile-fail/bugs/option_box_transmute_ptr.rs"}, {"sha": "4b5f510ad44091789ca67775fcf4e7ed59e587e5", "filename": "tests/run-pass/specialization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tests%2Frun-pass%2Fspecialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tests%2Frun-pass%2Fspecialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fspecialization.rs?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -18,6 +18,7 @@ fn specialization() -> (bool, bool) {\n     (i32::is_unit(), <()>::is_unit())\n }\n \n+#[miri_run]\n fn main() {\n     assert_eq!(specialization(), (false, true));\n }"}, {"sha": "b5bb7c7dbdb9f09a7e5281f16c9ec8580b16eec1", "filename": "tests/run-pass/std.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tests%2Frun-pass%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tests%2Frun-pass%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstd.rs?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -1,7 +1,7 @@\n #![feature(custom_attribute, box_syntax)]\n #![allow(dead_code, unused_attributes)]\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::rc::Rc;\n use std::sync::Arc;\n \n@@ -29,25 +29,13 @@ fn arc() -> Arc<i32> {\n     a\n }\n \n-struct Loop(Rc<RefCell<Option<Loop>>>);\n-\n-#[miri_run]\n-fn rc_reference_cycle() -> Loop {\n-    let a = Rc::new(RefCell::new(None));\n-    let b = a.clone();\n-    *a.borrow_mut() = Some(Loop(b));\n-    Loop(a)\n-}\n-\n #[miri_run]\n fn true_assert() {\n     assert_eq!(1, 1);\n }\n \n #[miri_run]\n fn main() {\n-    //let x = rc_reference_cycle().0;\n-    //assert!(x.borrow().is_some());\n     assert_eq!(*arc(), 42);\n     assert_eq!(rc_cell().get(), 84);\n }"}, {"sha": "d6eddc69fc9a5b5b0d4454b5310528114d193913", "filename": "tests/run-pass/sums.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tests%2Frun-pass%2Fsums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tests%2Frun-pass%2Fsums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsums.rs?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -2,24 +2,24 @@\n #![allow(dead_code, unused_attributes)]\n \n #[derive(Debug, PartialEq)]\n-enum Unit { Unit }\n+enum Unit { Unit(()) } // Force non-C-enum representation.\n \n #[miri_run]\n fn return_unit() -> Unit {\n-    Unit::Unit\n+    Unit::Unit(())\n }\n \n #[derive(Debug, PartialEq)]\n-enum MyBool { False, True }\n+enum MyBool { False(()), True(()) } // Force non-C-enum representation.\n \n #[miri_run]\n fn return_true() -> MyBool {\n-    MyBool::True\n+    MyBool::True(())\n }\n \n #[miri_run]\n fn return_false() -> MyBool {\n-    MyBool::False\n+    MyBool::False(())\n }\n \n #[miri_run]"}, {"sha": "9ef9652eed1d328ebdcd2632001badd688e0e0e1", "filename": "tex/report/miri-report.tex", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tex%2Freport%2Fmiri-report.tex", "raw_url": "https://github.com/rust-lang/rust/raw/5f07e2ebd30423cefb704742bcc85ad4dc8eaa49/tex%2Freport%2Fmiri-report.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Freport%2Fmiri-report.tex?ref=5f07e2ebd30423cefb704742bcc85ad4dc8eaa49", "patch": "@@ -536,12 +536,6 @@ \\subsection{Standard library}\n \\emph{does} invoke undefined behaviour, Miri will abort with an appropriate error message (see\n \\autoref{fig:vec-error}).\n \n-% You can even do unsafe things with \\rust{Vec} like \\rust{v.set_len(10)} or\n-% \\rust{v.get_unchecked(2)}, but if you do these things carefully in a way that doesn't cause any\n-% undefined behaviour (just like when you write unsafe code for regular Rust), then Miri can handle it\n-% all. But if you do slip up, Miri will error out with an appropriate message (see\n-% \\autoref{fig:vec-error}).\n-\n \\begin{figure}[t]\n   \\begin{minted}[autogobble]{rust}\n     fn out_of_bounds() -> u8 {"}]}