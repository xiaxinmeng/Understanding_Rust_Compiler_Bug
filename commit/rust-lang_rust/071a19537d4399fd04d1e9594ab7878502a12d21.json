{"sha": "071a19537d4399fd04d1e9594ab7878502a12d21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MWExOTUzN2Q0Mzk5ZmQwNGQxZTk1OTRhYjc4Nzg1MDJhMTJkMjE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-26T15:03:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-26T15:03:17Z"}, "message": "strongy-typed ids for macros", "tree": {"sha": "b6cdd380b2af4f570ebc6e831ef3ebaa5c4e9adc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6cdd380b2af4f570ebc6e831ef3ebaa5c4e9adc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/071a19537d4399fd04d1e9594ab7878502a12d21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/071a19537d4399fd04d1e9594ab7878502a12d21", "html_url": "https://github.com/rust-lang/rust/commit/071a19537d4399fd04d1e9594ab7878502a12d21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/071a19537d4399fd04d1e9594ab7878502a12d21/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb8b354dcc837d5eb9b81fc205e4282a203df177", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb8b354dcc837d5eb9b81fc205e4282a203df177", "html_url": "https://github.com/rust-lang/rust/commit/fb8b354dcc837d5eb9b81fc205e4282a203df177"}], "stats": {"total": 52, "additions": 19, "deletions": 33}, "files": [{"sha": "b503e0ee5931a1a86f09b3f3cd79ae88792151c0", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/071a19537d4399fd04d1e9594ab7878502a12d21/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/071a19537d4399fd04d1e9594ab7878502a12d21/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=071a19537d4399fd04d1e9594ab7878502a12d21", "patch": "@@ -10,7 +10,7 @@ use ra_arena::{RawId, ArenaId, impl_arena_id};\n use mbe::MacroRules;\n \n use crate::{\n-    Module, DefDatabase, SourceItemId, SourceFileItemId,\n+    Module, DefDatabase, SourceItemId, SourceFileItemId, AstId,\n };\n \n #[derive(Debug, Default)]\n@@ -68,7 +68,7 @@ impl HirFileId {\n             HirFileIdRepr::File(file_id) => file_id,\n             HirFileIdRepr::Macro(macro_call_id) => {\n                 let loc = macro_call_id.loc(db);\n-                loc.source_item_id.file_id.original_file(db)\n+                loc.ast_id.file_id().original_file(db)\n             }\n         }\n     }\n@@ -96,8 +96,7 @@ impl HirFileId {\n \n fn parse_macro(db: &impl DefDatabase, macro_call_id: MacroCallId) -> Option<TreeArc<SourceFile>> {\n     let loc = macro_call_id.loc(db);\n-    let syntax = db.file_item(loc.source_item_id);\n-    let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n+    let macro_call = loc.ast_id.to_node(db);\n     let (macro_arg, _) = macro_call.token_tree().and_then(mbe::ast_to_token_tree)?;\n \n     let macro_rules = db.macro_def(loc.def)?;\n@@ -124,15 +123,10 @@ impl From<MacroCallId> for HirFileId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum MacroDefId {\n-    MacroByExample { source_item_id: SourceItemId },\n-}\n+pub struct MacroDefId(pub(crate) AstId<ast::MacroCall>);\n \n pub(crate) fn macro_def_query(db: &impl DefDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n-    let syntax_node = match id {\n-        MacroDefId::MacroByExample { source_item_id } => db.file_item(source_item_id),\n-    };\n-    let macro_call = ast::MacroCall::cast(&syntax_node).unwrap();\n+    let macro_call = id.0.to_node(db);\n     let arg = macro_call.token_tree()?;\n     let (tt, _) = mbe::ast_to_token_tree(arg)?;\n     let rules = MacroRules::parse(&tt).ok()?;\n@@ -148,7 +142,7 @@ impl_arena_id!(MacroCallId);\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n     pub(crate) def: MacroDefId,\n-    pub(crate) source_item_id: SourceItemId,\n+    pub(crate) ast_id: AstId<ast::MacroCall>,\n }\n \n impl MacroCallId {"}, {"sha": "b5f02ab803d529fccdcd5c161ea50a9b4306ac25", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/071a19537d4399fd04d1e9594ab7878502a12d21/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/071a19537d4399fd04d1e9594ab7878502a12d21/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=071a19537d4399fd04d1e9594ab7878502a12d21", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::ast;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    DefDatabase, HirFileId, Name, Path, SourceItemId,\n+    DefDatabase, HirFileId, Name, Path,\n     KnownName,\n     nameres::{\n         Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode,\n@@ -53,7 +53,7 @@ struct DefCollector<DB> {\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n-    unexpanded_macros: Vec<(CrateModuleId, SourceItemId, Path)>,\n+    unexpanded_macros: Vec<(CrateModuleId, AstId<ast::MacroCall>, Path)>,\n     global_macro_scope: FxHashMap<Name, MacroDefId>,\n }\n \n@@ -295,7 +295,7 @@ where\n         let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n-        macros.retain(|(module_id, source_item_id, path)| {\n+        macros.retain(|(module_id, ast_id, path)| {\n             if path.segments.len() != 2 {\n                 return true;\n             }\n@@ -311,8 +311,7 @@ where\n             res = ReachedFixedPoint::No;\n             let def_map = self.db.crate_def_map(krate);\n             if let Some(macro_id) = def_map.public_macros.get(&path.segments[1].name).cloned() {\n-                let call_id =\n-                    MacroCallLoc { def: macro_id, source_item_id: *source_item_id }.id(self.db);\n+                let call_id = MacroCallLoc { def: macro_id, ast_id: *ast_id }.id(self.db);\n                 resolved.push((*module_id, call_id));\n             }\n             false\n@@ -456,34 +455,27 @@ where\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                let macro_id = MacroDefId::MacroByExample {\n-                    source_item_id: mac.source_item_id.with_file_id(self.file_id),\n-                };\n+                let macro_id = MacroDefId(mac.ast_id.with_file_id(self.file_id));\n                 self.def_collector.define_macro(name.clone(), macro_id, mac.export)\n             }\n             return;\n         }\n \n-        let source_item_id = SourceItemId { file_id: self.file_id, item_id: mac.source_item_id };\n+        let ast_id = mac.ast_id.with_file_id(self.file_id);\n \n         // Case 2: try to expand macro_rules from this crate, triggering\n         // recursive item collection.\n         if let Some(&macro_id) =\n             mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(name))\n         {\n-            let macro_call_id =\n-                MacroCallLoc { def: macro_id, source_item_id }.id(self.def_collector.db);\n+            let macro_call_id = MacroCallLoc { def: macro_id, ast_id }.id(self.def_collector.db);\n \n             self.def_collector.collect_macro_expansion(self.module_id, macro_call_id);\n             return;\n         }\n \n         // Case 3: path to a macro from another crate, expand during name resolution\n-        self.def_collector.unexpanded_macros.push((\n-            self.module_id,\n-            source_item_id,\n-            mac.path.clone(),\n-        ))\n+        self.def_collector.unexpanded_macros.push((self.module_id, ast_id, mac.path.clone()))\n     }\n }\n "}, {"sha": "684bd1d50e5dde862b879017d9cf003af46f066a", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/071a19537d4399fd04d1e9594ab7878502a12d21/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/071a19537d4399fd04d1e9594ab7878502a12d21/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=071a19537d4399fd04d1e9594ab7878502a12d21", "patch": "@@ -160,7 +160,7 @@ impl_arena_id!(Macro);\n \n #[derive(Debug, PartialEq, Eq)]\n pub(super) struct MacroData {\n-    pub(super) source_item_id: SourceFileItemId,\n+    pub(super) ast_id: FileAstId<ast::MacroCall>,\n     pub(super) path: Path,\n     pub(super) name: Option<Name>,\n     pub(super) export: bool,\n@@ -285,9 +285,9 @@ impl RawItemsCollector {\n         };\n \n         let name = m.name().map(|it| it.as_name());\n-        let source_item_id = self.source_file_items.id_of_unchecked(m.syntax());\n+        let ast_id = self.source_file_items.ast_id(m);\n         let export = m.has_atom_attr(\"macro_export\");\n-        let m = self.raw_items.macros.alloc(MacroData { source_item_id, path, name, export });\n+        let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export });\n         self.push_item(current_module, RawItem::Macro(m));\n     }\n "}, {"sha": "1dadd76c51ac4e7ad0d795b9c4f6706b769d6c46", "filename": "crates/ra_hir/src/source_id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/071a19537d4399fd04d1e9594ab7878502a12d21/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/071a19537d4399fd04d1e9594ab7878502a12d21/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_id.rs?ref=071a19537d4399fd04d1e9594ab7878502a12d21", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{SyntaxNodePtr, TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n \n use crate::{HirFileId, DefDatabase};\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq, Hash)]\n pub(crate) struct AstId<N: AstNode> {\n     file_id: HirFileId,\n     file_ast_id: FileAstId<N>,\n@@ -30,7 +30,7 @@ impl<N: AstNode> AstId<N> {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq, Hash)]\n pub(crate) struct FileAstId<N: AstNode> {\n     raw: SourceFileItemId,\n     _ty: PhantomData<N>,"}]}