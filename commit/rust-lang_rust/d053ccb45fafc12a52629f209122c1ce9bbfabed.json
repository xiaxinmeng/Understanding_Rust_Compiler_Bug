{"sha": "d053ccb45fafc12a52629f209122c1ce9bbfabed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNTNjY2I0NWZhZmMxMmE1MjYyOWYyMDkxMjJjMWNlOWJiZmFiZWQ=", "commit": {"author": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2015-01-10T13:53:22Z"}, "committer": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2015-01-18T15:12:45Z"}, "message": "std::dynamic_lib: Fix Windows error handling\n\nThis is a [breaking-change] since `std::dynamic_lib::dl` is now\nprivate.\n\nWhen `LoadLibraryW()` fails, original code called `errno()` to get error\ncode.  However, there was local allocation of `Vec` before\n`LoadLibraryW()`, and it drops before `errno()`, and the drop\n(deallocation) changed `errno`! Therefore `dynamic_lib::open()` thought\nit always succeeded.\nThis commit fixes the issue.\n\nThis commit also sets Windows error mode during `LoadLibrary()` to\nprevent \"dll load failed\" dialog.", "tree": {"sha": "f51caa00a27c5f369b7044f54ea2c5539793e3b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f51caa00a27c5f369b7044f54ea2c5539793e3b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d053ccb45fafc12a52629f209122c1ce9bbfabed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d053ccb45fafc12a52629f209122c1ce9bbfabed", "html_url": "https://github.com/rust-lang/rust/commit/d053ccb45fafc12a52629f209122c1ce9bbfabed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d053ccb45fafc12a52629f209122c1ce9bbfabed/comments", "author": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcaeb6aa23ecba2dc2af870668a9239136d20fa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcaeb6aa23ecba2dc2af870668a9239136d20fa3", "html_url": "https://github.com/rust-lang/rust/commit/dcaeb6aa23ecba2dc2af870668a9239136d20fa3"}], "stats": {"total": 148, "additions": 105, "deletions": 43}, "files": [{"sha": "db1239ae5b5ff3bccc739d7d543f4871def814e0", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 98, "deletions": 43, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/d053ccb45fafc12a52629f209122c1ce9bbfabed/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d053ccb45fafc12a52629f209122c1ce9bbfabed/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=d053ccb45fafc12a52629f209122c1ce9bbfabed", "patch": "@@ -52,21 +52,14 @@ impl DynamicLibrary {\n     /// Lazily open a dynamic library. When passed None it gives a\n     /// handle to the calling process\n     pub fn open(filename: Option<&Path>) -> Result<DynamicLibrary, String> {\n-        unsafe {\n-            let maybe_library = dl::check_for_errors_in(|| {\n-                match filename {\n-                    Some(name) => dl::open_external(name.as_vec()),\n-                    None => dl::open_internal()\n-                }\n-            });\n-\n-            // The dynamic library must not be constructed if there is\n-            // an error opening the library so the destructor does not\n-            // run.\n-            match maybe_library {\n-                Err(err) => Err(err),\n-                Ok(handle) => Ok(DynamicLibrary { handle: handle })\n-            }\n+        let maybe_library = dl::open(filename.map(|path| path.as_vec()));\n+\n+        // The dynamic library must not be constructed if there is\n+        // an error opening the library so the destructor does not\n+        // run.\n+        match maybe_library {\n+            Err(err) => Err(err),\n+            Ok(handle) => Ok(DynamicLibrary { handle: handle })\n         }\n     }\n \n@@ -198,22 +191,34 @@ mod test {\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\"))]\n-pub mod dl {\n-    pub use self::Rtld::*;\n+mod dl {\n     use prelude::v1::*;\n \n     use ffi::{self, CString};\n     use str;\n     use libc;\n     use ptr;\n \n-    pub unsafe fn open_external(filename: &[u8]) -> *mut u8 {\n+    pub fn open(filename: Option<&[u8]>) -> Result<*mut u8, String> {\n+        check_for_errors_in(|| {\n+            unsafe {\n+                match filename {\n+                    Some(filename) => open_external(filename),\n+                    None => open_internal(),\n+                }\n+            }\n+        })\n+    }\n+\n+    const LAZY: libc::c_int = 1;\n+\n+    unsafe fn open_external(filename: &[u8]) -> *mut u8 {\n         let s = CString::from_slice(filename);\n-        dlopen(s.as_ptr(), Lazy as libc::c_int) as *mut u8\n+        dlopen(s.as_ptr(), LAZY) as *mut u8\n     }\n \n-    pub unsafe fn open_internal() -> *mut u8 {\n-        dlopen(ptr::null(), Lazy as libc::c_int) as *mut u8\n+    unsafe fn open_internal() -> *mut u8 {\n+        dlopen(ptr::null(), LAZY) as *mut u8\n     }\n \n     pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n@@ -249,14 +254,6 @@ pub mod dl {\n         dlclose(handle as *mut libc::c_void); ()\n     }\n \n-    #[derive(Copy)]\n-    pub enum Rtld {\n-        Lazy = 1,\n-        Now = 2,\n-        Global = 256,\n-        Local = 0,\n-    }\n-\n     #[link_name = \"dl\"]\n     extern {\n         fn dlopen(filename: *const libc::c_char,\n@@ -269,11 +266,13 @@ pub mod dl {\n }\n \n #[cfg(target_os = \"windows\")]\n-pub mod dl {\n+mod dl {\n     use iter::IteratorExt;\n     use libc;\n+    use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n     use ops::FnOnce;\n     use os;\n+    use option::Option::{self, Some, None};\n     use ptr;\n     use result::Result;\n     use result::Result::{Ok, Err};\n@@ -282,19 +281,75 @@ pub mod dl {\n     use str;\n     use string::String;\n     use vec::Vec;\n+    use sys::c::compat::kernel32::SetThreadErrorMode;\n+\n+    pub fn open(filename: Option<&[u8]>) -> Result<*mut u8, String> {\n+        // disable \"dll load failed\" error dialog.\n+        let mut use_thread_mode = true;\n+        let prev_error_mode = unsafe {\n+            // SEM_FAILCRITICALERRORS 0x01\n+            let new_error_mode = 1;\n+            let mut prev_error_mode = 0;\n+            // Windows >= 7 supports thread error mode.\n+            let result = SetThreadErrorMode(new_error_mode, &mut prev_error_mode);\n+            if result == 0 {\n+                let err = os::errno();\n+                if err as libc::c_int == ERROR_CALL_NOT_IMPLEMENTED {\n+                    use_thread_mode = false;\n+                    // SetThreadErrorMode not found. use fallback solution: SetErrorMode()\n+                    // Note that SetErrorMode is process-wide so this can cause race condition!\n+                    // However, since even Windows APIs do not care of such problem (#20650),\n+                    // we just assume SetErrorMode race is not a great deal.\n+                    prev_error_mode = SetErrorMode(new_error_mode);\n+                }\n+            }\n+            prev_error_mode\n+        };\n \n-    pub unsafe fn open_external(filename: &[u8]) -> *mut u8 {\n-        // Windows expects Unicode data\n-        let filename_str = str::from_utf8(filename).unwrap();\n-        let mut filename_str: Vec<u16> = filename_str.utf16_units().collect();\n-        filename_str.push(0);\n-        LoadLibraryW(filename_str.as_ptr() as *const libc::c_void) as *mut u8\n-    }\n+        unsafe {\n+            SetLastError(0);\n+        }\n+\n+        let result = match filename {\n+            Some(filename) => {\n+                let filename_str = str::from_utf8(filename).unwrap();\n+                let mut filename_str: Vec<u16> = filename_str.utf16_units().collect();\n+                filename_str.push(0);\n+                let result = unsafe {\n+                    LoadLibraryW(filename_str.as_ptr() as *const libc::c_void)\n+                };\n+                // beware: Vec/String may change errno during drop!\n+                // so we get error here.\n+                if result == ptr::null_mut() {\n+                    let errno = os::errno();\n+                    Err(os::error_string(errno))\n+                } else {\n+                    Ok(result as *mut u8)\n+                }\n+            }\n+            None => {\n+                let mut handle = ptr::null_mut();\n+                let succeeded = unsafe {\n+                    GetModuleHandleExW(0 as libc::DWORD, ptr::null(), &mut handle)\n+                };\n+                if succeeded == libc::FALSE {\n+                    let errno = os::errno();\n+                    Err(os::error_string(errno))\n+                } else {\n+                    Ok(handle as *mut u8)\n+                }\n+            }\n+        };\n+\n+        unsafe {\n+            if use_thread_mode {\n+                SetThreadErrorMode(prev_error_mode, ptr::null_mut());\n+            } else {\n+                SetErrorMode(prev_error_mode);\n+            }\n+        }\n \n-    pub unsafe fn open_internal() -> *mut u8 {\n-        let mut handle = ptr::null_mut();\n-        GetModuleHandleExW(0 as libc::DWORD, ptr::null(), &mut handle);\n-        handle as *mut u8\n+        result\n     }\n \n     pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n@@ -326,10 +381,10 @@ pub mod dl {\n         fn SetLastError(error: libc::size_t);\n         fn LoadLibraryW(name: *const libc::c_void) -> *mut libc::c_void;\n         fn GetModuleHandleExW(dwFlags: libc::DWORD, name: *const u16,\n-                              handle: *mut *mut libc::c_void)\n-                              -> *mut libc::c_void;\n+                              handle: *mut *mut libc::c_void) -> libc::BOOL;\n         fn GetProcAddress(handle: *mut libc::c_void,\n                           name: *const libc::c_char) -> *mut libc::c_void;\n         fn FreeLibrary(handle: *mut libc::c_void);\n+        fn SetErrorMode(uMode: libc::c_uint) -> libc::c_uint;\n     }\n }"}, {"sha": "da3b7ee2f2fd5d7c560b59e658ae0143253ee5a3", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d053ccb45fafc12a52629f209122c1ce9bbfabed/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d053ccb45fafc12a52629f209122c1ce9bbfabed/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=d053ccb45fafc12a52629f209122c1ce9bbfabed", "patch": "@@ -226,6 +226,7 @@ pub mod compat {\n     /// * `CreateSymbolicLinkW`: Windows XP, Windows Server 2003\n     /// * `GetFinalPathNameByHandleW`: Windows XP, Windows Server 2003\n     pub mod kernel32 {\n+        use libc::c_uint;\n         use libc::types::os::arch::extra::{DWORD, LPCWSTR, BOOLEAN, HANDLE};\n         use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n \n@@ -249,6 +250,12 @@ pub mod compat {\n                 unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0 }\n             }\n         }\n+\n+        compat_fn! {\n+            kernel32::SetThreadErrorMode(_dwNewMode: DWORD, _lpOldMode: *mut DWORD) -> c_uint {\n+                unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0 }\n+            }\n+        }\n     }\n }\n "}]}