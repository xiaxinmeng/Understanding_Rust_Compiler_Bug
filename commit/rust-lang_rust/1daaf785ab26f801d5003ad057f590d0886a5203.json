{"sha": "1daaf785ab26f801d5003ad057f590d0886a5203", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYWFmNzg1YWIyNmY4MDFkNTAwM2FkMDU3ZjU5MGQwODg2YTUyMDM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-07T06:07:00Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-17T04:49:17Z"}, "message": "Optimize lint passes to perform far fewer allocations\n\nAchieves ~3x speedup on lint passes for libcore", "tree": {"sha": "0f475163247daaae7c800541ae2faad393e50ada", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f475163247daaae7c800541ae2faad393e50ada"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1daaf785ab26f801d5003ad057f590d0886a5203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1daaf785ab26f801d5003ad057f590d0886a5203", "html_url": "https://github.com/rust-lang/rust/commit/1daaf785ab26f801d5003ad057f590d0886a5203", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1daaf785ab26f801d5003ad057f590d0886a5203/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "030c666cc1bc4830eac2f845b114f7c514f6e201", "url": "https://api.github.com/repos/rust-lang/rust/commits/030c666cc1bc4830eac2f845b114f7c514f6e201", "html_url": "https://github.com/rust-lang/rust/commit/030c666cc1bc4830eac2f845b114f7c514f6e201"}], "stats": {"total": 332, "additions": 188, "deletions": 144}, "files": [{"sha": "2aa9a8c7001a7d5138590eb2bf5a36c300ae7202", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 188, "deletions": 144, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/1daaf785ab26f801d5003ad057f590d0886a5203/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1daaf785ab26f801d5003ad057f590d0886a5203/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=1daaf785ab26f801d5003ad057f590d0886a5203", "patch": "@@ -27,18 +27,25 @@ use syntax::{ast, visit, ast_util};\n  * other phases of the compiler, which are generally required to hold in order\n  * to compile the program at all.\n  *\n- * We also build up a table containing information about lint settings, in\n- * order to allow other passes to take advantage of the lint attribute\n- * infrastructure. To save space, the table is keyed by the id of /items/, not\n- * of every expression. When an item has the default settings, the entry will\n- * be omitted. If we start allowing lint attributes on expressions, we will\n- * start having entries for expressions that do not share their enclosing\n- * items settings.\n+ * The lint checking is all consolidated into one pass which runs just before\n+ * translation to LLVM bytecode. Throughout compilation, lint warnings can be\n+ * added via the `add_lint` method on the Session structure. This requires a\n+ * span and an id of the node that the lint is being added to. The lint isn't\n+ * actually emitted at that time because it is unknown what the actual lint\n+ * level for the particular attribute is.\n  *\n- * This module then, exports two passes: one that populates the lint\n- * settings table in the session and is run early in the compile process, and\n- * one that does a variety of lint checks, and is run late in the compile\n- * process.\n+ * To actually emit lint warnings/errors, a context keeps track of the current\n+ * state of all lint levels. Upon entering a node of the ast which can modify\n+ * the lint settings, the previous lint state is pushed onto a stack and the ast\n+ * is then recursed upon. Once the lint state has been altered, all of the known\n+ * lint passes are run on the node of the ast.\n+ *\n+ * Each lint pass is a visit::vt<()> structure. These visitors are constructed\n+ * via the lint_*() functions below. There are also some lint checks which\n+ * operate directly on ast nodes (such as @ast::item), and those are organized\n+ * as check_item_*(). Each visitor added to the lint context is modified to stop\n+ * once it reaches a node which could alter the lint levels. This means that\n+ * everything is looked at once and only once by every lint pass.\n  */\n \n #[deriving(Eq)]\n@@ -256,6 +263,12 @@ struct Context {\n     // levels, this stack keeps track of the previous lint levels of whatever\n     // was modified.\n     lint_stack: ~[(lint, level)],\n+    // Each of these visitors represents a lint pass. A number of the lint\n+    // attributes are registered by adding a visitor to iterate over the ast.\n+    // Others operate directly on @ast::item structures (or similar). Finally,\n+    // others still are added to the Session object via `add_lint`, and these\n+    // are all passed with the lint_session visitor.\n+    visitors: ~[visit::vt<()>],\n }\n \n impl Context {\n@@ -288,15 +301,8 @@ impl Context {\n         // current dictionary of lint information. Along the way, keep a history\n         // of what we changed so we can roll everything back after invoking the\n         // specified closure\n-        let triples = extract_lints(self.tcx.sess, attrs);\n         let mut pushed = 0u;\n-        for triples.each |triple| {\n-            // FIXME(#3874): it would be nicer to write this...\n-            // let (meta, level, lintname) = /*bad*/copy *pair;\n-            let (meta, level, lintname) = match *triple {\n-                (ref meta, level, lintname) => (meta, level, lintname)\n-            };\n-\n+        for each_lint(self.tcx.sess, attrs) |meta, level, lintname| {\n             let lint = match self.dict.find(lintname) {\n               None => {\n                 self.span_lint(\n@@ -315,12 +321,14 @@ impl Context {\n                     fmt!(\"%s(%s) overruled by outer forbid(%s)\",\n                          level_to_str(level),\n                          *lintname, *lintname));\n-                loop\n+                loop;\n             }\n \n-            self.lint_stack.push((lint, now));\n-            pushed += 1;\n-            self.set_level(lint, level);\n+            if now != level {\n+                self.lint_stack.push((lint, now));\n+                pushed += 1;\n+                self.set_level(lint, level);\n+            }\n         }\n \n         f();\n@@ -332,63 +340,100 @@ impl Context {\n         }\n     }\n \n-    fn process(&self, n: AttributedNode, v: @visit::SimpleVisitor) {\n-        self.process_visitor(n, visit::mk_simple_visitor(v));\n+    fn add_lint(&mut self, v: visit::vt<()>) {\n+        self.visitors.push(item_stopping_visitor(v));\n     }\n \n-    fn process_visitor(&self, n: AttributedNode, v: visit::vt<()>) {\n-        let v = item_stopping_visitor(v);\n+    fn process(&self, n: AttributedNode) {\n         match n {\n-            Item(it) => visit::visit_item(it, (), v),\n-            Crate(c) => visit::visit_crate(c, (), v),\n+            Item(it) => {\n+                for self.visitors.each |v| {\n+                    visit::visit_item(it, (), *v);\n+                }\n+            }\n+            Crate(c) => {\n+                for self.visitors.each |v| {\n+                    visit::visit_crate(c, (), *v);\n+                }\n+            }\n             // Can't use visit::visit_method_helper because the\n             // item_stopping_visitor has overridden visit_fn(&fk_method(... ))\n             // to be a no-op, so manually invoke visit_fn.\n-            Method(m) => visit::visit_fn(&visit::fk_method(copy m.ident,\n-                                                           &m.generics,\n-                                                           m),\n-                                         &m.decl,\n-                                         &m.body,\n-                                         m.span,\n-                                         m.id,\n-                                         (),\n-                                         v)\n+            Method(m) => {\n+                let fk = visit::fk_method(copy m.ident, &m.generics, m);\n+                for self.visitors.each |v| {\n+                    visit::visit_fn(&fk, &m.decl, &m.body, m.span, m.id,\n+                                    (), *v);\n+                }\n+            }\n         }\n     }\n }\n \n-pub fn extract_lints(sess: session::Session,\n-                     attrs: &[ast::attribute])\n-                            -> ~[(@ast::meta_item, level, @~str)]\n+#[cfg(stage0)]\n+pub fn each_lint(sess: session::Session,\n+                 attrs: &[ast::attribute],\n+                 f: &fn(@ast::meta_item, level, &~str) -> bool)\n {\n-    let mut triples = ~[];\n     for [allow, warn, deny, forbid].each |&level| {\n         let level_name = level_to_str(level);\n-        let metas =\n-            attr::attr_metas(attr::find_attrs_by_name(attrs, level_name));\n-        for metas.each |meta| {\n-            match meta.node {\n-              ast::meta_list(_, ref metas) => {\n-                for metas.each |meta| {\n-                    match meta.node {\n-                      ast::meta_word(lintname) => {\n-                        triples.push((*meta,\n-                                      level,\n-                                      lintname));\n-                      }\n-                      _ => {\n+        let attrs = attr::find_attrs_by_name(attrs, level_name);\n+        for attrs.each |attr| {\n+            let meta = attr.node.value;\n+            let metas = match meta.node {\n+                ast::meta_list(_, ref metas) => metas,\n+                _ => {\n+                    sess.span_err(meta.span, ~\"malformed lint attribute\");\n+                    loop;\n+                }\n+            };\n+            for metas.each |meta| {\n+                match meta.node {\n+                    ast::meta_word(lintname) => {\n+                        if !f(*meta, level, lintname) {\n+                            return;\n+                        }\n+                    }\n+                    _ => {\n+                        sess.span_err(meta.span, ~\"malformed lint attribute\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+#[cfg(not(stage0))]\n+pub fn each_lint(sess: session::Session,\n+                 attrs: &[ast::attribute],\n+                 f: &fn(@ast::meta_item, level, &~str) -> bool) -> bool\n+{\n+    for [allow, warn, deny, forbid].each |&level| {\n+        let level_name = level_to_str(level);\n+        let attrs = attr::find_attrs_by_name(attrs, level_name);\n+        for attrs.each |attr| {\n+            let meta = attr.node.value;\n+            let metas = match meta.node {\n+                ast::meta_list(_, ref metas) => metas,\n+                _ => {\n+                    sess.span_err(meta.span, ~\"malformed lint attribute\");\n+                    loop;\n+                }\n+            };\n+            for metas.each |meta| {\n+                match meta.node {\n+                    ast::meta_word(lintname) => {\n+                        if !f(*meta, level, lintname) {\n+                            return false;\n+                        }\n+                    }\n+                    _ => {\n                         sess.span_err(meta.span, ~\"malformed lint attribute\");\n-                      }\n                     }\n                 }\n-              }\n-              _  => {\n-                sess.span_err(meta.span, ~\"malformed lint attribute\");\n-              }\n             }\n         }\n     }\n-    return triples;\n+    return true;\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -411,8 +456,8 @@ fn ty_stopping_visitor<E>(v: visit::vt<E>) -> visit::vt<E> {\n     visit::mk_vt(@visit::Visitor {visit_ty: |_t, _e, _v| { },.. **v})\n }\n \n-fn check_item_while_true(cx: @mut Context, n: AttributedNode) {\n-    cx.process(n, @visit::SimpleVisitor {\n+fn lint_while_true(cx: @mut Context) -> visit::vt<()> {\n+    visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_expr: |e: @ast::expr| {\n             match e.node {\n                 ast::expr_while(cond, _) => {\n@@ -431,10 +476,10 @@ fn check_item_while_true(cx: @mut Context, n: AttributedNode) {\n             }\n         },\n         .. *visit::default_simple_visitor()\n-    });\n+    })\n }\n \n-fn check_item_type_limits(cx: @mut Context, n: AttributedNode) {\n+fn lint_type_limits(cx: @mut Context) -> visit::vt<()> {\n     fn is_valid<T:cmp::Ord>(binop: ast::binop, v: T,\n             min: T, max: T) -> bool {\n         match binop {\n@@ -544,10 +589,10 @@ fn check_item_type_limits(cx: @mut Context, n: AttributedNode) {\n         }\n     };\n \n-    cx.process(n, @visit::SimpleVisitor {\n+    visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_expr: visit_expr,\n         .. *visit::default_simple_visitor()\n-    });\n+    })\n }\n \n fn check_item_default_methods(cx: @mut Context, item: @ast::item) {\n@@ -609,79 +654,75 @@ fn check_item_ctypes(cx: @mut Context, it: @ast::item) {\n     }\n }\n \n-fn check_item_heap(cx: @mut Context, n: AttributedNode) {\n+fn check_type_for_lint(cx: @mut Context, lint: lint, span: span, ty: ty::t) {\n+    if cx.get_level(lint) == allow { return }\n \n-    fn check_type_for_lint(cx: @mut Context, lint: lint, span: span, ty: ty::t) {\n-        if cx.get_level(lint) == allow { return }\n-\n-        let mut n_box = 0;\n-        let mut n_uniq = 0;\n-        ty::fold_ty(cx.tcx, ty, |t| {\n-            match ty::get(t).sty {\n-              ty::ty_box(_) => n_box += 1,\n-              ty::ty_uniq(_) => n_uniq += 1,\n-              _ => ()\n-            };\n-            t\n-        });\n+    let mut n_box = 0;\n+    let mut n_uniq = 0;\n+    ty::fold_ty(cx.tcx, ty, |t| {\n+        match ty::get(t).sty {\n+          ty::ty_box(_) => n_box += 1,\n+          ty::ty_uniq(_) => n_uniq += 1,\n+          _ => ()\n+        };\n+        t\n+    });\n \n-        if n_uniq > 0 && lint != managed_heap_memory {\n-            let s = ty_to_str(cx.tcx, ty);\n-            let m = ~\"type uses owned (~ type) pointers: \" + s;\n-            cx.span_lint(lint, span, m);\n-        }\n+    if n_uniq > 0 && lint != managed_heap_memory {\n+        let s = ty_to_str(cx.tcx, ty);\n+        let m = ~\"type uses owned (~ type) pointers: \" + s;\n+        cx.span_lint(lint, span, m);\n+    }\n \n-        if n_box > 0 && lint != owned_heap_memory {\n-            let s = ty_to_str(cx.tcx, ty);\n-            let m = ~\"type uses managed (@ type) pointers: \" + s;\n-            cx.span_lint(lint, span, m);\n-        }\n+    if n_box > 0 && lint != owned_heap_memory {\n+        let s = ty_to_str(cx.tcx, ty);\n+        let m = ~\"type uses managed (@ type) pointers: \" + s;\n+        cx.span_lint(lint, span, m);\n     }\n+}\n \n-    fn check_type(cx: @mut Context, span: span, ty: ty::t) {\n-        for [managed_heap_memory, owned_heap_memory, heap_memory].each |lint| {\n-            check_type_for_lint(cx, *lint, span, ty);\n-        }\n+fn check_type(cx: @mut Context, span: span, ty: ty::t) {\n+    for [managed_heap_memory, owned_heap_memory, heap_memory].each |lint| {\n+        check_type_for_lint(cx, *lint, span, ty);\n     }\n+}\n \n-    match n {\n-        Item(it) => {\n-            match it.node {\n-              ast::item_fn(*) |\n-              ast::item_ty(*) |\n-              ast::item_enum(*) |\n-              ast::item_struct(*) => check_type(cx, it.span,\n-                                                ty::node_id_to_type(cx.tcx,\n-                                                                    it.id)),\n-              _ => ()\n-            }\n+fn check_item_heap(cx: @mut Context, it: @ast::item) {\n+    match it.node {\n+      ast::item_fn(*) |\n+      ast::item_ty(*) |\n+      ast::item_enum(*) |\n+      ast::item_struct(*) => check_type(cx, it.span,\n+                                        ty::node_id_to_type(cx.tcx,\n+                                                            it.id)),\n+      _ => ()\n+    }\n \n-            // If it's a struct, we also have to check the fields' types\n-            match it.node {\n-                ast::item_struct(struct_def, _) => {\n-                    for struct_def.fields.each |struct_field| {\n-                        check_type(cx, struct_field.span,\n-                                   ty::node_id_to_type(cx.tcx,\n-                                                       struct_field.node.id));\n-                    }\n-                }\n-                _ => ()\n+    // If it's a struct, we also have to check the fields' types\n+    match it.node {\n+        ast::item_struct(struct_def, _) => {\n+            for struct_def.fields.each |struct_field| {\n+                check_type(cx, struct_field.span,\n+                           ty::node_id_to_type(cx.tcx,\n+                                               struct_field.node.id));\n             }\n         }\n         _ => ()\n     }\n+}\n \n-    cx.process(n, @visit::SimpleVisitor {\n+fn lint_heap(cx: @mut Context) -> visit::vt<()> {\n+    visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_expr: |e| {\n             let ty = ty::expr_ty(cx.tcx, e);\n             check_type(cx, e.span, ty);\n         },\n         .. *visit::default_simple_visitor()\n-    });\n+    })\n }\n \n-fn check_item_path_statement(cx: @mut Context, n: AttributedNode) {\n-    cx.process(n, @visit::SimpleVisitor {\n+fn lint_path_statement(cx: @mut Context) -> visit::vt<()> {\n+    visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_stmt: |s| {\n             match s.node {\n                 ast::stmt_semi(\n@@ -695,7 +736,7 @@ fn check_item_path_statement(cx: @mut Context, n: AttributedNode) {\n             }\n         },\n         .. *visit::default_simple_visitor()\n-    });\n+    })\n }\n \n fn check_item_non_camel_case_types(cx: @mut Context, it: @ast::item) {\n@@ -745,7 +786,7 @@ fn check_item_non_camel_case_types(cx: @mut Context, it: @ast::item) {\n     }\n }\n \n-fn check_item_unused_unsafe(cx: @mut Context, n: AttributedNode) {\n+fn lint_unused_unsafe(cx: @mut Context) -> visit::vt<()> {\n     let visit_expr: @fn(@ast::expr) = |e| {\n         match e.node {\n             ast::expr_block(ref blk) if blk.node.rules == ast::unsafe_blk => {\n@@ -758,13 +799,13 @@ fn check_item_unused_unsafe(cx: @mut Context, n: AttributedNode) {\n         }\n     };\n \n-    cx.process(n, @visit::SimpleVisitor {\n+    visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_expr: visit_expr,\n         .. *visit::default_simple_visitor()\n-    });\n+    })\n }\n \n-fn check_item_unused_mut(cx: @mut Context, n: AttributedNode) {\n+fn lint_unused_mut(cx: @mut Context) -> visit::vt<()> {\n     let check_pat: @fn(@ast::pat) = |p| {\n         let mut used = false;\n         let mut bindings = 0;\n@@ -790,7 +831,7 @@ fn check_item_unused_mut(cx: @mut Context, n: AttributedNode) {\n         }\n     };\n \n-    cx.process(n, @visit::SimpleVisitor {\n+    visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_local: |l| {\n             if l.node.is_mutbl {\n                 check_pat(l.node.pat);\n@@ -806,31 +847,20 @@ fn check_item_unused_mut(cx: @mut Context, n: AttributedNode) {\n             }\n         },\n         .. *visit::default_simple_visitor()\n-    });\n+    })\n }\n \n-fn check_item_session_lints(cx: @mut Context, n: AttributedNode) {\n-    cx.process_visitor(n, ast_util::id_visitor(|id| {\n+fn lint_session(cx: @mut Context) -> visit::vt<()> {\n+    ast_util::id_visitor(|id| {\n         match cx.tcx.sess.lints.pop(&id) {\n             None => {},\n             Some(l) => {\n-                info!(\"id %?\", id);\n                 do vec::consume(l) |_, (lint, span, msg)| {\n                     cx.span_lint(lint, span, msg)\n                 }\n             }\n         }\n-    }));\n-}\n-\n-fn check_attributed_node(cx: @mut Context, n: AttributedNode) {\n-    check_item_while_true(cx, n);\n-    check_item_path_statement(cx, n);\n-    check_item_heap(cx, n);\n-    check_item_type_limits(cx, n);\n-    check_item_unused_unsafe(cx, n);\n-    check_item_unused_mut(cx, n);\n-    check_item_session_lints(cx, n);\n+    })\n }\n \n pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n@@ -839,6 +869,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n         curr: SmallIntMap::new(),\n         tcx: tcx,\n         lint_stack: ~[],\n+        visitors: ~[],\n     };\n \n     // Install defaults.\n@@ -851,6 +882,15 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n         cx.set_level(lint, level);\n     }\n \n+    // Register each of the lint passes with the context\n+    cx.add_lint(lint_while_true(cx));\n+    cx.add_lint(lint_path_statement(cx));\n+    cx.add_lint(lint_heap(cx));\n+    cx.add_lint(lint_type_limits(cx));\n+    cx.add_lint(lint_unused_unsafe(cx));\n+    cx.add_lint(lint_unused_mut(cx));\n+    cx.add_lint(lint_session(cx));\n+\n     // type inference doesn't like this being declared below, we need to tell it\n     // what the type of this first function is...\n     let visit_item:\n@@ -862,21 +902,22 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n             check_item_default_methods(cx, it);\n             check_item_heap(cx, it);\n \n-            check_attributed_node(cx, Item(it));\n+            cx.process(Item(it));\n             visit::visit_item(it, cx, vt);\n         }\n     };\n \n+    // Actually perform the lint checks (iterating the ast)\n     do cx.with_lint_attrs(crate.node.attrs) {\n-        check_item_session_lints(cx, Crate(crate));\n+        cx.process(Crate(crate));\n \n         visit::visit_crate(crate, cx, visit::mk_vt(@visit::Visitor {\n             visit_item: visit_item,\n             visit_fn: |fk, decl, body, span, id, cx, vt| {\n                 match *fk {\n                     visit::fk_method(_, _, m) => {\n                         do cx.with_lint_attrs(m.attrs) {\n-                            check_attributed_node(cx, Method(m));\n+                            cx.process(Method(m));\n                             visit::visit_fn(fk, decl, body, span, id, cx, vt);\n                         }\n                     }\n@@ -889,6 +930,8 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n         }));\n     }\n \n+    // If we missed any lints added to the session, then there's a bug somewhere\n+    // in the iteration code.\n     for tcx.sess.lints.each |_, v| {\n         for v.each |t| {\n             match *t {\n@@ -898,5 +941,6 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n             }\n         }\n     }\n+\n     tcx.sess.abort_if_errors();\n }"}]}