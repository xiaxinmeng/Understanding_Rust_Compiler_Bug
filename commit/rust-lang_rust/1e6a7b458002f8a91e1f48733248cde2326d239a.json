{"sha": "1e6a7b458002f8a91e1f48733248cde2326d239a", "node_id": "C_kwDOAAsO6NoAKDFlNmE3YjQ1ODAwMmY4YTkxZTFmNDg3MzMyNDhjZGUyMzI2ZDIzOWE", "commit": {"author": {"name": "Beno\u00eet du Garreau", "email": "bdgdlm@outlook.com", "date": "2023-04-20T14:33:01Z"}, "committer": {"name": "Beno\u00eet du Garreau", "email": "bdgdlm@outlook.com", "date": "2023-04-20T14:33:01Z"}, "message": "Specialize some `io::Read` and `io::Write` methods for `VecDeque<u8>` and `&[u8]`", "tree": {"sha": "6bedd0aa36f161443381fce3d50055f6f3d323f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bedd0aa36f161443381fce3d50055f6f3d323f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e6a7b458002f8a91e1f48733248cde2326d239a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e6a7b458002f8a91e1f48733248cde2326d239a", "html_url": "https://github.com/rust-lang/rust/commit/1e6a7b458002f8a91e1f48733248cde2326d239a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e6a7b458002f8a91e1f48733248cde2326d239a/comments", "author": {"login": "a1phyr", "id": 47725341, "node_id": "MDQ6VXNlcjQ3NzI1MzQx", "avatar_url": "https://avatars.githubusercontent.com/u/47725341?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a1phyr", "html_url": "https://github.com/a1phyr", "followers_url": "https://api.github.com/users/a1phyr/followers", "following_url": "https://api.github.com/users/a1phyr/following{/other_user}", "gists_url": "https://api.github.com/users/a1phyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/a1phyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a1phyr/subscriptions", "organizations_url": "https://api.github.com/users/a1phyr/orgs", "repos_url": "https://api.github.com/users/a1phyr/repos", "events_url": "https://api.github.com/users/a1phyr/events{/privacy}", "received_events_url": "https://api.github.com/users/a1phyr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "a1phyr", "id": 47725341, "node_id": "MDQ6VXNlcjQ3NzI1MzQx", "avatar_url": "https://avatars.githubusercontent.com/u/47725341?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a1phyr", "html_url": "https://github.com/a1phyr", "followers_url": "https://api.github.com/users/a1phyr/followers", "following_url": "https://api.github.com/users/a1phyr/following{/other_user}", "gists_url": "https://api.github.com/users/a1phyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/a1phyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a1phyr/subscriptions", "organizations_url": "https://api.github.com/users/a1phyr/orgs", "repos_url": "https://api.github.com/users/a1phyr/repos", "events_url": "https://api.github.com/users/a1phyr/events{/privacy}", "received_events_url": "https://api.github.com/users/a1phyr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e23d180c1db42941b3bd32542a899e9eee7cbcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e23d180c1db42941b3bd32542a899e9eee7cbcb", "html_url": "https://github.com/rust-lang/rust/commit/7e23d180c1db42941b3bd32542a899e9eee7cbcb"}], "stats": {"total": 54, "additions": 54, "deletions": 0}, "files": [{"sha": "7511438b02bad0ec6e7180762f694dc3baec7624", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1e6a7b458002f8a91e1f48733248cde2326d239a/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6a7b458002f8a91e1f48733248cde2326d239a/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=1e6a7b458002f8a91e1f48733248cde2326d239a", "patch": "@@ -9,6 +9,7 @@ use crate::io::{\n     self, BorrowedCursor, BufRead, ErrorKind, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write,\n };\n use crate::mem;\n+use crate::str;\n \n // =============================================================================\n // Forwarding implementations\n@@ -307,6 +308,17 @@ impl Read for &[u8] {\n         *self = &self[len..];\n         Ok(len)\n     }\n+\n+    #[inline]\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n+        let content = str::from_utf8(self).map_err(|_| {\n+            io::const_io_error!(ErrorKind::InvalidData, \"stream did not contain valid UTF-8\")\n+        })?;\n+        buf.push_str(content);\n+        let len = self.len();\n+        *self = &self[len..];\n+        Ok(len)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -434,6 +446,33 @@ impl<A: Allocator> Read for VecDeque<u8, A> {\n         self.drain(..n);\n         Ok(())\n     }\n+\n+    #[inline]\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        // The total len is known upfront so we can reserve it in a single call.\n+        let len = self.len();\n+        buf.reserve(len);\n+\n+        let (front, back) = self.as_slices();\n+        buf.extend_from_slice(front);\n+        buf.extend_from_slice(back);\n+        self.clear();\n+        Ok(len)\n+    }\n+\n+    #[inline]\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n+        // We have to use a single contiguous slice because the `VecDequeue` might be split in the\n+        // middle of an UTF-8 character.\n+        let len = self.len();\n+        let content = self.make_contiguous();\n+        let string = str::from_utf8(content).map_err(|_| {\n+            io::const_io_error!(ErrorKind::InvalidData, \"stream did not contain valid UTF-8\")\n+        })?;\n+        buf.push_str(string);\n+        self.clear();\n+        Ok(len)\n+    }\n }\n \n /// Write is implemented for `VecDeque<u8>` by appending to the `VecDeque`, growing it as needed.\n@@ -445,6 +484,21 @@ impl<A: Allocator> Write for VecDeque<u8, A> {\n         Ok(buf.len())\n     }\n \n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let len = bufs.iter().map(|b| b.len()).sum();\n+        self.reserve(len);\n+        for buf in bufs {\n+            self.extend(&**buf);\n+        }\n+        Ok(len)\n+    }\n+\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        true\n+    }\n+\n     #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n         self.extend(buf);"}]}