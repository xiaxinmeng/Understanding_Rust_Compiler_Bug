{"sha": "be2bb4fa1d5788ba1d2df757090daf5fa75df4a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMmJiNGZhMWQ1Nzg4YmExZDJkZjc1NzA5MGRhZjVmYTc1ZGY0YTI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-09-15T17:23:30Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-12-14T22:41:28Z"}, "message": "implement \"isolated\" autoderef using the Canonical mechanism", "tree": {"sha": "a8b100ff4c92272bff2f505a6fbe906974e9001d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8b100ff4c92272bff2f505a6fbe906974e9001d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2", "html_url": "https://github.com/rust-lang/rust/commit/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "832ac110df0f58627ec1134bb9caf60d41f93f3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/832ac110df0f58627ec1134bb9caf60d41f93f3c", "html_url": "https://github.com/rust-lang/rust/commit/832ac110df0f58627ec1134bb9caf60d41f93f3c"}], "stats": {"total": 349, "additions": 239, "deletions": 110}, "files": [{"sha": "e225b12366fbd811383b4be12d60ab07b3c48101", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=be2bb4fa1d5788ba1d2df757090daf5fa75df4a2", "patch": "@@ -116,6 +116,33 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         Ok(Lrc::new(canonical_result))\n     }\n \n+    /// A version of `make_canonicalized_query_response` that does\n+    /// not pack in obligations, for contexts that want to drop\n+    /// pending obligations instead of treating them as an ambiguity (e.g.\n+    /// typeck \"probing\" contexts).\n+    ///\n+    /// If you DO want to keep track of pending obligations (which\n+    /// include all region obligations, so this includes all cases\n+    /// that care about regions) with this function, you have to\n+    /// do it yourself, by e.g. having them be a part of the answer.\n+    ///\n+    /// TDFX(nikomatsakis): not sure this is the best name.\n+    pub fn make_query_response_with_obligations_pending<T>(\n+        &self,\n+        inference_vars: CanonicalVarValues<'tcx>,\n+        answer: T\n+    ) -> Canonical<'gcx, QueryResponse<'gcx, <T as Lift<'gcx>>::Lifted>>\n+    where\n+        T: Debug + Lift<'gcx> + TypeFoldable<'tcx>,\n+    {\n+        self.canonicalize_response(&QueryResponse {\n+            var_values: inference_vars,\n+            region_constraints: vec![],\n+            certainty: Certainty::Proven, // Ambiguities are OK!\n+            value: answer,\n+        })\n+    }\n+\n     /// Helper for `make_canonicalized_query_response` that does\n     /// everything up until the final canonicalization.\n     fn make_query_response<T>("}, {"sha": "3fce66a19d8654f06c2cde9005dede7c86e835d2", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=be2bb4fa1d5788ba1d2df757090daf5fa75df4a2", "patch": "@@ -19,7 +19,7 @@ use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n \n use syntax_pos::Span;\n-use syntax::ast::{NodeId, Ident};\n+use syntax::ast::{self, Ident};\n \n use std::iter;\n \n@@ -31,7 +31,7 @@ enum AutoderefKind {\n \n pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    body_id: NodeId,\n+    body_id: ast::NodeId,\n     param_env: ty::ParamEnv<'tcx>,\n     steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n     cur_ty: Ty<'tcx>,\n@@ -107,6 +107,26 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+               param_env: ty::ParamEnv<'tcx>,\n+               body_id: ast::NodeId,\n+               span: Span,\n+               base_ty: Ty<'tcx>)\n+               -> Autoderef<'a, 'gcx, 'tcx>\n+    {\n+        Autoderef {\n+            infcx,\n+            body_id,\n+            param_env,\n+            steps: vec![],\n+            cur_ty: infcx.resolve_type_vars_if_possible(&base_ty),\n+            obligations: vec![],\n+            at_start: true,\n+            include_raw_pointers: false,\n+            span,\n+        }\n+    }\n+\n     fn overloaded_deref_ty(&mut self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n         debug!(\"overloaded_deref_ty({:?})\", ty);\n \n@@ -231,17 +251,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'gcx, 'tcx> {\n-        Autoderef {\n-            infcx: &self.infcx,\n-            body_id: self.body_id,\n-            param_env: self.param_env,\n-            steps: vec![],\n-            cur_ty: self.resolve_type_vars_if_possible(&base_ty),\n-            obligations: vec![],\n-            at_start: true,\n-            include_raw_pointers: false,\n-            span,\n-        }\n+        Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n     }\n \n     pub fn try_overloaded_deref(&self,"}, {"sha": "36aad42e26bad214f94987742e315bc55cdf7cbc", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 170, "deletions": 96, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=be2bb4fa1d5788ba1d2df757090daf5fa75df4a2", "patch": "@@ -13,20 +13,24 @@ use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n use super::suggest;\n \n+use check::autoderef::Autoderef;\n use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n use namespace::Namespace;\n+\n use rustc::hir;\n use rustc::lint;\n use rustc::session::config::nightly_options;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n-use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n+use rustc::ty::{self, ParamEnv, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n use rustc::ty::GenericParamDefKind;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use rustc::infer::{self, InferOk};\n+use rustc::infer::canonical::{Canonical, QueryResponse};\n+use rustc::infer::canonical::{OriginalQueryValues};\n use rustc::middle::stability;\n use syntax::ast;\n use syntax::util::lev_distance::{lev_distance, find_best_match_for_name};\n@@ -51,7 +55,12 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     mode: Mode,\n     method_name: Option<ast::Ident>,\n     return_type: Option<Ty<'tcx>>,\n-    steps: Rc<Vec<CandidateStep<'tcx>>>,\n+\n+    /// This is the OriginalQueryValues for the steps queries\n+    /// that are answered in steps.\n+    orig_steps_var_values: OriginalQueryValues<'tcx>,\n+    steps: Rc<Vec<CandidateStep<'gcx>>>,\n+\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: FxHashSet<DefId>,\n@@ -82,8 +91,8 @@ impl<'a, 'gcx, 'tcx> Deref for ProbeContext<'a, 'gcx, 'tcx> {\n }\n \n #[derive(Debug)]\n-struct CandidateStep<'tcx> {\n-    self_ty: Ty<'tcx>,\n+struct CandidateStep<'gcx> {\n+    self_ty: Canonical<'gcx, QueryResponse<'gcx, Ty<'gcx>>>,\n     autoderefs: usize,\n     // true if the type results from a dereference of a raw pointer.\n     // when assembling candidates, we include these steps, but not when\n@@ -249,42 +258,86 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       -> Result<R, MethodError<'tcx>>\n         where OP: FnOnce(ProbeContext<'a, 'gcx, 'tcx>) -> Result<R, MethodError<'tcx>>\n     {\n-        // FIXME(#18741) -- right now, creating the steps involves evaluating the\n-        // `*` operator, which registers obligations that then escape into\n-        // the global fulfillment context and thus has global\n-        // side-effects. This is a bit of a pain to refactor. So just let\n-        // it ride, although it's really not great, and in fact could I\n-        // think cause spurious errors. Really though this part should\n-        // take place in the `self.probe` below.\n+        let mut orig_values = OriginalQueryValues::default();\n+        let param_env_and_self_ty =\n+            self.infcx.canonicalize_query(&(self.param_env, self_ty), &mut orig_values);\n+\n+        // FIXME: consider caching this \"whole op\" here.\n         let steps = if mode == Mode::MethodCall {\n-            match self.create_steps(span, scope_expr_id, self_ty, is_suggestion) {\n-                Some(steps) => steps,\n-                None => {\n-                    return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n-                                                                     Vec::new(),\n-                                                                     Vec::new(),\n-                                                                     None,\n-                                                                     mode)))\n-                }\n-            }\n+            create_steps_inner(self.tcx.global_tcx(), span, param_env_and_self_ty)\n         } else {\n-            vec![CandidateStep {\n-                     self_ty,\n-                     autoderefs: 0,\n-                     from_unsafe_deref: false,\n-                     unsize: false,\n-                 }]\n+            self.infcx.probe(|_| {\n+                // Mode::Path - the deref steps is \"trivial\". This turns\n+                // our CanonicalQuery into a \"trivial\" QueryResponse. This\n+                // is a bit inefficient, but I don't think that writing\n+                // special handling for this \"trivial case\" is a good idea.\n+\n+                let infcx = &self.infcx;\n+                let ((_, self_ty), canonical_inference_vars) =\n+                    infcx.instantiate_canonical_with_fresh_inference_vars(\n+                        span, &param_env_and_self_ty);\n+                debug!(\"param_env_and_self_ty={:?} self_ty={:?}\", param_env_and_self_ty, self_ty);\n+                CreateStepsResult {\n+                    steps: vec![CandidateStep {\n+                        self_ty: self.make_query_response_with_obligations_pending(\n+                            canonical_inference_vars, self_ty),\n+                        autoderefs: 0,\n+                        from_unsafe_deref: false,\n+                        unsize: false,\n+                    }],\n+                    opt_bad_ty: None\n+                }\n+            })\n         };\n \n+        // If we encountered an `_` type or an error type during autoderef, this is\n+        // ambiguous.\n+        if let Some(CreateStepsBadTy { reached_raw_pointer, ty }) = &steps.opt_bad_ty {\n+            if is_suggestion.0 {\n+                // Ambiguity was encountered during a suggestion. Just keep going.\n+                debug!(\"ProbeContext: encountered ambiguity in suggestion\");\n+            } else if *reached_raw_pointer && !self.tcx.features().arbitrary_self_types {\n+                // this case used to be allowed by the compiler,\n+                // so we do a future-compat lint here for the 2015 edition\n+                // (see https://github.com/rust-lang/rust/issues/46906)\n+                if self.tcx.sess.rust_2018() {\n+                    span_err!(self.tcx.sess, span, E0699,\n+                              \"the type of this value must be known \\\n+                               to call a method on a raw pointer on it\");\n+                } else {\n+                   self.tcx.lint_node(\n+                        lint::builtin::TYVAR_BEHIND_RAW_POINTER,\n+                        scope_expr_id,\n+                        span,\n+                        \"type annotations needed\");\n+                }\n+            } else {\n+                // Encountered a real ambiguity, so abort the lookup. If `ty` is not\n+                // an `Err`, report the right \"type annotations needed\" error pointing\n+                // to it.\n+                let ty = self.probe_instantiate_query_response(span, &orig_values, ty)\n+                    .unwrap_or_else(|_| span_bug!(span, \"instantiating {:?} failed?\", ty));\n+                let t = self.structurally_resolved_type(span, ty.value);\n+                assert_eq!(t, self.tcx.types.err);\n+                return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n+                                                                 Vec::new(),\n+                                                                 Vec::new(),\n+                                                                 None,\n+                                                                 mode)));\n+            }\n+        }\n+\n         debug!(\"ProbeContext: steps for self_ty={:?} are {:?}\",\n                self_ty,\n                steps);\n \n+\n         // this creates one big transaction so that all type variables etc\n         // that we create during the probe process are removed later\n         self.probe(|_| {\n             let mut probe_cx = ProbeContext::new(\n-                self, span, mode, method_name, return_type, Rc::new(steps), is_suggestion,\n+                self, span, mode, method_name, return_type, orig_values,\n+                Rc::new(steps.steps), is_suggestion,\n             );\n \n             probe_cx.assemble_inherent_candidates();\n@@ -297,21 +350,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             op(probe_cx)\n         })\n     }\n+}\n+\n+#[derive(Debug)]\n+struct CreateStepsResult<'gcx> {\n+    steps: Vec<CandidateStep<'gcx>>,\n+    opt_bad_ty: Option<CreateStepsBadTy<'gcx>>\n+}\n \n-    fn create_steps(&self,\n-                    span: Span,\n-                    scope_expr_id: ast::NodeId,\n-                    self_ty: Ty<'tcx>,\n-                    is_suggestion: IsSuggestion)\n-                    -> Option<Vec<CandidateStep<'tcx>>> {\n-        // FIXME: we don't need to create the entire steps in one pass\n+#[derive(Debug)]\n+struct CreateStepsBadTy<'gcx> {\n+    reached_raw_pointer: bool,\n+    ty: Canonical<'gcx, QueryResponse<'gcx, Ty<'gcx>>>,\n+}\n \n-        let mut autoderef = self.autoderef(span, self_ty).include_raw_pointers();\n+fn create_steps_inner<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+                                      span: Span,\n+                                      pe_and_self_ty: Canonical<'gcx, (ParamEnv<'gcx>, Ty<'gcx>)>)\n+                                      -> CreateStepsResult<'gcx>\n+{\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let ((param_env, self_ty), inference_vars) =\n+            infcx.instantiate_canonical_with_fresh_inference_vars(span, &pe_and_self_ty);\n+        let mut autoderef = Autoderef::new(infcx, param_env, ast::DUMMY_NODE_ID, span, self_ty)\n+            .include_raw_pointers();\n         let mut reached_raw_pointer = false;\n         let mut steps: Vec<_> = autoderef.by_ref()\n             .map(|(ty, d)| {\n                 let step = CandidateStep {\n-                    self_ty: ty,\n+                    self_ty: infcx.make_query_response_with_obligations_pending(\n+                        inference_vars.clone(), ty),\n                     autoderefs: d,\n                     from_unsafe_deref: reached_raw_pointer,\n                     unsize: false,\n@@ -325,68 +393,48 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .collect();\n \n         let final_ty = autoderef.maybe_ambiguous_final_ty();\n-        match final_ty.sty {\n-            ty::Infer(ty::TyVar(_)) => {\n-                // Ended in an inference variable. If we are doing\n-                // a real method lookup, this is a hard error because it's\n-                // possible that there will be multiple applicable methods.\n-                if !is_suggestion.0 {\n-                    if reached_raw_pointer\n-                    && !self.tcx.features().arbitrary_self_types {\n-                        // this case used to be allowed by the compiler,\n-                        // so we do a future-compat lint here for the 2015 edition\n-                        // (see https://github.com/rust-lang/rust/issues/46906)\n-                        if self.tcx.sess.rust_2018() {\n-                          span_err!(self.tcx.sess, span, E0699,\n-                                    \"the type of this value must be known \\\n-                                     to call a method on a raw pointer on it\");\n-                        } else {\n-                            self.tcx.lint_node(\n-                                lint::builtin::TYVAR_BEHIND_RAW_POINTER,\n-                                scope_expr_id,\n-                                span,\n-                                \"type annotations needed\");\n-                        }\n-                    } else {\n-                        let t = self.structurally_resolved_type(span, final_ty);\n-                        assert_eq!(t, self.tcx.types.err);\n-                        return None\n-                    }\n-                } else {\n-                    // If we're just looking for suggestions,\n-                    // though, ambiguity is no big thing, we can\n-                    // just ignore it.\n-                }\n+        let opt_bad_ty = match final_ty.sty {\n+            ty::Infer(ty::TyVar(_)) |\n+            ty::Error => {\n+                Some(CreateStepsBadTy {\n+                    reached_raw_pointer,\n+                    ty: infcx.make_query_response_with_obligations_pending(\n+                        inference_vars, final_ty)\n+                })\n             }\n             ty::Array(elem_ty, _) => {\n                 let dereferences = steps.len() - 1;\n \n                 steps.push(CandidateStep {\n-                    self_ty: self.tcx.mk_slice(elem_ty),\n+                    self_ty: infcx.make_query_response_with_obligations_pending(\n+                        inference_vars, infcx.tcx.mk_slice(elem_ty)),\n                     autoderefs: dereferences,\n                     // this could be from an unsafe deref if we had\n                     // a *mut/const [T; N]\n                     from_unsafe_deref: reached_raw_pointer,\n                     unsize: true,\n                 });\n+\n+                None\n             }\n-            ty::Error => return None,\n-            _ => (),\n-        }\n+            _ => None\n+        };\n \n-        debug!(\"create_steps: steps={:?}\", steps);\n+        debug!(\"create_steps: steps={:?} opt_bad_ty={:?}\", steps, opt_bad_ty);\n \n-        Some(steps)\n-    }\n+        CreateStepsResult { steps, opt_bad_ty }\n+    })\n }\n \n+\n impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n            span: Span,\n            mode: Mode,\n            method_name: Option<ast::Ident>,\n            return_type: Option<Ty<'tcx>>,\n-           steps: Rc<Vec<CandidateStep<'tcx>>>,\n+           orig_steps_var_values: OriginalQueryValues<'tcx>,\n+           steps: Rc<Vec<CandidateStep<'gcx>>>,\n            is_suggestion: IsSuggestion)\n            -> ProbeContext<'a, 'gcx, 'tcx> {\n         ProbeContext {\n@@ -398,7 +446,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: FxHashSet::default(),\n-            steps: steps,\n+            orig_steps_var_values,\n+            steps,\n             static_candidates: Vec::new(),\n             allow_similar_names: false,\n             private_candidate: None,\n@@ -443,18 +492,26 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn assemble_inherent_candidates(&mut self) {\n         let steps = self.steps.clone();\n         for step in steps.iter() {\n-            self.assemble_probe(step.self_ty);\n+            self.assemble_probe(&step.self_ty);\n         }\n     }\n \n-    fn assemble_probe(&mut self, self_ty: Ty<'tcx>) {\n+    fn assemble_probe(&mut self, self_ty: &Canonical<'gcx, QueryResponse<'gcx, Ty<'gcx>>>) {\n         debug!(\"assemble_probe: self_ty={:?}\", self_ty);\n         let lang_items = self.tcx.lang_items();\n \n-        match self_ty.sty {\n+        match self_ty.value.value.sty {\n             ty::Dynamic(ref data, ..) => {\n                 let p = data.principal();\n-                self.assemble_inherent_candidates_from_object(self_ty, p);\n+                self.fcx.probe(|_| {\n+                    let InferOk { value: self_ty, obligations: _ } =\n+                        self.fcx.probe_instantiate_query_response(\n+                            self.span, &self.orig_steps_var_values, self_ty)\n+                        .unwrap_or_else(|_| {\n+                            span_bug!(self.span, \"{:?} was applicable but now isn't?\", self_ty)\n+                        });\n+                    self.assemble_inherent_candidates_from_object(self_ty);\n+                });\n                 self.assemble_inherent_impl_candidates_for_type(p.def_id());\n             }\n             ty::Adt(def, _) => {\n@@ -464,7 +521,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 self.assemble_inherent_impl_candidates_for_type(did);\n             }\n             ty::Param(p) => {\n-                self.assemble_inherent_candidates_from_param(self_ty, p);\n+                self.assemble_inherent_candidates_from_param(p);\n             }\n             ty::Char => {\n                 let lang_def_id = lang_items.char_impl();\n@@ -615,11 +672,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_object(&mut self,\n-                                                self_ty: Ty<'tcx>,\n-                                                principal: ty::PolyExistentialTraitRef<'tcx>) {\n+                                                self_ty: Ty<'tcx>) {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={:?})\",\n                self_ty);\n \n+        let principal = match self_ty.sty {\n+            ty::Dynamic(ref data, ..) => data.principal(),\n+            _ => span_bug!(self.span, \"non-object {:?} in assemble_inherent_candidates_from_object\",\n+                           self_ty)\n+        };\n+\n         // It is illegal to invoke a method on a trait instance that\n         // refers to the `Self` type. An error will be reported by\n         // `enforce_object_limitations()` if the method refers to the\n@@ -642,7 +704,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_param(&mut self,\n-                                               _rcvr_ty: Ty<'tcx>,\n                                                param_ty: ty::ParamTy) {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n@@ -898,14 +959,22 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 // a raw pointer\n                 !step.self_ty.references_error() && !step.from_unsafe_deref\n             }).flat_map(|step| {\n-                self.pick_by_value_method(step).or_else(|| {\n-                self.pick_autorefd_method(step, hir::MutImmutable).or_else(|| {\n-                self.pick_autorefd_method(step, hir::MutMutable)\n+                let InferOk { value: self_ty, obligations: _ } =\n+                    self.fcx.probe_instantiate_query_response(\n+                        self.span, &self.orig_steps_var_values, &step.self_ty\n+                    ).unwrap_or_else(|_| {\n+                        span_bug!(self.span, \"{:?} was applicable but now isn't?\", step.self_ty)\n+                    });\n+                self.pick_by_value_method(step, self_ty).or_else(|| {\n+                self.pick_autorefd_method(step, self_ty, hir::MutImmutable).or_else(|| {\n+                self.pick_autorefd_method(step, self_ty, hir::MutMutable)\n             })})})\n             .next()\n     }\n \n-    fn pick_by_value_method(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n+    fn pick_by_value_method(&mut self, step: &CandidateStep<'gcx>, self_ty: Ty<'tcx>)\n+                            -> Option<PickResult<'tcx>>\n+    {\n         //! For each type `T` in the step list, this attempts to find a\n         //! method where the (transformed) self type is exactly `T`. We\n         //! do however do one transformation on the adjustment: if we\n@@ -918,12 +987,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        self.pick_method(step.self_ty).map(|r| {\n+        self.pick_method(self_ty).map(|r| {\n             r.map(|mut pick| {\n                 pick.autoderefs = step.autoderefs;\n \n                 // Insert a `&*` or `&mut *` if this is a reference type:\n-                if let ty::Ref(_, _, mutbl) = step.self_ty.sty {\n+                if let ty::Ref(_, _, mutbl) = step.self_ty.value.value.sty {\n                     pick.autoderefs += 1;\n                     pick.autoref = Some(mutbl);\n                 }\n@@ -933,7 +1002,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn pick_autorefd_method(&mut self, step: &CandidateStep<'tcx>, mutbl: hir::Mutability)\n+    fn pick_autorefd_method(&mut self,\n+                            step: &CandidateStep<'gcx>,\n+                            self_ty: Ty<'tcx>,\n+                            mutbl: hir::Mutability)\n                             -> Option<PickResult<'tcx>> {\n         let tcx = self.tcx;\n \n@@ -943,14 +1015,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let autoref_ty = tcx.mk_ref(region,\n                                     ty::TypeAndMut {\n-                                        ty: step.self_ty, mutbl\n+                                        ty: self_ty, mutbl\n                                     });\n         self.pick_method(autoref_ty).map(|r| {\n             r.map(|mut pick| {\n                 pick.autoderefs = step.autoderefs;\n                 pick.autoref = Some(mutbl);\n                 pick.unsize = if step.unsize {\n-                    Some(step.self_ty)\n+                    Some(self_ty)\n                 } else {\n                     None\n                 };\n@@ -1288,7 +1360,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let steps = self.steps.clone();\n         self.probe(|_| {\n             let mut pcx = ProbeContext::new(self.fcx, self.span, self.mode, self.method_name,\n-                                            self.return_type, steps, IsSuggestion(true));\n+                                            self.return_type,\n+                                            self.orig_steps_var_values.clone(),\n+                                            steps, IsSuggestion(true));\n             pcx.allow_similar_names = true;\n             pcx.assemble_inherent_candidates();\n             pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)?;"}, {"sha": "7aec741cf4d8e4af09bcdf953b7d140e01ab6439", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=be2bb4fa1d5788ba1d2df757090daf5fa75df4a2", "patch": "@@ -102,10 +102,11 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use middle::lang_items;\n use namespace::Namespace;\n+use rustc::infer::{self, InferCtxt, InferOk, InferResult, RegionVariableOrigin};\n+use rustc::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi::Abi;\n-use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n use rustc::infer::opaque_types::OpaqueTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n@@ -5349,6 +5350,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         (ctxt, result)\n     }\n+\n+    /// Instantiate a QueryResponse in a probe context, without a\n+    /// good ObligationCause.\n+    fn probe_instantiate_query_response(\n+        &self,\n+        span: Span,\n+        original_values: &OriginalQueryValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+    ) -> InferResult<'tcx, Ty<'tcx>>\n+    {\n+        self.instantiate_query_response_and_region_obligations(\n+            &traits::ObligationCause::misc(span, self.body_id),\n+            self.param_env,\n+            original_values,\n+            query_result)\n+    }\n }\n \n pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "fdc81a6ed1a9c3821954ef1fb74f7f9a3fdbcc9e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=be2bb4fa1d5788ba1d2df757090daf5fa75df4a2", "patch": "@@ -90,6 +90,7 @@ This API is completely unstable and subject to change.\n extern crate syntax_pos;\n \n extern crate arena;\n+\n #[macro_use] extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_data_structures;"}]}