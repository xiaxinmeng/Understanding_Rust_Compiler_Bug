{"sha": "8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjOWRmNjJjMWM2YTc3OGE4ZGY5ZWEwMjhkMWRjZTk4YzkxYzRkOWQ=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-18T17:46:54Z"}, "committer": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-25T18:59:02Z"}, "message": "move translate_offset_with_edit to ra_editor", "tree": {"sha": "0d4f3055025ca19b1b375a13b5e4ed1458d90afb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d4f3055025ca19b1b375a13b5e4ed1458d90afb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "html_url": "https://github.com/rust-lang/rust/commit/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "881c29192d39f657bf518baf399c47a5bfdc922f", "url": "https://api.github.com/repos/rust-lang/rust/commits/881c29192d39f657bf518baf399c47a5bfdc922f", "html_url": "https://github.com/rust-lang/rust/commit/881c29192d39f657bf518baf399c47a5bfdc922f"}], "stats": {"total": 579, "additions": 268, "deletions": 311}, "files": [{"sha": "127d7772a71c0ef65fc308a0675510e7651d25ce", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "patch": "@@ -723,6 +723,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proptest 0.8.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -763,7 +764,6 @@ dependencies = [\n  \"languageserver-types 0.53.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proptest 0.8.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_analysis 0.1.0\",\n  \"ra_editor 0.1.0\",\n  \"ra_syntax 0.1.0\","}, {"sha": "1ad99af280683319b496353f54bc770d58d59e83", "filename": "crates/ra_editor/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/crates%2Fra_editor%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/crates%2Fra_editor%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2FCargo.toml?ref=8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "patch": "@@ -14,5 +14,7 @@ rustc-hash = \"1.0\"\n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n \n+proptest = \"0.8.7\"\n+\n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }"}, {"sha": "619497f0b4bddff280d2926ab95c8b9e18594e23", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "patch": "@@ -2,6 +2,7 @@ mod code_actions;\n mod extend_selection;\n mod folding_ranges;\n mod line_index;\n+mod line_index_utils;\n mod symbols;\n #[cfg(test)]\n mod test_utils;\n@@ -12,6 +13,7 @@ pub use self::{\n     extend_selection::extend_selection,\n     folding_ranges::{folding_ranges, Fold, FoldKind},\n     line_index::{LineCol, LineIndex},\n+    line_index_utils::translate_offset_with_edit,\n     symbols::{file_structure, file_symbols, FileSymbol, StructureNode},\n     typing::{join_lines, on_enter, on_eq_typed},\n };"}, {"sha": "7d9b8d79fe769822d7e4fa9e01e9b0e90b1819c1", "filename": "crates/ra_editor/src/line_index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index.rs?ref=8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "patch": "@@ -1,4 +1,4 @@\n-use crate::{TextUnit, TextRange};\n+use crate::TextUnit;\n use rustc_hash::FxHashMap;\n use superslice::Ext;\n \n@@ -121,7 +121,7 @@ impl LineIndex {\n         col\n     }\n \n-    pub fn newlines(&self) -> &[TextUnit] {\n+    pub(crate) fn newlines(&self) -> &[TextUnit] {\n         &self.newlines[1..]\n     }\n }"}, {"sha": "e4fad04b2c358cef6bbafd54bb041eb0808017e2", "filename": "crates/ra_editor/src/line_index_utils.rs", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs?ref=8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "patch": "@@ -0,0 +1,260 @@\n+use ra_text_edit::{AtomTextEdit};\n+use ra_syntax::{TextUnit, TextRange};\n+use crate::{LineIndex, LineCol};\n+\n+#[derive(Debug)]\n+struct OffsetNewlineIter<'a> {\n+    text: &'a str,\n+    offset: TextUnit,\n+}\n+\n+impl<'a> Iterator for OffsetNewlineIter<'a> {\n+    type Item = TextUnit;\n+    fn next(&mut self) -> Option<TextUnit> {\n+        let next_idx = self\n+            .text\n+            .char_indices()\n+            .filter_map(|(i, c)| if c == '\\n' { Some(i + 1) } else { None })\n+            .next()?;\n+        let next = self.offset + TextUnit::from_usize(next_idx);\n+        self.text = &self.text[next_idx..];\n+        self.offset = next;\n+        Some(next)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+enum TranslatedPos {\n+    Before,\n+    After,\n+}\n+\n+/// None means it was deleted\n+type TranslatedOffset = Option<(TranslatedPos, TextUnit)>;\n+\n+fn translate_offset(offset: TextUnit, edit: &TranslatedAtomEdit) -> TranslatedOffset {\n+    if offset <= edit.delete.start() {\n+        Some((TranslatedPos::Before, offset))\n+    } else if offset <= edit.delete.end() {\n+        None\n+    } else {\n+        let diff = edit.insert.len() as i64 - edit.delete.len().to_usize() as i64;\n+        let after = TextUnit::from((offset.to_usize() as i64 + diff) as u32);\n+        Some((TranslatedPos::After, after))\n+    }\n+}\n+\n+trait TranslatedNewlineIterator {\n+    fn translate(&self, offset: TextUnit) -> TextUnit;\n+    fn translate_range(&self, range: TextRange) -> TextRange {\n+        TextRange::from_to(self.translate(range.start()), self.translate(range.end()))\n+    }\n+    fn next_translated(&mut self) -> Option<TextUnit>;\n+    fn boxed<'a>(self) -> Box<TranslatedNewlineIterator + 'a>\n+    where\n+        Self: 'a + Sized,\n+    {\n+        Box::new(self)\n+    }\n+}\n+\n+struct TranslatedAtomEdit<'a> {\n+    delete: TextRange,\n+    insert: &'a str,\n+}\n+\n+struct TranslatedNewlines<'a, T: TranslatedNewlineIterator> {\n+    inner: T,\n+    next_inner: Option<TranslatedOffset>,\n+    edit: TranslatedAtomEdit<'a>,\n+    insert: OffsetNewlineIter<'a>,\n+}\n+\n+impl<'a, T: TranslatedNewlineIterator> TranslatedNewlines<'a, T> {\n+    fn from(inner: T, edit: &'a AtomTextEdit) -> Self {\n+        let delete = inner.translate_range(edit.delete);\n+        let mut res = TranslatedNewlines {\n+            inner,\n+            next_inner: None,\n+            edit: TranslatedAtomEdit {\n+                delete,\n+                insert: &edit.insert,\n+            },\n+            insert: OffsetNewlineIter {\n+                offset: delete.start(),\n+                text: &edit.insert,\n+            },\n+        };\n+        // prepare next_inner\n+        res.advance_inner();\n+        res\n+    }\n+\n+    fn advance_inner(&mut self) {\n+        self.next_inner = self\n+            .inner\n+            .next_translated()\n+            .map(|x| translate_offset(x, &self.edit));\n+    }\n+}\n+\n+impl<'a, T: TranslatedNewlineIterator> TranslatedNewlineIterator for TranslatedNewlines<'a, T> {\n+    fn translate(&self, offset: TextUnit) -> TextUnit {\n+        let offset = self.inner.translate(offset);\n+        let (_, offset) =\n+            translate_offset(offset, &self.edit).expect(\"translate_unit returned None\");\n+        offset\n+    }\n+\n+    fn next_translated(&mut self) -> Option<TextUnit> {\n+        match self.next_inner {\n+            None => self.insert.next(),\n+            Some(next) => match next {\n+                None => self.insert.next().or_else(|| {\n+                    self.advance_inner();\n+                    self.next_translated()\n+                }),\n+                Some((TranslatedPos::Before, next)) => {\n+                    self.advance_inner();\n+                    Some(next)\n+                }\n+                Some((TranslatedPos::After, next)) => self.insert.next().or_else(|| {\n+                    self.advance_inner();\n+                    Some(next)\n+                }),\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for Box<dyn TranslatedNewlineIterator + 'a> {\n+    type Item = TextUnit;\n+    fn next(&mut self) -> Option<TextUnit> {\n+        self.next_translated()\n+    }\n+}\n+\n+impl<T: TranslatedNewlineIterator + ?Sized> TranslatedNewlineIterator for Box<T> {\n+    fn translate(&self, offset: TextUnit) -> TextUnit {\n+        self.as_ref().translate(offset)\n+    }\n+    fn next_translated(&mut self) -> Option<TextUnit> {\n+        self.as_mut().next_translated()\n+    }\n+}\n+\n+struct IteratorWrapper<T: Iterator<Item = TextUnit>>(T);\n+\n+impl<T: Iterator<Item = TextUnit>> TranslatedNewlineIterator for IteratorWrapper<T> {\n+    fn translate(&self, offset: TextUnit) -> TextUnit {\n+        offset\n+    }\n+    fn next_translated(&mut self) -> Option<TextUnit> {\n+        self.0.next()\n+    }\n+}\n+\n+impl<T: Iterator<Item = TextUnit>> Iterator for IteratorWrapper<T> {\n+    type Item = TextUnit;\n+    fn next(&mut self) -> Option<TextUnit> {\n+        self.0.next()\n+    }\n+}\n+\n+fn translate_newlines<'a>(\n+    mut newlines: Box<TranslatedNewlineIterator + 'a>,\n+    edits: &'a [AtomTextEdit],\n+) -> Box<TranslatedNewlineIterator + 'a> {\n+    for edit in edits {\n+        newlines = TranslatedNewlines::from(newlines, edit).boxed();\n+    }\n+    newlines\n+}\n+\n+pub fn translate_offset_with_edit(\n+    pre_edit_index: &LineIndex,\n+    offset: TextUnit,\n+    edits: &[AtomTextEdit],\n+) -> LineCol {\n+    let mut newlines: Box<TranslatedNewlineIterator> = Box::new(IteratorWrapper(\n+        pre_edit_index.newlines().iter().map(|x| *x),\n+    ));\n+\n+    newlines = translate_newlines(newlines, edits);\n+\n+    let mut line = 0;\n+    for n in newlines {\n+        if n > offset {\n+            break;\n+        }\n+        line += 1;\n+    }\n+\n+    LineCol {\n+        line: line,\n+        col_utf16: 0, // TODO not implemented yet\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use proptest::{prelude::*, proptest, proptest_helper};\n+    use super::*;\n+    use ra_text_edit::test_utils::{arb_text, arb_offset, arb_edits};\n+\n+    #[derive(Debug)]\n+    struct ArbTextWithOffsetAndEdits {\n+        text: String,\n+        offset: TextUnit,\n+        edits: Vec<AtomTextEdit>,\n+    }\n+\n+    fn arb_text_with_offset_and_edits() -> BoxedStrategy<ArbTextWithOffsetAndEdits> {\n+        arb_text()\n+            .prop_flat_map(|text| {\n+                (arb_offset(&text), arb_edits(&text), Just(text)).prop_map(\n+                    |(offset, edits, text)| ArbTextWithOffsetAndEdits {\n+                        text,\n+                        offset,\n+                        edits,\n+                    },\n+                )\n+            })\n+            .boxed()\n+    }\n+\n+    fn edit_text(pre_edit_text: &str, mut edits: Vec<AtomTextEdit>) -> String {\n+        // apply edits ordered from last to first\n+        // since they should not overlap we can just use start()\n+        edits.sort_by_key(|x| -(x.delete.start().to_usize() as isize));\n+\n+        let mut text = pre_edit_text.to_owned();\n+\n+        for edit in &edits {\n+            let range = edit.delete.start().to_usize()..edit.delete.end().to_usize();\n+            text.replace_range(range, &edit.insert);\n+        }\n+\n+        text\n+    }\n+\n+    fn translate_after_edit(\n+        pre_edit_text: &str,\n+        offset: TextUnit,\n+        edits: Vec<AtomTextEdit>,\n+    ) -> LineCol {\n+        let text = edit_text(pre_edit_text, edits);\n+        let line_index = LineIndex::new(&text);\n+        line_index.line_col(offset)\n+    }\n+\n+    proptest! {\n+        #[test]\n+        fn test_translate_offset_with_edit(x in arb_text_with_offset_and_edits()) {\n+            let line_index = LineIndex::new(&x.text);\n+            let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n+            let actual = translate_offset_with_edit(&line_index, x.offset, &x.edits);\n+            assert_eq!(actual.line, expected.line);\n+        }\n+    }\n+}"}, {"sha": "3c8c240cd80b5804c48cb06a2823cc7c7de2683a", "filename": "crates/ra_lsp_server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/crates%2Fra_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/crates%2Fra_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2FCargo.toml?ref=8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "patch": "@@ -34,8 +34,6 @@ ra_analysis = { path = \"../ra_analysis\" }\n gen_lsp_server = { path = \"../gen_lsp_server\" }\n ra_vfs = { path = \"../ra_vfs\" }\n \n-proptest = \"0.8.7\"\n-\n [dev-dependencies]\n tempdir = \"0.3.7\"\n-test_utils = { path = \"../test_utils\" }\n\\ No newline at end of file\n+test_utils = { path = \"../test_utils\" }"}, {"sha": "051f1f995b3c920badd995c9326408fc83dee76d", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=8c9df62c1c6a778a8df9ea028d1dce98c91c4d9d", "patch": "@@ -296,202 +296,6 @@ fn translate_offset_with_edit(\n     }\n }\n \n-#[derive(Debug)]\n-struct OffsetNewlineIter<'a> {\n-    text: &'a str,\n-    offset: TextUnit,\n-}\n-\n-impl<'a> Iterator for OffsetNewlineIter<'a> {\n-    type Item = TextUnit;\n-    fn next(&mut self) -> Option<TextUnit> {\n-        let next_idx = self\n-            .text\n-            .char_indices()\n-            .filter_map(|(i, c)| if c == '\\n' { Some(i + 1) } else { None })\n-            .next()?;\n-        let next = self.offset + TextUnit::from_usize(next_idx);\n-        self.text = &self.text[next_idx..];\n-        self.offset = next;\n-        Some(next)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq)]\n-enum TranslatedPos {\n-    Before,\n-    After,\n-}\n-\n-/// None means it was deleted\n-type TranslatedOffset = Option<(TranslatedPos, TextUnit)>;\n-\n-fn translate_offset(offset: TextUnit, edit: &TranslatedAtomEdit) -> TranslatedOffset {\n-    if offset <= edit.delete.start() {\n-        Some((TranslatedPos::Before, offset))\n-    } else if offset <= edit.delete.end() {\n-        None\n-    } else {\n-        let diff = edit.insert.len() as i64 - edit.delete.len().to_usize() as i64;\n-        let after = TextUnit::from((offset.to_usize() as i64 + diff) as u32);\n-        Some((TranslatedPos::After, after))\n-    }\n-}\n-\n-trait TranslatedNewlineIterator {\n-    fn translate(&self, offset: TextUnit) -> TextUnit;\n-    fn translate_range(&self, range: TextRange) -> TextRange {\n-        TextRange::from_to(self.translate(range.start()), self.translate(range.end()))\n-    }\n-    fn next_translated(&mut self) -> Option<TextUnit>;\n-    fn boxed<'a>(self) -> Box<TranslatedNewlineIterator + 'a>\n-    where\n-        Self: 'a + Sized,\n-    {\n-        Box::new(self)\n-    }\n-}\n-\n-struct TranslatedAtomEdit<'a> {\n-    delete: TextRange,\n-    insert: &'a str,\n-}\n-\n-struct TranslatedNewlines<'a, T: TranslatedNewlineIterator> {\n-    inner: T,\n-    next_inner: Option<TranslatedOffset>,\n-    edit: TranslatedAtomEdit<'a>,\n-    insert: OffsetNewlineIter<'a>,\n-}\n-\n-impl<'a, T: TranslatedNewlineIterator> TranslatedNewlines<'a, T> {\n-    fn from(inner: T, edit: &'a AtomTextEdit) -> Self {\n-        let delete = inner.translate_range(edit.delete);\n-        let mut res = TranslatedNewlines {\n-            inner,\n-            next_inner: None,\n-            edit: TranslatedAtomEdit {\n-                delete,\n-                insert: &edit.insert,\n-            },\n-            insert: OffsetNewlineIter {\n-                offset: delete.start(),\n-                text: &edit.insert,\n-            },\n-        };\n-        // prepare next_inner\n-        res.advance_inner();\n-        res\n-    }\n-\n-    fn advance_inner(&mut self) {\n-        self.next_inner = self\n-            .inner\n-            .next_translated()\n-            .map(|x| translate_offset(x, &self.edit));\n-    }\n-}\n-\n-impl<'a, T: TranslatedNewlineIterator> TranslatedNewlineIterator for TranslatedNewlines<'a, T> {\n-    fn translate(&self, offset: TextUnit) -> TextUnit {\n-        let offset = self.inner.translate(offset);\n-        let (_, offset) =\n-            translate_offset(offset, &self.edit).expect(\"translate_unit returned None\");\n-        offset\n-    }\n-\n-    fn next_translated(&mut self) -> Option<TextUnit> {\n-        match self.next_inner {\n-            None => self.insert.next(),\n-            Some(next) => match next {\n-                None => self.insert.next().or_else(|| {\n-                    self.advance_inner();\n-                    self.next_translated()\n-                }),\n-                Some((TranslatedPos::Before, next)) => {\n-                    self.advance_inner();\n-                    Some(next)\n-                }\n-                Some((TranslatedPos::After, next)) => self.insert.next().or_else(|| {\n-                    self.advance_inner();\n-                    Some(next)\n-                }),\n-            },\n-        }\n-    }\n-}\n-\n-impl<'a> Iterator for Box<dyn TranslatedNewlineIterator + 'a> {\n-    type Item = TextUnit;\n-    fn next(&mut self) -> Option<TextUnit> {\n-        self.next_translated()\n-    }\n-}\n-\n-impl<T: TranslatedNewlineIterator + ?Sized> TranslatedNewlineIterator for Box<T> {\n-    fn translate(&self, offset: TextUnit) -> TextUnit {\n-        self.as_ref().translate(offset)\n-    }\n-    fn next_translated(&mut self) -> Option<TextUnit> {\n-        self.as_mut().next_translated()\n-    }\n-}\n-\n-struct IteratorWrapper<T: Iterator<Item = TextUnit>>(T);\n-\n-impl<T: Iterator<Item = TextUnit>> TranslatedNewlineIterator for IteratorWrapper<T> {\n-    fn translate(&self, offset: TextUnit) -> TextUnit {\n-        offset\n-    }\n-    fn next_translated(&mut self) -> Option<TextUnit> {\n-        self.0.next()\n-    }\n-}\n-\n-impl<T: Iterator<Item = TextUnit>> Iterator for IteratorWrapper<T> {\n-    type Item = TextUnit;\n-    fn next(&mut self) -> Option<TextUnit> {\n-        self.0.next()\n-    }\n-}\n-\n-fn translate_newlines<'a>(\n-    mut newlines: Box<TranslatedNewlineIterator + 'a>,\n-    edits: &'a [AtomTextEdit],\n-) -> Box<TranslatedNewlineIterator + 'a> {\n-    for edit in edits {\n-        newlines = TranslatedNewlines::from(newlines, edit).boxed();\n-    }\n-    newlines\n-}\n-\n-#[allow(dead_code)]\n-fn translate_offset_with_edit_fast(\n-    pre_edit_index: &LineIndex,\n-    offset: TextUnit,\n-    edits: &[AtomTextEdit],\n-) -> LineCol {\n-    // println!(\"{:?}\", pre_edit_index.newlines());\n-    let mut newlines: Box<TranslatedNewlineIterator> = Box::new(IteratorWrapper(\n-        pre_edit_index.newlines().iter().map(|x| *x),\n-    ));\n-\n-    newlines = translate_newlines(newlines, edits);\n-\n-    let mut line = 0;\n-    for n in newlines {\n-        if n > offset {\n-            break;\n-        }\n-        line += 1;\n-    }\n-\n-    LineCol {\n-        line: line,\n-        col_utf16: 0,\n-    }\n-}\n-\n impl TryConvWith for SourceFileEdit {\n     type Ctx = ServerWorld;\n     type Output = TextDocumentEdit;\n@@ -582,112 +386,3 @@ where\n         self.iter.next().map(|item| item.conv_with(self.ctx))\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use proptest::{prelude::*, proptest, proptest_helper};\n-    use super::*;\n-    use ra_text_edit::test_utils::{arb_text, arb_offset, arb_edits};\n-\n-    #[derive(Debug)]\n-    struct ArbTextWithOffsetAndEdits {\n-        text: String,\n-        offset: TextUnit,\n-        edits: Vec<AtomTextEdit>,\n-    }\n-\n-    fn arb_text_with_offset_and_edits() -> BoxedStrategy<ArbTextWithOffsetAndEdits> {\n-        arb_text()\n-            .prop_flat_map(|text| {\n-                (arb_offset(&text), arb_edits(&text), Just(text)).prop_map(\n-                    |(offset, edits, text)| ArbTextWithOffsetAndEdits {\n-                        text,\n-                        offset,\n-                        edits,\n-                    },\n-                )\n-            })\n-            .boxed()\n-    }\n-\n-    fn edit_text(pre_edit_text: &str, mut edits: Vec<AtomTextEdit>) -> String {\n-        // apply edits ordered from last to first\n-        // since they should not overlap we can just use start()\n-        edits.sort_by_key(|x| -(x.delete.start().to_usize() as isize));\n-\n-        let mut text = pre_edit_text.to_owned();\n-\n-        for edit in &edits {\n-            let range = edit.delete.start().to_usize()..edit.delete.end().to_usize();\n-            text.replace_range(range, &edit.insert);\n-        }\n-\n-        text\n-    }\n-\n-    fn translate_after_edit(\n-        pre_edit_text: &str,\n-        offset: TextUnit,\n-        edits: Vec<AtomTextEdit>,\n-    ) -> LineCol {\n-        let text = edit_text(pre_edit_text, edits);\n-        let line_index = LineIndex::new(&text);\n-        line_index.line_col(offset)\n-    }\n-\n-    proptest! {\n-        #[test]\n-        fn test_translate_offset_with_edit(x in arb_text_with_offset_and_edits()) {\n-            let line_index = LineIndex::new(&x.text);\n-            let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n-            let actual = translate_offset_with_edit_fast(&line_index, x.offset, &x.edits);\n-            assert_eq!(actual.line, expected.line);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_translate_offset_with_edit_1() {\n-        let x = ArbTextWithOffsetAndEdits {\n-            text: \"jbnan\".to_owned(),\n-            offset: 3.into(),\n-            edits: vec![\n-                AtomTextEdit::delete(TextRange::from_to(1.into(), 3.into())),\n-                AtomTextEdit::insert(4.into(), \"\\n\".into()),\n-            ],\n-        };\n-        let line_index = LineIndex::new(&x.text);\n-        let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n-        let actual = translate_offset_with_edit_fast(&line_index, x.offset, &x.edits);\n-        // assert_eq!(actual, expected);\n-        assert_eq!(actual.line, expected.line);\n-    }\n-\n-    #[test]\n-    fn test_translate_offset_with_edit_2() {\n-        let x = ArbTextWithOffsetAndEdits {\n-            text: \"aa\\n\".to_owned(),\n-            offset: 1.into(),\n-            edits: vec![AtomTextEdit::delete(TextRange::from_to(0.into(), 2.into()))],\n-        };\n-        let line_index = LineIndex::new(&x.text);\n-        let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n-        let actual = translate_offset_with_edit_fast(&line_index, x.offset, &x.edits);\n-        // assert_eq!(actual, expected);\n-        assert_eq!(actual.line, expected.line);\n-    }\n-\n-    #[test]\n-    fn test_translate_offset_with_edit_3() {\n-        let x = ArbTextWithOffsetAndEdits {\n-            text: \"\".to_owned(),\n-            offset: 0.into(),\n-            edits: vec![AtomTextEdit::insert(0.into(), \"\\n\".into())],\n-        };\n-        let line_index = LineIndex::new(&x.text);\n-        let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n-        let actual = translate_offset_with_edit_fast(&line_index, x.offset, &x.edits);\n-        // assert_eq!(actual, expected);\n-        assert_eq!(actual.line, expected.line);\n-    }\n-\n-}"}]}