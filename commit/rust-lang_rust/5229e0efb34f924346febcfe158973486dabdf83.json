{"sha": "5229e0efb34f924346febcfe158973486dabdf83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMjllMGVmYjM0ZjkyNDM0NmZlYmNmZTE1ODk3MzQ4NmRhYmRmODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-25T09:33:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-25T09:33:29Z"}, "message": "Auto merge of #33602 - eddyb:no-trans--check, r=michaelwoerister\n\nSave metadata even with -Z no-trans (e.g. for multi-crate cargo check).\n\nRemoves the item symbol map in metadata, as we can now generate them in a deterministic manner.\nThe `-Z no-trans` change lets the LLVM passes and linking run, but with just metadata and no code.\nIt fails while trying to link a binary because there's no `main` function, which is correct but not good UX.\n\nThere's also no way to easily throw away all of the artifacts to rebuild with actual code generation.\nWe might want `cargo check` to do that using cargo-internal information and then it would just work.\n\ncc @alexcrichton @nikomatsakis @Aatch @michaelwoerister", "tree": {"sha": "262d5d899c26e1d66a5a64874b55fd6946e2d146", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/262d5d899c26e1d66a5a64874b55fd6946e2d146"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5229e0efb34f924346febcfe158973486dabdf83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5229e0efb34f924346febcfe158973486dabdf83", "html_url": "https://github.com/rust-lang/rust/commit/5229e0efb34f924346febcfe158973486dabdf83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5229e0efb34f924346febcfe158973486dabdf83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "487de4208346968b17be53bd5f423156a2b6c065", "url": "https://api.github.com/repos/rust-lang/rust/commits/487de4208346968b17be53bd5f423156a2b6c065", "html_url": "https://github.com/rust-lang/rust/commit/487de4208346968b17be53bd5f423156a2b6c065"}, {"sha": "a619901e3dafbfb01e10c53cdb5f9fea52a1ef6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a619901e3dafbfb01e10c53cdb5f9fea52a1ef6d", "html_url": "https://github.com/rust-lang/rust/commit/a619901e3dafbfb01e10c53cdb5f9fea52a1ef6d"}], "stats": {"total": 721, "additions": 371, "deletions": 350}, "files": [{"sha": "3ede60beb74436ba1ce61149bd03aabf7cb17062", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -34,8 +34,7 @@ use mir::mir_map::MirMap;\n use session::Session;\n use session::config::PanicStrategy;\n use session::search_paths::PathKind;\n-use util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n-use std::cell::RefCell;\n+use util::nodemap::{FnvHashMap, NodeSet, DefIdMap};\n use std::rc::Rc;\n use std::path::PathBuf;\n use syntax::ast;\n@@ -169,7 +168,6 @@ pub trait CrateStore<'tcx> {\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n-    fn item_symbol(&self, def: DefId) -> String;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n     fn method_arg_names(&self, did: DefId) -> Vec<String>;\n@@ -205,6 +203,7 @@ pub trait CrateStore<'tcx> {\n     fn is_impl(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool;\n+    fn is_foreign_item(&self, did: DefId) -> bool;\n     fn is_static_method(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n     fn is_typedef(&self, did: DefId) -> bool;\n@@ -274,7 +273,6 @@ pub trait CrateStore<'tcx> {\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>;\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n-                           item_symbols: &RefCell<NodeMap<String>>,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet,\n                            mir_map: &MirMap<'tcx>,\n@@ -352,7 +350,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n-    fn item_symbol(&self, def: DefId) -> String { bug!(\"item_symbol\") }\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n         { bug!(\"trait_def\") }\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n@@ -399,6 +396,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool\n         { bug!(\"is_extern_item\") }\n+    fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n     fn is_static_method(&self, did: DefId) -> bool { bug!(\"is_static_method\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n     fn is_typedef(&self, did: DefId) -> bool { bug!(\"is_typedef\") }\n@@ -481,7 +479,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum> { None }\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n-                           item_symbols: &RefCell<NodeMap<String>>,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet,\n                            mir_map: &MirMap<'tcx>,"}, {"sha": "05ed02211097c309091e83d9bea9a8244acae7ef", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -1104,7 +1104,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let no_analysis = debugging_opts.no_analysis;\n \n     let mut output_types = HashMap::new();\n-    if !debugging_opts.parse_only && !no_trans {\n+    if !debugging_opts.parse_only {\n         for list in matches.opt_strs(\"emit\") {\n             for output_type in list.split(',') {\n                 let mut parts = output_type.splitn(2, '=');"}, {"sha": "ab9187a835dada660907cf228c7ba9b1eb3035ba", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use dep_graph::DepGraph;\n+use hir::def_id::DefIndex;\n+use hir::svh::Svh;\n use lint;\n use middle::cstore::CrateStore;\n use middle::dependency_format;\n@@ -312,6 +314,14 @@ impl Session {\n     pub fn nonzeroing_move_hints(&self) -> bool {\n         self.opts.debugging_opts.enable_nonzeroing_move_hints\n     }\n+\n+    /// Returns the symbol name for the registrar function,\n+    /// given the crate Svh and the function DefIndex.\n+    pub fn generate_plugin_registrar_symbol(&self, svh: &Svh, index: DefIndex)\n+                                            -> String {\n+        format!(\"__rustc_plugin_registrar__{}_{}\", svh, index.as_usize())\n+    }\n+\n     pub fn sysroot<'a>(&'a self) -> &'a Path {\n         match self.opts.maybe_sysroot {\n             Some (ref sysroot) => sysroot,"}, {"sha": "ee9983038b162aab2c8fdaa3009f59a0c966d91d", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -14,12 +14,38 @@ use hir::def_id::{DefId, CRATE_DEF_INDEX};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n \n+use std::cell::Cell;\n+\n+thread_local! {\n+    static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false)\n+}\n+\n+/// Enforces that item_path_str always returns an absolute path.\n+/// This is useful when building symbols that contain types,\n+/// where we want the crate name to be part of the symbol.\n+pub fn with_forced_absolute_paths<F: FnOnce() -> R, R>(f: F) -> R {\n+    FORCE_ABSOLUTE.with(|force| {\n+        let old = force.get();\n+        force.set(true);\n+        let result = f();\n+        force.set(old);\n+        result\n+    })\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It is relative to the current crate\n-    /// root.\n+    /// root, unless with_forced_absolute_paths was used.\n     pub fn item_path_str(self, def_id: DefId) -> String {\n-        let mut buffer = LocalPathBuffer::new(RootMode::Local);\n+        let mode = FORCE_ABSOLUTE.with(|force| {\n+            if force.get() {\n+                RootMode::Absolute\n+            } else {\n+                RootMode::Local\n+            }\n+        });\n+        let mut buffer = LocalPathBuffer::new(mode);\n         self.push_item_path(&mut buffer, def_id);\n         buffer.into_string()\n     }\n@@ -75,7 +101,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             RootMode::Absolute => {\n                 // In absolute mode, just write the crate name\n                 // unconditionally.\n-                buffer.push(&self.crate_name(cnum));\n+                if cnum == LOCAL_CRATE {\n+                    buffer.push(&self.crate_name(cnum));\n+                } else {\n+                    buffer.push(&self.sess.cstore.original_crate_name(cnum));\n+                }\n             }\n         }\n     }"}, {"sha": "bd6b0599e7832f4b2cec029eee0e90bde6afa85f", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -511,10 +511,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             control.after_write_deps.stop = Compilation::Stop;\n         }\n \n-        if sess.opts.no_trans {\n-            control.after_analysis.stop = Compilation::Stop;\n-        }\n-\n         if !sess.opts.output_types.keys().any(|&i| i == OutputType::Exe) {\n             control.after_llvm.stop = Compilation::Stop;\n         }"}, {"sha": "74f97de26589839266d2b33040ce700092192d7c", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -33,7 +33,7 @@ pub const tag_items_data_item_family: usize = 0x24;\n \n pub const tag_items_data_item_type: usize = 0x25;\n \n-pub const tag_items_data_item_symbol: usize = 0x26;\n+// GAP 0x26\n \n pub const tag_items_data_item_variant: usize = 0x27;\n "}, {"sha": "2025045cc8f56f3ac6aced9424af50d3aa9da472", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -17,6 +17,7 @@ use cstore::{self, CStore, CrateSource, MetadataBlob};\n use decoder;\n use loader::{self, CratePaths};\n \n+use rustc::hir::def_id::DefIndex;\n use rustc::hir::svh::Svh;\n use rustc::dep_graph::{DepGraph, DepNode};\n use rustc::session::{config, Session};\n@@ -610,9 +611,10 @@ impl<'a> CrateReader<'a> {\n         macros\n     }\n \n-    /// Look for a plugin registrar. Returns library path and symbol name.\n+    /// Look for a plugin registrar. Returns library path, crate\n+    /// SVH and DefIndex of the registrar function.\n     pub fn find_plugin_registrar(&mut self, span: Span, name: &str)\n-                                 -> Option<(PathBuf, String)> {\n+                                 -> Option<(PathBuf, Svh, DefIndex)> {\n         let ekrate = self.read_extension_crate(span, &CrateInfo {\n              name: name.to_string(),\n              ident: name.to_string(),\n@@ -630,12 +632,14 @@ impl<'a> CrateReader<'a> {\n             span_fatal!(self.sess, span, E0456, \"{}\", &message[..]);\n         }\n \n+        let svh = decoder::get_crate_hash(ekrate.metadata.as_slice());\n         let registrar =\n-            decoder::get_plugin_registrar_fn(ekrate.metadata.as_slice())\n-            .map(|id| decoder::get_symbol_from_buf(ekrate.metadata.as_slice(), id));\n+            decoder::get_plugin_registrar_fn(ekrate.metadata.as_slice());\n \n         match (ekrate.dylib.as_ref(), registrar) {\n-            (Some(dylib), Some(reg)) => Some((dylib.to_path_buf(), reg)),\n+            (Some(dylib), Some(reg)) => {\n+                Some((dylib.to_path_buf(), svh, reg))\n+            }\n             (None, Some(_)) => {\n                 span_err!(self.sess, span, E0457,\n                           \"plugin `{}` only found in rlib format, but must be available \\"}, {"sha": "5d42f8c1d6f6ac3047a7df82403296f5ea4e31f7", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -25,7 +25,7 @@ use rustc::hir::map as hir_map;\n use rustc::hir::map::DefKey;\n use rustc::mir::repr::Mir;\n use rustc::mir::mir_map::MirMap;\n-use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n+use rustc::util::nodemap::{FnvHashMap, NodeSet, DefIdMap};\n use rustc::session::config::PanicStrategy;\n \n use std::cell::RefCell;\n@@ -115,13 +115,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_item_attrs(&cdata, def_id.index)\n     }\n \n-    fn item_symbol(&self, def: DefId) -> String\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_symbol(&cdata, def.index)\n-    }\n-\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n@@ -284,6 +277,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_extern_item(&cdata, did.index, tcx)\n     }\n \n+    fn is_foreign_item(&self, did: DefId) -> bool {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::is_foreign_item(&cdata, did.index)\n+    }\n+\n     fn is_static_method(&self, def: DefId) -> bool\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n@@ -564,7 +562,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n-                           item_symbols: &RefCell<NodeMap<String>>,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet,\n                            mir_map: &MirMap<'tcx>,\n@@ -574,7 +571,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n             diag: tcx.sess.diagnostic(),\n             tcx: tcx,\n             reexports: reexports,\n-            item_symbols: item_symbols,\n             link_meta: link_meta,\n             cstore: self,\n             reachable: reachable,"}, {"sha": "d1153fe2d06037e6a9cbd17e17afa869011be365", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -213,10 +213,6 @@ fn item_sort(item: rbml::Doc) -> Option<char> {\n     })\n }\n \n-fn item_symbol(item: rbml::Doc) -> String {\n-    reader::get_doc(item, tag_items_data_item_symbol).as_str().to_string()\n-}\n-\n fn untranslated_def_id(d: rbml::Doc) -> DefId {\n     let id = reader::doc_as_u64(d);\n     let index = DefIndex::new((id & 0xFFFF_FFFF) as usize);\n@@ -640,18 +636,6 @@ pub fn get_impl_trait<'a, 'tcx>(cdata: Cmd,\n     }\n }\n \n-pub fn get_symbol(cdata: Cmd, id: DefIndex) -> String {\n-    return item_symbol(cdata.lookup_item(id));\n-}\n-\n-/// If you have a crate_metadata, call get_symbol instead\n-pub fn get_symbol_from_buf(data: &[u8], id: DefIndex) -> String {\n-    let index = load_index(data);\n-    let pos = index.lookup_item(data, id).unwrap();\n-    let doc = reader::doc_at(data, pos as usize).unwrap().doc;\n-    item_symbol(doc)\n-}\n-\n /// Iterates over the language items in the given crate.\n pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n     F: FnMut(DefIndex, usize) -> bool,\n@@ -1642,6 +1626,16 @@ pub fn is_extern_item<'a, 'tcx>(cdata: Cmd,\n     }\n }\n \n+pub fn is_foreign_item(cdata: Cmd, id: DefIndex) -> bool {\n+    let item_doc = cdata.lookup_item(id);\n+    let parent_item_id = match item_parent_item(cdata, item_doc) {\n+        None => return false,\n+        Some(item_id) => item_id,\n+    };\n+    let parent_item_doc = cdata.lookup_item(parent_item_id.index);\n+    item_family(parent_item_doc) == ForeignMod\n+}\n+\n pub fn is_impl(cdata: Cmd, id: DefIndex) -> bool {\n     let item_doc = cdata.lookup_item(id);\n     match item_family(item_doc) {"}, {"sha": "2bc953039adb281851d27713c8a75bc55f279478", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -34,7 +34,7 @@ use rustc::ty::util::IntTypeExt;\n use rustc::hir::svh::Svh;\n use rustc::mir::mir_map::MirMap;\n use rustc::session::config::{self, PanicStrategy};\n-use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n+use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n use rustc_serialize::Encodable;\n use std::cell::RefCell;\n@@ -59,7 +59,6 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub reexports: &'a def::ExportMap,\n-    pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n     pub type_abbrevs: tyencode::abbrev_map<'tcx>,\n@@ -213,20 +212,6 @@ fn encode_region(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: &EncodeContext,\n-                 rbml_w: &mut Encoder,\n-                 id: NodeId) {\n-    match ecx.item_symbols.borrow().get(&id) {\n-        Some(x) => {\n-            debug!(\"encode_symbol(id={}, str={})\", id, *x);\n-            rbml_w.wr_tagged_str(tag_items_data_item_symbol, x);\n-        }\n-        None => {\n-            bug!(\"encode_symbol: id not found {}\", id);\n-        }\n-    }\n-}\n-\n fn encode_disr_val(_: &EncodeContext,\n                    rbml_w: &mut Encoder,\n                    disr_val: ty::Disr) {\n@@ -518,10 +503,6 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_name(rbml_w, name);\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(struct_id));\n \n-    if ecx.item_symbols.borrow().contains_key(&ctor_id) {\n-        encode_symbol(ecx, rbml_w, ctor_id);\n-    }\n-\n     let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(ctor_id));\n     let depr= ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(ctor_id));\n     encode_stability(rbml_w, stab);\n@@ -710,10 +691,6 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             }\n             encode_constness(rbml_w, sig.constness);\n             encode_defaultness(rbml_w, impl_item.defaultness);\n-            if !any_types {\n-                let m_id = ecx.local_id(m.def_id);\n-                encode_symbol(ecx, rbml_w, m_id);\n-            }\n             encode_method_argument_names(rbml_w, &sig.decl);\n         }\n     }\n@@ -894,7 +871,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_family(rbml_w, 'c');\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_symbol(ecx, rbml_w, item.id);\n         encode_name(rbml_w, item.name);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -931,9 +907,6 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n             encode_mir(ecx, rbml_w, item.id);\n         }\n-        if tps_len == 0 {\n-            encode_symbol(ecx, rbml_w, item.id);\n-        }\n         encode_constness(rbml_w, constness);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1354,6 +1327,8 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     let _task = index.record(def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, def_id);\n+    let parent_id = ecx.tcx.map.get_parent(nitem.id);\n+    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_visibility(rbml_w, &nitem.vis);\n     match nitem.node {\n       hir::ForeignItemFn(ref fndecl, _) => {\n@@ -1363,8 +1338,6 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n             encode_mir(ecx, rbml_w, nitem.id);\n-        } else {\n-            encode_symbol(ecx, rbml_w, nitem.id);\n         }\n         encode_attributes(rbml_w, &nitem.attrs);\n         let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n@@ -1385,7 +1358,6 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n-        encode_symbol(ecx, rbml_w, nitem.id);\n         encode_name(rbml_w, nitem.name);\n       }\n     }"}, {"sha": "11e1841f7493e716a47c4508bd5a049954f3f2b8", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -101,7 +101,8 @@ impl<'a> PluginLoader<'a> {\n     fn load_plugin(&mut self, span: Span, name: &str, args: Vec<P<ast::MetaItem>>) {\n         let registrar = self.reader.find_plugin_registrar(span, name);\n \n-        if let Some((lib, symbol)) = registrar {\n+        if let Some((lib, svh, index)) = registrar {\n+            let symbol = self.sess.generate_plugin_registrar_symbol(&svh, index);\n             let fun = self.dylink_registrar(span, lib, symbol);\n             self.plugins.push(PluginRegistrar {\n                 fun: fun,"}, {"sha": "4640377cf86005bc1dee0c192d44a48ca05906a8", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::archive::{ArchiveBuilder, ArchiveConfig};\n-use super::linker::{Linker, GnuLinker, MsvcLinker};\n+use super::linker::Linker;\n use super::rpath::RPathConfig;\n use super::rpath;\n use super::msvc;\n@@ -188,6 +188,11 @@ pub fn link_binary(sess: &Session,\n \n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n+        // Ignore executable crates if we have -Z no-trans, as they will error.\n+        if sess.opts.no_trans && crate_type == config::CrateTypeExecutable {\n+            continue;\n+        }\n+\n         if invalid_output_for_target(sess, crate_type) {\n            bug!(\"invalid output type `{:?}` for target os `{}`\",\n                 crate_type, sess.opts.target_triple);\n@@ -637,13 +642,9 @@ fn link_natively(sess: &Session,\n     }\n \n     {\n-        let mut linker = if sess.target.target.options.is_like_msvc {\n-            Box::new(MsvcLinker { cmd: &mut cmd, sess: &sess }) as Box<Linker>\n-        } else {\n-            Box::new(GnuLinker { cmd: &mut cmd, sess: &sess }) as Box<Linker>\n-        };\n+        let mut linker = trans.linker_info.to_linker(&mut cmd, &sess);\n         link_args(&mut *linker, sess, crate_type, tmpdir,\n-                  objects, out_filename, trans, outputs);\n+                  objects, out_filename, outputs);\n         if !sess.target.target.options.no_compiler_rt {\n             linker.link_staticlib(\"compiler-rt\");\n         }\n@@ -712,7 +713,6 @@ fn link_args(cmd: &mut Linker,\n              tmpdir: &Path,\n              objects: &[PathBuf],\n              out_filename: &Path,\n-             trans: &CrateTranslation,\n              outputs: &OutputFilenames) {\n \n     // The default library location, we need this to find the runtime.\n@@ -731,7 +731,7 @@ fn link_args(cmd: &mut Linker,\n     // If we're building a dynamic library then some platforms need to make sure\n     // that all symbols are exported correctly from the dynamic library.\n     if crate_type != config::CrateTypeExecutable {\n-        cmd.export_symbols(sess, trans, tmpdir, crate_type);\n+        cmd.export_symbols(tmpdir, crate_type);\n     }\n \n     // When linking a dynamic library, we put the metadata into a section of the"}, {"sha": "cb990ead8e81e94ae0de9f5982d8817517e2e9d6", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 80, "deletions": 36, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -15,13 +15,50 @@ use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n+use context::SharedCrateContext;\n+use monomorphize::Instance;\n+\n use back::archive;\n use middle::dependency_format::Linkage;\n use session::Session;\n use session::config::CrateType;\n use session::config;\n use syntax::ast;\n-use CrateTranslation;\n+\n+/// For all the linkers we support, and information they might\n+/// need out of the shared crate context before we get rid of it.\n+pub struct LinkerInfo {\n+    dylib_exports: Vec<String>,\n+    cdylib_exports: Vec<String>\n+}\n+\n+impl<'a, 'tcx> LinkerInfo {\n+    pub fn new(scx: &SharedCrateContext<'a, 'tcx>,\n+               reachable: &[String]) -> LinkerInfo {\n+        LinkerInfo {\n+            dylib_exports: exported_symbols(scx, reachable, CrateType::CrateTypeDylib),\n+            cdylib_exports: exported_symbols(scx, reachable, CrateType::CrateTypeCdylib)\n+        }\n+    }\n+\n+    pub fn to_linker(&'a self,\n+                     cmd: &'a mut Command,\n+                     sess: &'a Session) -> Box<Linker+'a> {\n+        if sess.target.target.options.is_like_msvc {\n+            Box::new(MsvcLinker {\n+                cmd: cmd,\n+                sess: sess,\n+                info: self\n+            }) as Box<Linker>\n+        } else {\n+            Box::new(GnuLinker {\n+                cmd: cmd,\n+                sess: sess,\n+                info: self\n+            }) as Box<Linker>\n+        }\n+    }\n+}\n \n /// Linker abstraction used by back::link to build up the command to invoke a\n /// linker.\n@@ -53,16 +90,13 @@ pub trait Linker {\n     fn hint_dynamic(&mut self);\n     fn whole_archives(&mut self);\n     fn no_whole_archives(&mut self);\n-    fn export_symbols(&mut self,\n-                      sess: &Session,\n-                      trans: &CrateTranslation,\n-                      tmpdir: &Path,\n-                      crate_type: CrateType);\n+    fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n }\n \n pub struct GnuLinker<'a> {\n-    pub cmd: &'a mut Command,\n-    pub sess: &'a Session,\n+    cmd: &'a mut Command,\n+    sess: &'a Session,\n+    info: &'a LinkerInfo\n }\n \n impl<'a> GnuLinker<'a> {\n@@ -201,11 +235,7 @@ impl<'a> Linker for GnuLinker<'a> {\n         self.cmd.arg(\"-Wl,-Bdynamic\");\n     }\n \n-    fn export_symbols(&mut self,\n-                      sess: &Session,\n-                      trans: &CrateTranslation,\n-                      tmpdir: &Path,\n-                      crate_type: CrateType) {\n+    fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n         // If we're compiling a dylib, then we let symbol visibility in object\n         // files to take care of whether they're exported or not.\n         //\n@@ -225,13 +255,13 @@ impl<'a> Linker for GnuLinker<'a> {\n         };\n         let res = (|| -> io::Result<()> {\n             let mut f = BufWriter::new(File::create(&path)?);\n-            for sym in exported_symbols(sess, trans, crate_type) {\n+            for sym in &self.info.cdylib_exports {\n                 writeln!(f, \"{}{}\", prefix, sym)?;\n             }\n             Ok(())\n         })();\n         if let Err(e) = res {\n-            sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n+            self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n         }\n         let mut arg = OsString::new();\n         if self.sess.target.target.options.is_like_osx {\n@@ -245,8 +275,9 @@ impl<'a> Linker for GnuLinker<'a> {\n }\n \n pub struct MsvcLinker<'a> {\n-    pub cmd: &'a mut Command,\n-    pub sess: &'a Session,\n+    cmd: &'a mut Command,\n+    sess: &'a Session,\n+    info: &'a LinkerInfo\n }\n \n impl<'a> Linker for MsvcLinker<'a> {\n@@ -366,8 +397,6 @@ impl<'a> Linker for MsvcLinker<'a> {\n     // in which case they may continue to transitively be used and hence need\n     // their symbols exported.\n     fn export_symbols(&mut self,\n-                      sess: &Session,\n-                      trans: &CrateTranslation,\n                       tmpdir: &Path,\n                       crate_type: CrateType) {\n         let path = tmpdir.join(\"lib.def\");\n@@ -378,26 +407,42 @@ impl<'a> Linker for MsvcLinker<'a> {\n             // straight to exports.\n             writeln!(f, \"LIBRARY\")?;\n             writeln!(f, \"EXPORTS\")?;\n-\n-            for sym in exported_symbols(sess, trans, crate_type) {\n-                writeln!(f, \"  {}\", sym)?;\n+            let symbols = if crate_type == CrateType::CrateTypeCdylib {\n+                &self.info.cdylib_exports\n+            } else {\n+                &self.info.dylib_exports\n+            };\n+            for symbol in symbols {\n+                writeln!(f, \"  {}\", symbol)?;\n             }\n-\n             Ok(())\n         })();\n         if let Err(e) = res {\n-            sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n+            self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n         }\n         let mut arg = OsString::from(\"/DEF:\");\n         arg.push(path);\n         self.cmd.arg(&arg);\n     }\n }\n \n-fn exported_symbols(sess: &Session,\n-                    trans: &CrateTranslation,\n-                    crate_type: CrateType) -> Vec<String> {\n-    let mut symbols = trans.reachable.iter().cloned().collect::<Vec<_>>();\n+fn exported_symbols(scx: &SharedCrateContext,\n+                    reachable: &[String],\n+                    crate_type: CrateType)\n+                    -> Vec<String> {\n+    if !scx.sess().crate_types.borrow().contains(&crate_type) {\n+        return vec![];\n+    }\n+\n+    // See explanation in GnuLinker::export_symbols, for\n+    // why we don't ever need dylib symbols on non-MSVC.\n+    if crate_type == CrateType::CrateTypeDylib {\n+        if !scx.sess().target.target.options.is_like_msvc {\n+            return vec![];\n+        }\n+    }\n+\n+    let mut symbols = reachable.to_vec();\n \n     // If we're producing anything other than a dylib then the `reachable` array\n     // above is the exhaustive set of symbols we should be exporting.\n@@ -409,20 +454,19 @@ fn exported_symbols(sess: &Session,\n         return symbols\n     }\n \n-    let cstore = &sess.cstore;\n-    let formats = sess.dependency_formats.borrow();\n-    let upstream_symbols = formats[&crate_type].iter();\n-    symbols.extend(upstream_symbols.enumerate().filter_map(|(i, f)| {\n+    let cstore = &scx.sess().cstore;\n+    let formats = scx.sess().dependency_formats.borrow();\n+    let deps = formats[&crate_type].iter();\n+    symbols.extend(deps.enumerate().filter_map(|(i, f)| {\n         if *f == Linkage::Static {\n             Some((i + 1) as ast::CrateNum)\n         } else {\n             None\n         }\n     }).flat_map(|cnum| {\n         cstore.reachable_ids(cnum)\n-    }).map(|did| {\n-        cstore.item_symbol(did)\n+    }).map(|did| -> String {\n+        Instance::mono(scx, did).symbol_name(scx)\n     }));\n-\n-    return symbols\n+    symbols\n }"}, {"sha": "170c8f75b5056c5ab9054bd7562623a197fabea4", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 97, "deletions": 70, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -97,17 +97,19 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use common::{CrateContext, gensym_name};\n+use common::{CrateContext, SharedCrateContext, gensym_name};\n use monomorphize::Instance;\n use util::sha2::{Digest, Sha256};\n \n-use rustc::middle::cstore;\n+use rustc::middle::{cstore, weak_lang_items};\n use rustc::hir::def_id::DefId;\n+use rustc::hir::map as hir_map;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n-use rustc::ty::item_path::{ItemPathBuffer, RootMode};\n+use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::hir::map::definitions::{DefPath, DefPathData};\n \n use std::fmt::Write;\n+use syntax::attr;\n use syntax::parse::token::{self, InternedString};\n use serialize::hex::ToHex;\n \n@@ -116,10 +118,14 @@ pub fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) ->\n     def_path_to_string(tcx, &def_path)\n }\n \n-pub fn def_path_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_path: &DefPath) -> String {\n+fn def_path_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_path: &DefPath) -> String {\n     let mut s = String::with_capacity(def_path.data.len() * 16);\n \n-    s.push_str(&tcx.crate_name(def_path.krate));\n+    if def_path.krate == cstore::LOCAL_CRATE {\n+        s.push_str(&tcx.crate_name(def_path.krate));\n+    } else {\n+        s.push_str(&tcx.sess.cstore.original_crate_name(def_path.krate));\n+    }\n     s.push_str(\"/\");\n     s.push_str(&tcx.crate_disambiguator(def_path.krate));\n \n@@ -134,7 +140,7 @@ pub fn def_path_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_path: &DefP\n     s\n }\n \n-fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n                              // path to the item this name is for\n                              def_path: &DefPath,\n@@ -152,9 +158,9 @@ fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"get_symbol_hash(def_path={:?}, parameters={:?})\",\n            def_path, parameters);\n \n-    let tcx = ccx.tcx();\n+    let tcx = scx.tcx();\n \n-    let mut hash_state = ccx.symbol_hasher().borrow_mut();\n+    let mut hash_state = scx.symbol_hasher().borrow_mut();\n \n     hash_state.reset();\n \n@@ -187,66 +193,100 @@ fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn exported_name_with_opt_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                           instance: &Instance<'tcx>,\n-                                           suffix: Option<&str>)\n-                                           -> String {\n-    let &Instance { def: mut def_id, ref substs } = instance;\n+impl<'a, 'tcx> Instance<'tcx> {\n+    pub fn symbol_name(self, scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+        let Instance { def: def_id, ref substs } = self;\n+\n+        debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n+               def_id, substs);\n \n-    debug!(\"exported_name_with_opt_suffix(def_id={:?}, substs={:?}, suffix={:?})\",\n-           def_id, substs, suffix);\n+        let node_id = scx.tcx().map.as_local_node_id(def_id);\n \n-    if let Some(node_id) = ccx.tcx().map.as_local_node_id(def_id) {\n-        if let Some(&src_def_id) = ccx.external_srcs().borrow().get(&node_id) {\n-            def_id = src_def_id;\n+        if let Some(id) = node_id {\n+            if scx.sess().plugin_registrar_fn.get() == Some(id) {\n+                let svh = &scx.link_meta().crate_hash;\n+                let idx = def_id.index;\n+                return scx.sess().generate_plugin_registrar_symbol(svh, idx);\n+            }\n         }\n-    }\n \n-    let def_path = ccx.tcx().def_path(def_id);\n-    assert_eq!(def_path.krate, def_id.krate);\n-\n-    // We want to compute the \"type\" of this item. Unfortunately, some\n-    // kinds of items (e.g., closures) don't have an entry in the\n-    // item-type array. So walk back up the find the closest parent\n-    // that DOES have an entry.\n-    let mut ty_def_id = def_id;\n-    let instance_ty;\n-    loop {\n-        let key = ccx.tcx().def_key(ty_def_id);\n-        match key.disambiguated_data.data {\n-            DefPathData::TypeNs(_) |\n-            DefPathData::ValueNs(_) => {\n-                instance_ty = ccx.tcx().lookup_item_type(ty_def_id);\n-                break;\n+        // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n+        let attrs = scx.tcx().get_attrs(def_id);\n+        let is_foreign = if let Some(id) = node_id {\n+            match scx.tcx().map.get(id) {\n+                hir_map::NodeForeignItem(_) => true,\n+                _ => false\n             }\n-            _ => {\n-                // if we're making a symbol for something, there ought\n-                // to be a value or type-def or something in there\n-                // *somewhere*\n-                ty_def_id.index = key.parent.unwrap_or_else(|| {\n-                    bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                         parent\", def_id, ty_def_id);\n-                });\n+        } else {\n+            scx.sess().cstore.is_foreign_item(def_id)\n+        };\n+\n+        if let Some(name) = weak_lang_items::link_name(&attrs) {\n+            return name.to_string();\n+        }\n+\n+        if is_foreign {\n+            if let Some(name) = attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n+                return name.to_string();\n             }\n+            // Don't mangle foreign items.\n+            return scx.tcx().item_name(def_id).as_str().to_string();\n         }\n-    }\n \n-    // Erase regions because they may not be deterministic when hashed\n-    // and should not matter anyhow.\n-    let instance_ty = ccx.tcx().erase_regions(&instance_ty.ty);\n+        if let Some(name) = attr::find_export_name_attr(scx.sess().diagnostic(), &attrs) {\n+            // Use provided name\n+            return name.to_string();\n+        }\n \n-    let hash = get_symbol_hash(ccx, &def_path, instance_ty, substs.types.as_slice());\n+        if attr::contains_name(&attrs, \"no_mangle\") {\n+            // Don't mangle\n+            return scx.tcx().item_name(def_id).as_str().to_string();\n+        }\n \n-    let mut buffer = SymbolPathBuffer {\n-        names: Vec::with_capacity(def_path.data.len())\n-    };\n-    ccx.tcx().push_item_path(&mut buffer, def_id);\n+        let def_path = scx.tcx().def_path(def_id);\n+\n+        // We want to compute the \"type\" of this item. Unfortunately, some\n+        // kinds of items (e.g., closures) don't have an entry in the\n+        // item-type array. So walk back up the find the closest parent\n+        // that DOES have an entry.\n+        let mut ty_def_id = def_id;\n+        let instance_ty;\n+        loop {\n+            let key = scx.tcx().def_key(ty_def_id);\n+            match key.disambiguated_data.data {\n+                DefPathData::TypeNs(_) |\n+                DefPathData::ValueNs(_) => {\n+                    instance_ty = scx.tcx().lookup_item_type(ty_def_id);\n+                    break;\n+                }\n+                _ => {\n+                    // if we're making a symbol for something, there ought\n+                    // to be a value or type-def or something in there\n+                    // *somewhere*\n+                    ty_def_id.index = key.parent.unwrap_or_else(|| {\n+                        bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                             parent\", def_id, ty_def_id);\n+                    });\n+                }\n+            }\n+        }\n \n-    if let Some(suffix) = suffix {\n-        buffer.push(suffix);\n-    }\n+        // Erase regions because they may not be deterministic when hashed\n+        // and should not matter anyhow.\n+        let instance_ty = scx.tcx().erase_regions(&instance_ty.ty);\n+\n+        let hash = get_symbol_hash(scx, &def_path, instance_ty, substs.types.as_slice());\n+\n+        let mut buffer = SymbolPathBuffer {\n+            names: Vec::with_capacity(def_path.data.len())\n+        };\n \n-    mangle(buffer.names.into_iter(), Some(&hash[..]))\n+        item_path::with_forced_absolute_paths(|| {\n+            scx.tcx().push_item_path(&mut buffer, def_id);\n+        });\n+\n+        mangle(buffer.names.into_iter(), Some(&hash[..]))\n+    }\n }\n \n struct SymbolPathBuffer {\n@@ -264,19 +304,6 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     }\n }\n \n-pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               instance: &Instance<'tcx>)\n-                               -> String {\n-    exported_name_with_opt_suffix(ccx, instance, None)\n-}\n-\n-pub fn exported_name_with_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                           instance: &Instance<'tcx>,\n-                                           suffix: &str)\n-                                           -> String {\n-   exported_name_with_opt_suffix(ccx, instance, Some(suffix))\n-}\n-\n /// Only symbols that are invisible outside their compilation unit should use a\n /// name generated by this function.\n pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -289,7 +316,7 @@ pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>\n         data: vec![],\n         krate: cstore::LOCAL_CRATE,\n     };\n-    let hash = get_symbol_hash(ccx, &def_path, t, &[]);\n+    let hash = get_symbol_hash(ccx.shared(), &def_path, t, &[]);\n     mangle(path.iter().cloned(), Some(&hash[..]))\n }\n "}, {"sha": "03e12c1c8a7b04f312c8cb0f9123b80754ed02e6", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 59, "deletions": 90, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -30,14 +30,14 @@ pub use self::ValueOrigin::*;\n use super::CrateTranslation;\n use super::ModuleTranslation;\n \n-use back::{link, symbol_names};\n+use back::link;\n+use back::linker::LinkerInfo;\n use lint;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n use rustc::cfg;\n use rustc::hir::def_id::DefId;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n-use middle::weak_lang_items;\n use rustc::hir::pat_util::simple_name;\n use rustc::ty::subst::{self, Substs};\n use rustc::traits;\n@@ -2344,15 +2344,6 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n             set_global_section(ccx, g, item);\n             update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n         }\n-        hir::ItemForeignMod(ref m) => {\n-            if m.abi == Abi::RustIntrinsic || m.abi == Abi::PlatformIntrinsic {\n-                return;\n-            }\n-            for fi in &m.items {\n-                let lname = imported_name(fi.name, &fi.attrs).to_string();\n-                ccx.item_symbols().borrow_mut().insert(fi.id, lname);\n-            }\n-        }\n         _ => {}\n     }\n }\n@@ -2437,60 +2428,12 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n     }\n }\n \n-pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               instance: Instance<'tcx>,\n-                               attrs: &[ast::Attribute])\n-                               -> String {\n-    let id = ccx.tcx().map.as_local_node_id(instance.def).unwrap();\n-\n-    match ccx.external_srcs().borrow().get(&id) {\n-        Some(&did) => {\n-            let sym = ccx.sess().cstore.item_symbol(did);\n-            debug!(\"found item {} in other crate...\", sym);\n-            return sym;\n-        }\n-        None => {}\n-    }\n-\n-    match attr::find_export_name_attr(ccx.sess().diagnostic(), attrs) {\n-        // Use provided name\n-        Some(name) => name.to_string(),\n-        _ => {\n-            if attr::contains_name(attrs, \"no_mangle\") {\n-                // Don't mangle\n-                ccx.tcx().map.name(id).as_str().to_string()\n-            } else {\n-                match weak_lang_items::link_name(attrs) {\n-                    Some(name) => name.to_string(),\n-                    None => {\n-                        // Usual name mangling\n-                        symbol_names::exported_name(ccx, &instance)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub fn imported_name(name: ast::Name, attrs: &[ast::Attribute]) -> InternedString {\n-    match attr::first_attr_value_str_by_name(attrs, \"link_name\") {\n-        Some(ln) => ln.clone(),\n-        None => match weak_lang_items::link_name(attrs) {\n-            Some(name) => name,\n-            None => name.as_str(),\n-        }\n-    }\n-}\n-\n fn contains_null(s: &str) -> bool {\n     s.bytes().any(|b| b == 0)\n }\n \n-pub fn write_metadata<'a, 'tcx>(cx: &SharedCrateContext<'a, 'tcx>,\n-                                krate: &hir::Crate,\n-                                reachable: &NodeSet,\n-                                mir_map: &MirMap<'tcx>)\n-                                -> Vec<u8> {\n+fn write_metadata(cx: &SharedCrateContext,\n+                  reachable_ids: &NodeSet) -> Vec<u8> {\n     use flate;\n \n     let any_library = cx.sess()\n@@ -2505,11 +2448,10 @@ pub fn write_metadata<'a, 'tcx>(cx: &SharedCrateContext<'a, 'tcx>,\n     let cstore = &cx.tcx().sess.cstore;\n     let metadata = cstore.encode_metadata(cx.tcx(),\n                                           cx.export_map(),\n-                                          cx.item_symbols(),\n                                           cx.link_meta(),\n-                                          reachable,\n-                                          mir_map,\n-                                          krate);\n+                                          reachable_ids,\n+                                          cx.mir_map(),\n+                                          cx.tcx().map.krate());\n     let mut compressed = cstore.metadata_encoding_version().to_vec();\n     compressed.extend_from_slice(&flate::deflate_bytes(&metadata));\n \n@@ -2670,10 +2612,7 @@ fn iter_functions(llmod: llvm::ModuleRef) -> ValueIter {\n /// This list is later used by linkers to determine the set of symbols needed to\n /// be exposed from a dynamic library and it's also encoded into the metadata.\n pub fn filter_reachable_ids(scx: &SharedCrateContext) -> NodeSet {\n-    scx.reachable().iter().map(|x| *x).filter(|id| {\n-        // First, only worry about nodes which have a symbol name\n-        scx.item_symbols().borrow().contains_key(id)\n-    }).filter(|&id| {\n+    scx.reachable().iter().map(|x| *x).filter(|&id| {\n         // Next, we want to ignore some FFI functions that are not exposed from\n         // this crate. Reachable FFI functions can be lumped into two\n         // categories:\n@@ -2691,7 +2630,20 @@ pub fn filter_reachable_ids(scx: &SharedCrateContext) -> NodeSet {\n             hir_map::NodeForeignItem(..) => {\n                 scx.sess().cstore.is_statically_included_foreign_item(id)\n             }\n-            _ => true,\n+\n+            // Only consider nodes that actually have exported symbols.\n+            hir_map::NodeItem(&hir::Item {\n+                node: hir::ItemStatic(..), .. }) |\n+            hir_map::NodeItem(&hir::Item {\n+                node: hir::ItemFn(..), .. }) |\n+            hir_map::NodeImplItem(&hir::ImplItem {\n+                node: hir::ImplItemKind::Method(..), .. }) => {\n+                let def_id = scx.tcx().map.local_def_id(id);\n+                let scheme = scx.tcx().lookup_item_type(def_id);\n+                scheme.generics.types.is_empty()\n+            }\n+\n+            _ => false\n         }\n     }).collect()\n }\n@@ -2733,13 +2685,44 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              check_overflow,\n                                              check_dropflag);\n \n+    let reachable_symbol_ids = filter_reachable_ids(&shared_ccx);\n+\n+    // Translate the metadata.\n+    let metadata = time(tcx.sess.time_passes(), \"write metadata\", || {\n+        write_metadata(&shared_ccx, &reachable_symbol_ids)\n+    });\n+\n+    let metadata_module = ModuleTranslation {\n+        llcx: shared_ccx.metadata_llcx(),\n+        llmod: shared_ccx.metadata_llmod(),\n+    };\n+    let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n+\n     let codegen_units = collect_and_partition_translation_items(&shared_ccx);\n     let codegen_unit_count = codegen_units.len();\n     assert!(tcx.sess.opts.cg.codegen_units == codegen_unit_count ||\n             tcx.sess.opts.debugging_opts.incremental.is_some());\n \n     let crate_context_list = CrateContextList::new(&shared_ccx, codegen_units);\n \n+    let modules = crate_context_list.iter()\n+        .map(|ccx| ModuleTranslation { llcx: ccx.llcx(), llmod: ccx.llmod() })\n+        .collect();\n+\n+    // Skip crate items and just output metadata in -Z no-trans mode.\n+    if tcx.sess.opts.no_trans {\n+        let linker_info = LinkerInfo::new(&shared_ccx, &[]);\n+        return CrateTranslation {\n+            modules: modules,\n+            metadata_module: metadata_module,\n+            link: link_meta,\n+            metadata: metadata,\n+            reachable: vec![],\n+            no_builtins: no_builtins,\n+            linker_info: linker_info\n+        };\n+    }\n+\n     {\n         let ccx = crate_context_list.get_ccx(0);\n \n@@ -2769,13 +2752,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let reachable_symbol_ids = filter_reachable_ids(&shared_ccx);\n-\n-    // Translate the metadata.\n-    let metadata = time(tcx.sess.time_passes(), \"write metadata\", || {\n-        write_metadata(&shared_ccx, krate, &reachable_symbol_ids, mir_map)\n-    });\n-\n     if shared_ccx.sess().trans_stats() {\n         let stats = shared_ccx.stats();\n         println!(\"--- trans stats ---\");\n@@ -2805,13 +2781,10 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let modules = crate_context_list.iter()\n-        .map(|ccx| ModuleTranslation { llcx: ccx.llcx(), llmod: ccx.llmod() })\n-        .collect();\n-\n     let sess = shared_ccx.sess();\n-    let mut reachable_symbols = reachable_symbol_ids.iter().map(|id| {\n-        shared_ccx.item_symbols().borrow()[id].to_string()\n+    let mut reachable_symbols = reachable_symbol_ids.iter().map(|&id| {\n+        let def_id = shared_ccx.tcx().map.local_def_id(id);\n+        Instance::mono(&shared_ccx, def_id).symbol_name(&shared_ccx)\n     }).collect::<Vec<_>>();\n     if sess.entry_fn.borrow().is_some() {\n         reachable_symbols.push(\"main\".to_string());\n@@ -2834,7 +2807,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         reachable_symbols.extend(syms.into_iter().filter(|did| {\n             sess.cstore.is_extern_item(shared_ccx.tcx(), *did)\n         }).map(|did| {\n-            sess.cstore.item_symbol(did)\n+            Instance::mono(&shared_ccx, did).symbol_name(&shared_ccx)\n         }));\n     }\n \n@@ -2848,19 +2821,15 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         create_imps(&crate_context_list);\n     }\n \n-    let metadata_module = ModuleTranslation {\n-        llcx: shared_ccx.metadata_llcx(),\n-        llmod: shared_ccx.metadata_llmod(),\n-    };\n-    let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n-\n+    let linker_info = LinkerInfo::new(&shared_ccx, &reachable_symbols);\n     CrateTranslation {\n         modules: modules,\n         metadata_module: metadata_module,\n         link: link_meta,\n         metadata: metadata,\n         reachable: reachable_symbols,\n         no_builtins: no_builtins,\n+        linker_info: linker_info\n     }\n }\n "}, {"sha": "d7f565a9cd449f03e4dda29dce5fe9b12f3b30c1", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 16, "deletions": 35, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -499,43 +499,20 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return immediate_rvalue(llfn, fn_ptr_ty);\n     }\n \n-    let attrs;\n     let local_id = ccx.tcx().map.as_local_node_id(def_id);\n-    let maybe_node = local_id.and_then(|id| tcx.map.find(id));\n-    let (sym, attrs, local_item) = match maybe_node {\n+    let local_item = match local_id.and_then(|id| tcx.map.find(id)) {\n         Some(hir_map::NodeItem(&hir::Item {\n-            ref attrs, id, span, node: hir::ItemFn(..), ..\n+            span, node: hir::ItemFn(..), ..\n         })) |\n         Some(hir_map::NodeTraitItem(&hir::TraitItem {\n-            ref attrs, id, span, node: hir::MethodTraitItem(_, Some(_)), ..\n+            span, node: hir::MethodTraitItem(_, Some(_)), ..\n         })) |\n         Some(hir_map::NodeImplItem(&hir::ImplItem {\n-            ref attrs, id, span, node: hir::ImplItemKind::Method(..), ..\n+            span, node: hir::ImplItemKind::Method(..), ..\n         })) => {\n-            let sym = exported_name(ccx, instance, attrs);\n-\n-            if declare::get_defined_value(ccx, &sym).is_some() {\n-                ccx.sess().span_fatal(span,\n-                    &format!(\"symbol `{}` is already defined\", sym));\n-            }\n-\n-            (sym, &attrs[..], Some(id))\n-        }\n-\n-        Some(hir_map::NodeForeignItem(&hir::ForeignItem {\n-            ref attrs, name, node: hir::ForeignItemFn(..), ..\n-        })) => {\n-            (imported_name(name, attrs).to_string(), &attrs[..], None)\n-        }\n-\n-        None => {\n-            attrs = ccx.sess().cstore.item_attrs(def_id);\n-            (ccx.sess().cstore.item_symbol(def_id), &attrs[..], None)\n-        }\n-\n-        ref variant => {\n-            bug!(\"get_fn: unexpected variant: {:?}\", variant)\n+            Some(span)\n         }\n+        _ => None\n     };\n \n     // This is subtle and surprising, but sometimes we have to bitcast\n@@ -562,8 +539,16 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n \n+    let sym = instance.symbol_name(ccx.shared());\n     let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n     let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n+        if let Some(span) = local_item {\n+            if declare::get_defined_value(ccx, &sym).is_some() {\n+                ccx.sess().span_fatal(span,\n+                    &format!(\"symbol `{}` is already defined\", sym));\n+            }\n+        }\n+\n         if common::val_ty(llfn) != llptrty {\n             if local_item.is_some() {\n                 bug!(\"symbol `{}` previously declared as {:?}, now wanted as {:?}\",\n@@ -580,7 +565,8 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         assert_eq!(common::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n-        attributes::from_fn_attrs(ccx, attrs, llfn);\n+        let attrs = ccx.tcx().get_attrs(def_id);\n+        attributes::from_fn_attrs(ccx, &attrs, llfn);\n         if local_item.is_some() {\n             // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n             attributes::unwind(llfn, true);\n@@ -589,11 +575,6 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         llfn\n     };\n \n-    // Always insert into item_symbols, in case this item is exported.\n-    if let Some(id) = local_item {\n-        ccx.item_symbols().borrow_mut().insert(id, sym);\n-    }\n-\n     ccx.instances().borrow_mut().insert(instance, llfn);\n \n     immediate_rvalue(llfn, fn_ptr_ty)"}, {"sha": "5e0d34c2a674d5b851c248aee2a19fc02f91d1b6", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -150,7 +150,7 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let symbol = symbol_names::exported_name(ccx, &instance);\n+    let symbol = instance.symbol_name(ccx.shared());\n \n     // Compute the rust-call form of the closure call method.\n     let sig = &tcx.closure_type(closure_id, substs).sig;"}, {"sha": "bd36c18a47ee2252803f48a04b189274809380b9", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use {abi, adt, closure, debuginfo, expr, machine};\n-use base::{self, exported_name, imported_name, push_ctxt};\n+use base::{self, push_ctxt};\n use callee::Callee;\n use collector;\n use trans_item::TransItem;\n@@ -1017,34 +1017,31 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n         return Datum::new(g, ty, Lvalue::new(\"static\"));\n     }\n \n+    let sym = instance.symbol_name(ccx.shared());\n+\n     let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n         let llty = type_of::type_of(ccx, ty);\n         match ccx.tcx().map.get(id) {\n             hir_map::NodeItem(&hir::Item {\n-                ref attrs, span, node: hir::ItemStatic(..), ..\n+                span, node: hir::ItemStatic(..), ..\n             }) => {\n                 // If this static came from an external crate, then\n                 // we need to get the symbol from metadata instead of\n                 // using the current crate's name/version\n                 // information in the hash of the symbol\n-                let sym = exported_name(ccx, instance, attrs);\n                 debug!(\"making {}\", sym);\n \n                 // Create the global before evaluating the initializer;\n                 // this is necessary to allow recursive statics.\n-                let g = declare::define_global(ccx, &sym, llty).unwrap_or_else(|| {\n+                declare::define_global(ccx, &sym, llty).unwrap_or_else(|| {\n                     ccx.sess().span_fatal(span,\n                         &format!(\"symbol `{}` is already defined\", sym))\n-                });\n-\n-                ccx.item_symbols().borrow_mut().insert(id, sym);\n-                g\n+                })\n             }\n \n             hir_map::NodeForeignItem(&hir::ForeignItem {\n-                ref attrs, name, span, node: hir::ForeignItemStatic(..), ..\n+                ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let ident = imported_name(name, attrs);\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -1066,7 +1063,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                     };\n                     unsafe {\n                         // Declare a symbol `foo` with the desired linkage.\n-                        let g1 = declare::declare_global(ccx, &ident, llty2);\n+                        let g1 = declare::declare_global(ccx, &sym, llty2);\n                         llvm::SetLinkage(g1, linkage);\n \n                         // Declare an internal global `extern_with_linkage_foo` which\n@@ -1076,18 +1073,18 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                         // `extern_with_linkage_foo` will instead be initialized to\n                         // zero.\n                         let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n-                        real_name.push_str(&ident);\n+                        real_name.push_str(&sym);\n                         let g2 = declare::define_global(ccx, &real_name, llty).unwrap_or_else(||{\n                             ccx.sess().span_fatal(span,\n-                                &format!(\"symbol `{}` is already defined\", ident))\n+                                &format!(\"symbol `{}` is already defined\", sym))\n                         });\n                         llvm::SetLinkage(g2, llvm::InternalLinkage);\n                         llvm::LLVMSetInitializer(g2, g1);\n                         g2\n                     }\n                 } else {\n                     // Generate an external declaration.\n-                    declare::declare_global(ccx, &ident, llty)\n+                    declare::declare_global(ccx, &sym, llty)\n                 };\n \n                 for attr in attrs {\n@@ -1104,8 +1101,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n     } else {\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n-        let name = ccx.sess().cstore.item_symbol(def_id);\n-        let g = declare::declare_global(ccx, &name, type_of::type_of(ccx, ty));\n+        let g = declare::declare_global(ccx, &sym, type_of::type_of(ccx, ty));\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n         // thread-local attribute locally if it was present remotely. If we"}, {"sha": "1ddcbc79aed5fe0ea04d06c35459ead0c9361ead", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -71,7 +71,6 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n \n     export_map: ExportMap,\n     reachable: NodeSet,\n-    item_symbols: RefCell<NodeMap<String>>,\n     link_meta: LinkMeta,\n     symbol_hasher: RefCell<Sha256>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -395,7 +394,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             metadata_llcx: metadata_llcx,\n             export_map: export_map,\n             reachable: reachable,\n-            item_symbols: RefCell::new(NodeMap()),\n             link_meta: link_meta,\n             symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n@@ -439,10 +437,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.reachable\n     }\n \n-    pub fn item_symbols<'a>(&'a self) -> &'a RefCell<NodeMap<String>> {\n-        &self.item_symbols\n-    }\n-\n     pub fn trait_cache(&self) -> &RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>> {\n         &self.trait_cache\n     }\n@@ -504,6 +498,14 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n                         scheme.generics.regions.map(|_| ty::ReStatic)))\n     }\n \n+    pub fn symbol_hasher(&self) -> &RefCell<Sha256> {\n+        &self.symbol_hasher\n+    }\n+\n+    pub fn mir_map(&self) -> &MirMap<'tcx> {\n+        &self.mir_map\n+    }\n+\n     pub fn metadata_symbol_name(&self) -> String {\n         format!(\"rust_metadata_{}_{}\",\n                 self.link_meta().crate_name,\n@@ -716,10 +718,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.reachable\n     }\n \n-    pub fn item_symbols<'a>(&'a self) -> &'a RefCell<NodeMap<String>> {\n-        &self.shared.item_symbols\n-    }\n-\n     pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n         &self.shared.link_meta\n     }"}, {"sha": "0188a6d54de2dc88ea0e71515d5f850b6fb3d774", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -145,6 +145,7 @@ pub struct CrateTranslation {\n     pub metadata: Vec<u8>,\n     pub reachable: Vec<String>,\n     pub no_builtins: bool,\n+    pub linker_info: back::linker::LinkerInfo\n }\n \n __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }"}, {"sha": "b0f8edac0a623ab85ba6455023dc6f722f910952", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::symbol_names;\n use llvm::ValueRef;\n use llvm;\n use rustc::hir::def_id::DefId;\n@@ -88,7 +87,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         monomorphizing.insert(fn_id, depth + 1);\n     }\n \n-    let symbol = symbol_names::exported_name(ccx, &instance);\n+    let symbol = instance.symbol_name(ccx.shared());\n \n     debug!(\"monomorphize_fn mangled to {}\", symbol);\n     assert!(declare::get_defined_value(ccx, &symbol).is_none());"}, {"sha": "11e9e9f3204a28a3b9e0860e3434596a9dbfcf61", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -14,7 +14,6 @@\n //! item-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n-use back::symbol_names;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor};\n use syntax::ast;\n@@ -53,7 +52,7 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n                 let instance = Instance::mono(self.ccx.shared(), def_id);\n-                let name = symbol_names::exported_name(self.ccx, &instance);\n+                let name = instance.symbol_name(self.ccx.shared());\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {\n                 let path = tcx.item_path_str(def_id);"}, {"sha": "93fa48b880fdf9a599263134a3eb5a78c7fae8dc", "filename": "src/test/compile-fail/symbol-names/impl1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Ftest%2Fcompile-fail%2Fsymbol-names%2Fimpl1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Ftest%2Fcompile-fail%2Fsymbol-names%2Fimpl1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsymbol-names%2Fimpl1.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -25,7 +25,7 @@ mod bar {\n     use foo::Foo;\n \n     impl Foo {\n-        #[rustc_symbol_name] //~ ERROR _ZN5impl13bar26_$LT$impl$u20$foo..Foo$GT$3baz\n+        #[rustc_symbol_name] //~ ERROR _ZN5impl13bar33_$LT$impl$u20$impl1..foo..Foo$GT$3baz\n         #[rustc_item_path] //~ ERROR item-path(bar::<impl foo::Foo>::baz)\n         fn baz() { }\n     }"}, {"sha": "4040b55ff98cbf094cd273a686844ad2d2c14dea", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5229e0efb34f924346febcfe158973486dabdf83/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5229e0efb34f924346febcfe158973486dabdf83/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=5229e0efb34f924346febcfe158973486dabdf83", "patch": "@@ -371,9 +371,16 @@ actual:\\n\\\n         } else {\n             &*self.config.target\n         };\n+\n+        let out_dir = self.output_base_name().with_extension(\"pretty-out\");\n+        let _ = fs::remove_dir_all(&out_dir);\n+        self.create_dir_racy(&out_dir);\n+\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let mut args = vec!(\"-\".to_owned(),\n                             \"-Zno-trans\".to_owned(),\n+                            \"--out-dir\".to_owned(),\n+                            out_dir.to_str().unwrap().to_owned(),\n                             format!(\"--target={}\", target),\n                             \"-L\".to_owned(),\n                             self.config.build_base.to_str().unwrap().to_owned(),"}]}