{"sha": "fd616f01705ddc580948279cb22f1f69b753acf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNjE2ZjAxNzA1ZGRjNTgwOTQ4Mjc5Y2IyMmYxZjY5Yjc1M2FjZjQ=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-18T02:47:18Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-18T04:54:45Z"}, "message": "Rollup merge of #54933 - ljedrz:cleanup_codegen_llvm/misc, r=varkor\n\nCleanup the rest of codegen_llvm\n\n- improve common patterns\n- convert string literals with `to_owned`\n- remove explicit `return`s\n- whitespace & formatting improvements", "tree": {"sha": "73db5972d210860718a25b635d83349a34b624aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73db5972d210860718a25b635d83349a34b624aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd616f01705ddc580948279cb22f1f69b753acf4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlvIEhUACgkQ/vbIBR0O\nATwnJQ/7BqG46lcXa95V/G01kK+RmS2TC0AOSARl3Uz+zxKo6ymmo9Elh0Fv7r0Q\nD7TmpkLcTcT0BiLdxNRn4pJFrTiGrqQ8/1kdh57fTgX62A5XDpyeFTc9hBihF1MV\nt51lUl439id/bs+PaySzcOulYGkFqTfcyIsNQtL7MHPRJQWcFxpXHk/S+jGvSExI\ndv2N5tlvnGQCyHlKJI7FPw/CphLWJi3adAm0ngvHjAifznw5zwCB0E+YT6I/q7Is\nzCId7WNtrRYltFIXFwQcKqDeEyy4AJV7o8cWmMVx/32X2ePKWhLU0C9CyyBkwALJ\nliiq1IPluKH798LVwDuFErqt0L+mftI0JMtsjcr86iTili2/0QZ4Lk7PqFp3wWNk\nItJbND9Bz+dZy92pkT6eAUKM6k8WJ4sBSlKxUrBiWkp7fy1cOnVdGDxKExi9vpmd\nsjKBLanalwqjKRRwNZsfb82OYOIsE7xNfF3p5wX/4A/oLSmRIBGVAa7Tycu/78mk\ngiC7a7KPnyknKU3uqjKTH4Yw4S8EPyhKIWbX8O8b5d6vaK09k1v4nWOSeY/kVn0Q\nqQxZkW2h5gI9g6P8tzKzxWPlBbTf8N5p4u8CJYh5CNF3VMbmlI5DW/rkri/TEMXe\nvwmgVW5K1b6JM8t2Z3dETiKkwE/oUtpKEtMY2ZlgVeD0/1G9Pr8=\n=Zpm+\n-----END PGP SIGNATURE-----", "payload": "tree 73db5972d210860718a25b635d83349a34b624aa\nparent e4ac4478514779d956cbc51068ec2d3207083bfa\nparent 24b74b27443192f6d440be10f7aa0617d8003fab\nauthor kennytm <kennytm@gmail.com> 1539830838 +0800\ncommitter kennytm <kennytm@gmail.com> 1539838485 +0800\n\nRollup merge of #54933 - ljedrz:cleanup_codegen_llvm/misc, r=varkor\n\nCleanup the rest of codegen_llvm\n\n- improve common patterns\n- convert string literals with `to_owned`\n- remove explicit `return`s\n- whitespace & formatting improvements\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd616f01705ddc580948279cb22f1f69b753acf4", "html_url": "https://github.com/rust-lang/rust/commit/fd616f01705ddc580948279cb22f1f69b753acf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd616f01705ddc580948279cb22f1f69b753acf4/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4ac4478514779d956cbc51068ec2d3207083bfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4ac4478514779d956cbc51068ec2d3207083bfa", "html_url": "https://github.com/rust-lang/rust/commit/e4ac4478514779d956cbc51068ec2d3207083bfa"}, {"sha": "24b74b27443192f6d440be10f7aa0617d8003fab", "url": "https://api.github.com/repos/rust-lang/rust/commits/24b74b27443192f6d440be10f7aa0617d8003fab", "html_url": "https://github.com/rust-lang/rust/commit/24b74b27443192f6d440be10f7aa0617d8003fab"}], "stats": {"total": 171, "additions": 83, "deletions": 88}, "files": [{"sha": "56352ae963f20ab4d1febe92224d51cf80767c5e", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=fd616f01705ddc580948279cb22f1f69b753acf4", "patch": "@@ -37,7 +37,7 @@ pub struct MirDebugScope<'ll> {\n \n impl MirDebugScope<'ll> {\n     pub fn is_valid(&self) -> bool {\n-        !self.scope_metadata.is_none()\n+        self.scope_metadata.is_some()\n     }\n }\n "}, {"sha": "f5e5287cd42c5409741715fe23b6bb5ac6c2bc28", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=fd616f01705ddc580948279cb22f1f69b753acf4", "patch": "@@ -163,10 +163,10 @@ impl TypeMap<'ll, 'tcx> {\n     fn get_unique_type_id_of_type<'a>(&mut self, cx: &CodegenCx<'a, 'tcx>,\n                                       type_: Ty<'tcx>) -> UniqueTypeId {\n         // Let's see if we already have something in the cache\n-        match self.type_to_unique_id.get(&type_).cloned() {\n-            Some(unique_type_id) => return unique_type_id,\n-            None => { /* generate one */}\n-        };\n+        if let Some(unique_type_id) = self.type_to_unique_id.get(&type_).cloned() {\n+            return unique_type_id;\n+        }\n+        // if not, generate one\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n@@ -286,11 +286,11 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n // unique id can be found in the type map\n macro_rules! return_if_metadata_created_in_meantime {\n     ($cx: expr, $unique_type_id: expr) => (\n-        match debug_context($cx).type_map\n-                                .borrow()\n-                                .find_metadata_for_unique_id($unique_type_id) {\n-            Some(metadata) => return MetadataCreationResult::new(metadata, true),\n-            None => { /* proceed normally */ }\n+        if let Some(metadata) = debug_context($cx).type_map\n+            .borrow()\n+            .find_metadata_for_unique_id($unique_type_id)\n+        {\n+            return MetadataCreationResult::new(metadata, true);\n         }\n     )\n }\n@@ -352,15 +352,15 @@ fn vec_slice_metadata(\n \n     let member_descriptions = vec![\n         MemberDescription {\n-            name: \"data_ptr\".to_string(),\n+            name: \"data_ptr\".to_owned(),\n             type_metadata: data_ptr_metadata,\n             offset: Size::ZERO,\n             size: pointer_size,\n             align: pointer_align,\n             flags: DIFlags::FlagZero,\n         },\n         MemberDescription {\n-            name: \"length\".to_string(),\n+            name: \"length\".to_owned(),\n             type_metadata: type_metadata(cx, cx.tcx.types.usize, span),\n             offset: pointer_size,\n             size: usize_size,\n@@ -458,7 +458,7 @@ fn trait_pointer_metadata(\n     let vtable_field = layout.field(cx, 1);\n     let member_descriptions = vec![\n         MemberDescription {\n-            name: \"pointer\".to_string(),\n+            name: \"pointer\".to_owned(),\n             type_metadata: type_metadata(cx,\n                 cx.tcx.mk_mut_ptr(cx.tcx.types.u8),\n                 syntax_pos::DUMMY_SP),\n@@ -468,7 +468,7 @@ fn trait_pointer_metadata(\n             flags: DIFlags::FlagArtificial,\n         },\n         MemberDescription {\n-            name: \"vtable\".to_string(),\n+            name: \"vtable\".to_owned(),\n             type_metadata: type_metadata(cx, vtable_field.ty, syntax_pos::DUMMY_SP),\n             offset: layout.fields.offset(1),\n             size: vtable_field.size,\n@@ -543,12 +543,12 @@ pub fn type_metadata(\n             _ => {\n                 let pointee_metadata = type_metadata(cx, ty, usage_site_span);\n \n-                match debug_context(cx).type_map\n-                                        .borrow()\n-                                        .find_metadata_for_unique_id(unique_type_id) {\n-                    Some(metadata) => return Err(metadata),\n-                    None => { /* proceed normally */ }\n-                };\n+                if let Some(metadata) = debug_context(cx).type_map\n+                    .borrow()\n+                    .find_metadata_for_unique_id(unique_type_id)\n+                {\n+                    return Err(metadata);\n+                }\n \n                 Ok(MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n                    false))\n@@ -577,12 +577,12 @@ pub fn type_metadata(\n         }\n         ty::Dynamic(..) => {\n             MetadataCreationResult::new(\n-                        trait_pointer_metadata(cx, t, None, unique_type_id),\n-            false)\n+                trait_pointer_metadata(cx, t, None, unique_type_id),\n+                false)\n         }\n         ty::Foreign(..) => {\n             MetadataCreationResult::new(\n-                        foreign_type_metadata(cx, t, unique_type_id),\n+            foreign_type_metadata(cx, t, unique_type_id),\n             false)\n         }\n         ty::RawPtr(ty::TypeAndMut{ty, ..}) |\n@@ -603,12 +603,12 @@ pub fn type_metadata(\n                                                        unique_type_id,\n                                                        t.fn_sig(cx.tcx),\n                                                        usage_site_span).metadata;\n-            match debug_context(cx).type_map\n-                                   .borrow()\n-                                   .find_metadata_for_unique_id(unique_type_id) {\n-                Some(metadata) => return metadata,\n-                None => { /* proceed normally */ }\n-            };\n+            if let Some(metadata) = debug_context(cx).type_map\n+               .borrow()\n+               .find_metadata_for_unique_id(unique_type_id)\n+            {\n+                return metadata;\n+            }\n \n             // This is actually a function pointer, so wrap it in pointer DI\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n@@ -641,16 +641,16 @@ pub fn type_metadata(\n             }\n             AdtKind::Union => {\n                 prepare_union_metadata(cx,\n-                                    t,\n-                                    unique_type_id,\n-                                    usage_site_span).finalize(cx)\n+                                       t,\n+                                       unique_type_id,\n+                                       usage_site_span).finalize(cx)\n             }\n             AdtKind::Enum => {\n                 prepare_enum_metadata(cx,\n-                                    t,\n-                                    def.did,\n-                                    unique_type_id,\n-                                    usage_site_span).finalize(cx)\n+                                      t,\n+                                      def.did,\n+                                      unique_type_id,\n+                                      usage_site_span).finalize(cx)\n             }\n         },\n         ty::Tuple(ref elements) => {\n@@ -938,7 +938,7 @@ enum MemberDescriptionFactory<'ll, 'tcx> {\n \n impl MemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         match *self {\n             StructMDF(ref this) => {\n                 this.create_member_descriptions(cx)\n@@ -972,7 +972,7 @@ struct StructMemberDescriptionFactory<'tcx> {\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let name = if self.variant.ctor_kind == CtorKind::Fn {\n@@ -1042,7 +1042,7 @@ struct TupleMemberDescriptionFactory<'tcx> {\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n         self.component_types.iter().enumerate().map(|(i, &component_type)| {\n             let (size, align) = cx.size_and_align_of(component_type);\n@@ -1096,7 +1096,7 @@ struct UnionMemberDescriptionFactory<'tcx> {\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = self.layout.field(cx, i);\n             let (size, align) = field.size_and_align();\n@@ -1165,7 +1165,7 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n         match self.layout.variants {\n             layout::Variants::Single { .. } if adt.variants.is_empty() => vec![],\n@@ -1357,7 +1357,7 @@ fn describe_enum_variant(\n             // We have the layout of an enum variant, we need the layout of the outer enum\n             let enum_layout = cx.layout_of(layout.ty);\n             (Some(enum_layout.fields.offset(0)),\n-             Some((\"RUST$ENUM$DISR\".to_string(), enum_layout.field(cx, 0).ty)))\n+             Some((\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, 0).ty)))\n         }\n         _ => (None, None),\n     };\n@@ -1471,9 +1471,8 @@ fn prepare_enum_metadata(\n         }\n     };\n \n-    match (&layout.abi, discriminant_type_metadata) {\n-        (&layout::Abi::Scalar(_), Some(discr)) => return FinalMetadata(discr),\n-        _ => {}\n+    if let (&layout::Abi::Scalar(_), Some(discr)) = (&layout.abi, discriminant_type_metadata) {\n+        return FinalMetadata(discr);\n     }\n \n     let (enum_type_size, enum_type_align) = layout.size_and_align();\n@@ -1546,7 +1545,7 @@ fn composite_type_metadata(\n                                   composite_type_metadata,\n                                   member_descriptions);\n \n-    return composite_type_metadata;\n+    composite_type_metadata\n }\n \n fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n@@ -1634,7 +1633,7 @@ fn create_struct_stub(\n             unique_type_id.as_ptr())\n     };\n \n-    return metadata_stub;\n+    metadata_stub\n }\n \n fn create_union_stub(\n@@ -1670,7 +1669,7 @@ fn create_union_stub(\n             unique_type_id.as_ptr())\n     };\n \n-    return metadata_stub;\n+    metadata_stub\n }\n \n /// Creates debug information for the given global variable."}, {"sha": "acb79d6f568cc5cb6fa1a9abc394547ddf3e6367", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=fd616f01705ddc580948279cb22f1f69b753acf4", "patch": "@@ -271,16 +271,14 @@ pub fn create_function_debug_context(\n     let mut flags = DIFlags::FlagPrototyped;\n \n     let local_id = cx.tcx.hir.as_local_node_id(def_id);\n-    match *cx.sess().entry_fn.borrow() {\n-        Some((id, _, _)) => {\n-            if local_id == Some(id) {\n-                flags = flags | DIFlags::FlagMainSubprogram;\n-            }\n+    if let Some((id, _, _)) = *cx.sess().entry_fn.borrow() {\n+        if local_id == Some(id) {\n+            flags |= DIFlags::FlagMainSubprogram;\n         }\n-        None => {}\n-    };\n+    }\n+\n     if cx.layout_of(sig.output()).abi.is_uninhabited() {\n-        flags = flags | DIFlags::FlagNoReturn;\n+        flags |= DIFlags::FlagNoReturn;\n     }\n \n     let fn_metadata = unsafe {\n@@ -371,7 +369,7 @@ pub fn create_function_debug_context(\n             }\n         }\n \n-        return create_DIArray(DIB(cx), &signature[..]);\n+        create_DIArray(DIB(cx), &signature[..])\n     }\n \n     fn get_template_parameters(\n@@ -428,7 +426,7 @@ pub fn create_function_debug_context(\n             vec![]\n         };\n \n-        return create_DIArray(DIB(cx), &template_params[..]);\n+        create_DIArray(DIB(cx), &template_params[..])\n     }\n \n     fn get_parameter_names(cx: &CodegenCx,"}, {"sha": "60ebcb888166ff96bb0193f05edf153b7551d9c5", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=fd616f01705ddc580948279cb22f1f69b753acf4", "patch": "@@ -56,11 +56,8 @@ pub fn set_source_location(\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is codegened.\n pub fn start_emitting_source_locations(dbg_context: &FunctionDebugContext<'ll>) {\n-    match *dbg_context {\n-        FunctionDebugContext::RegularContext(ref data) => {\n-            data.source_locations_enabled.set(true)\n-        },\n-        _ => { /* safe to ignore */ }\n+    if let FunctionDebugContext::RegularContext(ref data) = *dbg_context {\n+        data.source_locations_enabled.set(true);\n     }\n }\n "}, {"sha": "f5abb527e430fa91c41a6ce4f6c12c9c3a9b21d1", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=fd616f01705ddc580948279cb22f1f69b753acf4", "patch": "@@ -177,7 +177,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::GeneratorWitness(..) |\n         ty::Param(_) => {\n             bug!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {:?}\", t);\n+                  unexpected type: {:?}\", t);\n         }\n     }\n "}, {"sha": "e0a9f31e508ba2f0cac91a8ca32c03d481146eab", "filename": "src/librustc_codegen_llvm/llvm/archive_ro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs?ref=fd616f01705ddc580948279cb22f1f69b753acf4", "patch": "@@ -40,7 +40,7 @@ impl ArchiveRO {\n         return unsafe {\n             let s = path2cstr(dst);\n             let ar = super::LLVMRustOpenArchive(s.as_ptr()).ok_or_else(|| {\n-                super::last_error().unwrap_or(\"failed to open archive\".to_string())\n+                super::last_error().unwrap_or(\"failed to open archive\".to_owned())\n             })?;\n             Ok(ArchiveRO { raw: ar })\n         };"}, {"sha": "68e30227185c0ba68c22ca50b705fb6c8d671432", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=fd616f01705ddc580948279cb22f1f69b753acf4", "patch": "@@ -125,10 +125,10 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     this.unreachable_block()\n                 };\n                 let invokeret = bx.invoke(fn_ptr,\n-                                           &llargs,\n-                                           ret_bx,\n-                                           llblock(this, cleanup),\n-                                           cleanup_bundle);\n+                                          &llargs,\n+                                          ret_bx,\n+                                          llblock(this, cleanup),\n+                                          cleanup_bundle);\n                 fn_ty.apply_attrs_callsite(&bx, invokeret);\n \n                 if let Some((ret_dest, target)) = destination {\n@@ -213,7 +213,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 } else {\n                     let (otherwise, targets) = targets.split_last().unwrap();\n                     let switch = bx.switch(discr.immediate(),\n-                                            llblock(self, *otherwise), values.len());\n+                                           llblock(self, *otherwise),\n+                                           values.len());\n                     let switch_llty = bx.cx.layout_of(switch_ty).immediate_llvm_type(bx.cx);\n                     for (&value, target) in values.iter().zip(targets) {\n                         let llval = C_uint_big(switch_llty, value);\n@@ -387,8 +388,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         let msg_str = Symbol::intern(str).as_str();\n                         let msg_str = C_str_slice(bx.cx, msg_str);\n                         let msg_file_line_col = C_struct(bx.cx,\n-                                                     &[msg_str, filename, line, col],\n-                                                     false);\n+                                                         &[msg_str, filename, line, col],\n+                                                         false);\n                         let msg_file_line_col = consts::addr_of(bx.cx,\n                                                                 msg_file_line_col,\n                                                                 align,\n@@ -509,8 +510,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     let msg_str = Symbol::intern(&str).as_str();\n                     let msg_str = C_str_slice(bx.cx, msg_str);\n                     let msg_file_line_col = C_struct(bx.cx,\n-                                                    &[msg_str, filename, line, col],\n-                                                    false);\n+                                                     &[msg_str, filename, line, col],\n+                                                     false);\n                     let msg_file_line_col = consts::addr_of(bx.cx,\n                                                             msg_file_line_col,\n                                                             align,\n@@ -619,7 +620,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n                     let callee_ty = instance.as_ref().unwrap().ty(bx.cx.tcx);\n                     codegen_intrinsic_call(&bx, callee_ty, &fn_ty, &args, dest,\n-                                         terminator.source_info.span);\n+                                           terminator.source_info.span);\n \n                     if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n                         self.store_return(&bx, ret_dest, &fn_ty.ret, dst.llval);\n@@ -756,7 +757,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n                 llval = bx.load(bx.pointercast(llval, ty.llvm_type(bx.cx).ptr_to()),\n-                                 align.min(arg.layout.align));\n+                                align.min(arg.layout.align));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n@@ -778,10 +779,10 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n \n     fn codegen_arguments_untupled(&mut self,\n-                                bx: &Builder<'a, 'll, 'tcx>,\n-                                operand: &mir::Operand<'tcx>,\n-                                llargs: &mut Vec<&'ll Value>,\n-                                args: &[ArgType<'tcx, Ty<'tcx>>]) {\n+                                  bx: &Builder<'a, 'll, 'tcx>,\n+                                  operand: &mir::Operand<'tcx>,\n+                                  llargs: &mut Vec<&'ll Value>,\n+                                  args: &[ArgType<'tcx, Ty<'tcx>>]) {\n         let tuple = self.codegen_operand(bx, operand);\n \n         // Handle both by-ref and immediate tuples.\n@@ -933,8 +934,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n \n     fn codegen_transmute(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n-                       src: &mir::Operand<'tcx>,\n-                       dst: &mir::Place<'tcx>) {\n+                         src: &mir::Operand<'tcx>,\n+                         dst: &mir::Place<'tcx>) {\n         if let mir::Place::Local(index) = *dst {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n@@ -961,8 +962,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n \n     fn codegen_transmute_into(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n-                            src: &mir::Operand<'tcx>,\n-                            dst: PlaceRef<'ll, 'tcx>) {\n+                              src: &mir::Operand<'tcx>,\n+                              dst: PlaceRef<'ll, 'tcx>) {\n         let src = self.codegen_operand(bx, src);\n         let llty = src.layout.llvm_type(bx.cx);\n         let cast_ptr = bx.pointercast(dst.llval, llty.ptr_to());"}, {"sha": "a6e2ccf92e4e3fd416a028c1950679fb0fce14a0", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd616f01705ddc580948279cb22f1f69b753acf4/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=fd616f01705ddc580948279cb22f1f69b753acf4", "patch": "@@ -162,16 +162,16 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     // corresponding to span's containing source scope.  If so, we need to create a DIScope\n     // \"extension\" into that file.\n     fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n-                               -> Option<&'ll DIScope> {\n+                              -> Option<&'ll DIScope> {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n             let cm = self.cx.sess().source_map();\n             let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n             Some(debuginfo::extend_scope_to_file(self.cx,\n-                                            scope_metadata.unwrap(),\n-                                            &cm.lookup_char_pos(pos).file,\n-                                            defining_crate))\n+                                                 scope_metadata.unwrap(),\n+                                                 &cm.lookup_char_pos(pos).file,\n+                                                 defining_crate))\n         } else {\n             scope_metadata\n         }"}]}