{"sha": "18b33579e18a64293063cd5b1efc5061bbc54d07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YjMzNTc5ZTE4YTY0MjkzMDYzY2Q1YjFlZmM1MDYxYmJjNTRkMDc=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-11-01T23:03:45Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-20T10:37:15Z"}, "message": "splitting methods into smaller ones, add docs, better variable naming", "tree": {"sha": "d6c6ae8d6e443cbd9be98e3e80ea89013cdf3ed3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6c6ae8d6e443cbd9be98e3e80ea89013cdf3ed3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18b33579e18a64293063cd5b1efc5061bbc54d07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18b33579e18a64293063cd5b1efc5061bbc54d07", "html_url": "https://github.com/rust-lang/rust/commit/18b33579e18a64293063cd5b1efc5061bbc54d07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18b33579e18a64293063cd5b1efc5061bbc54d07/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5686422e1a327a77bf9a43a91cb9b3a8d2a2637", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5686422e1a327a77bf9a43a91cb9b3a8d2a2637", "html_url": "https://github.com/rust-lang/rust/commit/b5686422e1a327a77bf9a43a91cb9b3a8d2a2637"}], "stats": {"total": 173, "additions": 109, "deletions": 64}, "files": [{"sha": "de9fb7549352c7c69e0b1b2162e4070388128f02", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 65, "deletions": 28, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/18b33579e18a64293063cd5b1efc5061bbc54d07/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18b33579e18a64293063cd5b1efc5061bbc54d07/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=18b33579e18a64293063cd5b1efc5061bbc54d07", "patch": "@@ -61,22 +61,50 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_ref(&self, expr: &hir::Expr, checked_ty: Ty<'tcx>,\n-                 expected: Ty<'tcx>) -> Option<String> {\n-        match (&checked_ty.sty, &expected.sty) {\n-            (&ty::TyRef(_, x_mutability), &ty::TyRef(_, y_mutability)) => {\n+    /// This function is used to determine potential \"simple\" improvements or users' errors and\n+    /// provide them useful help. For example:\n+    ///\n+    /// ```\n+    /// fn some_fn(s: &str) {}\n+    ///\n+    /// let x = \"hey!\".to_owned();\n+    /// some_fn(x); // error\n+    /// ```\n+    ///\n+    /// No need to find every potential function which could make a coercion to transform a\n+    /// `String` into a `&str` since a `&` would do the trick!\n+    ///\n+    /// In addition of this check, it also checks between references mutability state. If the\n+    /// expected is mutable but the provided isn't, maybe we could just say \"Hey, try with\n+    /// `&mut`!\".\n+    fn check_ref(&self,\n+                 expr: &hir::Expr,\n+                 checked_ty: Ty<'tcx>,\n+                 expected: Ty<'tcx>)\n+                 -> Option<String> {\n+        match (&expected.sty, &checked_ty.sty) {\n+            (&ty::TyRef(_, expected_mutability),\n+             &ty::TyRef(_, checked_mutability)) => {\n                 // check if there is a mutability difference\n-                if x_mutability.mutbl == hir::Mutability::MutImmutable &&\n-                   x_mutability.mutbl != y_mutability.mutbl &&\n-                   self.can_sub_types(&x_mutability.ty, y_mutability.ty).is_ok() {\n+                if checked_mutability.mutbl == hir::Mutability::MutImmutable &&\n+                   checked_mutability.mutbl != expected_mutability.mutbl &&\n+                   self.can_sub_types(&checked_mutability.ty,\n+                                      expected_mutability.ty).is_ok() {\n                     if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n                         return Some(format!(\"try with `&mut {}`\", &src.replace(\"&\", \"\")));\n                     }\n                 }\n                 None\n             }\n-            (_, &ty::TyRef(_, mutability)) => {\n-                // check if it can work when put into a ref\n+            (&ty::TyRef(_, mutability), _) => {\n+                // Check if it can work when put into a ref. For example:\n+                //\n+                // ```\n+                // fn bar(x: &mut i32) {}\n+                //\n+                // let x = 0u32;\n+                // bar(&x); // error, expected &mut\n+                // ```\n                 let ref_ty = match mutability.mutbl {\n                     hir::Mutability::MutMutable => self.tcx.mk_mut_ref(\n                                                        self.tcx.mk_region(ty::ReStatic),\n@@ -110,11 +138,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let mode = probe::Mode::MethodCall;\n             let suggestions = if let Some(s) = self.check_ref(expr, checked_ty, expected) {\n                 Some(s)\n-            } else if let Ok(methods) = self.probe_return(syntax_pos::DUMMY_SP,\n-                                                          mode,\n-                                                          expected,\n-                                                          checked_ty,\n-                                                          ast::DUMMY_NODE_ID) {\n+            } else if let Ok(methods) = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n+                                                                   mode,\n+                                                                   expected,\n+                                                                   checked_ty,\n+                                                                   ast::DUMMY_NODE_ID) {\n                 let suggestions: Vec<_> =\n                     methods.iter()\n                            .map(|ref x| {\n@@ -143,29 +171,38 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn format_method_suggestion(&self, method: &ImplOrTraitItem<'tcx>) -> String {\n+        format!(\".{}({})\",\n+                method.name(),\n+                if self.has_not_input_arg(method) {\n+                    \"\"\n+                } else {\n+                    \"...\"\n+                })\n+    }\n+\n+    fn display_suggested_methods(&self, methods: &[Rc<ImplOrTraitItem<'tcx>>]) -> String {\n+        methods.iter()\n+               .take(5)\n+               .map(|method| self.format_method_suggestion(&*method))\n+               .collect::<Vec<String>>()\n+               .join(\"\\n - \")\n+    }\n+\n     fn get_best_match(&self, methods: &[Rc<ImplOrTraitItem<'tcx>>]) -> String {\n-        if methods.len() == 1 {\n-            return format!(\" - {}\", methods[0].name());\n-        }\n-        let no_argument_methods: Vec<&Rc<ImplOrTraitItem<'tcx>>> =\n+        let no_argument_methods: Vec<Rc<ImplOrTraitItem<'tcx>>> =\n             methods.iter()\n                    .filter(|ref x| self.has_not_input_arg(&*x))\n+                   .map(|x| x.clone())\n                    .collect();\n         if no_argument_methods.len() > 0 {\n-            no_argument_methods.iter()\n-                               .take(5)\n-                               .map(|method| format!(\".{}()\", method.name()))\n-                               .collect::<Vec<String>>()\n-                               .join(\"\\n - \")\n+            self.display_suggested_methods(&no_argument_methods)\n         } else {\n-            methods.iter()\n-                   .take(5)\n-                   .map(|method| format!(\".{}()\", method.name()))\n-                   .collect::<Vec<String>>()\n-                   .join(\"\\n - \")\n+            self.display_suggested_methods(&methods)\n         }\n     }\n \n+    // This function checks if the method isn't static and takes other arguments than `self`.\n     fn has_not_input_arg(&self, method: &ImplOrTraitItem<'tcx>) -> bool {\n         match *method {\n             ImplOrTraitItem::MethodTraitItem(ref x) => {"}, {"sha": "968cc242c601a090d8bf4177d0e9f09ef1020969", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18b33579e18a64293063cd5b1efc5061bbc54d07/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18b33579e18a64293063cd5b1efc5061bbc54d07/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=18b33579e18a64293063cd5b1efc5061bbc54d07", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          allow_private: bool)\n                          -> bool {\n         let mode = probe::Mode::MethodCall;\n-        match self.probe_method(span, mode, method_name, self_ty, call_expr_id) {\n+        match self.probe_for_name(span, mode, method_name, self_ty, call_expr_id) {\n             Ok(..) => true,\n             Err(NoMatch(..)) => false,\n             Err(Ambiguity(..)) => true,\n@@ -130,7 +130,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mode = probe::Mode::MethodCall;\n         let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n-        let pick = self.probe_method(span, mode, method_name, self_ty, call_expr.id)?.remove(0);\n+        let pick = self.probe_for_name(span, mode, method_name, self_ty, call_expr.id)?.remove(0);\n \n         if let Some(import_id) = pick.import_id {\n             self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n@@ -328,7 +328,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         expr_id: ast::NodeId)\n                         -> Result<Def, MethodError<'tcx>> {\n         let mode = probe::Mode::Path;\n-        let picks = self.probe_method(span, mode, method_name, self_ty, expr_id)?;\n+        let picks = self.probe_for_name(span, mode, method_name, self_ty, expr_id)?;\n         let pick = &picks[0];\n \n         if let Some(import_id) = pick.import_id {"}, {"sha": "4558aa5b2b542544b15e559e5c00b0f8d7cf7d15", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/18b33579e18a64293063cd5b1efc5061bbc54d07/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18b33579e18a64293063cd5b1efc5061bbc54d07/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=18b33579e18a64293063cd5b1efc5061bbc54d07", "patch": "@@ -150,41 +150,41 @@ pub enum Mode {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn probe_return(&self,\n-                        span: Span,\n-                        mode: Mode,\n-                        return_type: Ty<'tcx>,\n-                        self_ty: Ty<'tcx>,\n-                        scope_expr_id: ast::NodeId)\n-                        -> PickResult<'tcx> {\n+    pub fn probe_for_return_type(&self,\n+                                 span: Span,\n+                                 mode: Mode,\n+                                 return_type: Ty<'tcx>,\n+                                 self_ty: Ty<'tcx>,\n+                                 scope_expr_id: ast::NodeId)\n+                                 -> PickResult<'tcx> {\n         debug!(\"probe(self_ty={:?}, return_type={}, scope_expr_id={})\",\n                self_ty,\n                return_type,\n                scope_expr_id);\n-        self._probe(span, mode, LookingFor::ReturnType(return_type), self_ty, scope_expr_id)\n+        self.probe_for(span, mode, LookingFor::ReturnType(return_type), self_ty, scope_expr_id)\n     }\n \n-    pub fn probe_method(&self,\n-                        span: Span,\n-                        mode: Mode,\n-                        item_name: ast::Name,\n-                        self_ty: Ty<'tcx>,\n-                        scope_expr_id: ast::NodeId)\n-                        -> PickResult<'tcx> {\n+    pub fn probe_for_name(&self,\n+                          span: Span,\n+                          mode: Mode,\n+                          item_name: ast::Name,\n+                          self_ty: Ty<'tcx>,\n+                          scope_expr_id: ast::NodeId)\n+                          -> PickResult<'tcx> {\n         debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n                self_ty,\n                item_name,\n                scope_expr_id);\n-        self._probe(span, mode, LookingFor::MethodName(item_name), self_ty, scope_expr_id)\n+        self.probe_for(span, mode, LookingFor::MethodName(item_name), self_ty, scope_expr_id)\n     }\n \n-    fn _probe(&self,\n-              span: Span,\n-              mode: Mode,\n-              looking_for: LookingFor<'tcx>,\n-              self_ty: Ty<'tcx>,\n-              scope_expr_id: ast::NodeId)\n-              -> PickResult<'tcx> {\n+    fn probe_for(&self,\n+                 span: Span,\n+                 mode: Mode,\n+                 looking_for: LookingFor<'tcx>,\n+                 self_ty: Ty<'tcx>,\n+                 scope_expr_id: ast::NodeId)\n+                 -> PickResult<'tcx> {\n \n         // FIXME(#18741) -- right now, creating the steps involves evaluating the\n         // `*` operator, which registers obligations that then escape into\n@@ -265,6 +265,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let final_ty = match looking_for {\n             &LookingFor::MethodName(_) => autoderef.unambiguous_final_ty(),\n+            // Since ReturnType case tries to coerce the returned type to the\n+            // expected one, we need all the information!\n             &LookingFor::ReturnType(_) => self_ty,\n         };\n         match final_ty.sty {\n@@ -627,10 +629,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         match *method {\n             ty::ImplOrTraitItem::MethodTraitItem(ref x) => {\n                 self.probe(|_| {\n-                    let output = self.replace_late_bound_regions_with_fresh_var(\n-                        self.span, infer::FnCall, &x.fty.sig.output());\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id());\n-                    let output = output.0.subst(self.tcx, substs);\n+                    let output = x.fty.sig.output().subst(self.tcx, substs);\n+                    let (output, _) = self.replace_late_bound_regions_with_fresh_var(\n+                        self.span, infer::FnCall, &output);\n                     self.can_sub_types(output, expected).is_ok()\n                 })\n             }\n@@ -950,10 +952,17 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let steps = self.steps.clone();\n \n         match self.looking_for {\n-            LookingFor::MethodName(_) => steps.iter()\n-                                              .filter_map(|step| self.pick_step(step))\n-                                              .next(),\n+            LookingFor::MethodName(_) => {\n+                // find the first step that works\n+                steps.iter()\n+                     .filter_map(|step| self.pick_step(step))\n+                     .next()\n+            }\n             LookingFor::ReturnType(_) => {\n+                // Normally, we stop at the first step where we find a positive match.\n+                // But when we are scanning for methods with a suitable return type,\n+                // these methods have distinct names and hence may not shadow one another\n+                // (also, this is just for hints, so precision is less important).\n                 let mut ret = Vec::new();\n \n                 for step in steps.iter() {\n@@ -1050,10 +1059,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         match self.looking_for {\n             LookingFor::MethodName(_) => it.nth(0),\n             LookingFor::ReturnType(_) => {\n-                let mut ret = Vec::new();\n-                it.filter_map(|entry| entry.ok())\n-                  .map(|mut v| { ret.append(&mut v); })\n-                  .all(|_| true);\n+                let ret = it.filter_map(|entry| entry.ok())\n+                            .flat_map(|v| v)\n+                            .collect::<Vec<_>>();\n \n                 if ret.len() < 1 {\n                     None"}]}