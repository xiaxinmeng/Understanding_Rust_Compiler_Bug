{"sha": "29f01cd9d2bcef560e165a2d4ff55b2546116e38", "node_id": "C_kwDOAAsO6NoAKDI5ZjAxY2Q5ZDJiY2VmNTYwZTE2NWEyZDRmZjU1YjI1NDYxMTZlMzg", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-06-23T12:10:12Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-06-23T12:38:28Z"}, "message": "Various cleanups\n\n - remove Valid, it serves no purpose and just obscures the diff\n - rename some things\n - don't use is_valid_candidate when searching for impl, it's not necessary", "tree": {"sha": "4ccf4f3a7cc1effcfa4122044b43f7772ba02a8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ccf4f3a7cc1effcfa4122044b43f7772ba02a8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29f01cd9d2bcef560e165a2d4ff55b2546116e38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29f01cd9d2bcef560e165a2d4ff55b2546116e38", "html_url": "https://github.com/rust-lang/rust/commit/29f01cd9d2bcef560e165a2d4ff55b2546116e38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29f01cd9d2bcef560e165a2d4ff55b2546116e38/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1064c7513a9cbe8a9d891a8ab20567b6649744d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1064c7513a9cbe8a9d891a8ab20567b6649744d7", "html_url": "https://github.com/rust-lang/rust/commit/1064c7513a9cbe8a9d891a8ab20567b6649744d7"}], "stats": {"total": 267, "additions": 122, "deletions": 145}, "files": [{"sha": "a15514283b5442ffffa1e098544634139f0069ff", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 120, "deletions": 137, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/29f01cd9d2bcef560e165a2d4ff55b2546116e38/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f01cd9d2bcef560e165a2d4ff55b2546116e38/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=29f01cd9d2bcef560e165a2d4ff55b2546116e38", "patch": "@@ -576,30 +576,57 @@ pub(crate) fn iterate_method_candidates<T>(\n     slot\n }\n \n-pub fn lookup_trait_m_for_self_ty(\n+pub fn lookup_impl_method(\n     self_ty: &Ty,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    implied_trait: TraitId,\n+    trait_: TraitId,\n     name: &Name,\n ) -> Option<FunctionId> {\n-    let self_ty_tp = TyFingerprint::for_trait_impl(self_ty)?;\n+    let self_ty_fp = TyFingerprint::for_trait_impl(self_ty)?;\n     let trait_impls = TraitImpls::trait_impls_in_deps_query(db, env.krate);\n-    let impls = trait_impls.for_trait_and_self_ty(implied_trait, self_ty_tp);\n+    let impls = trait_impls.for_trait_and_self_ty(trait_, self_ty_fp);\n     let mut table = InferenceTable::new(db, env.clone());\n-    if let Some(data) = Valid::valid_impl(impls, &mut table, &self_ty) {\n-        for &impl_item in data.items.iter() {\n-            if Valid::is_valid_item(&mut table, Some(name), None, impl_item, self_ty, None) {\n-                match impl_item {\n-                    AssocItemId::FunctionId(f) => {\n-                        return Some(f);\n-                    }\n-                    _ => (),\n-                }\n-            }\n+    find_matching_impl(impls, &mut table, &self_ty).and_then(|data| {\n+        data.items.iter().find_map(|it| match it {\n+            AssocItemId::FunctionId(f) => (db.function_data(*f).name == *name).then_some(*f),\n+            _ => None,\n+        })\n+    })\n+}\n+\n+fn find_matching_impl(\n+    mut impls: impl Iterator<Item = ImplId>,\n+    table: &mut InferenceTable,\n+    self_ty: &Ty,\n+) -> Option<Arc<ImplData>> {\n+    let db = table.db;\n+    loop {\n+        let impl_ = impls.next()?;\n+        let r = table.run_in_snapshot(|table| {\n+            let impl_data = db.impl_data(impl_);\n+            let substs =\n+                TyBuilder::subst_for_def(db, impl_).fill_with_inference_vars(table).build();\n+            let impl_ty = db.impl_self_ty(impl_).substitute(Interner, &substs);\n+\n+            table\n+                .unify(self_ty, &impl_ty)\n+                .then(|| {\n+                    let wh_goals =\n+                        crate::chalk_db::convert_where_clauses(db, impl_.into(), &substs)\n+                            .into_iter()\n+                            .map(|b| b.into_well_formed_goal(Interner).cast(Interner));\n+\n+                    let goal = crate::Goal::all(Interner, wh_goals);\n+\n+                    table.try_obligation(goal).map(|_| impl_data)\n+                })\n+                .flatten()\n+        });\n+        if r.is_some() {\n+            break r;\n         }\n     }\n-    None\n }\n \n pub fn iterate_path_candidates(\n@@ -877,7 +904,7 @@ fn iterate_trait_method_candidates(\n         for &(_, item) in data.items.iter() {\n             // Don't pass a `visible_from_module` down to `is_valid_candidate`,\n             // since only inherent methods should be included into visibility checking.\n-            if !Valid::is_valid_item(table, name, receiver_ty, item, self_ty, None) {\n+            if !is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n                 continue;\n             }\n             if !known_implemented {\n@@ -959,14 +986,8 @@ fn iterate_inherent_methods(\n         let impls_for_self_ty = impls.for_self_ty(self_ty);\n         for &impl_def in impls_for_self_ty {\n             for &item in &db.impl_data(impl_def).items {\n-                if !Valid::is_valid_item(\n-                    table,\n-                    name,\n-                    receiver_ty,\n-                    item,\n-                    self_ty,\n-                    visible_from_module,\n-                ) {\n+                if !is_valid_candidate(table, name, receiver_ty, item, self_ty, visible_from_module)\n+                {\n                     continue;\n                 }\n                 callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n@@ -994,130 +1015,92 @@ pub fn resolve_indexing_op(\n     }\n     None\n }\n-struct Valid;\n-impl Valid {\n-    fn valid_impl(\n-        mut impls: impl Iterator<Item = ImplId>,\n-        table: &mut InferenceTable,\n-        self_ty: &Ty,\n-    ) -> Option<Arc<ImplData>> {\n-        let db = table.db;\n-        loop {\n-            let impl_ = impls.next()?;\n-            let r = table.run_in_snapshot(|table| {\n-                let impl_data = db.impl_data(impl_);\n-                let substs =\n-                    TyBuilder::subst_for_def(db, impl_).fill_with_inference_vars(table).build();\n-                let impl_ty = substs\n-                    .apply(db.impl_self_ty(impl_).into_value_and_skipped_binders().0, Interner);\n-\n-                table\n-                    .unify(self_ty, &impl_ty)\n-                    .then(|| {\n-                        let wh_goals =\n-                            crate::chalk_db::convert_where_clauses(db, impl_.into(), &substs)\n-                                .into_iter()\n-                                .map(|b| b.into_well_formed_goal(Interner).cast(Interner));\n-\n-                        let goal = crate::Goal::all(Interner, wh_goals);\n-\n-                        table.try_obligation(goal).map(|_| impl_data)\n-                    })\n-                    .flatten()\n-            });\n-            if r.is_some() {\n-                break r;\n+\n+fn is_valid_candidate(\n+    table: &mut InferenceTable,\n+    name: Option<&Name>,\n+    receiver_ty: Option<&Ty>,\n+    item: AssocItemId,\n+    self_ty: &Ty,\n+    visible_from_module: Option<ModuleId>,\n+) -> bool {\n+    macro_rules! check_that {\n+        ($cond:expr) => {\n+            if !$cond {\n+                return false;\n             }\n-        }\n+        };\n     }\n \n-    fn is_valid_item(\n-        table: &mut InferenceTable,\n-        name: Option<&Name>,\n-        receiver_ty: Option<&Ty>,\n-        item: AssocItemId,\n-        self_ty: &Ty,\n-        visible_from_module: Option<ModuleId>,\n-    ) -> bool {\n-        macro_rules! assert {\n-            ($cond:expr) => {\n-                if !$cond {\n-                    return false;\n+    let db = table.db;\n+    match item {\n+        AssocItemId::FunctionId(m) => {\n+            let data = db.function_data(m);\n+\n+            check_that!(name.map_or(true, |n| n == &data.name));\n+            check_that!(visible_from_module.map_or(true, |from_module| {\n+                let v = db.function_visibility(m).is_visible_from(db.upcast(), from_module);\n+                if !v {\n+                    cov_mark::hit!(autoderef_candidate_not_visible);\n                 }\n-            };\n-        }\n-\n-        let db = table.db;\n-        match item {\n-            AssocItemId::FunctionId(m) => {\n-                let data = db.function_data(m);\n-\n-                assert!(name.map_or(true, |n| n == &data.name));\n-                assert!(visible_from_module.map_or(true, |from_module| {\n-                    let v = db.function_visibility(m).is_visible_from(db.upcast(), from_module);\n-                    if !v {\n-                        cov_mark::hit!(autoderef_candidate_not_visible);\n-                    }\n-                    v\n-                }));\n-\n-                table.run_in_snapshot(|table| {\n-                    let subst =\n-                        TyBuilder::subst_for_def(db, m).fill_with_inference_vars(table).build();\n-                    let expect_self_ty = match m.lookup(db.upcast()).container {\n-                        ItemContainerId::TraitId(_) => {\n-                            subst.at(Interner, 0).assert_ty_ref(Interner).clone()\n-                        }\n-                        ItemContainerId::ImplId(impl_id) => {\n-                            subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n-                        }\n-                        // We should only get called for associated items (impl/trait)\n-                        ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n-                            unreachable!()\n-                        }\n-                    };\n-                    assert!(table.unify(&expect_self_ty, self_ty));\n-                    if let Some(receiver_ty) = receiver_ty {\n-                        assert!(data.has_self_param());\n-\n-                        let sig = db.callable_item_signature(m.into());\n-                        let expected_receiver =\n-                            sig.map(|s| s.params()[0].clone()).substitute(Interner, &subst);\n-\n-                        assert!(table.unify(&receiver_ty, &expected_receiver));\n+                v\n+            }));\n+\n+            table.run_in_snapshot(|table| {\n+                let subst = TyBuilder::subst_for_def(db, m).fill_with_inference_vars(table).build();\n+                let expect_self_ty = match m.lookup(db.upcast()).container {\n+                    ItemContainerId::TraitId(_) => {\n+                        subst.at(Interner, 0).assert_ty_ref(Interner).clone()\n                     }\n-                    true\n-                })\n-            }\n-            AssocItemId::ConstId(c) => {\n-                let data = db.const_data(c);\n-                assert!(receiver_ty.is_none());\n-\n-                assert!(name.map_or(true, |n| data.name.as_ref() == Some(n)));\n-                assert!(visible_from_module.map_or(true, |from_module| {\n-                    let v = db.const_visibility(c).is_visible_from(db.upcast(), from_module);\n-                    if !v {\n-                        cov_mark::hit!(const_candidate_not_visible);\n+                    ItemContainerId::ImplId(impl_id) => {\n+                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n                     }\n-                    v\n-                }));\n-                if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n-                    let self_ty_matches = table.run_in_snapshot(|table| {\n-                        let subst =\n-                            TyBuilder::subst_for_def(db, c).fill_with_inference_vars(table).build();\n-                        let expected_self_ty =\n-                            subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner);\n-                        table.unify(&expected_self_ty, &self_ty)\n-                    });\n-                    if !self_ty_matches {\n-                        cov_mark::hit!(const_candidate_self_type_mismatch);\n-                        return false;\n+                    // We should only get called for associated items (impl/trait)\n+                    ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n+                        unreachable!()\n                     }\n+                };\n+                check_that!(table.unify(&expect_self_ty, self_ty));\n+                if let Some(receiver_ty) = receiver_ty {\n+                    check_that!(data.has_self_param());\n+\n+                    let sig = db.callable_item_signature(m.into());\n+                    let expected_receiver =\n+                        sig.map(|s| s.params()[0].clone()).substitute(Interner, &subst);\n+\n+                    check_that!(table.unify(&receiver_ty, &expected_receiver));\n                 }\n                 true\n+            })\n+        }\n+        AssocItemId::ConstId(c) => {\n+            let data = db.const_data(c);\n+            check_that!(receiver_ty.is_none());\n+\n+            check_that!(name.map_or(true, |n| data.name.as_ref() == Some(n)));\n+            check_that!(visible_from_module.map_or(true, |from_module| {\n+                let v = db.const_visibility(c).is_visible_from(db.upcast(), from_module);\n+                if !v {\n+                    cov_mark::hit!(const_candidate_not_visible);\n+                }\n+                v\n+            }));\n+            if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n+                let self_ty_matches = table.run_in_snapshot(|table| {\n+                    let subst =\n+                        TyBuilder::subst_for_def(db, c).fill_with_inference_vars(table).build();\n+                    let expected_self_ty =\n+                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner);\n+                    table.unify(&expected_self_ty, &self_ty)\n+                });\n+                if !self_ty_matches {\n+                    cov_mark::hit!(const_candidate_self_type_mismatch);\n+                    return false;\n+                }\n             }\n-            _ => false,\n+            true\n         }\n+        _ => false,\n     }\n }\n "}, {"sha": "62bcc9de39f037ae536a5f8be84fd3484a09e88b", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29f01cd9d2bcef560e165a2d4ff55b2546116e38/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29f01cd9d2bcef560e165a2d4ff55b2546116e38/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=29f01cd9d2bcef560e165a2d4ff55b2546116e38", "patch": "@@ -281,7 +281,7 @@ impl SourceAnalyzer {\n             _ => (),\n         };\n         let (func, self_ty) = fun_info?;\n-        let implied_trait = match func.lookup(db.upcast()).container {\n+        let impled_trait = match func.lookup(db.upcast()).container {\n             ItemContainerId::TraitId(trait_id) => trait_id,\n             _ => return None,\n         };\n@@ -293,13 +293,7 @@ impl SourceAnalyzer {\n         );\n \n         let fun_data = db.function_data(func);\n-        method_resolution::lookup_trait_m_for_self_ty(\n-            &self_ty,\n-            db,\n-            trait_env,\n-            implied_trait,\n-            &fun_data.name,\n-        )\n+        method_resolution::lookup_impl_method(&self_ty, db, trait_env, impled_trait, &fun_data.name)\n     }\n \n     pub(crate) fn resolve_field("}]}