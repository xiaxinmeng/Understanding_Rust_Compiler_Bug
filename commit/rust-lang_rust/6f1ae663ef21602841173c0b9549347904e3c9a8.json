{"sha": "6f1ae663ef21602841173c0b9549347904e3c9a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMWFlNjYzZWYyMTYwMjg0MTE3M2MwYjk1NDkzNDc5MDRlM2M5YTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-06T00:17:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-06T00:17:41Z"}, "message": "Auto merge of #38069 - canndrew:empty-sub-patterns-again, r=nikomatsakis\n\nFix handling of empty types in patterns.\n\nFix for #12609.", "tree": {"sha": "c9e0f6e7a02ec761eea205208ca9438453ba371f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9e0f6e7a02ec761eea205208ca9438453ba371f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f1ae663ef21602841173c0b9549347904e3c9a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f1ae663ef21602841173c0b9549347904e3c9a8", "html_url": "https://github.com/rust-lang/rust/commit/6f1ae663ef21602841173c0b9549347904e3c9a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f1ae663ef21602841173c0b9549347904e3c9a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42bed7238534b50178cb2bd275f1153d67cc3ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/42bed7238534b50178cb2bd275f1153d67cc3ece", "html_url": "https://github.com/rust-lang/rust/commit/42bed7238534b50178cb2bd275f1153d67cc3ece"}, {"sha": "275c19d5b6a0f5eceb93e60ee314e73909a12faf", "url": "https://api.github.com/repos/rust-lang/rust/commits/275c19d5b6a0f5eceb93e60ee314e73909a12faf", "html_url": "https://github.com/rust-lang/rust/commit/275c19d5b6a0f5eceb93e60ee314e73909a12faf"}], "stats": {"total": 1472, "additions": 1172, "deletions": 300}, "files": [{"sha": "96fb168581b2169ee141d09a22cf9280c50a4155", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -70,6 +70,12 @@ declare_lint! {\n     \"detects unreachable code paths\"\n }\n \n+declare_lint! {\n+    pub UNREACHABLE_PATTERNS,\n+    Warn,\n+    \"detects unreachable patterns\"\n+}\n+\n declare_lint! {\n     pub WARNINGS,\n     Warn,\n@@ -239,6 +245,7 @@ impl LintPass for HardwiredLints {\n             UNUSED_ASSIGNMENTS,\n             DEAD_CODE,\n             UNREACHABLE_CODE,\n+            UNREACHABLE_PATTERNS,\n             WARNINGS,\n             UNUSED_FEATURES,\n             STABLE_FEATURES,"}, {"sha": "1d0e95245ea2dd31793a14079f3b145b0326b7cb", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -888,6 +888,10 @@ impl<'tcx> Lvalue<'tcx> {\n         self.elem(ProjectionElem::Deref)\n     }\n \n+    pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: usize) -> Lvalue<'tcx> {\n+        self.elem(ProjectionElem::Downcast(adt_def, variant_index))\n+    }\n+\n     pub fn index(self, index: Operand<'tcx>) -> Lvalue<'tcx> {\n         self.elem(ProjectionElem::Index(index))\n     }"}, {"sha": "644df8741e8534a472cde67a54e34782352235df", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -33,6 +33,7 @@ use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n+use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n@@ -459,6 +460,8 @@ pub struct GlobalCtxt<'tcx> {\n     // FIXME dep tracking -- should be harmless enough\n     pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n+    pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, DefIdForest>>,\n+\n     pub lang_items: middle::lang_items::LanguageItems,\n \n     /// Maps from def-id of a type or region parameter to its\n@@ -760,6 +763,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             associated_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n+            inhabitedness_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,\n             inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),"}, {"sha": "16bc65603f1353188b082cf02114d4f45fef31ee", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+use rustc_data_structures::small_vec::SmallVec;\n+use syntax::ast::CRATE_NODE_ID;\n+use ty::context::TyCtxt;\n+use ty::{DefId, DefIdTree};\n+\n+/// Represents a forest of DefIds closed under the ancestor relation. That is,\n+/// if a DefId representing a module is contained in the forest then all\n+/// DefIds defined in that module or submodules are also implicitly contained\n+/// in the forest.\n+///\n+/// This is used to represent a set of modules in which a type is visibly\n+/// uninhabited.\n+#[derive(Clone)]\n+pub struct DefIdForest {\n+    /// The minimal set of DefIds required to represent the whole set.\n+    /// If A and B are DefIds in the DefIdForest, and A is a desecendant\n+    /// of B, then only B will be in root_ids.\n+    /// We use a SmallVec here because (for its use for cacheing inhabitedness)\n+    /// its rare that this will contain even two ids.\n+    root_ids: SmallVec<[DefId; 1]>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> DefIdForest {\n+    /// Create an empty forest.\n+    pub fn empty() -> DefIdForest {\n+        DefIdForest {\n+            root_ids: SmallVec::new(),\n+        }\n+    }\n+\n+    /// Create a forest consisting of a single tree representing the entire\n+    /// crate.\n+    #[inline]\n+    pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest {\n+        let crate_id = tcx.map.local_def_id(CRATE_NODE_ID);\n+        DefIdForest::from_id(crate_id)\n+    }\n+\n+    /// Create a forest containing a DefId and all its descendants.\n+    pub fn from_id(id: DefId) -> DefIdForest {\n+        let mut root_ids = SmallVec::new();\n+        root_ids.push(id);\n+        DefIdForest {\n+            root_ids: root_ids,\n+        }\n+    }\n+\n+    /// Test whether the forest is empty.\n+    pub fn is_empty(&self) -> bool {\n+        self.root_ids.is_empty()\n+    }\n+\n+    /// Test whether the forest conains a given DefId.\n+    pub fn contains(&self,\n+                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    id: DefId) -> bool\n+    {\n+        for root_id in self.root_ids.iter() {\n+            if tcx.is_descendant_of(id, *root_id) {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Calculate the intersection of a collection of forests.\n+    pub fn intersection<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                           iter: I) -> DefIdForest\n+            where I: IntoIterator<Item=DefIdForest>\n+    {\n+        let mut ret = DefIdForest::full(tcx);\n+        let mut next_ret = SmallVec::new();\n+        let mut old_ret: SmallVec<[DefId; 1]> = SmallVec::new();\n+        for next_forest in iter {\n+            for id in ret.root_ids.drain(..) {\n+                if next_forest.contains(tcx, id) {\n+                    next_ret.push(id);\n+                } else {\n+                    old_ret.push(id);\n+                }\n+            }\n+            ret.root_ids.extend(old_ret.drain(..));\n+\n+            for id in next_forest.root_ids {\n+                if ret.contains(tcx, id) {\n+                    next_ret.push(id);\n+                }\n+            }\n+\n+            mem::swap(&mut next_ret, &mut ret.root_ids);\n+            next_ret.drain(..);\n+        }\n+        ret\n+    }\n+\n+    /// Calculate the union of a collection of forests.\n+    pub fn union<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    iter: I) -> DefIdForest\n+            where I: IntoIterator<Item=DefIdForest>\n+    {\n+        let mut ret = DefIdForest::empty();\n+        let mut next_ret = SmallVec::new();\n+        for next_forest in iter {\n+            for id in ret.root_ids.drain(..) {\n+                if !next_forest.contains(tcx, id) {\n+                    next_ret.push(id);\n+                }\n+            }\n+\n+            for id in next_forest.root_ids {\n+                if !next_ret.contains(&id) {\n+                    next_ret.push(id);\n+                }\n+            }\n+\n+            mem::swap(&mut next_ret, &mut ret.root_ids);\n+            next_ret.drain(..);\n+        }\n+        ret\n+    }\n+}\n+"}, {"sha": "c5b75839e99b7dd634703119272b4da0f52783e7", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -0,0 +1,199 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use util::nodemap::FxHashSet;\n+use ty::context::TyCtxt;\n+use ty::{AdtDef, VariantDef, FieldDef, TyS};\n+use ty::{DefId, Substs};\n+use ty::{AdtKind, Visibility};\n+use ty::TypeVariants::*;\n+\n+pub use self::def_id_forest::DefIdForest;\n+\n+mod def_id_forest;\n+\n+// The methods in this module calculate DefIdForests of modules in which a\n+// AdtDef/VariantDef/FieldDef is visibly uninhabited.\n+//\n+// # Example\n+// ```rust\n+// enum Void {}\n+// mod a {\n+//     pub mod b {\n+//         pub struct SecretlyUninhabited {\n+//             _priv: !,\n+//         }\n+//     }\n+// }\n+//\n+// mod c {\n+//     pub struct AlsoSecretlyUninhabited {\n+//         _priv: Void,\n+//     }\n+//     mod d {\n+//     }\n+// }\n+//\n+// struct Foo {\n+//     x: a::b::SecretlyUninhabited,\n+//     y: c::AlsoSecretlyUninhabited,\n+// }\n+// ```\n+// In this code, the type Foo will only be visibly uninhabited inside the\n+// modules b, c and d. Calling uninhabited_from on Foo or its AdtDef will\n+// return the forest of modules {b, c->d} (represented in a DefIdForest by the\n+// set {b, c})\n+//\n+// We need this information for pattern-matching on Foo or types that contain\n+// Foo.\n+//\n+// # Example\n+// ```rust\n+// let foo_result: Result<T, Foo> = ... ;\n+// let Ok(t) = foo_result;\n+// ```\n+// This code should only compile in modules where the uninhabitedness of Foo is\n+// visible.\n+\n+impl<'a, 'gcx, 'tcx> AdtDef {\n+    /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n+    pub fn uninhabited_from(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                substs: &'tcx Substs<'tcx>) -> DefIdForest\n+    {\n+        if !visited.insert((self.did, substs)) {\n+            return DefIdForest::empty();\n+        }\n+\n+        let ret = DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n+            v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n+        }));\n+        visited.remove(&(self.did, substs));\n+        ret\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> VariantDef {\n+    /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n+    pub fn uninhabited_from(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                substs: &'tcx Substs<'tcx>,\n+                adt_kind: AdtKind) -> DefIdForest\n+    {\n+        match adt_kind {\n+            AdtKind::Union => {\n+                DefIdForest::intersection(tcx, self.fields.iter().map(|f| {\n+                    f.uninhabited_from(visited, tcx, substs, false)\n+                }))\n+            },\n+            AdtKind::Struct => {\n+                DefIdForest::union(tcx, self.fields.iter().map(|f| {\n+                    f.uninhabited_from(visited, tcx, substs, false)\n+                }))\n+            },\n+            AdtKind::Enum => {\n+                DefIdForest::union(tcx, self.fields.iter().map(|f| {\n+                    f.uninhabited_from(visited, tcx, substs, true)\n+                }))\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> FieldDef {\n+    /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n+    pub fn uninhabited_from(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                substs: &'tcx Substs<'tcx>,\n+                is_enum: bool) -> DefIdForest\n+    {\n+        let mut data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(visited, tcx);\n+        // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n+        // Visibility::Invisible so we need to override self.vis if we're\n+        // dealing with an enum.\n+        if is_enum {\n+            data_uninhabitedness()\n+        } else {\n+            match self.vis {\n+                Visibility::Invisible => DefIdForest::empty(),\n+                Visibility::Restricted(from) => {\n+                    let forest = DefIdForest::from_id(from);\n+                    let iter = Some(forest).into_iter().chain(Some(data_uninhabitedness()));\n+                    DefIdForest::intersection(tcx, iter)\n+                },\n+                Visibility::Public => data_uninhabitedness(),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n+    /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n+    pub fn uninhabited_from(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n+    {\n+        match tcx.lift_to_global(&self) {\n+            Some(global_ty) => {\n+                {\n+                    let cache = tcx.inhabitedness_cache.borrow();\n+                    if let Some(forest) = cache.get(&global_ty) {\n+                        return forest.clone();\n+                    }\n+                }\n+                let forest = global_ty.uninhabited_from_inner(visited, tcx);\n+                let mut cache = tcx.inhabitedness_cache.borrow_mut();\n+                cache.insert(global_ty, forest.clone());\n+                forest\n+            },\n+            None => {\n+                let forest = self.uninhabited_from_inner(visited, tcx);\n+                forest\n+            },\n+        }\n+    }\n+\n+    fn uninhabited_from_inner(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n+    {\n+        match self.sty {\n+            TyAdt(def, substs) => {\n+                def.uninhabited_from(visited, tcx, substs)\n+            },\n+\n+            TyNever => DefIdForest::full(tcx),\n+            TyTuple(ref tys) => {\n+                DefIdForest::union(tcx, tys.iter().map(|ty| {\n+                    ty.uninhabited_from(visited, tcx)\n+                }))\n+            },\n+            TyArray(ty, len) => {\n+                if len == 0 {\n+                    DefIdForest::empty()\n+                } else {\n+                    ty.uninhabited_from(visited, tcx)\n+                }\n+            }\n+            TyRef(_, ref tm) => tm.ty.uninhabited_from(visited, tcx),\n+\n+            _ => DefIdForest::empty(),\n+        }\n+    }\n+}\n+"}, {"sha": "fa62e893a2875215047b061d4b6324869ac80dca", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 48, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -29,7 +29,7 @@ use ty;\n use ty::subst::{Subst, Substs};\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n-use util::nodemap::{NodeSet, NodeMap, FxHashMap, FxHashSet};\n+use util::nodemap::{NodeSet, NodeMap, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n@@ -78,6 +78,7 @@ pub mod cast;\n pub mod error;\n pub mod fast_reject;\n pub mod fold;\n+pub mod inhabitedness;\n pub mod item_path;\n pub mod layout;\n pub mod _match;\n@@ -226,6 +227,20 @@ pub enum Visibility {\n \n pub trait DefIdTree: Copy {\n     fn parent(self, id: DefId) -> Option<DefId>;\n+\n+    fn is_descendant_of(self, mut descendant: DefId, ancestor: DefId) -> bool {\n+        if descendant.krate != ancestor.krate {\n+            return false;\n+        }\n+\n+        while descendant != ancestor {\n+            match self.parent(descendant) {\n+                Some(parent) => descendant = parent,\n+                None => return false,\n+            }\n+        }\n+        true\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> DefIdTree for TyCtxt<'a, 'gcx, 'tcx> {\n@@ -252,7 +267,7 @@ impl Visibility {\n     }\n \n     /// Returns true if an item with this visibility is accessible from the given block.\n-    pub fn is_accessible_from<T: DefIdTree>(self, mut module: DefId, tree: T) -> bool {\n+    pub fn is_accessible_from<T: DefIdTree>(self, module: DefId, tree: T) -> bool {\n         let restriction = match self {\n             // Public items are visible everywhere.\n             Visibility::Public => return true,\n@@ -263,14 +278,7 @@ impl Visibility {\n             Visibility::Restricted(module) => module,\n         };\n \n-        while module != restriction {\n-            match tree.parent(module) {\n-                Some(parent) => module = parent,\n-                None => return false,\n-            }\n-        }\n-\n-        true\n+        tree.is_descendant_of(module, restriction)\n     }\n \n     /// Returns true if this visibility is at least as accessible as the given visibility\n@@ -1406,20 +1414,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK_VALID)\n     }\n \n-    #[inline]\n-    pub fn is_uninhabited_recurse(&self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  substs: &'tcx Substs<'tcx>) -> bool {\n-        if !visited.insert((self.did, substs)) {\n-            return false;\n-        };\n-        self.variants.iter().all(|v| {\n-            v.is_uninhabited_recurse(visited, block, tcx, substs, self.is_union())\n-        })\n-    }\n-\n     #[inline]\n     pub fn is_struct(&self) -> bool {\n         !self.is_union() && !self.is_enum()\n@@ -1754,36 +1748,12 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     pub fn field_named(&self, name: ast::Name) -> &FieldDef {\n         self.find_field_named(name).unwrap()\n     }\n-\n-    #[inline]\n-    pub fn is_uninhabited_recurse(&self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  substs: &'tcx Substs<'tcx>,\n-                                  is_union: bool) -> bool {\n-        if is_union {\n-            self.fields.iter().all(|f| f.is_uninhabited_recurse(visited, block, tcx, substs))\n-        } else {\n-            self.fields.iter().any(|f| f.is_uninhabited_recurse(visited, block, tcx, substs))\n-        }\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> FieldDef {\n     pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n         tcx.item_type(self.did).subst(tcx, subst)\n     }\n-\n-    #[inline]\n-    pub fn is_uninhabited_recurse(&self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  substs: &'tcx Substs<'tcx>) -> bool {\n-        block.map_or(true, |b| tcx.vis_is_accessible_from(self.vis, b)) &&\n-        self.ty(tcx, substs).is_uninhabited_recurse(visited, block, tcx)\n-    }\n }\n \n /// Records the substitutions used to translate the polytype for an"}, {"sha": "81b0a55841ad839e58547a58565e207dca8af488", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -22,7 +22,7 @@ use std::fmt;\n use std::iter;\n use std::cmp::Ordering;\n use syntax::abi;\n-use syntax::ast::{self, Name, NodeId};\n+use syntax::ast::{self, Name};\n use syntax::symbol::{keywords, InternedString};\n use util::nodemap::FxHashSet;\n \n@@ -979,29 +979,52 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Checks whether a type is uninhabited.\n-    /// If `block` is `Some(id)` it also checks that the uninhabited-ness is visible from `id`.\n-    pub fn is_uninhabited(&self, block: Option<NodeId>, cx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    /// Checks whether a type is visibly uninhabited from a particular module.\n+    /// # Example\n+    /// ```rust\n+    /// enum Void {}\n+    /// mod a {\n+    ///     pub mod b {\n+    ///         pub struct SecretlyUninhabited {\n+    ///             _priv: !,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// mod c {\n+    ///     pub struct AlsoSecretlyUninhabited {\n+    ///         _priv: Void,\n+    ///     }\n+    ///     mod d {\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Foo {\n+    ///     x: a::b::SecretlyUninhabited,\n+    ///     y: c::AlsoSecretlyUninhabited,\n+    /// }\n+    /// ```\n+    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n+    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n+    /// contain `Foo`.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// let foo_result: Result<T, Foo> = ... ;\n+    /// let Ok(t) = foo_result;\n+    /// ```\n+    /// This code should only compile in modules where the uninhabitedness of Foo is\n+    /// visible.\n+    pub fn is_uninhabited_from(&self, module: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         let mut visited = FxHashSet::default();\n-        self.is_uninhabited_recurse(&mut visited, block, cx)\n-    }\n-\n-    pub fn is_uninhabited_recurse(&self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  cx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        match self.sty {\n-            TyAdt(def, substs) => {\n-                def.is_uninhabited_recurse(visited, block, cx, substs)\n-            },\n-\n-            TyNever => true,\n-            TyTuple(ref tys) => tys.iter().any(|ty| ty.is_uninhabited_recurse(visited, block, cx)),\n-            TyArray(ty, len) => len > 0 && ty.is_uninhabited_recurse(visited, block, cx),\n-            TyRef(_, ref tm) => tm.ty.is_uninhabited_recurse(visited, block, cx),\n-\n-            _ => false,\n-        }\n+        let forest = self.uninhabited_from(&mut visited, tcx);\n+\n+        // To check whether this type is uninhabited at all (not just from the\n+        // given node) you could check whether the forest is empty.\n+        // ```\n+        // forest.is_empty()\n+        // ```\n+        forest.contains(tcx, module)\n     }\n \n     pub fn is_primitive(&self) -> bool {"}, {"sha": "f4b3646fce02c02840c0bc1061961273b0c67653", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 206, "deletions": 103, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -17,14 +17,14 @@ use eval::{compare_const_vals};\n \n use rustc_const_math::ConstInt;\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::Idx;\n \n use pattern::{FieldPattern, Pattern, PatternKind};\n use pattern::{PatternFoldable, PatternFolder};\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n \n use rustc::mir::Field;\n use rustc::util::common::ErrorReported;\n@@ -144,37 +144,38 @@ impl<'a, 'tcx> FromIterator<Vec<&'a Pattern<'tcx>>> for Matrix<'a, 'tcx> {\n //NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    /// A wild pattern with an error type - it exists to avoid having to normalize\n-    /// associated types to get field types.\n-    pub wild_pattern: &'a Pattern<'tcx>,\n+    /// The module in which the match occurs. This is necessary for\n+    /// checking inhabited-ness of types because whether a type is (visibly)\n+    /// inhabited can depend on whether it was defined in the current module or\n+    /// not. eg. `struct Foo { _private: ! }` cannot be seen to be empty\n+    /// outside it's module and should not be matchable with an empty match\n+    /// statement.\n+    pub module: DefId,\n     pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n     pub byte_array_map: FxHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     pub fn create_and_enter<F, R>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        module: DefId,\n         f: F) -> R\n         where F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R\n     {\n-        let wild_pattern = Pattern {\n-            ty: tcx.types.err,\n-            span: DUMMY_SP,\n-            kind: box PatternKind::Wild\n-        };\n-\n         let pattern_arena = TypedArena::new();\n \n         f(MatchCheckCtxt {\n             tcx: tcx,\n-            wild_pattern: &wild_pattern,\n+            module: module,\n             pattern_arena: &pattern_arena,\n             byte_array_map: FxHashMap(),\n         })\n     }\n \n     // convert a byte-string pattern to a list of u8 patterns.\n-    fn lower_byte_str_pattern(&mut self, pat: &'a Pattern<'tcx>) -> Vec<&'a Pattern<'tcx>> {\n+    fn lower_byte_str_pattern<'p>(&mut self, pat: &'p Pattern<'tcx>) -> Vec<&'p Pattern<'tcx>>\n+            where 'a: 'p\n+    {\n         let pattern_arena = &*self.pattern_arena;\n         let tcx = self.tcx;\n         self.byte_array_map.entry(pat).or_insert_with(|| {\n@@ -269,8 +270,14 @@ impl<'tcx> Witness<'tcx> {\n         ty: Ty<'tcx>)\n         -> Self\n     {\n-        let arity = constructor_arity(cx, ctor, ty);\n-        self.0.extend(repeat(cx.wild_pattern).take(arity).cloned());\n+        let sub_pattern_tys = constructor_sub_pattern_tys(cx, ctor, ty);\n+        self.0.extend(sub_pattern_tys.into_iter().map(|ty| {\n+            Pattern {\n+                ty: ty,\n+                span: DUMMY_SP,\n+                kind: box PatternKind::Wild,\n+            }\n+        }));\n         self.apply_constructor(cx, ctor, ty)\n     }\n \n@@ -310,10 +317,11 @@ impl<'tcx> Witness<'tcx> {\n                         }\n                     }).collect();\n \n-                    if let ty::TyAdt(adt, _) = ty.sty {\n+                    if let ty::TyAdt(adt, substs) = ty.sty {\n                         if adt.variants.len() > 1 {\n                             PatternKind::Variant {\n                                 adt_def: adt,\n+                                substs: substs,\n                                 variant_index: ctor.variant_index_for_adt(adt),\n                                 subpatterns: pats\n                             }\n@@ -356,51 +364,65 @@ impl<'tcx> Witness<'tcx> {\n     }\n }\n \n-/// Return the set of constructors from the same type as the first column of `matrix`,\n-/// that are matched only by wildcard patterns from that first column.\n-///\n-/// Therefore, if there is some pattern that is unmatched by `matrix`, it will\n-/// still be unmatched if the first constructor is replaced by any of the constructors\n-/// in the return value.\n-fn missing_constructors(cx: &mut MatchCheckCtxt,\n-                        matrix: &Matrix,\n-                        pcx: PatternContext) -> Vec<Constructor> {\n-    let used_constructors: Vec<Constructor> =\n-        matrix.0.iter()\n-        .flat_map(|row| pat_constructors(cx, row[0], pcx).unwrap_or(vec![]))\n-        .collect();\n-    debug!(\"used_constructors = {:?}\", used_constructors);\n-    all_constructors(cx, pcx).into_iter()\n-        .filter(|c| !used_constructors.contains(c))\n-        .collect()\n-}\n-\n /// This determines the set of all possible constructors of a pattern matching\n /// values of type `left_ty`. For vectors, this would normally be an infinite set\n+/// but is instead bounded by the maximum fixed length of slice patterns in\n+/// the column of patterns being analyzed.\n ///\n /// This intentionally does not list ConstantValue specializations for\n /// non-booleans, because we currently assume that there is always a\n /// \"non-standard constant\" that matches. See issue #12483.\n ///\n-/// but is instead bounded by the maximum fixed length of slice patterns in\n-/// the column of patterns being analyzed.\n-fn all_constructors(_cx: &mut MatchCheckCtxt, pcx: PatternContext) -> Vec<Constructor> {\n+/// We make sure to omit constructors that are statically impossible. eg for\n+/// Option<!> we do not include Some(_) in the returned list of constructors.\n+fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                                  pcx: PatternContext<'tcx>) -> Vec<Constructor>\n+{\n+    debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n-        ty::TySlice(_) =>\n-            (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect(),\n-        ty::TyArray(_, length) => vec![Slice(length)],\n-        ty::TyAdt(def, _) if def.is_enum() && def.variants.len() > 1 =>\n-            def.variants.iter().map(|v| Variant(v.did)).collect(),\n-        _ => vec![Single]\n+        ty::TySlice(ref sub_ty) => {\n+            if sub_ty.is_uninhabited_from(cx.module, cx.tcx) {\n+                vec![Slice(0)]\n+            } else {\n+                (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n+            }\n+        }\n+        ty::TyArray(ref sub_ty, length) => {\n+            if length == 0 || !sub_ty.is_uninhabited_from(cx.module, cx.tcx) {\n+                vec![Slice(length)]\n+            } else {\n+                vec![]\n+            }\n+        }\n+        ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n+            def.variants.iter().filter_map(|v| {\n+                let mut visited = FxHashSet::default();\n+                let forest = v.uninhabited_from(&mut visited,\n+                                                cx.tcx, substs,\n+                                                AdtKind::Enum);\n+                if forest.contains(cx.tcx, cx.module) {\n+                    None\n+                } else {\n+                    Some(Variant(v.did))\n+                }\n+            }).collect()\n+        }\n+        _ => {\n+            if pcx.ty.is_uninhabited_from(cx.module, cx.tcx) {\n+                vec![]\n+            } else {\n+                vec![Single]\n+            }\n+        }\n     }\n }\n \n-fn max_slice_length<'a, 'tcx, I>(\n+fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     _cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     patterns: I) -> usize\n-    where I: Iterator<Item=&'a Pattern<'tcx>>\n+    where I: Iterator<Item=&'p Pattern<'tcx>>\n {\n     // The exhaustiveness-checking paper does not include any details on\n     // checking variable-length slice patterns. However, they are matched\n@@ -491,6 +513,12 @@ fn max_slice_length<'a, 'tcx, I>(\n }\n \n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n+/// The algorithm from the paper has been modified to correctly handle empty\n+/// types. The changes are:\n+///   (0) We don't exit early if the pattern matrix has zero rows. We just\n+///       continue to recurse over columns.\n+///   (1) all_constructors will only return constructors that are statically\n+///       possible. eg. it will only return Ok for Result<T, !>\n ///\n /// Whether a vector `v` of patterns is 'useful' in relation to a set of such\n /// vectors `m` is defined as there being a set of inputs that will match `v`\n@@ -500,29 +528,30 @@ fn max_slice_length<'a, 'tcx, I>(\n /// relation to preceding patterns, it is not reachable) and exhaustiveness\n /// checking (if a wildcard pattern is useful in relation to a matrix, the\n /// matrix isn't exhaustive).\n-///\n-/// Note: is_useful doesn't work on empty types, as the paper notes.\n-/// So it assumes that v is non-empty.\n-pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-                           matrix: &Matrix<'a, 'tcx>,\n-                           v: &[&'a Pattern<'tcx>],\n+pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                           matrix: &Matrix<'p, 'tcx>,\n+                           v: &[&'p Pattern<'tcx>],\n                            witness: WitnessPreference)\n                            -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"is_useful({:?}, {:?})\", matrix, v);\n-    if rows.is_empty() {\n-        return match witness {\n-            ConstructWitness => UsefulWithWitness(vec![Witness(\n-                repeat(cx.wild_pattern).take(v.len()).cloned().collect()\n-            )]),\n-            LeaveOutWitness => Useful\n-        };\n-    }\n-    if rows[0].is_empty() {\n-        return NotUseful;\n-    }\n \n-    let &Matrix(ref rows) = matrix;\n+    // The base case. We are pattern-matching on () and the return value is\n+    // based on whether our matrix has a row or not.\n+    // NOTE: This could potentially be optimized by checking rows.is_empty()\n+    // first and then, if v is non-empty, the return value is based on whether\n+    // the type of the tuple we're checking is inhabited or not.\n+    if v.is_empty() {\n+        return if rows.is_empty() {\n+            match witness {\n+                ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n+                LeaveOutWitness => Useful,\n+            }\n+        } else {\n+            NotUseful\n+        }\n+    };\n+\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n \n@@ -541,10 +570,28 @@ pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n-        let constructors = missing_constructors(cx, matrix, pcx);\n-        debug!(\"is_useful - missing_constructors = {:?}\", constructors);\n-        if constructors.is_empty() {\n-            all_constructors(cx, pcx).into_iter().map(|c| {\n+\n+        let used_ctors: Vec<Constructor> = rows.iter().flat_map(|row| {\n+            pat_constructors(cx, row[0], pcx).unwrap_or(vec![])\n+        }).collect();\n+        debug!(\"used_ctors = {:?}\", used_ctors);\n+        let all_ctors = all_constructors(cx, pcx);\n+        debug!(\"all_ctors = {:?}\", all_ctors);\n+        let missing_ctors: Vec<Constructor> = all_ctors.iter().filter(|c| {\n+            !used_ctors.contains(*c)\n+        }).cloned().collect();\n+        debug!(\"missing_ctors = {:?}\", missing_ctors);\n+\n+        // `missing_ctors` is the set of constructors from the same type as the\n+        // first column of `matrix` that are matched only by wildcard patterns\n+        // from the first column.\n+        //\n+        // Therefore, if there is some pattern that is unmatched by `matrix`,\n+        // it will still be unmatched if the first constructor is replaced by\n+        // any of the constructors in `missing_ctors`\n+\n+        if missing_ctors.is_empty() {\n+            all_ctors.into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n             }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n         } else {\n@@ -558,31 +605,53 @@ pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             match is_useful(cx, &matrix, &v[1..], witness) {\n                 UsefulWithWitness(pats) => {\n                     let cx = &*cx;\n-                    UsefulWithWitness(pats.into_iter().flat_map(|witness| {\n-                        constructors.iter().map(move |ctor| {\n-                            witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n-                        })\n-                    }).collect())\n+                    let new_witnesses = if used_ctors.is_empty() {\n+                        // All constructors are unused. Add wild patterns\n+                        // rather than each individual constructor\n+                        pats.into_iter().map(|mut witness| {\n+                            witness.0.push(Pattern {\n+                                ty: pcx.ty,\n+                                span: DUMMY_SP,\n+                                kind: box PatternKind::Wild,\n+                            });\n+                            witness\n+                        }).collect()\n+                    } else {\n+                        pats.into_iter().flat_map(|witness| {\n+                            missing_ctors.iter().map(move |ctor| {\n+                                witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n+                            })\n+                        }).collect()\n+                    };\n+                    UsefulWithWitness(new_witnesses)\n                 }\n                 result => result\n             }\n         }\n     }\n }\n \n-fn is_useful_specialized<'a, 'tcx>(\n+fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    &Matrix(ref m): &Matrix<'a, 'tcx>,\n-    v: &[&'a Pattern<'tcx>],\n+    &Matrix(ref m): &Matrix<'p, 'tcx>,\n+    v: &[&'p Pattern<'tcx>],\n     ctor: Constructor,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness<'tcx>\n {\n-    let arity = constructor_arity(cx, &ctor, lty);\n+    let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n+    let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n+        Pattern {\n+            ty: ty,\n+            span: DUMMY_SP,\n+            kind: box PatternKind::Wild,\n+        }\n+    }).collect();\n+    let wild_patterns: Vec<_> = wild_patterns_owned.iter().collect();\n     let matrix = Matrix(m.iter().flat_map(|r| {\n-        specialize(cx, &r[..], &ctor, 0, arity)\n+        specialize(cx, &r[..], &ctor, &wild_patterns)\n     }).collect());\n-    match specialize(cx, v, &ctor, 0, arity) {\n+    match specialize(cx, v, &ctor, &wild_patterns) {\n         Some(v) => match is_useful(cx, &matrix, &v[..], witness) {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n                 witnesses.into_iter()\n@@ -657,6 +726,33 @@ fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize\n     }\n }\n \n+/// This computes the types of the sub patterns that a constructor should be\n+/// expanded to.\n+///\n+/// For instance, a tuple pattern (43u32, 'a') has sub pattern types [u32, char].\n+fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n+                                             ctor: &Constructor,\n+                                             ty: Ty<'tcx>) -> Vec<Ty<'tcx>>\n+{\n+    debug!(\"constructor_sub_pattern_tys({:?}, {:?})\", ctor, ty);\n+    match ty.sty {\n+        ty::TyTuple(ref fs) => fs.into_iter().map(|t| *t).collect(),\n+        ty::TyBox(ty) => vec![ty],\n+        ty::TySlice(ty) | ty::TyArray(ty, _) => match *ctor {\n+            Slice(length) => repeat(ty).take(length).collect(),\n+            ConstantValue(_) => vec![],\n+            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n+        },\n+        ty::TyRef(_, ref ty_and_mut) => vec![ty_and_mut.ty],\n+        ty::TyAdt(adt, substs) => {\n+            adt.variants[ctor.variant_index_for_adt(adt)].fields.iter().map(|field| {\n+                field.ty(cx.tcx, substs)\n+            }).collect()\n+        }\n+        _ => vec![],\n+    }\n+}\n+\n fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n                                     ctor: &Constructor,\n                                     prefix: &[Pattern],\n@@ -708,19 +804,18 @@ fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n     Ok(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n }\n \n-fn patterns_for_variant<'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    subpatterns: &'a [FieldPattern<'tcx>],\n-    arity: usize)\n-    -> Vec<&'a Pattern<'tcx>>\n+fn patterns_for_variant<'p, 'a: 'p, 'tcx: 'a>(\n+    subpatterns: &'p [FieldPattern<'tcx>],\n+    wild_patterns: &[&'p Pattern<'tcx>])\n+    -> Vec<&'p Pattern<'tcx>>\n {\n-    let mut result = vec![cx.wild_pattern; arity];\n+    let mut result = wild_patterns.to_owned();\n \n     for subpat in subpatterns {\n         result[subpat.field.index()] = &subpat.pattern;\n     }\n \n-    debug!(\"patterns_for_variant({:?}, {:?}) = {:?}\", subpatterns, arity, result);\n+    debug!(\"patterns_for_variant({:?}, {:?}) = {:?}\", subpatterns, wild_patterns, result);\n     result\n }\n \n@@ -732,35 +827,41 @@ fn patterns_for_variant<'a, 'tcx>(\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-fn specialize<'a, 'tcx>(\n+fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    r: &[&'a Pattern<'tcx>],\n-    constructor: &Constructor, col: usize, arity: usize)\n-    -> Option<Vec<&'a Pattern<'tcx>>>\n+    r: &[&'p Pattern<'tcx>],\n+    constructor: &Constructor,\n+    wild_patterns: &[&'p Pattern<'tcx>])\n+    -> Option<Vec<&'p Pattern<'tcx>>>\n {\n-    let pat = &r[col];\n+    let pat = &r[0];\n \n     let head: Option<Vec<&Pattern>> = match *pat.kind {\n-        PatternKind::Binding { .. } | PatternKind::Wild =>\n-            Some(vec![cx.wild_pattern; arity]),\n+        PatternKind::Binding { .. } | PatternKind::Wild => {\n+            Some(wild_patterns.to_owned())\n+        },\n \n-        PatternKind::Variant { adt_def, variant_index, ref subpatterns } => {\n+        PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n             if *constructor == Variant(variant.did) {\n-                Some(patterns_for_variant(cx, subpatterns, arity))\n+                Some(patterns_for_variant(subpatterns, wild_patterns))\n             } else {\n                 None\n             }\n         }\n \n-        PatternKind::Leaf { ref subpatterns } => Some(patterns_for_variant(cx, subpatterns, arity)),\n-        PatternKind::Deref { ref subpattern } => Some(vec![subpattern]),\n+        PatternKind::Leaf { ref subpatterns } => {\n+            Some(patterns_for_variant(subpatterns, wild_patterns))\n+        }\n+        PatternKind::Deref { ref subpattern } => {\n+            Some(vec![subpattern])\n+        }\n \n         PatternKind::Constant { ref value } => {\n             match *constructor {\n                 Slice(..) => match *value {\n                     ConstVal::ByteStr(ref data) => {\n-                        if arity == data.len() {\n+                        if wild_patterns.len() == data.len() {\n                             Some(cx.lower_byte_str_pattern(pat))\n                         } else {\n                             None\n@@ -796,11 +897,14 @@ fn specialize<'a, 'tcx>(\n             match *constructor {\n                 Slice(..) => {\n                     let pat_len = prefix.len() + suffix.len();\n-                    if let Some(slice_count) = arity.checked_sub(pat_len) {\n+                    if let Some(slice_count) = wild_patterns.len().checked_sub(pat_len) {\n                         if slice_count == 0 || slice.is_some() {\n                             Some(\n                                 prefix.iter().chain(\n-                                repeat(cx.wild_pattern).take(slice_count).chain(\n+                                wild_patterns.iter().map(|p| *p)\n+                                                    .skip(prefix.len())\n+                                                    .take(slice_count)\n+                                                    .chain(\n                                 suffix.iter()\n                             )).collect())\n                         } else {\n@@ -824,11 +928,10 @@ fn specialize<'a, 'tcx>(\n             }\n         }\n     };\n-    debug!(\"specialize({:?}, {:?}) = {:?}\", r[col], arity, head);\n+    debug!(\"specialize({:?}, {:?}) = {:?}\", r[0], wild_patterns, head);\n \n     head.map(|mut head| {\n-        head.extend_from_slice(&r[..col]);\n-        head.extend_from_slice(&r[col + 1..]);\n+        head.extend_from_slice(&r[1 ..]);\n         head\n     })\n }"}, {"sha": "2949cf0d535bfd286bca8e4554dc7f243d7417cc", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -24,8 +24,9 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n use rustc::session::Session;\n use rustc::traits::Reveal;\n-use rustc::ty::{self, TyCtxt};\n-use rustc_errors::DiagnosticBuilder;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::lint;\n+use rustc_errors::{Diagnostic, Level, DiagnosticBuilder};\n \n use rustc::hir::def::*;\n use rustc::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n@@ -35,7 +36,7 @@ use rustc_back::slice;\n \n use syntax::ast;\n use syntax::ptr::P;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n struct OuterVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n \n@@ -80,7 +81,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n \n         match ex.node {\n             hir::ExprMatch(ref scrut, ref arms, source) => {\n-                self.check_match(scrut, arms, source, ex.span);\n+                self.check_match(scrut, arms, source);\n             }\n             _ => {}\n         }\n@@ -131,8 +132,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         &self,\n         scrut: &hir::Expr,\n         arms: &[hir::Arm],\n-        source: hir::MatchSource,\n-        span: Span)\n+        source: hir::MatchSource)\n     {\n         for arm in arms {\n             // First, check legality of move bindings.\n@@ -150,7 +150,8 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             }\n         }\n \n-        MatchCheckCtxt::create_and_enter(self.tcx, |ref mut cx| {\n+        let module = self.tcx.map.local_def_id(self.tcx.map.get_module_parent(scrut.id));\n+        MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut have_errors = false;\n \n             let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n@@ -174,32 +175,14 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Fourth, check for unreachable arms.\n             check_arms(cx, &inlined_arms, source);\n \n-            // Finally, check if the whole match expression is exhaustive.\n-            // Check for empty enum, because is_useful only works on inhabited types.\n-            let pat_ty = self.tcx.tables().node_id_to_type(scrut.id);\n-            if inlined_arms.is_empty() {\n-                if !pat_ty.is_uninhabited(Some(scrut.id), self.tcx) {\n-                    // We know the type is inhabited, so this must be wrong\n-                    let mut err = create_e0004(self.tcx.sess, span,\n-                                               format!(\"non-exhaustive patterns: type {} \\\n-                                                        is non-empty\",\n-                                                       pat_ty));\n-                    span_help!(&mut err, span,\n-                               \"Please ensure that all possible cases are being handled; \\\n-                                possibly adding wildcards or more match arms.\");\n-                    err.emit();\n-                }\n-                // If the type *is* uninhabited, it's vacuously exhaustive\n-                return;\n-            }\n-\n             let matrix: Matrix = inlined_arms\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n                 .flat_map(|arm| &arm.0)\n                 .map(|pat| vec![pat.0])\n                 .collect();\n-            check_exhaustive(cx, scrut.span, &matrix, source);\n+            let scrut_ty = cx.tcx.tables().node_id_to_type(scrut.id);\n+            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, source);\n         })\n     }\n \n@@ -210,13 +193,21 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             \"local binding\"\n         };\n \n-        MatchCheckCtxt::create_and_enter(self.tcx, |ref mut cx| {\n+        let module = self.tcx.map.local_def_id(self.tcx.map.get_module_parent(pat.id));\n+        MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx);\n+            let pattern = patcx.lower_pattern(pat);\n+            let pattern_ty = pattern.ty;\n             let pats : Matrix = vec![vec![\n-                expand_pattern(cx, patcx.lower_pattern(pat))\n+                expand_pattern(cx, pattern)\n             ]].into_iter().collect();\n \n-            let witness = match is_useful(cx, &pats, &[cx.wild_pattern], ConstructWitness) {\n+            let wild_pattern = Pattern {\n+                ty: pattern_ty,\n+                span: DUMMY_SP,\n+                kind: box PatternKind::Wild,\n+            };\n+            let witness = match is_useful(cx, &pats, &[&wild_pattern], ConstructWitness) {\n                 UsefulWithWitness(witness) => witness,\n                 NotUseful => return,\n                 Useful => bug!()\n@@ -324,14 +315,16 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                         },\n \n                         hir::MatchSource::Normal => {\n-                            let mut err = struct_span_err!(cx.tcx.sess, pat.span, E0001,\n-                                                           \"unreachable pattern\");\n-                            err.span_label(pat.span, &\"this is an unreachable pattern\");\n+                            let mut diagnostic = Diagnostic::new(Level::Warning,\n+                                                                 \"unreachable pattern\");\n+                            diagnostic.set_span(pat.span);\n                             // if we had a catchall pattern, hint at that\n                             if let Some(catchall) = catchall {\n-                                err.span_note(catchall, \"this pattern matches any value\");\n+                                diagnostic.span_label(pat.span, &\"this is an unreachable pattern\");\n+                                diagnostic.span_note(catchall, \"this pattern matches any value\");\n                             }\n-                            err.emit();\n+                            cx.tcx.sess.add_lint_diagnostic(lint::builtin::UNREACHABLE_PATTERNS,\n+                                                            hir_pat.id, diagnostic);\n                         },\n \n                         hir::MatchSource::TryDesugar => {\n@@ -353,13 +346,19 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n }\n \n fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                              scrut_ty: Ty<'tcx>,\n                               sp: Span,\n                               matrix: &Matrix<'a, 'tcx>,\n                               source: hir::MatchSource) {\n-    match is_useful(cx, matrix, &[cx.wild_pattern], ConstructWitness) {\n+    let wild_pattern = Pattern {\n+        ty: scrut_ty,\n+        span: DUMMY_SP,\n+        kind: box PatternKind::Wild,\n+    };\n+    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witnesses = if pats.is_empty() {\n-                vec![cx.wild_pattern]\n+                vec![&wild_pattern]\n             } else {\n                 pats.iter().map(|w| w.single_pattern()).collect()\n             };"}, {"sha": "8c8b2b5da36dc65d7e13a787e7bf349c09f44000", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -16,6 +16,8 @@\n register_long_diagnostics! {\n \n E0001: r##\"\n+## Note: this error code is no longer emitted by the compiler.\n+\n This error suggests that the expression arm corresponding to the noted pattern\n will never be reached as for all possible values of the expression being\n matched, one of the preceding patterns will match.\n@@ -25,10 +27,10 @@ one is too specific or the ordering is incorrect.\n \n For example, the following `match` block has too many arms:\n \n-```compile_fail,E0001\n+```\n match Some(0) {\n     Some(bar) => {/* ... */}\n-    None => {/* ... */}\n+    x => {/* ... */} // This handles the `None` case\n     _ => {/* ... */} // All possible cases have already been handled\n }\n ```"}, {"sha": "42394f4745f6611067c0793bc2b78a6b7776e35e", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -13,7 +13,8 @@ use eval;\n use rustc::lint;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::{Field, BorrowKind, Mutability};\n-use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n+use rustc::ty::{self, TyCtxt, AdtDef, Ty, TypeVariants, Region};\n+use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n@@ -67,6 +68,7 @@ pub enum PatternKind<'tcx> {\n     /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n     Variant {\n         adt_def: &'tcx AdtDef,\n+        substs: &'tcx Substs<'tcx>,\n         variant_index: usize,\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n@@ -391,8 +393,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n \n             PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n                 let def = self.tcx.tables().qpath_def(qpath, pat.id);\n-                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n-                let adt_def = match pat_ty.sty {\n+                let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n                 };\n@@ -406,13 +407,12 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                                        pattern: self.lower_pattern(field),\n                                    })\n                                    .collect();\n-                self.lower_variant_or_leaf(def, subpatterns)\n+                self.lower_variant_or_leaf(def, ty, subpatterns)\n             }\n \n             PatKind::Struct(ref qpath, ref fields, _) => {\n                 let def = self.tcx.tables().qpath_def(qpath, pat.id);\n-                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n-                let adt_def = match pat_ty.sty {\n+                let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n                         span_bug!(\n@@ -439,7 +439,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                           })\n                           .collect();\n \n-                self.lower_variant_or_leaf(def, subpatterns)\n+                self.lower_variant_or_leaf(def, ty, subpatterns)\n             }\n         };\n \n@@ -529,6 +529,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n     fn lower_variant_or_leaf(\n         &mut self,\n         def: Def,\n+        ty: Ty<'tcx>,\n         subpatterns: Vec<FieldPattern<'tcx>>)\n         -> PatternKind<'tcx>\n     {\n@@ -537,8 +538,14 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n                 let adt_def = self.tcx.lookup_adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n+                    let substs = match ty.sty {\n+                        TypeVariants::TyAdt(_, substs) => substs,\n+                        TypeVariants::TyFnDef(_, substs, _) => substs,\n+                        _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n+                    };\n                     PatternKind::Variant {\n                         adt_def: adt_def,\n+                        substs: substs,\n                         variant_index: adt_def.variant_index_with_id(variant_id),\n                         subpatterns: subpatterns,\n                     }\n@@ -562,6 +569,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                   pat_id: ast::NodeId,\n                   span: Span)\n                   -> Pattern<'tcx> {\n+        let ty = self.tcx.tables().node_id_to_type(id);\n         let def = self.tcx.tables().qpath_def(qpath, id);\n         let kind = match def {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n@@ -578,12 +586,12 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            _ => self.lower_variant_or_leaf(def, vec![])\n+            _ => self.lower_variant_or_leaf(def, ty, vec![]),\n         };\n \n         Pattern {\n             span: span,\n-            ty: self.tcx.tables().node_id_to_type(id),\n+            ty: ty,\n             kind: Box::new(kind),\n         }\n     }\n@@ -651,6 +659,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                     hir::ExprPath(ref qpath) => qpath,\n                     _ => bug!()\n                 };\n+                let ty = self.tcx.tables().node_id_to_type(callee.id);\n                 let def = self.tcx.tables().qpath_def(qpath, callee.id);\n                 match def {\n                     Def::Fn(..) | Def::Method(..) => self.lower_lit(expr),\n@@ -661,7 +670,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                                 pattern: self.lower_const_expr(expr, pat_id, span)\n                             }\n                         }).collect();\n-                        self.lower_variant_or_leaf(def, subpatterns)\n+                        self.lower_variant_or_leaf(def, ty, subpatterns)\n                     }\n                 }\n             }\n@@ -696,7 +705,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                           })\n                           .collect();\n \n-                self.lower_variant_or_leaf(def, subpatterns)\n+                self.lower_variant_or_leaf(def, pat_ty, subpatterns)\n             }\n \n             hir::ExprArray(ref exprs) => {\n@@ -776,8 +785,9 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal,\n-    Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal, Region,\n+    Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n+    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n }\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n@@ -828,10 +838,12 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             },\n             PatternKind::Variant {\n                 adt_def,\n+                substs,\n                 variant_index,\n                 ref subpatterns,\n             } => PatternKind::Variant {\n                 adt_def: adt_def.fold_with(folder),\n+                substs: substs.fold_with(folder),\n                 variant_index: variant_index.fold_with(folder),\n                 subpatterns: subpatterns.fold_with(folder)\n             },"}, {"sha": "78af655852d1b0656ade7f7ce031ad0e38d71434", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -19,6 +19,7 @@ use std::ops::{Deref, DerefMut};\n use std::iter::{self, IntoIterator, FromIterator};\n use std::slice;\n use std::vec;\n+use std::collections::range::RangeArgument;\n \n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n \n@@ -71,6 +72,19 @@ impl<A: Array> AccumulateVec<A> {\n             AccumulateVec::Heap(ref mut vec) => vec.pop(),\n         }\n     }\n+\n+    pub fn drain<R>(&mut self, range: R) -> Drain<A>\n+        where R: RangeArgument<usize>\n+    {\n+        match *self {\n+            AccumulateVec::Array(ref mut v) => {\n+                Drain::Array(v.drain(range))\n+            },\n+            AccumulateVec::Heap(ref mut v) => {\n+                Drain::Heap(v.drain(range))\n+            },\n+        }\n+    }\n }\n \n impl<A: Array> Deref for AccumulateVec<A> {\n@@ -132,6 +146,31 @@ impl<A: Array> Iterator for IntoIter<A> {\n     }\n }\n \n+pub enum Drain<'a, A: Array>\n+        where A::Element: 'a\n+{\n+    Array(array_vec::Drain<'a, A>),\n+    Heap(vec::Drain<'a, A::Element>),\n+}\n+\n+impl<'a, A: Array> Iterator for Drain<'a, A> {\n+    type Item = A::Element;\n+\n+    fn next(&mut self) -> Option<A::Element> {\n+        match *self {\n+            Drain::Array(ref mut drain) => drain.next(),\n+            Drain::Heap(ref mut drain) => drain.next(),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match *self {\n+            Drain::Array(ref drain) => drain.size_hint(),\n+            Drain::Heap(ref drain) => drain.size_hint(),\n+        }\n+    }\n+}\n+\n impl<A: Array> IntoIterator for AccumulateVec<A> {\n     type Item = A::Element;\n     type IntoIter = IntoIter<A>;"}, {"sha": "844e9041d202984a8d312149510a10871b491775", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -12,12 +12,13 @@\n \n use std::marker::Unsize;\n use std::iter::Extend;\n-use std::ptr::{self, drop_in_place};\n+use std::ptr::{self, drop_in_place, Shared};\n use std::ops::{Deref, DerefMut, Range};\n use std::hash::{Hash, Hasher};\n use std::slice;\n use std::fmt;\n use std::mem;\n+use std::collections::range::RangeArgument;\n \n pub unsafe trait Array {\n     type Element;\n@@ -103,6 +104,44 @@ impl<A: Array> ArrayVec<A> {\n             None\n         }\n     }\n+\n+    pub fn drain<R>(&mut self, range: R) -> Drain<A>\n+        where R: RangeArgument<usize>\n+    {\n+        // Memory safety\n+        //\n+        // When the Drain is first created, it shortens the length of\n+        // the source vector to make sure no uninitalized or moved-from elements\n+        // are accessible at all if the Drain's destructor never gets to run.\n+        //\n+        // Drain will ptr::read out the values to remove.\n+        // When finished, remaining tail of the vec is copied back to cover\n+        // the hole, and the vector length is restored to the new length.\n+        //\n+        let len = self.len();\n+        let start = *range.start().unwrap_or(&0);\n+        let end = *range.end().unwrap_or(&len);\n+        assert!(start <= end);\n+        assert!(end <= len);\n+\n+        unsafe {\n+            // set self.vec length's to start, to be safe in case Drain is leaked\n+            self.set_len(start);\n+            // Use the borrow in the IterMut to indicate borrowing behavior of the\n+            // whole Drain iterator (like &mut T).\n+            let range_slice = {\n+                let arr = &mut self.values as &mut [ManuallyDrop<_>];\n+                slice::from_raw_parts_mut(arr.as_mut_ptr().offset(start as isize),\n+                                          end - start)\n+            };\n+            Drain {\n+                tail_start: end,\n+                tail_len: len - end,\n+                iter: range_slice.iter(),\n+                array_vec: Shared::new(self as *mut _),\n+            }\n+        }\n+    }\n }\n \n impl<A> Default for ArrayVec<A>\n@@ -179,6 +218,51 @@ impl<A: Array> Iterator for Iter<A> {\n     }\n }\n \n+pub struct Drain<'a, A: Array>\n+        where A::Element: 'a\n+{\n+    tail_start: usize,\n+    tail_len: usize,\n+    iter: slice::Iter<'a, ManuallyDrop<A::Element>>,\n+    array_vec: Shared<ArrayVec<A>>,\n+}\n+\n+impl<'a, A: Array> Iterator for Drain<'a, A> {\n+    type Item = A::Element;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A::Element> {\n+        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const ManuallyDrop<_>).value })\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+impl<'a, A: Array> Drop for Drain<'a, A> {\n+    fn drop(&mut self) {\n+        // exhaust self first\n+        while let Some(_) = self.next() {}\n+\n+        if self.tail_len > 0 {\n+            unsafe {\n+                let source_array_vec = &mut **self.array_vec;\n+                // memmove back untouched tail, update to new length\n+                let start = source_array_vec.len();\n+                let tail = self.tail_start;\n+                {\n+                    let mut arr = &mut source_array_vec.values as &mut [ManuallyDrop<_>];\n+                    let src = arr.as_ptr().offset(tail as isize);\n+                    let dst = arr.as_mut_ptr().offset(start as isize);\n+                    ptr::copy(src, dst, self.tail_len);\n+                };\n+                source_array_vec.set_len(start + self.tail_len);\n+            }\n+        }\n+    }\n+}\n+\n impl<A: Array> IntoIterator for ArrayVec<A> {\n     type Item = A::Element;\n     type IntoIter = Iter<A>;"}, {"sha": "ee75a3596e18ab89e8b0d4ff61f35831d9e472d9", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -25,6 +25,8 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+#![feature(shared)]\n+#![feature(collections_range)]\n #![feature(nonzero)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "efccc4abd43b8f7d3e96d19e01e6d4ee06b85d50", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -165,6 +165,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     DEAD_CODE,\n                     UNUSED_MUT,\n                     UNREACHABLE_CODE,\n+                    UNREACHABLE_PATTERNS,\n                     UNUSED_MUST_USE,\n                     UNUSED_UNSAFE,\n                     PATH_STATEMENTS,"}, {"sha": "b071834122367421000e107fd2e06fd2324baba9", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -26,6 +26,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::matches::{Binding, MatchPair, Candidate};\n use hair::*;\n use rustc::mir::*;\n+use rustc_data_structures::fx::FxHashSet;\n \n use std::mem;\n \n@@ -93,11 +94,30 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             PatternKind::Range { .. } |\n-            PatternKind::Variant { .. } |\n             PatternKind::Slice { .. } => {\n                 Err(match_pair)\n             }\n \n+            PatternKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n+                let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n+                    i == variant_index || {\n+                        let mut visited = FxHashSet::default();\n+                        let node_set = v.uninhabited_from(&mut visited,\n+                                                          self.hir.tcx(),\n+                                                          substs,\n+                                                          adt_def.adt_kind());\n+                        !node_set.is_empty()\n+                    }\n+                });\n+                if irrefutable {\n+                    let lvalue = match_pair.lvalue.downcast(adt_def, variant_index);\n+                    candidate.match_pairs.extend(self.field_match_pairs(lvalue, subpatterns));\n+                    Ok(())\n+                } else {\n+                    Err(match_pair)\n+                }\n+            },\n+\n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n                 self.prefix_slice_suffix(&mut candidate.match_pairs,\n                                          &match_pair.lvalue,"}, {"sha": "8b4a013bad0a369be8bbc4c7b488bf1d3122dcae", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// It is a bug to call this with a simplifyable pattern.\n     pub fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n         match *match_pair.pattern.kind {\n-            PatternKind::Variant { ref adt_def, variant_index: _, subpatterns: _ } => {\n+            PatternKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Switch {\n@@ -451,7 +451,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // If we are performing a variant switch, then this\n             // informs variant patterns, but nothing else.\n             (&TestKind::Switch { adt_def: tested_adt_def, .. },\n-             &PatternKind::Variant { adt_def, variant_index, ref subpatterns }) => {\n+             &PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. }) => {\n                 assert_eq!(adt_def, tested_adt_def);\n                 let new_candidate =\n                     self.candidate_after_variant_switch(match_pair_index,"}, {"sha": "0fa9062df45915adb3fef479310a6907b56ccc69", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -399,7 +399,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.check_pat(&p, discrim_ty);\n                 all_pats_diverge &= self.diverges.get();\n             }\n-            all_pats_diverge\n+            // As discussed with @eddyb, this is for disabling unreachable_code\n+            // warnings on patterns (they're now subsumed by unreachable_patterns\n+            // warnings).\n+            match all_pats_diverge {\n+                Diverges::Maybe => Diverges::Maybe,\n+                Diverges::Always | Diverges::WarnedAlways => Diverges::WarnedAlways,\n+            }\n         }).collect();\n \n         // Now typecheck the blocks."}, {"sha": "b72b0d661901fbf0d9b3a8bbc215628067e49919", "filename": "src/test/compile-fail/E0001.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2FE0001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2FE0001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0001.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(unreachable_patterns)]\n+\n fn main() {\n     let foo = Some(1);\n     match foo {\n-        Some(bar) => {/* ... */}\n+        Some(_) => {/* ... */}\n         None => {/* ... */}\n-        _ => {/* ... */} //~ ERROR E0001\n+        _ => {/* ... */} //~ ERROR unreachable pattern\n     }\n }"}, {"sha": "a8d2c55255340ceca1c776cd07723836805d1080", "filename": "src/test/compile-fail/issue-12116.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-12116.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-12116.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12116.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -10,6 +10,9 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+#![deny(unreachable_patterns)]\n \n enum IntList {\n     Cons(isize, Box<IntList>),\n@@ -19,9 +22,8 @@ enum IntList {\n fn tail(source_list: &IntList) -> IntList {\n     match source_list {\n         &IntList::Cons(val, box ref next_list) => tail(next_list),\n-        &IntList::Cons(val, box Nil)           => IntList::Cons(val, box Nil),\n+        &IntList::Cons(val, box IntList::Nil)  => IntList::Cons(val, box IntList::Nil),\n //~^ ERROR unreachable pattern\n-//~^^ WARN pattern binding `Nil` is named the same as one of the variants of the type `IntList`\n         _                          => panic!()\n     }\n }"}, {"sha": "4df1e24dcfbd53c05d12653f63e47e5a37dd8b45", "filename": "src/test/compile-fail/issue-12369.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n #![feature(slice_patterns)]\n+#![allow(unused_variables)]\n+#![deny(unreachable_patterns)]\n \n fn main() {\n     let sl = vec![1,2,3];"}, {"sha": "2e815548e89134c7e95e16cc1fe318f0c0fc8df0", "filename": "src/test/compile-fail/issue-13727.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-13727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-13727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13727.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(overflowing_literals)]\n+#![deny(unreachable_patterns)]\n+\n fn test(val: u8) {\n   match val {\n     256 => print!(\"0b1110\\n\"),"}, {"sha": "d11fe99c07f6b738433a029d386904bd2e2fa83b", "filename": "src/test/compile-fail/issue-14221.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-14221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-14221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14221.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(unreachable_patterns)]\n+#![allow(unused_variables)]\n+#![allow(non_snake_case)]\n+\n pub enum E {\n     A,\n     B,"}, {"sha": "cf6935b9ba6d4a34a16f867b3fb0e854bf683e88", "filename": "src/test/compile-fail/issue-30240-b.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-30240-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-30240-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30240-b.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(unreachable_patterns)]\n+\n+fn main() {\n+    match \"world\" {\n+        \"hello\" => {}\n+        _ => {},\n+    }\n+\n+    match \"world\" {\n+        ref _x if false => {}\n+        \"hello\" => {}\n+        \"hello\" => {} //~ ERROR unreachable pattern\n+        _ => {},\n+    }\n+}\n+"}, {"sha": "60fb307d4e1a4a141689f3f7d4e7258cd6eed5c8", "filename": "src/test/compile-fail/issue-30240.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-30240.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-30240.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30240.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -16,6 +16,5 @@ fn main() {\n     match \"world\" { //~ ERROR non-exhaustive patterns: `&_`\n         ref _x if false => {}\n         \"hello\" => {}\n-        \"hello\" => {} //~ ERROR unreachable pattern\n     }\n }"}, {"sha": "01150ff13740f1446a06b8922507e0578c0af552", "filename": "src/test/compile-fail/issue-30302.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-30302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-30302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30302.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+#![allow(non_snake_case)]\n+#![deny(unreachable_patterns)]\n+\n enum Stack<T> {\n     Nil,\n     Cons(T, Box<Stack<T>>)"}, {"sha": "e2b80215caf61894fec84d8235657379ae02f297", "filename": "src/test/compile-fail/issue-31221.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-31221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-31221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31221.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -8,6 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+#![allow(non_snake_case)]\n+#![deny(unreachable_patterns)]\n+//~^ NOTE lint level defined here\n+//~^^ NOTE lint level defined here\n+//~^^^ NOTE lint level defined here\n+\n+#[derive(Clone, Copy)]\n enum Enum {\n     Var1,\n     Var2,\n@@ -41,13 +50,4 @@ fn main() {\n         //~^ ERROR unreachable pattern\n         //~^^ NOTE this is an unreachable pattern\n     };\n-    // `_` need not emit a note, it is pretty obvious already.\n-    let t = (Var1, Var1);\n-    match t {\n-        (Var1, b) => (),\n-        _ => (),\n-        anything => ()\n-        //~^ ERROR unreachable pattern\n-        //~^^ NOTE this is an unreachable pattern\n-    };\n }"}, {"sha": "cc69a76e04331e411c12a9a217946993ae5c7479", "filename": "src/test/compile-fail/issue-3601.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3601.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -40,6 +40,5 @@ fn main() {\n         box NodeKind::Element(ed) => match ed.kind { //~ ERROR non-exhaustive patterns\n             box ElementKind::HTMLImageElement(ref d) if d.image.is_some() => { true }\n         },\n-        _ => panic!(\"WAT\") //~ ERROR unreachable pattern\n     };\n }"}, {"sha": "40dcf3d0f12cc987d82a12b329d3820efe588baf", "filename": "src/test/compile-fail/match-argm-statics-2.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-argm-statics-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-argm-statics-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-argm-statics-2.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::Direction::{North, East, South, West};\n+\n+struct NewBool(bool);\n+\n+enum Direction {\n+    North,\n+    East,\n+    South,\n+    West\n+}\n+\n+const TRUE_TRUE: (bool, bool) = (true, true);\n+\n+fn nonexhaustive_1() {\n+    match (true, false) {\n+    //~^ ERROR non-exhaustive patterns: `(true, false)` not covered\n+        TRUE_TRUE => (),\n+        (false, false) => (),\n+        (false, true) => ()\n+    }\n+}\n+\n+const NONE: Option<Direction> = None;\n+const EAST: Direction = East;\n+\n+fn nonexhaustive_2() {\n+    match Some(Some(North)) {\n+    //~^ ERROR non-exhaustive patterns: `Some(Some(West))` not covered\n+        Some(NONE) => (),\n+        Some(Some(North)) => (),\n+        Some(Some(EAST)) => (),\n+        Some(Some(South)) => (),\n+        None => ()\n+    }\n+}\n+\n+const NEW_FALSE: NewBool = NewBool(false);\n+struct Foo {\n+    bar: Option<Direction>,\n+    baz: NewBool\n+}\n+\n+const STATIC_FOO: Foo = Foo { bar: None, baz: NEW_FALSE };\n+\n+fn nonexhaustive_3() {\n+    match (Foo { bar: Some(North), baz: NewBool(true) }) {\n+    //~^ ERROR non-exhaustive patterns: `Foo { bar: Some(North), baz: NewBool(true) }`\n+        Foo { bar: None, baz: NewBool(true) } => (),\n+        Foo { bar: _, baz: NEW_FALSE } => (),\n+        Foo { bar: Some(West), baz: NewBool(true) } => (),\n+        Foo { bar: Some(South), .. } => (),\n+        Foo { bar: Some(EAST), .. } => ()\n+    }\n+}\n+\n+fn main() {\n+    nonexhaustive_1();\n+    nonexhaustive_2();\n+    nonexhaustive_3();\n+}\n+"}, {"sha": "40d73ab51c76228ca9f45ed6b38ad420f003a454", "filename": "src/test/compile-fail/match-arm-statics.rs", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-arm-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-arm-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-arm-statics.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -7,10 +7,16 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n+#![allow(dead_code)]\n+#![deny(unreachable_patterns)]\n+\n use self::Direction::{North, East, South, West};\n \n+#[derive(PartialEq, Eq)]\n struct NewBool(bool);\n \n+#[derive(PartialEq, Eq)]\n enum Direction {\n     North,\n     East,\n@@ -20,15 +26,6 @@ enum Direction {\n \n const TRUE_TRUE: (bool, bool) = (true, true);\n \n-fn nonexhaustive_1() {\n-    match (true, false) {\n-    //~^ ERROR non-exhaustive patterns: `(true, false)` not covered\n-        TRUE_TRUE => (),\n-        (false, false) => (),\n-        (false, true) => ()\n-    }\n-}\n-\n fn unreachable_1() {\n     match (true, false) {\n         TRUE_TRUE => (),\n@@ -43,17 +40,6 @@ fn unreachable_1() {\n const NONE: Option<Direction> = None;\n const EAST: Direction = East;\n \n-fn nonexhaustive_2() {\n-    match Some(Some(North)) {\n-    //~^ ERROR non-exhaustive patterns: `Some(Some(West))` not covered\n-        Some(NONE) => (),\n-        Some(Some(North)) => (),\n-        Some(Some(EAST)) => (),\n-        Some(Some(South)) => (),\n-        None => ()\n-    }\n-}\n-\n fn unreachable_2() {\n     match Some(Some(North)) {\n         Some(NONE) => (),\n@@ -73,19 +59,6 @@ struct Foo {\n     baz: NewBool\n }\n \n-const STATIC_FOO: Foo = Foo { bar: None, baz: NEW_FALSE };\n-\n-fn nonexhaustive_3() {\n-    match (Foo { bar: Some(North), baz: NewBool(true) }) {\n-    //~^ ERROR non-exhaustive patterns: `Foo { bar: Some(North), baz: NewBool(true) }`\n-        Foo { bar: None, baz: NewBool(true) } => (),\n-        Foo { bar: _, baz: NEW_FALSE } => (),\n-        Foo { bar: Some(West), baz: NewBool(true) } => (),\n-        Foo { bar: Some(South), .. } => (),\n-        Foo { bar: Some(EAST), .. } => ()\n-    }\n-}\n-\n fn unreachable_3() {\n     match (Foo { bar: Some(EAST), baz: NewBool(true) }) {\n         Foo { bar: None, baz: NewBool(true) } => (),\n@@ -100,9 +73,6 @@ fn unreachable_3() {\n }\n \n fn main() {\n-    nonexhaustive_1();\n-    nonexhaustive_2();\n-    nonexhaustive_3();\n     unreachable_1();\n     unreachable_2();\n     unreachable_3();"}, {"sha": "ad7e931a0ec9723999b7d5ba6fd2d1ea9c9337b3", "filename": "src/test/compile-fail/match-byte-array-patterns-2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-byte-array-patterns-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-byte-array-patterns-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-byte-array-patterns-2.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(advanced_slice_patterns, slice_patterns)]\n+\n+fn main() {\n+    let buf = &[0, 1, 2, 3];\n+\n+    match buf { //~ ERROR non-exhaustive\n+        b\"AAAA\" => {}\n+    }\n+\n+    let buf: &[u8] = buf;\n+\n+    match buf { //~ ERROR non-exhaustive\n+        b\"AAAA\" => {}\n+    }\n+}\n+"}, {"sha": "1ff07eae1c9c03a654d9cef0f63d7718df1ea873", "filename": "src/test/compile-fail/match-byte-array-patterns.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-byte-array-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-byte-array-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-byte-array-patterns.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(advanced_slice_patterns, slice_patterns)]\n+#![deny(unreachable_patterns)]\n \n fn main() {\n     let buf = &[0, 1, 2, 3];\n@@ -37,10 +38,6 @@ fn main() {\n         _ => {}\n     }\n \n-    match buf { //~ ERROR non-exhaustive\n-        b\"AAAA\" => {}\n-    }\n-\n     let buf: &[u8] = buf;\n \n     match buf {\n@@ -66,8 +63,4 @@ fn main() {\n         b\"AAAA\" => {}, //~ ERROR unreachable pattern\n         _ => {}\n     }\n-\n-    match buf { //~ ERROR non-exhaustive\n-        b\"AAAA\" => {}\n-    }\n }"}, {"sha": "256aa180f4a59e84d1f3b03973ac4fd36468a27e", "filename": "src/test/compile-fail/match-range-fail-dominate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail-dominate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail-dominate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail-dominate.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -14,6 +14,8 @@\n //error-pattern: unreachable\n //error-pattern: unreachable\n \n+#![deny(unreachable_patterns)]\n+\n fn main() {\n     match 5 {\n       1 ... 10 => { }"}, {"sha": "1cdbba17f658ad9501169068232e68ce3774af1a", "filename": "src/test/compile-fail/match-ref-ice.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-ref-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-ref-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-ref-ice.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(slice_patterns)]\n+#![deny(unreachable_patterns)]\n \n // The arity of `ref x` is always 1. If the pattern is compared to some non-structural type whose\n // arity is always 0, an ICE occurs.\n@@ -19,7 +20,7 @@ fn main() {\n     let homura = [1, 2, 3];\n \n     match homura {\n-        [1, ref madoka, 3] => (),\n+        [1, ref _madoka, 3] => (),\n         [1, 2, 3] => (), //~ ERROR unreachable pattern\n         [_, _, _] => (),\n     }"}, {"sha": "fd4bd1c7b944b7b879e3160f3e1a89cf65cc0dd4", "filename": "src/test/compile-fail/match-slice-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-slice-patterns.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -12,7 +12,7 @@\n \n fn check(list: &[Option<()>]) {\n     match list {\n-    //~^ ERROR `&[None, Some(_), None, _]` and `&[Some(_), Some(_), None, _]` not covered\n+    //~^ ERROR `&[_, Some(_), None, _]` not covered\n         &[] => {},\n         &[_] => {},\n         &[_, _] => {},"}, {"sha": "dd9379c756d12a147d56d9a71c5e1308cb516d91", "filename": "src/test/compile-fail/match-vec-fixed.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-vec-fixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-vec-fixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-fixed.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(slice_patterns)]\n+#![deny(unreachable_patterns)]\n \n fn a() {\n     let v = [1, 2, 3];"}, {"sha": "472b054b08777c19df99f71d58823864232199c9", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n #![feature(slice_patterns)]\n+#![deny(unreachable_patterns)]\n+#![allow(unused_variables)]\n \n fn main() {\n     let x: Vec<(isize, isize)> = Vec::new();\n@@ -24,7 +26,7 @@ fn main() {\n                               \"baz\".to_string()];\n     let x: &[String] = &x;\n     match *x {\n-        [a, _, _, ..] => { println!(\"{}\", a); }\n+        [ref a, _, _, ..] => { println!(\"{}\", a); }\n         [_, _, _, _, _] => { } //~ ERROR unreachable pattern\n         _ => { }\n     }"}, {"sha": "dda30141b4a06e9f79b9ee5d46f22587d59683b3", "filename": "src/test/compile-fail/struct-pattern-match-useless.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fstruct-pattern-match-useless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Fstruct-pattern-match-useless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-pattern-match-useless.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(unreachable_patterns)]\n+\n struct Foo {\n     x: isize,\n     y: isize,\n@@ -16,7 +18,7 @@ struct Foo {\n pub fn main() {\n     let a = Foo { x: 1, y: 2 };\n     match a {\n-        Foo { x: x, y: y } => (),\n+        Foo { x: _x, y: _y } => (),\n         Foo { .. } => () //~ ERROR unreachable pattern\n     }\n "}, {"sha": "4755fdd4fd5e8c1e2a846b8a2692c8482e42b21d", "filename": "src/test/compile-fail/uninhabited-irrefutable.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Funinhabited-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Funinhabited-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-irrefutable.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+\n+mod foo {\n+    pub struct SecretlyEmpty {\n+        _priv: !,\n+    }\n+\n+    pub struct NotSoSecretlyEmpty {\n+        pub _pub: !,\n+    }\n+}\n+\n+struct NotSoSecretlyEmpty {\n+    _priv: !,\n+}\n+\n+enum Foo {\n+    A(foo::SecretlyEmpty),\n+    B(foo::NotSoSecretlyEmpty),\n+    C(NotSoSecretlyEmpty),\n+    D(u32),\n+}\n+\n+fn main() {\n+    let x: Foo = Foo::D(123);\n+    let Foo::D(_y) = x; //~ ERROR refutable pattern in local binding: `A(_)` not covered\n+}\n+"}, {"sha": "0de29f3a8d7375e1d0d49ed517ddbc94752efb90", "filename": "src/test/compile-fail/uninhabited-patterns.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Funinhabited-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Funinhabited-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-patterns.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_patterns)]\n+#![feature(slice_patterns)]\n+#![feature(box_syntax)]\n+#![feature(never_type)]\n+#![deny(unreachable_patterns)]\n+\n+mod foo {\n+    pub struct SecretlyEmpty {\n+        _priv: !,\n+    }\n+}\n+\n+struct NotSoSecretlyEmpty {\n+    _priv: !,\n+}\n+\n+fn main() {\n+    let x: &[!] = &[];\n+\n+    match x {\n+        &[]   => (),\n+        &[..] => (),    //~ ERROR unreachable pattern\n+    };\n+\n+    let x: Result<Box<NotSoSecretlyEmpty>, &[Result<!, !>]> = Err(&[]);\n+    match x {\n+        Ok(box _) => (),    //~ ERROR unreachable pattern\n+        Err(&[]) => (),\n+        Err(&[..]) => (),   //~ ERROR unreachable pattern\n+    }\n+\n+    let x: Result<foo::SecretlyEmpty, Result<NotSoSecretlyEmpty, u32>> = Err(Err(123));\n+    match x {\n+        Ok(_y) => (),\n+        Err(Err(_y)) => (),\n+        Err(Ok(_y)) => (),  //~ ERROR unreachable pattern\n+    }\n+}\n+"}, {"sha": "df827d2c78421f31b34203317d053ab0321006fc", "filename": "src/test/compile-fail/unreachable-arm.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -8,11 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:unreachable pattern\n-\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![allow(dead_code)]\n+#![deny(unreachable_patterns)]\n+\n+enum Foo { A(Box<Foo>, isize), B(usize), }\n \n-enum foo { a(Box<foo>, isize), b(usize), }\n+fn main() {\n+    match Foo::B(1) {\n+        Foo::B(_) | Foo::A(box _, 1) => { }\n+        Foo::A(_, 1) => { } //~ ERROR unreachable pattern\n+        _ => { }\n+    }\n+}\n \n-fn main() { match foo::b(1) { foo::b(_) | foo::a(box _, 1) => { } foo::a(_, 1) => { } } }"}, {"sha": "23705d36e3de2fc87c4b80371ddd1b27bdc0f858", "filename": "src/test/run-pass/empty-types-in-patterns.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Frun-pass%2Fempty-types-in-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Frun-pass%2Fempty-types-in-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-types-in-patterns.rs?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+#![feature(slice_patterns)]\n+#![allow(unreachable_patterns)]\n+#![allow(unreachable_code)]\n+\n+#[allow(dead_code)]\n+fn foo(z: !) {\n+    let x: Result<!, !> = Ok(z);\n+\n+    let Ok(_y) = x;\n+    let Err(_y) = x;\n+\n+    let x = [z; 1];\n+\n+    match x {};\n+    match x {\n+        [q] => q,\n+    };\n+}\n+\n+fn bar(nevers: &[!]) {\n+    match nevers {\n+        &[]  => (),\n+    };\n+\n+    match nevers {\n+        &[]  => (),\n+        &[_]  => (),\n+        &[_, _, _, ..]  => (),\n+    };\n+}\n+\n+fn main() {\n+    let x: Result<u32, !> = Ok(123);\n+    let Ok(y) = x;\n+\n+    assert_eq!(123, y);\n+\n+    match x {\n+        Ok(y) => y,\n+    };\n+\n+    match x {\n+        Ok(y) => y,\n+        Err(e) => match e {},\n+    };\n+\n+    bar(&[]);\n+}\n+"}, {"sha": "0aafe3f17b3d0f6310b30d10baedc9eb00d19cef", "filename": "src/test/ui/check_match/issue-35609.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f1ae663ef21602841173c0b9549347904e3c9a8/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.stderr?ref=6f1ae663ef21602841173c0b9549347904e3c9a8", "patch": "@@ -4,11 +4,11 @@ error[E0004]: non-exhaustive patterns: `(B, _)`, `(C, _)`, `(D, _)` and 2 more n\n 20 |     match (A, ()) {\n    |           ^^^^^^^ patterns `(B, _)`, `(C, _)`, `(D, _)` and 2 more not covered\n \n-error[E0004]: non-exhaustive patterns: `(A, B)`, `(B, B)`, `(C, B)` and 27 more not covered\n+error[E0004]: non-exhaustive patterns: `(_, B)`, `(_, C)`, `(_, D)` and 2 more not covered\n   --> $DIR/issue-35609.rs:24:11\n    |\n 24 |     match (A, A) {\n-   |           ^^^^^^ patterns `(A, B)`, `(B, B)`, `(C, B)` and 27 more not covered\n+   |           ^^^^^^ patterns `(_, B)`, `(_, C)`, `(_, D)` and 2 more not covered\n \n error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:28:11"}]}