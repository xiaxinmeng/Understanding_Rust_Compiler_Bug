{"sha": "ac3844a0bb9a13260bf211354dbc014e892d7491", "node_id": "C_kwDOAAsO6NoAKGFjMzg0NGEwYmI5YTEzMjYwYmYyMTEzNTRkYmMwMTRlODkyZDc0OTE", "commit": {"author": {"name": "Daniel Eades", "email": "danieleades@hotmail.com", "date": "2023-01-10T18:48:51Z"}, "committer": {"name": "Daniel Eades", "email": "danieleades@hotmail.com", "date": "2023-01-10T18:48:51Z"}, "message": "a number of code simplifications", "tree": {"sha": "4410cf112ab92dddf865fc37030983ed168a3124", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4410cf112ab92dddf865fc37030983ed168a3124"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac3844a0bb9a13260bf211354dbc014e892d7491", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac3844a0bb9a13260bf211354dbc014e892d7491", "html_url": "https://github.com/rust-lang/rust/commit/ac3844a0bb9a13260bf211354dbc014e892d7491", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac3844a0bb9a13260bf211354dbc014e892d7491/comments", "author": {"login": "danieleades", "id": 33452915, "node_id": "MDQ6VXNlcjMzNDUyOTE1", "avatar_url": "https://avatars.githubusercontent.com/u/33452915?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danieleades", "html_url": "https://github.com/danieleades", "followers_url": "https://api.github.com/users/danieleades/followers", "following_url": "https://api.github.com/users/danieleades/following{/other_user}", "gists_url": "https://api.github.com/users/danieleades/gists{/gist_id}", "starred_url": "https://api.github.com/users/danieleades/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danieleades/subscriptions", "organizations_url": "https://api.github.com/users/danieleades/orgs", "repos_url": "https://api.github.com/users/danieleades/repos", "events_url": "https://api.github.com/users/danieleades/events{/privacy}", "received_events_url": "https://api.github.com/users/danieleades/received_events", "type": "User", "site_admin": false}, "committer": {"login": "danieleades", "id": 33452915, "node_id": "MDQ6VXNlcjMzNDUyOTE1", "avatar_url": "https://avatars.githubusercontent.com/u/33452915?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danieleades", "html_url": "https://github.com/danieleades", "followers_url": "https://api.github.com/users/danieleades/followers", "following_url": "https://api.github.com/users/danieleades/following{/other_user}", "gists_url": "https://api.github.com/users/danieleades/gists{/gist_id}", "starred_url": "https://api.github.com/users/danieleades/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danieleades/subscriptions", "organizations_url": "https://api.github.com/users/danieleades/orgs", "repos_url": "https://api.github.com/users/danieleades/repos", "events_url": "https://api.github.com/users/danieleades/events{/privacy}", "received_events_url": "https://api.github.com/users/danieleades/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3987c835f204a064fd28d21b59aecd2c72f5d0d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3987c835f204a064fd28d21b59aecd2c72f5d0d0", "html_url": "https://github.com/rust-lang/rust/commit/3987c835f204a064fd28d21b59aecd2c72f5d0d0"}], "stats": {"total": 223, "additions": 99, "deletions": 124}, "files": [{"sha": "41783081ecd7a93ef12903098fc9c534026ada33", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -80,7 +80,7 @@ impl<'a> Write for Printer<'a> {\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n         for line in s.split_inclusive('\\n') {\n             if self.needs_indent {\n-                match self.buf.chars().rev().skip_while(|ch| *ch == ' ').next() {\n+                match self.buf.chars().rev().find(|ch| *ch != ' ') {\n                     Some('\\n') | None => {}\n                     _ => self.buf.push('\\n'),\n                 }"}, {"sha": "c69599079b5e3a4a800cdc0e269c1f8e40415ebf", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -1600,17 +1600,15 @@ impl ModCollector<'_, '_> {\n                         FunctionLoc { container, id: ItemTreeId::new(self.tree_id, id) }.intern(db);\n \n                     let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n-                    if self.def_collector.is_proc_macro {\n-                        if self.module_id == def_map.root {\n-                            if let Some(proc_macro) = attrs.parse_proc_macro_decl(&it.name) {\n-                                let crate_root = def_map.module_id(def_map.root);\n-                                self.def_collector.export_proc_macro(\n-                                    proc_macro,\n-                                    ItemTreeId::new(self.tree_id, id),\n-                                    fn_id,\n-                                    crate_root,\n-                                );\n-                            }\n+                    if self.def_collector.is_proc_macro && self.module_id == def_map.root {\n+                        if let Some(proc_macro) = attrs.parse_proc_macro_decl(&it.name) {\n+                            let crate_root = def_map.module_id(def_map.root);\n+                            self.def_collector.export_proc_macro(\n+                                proc_macro,\n+                                ItemTreeId::new(self.tree_id, id),\n+                                fn_id,\n+                                crate_root,\n+                            );\n                         }\n                     }\n "}, {"sha": "c1e165b6381e7fcfc1efd7272e2ab97b9e62f631", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -472,8 +472,8 @@ impl Module {\n         let def_map = self.id.def_map(db.upcast());\n         let children = def_map[self.id.local_id]\n             .children\n-            .iter()\n-            .map(|(_, module_id)| Module { id: def_map.module_id(*module_id) })\n+            .values()\n+            .map(|module_id| Module { id: def_map.module_id(*module_id) })\n             .collect::<Vec<_>>();\n         children.into_iter()\n     }"}, {"sha": "860372941f7948d2709ca0cd78591ac54c86fae9", "filename": "crates/ide-assists/src/handlers/generate_default_from_new.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -82,18 +82,18 @@ fn generate_trait_impl_text_from_impl(impl_: &ast::Impl, trait_text: &str, code:\n     let generic_params = impl_.generic_param_list().map(|generic_params| {\n         let lifetime_params =\n             generic_params.lifetime_params().map(ast::GenericParam::LifetimeParam);\n-        let ty_or_const_params = generic_params.type_or_const_params().filter_map(|param| {\n+        let ty_or_const_params = generic_params.type_or_const_params().map(|param| {\n             // remove defaults since they can't be specified in impls\n             match param {\n                 ast::TypeOrConstParam::Type(param) => {\n                     let param = param.clone_for_update();\n                     param.remove_default();\n-                    Some(ast::GenericParam::TypeParam(param))\n+                    ast::GenericParam::TypeParam(param)\n                 }\n                 ast::TypeOrConstParam::Const(param) => {\n                     let param = param.clone_for_update();\n                     param.remove_default();\n-                    Some(ast::GenericParam::ConstParam(param))\n+                    ast::GenericParam::ConstParam(param)\n                 }\n             }\n         });"}, {"sha": "d7ddc5f23f5dc5b3a743ad112482193d8e8954fd", "filename": "crates/ide-assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -92,7 +92,7 @@ trait Merge: AstNode + Clone {\n     fn try_merge_from(self, items: &mut dyn Iterator<Item = Self>) -> Option<Vec<Edit>> {\n         let mut edits = Vec::new();\n         let mut merged = self.clone();\n-        while let Some(item) = items.next() {\n+        for item in items {\n             merged = merged.try_merge(&item)?;\n             edits.push(Edit::Remove(item.into_either()));\n         }"}, {"sha": "db789cfa334289421d7c3f118c4a969c5398a791", "filename": "crates/ide-assists/src/handlers/unmerge_match_arm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_match_arm.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -86,8 +86,7 @@ pub(crate) fn unmerge_match_arm(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n                     it.prev_sibling_or_token()\n                 })\n                 .map(|it| it.kind())\n-                .skip_while(|it| it.is_trivia())\n-                .next()\n+                .find(|it| !it.is_trivia())\n                     == Some(T![,]);\n             let has_arms_after = neighbor(&match_arm, Direction::Next).is_some();\n             if !has_comma_after && !has_arms_after {"}, {"sha": "8f310b0f42fb029cdf0db819192c975c928c381f", "filename": "crates/ide-db/src/rename.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Frename.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -334,11 +334,9 @@ pub fn source_edit_from_references(\n             }\n             _ => false,\n         };\n-        if !has_emitted_edit {\n-            if !edited_ranges.contains(&range.start()) {\n-                edit.replace(range, new_name.to_string());\n-                edited_ranges.push(range.start());\n-            }\n+        if !has_emitted_edit && !edited_ranges.contains(&range.start()) {\n+            edit.replace(range, new_name.to_string());\n+            edited_ranges.push(range.start());\n         }\n     }\n "}, {"sha": "f6d4ccc3ce5af247b3200c7b2e3d7faa962499e5", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -494,41 +494,37 @@ impl<'a> FindUsages<'a> {\n         }\n \n         // Search for `super` and `crate` resolving to our module\n-        match self.def {\n-            Definition::Module(module) => {\n-                let scope = search_scope\n-                    .intersection(&SearchScope::module_and_children(self.sema.db, module));\n+        if let Definition::Module(module) = self.def {\n+            let scope =\n+                search_scope.intersection(&SearchScope::module_and_children(self.sema.db, module));\n \n-                let is_crate_root =\n-                    module.is_crate_root(self.sema.db).then(|| Finder::new(\"crate\"));\n-                let finder = &Finder::new(\"super\");\n+            let is_crate_root = module.is_crate_root(self.sema.db).then(|| Finder::new(\"crate\"));\n+            let finder = &Finder::new(\"super\");\n \n-                for (text, file_id, search_range) in scope_files(sema, &scope) {\n-                    let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n+            for (text, file_id, search_range) in scope_files(sema, &scope) {\n+                let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n+                for offset in match_indices(&text, finder, search_range) {\n+                    if let Some(iter) = find_nodes(\"super\", &tree, offset) {\n+                        for name_ref in iter.filter_map(ast::NameRef::cast) {\n+                            if self.found_name_ref(&name_ref, sink) {\n+                                return;\n+                            }\n+                        }\n+                    }\n+                }\n+                if let Some(finder) = &is_crate_root {\n                     for offset in match_indices(&text, finder, search_range) {\n-                        if let Some(iter) = find_nodes(\"super\", &tree, offset) {\n+                        if let Some(iter) = find_nodes(\"crate\", &tree, offset) {\n                             for name_ref in iter.filter_map(ast::NameRef::cast) {\n                                 if self.found_name_ref(&name_ref, sink) {\n                                     return;\n                                 }\n                             }\n                         }\n                     }\n-                    if let Some(finder) = &is_crate_root {\n-                        for offset in match_indices(&text, finder, search_range) {\n-                            if let Some(iter) = find_nodes(\"crate\", &tree, offset) {\n-                                for name_ref in iter.filter_map(ast::NameRef::cast) {\n-                                    if self.found_name_ref(&name_ref, sink) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n                 }\n             }\n-            _ => (),\n         }\n \n         // search for module `self` references in our module's definition source"}, {"sha": "04ce1e0feeed4f300f27807d19c3e5bf97cf1738", "filename": "crates/ide-diagnostics/src/handlers/json_is_not_rust.rs", "status": "modified", "additions": 56, "deletions": 66, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -99,76 +99,66 @@ pub(crate) fn json_in_items(\n             && node.last_token().map(|x| x.kind()) == Some(SyntaxKind::R_CURLY)\n         {\n             let node_string = node.to_string();\n-            if let Ok(it) = serde_json::from_str(&node_string) {\n-                if let serde_json::Value::Object(it) = it {\n-                    let import_scope = ImportScope::find_insert_use_container(node, sema)?;\n-                    let range = node.text_range();\n-                    let mut edit = TextEdit::builder();\n-                    edit.delete(range);\n-                    let mut state = State::default();\n-                    let semantics_scope = sema.scope(node)?;\n-                    let scope_resolve =\n-                        |it| semantics_scope.speculative_resolve(&make::path_from_text(it));\n-                    let scope_has = |it| scope_resolve(it).is_some();\n-                    let deserialize_resolved = scope_resolve(\"::serde::Deserialize\");\n-                    let serialize_resolved = scope_resolve(\"::serde::Serialize\");\n-                    state.has_deserialize = deserialize_resolved.is_some();\n-                    state.has_serialize = serialize_resolved.is_some();\n-                    state.build_struct(&it);\n-                    edit.insert(range.start(), state.result);\n-                    acc.push(\n-                        Diagnostic::new(\n-                            \"json-is-not-rust\",\n-                            \"JSON syntax is not valid as a Rust item\",\n-                            range,\n-                        )\n-                        .severity(Severity::WeakWarning)\n-                        .with_fixes(Some(vec![{\n-                            let mut scb = SourceChangeBuilder::new(file_id);\n-                            let scope = match import_scope {\n-                                ImportScope::File(it) => ImportScope::File(scb.make_mut(it)),\n-                                ImportScope::Module(it) => ImportScope::Module(scb.make_mut(it)),\n-                                ImportScope::Block(it) => ImportScope::Block(scb.make_mut(it)),\n-                            };\n-                            let current_module = semantics_scope.module();\n-                            if !scope_has(\"Serialize\") {\n-                                if let Some(PathResolution::Def(it)) = serialize_resolved {\n-                                    if let Some(it) = current_module.find_use_path_prefixed(\n-                                        sema.db,\n-                                        it,\n-                                        config.insert_use.prefix_kind,\n-                                        config.prefer_no_std,\n-                                    ) {\n-                                        insert_use(\n-                                            &scope,\n-                                            mod_path_to_ast(&it),\n-                                            &config.insert_use,\n-                                        );\n-                                    }\n+            if let Ok(serde_json::Value::Object(it)) = serde_json::from_str(&node_string) {\n+                let import_scope = ImportScope::find_insert_use_container(node, sema)?;\n+                let range = node.text_range();\n+                let mut edit = TextEdit::builder();\n+                edit.delete(range);\n+                let mut state = State::default();\n+                let semantics_scope = sema.scope(node)?;\n+                let scope_resolve =\n+                    |it| semantics_scope.speculative_resolve(&make::path_from_text(it));\n+                let scope_has = |it| scope_resolve(it).is_some();\n+                let deserialize_resolved = scope_resolve(\"::serde::Deserialize\");\n+                let serialize_resolved = scope_resolve(\"::serde::Serialize\");\n+                state.has_deserialize = deserialize_resolved.is_some();\n+                state.has_serialize = serialize_resolved.is_some();\n+                state.build_struct(&it);\n+                edit.insert(range.start(), state.result);\n+                acc.push(\n+                    Diagnostic::new(\n+                        \"json-is-not-rust\",\n+                        \"JSON syntax is not valid as a Rust item\",\n+                        range,\n+                    )\n+                    .severity(Severity::WeakWarning)\n+                    .with_fixes(Some(vec![{\n+                        let mut scb = SourceChangeBuilder::new(file_id);\n+                        let scope = match import_scope {\n+                            ImportScope::File(it) => ImportScope::File(scb.make_mut(it)),\n+                            ImportScope::Module(it) => ImportScope::Module(scb.make_mut(it)),\n+                            ImportScope::Block(it) => ImportScope::Block(scb.make_mut(it)),\n+                        };\n+                        let current_module = semantics_scope.module();\n+                        if !scope_has(\"Serialize\") {\n+                            if let Some(PathResolution::Def(it)) = serialize_resolved {\n+                                if let Some(it) = current_module.find_use_path_prefixed(\n+                                    sema.db,\n+                                    it,\n+                                    config.insert_use.prefix_kind,\n+                                    config.prefer_no_std,\n+                                ) {\n+                                    insert_use(&scope, mod_path_to_ast(&it), &config.insert_use);\n                                 }\n                             }\n-                            if !scope_has(\"Deserialize\") {\n-                                if let Some(PathResolution::Def(it)) = deserialize_resolved {\n-                                    if let Some(it) = current_module.find_use_path_prefixed(\n-                                        sema.db,\n-                                        it,\n-                                        config.insert_use.prefix_kind,\n-                                        config.prefer_no_std,\n-                                    ) {\n-                                        insert_use(\n-                                            &scope,\n-                                            mod_path_to_ast(&it),\n-                                            &config.insert_use,\n-                                        );\n-                                    }\n+                        }\n+                        if !scope_has(\"Deserialize\") {\n+                            if let Some(PathResolution::Def(it)) = deserialize_resolved {\n+                                if let Some(it) = current_module.find_use_path_prefixed(\n+                                    sema.db,\n+                                    it,\n+                                    config.insert_use.prefix_kind,\n+                                    config.prefer_no_std,\n+                                ) {\n+                                    insert_use(&scope, mod_path_to_ast(&it), &config.insert_use);\n                                 }\n                             }\n-                            let mut sc = scb.finish();\n-                            sc.insert_source_edit(file_id, edit.finish());\n-                            fix(\"convert_json_to_struct\", \"Convert JSON to struct\", sc, range)\n-                        }])),\n-                    );\n-                }\n+                        }\n+                        let mut sc = scb.finish();\n+                        sc.insert_source_edit(file_id, edit.finish());\n+                        fix(\"convert_json_to_struct\", \"Convert JSON to struct\", sc, range)\n+                    }])),\n+                );\n             }\n         }\n         Some(())"}, {"sha": "0b3121c765d8d2448f283a21d7d10259623c44e8", "filename": "crates/ide-diagnostics/src/handlers/private_assoc_item.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -11,10 +11,7 @@ pub(crate) fn private_assoc_item(\n     d: &hir::PrivateAssocItem,\n ) -> Diagnostic {\n     // FIXME: add quickfix\n-    let name = match d.item.name(ctx.sema.db) {\n-        Some(name) => format!(\"`{}` \", name),\n-        None => String::new(),\n-    };\n+    let name = d.item.name(ctx.sema.db).map(|name| format!(\"`{name}` \")).unwrap_or_default();\n     Diagnostic::new(\n         \"private-assoc-item\",\n         format!("}, {"sha": "9a984ba6bf07afadbe83427aa6e7aa0591664e78", "filename": "crates/ide-diagnostics/src/handlers/unresolved_proc_macro.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -34,10 +34,7 @@ pub(crate) fn unresolved_proc_macro(\n     let message = format!(\n         \"{message}: {}\",\n         if config_enabled {\n-            match def_map.proc_macro_loading_error() {\n-                Some(e) => e,\n-                None => \"proc macro not found in the built dylib\",\n-            }\n+            def_map.proc_macro_loading_error().unwrap_or(\"proc macro not found in the built dylib\")\n         } else {\n             match d.kind {\n                 hir::MacroKind::Attr if proc_macros_enabled => {"}, {"sha": "605ddd4a065d839019676b1de1901fe8a14fbddd", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -212,7 +212,7 @@ fn expand_var(ctx: &mut ExpandCtx<'_>, v: &SmolStr, id: tt::TokenId) -> ExpandRe\n     } else {\n         ctx.bindings.get(v, &mut ctx.nesting).map_or_else(\n             |e| ExpandResult { value: Fragment::Tokens(tt::TokenTree::empty()), err: Some(e) },\n-            |it| ExpandResult::ok(it),\n+            ExpandResult::ok,\n         )\n     }\n }"}, {"sha": "5ab767a0e5faf66cd626e5dba33e0a9a3d52269b", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3844a0bb9a13260bf211354dbc014e892d7491/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=ac3844a0bb9a13260bf211354dbc014e892d7491", "patch": "@@ -366,11 +366,11 @@ impl ProjectWorkspace {\n                 _ => None,\n             })\n             .collect();\n-        let ref mut outputs = match WorkspaceBuildScripts::run_once(config, &cargo_ws, progress) {\n+        let outputs = &mut (match WorkspaceBuildScripts::run_once(config, &cargo_ws, progress) {\n             Ok(it) => Ok(it.into_iter()),\n             // io::Error is not Clone?\n             Err(e) => Err(Arc::new(e)),\n-        };\n+        });\n \n         workspaces\n             .iter()"}]}