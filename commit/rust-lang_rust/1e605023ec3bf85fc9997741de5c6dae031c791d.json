{"sha": "1e605023ec3bf85fc9997741de5c6dae031c791d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNjA1MDIzZWMzYmY4NWZjOTk5Nzc0MWRlNWM2ZGFlMDMxYzc5MWQ=", "commit": {"author": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-08-17T18:41:29Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-08-18T05:00:27Z"}, "message": "Properly generate multiple candidates for trait upcasting coercion.", "tree": {"sha": "16202ad3545c19d7a0971551d73d56568e3a4006", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16202ad3545c19d7a0971551d73d56568e3a4006"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e605023ec3bf85fc9997741de5c6dae031c791d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e605023ec3bf85fc9997741de5c6dae031c791d", "html_url": "https://github.com/rust-lang/rust/commit/1e605023ec3bf85fc9997741de5c6dae031c791d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e605023ec3bf85fc9997741de5c6dae031c791d/comments", "author": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adf168844791b213383b18d10515eaee88695f7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/adf168844791b213383b18d10515eaee88695f7d", "html_url": "https://github.com/rust-lang/rust/commit/adf168844791b213383b18d10515eaee88695f7d"}], "stats": {"total": 314, "additions": 155, "deletions": 159}, "files": [{"sha": "3b7c201f3ee341773da8dc78f5962e828469400f", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e605023ec3bf85fc9997741de5c6dae031c791d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e605023ec3bf85fc9997741de5c6dae031c791d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=1e605023ec3bf85fc9997741de5c6dae031c791d", "patch": "@@ -135,6 +135,11 @@ pub enum SelectionCandidate<'tcx> {\n     /// `rustc_infer::traits::util::supertraits`.\n     ObjectCandidate(usize),\n \n+    /// Perform trait upcasting coercion of `dyn Trait` to a supertrait of `Trait`.\n+    /// The index is the position in the iterator returned by\n+    /// `rustc_infer::traits::util::supertraits`.\n+    TraitUpcastingUnsizeCandidate(usize),\n+\n     BuiltinObjectCandidate,\n \n     BuiltinUnsizeCandidate,"}, {"sha": "e18828fec3f6bf6aedaabb5ff8e5f605ae0ee007", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 47, "deletions": 13, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1e605023ec3bf85fc9997741de5c6dae031c791d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e605023ec3bf85fc9997741de5c6dae031c791d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=1e605023ec3bf85fc9997741de5c6dae031c791d", "patch": "@@ -690,46 +690,80 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?source, ?target, \"assemble_candidates_for_unsizing\");\n \n-        let may_apply = match (source.kind(), target.kind()) {\n+        match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n-                // See `confirm_builtin_unsize_candidate` for more info.\n+                // Upcast coercions permit several things:\n+                //\n+                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n+                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n+                // 3. Tightening trait to its super traits, eg. `Foo` to `Bar` if `Foo: Bar`\n+                //\n+                // Note that neither of the first two of these changes requires any\n+                // change at runtime. The third needs to change pointer metadata at runtime.\n+                //\n+                // We always perform upcasting coercions when we can because of reason\n+                // #2 (region bounds).\n                 let auto_traits_compatible = data_b\n                     .auto_traits()\n                     // All of a's auto traits need to be in b's auto traits.\n                     .all(|b| data_a.auto_traits().any(|a| a == b));\n-                auto_traits_compatible\n+                if auto_traits_compatible {\n+                    let principal_def_id_a = data_a.principal_def_id();\n+                    let principal_def_id_b = data_b.principal_def_id();\n+                    if principal_def_id_a == principal_def_id_b {\n+                        // no cyclic\n+                        candidates.vec.push(BuiltinUnsizeCandidate);\n+                    } else if principal_def_id_a.is_some() && principal_def_id_b.is_some() {\n+                        // not casual unsizing, now check whether this is trait upcasting coercion.\n+                        let principal_a = data_a.principal().unwrap();\n+                        let target_trait_did = principal_def_id_b.unwrap();\n+                        let source_trait_ref = principal_a.with_self_ty(self.tcx(), source);\n+                        for (idx, upcast_trait_ref) in\n+                            util::supertraits(self.tcx(), source_trait_ref).enumerate()\n+                        {\n+                            if upcast_trait_ref.def_id() == target_trait_did {\n+                                candidates.vec.push(TraitUpcastingUnsizeCandidate(idx));\n+                            }\n+                        }\n+                    }\n+                }\n             }\n \n             // `T` -> `Trait`\n-            (_, &ty::Dynamic(..)) => true,\n+            (_, &ty::Dynamic(..)) => {\n+                candidates.vec.push(BuiltinUnsizeCandidate);\n+            }\n \n             // Ambiguous handling is below `T` -> `Trait`, because inference\n             // variables can still implement `Unsize<Trait>` and nested\n             // obligations will have the final say (likely deferred).\n             (&ty::Infer(ty::TyVar(_)), _) | (_, &ty::Infer(ty::TyVar(_))) => {\n                 debug!(\"assemble_candidates_for_unsizing: ambiguous\");\n                 candidates.ambiguous = true;\n-                false\n             }\n \n             // `[T; n]` -> `[T]`\n-            (&ty::Array(..), &ty::Slice(_)) => true,\n+            (&ty::Array(..), &ty::Slice(_)) => {\n+                candidates.vec.push(BuiltinUnsizeCandidate);\n+            }\n \n             // `Struct<T>` -> `Struct<U>`\n             (&ty::Adt(def_id_a, _), &ty::Adt(def_id_b, _)) if def_id_a.is_struct() => {\n-                def_id_a == def_id_b\n+                if def_id_a == def_id_b {\n+                    candidates.vec.push(BuiltinUnsizeCandidate);\n+                }\n             }\n \n             // `(.., T)` -> `(.., U)`\n-            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => tys_a.len() == tys_b.len(),\n+            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n+                if tys_a.len() == tys_b.len() {\n+                    candidates.vec.push(BuiltinUnsizeCandidate);\n+                }\n+            }\n \n-            _ => false,\n+            _ => {}\n         };\n-\n-        if may_apply {\n-            candidates.vec.push(BuiltinUnsizeCandidate);\n-        }\n     }\n \n     fn assemble_candidates_for_trait_alias("}, {"sha": "9dc9c21b519573f5c9f1782c9d8e806d9f93db20", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 85, "deletions": 50, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/1e605023ec3bf85fc9997741de5c6dae031c791d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e605023ec3bf85fc9997741de5c6dae031c791d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=1e605023ec3bf85fc9997741de5c6dae031c791d", "patch": "@@ -118,6 +118,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let data = self.confirm_builtin_unsize_candidate(obligation)?;\n                 Ok(ImplSource::Builtin(data))\n             }\n+\n+            TraitUpcastingUnsizeCandidate(idx) => {\n+                let data = self.confirm_trait_upcasting_unsize_candidate(obligation, idx)?;\n+                Ok(ImplSource::Builtin(data))\n+            }\n         }\n     }\n \n@@ -685,9 +690,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n \n-    fn confirm_builtin_unsize_candidate(\n+    fn confirm_trait_upcasting_unsize_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n+        idx: usize,\n     ) -> Result<ImplSourceBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let tcx = self.tcx();\n \n@@ -697,62 +703,91 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n         let target = self.infcx.shallow_resolve(target);\n \n-        debug!(?source, ?target, \"confirm_builtin_unsize_candidate\");\n+        debug!(?source, ?target, \"confirm_trait_upcasting_unsize_candidate\");\n \n         let mut nested = vec![];\n         match (source.kind(), target.kind()) {\n-            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n+            // TraitA+Kx+'a -> TraitB+Ky+'b (trait upcasting coercion).\n             (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n-                // Upcast coercions permit several things:\n-                //\n-                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n-                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n-                // 3. Tightening trait to its super traits, eg. `Foo` to `Bar` if `Foo: Bar`\n-                //\n-                // Note that neither of the first two of these changes requires any\n-                // change at runtime. The third needs to change pointer metadata at runtime.\n-                //\n-                // We always perform upcasting coercions when we can because of reason\n-                // #2 (region bounds).\n-\n+                // See `assemble_candidates_for_unsizing` for more info.\n                 // We already checked the compatiblity of auto traits within `assemble_candidates_for_unsizing`.\n+                let principal_a = data_a.principal().unwrap();\n+                let source_trait_ref = principal_a.with_self_ty(tcx, source);\n+                let target_trait_ref = util::supertraits(tcx, source_trait_ref).nth(idx).unwrap();\n+                assert_eq!(data_b.principal_def_id(), Some(target_trait_ref.def_id()));\n+                let existential_predicate = target_trait_ref.map_bound(|trait_ref| {\n+                    ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef::erase_self_ty(\n+                        tcx, trait_ref,\n+                    ))\n+                });\n+                let iter = Some(existential_predicate)\n+                    .into_iter()\n+                    .chain(\n+                        data_a\n+                            .projection_bounds()\n+                            .map(|b| b.map_bound(ty::ExistentialPredicate::Projection)),\n+                    )\n+                    .chain(\n+                        data_b\n+                            .auto_traits()\n+                            .map(ty::ExistentialPredicate::AutoTrait)\n+                            .map(ty::Binder::dummy),\n+                    );\n+                let existential_predicates = tcx.mk_poly_existential_predicates(iter);\n+                let source_trait = tcx.mk_dynamic(existential_predicates, r_b);\n \n-                let principal_a = data_a.principal();\n-                let principal_def_id_b = data_b.principal_def_id();\n-\n-                let existential_predicate = if let Some(principal_a) = principal_a {\n-                    let source_trait_ref = principal_a.with_self_ty(tcx, source);\n-                    let target_trait_did = principal_def_id_b.ok_or_else(|| Unimplemented)?;\n-                    let upcast_idx = util::supertraits(tcx, source_trait_ref)\n-                        .position(|upcast_trait_ref| upcast_trait_ref.def_id() == target_trait_did)\n-                        .ok_or_else(|| Unimplemented)?;\n-                    // FIXME(crlf0710): This is less than ideal, for example,\n-                    // if the trait is defined as `trait Foo: Bar<u32> + Bar<i32>`,\n-                    // the coercion from Box<Foo> to Box<dyn Bar<_>> is actually ambiguous.\n-                    // We currently make this coercion fail for now.\n-                    //\n-                    // see #65991 for more information.\n-                    if util::supertraits(tcx, source_trait_ref)\n-                        .skip(upcast_idx + 1)\n-                        .any(|upcast_trait_ref| upcast_trait_ref.def_id() == target_trait_did)\n-                    {\n-                        return Err(Unimplemented);\n-                    }\n-                    let target_trait_ref =\n-                        util::supertraits(tcx, source_trait_ref).nth(upcast_idx).unwrap();\n-                    let existential_predicate = target_trait_ref.map_bound(|trait_ref| {\n-                        ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef::erase_self_ty(\n-                            tcx, trait_ref,\n-                        ))\n-                    });\n-                    Some(existential_predicate)\n-                } else if principal_def_id_b.is_none() {\n-                    None\n-                } else {\n-                    return Err(Unimplemented);\n-                };\n+                // Require that the traits involved in this upcast are **equal**;\n+                // only the **lifetime bound** is changed.\n+                let InferOk { obligations, .. } = self\n+                    .infcx\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .sup(target, source_trait)\n+                    .map_err(|_| Unimplemented)?;\n+                nested.extend(obligations);\n+\n+                // Register one obligation for 'a: 'b.\n+                let cause = ObligationCause::new(\n+                    obligation.cause.span,\n+                    obligation.cause.body_id,\n+                    ObjectCastObligation(target),\n+                );\n+                let outlives = ty::OutlivesPredicate(r_a, r_b);\n+                nested.push(Obligation::with_depth(\n+                    cause,\n+                    obligation.recursion_depth + 1,\n+                    obligation.param_env,\n+                    obligation.predicate.rebind(outlives).to_predicate(tcx),\n+                ));\n+            }\n+            _ => bug!(),\n+        };\n+\n+        Ok(ImplSourceBuiltinData { nested })\n+    }\n \n-                let iter = existential_predicate\n+    fn confirm_builtin_unsize_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> Result<ImplSourceBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        let tcx = self.tcx();\n+\n+        // `assemble_candidates_for_unsizing` should ensure there are no late-bound\n+        // regions here. See the comment there for more details.\n+        let source = self.infcx.shallow_resolve(obligation.self_ty().no_bound_vars().unwrap());\n+        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n+        let target = self.infcx.shallow_resolve(target);\n+\n+        debug!(?source, ?target, \"confirm_builtin_unsize_candidate\");\n+\n+        let mut nested = vec![];\n+        match (source.kind(), target.kind()) {\n+            // Trait+Kx+'a -> Trait+Ky+'b (auto traits and lifetime subtyping).\n+            (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n+                // See `assemble_candidates_for_unsizing` for more info.\n+                // We already checked the compatiblity of auto traits within `assemble_candidates_for_unsizing`.\n+                let iter = data_a\n+                    .principal()\n+                    .map(|b| b.map_bound(ty::ExistentialPredicate::Trait))\n                     .into_iter()\n                     .chain(\n                         data_a"}, {"sha": "6ef18034298fd90580091a956258ce3bbe2be9ce", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e605023ec3bf85fc9997741de5c6dae031c791d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e605023ec3bf85fc9997741de5c6dae031c791d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=1e605023ec3bf85fc9997741de5c6dae031c791d", "patch": "@@ -1500,6 +1500,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n+                | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..)\n                 | ObjectCandidate(_)\n@@ -1517,6 +1518,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n+                | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate(..),\n                 ParamCandidate(ref cand),\n@@ -1546,6 +1548,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n+                | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..),\n             ) => true,\n@@ -1557,6 +1560,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n+                | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..),\n                 ObjectCandidate(_) | ProjectionCandidate(_),\n@@ -1630,6 +1634,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n+                | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate(..),\n                 ImplCandidate(_)\n@@ -1638,6 +1643,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n+                | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate(..),\n             ) => false,"}, {"sha": "79ddedd4187560fbfe8e4c2e44da0e170545f552", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-1.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e605023ec3bf85fc9997741de5c6dae031c791d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e605023ec3bf85fc9997741de5c6dae031c791d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.rs?ref=1e605023ec3bf85fc9997741de5c6dae031c791d", "patch": "@@ -9,12 +9,8 @@ trait Bar<T> {\n }\n \n fn test_specific(x: &dyn Foo) {\n-    let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n-                                //~^ ERROR non-primitive cast\n-                                //~^^ ERROR the trait bound `&dyn Foo: Bar<i32>` is not satisfied\n-    let _ = x as &dyn Bar<u32>; // FIXME: OK, eventually\n-                                //~^ ERROR non-primitive cast\n-                                //~^^ ERROR the trait bound `&dyn Foo: Bar<u32>` is not satisfied\n+    let _ = x as &dyn Bar<i32>; // OK\n+    let _ = x as &dyn Bar<u32>; // OK\n }\n \n fn test_unknown_version(x: &dyn Foo) {\n@@ -24,9 +20,7 @@ fn test_unknown_version(x: &dyn Foo) {\n }\n \n fn test_infer_version(x: &dyn Foo) {\n-    let a = x as &dyn Bar<_>; // FIXME: OK, eventually\n-                              //~^ ERROR non-primitive cast\n-                              //~^^ ERROR the trait bound `&dyn Foo: Bar<u32>` is not satisfied\n+    let a = x as &dyn Bar<_>; // OK\n     let _: Option<u32> = a.bar();\n }\n "}, {"sha": "44f32e0cec91ced2dedb7b3271b36fe4932fdb2a", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-1.stderr", "status": "modified", "additions": 3, "deletions": 60, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1e605023ec3bf85fc9997741de5c6dae031c791d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e605023ec3bf85fc9997741de5c6dae031c791d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.stderr?ref=1e605023ec3bf85fc9997741de5c6dae031c791d", "patch": "@@ -1,43 +1,5 @@\n-error[E0605]: non-primitive cast: `&dyn Foo` as `&dyn Bar<i32>`\n-  --> $DIR/type-checking-test-1.rs:12:13\n-   |\n-LL |     let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n-   |             ^^^^^^^^^^^^^^^^^^ invalid cast\n-   |\n-help: consider borrowing the value\n-   |\n-LL |     let _ = &x as &dyn Bar<i32>; // FIXME: OK, eventually\n-   |             +\n-\n-error[E0605]: non-primitive cast: `&dyn Foo` as `&dyn Bar<u32>`\n-  --> $DIR/type-checking-test-1.rs:15:13\n-   |\n-LL |     let _ = x as &dyn Bar<u32>; // FIXME: OK, eventually\n-   |             ^^^^^^^^^^^^^^^^^^ invalid cast\n-   |\n-help: consider borrowing the value\n-   |\n-LL |     let _ = &x as &dyn Bar<u32>; // FIXME: OK, eventually\n-   |             +\n-\n-error[E0277]: the trait bound `&dyn Foo: Bar<i32>` is not satisfied\n-  --> $DIR/type-checking-test-1.rs:12:13\n-   |\n-LL |     let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n-   |             ^ the trait `Bar<i32>` is not implemented for `&dyn Foo`\n-   |\n-   = note: required for the cast to the object type `dyn Bar<i32>`\n-\n-error[E0277]: the trait bound `&dyn Foo: Bar<u32>` is not satisfied\n-  --> $DIR/type-checking-test-1.rs:15:13\n-   |\n-LL |     let _ = x as &dyn Bar<u32>; // FIXME: OK, eventually\n-   |             ^ the trait `Bar<u32>` is not implemented for `&dyn Foo`\n-   |\n-   = note: required for the cast to the object type `dyn Bar<u32>`\n-\n error[E0605]: non-primitive cast: `&dyn Foo` as `&dyn Bar<_>`\n-  --> $DIR/type-checking-test-1.rs:21:13\n+  --> $DIR/type-checking-test-1.rs:17:13\n    |\n LL |     let _ = x as &dyn Bar<_>; // Ambiguous\n    |             ^^^^^^^^^^^^^^^^ invalid cast\n@@ -48,33 +10,14 @@ LL |     let _ = &x as &dyn Bar<_>; // Ambiguous\n    |             +\n \n error[E0277]: the trait bound `&dyn Foo: Bar<_>` is not satisfied\n-  --> $DIR/type-checking-test-1.rs:21:13\n+  --> $DIR/type-checking-test-1.rs:17:13\n    |\n LL |     let _ = x as &dyn Bar<_>; // Ambiguous\n    |             ^ the trait `Bar<_>` is not implemented for `&dyn Foo`\n    |\n    = note: required for the cast to the object type `dyn Bar<_>`\n \n-error[E0605]: non-primitive cast: `&dyn Foo` as `&dyn Bar<u32>`\n-  --> $DIR/type-checking-test-1.rs:27:13\n-   |\n-LL |     let a = x as &dyn Bar<_>; // FIXME: OK, eventually\n-   |             ^^^^^^^^^^^^^^^^ invalid cast\n-   |\n-help: consider borrowing the value\n-   |\n-LL |     let a = &x as &dyn Bar<_>; // FIXME: OK, eventually\n-   |             +\n-\n-error[E0277]: the trait bound `&dyn Foo: Bar<u32>` is not satisfied\n-  --> $DIR/type-checking-test-1.rs:27:13\n-   |\n-LL |     let a = x as &dyn Bar<_>; // FIXME: OK, eventually\n-   |             ^ the trait `Bar<u32>` is not implemented for `&dyn Foo`\n-   |\n-   = note: required for the cast to the object type `dyn Bar<u32>`\n-\n-error: aborting due to 8 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0277, E0605.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "32754c53803786ca145e63e56f00356f7f53b2a5", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e605023ec3bf85fc9997741de5c6dae031c791d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e605023ec3bf85fc9997741de5c6dae031c791d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.rs?ref=1e605023ec3bf85fc9997741de5c6dae031c791d", "patch": "@@ -13,9 +13,7 @@ fn test_specific(x: &dyn Foo<i32>) {\n }\n \n fn test_specific2(x: &dyn Foo<u32>) {\n-    let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n-                                //~^ ERROR non-primitive cast\n-                                //~^^ ERROR the trait bound `&dyn Foo<u32>: Bar<i32>` is not satisfied\n+    let _ = x as &dyn Bar<i32>; // OK\n }\n \n fn test_specific3(x: &dyn Foo<i32>) {"}, {"sha": "4ae4c8552c16130523c4071ba8dfb0a578e7999d", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-2.stderr", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1e605023ec3bf85fc9997741de5c6dae031c791d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e605023ec3bf85fc9997741de5c6dae031c791d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.stderr?ref=1e605023ec3bf85fc9997741de5c6dae031c791d", "patch": "@@ -1,24 +1,5 @@\n-error[E0605]: non-primitive cast: `&dyn Foo<u32>` as `&dyn Bar<i32>`\n-  --> $DIR/type-checking-test-2.rs:16:13\n-   |\n-LL |     let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n-   |             ^^^^^^^^^^^^^^^^^^ invalid cast\n-   |\n-help: consider borrowing the value\n-   |\n-LL |     let _ = &x as &dyn Bar<i32>; // FIXME: OK, eventually\n-   |             +\n-\n-error[E0277]: the trait bound `&dyn Foo<u32>: Bar<i32>` is not satisfied\n-  --> $DIR/type-checking-test-2.rs:16:13\n-   |\n-LL |     let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n-   |             ^ the trait `Bar<i32>` is not implemented for `&dyn Foo<u32>`\n-   |\n-   = note: required for the cast to the object type `dyn Bar<i32>`\n-\n error[E0605]: non-primitive cast: `&dyn Foo<i32>` as `&dyn Bar<u32>`\n-  --> $DIR/type-checking-test-2.rs:22:13\n+  --> $DIR/type-checking-test-2.rs:20:13\n    |\n LL |     let _ = x as &dyn Bar<u32>; // Error\n    |             ^^^^^^^^^^^^^^^^^^ invalid cast\n@@ -29,15 +10,15 @@ LL |     let _ = &x as &dyn Bar<u32>; // Error\n    |             +\n \n error[E0277]: the trait bound `&dyn Foo<i32>: Bar<u32>` is not satisfied\n-  --> $DIR/type-checking-test-2.rs:22:13\n+  --> $DIR/type-checking-test-2.rs:20:13\n    |\n LL |     let _ = x as &dyn Bar<u32>; // Error\n    |             ^ the trait `Bar<u32>` is not implemented for `&dyn Foo<i32>`\n    |\n    = note: required for the cast to the object type `dyn Bar<u32>`\n \n error[E0605]: non-primitive cast: `&dyn Foo<u32>` as `&dyn Bar<_>`\n-  --> $DIR/type-checking-test-2.rs:28:13\n+  --> $DIR/type-checking-test-2.rs:26:13\n    |\n LL |     let a = x as &dyn Bar<_>; // Ambiguous\n    |             ^^^^^^^^^^^^^^^^ invalid cast\n@@ -48,14 +29,14 @@ LL |     let a = &x as &dyn Bar<_>; // Ambiguous\n    |             +\n \n error[E0277]: the trait bound `&dyn Foo<u32>: Bar<_>` is not satisfied\n-  --> $DIR/type-checking-test-2.rs:28:13\n+  --> $DIR/type-checking-test-2.rs:26:13\n    |\n LL |     let a = x as &dyn Bar<_>; // Ambiguous\n    |             ^ the trait `Bar<_>` is not implemented for `&dyn Foo<u32>`\n    |\n    = note: required for the cast to the object type `dyn Bar<_>`\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0277, E0605.\n For more information about an error, try `rustc --explain E0277`."}]}