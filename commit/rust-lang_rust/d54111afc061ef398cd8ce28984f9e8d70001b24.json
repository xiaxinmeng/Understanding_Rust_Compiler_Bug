{"sha": "d54111afc061ef398cd8ce28984f9e8d70001b24", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NDExMWFmYzA2MWVmMzk4Y2Q4Y2UyODk4NGY5ZThkNzAwMDFiMjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-25T00:40:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-25T00:40:55Z"}, "message": "Auto merge of #65771 - Centril:rollup-upfsvrb, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #65625 (Turn crate store into a resolver output)\n - #65627 (Forbid non-`structural_match` types in const generics)\n - #65710 (Update cargo)\n - #65729 (Update test cases for vxWorks)\n - #65746 (Tweak format string error to point at arguments always)\n - #65753 (Don't assert for different instance on impl trait alias)\n - #65755 (Avoid ICE when adjusting bad self ty)\n - #65766 (Update hashbrown to 0.6.2)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "4e68a43ce1cde8526dd1ce1229ed297a8182a1b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e68a43ce1cde8526dd1ce1229ed297a8182a1b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d54111afc061ef398cd8ce28984f9e8d70001b24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d54111afc061ef398cd8ce28984f9e8d70001b24", "html_url": "https://github.com/rust-lang/rust/commit/d54111afc061ef398cd8ce28984f9e8d70001b24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d54111afc061ef398cd8ce28984f9e8d70001b24/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10a52c25cad963986cace7a22c167363afca0d74", "url": "https://api.github.com/repos/rust-lang/rust/commits/10a52c25cad963986cace7a22c167363afca0d74", "html_url": "https://github.com/rust-lang/rust/commit/10a52c25cad963986cace7a22c167363afca0d74"}, {"sha": "fd6795b46a249d33c0127f77e08019b401a67fc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6795b46a249d33c0127f77e08019b401a67fc5", "html_url": "https://github.com/rust-lang/rust/commit/fd6795b46a249d33c0127f77e08019b401a67fc5"}], "stats": {"total": 1361, "additions": 719, "deletions": 642}, "files": [{"sha": "fb81c0637cca9f94387e26786cae53bebcc46a68", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -1297,9 +1297,9 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.6.1\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6587d09be37fb98a11cb08b9000a3f592451c1b1b613ca69d949160e313a430a\"\n+checksum = \"3cd9867f119b19fecb08cd5c326ad4488d7a1da4bf75b4d95d71db742525aaab\"\n dependencies = [\n  \"autocfg\",\n  \"compiler_builtins\",\n@@ -4146,7 +4146,7 @@ dependencies = [\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n- \"hashbrown 0.6.1\",\n+ \"hashbrown 0.6.2\",\n  \"libc\",\n  \"panic_abort\",\n  \"panic_unwind\","}, {"sha": "002e6874466bbd12321c6256411c24d1499879c2", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -83,8 +83,6 @@ pub struct LoweringContext<'a> {\n     /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n-    cstore: &'a dyn CrateStore,\n-\n     resolver: &'a mut dyn Resolver,\n \n     /// HACK(Centril): there is a cyclic dependency between the parser and lowering\n@@ -160,6 +158,8 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n+    fn cstore(&self) -> &dyn CrateStore;\n+\n     /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n@@ -240,7 +240,6 @@ impl<'a> ImplTraitContext<'a> {\n \n pub fn lower_crate(\n     sess: &Session,\n-    cstore: &dyn CrateStore,\n     dep_graph: &DepGraph,\n     krate: &Crate,\n     resolver: &mut dyn Resolver,\n@@ -256,7 +255,6 @@ pub fn lower_crate(\n     LoweringContext {\n         crate_root: sess.parse_sess.injected_crate_name.try_get().copied(),\n         sess,\n-        cstore,\n         resolver,\n         nt_to_tokenstream,\n         items: BTreeMap::new(),\n@@ -980,7 +978,7 @@ impl<'a> LoweringContext<'a> {\n         if id.is_local() {\n             self.resolver.definitions().def_key(id.index)\n         } else {\n-            self.cstore.def_key(id)\n+            self.resolver.cstore().def_key(id)\n         }\n     }\n \n@@ -1727,8 +1725,8 @@ impl<'a> LoweringContext<'a> {\n                             return n;\n                         }\n                         assert!(!def_id.is_local());\n-                        let item_generics =\n-                            self.cstore.item_generics_cloned_untracked(def_id, self.sess);\n+                        let item_generics = self.resolver.cstore()\n+                            .item_generics_cloned_untracked(def_id, self.sess);\n                         let n = item_generics.own_counts().lifetimes;\n                         self.type_def_lifetime_params.insert(def_id, n);\n                         n"}, {"sha": "d5558db2397e797cd14f4297ebc0bc1a07fa2eb1", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -16,7 +16,7 @@ use syntax::ast;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_target::spec::Target;\n-use rustc_data_structures::sync::{self, MetadataRef, Lrc};\n+use rustc_data_structures::sync::{self, MetadataRef};\n use rustc_macros::HashStable;\n \n pub use self::NativeLibraryKind::*;\n@@ -191,6 +191,8 @@ pub trait MetadataLoader {\n                           -> Result<MetadataRef, String>;\n }\n \n+pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n+\n /// A store of Rust crates, through which their metadata can be accessed.\n ///\n /// Note that this trait should probably not be expanding today. All new\n@@ -201,13 +203,13 @@ pub trait MetadataLoader {\n /// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n /// during resolve)\n pub trait CrateStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<dyn Any>;\n+    fn crate_data_as_any(&self, cnum: CrateNum) -> &dyn Any;\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn def_path_hash(&self, def: DefId) -> hir_map::DefPathHash;\n-    fn def_path_table(&self, cnum: CrateNum) -> Lrc<DefPathTable>;\n+    fn def_path_table(&self, cnum: CrateNum) -> &DefPathTable;\n \n     // \"queries\" used in resolve that aren't tracked for incremental compilation\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;"}, {"sha": "f99298281fecc5e5b7e203d5827ca148e955a4e8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -1027,7 +1027,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     interners: CtxtInterners<'tcx>,\n \n-    cstore: &'tcx CrateStoreDyn,\n+    cstore: Box<CrateStoreDyn>,\n \n     pub sess: &'tcx Session,\n \n@@ -1195,11 +1195,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn create_global_ctxt(\n         s: &'tcx Session,\n         lint_store: Lrc<lint::LintStore>,\n-        cstore: &'tcx CrateStoreDyn,\n         local_providers: ty::query::Providers<'tcx>,\n         extern_providers: ty::query::Providers<'tcx>,\n         arenas: &'tcx AllArenas,\n-        resolutions: ty::Resolutions,\n+        resolutions: ty::ResolverOutputs,\n         hir: hir_map::Map<'tcx>,\n         on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n         crate_name: &str,\n@@ -1213,34 +1212,28 @@ impl<'tcx> TyCtxt<'tcx> {\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n         let dep_graph = hir.dep_graph.clone();\n-        let max_cnum = cstore.crates_untracked().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n+        let cstore = resolutions.cstore;\n+        let crates = cstore.crates_untracked();\n+        let max_cnum = crates.iter().map(|c| c.as_usize()).max().unwrap_or(0);\n         let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n         providers[LOCAL_CRATE] = local_providers;\n \n         let def_path_hash_to_def_id = if s.opts.build_dep_graph() {\n-            let upstream_def_path_tables: Vec<(CrateNum, Lrc<_>)> = cstore\n-                .crates_untracked()\n+            let def_path_tables = crates\n                 .iter()\n                 .map(|&cnum| (cnum, cstore.def_path_table(cnum)))\n-                .collect();\n-\n-            let def_path_tables = || {\n-                upstream_def_path_tables\n-                    .iter()\n-                    .map(|&(cnum, ref rc)| (cnum, &**rc))\n-                    .chain(iter::once((LOCAL_CRATE, hir.definitions().def_path_table())))\n-            };\n+                .chain(iter::once((LOCAL_CRATE, hir.definitions().def_path_table())));\n \n             // Precompute the capacity of the hashmap so we don't have to\n             // re-allocate when populating it.\n-            let capacity = def_path_tables().map(|(_, t)| t.size()).sum::<usize>();\n+            let capacity = def_path_tables.clone().map(|(_, t)| t.size()).sum::<usize>();\n \n             let mut map: FxHashMap<_, _> = FxHashMap::with_capacity_and_hasher(\n                 capacity,\n                 ::std::default::Default::default()\n             );\n \n-            for (cnum, def_path_table) in def_path_tables() {\n+            for (cnum, def_path_table) in def_path_tables {\n                 def_path_table.add_def_path_hashes_to(cnum, &mut map);\n             }\n \n@@ -1417,8 +1410,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n-    pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Lrc<dyn Any> {\n-        self.cstore.crate_data_as_rc_any(cnum)\n+    pub fn crate_data_as_any(self, cnum: CrateNum) -> &'tcx dyn Any {\n+        self.cstore.crate_data_as_any(cnum)\n     }\n \n     #[inline(always)]\n@@ -1428,7 +1421,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         StableHashingContext::new(self.sess,\n                                   krate,\n                                   self.hir().definitions(),\n-                                  self.cstore)\n+                                  &*self.cstore)\n     }\n \n     // This method makes sure that we have a DepNode and a Fingerprint for"}, {"sha": "4660e8025d48ef9a1a0a048121b646dff50be094", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 129, "deletions": 4, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -4,7 +4,7 @@ pub use self::Variance::*;\n pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n-pub use self::fold::TypeFoldable;\n+pub use self::fold::{TypeFoldable, TypeVisitor};\n \n use crate::hir::{map as hir_map, GlobMap, TraitMap};\n use crate::hir::Node;\n@@ -15,6 +15,7 @@ use rustc_macros::HashStable;\n use crate::ich::Fingerprint;\n use crate::ich::StableHashingContext;\n use crate::infer::canonical::Canonical;\n+use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n use crate::mir::Body;\n@@ -50,7 +51,7 @@ use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n \n use smallvec;\n-use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_index::vec::{Idx, IndexVec};\n \n@@ -119,8 +120,9 @@ mod sty;\n \n // Data types\n \n-#[derive(Clone)]\n-pub struct Resolutions {\n+pub struct ResolverOutputs {\n+    pub definitions: hir_map::Definitions,\n+    pub cstore: Box<CrateStoreDyn>,\n     pub extern_crate_map: NodeMap<CrateNum>,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n@@ -3393,6 +3395,129 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n     fn_like.asyncness()\n }\n \n+pub enum NonStructuralMatchTy<'tcx> {\n+    Adt(&'tcx AdtDef),\n+    Param,\n+}\n+\n+/// This method traverses the structure of `ty`, trying to find an\n+/// instance of an ADT (i.e. struct or enum) that was declared without\n+/// the `#[structural_match]` attribute, or a generic type parameter\n+/// (which cannot be determined to be `structural_match`).\n+///\n+/// The \"structure of a type\" includes all components that would be\n+/// considered when doing a pattern match on a constant of that\n+/// type.\n+///\n+///  * This means this method descends into fields of structs/enums,\n+///    and also descends into the inner type `T` of `&T` and `&mut T`\n+///\n+///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n+///    `*mut T`), and it does not visit the type arguments of an\n+///    instantiated generic like `PhantomData<T>`.\n+///\n+/// The reason we do this search is Rust currently require all ADTs\n+/// reachable from a constant's type to be annotated with\n+/// `#[structural_match]`, an attribute which essentially says that\n+/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n+/// comparison against the unfolded structure.\n+///\n+/// For more background on why Rust has this requirement, and issues\n+/// that arose when the requirement was not enforced completely, see\n+/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n+pub fn search_for_structural_match_violation<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<NonStructuralMatchTy<'tcx>> {\n+    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n+    ty.visit_with(&mut search);\n+    return search.found;\n+\n+    struct Search<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+\n+        // Records the first ADT or type parameter we find without `#[structural_match`.\n+        found: Option<NonStructuralMatchTy<'tcx>>,\n+\n+        // Tracks ADTs previously encountered during search, so that\n+        // we will not recurse on them again.\n+        seen: FxHashSet<hir::def_id::DefId>,\n+    }\n+\n+    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n+        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+            debug!(\"Search visiting ty: {:?}\", ty);\n+\n+            let (adt_def, substs) = match ty.kind {\n+                ty::Adt(adt_def, substs) => (adt_def, substs),\n+                ty::Param(_) => {\n+                    self.found = Some(NonStructuralMatchTy::Param);\n+                    return true; // Stop visiting.\n+                }\n+                ty::RawPtr(..) => {\n+                    // `#[structural_match]` ignores substructure of\n+                    // `*const _`/`*mut _`, so skip super_visit_with\n+                    //\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::FnDef(..) | ty::FnPtr(..) => {\n+                    // types of formals and return in `fn(_) -> _` are also irrelevant\n+                    //\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n+                => {\n+                    // rust-lang/rust#62336: ignore type of contents\n+                    // for empty array.\n+                    return false;\n+                }\n+                _ => {\n+                    ty.super_visit_with(self);\n+                    return false;\n+                }\n+            };\n+\n+            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n+                self.found = Some(NonStructuralMatchTy::Adt(&adt_def));\n+                debug!(\"Search found adt_def: {:?}\", adt_def);\n+                return true; // Stop visiting.\n+            }\n+\n+            if !self.seen.insert(adt_def.did) {\n+                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n+                // let caller continue its search\n+                return false;\n+            }\n+\n+            // `#[structural_match]` does not care about the\n+            // instantiation of the generics in an ADT (it\n+            // instead looks directly at its fields outside\n+            // this match), so we skip super_visit_with.\n+            //\n+            // (Must not recur on substs for `PhantomData<T>` cf\n+            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n+            // want to skip substs when only uses of generic are\n+            // behind unsafe pointers `*const T`/`*mut T`.)\n+\n+            // even though we skip super_visit_with, we must recur on\n+            // fields of ADT.\n+            let tcx = self.tcx;\n+            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n+                if field_ty.visit_with(self) {\n+                    // found an ADT without `#[structural_match]`; halt visiting!\n+                    assert!(self.found.is_some());\n+                    return true;\n+                }\n+            }\n+\n+            // Even though we do not want to recur on substs, we do\n+            // want our caller to continue its own search.\n+            false\n+        }\n+    }\n+}\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);"}, {"sha": "1da65f4b51d36d083e7697d5cc6c135c61e3ba7c", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -557,10 +557,9 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         x.val\n     };\n \n-    // Currently, the values that can be unified are those that\n-    // implement both `PartialEq` and `Eq`, corresponding to\n-    // `structural_match` types.\n-    // FIXME(const_generics): check for `structural_match` synthetic attribute.\n+    // Currently, the values that can be unified are primitive types,\n+    // and those that derive both `PartialEq` and `Eq`, corresponding\n+    // to `structural_match` types.\n     let new_const_val = match (eagerly_eval(a), eagerly_eval(b)) {\n         (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n             // The caller should handle these cases!"}, {"sha": "e09b600afd4e5a4955bc76e0ef6a78f5f2de877d", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -56,7 +56,7 @@ use std::sync::Arc;\n use std::ffi::CStr;\n \n use rustc::dep_graph::DepGraph;\n-use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n use rustc::session::Session;\n use rustc::session::config::{OutputFilenames, OutputType, PrintRequest, OptLevel};\n use rustc::ty::{self, TyCtxt};\n@@ -260,7 +260,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n         target_features(sess)\n     }\n \n-    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n+    fn metadata_loader(&self) -> Box<MetadataLoaderDyn> {\n         box metadata::LlvmMetadataLoader\n     }\n "}, {"sha": "0e2c3731eae6d23b10751fc51a08779eb63c5960", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -14,7 +14,7 @@ use rustc::util::common::ErrorReported;\n use rustc::session::config::{OutputFilenames, PrintRequest};\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n use rustc::dep_graph::DepGraph;\n \n pub use rustc_data_structures::sync::MetadataRef;\n@@ -26,7 +26,7 @@ pub trait CodegenBackend {\n     fn print_passes(&self) {}\n     fn print_version(&self) {}\n \n-    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync>;\n+    fn metadata_loader(&self) -> Box<MetadataLoaderDyn>;\n     fn provide(&self, _providers: &mut Providers<'_>);\n     fn provide_extern(&self, _providers: &mut Providers<'_>);\n     fn codegen_crate<'tcx>("}, {"sha": "15adf7e4add73ac640d0514729ca8e9a4043a82f", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -36,11 +36,11 @@ use rustc::session::config::nightly_options;\n use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n+use rustc::middle::cstore::MetadataLoader;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::ty::TyCtxt;\n use rustc::util::common::{set_time_depth, time, print_time_passes_entry, ErrorReported};\n use rustc_metadata::locator;\n-use rustc_metadata::cstore::CStore;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_interface::interface;\n use rustc_interface::util::get_codegen_sysroot;\n@@ -277,7 +277,7 @@ pub fn run_compiler(\n             compiler.output_file(),\n         ).and_then(|| RustcDefaultCalls::list_metadata(\n             sess,\n-            compiler.cstore(),\n+            &*compiler.codegen_backend().metadata_loader(),\n             &matches,\n             compiler.input()\n         ));\n@@ -614,7 +614,7 @@ fn show_content_with_pager(content: &String) {\n \n impl RustcDefaultCalls {\n     pub fn list_metadata(sess: &Session,\n-                         cstore: &CStore,\n+                         metadata_loader: &dyn MetadataLoader,\n                          matches: &getopts::Matches,\n                          input: &Input)\n                          -> Compilation {\n@@ -626,7 +626,7 @@ impl RustcDefaultCalls {\n                     let mut v = Vec::new();\n                     locator::list_file_metadata(&sess.target.target,\n                                                 path,\n-                                                cstore,\n+                                                metadata_loader,\n                                                 &mut v)\n                             .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());"}, {"sha": "e014e4ed0fdc1cbe6fdb960fc012f2f2e2c1a3c7", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -11,7 +11,6 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::OnDrop;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use rustc_metadata::cstore::CStore;\n use std::path::PathBuf;\n use std::result;\n use std::sync::{Arc, Mutex};\n@@ -37,7 +36,6 @@ pub struct Compiler {\n     pub(crate) output_dir: Option<PathBuf>,\n     pub(crate) output_file: Option<PathBuf>,\n     pub(crate) queries: Queries,\n-    pub(crate) cstore: Lrc<CStore>,\n     pub(crate) crate_name: Option<String>,\n     pub(crate) register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n }\n@@ -49,9 +47,6 @@ impl Compiler {\n     pub fn codegen_backend(&self) -> &Lrc<Box<dyn CodegenBackend>> {\n         &self.codegen_backend\n     }\n-    pub fn cstore(&self) -> &Lrc<CStore> {\n-        &self.cstore\n-    }\n     pub fn source_map(&self) -> &Lrc<SourceMap> {\n         &self.source_map\n     }\n@@ -160,13 +155,10 @@ where\n         config.lint_caps,\n     );\n \n-    let cstore = Lrc::new(CStore::new(codegen_backend.metadata_loader()));\n-\n     let compiler = Compiler {\n         sess,\n         codegen_backend,\n         source_map,\n-        cstore,\n         input: config.input,\n         input_path: config.input_path,\n         output_dir: config.output_dir,"}, {"sha": "58936172c5bcec0cd73a73b4d16528caf0046f5d", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 40, "deletions": 97, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -9,8 +9,8 @@ use rustc::hir::lowering::lower_crate;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::lint;\n use rustc::middle::{self, reachable, resolve_lifetime, stability};\n-use rustc::middle::cstore::CrateStore;\n-use rustc::ty::{self, AllArenas, Resolutions, TyCtxt, GlobalCtxt};\n+use rustc::middle::cstore::{CrateStore, MetadataLoader, MetadataLoaderDyn};\n+use rustc::ty::{self, AllArenas, ResolverOutputs, TyCtxt, GlobalCtxt};\n use rustc::ty::steal::Steal;\n use rustc::traits;\n use rustc::util::common::{time, ErrorReported};\n@@ -23,8 +23,7 @@ use rustc_codegen_utils::link::filename_for_metadata;\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_data_structures::sync::{Lrc, ParallelIterator, par_iter};\n use rustc_incremental;\n-use rustc_metadata::creader::CrateLoader;\n-use rustc_metadata::cstore::{self, CStore};\n+use rustc_metadata::cstore;\n use rustc_mir as mir;\n use rustc_passes::{self, ast_validation, hir_stats, layout_test};\n use rustc_plugin as plugin;\n@@ -46,12 +45,10 @@ use syntax_ext;\n use rustc_serialize::json;\n use tempfile::Builder as TempFileBuilder;\n \n+use std::{env, fs, iter, mem};\n use std::any::Any;\n-use std::env;\n use std::ffi::OsString;\n-use std::fs;\n use std::io::{self, Write};\n-use std::iter;\n use std::path::PathBuf;\n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -105,7 +102,7 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n declare_box_region_type!(\n     pub BoxedResolver,\n     for(),\n-    (&mut Resolver<'_>) -> (Result<ast::Crate>, ExpansionResult)\n+    (&mut Resolver<'_>) -> (Result<ast::Crate>, ResolverOutputs)\n );\n \n /// Runs the \"early phases\" of the compiler: initial `cfg` processing,\n@@ -118,7 +115,7 @@ declare_box_region_type!(\n pub fn configure_and_expand(\n     sess: Lrc<Session>,\n     lint_store: Lrc<lint::LintStore>,\n-    cstore: Lrc<CStore>,\n+    metadata_loader: Box<MetadataLoaderDyn>,\n     krate: ast::Crate,\n     crate_name: &str,\n     plugin_info: PluginInfo,\n@@ -131,16 +128,14 @@ pub fn configure_and_expand(\n     let crate_name = crate_name.to_string();\n     let (result, resolver) = BoxedResolver::new(static move || {\n         let sess = &*sess;\n-        let crate_loader = CrateLoader::new(sess, &*cstore, &crate_name);\n         let resolver_arenas = Resolver::arenas();\n         let res = configure_and_expand_inner(\n             sess,\n             &lint_store,\n-            &*cstore,\n             krate,\n             &crate_name,\n             &resolver_arenas,\n-            &crate_loader,\n+            &*metadata_loader,\n             plugin_info,\n         );\n         let mut resolver = match res {\n@@ -154,68 +149,16 @@ pub fn configure_and_expand(\n             }\n         };\n         box_region_allow_access!(for(), (&mut Resolver<'_>), (&mut resolver));\n-        ExpansionResult::from_owned_resolver(resolver)\n+        resolver.into_outputs()\n     });\n     result.map(|k| (k, resolver))\n }\n \n-pub struct ExpansionResult {\n-    pub defs: Steal<hir::map::Definitions>,\n-    pub resolutions: Steal<Resolutions>,\n-}\n-\n-impl ExpansionResult {\n-    fn from_owned_resolver(\n-        resolver: Resolver<'_>,\n-    ) -> Self {\n-        ExpansionResult {\n-            defs: Steal::new(resolver.definitions),\n-            resolutions: Steal::new(Resolutions {\n-                extern_crate_map: resolver.extern_crate_map,\n-                export_map: resolver.export_map,\n-                trait_map: resolver.trait_map,\n-                glob_map: resolver.glob_map,\n-                maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n-                maybe_unused_extern_crates: resolver.maybe_unused_extern_crates,\n-                extern_prelude: resolver.extern_prelude.iter().map(|(ident, entry)| {\n-                    (ident.name, entry.introduced_by_item)\n-                }).collect(),\n-            }),\n-        }\n-    }\n-\n-    pub fn from_resolver_ref(\n-        resolver: &Resolver<'_>,\n-    ) -> Self {\n-        ExpansionResult {\n-            defs: Steal::new(resolver.definitions.clone()),\n-            resolutions: Steal::new(Resolutions {\n-                extern_crate_map: resolver.extern_crate_map.clone(),\n-                export_map: resolver.export_map.clone(),\n-                trait_map: resolver.trait_map.clone(),\n-                glob_map: resolver.glob_map.clone(),\n-                maybe_unused_trait_imports: resolver.maybe_unused_trait_imports.clone(),\n-                maybe_unused_extern_crates: resolver.maybe_unused_extern_crates.clone(),\n-                extern_prelude: resolver.extern_prelude.iter().map(|(ident, entry)| {\n-                    (ident.name, entry.introduced_by_item)\n-                }).collect(),\n-            }),\n-        }\n-    }\n-}\n-\n impl BoxedResolver {\n-    pub fn to_expansion_result(\n-        resolver: Rc<RefCell<BoxedResolver>>,\n-    ) -> ExpansionResult {\n+    pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ResolverOutputs {\n         match Rc::try_unwrap(resolver) {\n             Ok(resolver) => resolver.into_inner().complete(),\n-            Err(resolver) => {\n-                let resolver = &*resolver;\n-                resolver.borrow_mut().access(|resolver| {\n-                    ExpansionResult::from_resolver_ref(resolver)\n-                })\n-            }\n+            Err(resolver) => resolver.borrow_mut().access(|resolver| resolver.clone_outputs()),\n         }\n     }\n }\n@@ -226,7 +169,7 @@ pub struct PluginInfo {\n \n pub fn register_plugins<'a>(\n     sess: &'a Session,\n-    cstore: &'a CStore,\n+    metadata_loader: &'a dyn MetadataLoader,\n     register_lints: impl Fn(&Session, &mut lint::LintStore),\n     mut krate: ast::Crate,\n     crate_name: &str,\n@@ -274,9 +217,8 @@ pub fn register_plugins<'a>(\n     let registrars = time(sess, \"plugin loading\", || {\n         plugin::load::load_plugins(\n             sess,\n-            &cstore,\n+            metadata_loader,\n             &krate,\n-            crate_name,\n             Some(sess.opts.debugging_opts.extra_plugins.clone()),\n         )\n     });\n@@ -313,11 +255,10 @@ pub fn register_plugins<'a>(\n fn configure_and_expand_inner<'a>(\n     sess: &'a Session,\n     lint_store: &'a lint::LintStore,\n-    cstore: &'a CStore,\n     mut krate: ast::Crate,\n     crate_name: &str,\n     resolver_arenas: &'a ResolverArenas<'a>,\n-    crate_loader: &'a CrateLoader<'a>,\n+    metadata_loader: &'a MetadataLoaderDyn,\n     plugin_info: PluginInfo,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n     time(sess, \"pre-AST-expansion lint checks\", || {\n@@ -331,10 +272,9 @@ fn configure_and_expand_inner<'a>(\n \n     let mut resolver = Resolver::new(\n         sess,\n-        cstore,\n         &krate,\n         crate_name,\n-        crate_loader,\n+        metadata_loader,\n         &resolver_arenas,\n     );\n     syntax_ext::register_builtin_macros(&mut resolver, sess.edition());\n@@ -534,15 +474,14 @@ fn configure_and_expand_inner<'a>(\n pub fn lower_to_hir(\n     sess: &Session,\n     lint_store: &lint::LintStore,\n-    cstore: &CStore,\n     resolver: &mut Resolver<'_>,\n     dep_graph: &DepGraph,\n     krate: &ast::Crate,\n ) -> Result<hir::map::Forest> {\n     // Lower AST to HIR.\n     let hir_forest = time(sess, \"lowering AST -> HIR\", || {\n         let nt_to_tokenstream = syntax::parse::nt_to_tokenstream;\n-        let hir_crate = lower_crate(sess, cstore, &dep_graph, &krate, resolver, nt_to_tokenstream);\n+        let hir_crate = lower_crate(sess, &dep_graph, &krate, resolver, nt_to_tokenstream);\n \n         if sess.opts.debugging_opts.hir_stats {\n             hir_stats::print_hir_stats(&hir_crate);\n@@ -648,8 +587,12 @@ fn escape_dep_filename(filename: &FileName) -> String {\n     filename.to_string().replace(\" \", \"\\\\ \")\n }\n \n-fn write_out_deps(compiler: &Compiler, outputs: &OutputFilenames, out_filenames: &[PathBuf]) {\n-    let sess = &compiler.sess;\n+fn write_out_deps(\n+    sess: &Session,\n+    boxed_resolver: &Steal<Rc<RefCell<BoxedResolver>>>,\n+    outputs: &OutputFilenames,\n+    out_filenames: &[PathBuf],\n+) {\n     // Write out dependency rules to the dep-info file if requested\n     if !sess.opts.output_types.contains_key(&OutputType::DepInfo) {\n         return;\n@@ -668,18 +611,20 @@ fn write_out_deps(compiler: &Compiler, outputs: &OutputFilenames, out_filenames:\n             .collect();\n \n         if sess.binary_dep_depinfo() {\n-            for cnum in compiler.cstore.crates_untracked() {\n-                let source = compiler.cstore.crate_source_untracked(cnum);\n-                if let Some((path, _)) = source.dylib {\n-                    files.push(escape_dep_filename(&FileName::Real(path)));\n+            boxed_resolver.borrow().borrow_mut().access(|resolver| {\n+                for cnum in resolver.cstore().crates_untracked() {\n+                    let source = resolver.cstore().crate_source_untracked(cnum);\n+                    if let Some((path, _)) = source.dylib {\n+                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                    }\n+                    if let Some((path, _)) = source.rlib {\n+                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                    }\n+                    if let Some((path, _)) = source.rmeta {\n+                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                    }\n                 }\n-                if let Some((path, _)) = source.rlib {\n-                    files.push(escape_dep_filename(&FileName::Real(path)));\n-                }\n-                if let Some((path, _)) = source.rmeta {\n-                    files.push(escape_dep_filename(&FileName::Real(path)));\n-                }\n-            }\n+            });\n         }\n \n         let mut file = fs::File::create(&deps_filename)?;\n@@ -717,6 +662,7 @@ pub fn prepare_outputs(\n     sess: &Session,\n     compiler: &Compiler,\n     krate: &ast::Crate,\n+    boxed_resolver: &Steal<Rc<RefCell<BoxedResolver>>>,\n     crate_name: &str\n ) -> Result<OutputFilenames> {\n     // FIXME: rustdoc passes &[] instead of &krate.attrs here\n@@ -758,7 +704,7 @@ pub fn prepare_outputs(\n         }\n     }\n \n-    write_out_deps(compiler, &outputs, &output_paths);\n+    write_out_deps(sess, boxed_resolver, &outputs, &output_paths);\n \n     let only_dep_info = sess.opts.output_types.contains_key(&OutputType::DepInfo)\n         && sess.opts.output_types.len() == 1;\n@@ -823,26 +769,24 @@ pub fn create_global_ctxt(\n     compiler: &Compiler,\n     lint_store: Lrc<lint::LintStore>,\n     mut hir_forest: hir::map::Forest,\n-    defs: hir::map::Definitions,\n-    resolutions: Resolutions,\n+    mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,\n ) -> BoxedGlobalCtxt {\n     let sess = compiler.session().clone();\n-    let cstore = compiler.cstore.clone();\n     let codegen_backend = compiler.codegen_backend().clone();\n     let crate_name = crate_name.to_string();\n+    let defs = mem::take(&mut resolver_outputs.definitions);\n \n     let ((), result) = BoxedGlobalCtxt::new(static move || {\n         let sess = &*sess;\n-        let cstore = &*cstore;\n \n         let global_ctxt: Option<GlobalCtxt<'_>>;\n         let arenas = AllArenas::new();\n \n         // Construct the HIR map.\n         let hir_map = time(sess, \"indexing HIR\", || {\n-            hir::map::map_crate(sess, cstore, &mut hir_forest, &defs)\n+            hir::map::map_crate(sess, &*resolver_outputs.cstore, &mut hir_forest, &defs)\n         });\n \n         let query_result_on_disk_cache = time(sess, \"load query result cache\", || {\n@@ -860,11 +804,10 @@ pub fn create_global_ctxt(\n         let gcx = TyCtxt::create_global_ctxt(\n             sess,\n             lint_store,\n-            cstore,\n             local_providers,\n             extern_providers,\n             &arenas,\n-            resolutions,\n+            resolver_outputs,\n             hir_map,\n             query_result_on_disk_cache,\n             &crate_name,"}, {"sha": "ea51e63725ea2f117ec4c0b7354fb6660374fca3", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -1,5 +1,5 @@\n use crate::interface::{Compiler, Result};\n-use crate::passes::{self, BoxedResolver, ExpansionResult, BoxedGlobalCtxt, PluginInfo};\n+use crate::passes::{self, BoxedResolver, BoxedGlobalCtxt, PluginInfo};\n \n use rustc_incremental::DepGraphFuture;\n use rustc_data_structures::sync::Lrc;\n@@ -11,6 +11,7 @@ use rustc::session::Session;\n use rustc::lint::LintStore;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::ty::steal::Steal;\n+use rustc::ty::ResolverOutputs;\n use rustc::dep_graph::DepGraph;\n use std::cell::{Ref, RefMut, RefCell};\n use std::rc::Rc;\n@@ -81,7 +82,7 @@ pub(crate) struct Queries {\n     register_plugins: Query<(ast::Crate, PluginInfo, Lrc<LintStore>)>,\n     expansion: Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n-    lower_to_hir: Query<(Steal<hir::map::Forest>, ExpansionResult)>,\n+    lower_to_hir: Query<(Steal<hir::map::Forest>, Steal<ResolverOutputs>)>,\n     prepare_outputs: Query<OutputFilenames>,\n     global_ctxt: Query<BoxedGlobalCtxt>,\n     ongoing_codegen: Query<Box<dyn Any>>,\n@@ -118,7 +119,7 @@ impl Compiler {\n             let empty: &(dyn Fn(&Session, &mut lint::LintStore) + Sync + Send) = &|_, _| {};\n             let result = passes::register_plugins(\n                 self.session(),\n-                self.cstore(),\n+                &*self.codegen_backend().metadata_loader(),\n                 self.register_lints\n                     .as_ref()\n                     .map(|p| &**p)\n@@ -164,7 +165,7 @@ impl Compiler {\n             passes::configure_and_expand(\n                 self.sess.clone(),\n                 lint_store.clone(),\n-                self.cstore().clone(),\n+                self.codegen_backend().metadata_loader(),\n                 krate,\n                 &crate_name,\n                 plugin_info,\n@@ -191,7 +192,9 @@ impl Compiler {\n         })\n     }\n \n-    pub fn lower_to_hir(&self) -> Result<&Query<(Steal<hir::map::Forest>, ExpansionResult)>> {\n+    pub fn lower_to_hir(\n+        &self,\n+    ) -> Result<&Query<(Steal<hir::map::Forest>, Steal<ResolverOutputs>)>> {\n         self.queries.lower_to_hir.compute(|| {\n             let expansion_result = self.expansion()?;\n             let peeked = expansion_result.peek();\n@@ -202,23 +205,22 @@ impl Compiler {\n                 passes::lower_to_hir(\n                     self.session(),\n                     lint_store,\n-                    self.cstore(),\n                     resolver,\n                     &*self.dep_graph()?.peek(),\n                     &krate\n                 )\n             })?);\n-            Ok((hir, BoxedResolver::to_expansion_result(resolver)))\n+            Ok((hir, Steal::new(BoxedResolver::to_resolver_outputs(resolver))))\n         })\n     }\n \n     pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n         self.queries.prepare_outputs.compute(|| {\n-            let krate = self.expansion()?;\n-            let krate = krate.peek();\n+            let expansion_result = self.expansion()?;\n+            let (krate, boxed_resolver, _) = &*expansion_result.peek();\n             let crate_name = self.crate_name()?;\n             let crate_name = crate_name.peek();\n-            passes::prepare_outputs(self.session(), self, &krate.0, &*crate_name)\n+            passes::prepare_outputs(self.session(), self, &krate, &boxed_resolver, &crate_name)\n         })\n     }\n \n@@ -229,13 +231,12 @@ impl Compiler {\n             let lint_store = self.expansion()?.peek().2.clone();\n             let hir = self.lower_to_hir()?;\n             let hir = hir.peek();\n-            let (ref hir_forest, ref expansion) = *hir;\n+            let (hir_forest, resolver_outputs) = &*hir;\n             Ok(passes::create_global_ctxt(\n                 self,\n                 lint_store,\n                 hir_forest.steal(),\n-                expansion.defs.steal(),\n-                expansion.resolutions.steal(),\n+                resolver_outputs.steal(),\n                 outputs,\n                 &crate_name))\n         })"}, {"sha": "f0a68058de8ca89e414d553f6669d509c1134bb5", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 57, "deletions": 160, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -3,7 +3,7 @@\n use crate::cstore::{self, CStore, MetadataBlob};\n use crate::locator::{self, CratePaths};\n use crate::schema::{CrateRoot, CrateDep};\n-use rustc_data_structures::sync::{Lrc, RwLock, Lock, AtomicCell};\n+use rustc_data_structures::sync::{RwLock, Lock, AtomicCell};\n \n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n@@ -14,21 +14,20 @@ use rustc::session::{Session, CrateDisambiguator};\n use rustc::session::config::{Sanitizer, self};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc::session::search_paths::PathKind;\n-use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource};\n+use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn};\n use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::map::Definitions;\n use rustc::hir::def_id::LOCAL_CRATE;\n \n-use std::ops::Deref;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n use syntax_expand::allocator::{global_allocator_spans, AllocatorKind};\n use syntax::symbol::{Symbol, sym};\n-use syntax::{span_err, span_fatal};\n+use syntax::span_fatal;\n use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n use proc_macro::bridge::client::ProcMacro;\n@@ -39,9 +38,12 @@ crate struct Library {\n }\n \n pub struct CrateLoader<'a> {\n+    // Immutable configuration.\n     sess: &'a Session,\n-    cstore: &'a CStore,\n+    metadata_loader: &'a MetadataLoaderDyn,\n     local_crate_name: Symbol,\n+    // Mutable output.\n+    cstore: CStore,\n }\n \n fn dump_crates(cstore: &CStore) {\n@@ -58,29 +60,6 @@ fn dump_crates(cstore: &CStore) {\n     });\n }\n \n-// Extra info about a crate loaded for plugins or exported macros.\n-struct ExtensionCrate {\n-    metadata: PMDSource,\n-    dylib: Option<PathBuf>,\n-    target_only: bool,\n-}\n-\n-enum PMDSource {\n-    Registered(Lrc<cstore::CrateMetadata>),\n-    Owned(Library),\n-}\n-\n-impl Deref for PMDSource {\n-    type Target = MetadataBlob;\n-\n-    fn deref(&self) -> &MetadataBlob {\n-        match *self {\n-            PMDSource::Registered(ref cmd) => &cmd.blob,\n-            PMDSource::Owned(ref lib) => &lib.metadata\n-        }\n-    }\n-}\n-\n enum LoadResult {\n     Previous(CrateNum),\n     Loaded(Library),\n@@ -99,14 +78,27 @@ impl<'a> LoadError<'a> {\n }\n \n impl<'a> CrateLoader<'a> {\n-    pub fn new(sess: &'a Session, cstore: &'a CStore, local_crate_name: &str) -> Self {\n+    pub fn new(\n+        sess: &'a Session,\n+        metadata_loader: &'a MetadataLoaderDyn,\n+        local_crate_name: &str,\n+    ) -> Self {\n         CrateLoader {\n             sess,\n-            cstore,\n+            metadata_loader,\n             local_crate_name: Symbol::intern(local_crate_name),\n+            cstore: Default::default(),\n         }\n     }\n \n+    pub fn cstore(&self) -> &CStore {\n+        &self.cstore\n+    }\n+\n+    pub fn into_cstore(self) -> CStore {\n+        self.cstore\n+    }\n+\n     fn existing_match(&self, name: Symbol, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<CrateNum> {\n         let mut ret = None;\n@@ -187,14 +179,14 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn register_crate(\n-        &self,\n+        &mut self,\n         host_lib: Option<Library>,\n         root: Option<&CratePaths>,\n         span: Span,\n         lib: Library,\n         dep_kind: DepKind,\n         name: Symbol\n-    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+    ) -> CrateNum {\n         let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n \n         let Library { source, metadata } = lib;\n@@ -248,9 +240,9 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode((&metadata, self.sess))\n         });\n \n-        let cmeta = cstore::CrateMetadata {\n+        self.cstore.set_crate_data(cnum, cstore::CrateMetadata {\n             extern_crate: Lock::new(None),\n-            def_path_table: Lrc::new(def_path_table),\n+            def_path_table,\n             trait_impls,\n             root: crate_root,\n             blob: metadata,\n@@ -264,11 +256,9 @@ impl<'a> CrateLoader<'a> {\n             private_dep,\n             raw_proc_macros,\n             dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n-        };\n+        });\n \n-        let cmeta = Lrc::new(cmeta);\n-        self.cstore.set_crate_data(cnum, cmeta.clone());\n-        (cnum, cmeta)\n+        cnum\n     }\n \n     fn load_proc_macro<'b>(\n@@ -327,22 +317,22 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn resolve_crate<'b>(\n-        &'b self,\n+        &'b mut self,\n         name: Symbol,\n         span: Span,\n         dep_kind: DepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n-    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+    ) -> CrateNum {\n         self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n     }\n \n     fn maybe_resolve_crate<'b>(\n-        &'b self,\n+        &'b mut self,\n         name: Symbol,\n         span: Span,\n         mut dep_kind: DepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n-    ) -> Result<(CrateNum, Lrc<cstore::CrateMetadata>), LoadError<'b>> {\n+    ) -> Result<CrateNum, LoadError<'b>> {\n         info!(\"resolving crate `{}`\", name);\n         let (root, hash, extra_filename, path_kind) = match dep {\n             Some((root, dep)) =>\n@@ -370,7 +360,7 @@ impl<'a> CrateLoader<'a> {\n                 rejected_via_filename: vec![],\n                 should_match_name: true,\n                 is_proc_macro: Some(false),\n-                metadata_loader: &*self.cstore.metadata_loader,\n+                metadata_loader: self.metadata_loader,\n             };\n \n             self.load(&mut locate_ctxt).map(|r| (r, None)).or_else(|| {\n@@ -388,7 +378,7 @@ impl<'a> CrateLoader<'a> {\n                 data.dep_kind.with_lock(|data_dep_kind| {\n                     *data_dep_kind = cmp::max(*data_dep_kind, dep_kind);\n                 });\n-                Ok((cnum, data))\n+                Ok(cnum)\n             }\n             (LoadResult::Loaded(library), host_library) => {\n                 Ok(self.register_crate(host_library, root, span, library, dep_kind, name))\n@@ -466,7 +456,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     // Go through the crate metadata and load any crates that it references\n-    fn resolve_crate_deps(&self,\n+    fn resolve_crate_deps(&mut self,\n                           root: &CratePaths,\n                           crate_root: &CrateRoot<'_>,\n                           metadata: &MetadataBlob,\n@@ -492,73 +482,10 @@ impl<'a> CrateLoader<'a> {\n                 DepKind::MacrosOnly => DepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n-            self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep))).0\n+            self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep)))\n         })).collect()\n     }\n \n-    fn read_extension_crate(&self, name: Symbol, span: Span) -> ExtensionCrate {\n-        info!(\"read extension crate `{}`\", name);\n-        let target_triple = self.sess.opts.target_triple.clone();\n-        let host_triple = TargetTriple::from_triple(config::host_triple());\n-        let is_cross = target_triple != host_triple;\n-        let mut target_only = false;\n-        let mut locate_ctxt = locator::Context {\n-            sess: self.sess,\n-            span,\n-            crate_name: name,\n-            hash: None,\n-            extra_filename: None,\n-            filesearch: self.sess.host_filesearch(PathKind::Crate),\n-            target: &self.sess.host,\n-            triple: host_triple,\n-            root: None,\n-            rejected_via_hash: vec![],\n-            rejected_via_triple: vec![],\n-            rejected_via_kind: vec![],\n-            rejected_via_version: vec![],\n-            rejected_via_filename: vec![],\n-            should_match_name: true,\n-            is_proc_macro: None,\n-            metadata_loader: &*self.cstore.metadata_loader,\n-        };\n-        let library = self.load(&mut locate_ctxt).or_else(|| {\n-            if !is_cross {\n-                return None\n-            }\n-            // Try loading from target crates. This will abort later if we\n-            // try to load a plugin registrar function,\n-            target_only = true;\n-\n-            locate_ctxt.target = &self.sess.target.target;\n-            locate_ctxt.triple = target_triple;\n-            locate_ctxt.filesearch = self.sess.target_filesearch(PathKind::Crate);\n-\n-            self.load(&mut locate_ctxt)\n-        });\n-        let library = match library {\n-            Some(l) => l,\n-            None => locate_ctxt.report_errs(),\n-        };\n-\n-        let (dylib, metadata) = match library {\n-            LoadResult::Previous(cnum) => {\n-                let data = self.cstore.get_crate_data(cnum);\n-                (data.source.dylib.clone(), PMDSource::Registered(data))\n-            }\n-            LoadResult::Loaded(library) => {\n-                let dylib = library.source.dylib.clone();\n-                let metadata = PMDSource::Owned(library);\n-                (dylib, metadata)\n-            }\n-        };\n-\n-        ExtensionCrate {\n-            metadata,\n-            dylib: dylib.map(|p| p.0),\n-            target_only,\n-        }\n-    }\n-\n     fn dlsym_proc_macros(&self,\n                          path: &Path,\n                          disambiguator: CrateDisambiguator,\n@@ -590,42 +517,7 @@ impl<'a> CrateLoader<'a> {\n         decls\n     }\n \n-    /// Look for a plugin registrar. Returns library path, crate\n-    /// SVH and DefIndex of the registrar function.\n-    pub fn find_plugin_registrar(&self,\n-                                 span: Span,\n-                                 name: Symbol)\n-                                 -> Option<(PathBuf, CrateDisambiguator)> {\n-        let ekrate = self.read_extension_crate(name, span);\n-\n-        if ekrate.target_only {\n-            // Need to abort before syntax expansion.\n-            let message = format!(\"plugin `{}` is not available for triple `{}` \\\n-                                   (only found {})\",\n-                                  name,\n-                                  config::host_triple(),\n-                                  self.sess.opts.target_triple);\n-            span_fatal!(self.sess, span, E0456, \"{}\", &message);\n-        }\n-\n-        let root = ekrate.metadata.get_root();\n-        match ekrate.dylib.as_ref() {\n-            Some(dylib) => {\n-                Some((dylib.to_path_buf(), root.disambiguator))\n-            }\n-            None => {\n-                span_err!(self.sess, span, E0457,\n-                          \"plugin `{}` only found in rlib format, but must be available \\\n-                           in dylib format\",\n-                          name);\n-                // No need to abort because the loading code will just ignore this\n-                // empty dylib.\n-                None\n-            }\n-        }\n-    }\n-\n-    fn inject_panic_runtime(&self, krate: &ast::Crate) {\n+    fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n         // If we're only compiling an rlib, then there's no need to select a\n         // panic runtime, so we just skip this section entirely.\n         let any_non_rlib = self.sess.crate_types.borrow().iter().any(|ct| {\n@@ -687,7 +579,8 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let (cnum, data) = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+        let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+        let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n@@ -706,7 +599,7 @@ impl<'a> CrateLoader<'a> {\n                                   &|data| data.root.needs_panic_runtime);\n     }\n \n-    fn inject_sanitizer_runtime(&self) {\n+    fn inject_sanitizer_runtime(&mut self) {\n         if let Some(ref sanitizer) = self.sess.opts.debugging_opts.sanitizer {\n             // Sanitizers can only be used on some tested platforms with\n             // executables linked to `std`\n@@ -791,7 +684,8 @@ impl<'a> CrateLoader<'a> {\n                 });\n                 info!(\"loading sanitizer: {}\", name);\n \n-                let data = self.resolve_crate(name, DUMMY_SP, DepKind::Explicit, None).1;\n+                let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Explicit, None);\n+                let data = self.cstore.get_crate_data(cnum);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n                 if !data.root.sanitizer_runtime {\n@@ -804,14 +698,15 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn inject_profiler_runtime(&self) {\n+    fn inject_profiler_runtime(&mut self) {\n         if self.sess.opts.debugging_opts.profile ||\n            self.sess.opts.cg.profile_generate.enabled()\n         {\n             info!(\"loading profiler\");\n \n             let name = Symbol::intern(\"profiler_builtins\");\n-            let data = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None).1;\n+            let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+            let data = self.cstore.get_crate_data(cnum);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n             if !data.root.profiler_runtime {\n@@ -957,10 +852,8 @@ impl<'a> CrateLoader<'a> {\n             data.dependencies.borrow_mut().push(krate);\n         });\n     }\n-}\n \n-impl<'a> CrateLoader<'a> {\n-    pub fn postprocess(&self, krate: &ast::Crate) {\n+    pub fn postprocess(&mut self, krate: &ast::Crate) {\n         self.inject_sanitizer_runtime();\n         self.inject_profiler_runtime();\n         self.inject_allocator_crate(krate);\n@@ -971,7 +864,11 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    pub fn process_extern_crate(&self, item: &ast::Item, definitions: &Definitions) -> CrateNum {\n+    pub fn process_extern_crate(\n+        &mut self,\n+        item: &ast::Item,\n+        definitions: &Definitions,\n+    ) -> CrateNum {\n         match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 debug!(\"resolving extern crate stmt. ident: {} orig_name: {:?}\",\n@@ -990,7 +887,7 @@ impl<'a> CrateLoader<'a> {\n                     DepKind::Explicit\n                 };\n \n-                let cnum = self.resolve_crate(name, item.span, dep_kind, None).0;\n+                let cnum = self.resolve_crate(name, item.span, dep_kind, None);\n \n                 let def_id = definitions.opt_local_def_id(item.id).unwrap();\n                 let path_len = definitions.def_path(def_id.index).data.len();\n@@ -1010,8 +907,8 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    pub fn process_path_extern(&self, name: Symbol, span: Span) -> CrateNum {\n-        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None).0;\n+    pub fn process_path_extern(&mut self, name: Symbol, span: Span) -> CrateNum {\n+        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None);\n \n         self.update_extern_crate(\n             cnum,\n@@ -1028,8 +925,8 @@ impl<'a> CrateLoader<'a> {\n         cnum\n     }\n \n-    pub fn maybe_process_path_extern(&self, name: Symbol, span: Span) -> Option<CrateNum> {\n-        let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?.0;\n+    pub fn maybe_process_path_extern(&mut self, name: Symbol, span: Span) -> Option<CrateNum> {\n+        let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?;\n \n         self.update_extern_crate(\n             cnum,"}, {"sha": "6b06cf575edcf5557aeddaf70335f4f4e7e809de", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -5,12 +5,13 @@ use crate::schema;\n use rustc::dep_graph::DepNodeIndex;\n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n-use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate, MetadataLoader};\n+use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate};\n use rustc::mir::interpret::AllocDecodingState;\n use rustc_index::vec::IndexVec;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::sync::{Lrc, RwLock, Lock, MetadataRef, AtomicCell};\n use syntax::ast;\n+use syntax::edition::Edition;\n use syntax_expand::base::SyntaxExtension;\n use syntax_pos;\n use proc_macro::bridge::client::ProcMacro;\n@@ -36,7 +37,7 @@ crate struct ImportedSourceFile {\n     pub translated_source_file: Lrc<syntax_pos::SourceFile>,\n }\n \n-pub struct CrateMetadata {\n+crate struct CrateMetadata {\n     /// The primary crate data - binary metadata blob.\n     crate blob: MetadataBlob,\n \n@@ -53,7 +54,7 @@ pub struct CrateMetadata {\n     /// hashmap, which gives the reverse mapping. This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    crate def_path_table: Lrc<DefPathTable>,\n+    crate def_path_table: DefPathTable,\n     /// Trait impl data.\n     /// FIXME: Used only from queries and can use query cache,\n     /// so pre-decoding can probably be avoided.\n@@ -94,50 +95,48 @@ pub struct CrateMetadata {\n     crate extern_crate: Lock<Option<ExternCrate>>,\n }\n \n+#[derive(Clone)]\n pub struct CStore {\n-    metas: RwLock<IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>>,\n-    crate metadata_loader: Box<dyn MetadataLoader + Sync>,\n+    metas: IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>,\n }\n \n pub enum LoadedMacro {\n-    MacroDef(ast::Item),\n+    MacroDef(ast::Item, Edition),\n     ProcMacro(SyntaxExtension),\n }\n \n-impl CStore {\n-    pub fn new(metadata_loader: Box<dyn MetadataLoader + Sync>) -> CStore {\n+impl Default for CStore {\n+    fn default() -> Self {\n         CStore {\n             // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n             // order to make array indices in `metas` match with the\n             // corresponding `CrateNum`. This first entry will always remain\n             // `None`.\n-            metas: RwLock::new(IndexVec::from_elem_n(None, 1)),\n-            metadata_loader,\n+            metas: IndexVec::from_elem_n(None, 1),\n         }\n     }\n+}\n \n-    crate fn alloc_new_crate_num(&self) -> CrateNum {\n-        let mut metas = self.metas.borrow_mut();\n-        let cnum = CrateNum::new(metas.len());\n-        metas.push(None);\n-        cnum\n+impl CStore {\n+    crate fn alloc_new_crate_num(&mut self) -> CrateNum {\n+        self.metas.push(None);\n+        CrateNum::new(self.metas.len() - 1)\n     }\n \n-    crate fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n-        self.metas.borrow()[cnum].clone()\n+    crate fn get_crate_data(&self, cnum: CrateNum) -> &CrateMetadata {\n+        self.metas[cnum].as_ref()\n             .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum))\n     }\n \n-    crate fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n-        let mut metas = self.metas.borrow_mut();\n-        assert!(metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n-        metas[cnum] = Some(data);\n+    crate fn set_crate_data(&mut self, cnum: CrateNum, data: CrateMetadata) {\n+        assert!(self.metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n+        self.metas[cnum] = Some(Lrc::new(data));\n     }\n \n     crate fn iter_crate_data<I>(&self, mut i: I)\n-        where I: FnMut(CrateNum, &Lrc<CrateMetadata>)\n+        where I: FnMut(CrateNum, &CrateMetadata)\n     {\n-        for (k, v) in self.metas.borrow().iter_enumerated() {\n+        for (k, v) in self.metas.iter_enumerated() {\n             if let &Some(ref v) = v {\n                 i(k, v);\n             }\n@@ -168,7 +167,7 @@ impl CStore {\n \n     crate fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n-        for (num, v) in self.metas.borrow().iter_enumerated() {\n+        for (num, v) in self.metas.iter_enumerated() {\n             if let &Some(_) = v {\n                 self.push_dependencies_in_postorder(&mut ordering, num);\n             }"}, {"sha": "d942a19194a1443d69a35a34a52daf3502f0c152", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -29,7 +29,6 @@ use std::sync::Arc;\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map;\n-use syntax::edition::Edition;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::source_map::Spanned;\n@@ -54,7 +53,7 @@ macro_rules! provide {\n                 let ($def_id, $other) = def_id_arg.into_args();\n                 assert!(!$def_id.is_local());\n \n-                let $cdata = $tcx.crate_data_as_rc_any($def_id.krate);\n+                let $cdata = $tcx.crate_data_as_any($def_id.krate);\n                 let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n                     .expect(\"CrateStore created data is not a CrateMetadata\");\n \n@@ -411,10 +410,6 @@ impl cstore::CStore {\n         }\n     }\n \n-    pub fn crate_edition_untracked(&self, cnum: CrateNum) -> Edition {\n-        self.get_crate_data(cnum).root.edition\n-    }\n-\n     pub fn struct_field_names_untracked(&self, def: DefId, sess: &Session) -> Vec<Spanned<Symbol>> {\n         self.get_crate_data(def.krate).get_struct_field_names(def.index, sess)\n     }\n@@ -470,7 +465,7 @@ impl cstore::CStore {\n             }),\n             vis: source_map::respan(local_span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n             tokens: None,\n-        })\n+        }, data.root.edition)\n     }\n \n     pub fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssocItem {\n@@ -483,8 +478,8 @@ impl cstore::CStore {\n }\n \n impl CrateStore for cstore::CStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<dyn Any> {\n-        self.get_crate_data(krate)\n+    fn crate_data_as_any(&self, cnum: CrateNum) -> &dyn Any {\n+        self.get_crate_data(cnum)\n     }\n \n     fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics {\n@@ -525,8 +520,8 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).def_path_hash(def.index)\n     }\n \n-    fn def_path_table(&self, cnum: CrateNum) -> Lrc<DefPathTable> {\n-        self.get_crate_data(cnum).def_path_table.clone()\n+    fn def_path_table(&self, cnum: CrateNum) -> &DefPathTable {\n+        &self.get_crate_data(cnum).def_path_table\n     }\n \n     fn crates_untracked(&self) -> Vec<CrateNum>"}, {"sha": "a5298402dd4115b95839ce89a65d2704d422bf92", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 82, "deletions": 4, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -212,20 +212,21 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::locator or metadata::creader for all the juicy details!\n \n-use crate::cstore::{MetadataBlob, CStore};\n+use crate::cstore::MetadataBlob;\n use crate::creader::Library;\n use crate::schema::{METADATA_HEADER, rustc_version};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc::middle::cstore::{CrateSource, MetadataLoader};\n-use rustc::session::{config, Session};\n+use rustc::session::{config, Session, CrateDisambiguator};\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n use rustc::util::nodemap::FxHashMap;\n \n use errors::DiagnosticBuilder;\n+use syntax::{span_err, span_fatal};\n use syntax::symbol::{Symbol, sym};\n use syntax::struct_span_err;\n use syntax_pos::Span;\n@@ -911,10 +912,87 @@ fn get_metadata_section_imp(target: &Target,\n     }\n }\n \n+/// Look for a plugin registrar. Returns its library path and crate disambiguator.\n+pub fn find_plugin_registrar(\n+    sess: &Session,\n+    metadata_loader: &dyn MetadataLoader,\n+    span: Span,\n+    name: Symbol,\n+) -> Option<(PathBuf, CrateDisambiguator)> {\n+    info!(\"find plugin registrar `{}`\", name);\n+    let target_triple = sess.opts.target_triple.clone();\n+    let host_triple = TargetTriple::from_triple(config::host_triple());\n+    let is_cross = target_triple != host_triple;\n+    let mut target_only = false;\n+    let mut locate_ctxt = Context {\n+        sess,\n+        span,\n+        crate_name: name,\n+        hash: None,\n+        extra_filename: None,\n+        filesearch: sess.host_filesearch(PathKind::Crate),\n+        target: &sess.host,\n+        triple: host_triple,\n+        root: None,\n+        rejected_via_hash: vec![],\n+        rejected_via_triple: vec![],\n+        rejected_via_kind: vec![],\n+        rejected_via_version: vec![],\n+        rejected_via_filename: vec![],\n+        should_match_name: true,\n+        is_proc_macro: None,\n+        metadata_loader,\n+    };\n+\n+    let library = locate_ctxt.maybe_load_library_crate().or_else(|| {\n+        if !is_cross {\n+            return None\n+        }\n+        // Try loading from target crates. This will abort later if we\n+        // try to load a plugin registrar function,\n+        target_only = true;\n+\n+        locate_ctxt.target = &sess.target.target;\n+        locate_ctxt.triple = target_triple;\n+        locate_ctxt.filesearch = sess.target_filesearch(PathKind::Crate);\n+\n+        locate_ctxt.maybe_load_library_crate()\n+    });\n+    let library = match library {\n+        Some(l) => l,\n+        None => locate_ctxt.report_errs(),\n+    };\n+\n+    if target_only {\n+        // Need to abort before syntax expansion.\n+        let message = format!(\"plugin `{}` is not available for triple `{}` \\\n+                                (only found {})\",\n+                                name,\n+                                config::host_triple(),\n+                                sess.opts.target_triple);\n+        span_fatal!(sess, span, E0456, \"{}\", &message);\n+    }\n+\n+    match library.source.dylib {\n+        Some(dylib) => {\n+            Some((dylib.0, library.metadata.get_root().disambiguator))\n+        }\n+        None => {\n+            span_err!(sess, span, E0457,\n+                        \"plugin `{}` only found in rlib format, but must be available \\\n+                        in dylib format\",\n+                        name);\n+            // No need to abort because the loading code will just ignore this\n+            // empty dylib.\n+            None\n+        }\n+    }\n+}\n+\n /// A diagnostic function for dumping crate metadata to an output stream.\n pub fn list_file_metadata(target: &Target,\n                           path: &Path,\n-                          cstore: &CStore,\n+                          metadata_loader: &dyn MetadataLoader,\n                           out: &mut dyn io::Write)\n                           -> io::Result<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n@@ -925,7 +1003,7 @@ pub fn list_file_metadata(target: &Target,\n     } else {\n         CrateFlavor::Dylib\n     };\n-    match get_metadata_section(target, flavor, path, &*cstore.metadata_loader) {\n+    match get_metadata_section(target, flavor, path, metadata_loader) {\n         Ok(metadata) => metadata.list_crate_metadata(out),\n         Err(msg) => write!(out, \"{}\\n\", msg),\n     }"}, {"sha": "98e286e61e942d54c7e293f34ebf2e01680da233", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 15, "deletions": 129, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -25,7 +25,6 @@ use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::hir::ptr::P;\n \n use rustc_index::vec::Idx;\n-use rustc_data_structures::fx::FxHashSet;\n \n use std::cmp::Ordering;\n use std::fmt;\n@@ -1000,15 +999,21 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         if self.include_lint_checks && !saw_error {\n             // If we were able to successfully convert the const to some pat, double-check\n             // that the type of the const obeys `#[structural_match]` constraint.\n-            if let Some(adt_def) = search_for_adt_without_structural_match(self.tcx, cv.ty) {\n-\n-                let path = self.tcx.def_path_str(adt_def.did);\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path,\n-                    path,\n-                );\n+            if let Some(non_sm_ty) = ty::search_for_structural_match_violation(self.tcx, cv.ty) {\n+                let msg = match non_sm_ty {\n+                    ty::NonStructuralMatchTy::Adt(adt_def) => {\n+                        let path = self.tcx.def_path_str(adt_def.did);\n+                        format!(\n+                            \"to use a constant of type `{}` in a pattern, \\\n+                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                            path,\n+                            path,\n+                        )\n+                    }\n+                    ty::NonStructuralMatchTy::Param => {\n+                        bug!(\"use of constant whose type is a parameter inside a pattern\");\n+                    }\n+                };\n \n                 // before issuing lint, double-check there even *is* a\n                 // semantic PartialEq for us to dispatch to.\n@@ -1169,125 +1174,6 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     }\n }\n \n-/// This method traverses the structure of `ty`, trying to find an\n-/// instance of an ADT (i.e. struct or enum) that was declared without\n-/// the `#[structural_match]` attribute.\n-///\n-/// The \"structure of a type\" includes all components that would be\n-/// considered when doing a pattern match on a constant of that\n-/// type.\n-///\n-///  * This means this method descends into fields of structs/enums,\n-///    and also descends into the inner type `T` of `&T` and `&mut T`\n-///\n-///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n-///    `*mut T`), and it does not visit the type arguments of an\n-///    instantiated generic like `PhantomData<T>`.\n-///\n-/// The reason we do this search is Rust currently require all ADT's\n-/// reachable from a constant's type to be annotated with\n-/// `#[structural_match]`, an attribute which essentially says that\n-/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n-/// comparison against the unfolded structure.\n-///\n-/// For more background on why Rust has this requirement, and issues\n-/// that arose when the requirement was not enforced completely, see\n-/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n-fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n-                                                 ty: Ty<'tcx>)\n-                                                 -> Option<&'tcx AdtDef>\n-{\n-    // Import here (not mod level), because `TypeFoldable::fold_with`\n-    // conflicts with `PatternFoldable::fold_with`\n-    use crate::rustc::ty::fold::TypeVisitor;\n-    use crate::rustc::ty::TypeFoldable;\n-\n-    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n-    ty.visit_with(&mut search);\n-    return search.found;\n-\n-    struct Search<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-\n-        // records the first ADT we find without `#[structural_match`\n-        found: Option<&'tcx AdtDef>,\n-\n-        // tracks ADT's previously encountered during search, so that\n-        // we will not recur on them again.\n-        seen: FxHashSet<hir::def_id::DefId>,\n-    }\n-\n-    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n-        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-            debug!(\"Search visiting ty: {:?}\", ty);\n-\n-            let (adt_def, substs) = match ty.kind {\n-                ty::Adt(adt_def, substs) => (adt_def, substs),\n-                ty::RawPtr(..) => {\n-                    // `#[structural_match]` ignores substructure of\n-                    // `*const _`/`*mut _`, so skip super_visit_with\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::FnDef(..) | ty::FnPtr(..) => {\n-                    // types of formals and return in `fn(_) -> _` are also irrelevant\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n-                => {\n-                    // rust-lang/rust#62336: ignore type of contents\n-                    // for empty array.\n-                    return false;\n-                }\n-                _ => {\n-                    ty.super_visit_with(self);\n-                    return false;\n-                }\n-            };\n-\n-            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n-                self.found = Some(&adt_def);\n-                debug!(\"Search found adt_def: {:?}\", adt_def);\n-                return true // Halt visiting!\n-            }\n-\n-            if !self.seen.insert(adt_def.did) {\n-                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n-                // let caller continue its search\n-                return false;\n-            }\n-\n-            // `#[structural_match]` does not care about the\n-            // instantiation of the generics in an ADT (it\n-            // instead looks directly at its fields outside\n-            // this match), so we skip super_visit_with.\n-            //\n-            // (Must not recur on substs for `PhantomData<T>` cf\n-            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n-            // want to skip substs when only uses of generic are\n-            // behind unsafe pointers `*const T`/`*mut T`.)\n-\n-            // even though we skip super_visit_with, we must recur on\n-            // fields of ADT.\n-            let tcx = self.tcx;\n-            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n-                if field_ty.visit_with(self) {\n-                    // found an ADT without `#[structural_match]`; halt visiting!\n-                    assert!(self.found.is_some());\n-                    return true;\n-                }\n-            }\n-\n-            // Even though we do not want to recur on substs, we do\n-            // want our caller to continue its own search.\n-            false\n-        }\n-    }\n-}\n-\n impl UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx"}, {"sha": "8ceb56b0fd2b4c4004f2d809664499e95bbf133a", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -1,8 +1,8 @@\n //! Used by `rustc` when loading a plugin.\n \n+use rustc::middle::cstore::MetadataLoader;\n use rustc::session::Session;\n-use rustc_metadata::creader::CrateLoader;\n-use rustc_metadata::cstore::CStore;\n+use rustc_metadata::locator;\n use crate::registry::Registry;\n \n use std::borrow::ToOwned;\n@@ -25,7 +25,7 @@ pub struct PluginRegistrar {\n \n struct PluginLoader<'a> {\n     sess: &'a Session,\n-    reader: CrateLoader<'a>,\n+    metadata_loader: &'a dyn MetadataLoader,\n     plugins: Vec<PluginRegistrar>,\n }\n \n@@ -37,11 +37,10 @@ fn call_malformed_plugin_attribute(sess: &Session, span: Span) {\n \n /// Read plugin metadata and dynamically load registrar functions.\n pub fn load_plugins(sess: &Session,\n-                    cstore: &CStore,\n+                    metadata_loader: &dyn MetadataLoader,\n                     krate: &ast::Crate,\n-                    crate_name: &str,\n                     addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n-    let mut loader = PluginLoader::new(sess, cstore, crate_name);\n+    let mut loader = PluginLoader { sess, metadata_loader, plugins: Vec::new() };\n \n     // do not report any error now. since crate attributes are\n     // not touched by expansion, every use of plugin without\n@@ -80,16 +79,8 @@ pub fn load_plugins(sess: &Session,\n }\n \n impl<'a> PluginLoader<'a> {\n-    fn new(sess: &'a Session, cstore: &'a CStore, crate_name: &str) -> Self {\n-        PluginLoader {\n-            sess,\n-            reader: CrateLoader::new(sess, cstore, crate_name),\n-            plugins: vec![],\n-        }\n-    }\n-\n     fn load_plugin(&mut self, span: Span, name: Symbol, args: Vec<ast::NestedMetaItem>) {\n-        let registrar = self.reader.find_plugin_registrar(span, name);\n+        let registrar = locator::find_plugin_registrar(self.sess, self.metadata_loader, span, name);\n \n         if let Some((lib, disambiguator)) = registrar {\n             let symbol = self.sess.generate_plugin_registrar_symbol(disambiguator);"}, {"sha": "c0fb8e33a819eb6ec0bc6313a20e9c4447edbe52", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -110,9 +110,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n-            (self.cstore.crate_name_untracked(def_id.krate), None)\n+            (self.cstore().crate_name_untracked(def_id.krate), None)\n         } else {\n-            let def_key = self.cstore.def_key(def_id);\n+            let def_key = self.cstore().def_key(def_id);\n             (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n              Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n         };\n@@ -153,9 +153,8 @@ impl<'a> Resolver<'a> {\n             return Some(ext.clone());\n         }\n \n-        let ext = Lrc::new(match self.cstore.load_macro_untracked(def_id, &self.session) {\n-            LoadedMacro::MacroDef(item) =>\n-                self.compile_macro(&item, self.cstore.crate_edition_untracked(def_id.krate)),\n+        let ext = Lrc::new(match self.cstore().load_macro_untracked(def_id, &self.session) {\n+            LoadedMacro::MacroDef(item, edition) => self.compile_macro(&item, edition),\n             LoadedMacro::ProcMacro(ext) => ext,\n         });\n \n@@ -177,7 +176,7 @@ impl<'a> Resolver<'a> {\n \n     crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n         let def_id = module.def_id().expect(\"unpopulated module without a def-id\");\n-        for child in self.cstore.item_children_untracked(def_id, self.session) {\n+        for child in self.cstore().item_children_untracked(def_id, self.session) {\n             let child = child.map_id(|_| panic!(\"unexpected id\"));\n             BuildReducedGraphVisitor { r: self, parent_scope: ParentScope::module(module) }\n                 .build_reduced_graph_for_external_crate_res(child);\n@@ -885,19 +884,19 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 bug!(\"unexpected resolution: {:?}\", res)\n         }\n         // Record some extra data for better diagnostics.\n+        let cstore = self.r.cstore();\n         match res {\n             Res::Def(DefKind::Struct, def_id) | Res::Def(DefKind::Union, def_id) => {\n-                let field_names =\n-                    self.r.cstore.struct_field_names_untracked(def_id, self.r.session);\n+                let field_names = cstore.struct_field_names_untracked(def_id, self.r.session);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Res::Def(DefKind::Method, def_id) => {\n-                if self.r.cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n+                if cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n                     self.r.has_self.insert(def_id);\n                 }\n             }\n             Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                let parent = self.r.cstore.def_key(def_id).parent;\n+                let parent = cstore.def_key(def_id).parent;\n                 if let Some(struct_def_id) = parent.map(|index| DefId { index, ..def_id }) {\n                     self.r.struct_constructors.insert(struct_def_id, (res, vis));\n                 }"}, {"sha": "7634093fbefbac29bbbb8f0336bc92a40ed95011", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -367,16 +367,6 @@ impl<'a> Resolver<'a> {\n                     span, \"`Self` in type parameter default\".to_string());\n                 err\n             }\n-            ResolutionError::ConstParamDependentOnTypeParam => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0671,\n-                    \"const parameters cannot depend on type parameters\"\n-                );\n-                err.span_label(span, format!(\"const parameter depends on type parameter\"));\n-                err\n-            }\n         }\n     }\n "}, {"sha": "9883a64a1e896e6600b26fad803a275bfeaa7d8d", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -1880,13 +1880,14 @@ fn main() {\n \"##,\n \n E0671: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n Const parameters cannot depend on type parameters.\n The following is therefore invalid:\n-```compile_fail,E0671\n+```compile_fail,E0741\n #![feature(const_generics)]\n \n-fn const_id<T, const N: T>() -> T { // error: const parameter\n-                                    // depends on type parameter\n+fn const_id<T, const N: T>() -> T { // error\n     N\n }\n ```"}, {"sha": "136ab1f0444fa87cc334f1d77b862042e32bf51a", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -111,9 +111,6 @@ crate enum RibKind<'a> {\n     /// from the default of a type parameter because they're not declared\n     /// before said type parameter. Also see the `visit_generics` override.\n     ForwardTyParamBanRibKind,\n-\n-    /// We forbid the use of type parameters as the types of const parameters.\n-    TyParamAsConstParamTy,\n }\n \n impl RibKind<'_> {\n@@ -128,8 +125,7 @@ impl RibKind<'_> {\n             | MacroDefinition(_) => false,\n             AssocItemRibKind\n             | ItemRibKind(_)\n-            | ForwardTyParamBanRibKind\n-            | TyParamAsConstParamTy => true,\n+            | ForwardTyParamBanRibKind => true,\n         }\n     }\n }\n@@ -483,18 +479,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             default_ban_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), Res::Err);\n         }\n \n-        // We also ban access to type parameters for use as the types of const parameters.\n-        let mut const_ty_param_ban_rib = Rib::new(TyParamAsConstParamTy);\n-        const_ty_param_ban_rib.bindings.extend(generics.params.iter()\n-            .filter(|param| {\n-                if let GenericParamKind::Type { .. } = param.kind {\n-                    true\n-                } else {\n-                    false\n-                }\n-            })\n-            .map(|param| (Ident::with_dummy_span(param.ident.name), Res::Err)));\n-\n         for param in &generics.params {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => self.visit_generic_param(param),\n@@ -513,15 +497,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                     default_ban_rib.bindings.remove(&Ident::with_dummy_span(param.ident.name));\n                 }\n                 GenericParamKind::Const { ref ty } => {\n-                    self.ribs[TypeNS].push(const_ty_param_ban_rib);\n-\n                     for bound in &param.bounds {\n                         self.visit_param_bound(bound);\n                     }\n-\n                     self.visit_ty(ty);\n-\n-                    const_ty_param_ban_rib = self.ribs[TypeNS].pop().unwrap();\n                 }\n             }\n         }"}, {"sha": "92392806347244ce9e65f93f4b61b85494b04afd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 68, "deletions": 33, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -21,14 +21,14 @@ use Determinacy::*;\n \n use rustc::hir::map::Definitions;\n use rustc::hir::{self, PrimTy, Bool, Char, Float, Int, Uint, Str};\n-use rustc::middle::cstore::CrateStore;\n+use rustc::middle::cstore::{CrateStore, MetadataLoaderDyn};\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::{self, DefKind, PartialRes, CtorKind, CtorOf, NonMacroAttrKind, ExportMap};\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::{TraitMap, GlobMap};\n-use rustc::ty::{self, DefIdTree};\n+use rustc::ty::{self, DefIdTree, ResolverOutputs};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::span_bug;\n \n@@ -215,8 +215,6 @@ enum ResolutionError<'a> {\n     ForwardDeclaredTyParam, // FIXME(const_generics:defaults)\n     /// Error E0735: type parameters with a default cannot use `Self`\n     SelfInTyParamDefault,\n-    /// Error E0671: const parameter cannot depend on type parameter.\n-    ConstParamDependentOnTypeParam,\n }\n \n // A minimal representation of a path segment. We use this in resolve because\n@@ -829,14 +827,13 @@ pub struct ExternPreludeEntry<'a> {\n /// This is the visitor that walks the whole crate.\n pub struct Resolver<'a> {\n     session: &'a Session,\n-    cstore: &'a CStore,\n \n-    pub definitions: Definitions,\n+    definitions: Definitions,\n \n-    pub graph_root: Module<'a>,\n+    graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n-    pub extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'a>>,\n+    extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'a>>,\n \n     /// N.B., this is used only for better diagnostics, not name resolution itself.\n     has_self: FxHashSet<DefId>,\n@@ -869,9 +866,9 @@ pub struct Resolver<'a> {\n     label_res_map: NodeMap<NodeId>,\n \n     /// `CrateNum` resolutions of `extern crate` items.\n-    pub extern_crate_map: NodeMap<CrateNum>,\n-    pub export_map: ExportMap<NodeId>,\n-    pub trait_map: TraitMap,\n+    extern_crate_map: NodeMap<CrateNum>,\n+    export_map: ExportMap<NodeId>,\n+    trait_map: TraitMap,\n \n     /// A map from nodes to anonymous modules.\n     /// Anonymous modules are pseudo-modules that are implicitly created around items\n@@ -898,11 +895,11 @@ pub struct Resolver<'a> {\n     underscore_disambiguator: u32,\n \n     /// Maps glob imports to the names of items actually imported.\n-    pub glob_map: GlobMap,\n+    glob_map: GlobMap,\n \n     used_imports: FxHashSet<(NodeId, Namespace)>,\n-    pub maybe_unused_trait_imports: NodeSet,\n-    pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n+    maybe_unused_trait_imports: NodeSet,\n+    maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n \n     /// Privacy errors are delayed until the end in order to deduplicate them.\n     privacy_errors: Vec<PrivacyError<'a>>,\n@@ -916,11 +913,11 @@ pub struct Resolver<'a> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n \n-    crate_loader: &'a CrateLoader<'a>,\n+    crate_loader: CrateLoader<'a>,\n     macro_names: FxHashSet<Ident>,\n     builtin_macros: FxHashMap<Name, SyntaxExtension>,\n     macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n-    pub all_macros: FxHashMap<Name, Res>,\n+    all_macros: FxHashMap<Name, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n     dummy_ext_bang: Lrc<SyntaxExtension>,\n     dummy_ext_derive: Lrc<SyntaxExtension>,\n@@ -1015,14 +1012,18 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n         match id.krate {\n             LOCAL_CRATE => self.definitions.def_key(id.index).parent,\n-            _ => self.cstore.def_key(id).parent,\n+            _ => self.cstore().def_key(id).parent,\n         }.map(|index| DefId { index, ..id })\n     }\n }\n \n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n impl<'a> hir::lowering::Resolver for Resolver<'a> {\n+    fn cstore(&self) -> &dyn CrateStore {\n+        self.cstore()\n+    }\n+\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n@@ -1083,10 +1084,9 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n \n impl<'a> Resolver<'a> {\n     pub fn new(session: &'a Session,\n-               cstore: &'a CStore,\n                krate: &Crate,\n                crate_name: &str,\n-               crate_loader: &'a CrateLoader<'a>,\n+               metadata_loader: &'a MetadataLoaderDyn,\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n@@ -1147,8 +1147,6 @@ impl<'a> Resolver<'a> {\n         Resolver {\n             session,\n \n-            cstore,\n-\n             definitions,\n \n             // The outermost module has def ID 0; this is not reflected in the\n@@ -1202,7 +1200,7 @@ impl<'a> Resolver<'a> {\n                 vis: ty::Visibility::Public,\n             }),\n \n-            crate_loader,\n+            crate_loader: CrateLoader::new(session, metadata_loader, crate_name),\n             macro_names: FxHashSet::default(),\n             builtin_macros: Default::default(),\n             macro_use_prelude: FxHashMap::default(),\n@@ -1236,6 +1234,42 @@ impl<'a> Resolver<'a> {\n         Default::default()\n     }\n \n+    pub fn into_outputs(self) -> ResolverOutputs {\n+        ResolverOutputs {\n+            definitions: self.definitions,\n+            cstore: Box::new(self.crate_loader.into_cstore()),\n+            extern_crate_map: self.extern_crate_map,\n+            export_map: self.export_map,\n+            trait_map: self.trait_map,\n+            glob_map: self.glob_map,\n+            maybe_unused_trait_imports: self.maybe_unused_trait_imports,\n+            maybe_unused_extern_crates: self.maybe_unused_extern_crates,\n+            extern_prelude: self.extern_prelude.iter().map(|(ident, entry)| {\n+                (ident.name, entry.introduced_by_item)\n+            }).collect(),\n+        }\n+    }\n+\n+    pub fn clone_outputs(&self) -> ResolverOutputs {\n+        ResolverOutputs {\n+            definitions: self.definitions.clone(),\n+            cstore: Box::new(self.cstore().clone()),\n+            extern_crate_map: self.extern_crate_map.clone(),\n+            export_map: self.export_map.clone(),\n+            trait_map: self.trait_map.clone(),\n+            glob_map: self.glob_map.clone(),\n+            maybe_unused_trait_imports: self.maybe_unused_trait_imports.clone(),\n+            maybe_unused_extern_crates: self.maybe_unused_extern_crates.clone(),\n+            extern_prelude: self.extern_prelude.iter().map(|(ident, entry)| {\n+                (ident.name, entry.introduced_by_item)\n+            }).collect(),\n+        }\n+    }\n+\n+    pub fn cstore(&self) -> &CStore {\n+        self.crate_loader.cstore()\n+    }\n+\n     fn non_macro_attr(&self, mark_used: bool) -> Lrc<SyntaxExtension> {\n         self.non_macro_attrs[mark_used as usize].clone()\n     }\n@@ -2169,15 +2203,6 @@ impl<'a> Resolver<'a> {\n             return Res::Err;\n         }\n \n-        // An invalid use of a type parameter as the type of a const parameter.\n-        if let TyParamAsConstParamTy = all_ribs[rib_index].kind {\n-            if record_used {\n-                self.report_error(span, ResolutionError::ConstParamDependentOnTypeParam);\n-            }\n-            assert_eq!(res, Res::Err);\n-            return Res::Err;\n-        }\n-\n         match res {\n             Res::Local(_) => {\n                 use ResolutionError::*;\n@@ -2186,7 +2211,7 @@ impl<'a> Resolver<'a> {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) |\n-                        ForwardTyParamBanRibKind | TyParamAsConstParamTy => {\n+                        ForwardTyParamBanRibKind => {\n                             // Nothing to do. Continue.\n                         }\n                         ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n@@ -2220,7 +2245,7 @@ impl<'a> Resolver<'a> {\n                     let has_generic_params = match rib.kind {\n                         NormalRibKind | AssocItemRibKind |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n-                        ConstantItemRibKind | TyParamAsConstParamTy => {\n+                        ConstantItemRibKind => {\n                             // Nothing to do. Continue.\n                             continue;\n                         }\n@@ -2808,6 +2833,16 @@ impl<'a> Resolver<'a> {\n         seg.id = self.session.next_node_id();\n         seg\n     }\n+\n+    // For rustdoc.\n+    pub fn graph_root(&self) -> Module<'a> {\n+        self.graph_root\n+    }\n+\n+    // For rustdoc.\n+    pub fn all_macros(&self) -> &FxHashMap<Name, Res> {\n+        &self.all_macros\n+    }\n }\n \n fn names_to_string(names: &[Name]) -> String {"}, {"sha": "31340ddd68372f18455ab587247f4eaea20d3d69", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -1344,7 +1344,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 if res != Res::Err {\n                     if let Some(def_id) = res.opt_def_id() {\n                         if !def_id.is_local() {\n-                            this.cstore.export_macros_untracked(def_id.krate);\n+                            this.cstore().export_macros_untracked(def_id.krate);\n                         }\n                     }\n                     reexports.push(Export {"}, {"sha": "59636d32bc037b84dcee5d97e5fcfa36f39bffd5", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -141,14 +141,24 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // ADJUSTMENTS\n \n-    fn adjust_self_ty(&mut self,\n-                      unadjusted_self_ty: Ty<'tcx>,\n-                      pick: &probe::Pick<'tcx>)\n-                      -> Ty<'tcx> {\n+    fn adjust_self_ty(\n+        &mut self,\n+        unadjusted_self_ty: Ty<'tcx>,\n+        pick: &probe::Pick<'tcx>,\n+    ) -> Ty<'tcx> {\n         // Commit the autoderefs by calling `autoderef` again, but this\n         // time writing the results into the various tables.\n         let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n-        let (_, n) = autoderef.nth(pick.autoderefs).unwrap();\n+        let (_, n) = match autoderef.nth(pick.autoderefs) {\n+            Some(n) => n,\n+            None => {\n+                self.tcx.sess.delay_span_bug(\n+                    syntax_pos::DUMMY_SP,\n+                    &format!(\"failed autoderef {}\", pick.autoderefs),\n+                );\n+                return self.tcx.types.err;\n+            }\n+        };\n         assert_eq!(n, pick.autoderefs);\n \n         let mut adjustments = autoderef.adjust_steps(self, Needs::None);"}, {"sha": "96a097695fa1f00d9269d551b6f38d1148661a87", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -2767,8 +2767,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut opaque_types = self.opaque_types.borrow_mut();\n         for (ty, decl) in opaque_type_map {\n-            let old_value = opaque_types.insert(ty, decl);\n-            assert!(old_value.is_none(), \"instantiated twice: {:?}/{:?}\", ty, decl);\n+            let _ = opaque_types.insert(ty, decl);\n         }\n \n         value"}, {"sha": "00435d67184a356b9ae6835769163c3171b1a182", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -1532,6 +1532,17 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                         );\n                     };\n                 }\n+                if ty::search_for_structural_match_violation(tcx, ty).is_some() {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        hir_ty.span,\n+                        E0741,\n+                        \"the types of const generic parameters must derive `PartialEq` and `Eq`\",\n+                    ).span_label(\n+                        hir_ty.span,\n+                        format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n+                    ).emit();\n+                }\n                 ty\n             }\n             x => {"}, {"sha": "75b508a1bbf0ff6961d2631aabbb7229b143cf3a", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -5005,6 +5005,30 @@ the future, [RFC 2091] prohibits their implementation without a follow-up RFC.\n [RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\n \"##,\n \n+E0741: r##\"\n+Only `structural_match` types (that is, types that derive `PartialEq` and `Eq`)\n+may be used as the types of const generic parameters.\n+\n+```compile_fail,E0741\n+#![feature(const_generics)]\n+\n+struct A;\n+\n+struct B<const X: A>; // error!\n+```\n+\n+To fix this example, we derive `PartialEq` and `Eq`.\n+\n+```\n+#![feature(const_generics)]\n+\n+#[derive(PartialEq, Eq)]\n+struct A;\n+\n+struct B<const X: A>; // ok!\n+```\n+\"##,\n+\n ;\n //  E0035, merged into E0087/E0089\n //  E0036, merged into E0087/E0089"}, {"sha": "a6a8fec429e20ec80030a282350a18e6bf274738", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -479,8 +479,8 @@ fn build_static(cx: &DocContext<'_>, did: DefId, mutable: bool) -> clean::Static\n \n fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemEnum {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n-    match cx.cstore.load_macro_untracked(did, cx.sess()) {\n-        LoadedMacro::MacroDef(def) => {\n+    match cx.enter_resolver(|r| r.cstore().load_macro_untracked(did, cx.sess())) {\n+        LoadedMacro::MacroDef(def, _) => {\n             let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.kind {\n                 let tts: Vec<_> = def.stream().into_trees().collect();\n                 tts.chunks(4).map(|arm| arm[0].span()).collect()"}, {"sha": "b227f432a4e98d3b0b24ec111f7fdfd8208831d6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -12,7 +12,6 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_interface::interface;\n use rustc_driver::abort_on_err;\n use rustc_resolve as resolve;\n-use rustc_metadata::cstore::CStore;\n \n use syntax::source_map;\n use syntax::attr;\n@@ -43,7 +42,6 @@ pub struct DocContext<'tcx> {\n \n     pub tcx: TyCtxt<'tcx>,\n     pub resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    pub cstore: Lrc<CStore>,\n     /// Later on moved into `html::render::CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n@@ -117,9 +115,7 @@ impl<'tcx> DocContext<'tcx> {\n                     .def_path_table()\n                     .next_id()\n             } else {\n-                self.cstore\n-                    .def_path_table(crate_num)\n-                    .next_id()\n+                self.enter_resolver(|r| r.cstore().def_path_table(crate_num).next_id())\n             };\n \n             DefId {\n@@ -376,7 +372,6 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             let mut ctxt = DocContext {\n                 tcx,\n                 resolver,\n-                cstore: compiler.cstore().clone(),\n                 external_traits: Default::default(),\n                 active_extern_traits: Default::default(),\n                 renderinfo: RefCell::new(renderinfo),"}, {"sha": "caa7f08f68cffb3fb15840ab08108ab8ba229e7b", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -432,13 +432,13 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n     let path = ast::Path::from_ident(Ident::from_str(path_str));\n     cx.enter_resolver(|resolver| {\n         if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-            &path, None, &ParentScope::module(resolver.graph_root), false, false\n+            &path, None, &ParentScope::module(resolver.graph_root()), false, false\n         ) {\n             if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n                 return Some(res.map_id(|_| panic!(\"unexpected id\")));\n             }\n         }\n-        if let Some(res) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n+        if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n             return Some(res.map_id(|_| panic!(\"unexpected id\")));\n         }\n         None"}, {"sha": "efe5c9d28f0d29679ecfc315ab2566d738a302bd", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -23,7 +23,7 @@ libc = { version = \"0.2.51\", default-features = false, features = ['rustc-dep-of\n compiler_builtins = { version = \"0.1.16\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n unwind = { path = \"../libunwind\" }\n-hashbrown = { version = \"0.6.1\", default-features = false, features = ['rustc-dep-of-std'] }\n+hashbrown = { version = \"0.6.2\", default-features = false, features = ['rustc-dep-of-std'] }\n \n [dependencies.backtrace_rs]\n package = \"backtrace\""}, {"sha": "37310f46f7eed7c4a93fca9b99306fd0ab610593", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -278,7 +278,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// format string.\n     fn report_invalid_references(&self, numbered_position_args: bool) {\n         let mut e;\n-        let sp = if self.is_literal {\n+        let sp = if self.is_literal { // Point at the formatting arguments.\n             MultiSpan::from_spans(self.arg_spans.clone())\n         } else {\n             MultiSpan::from_span(self.fmtsp)\n@@ -304,6 +304,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.describe_num_args(),\n                 ),\n             );\n+            for arg in &self.args { // Point at the arguments that will be formatted.\n+                e.span_label(arg.span, \"\");\n+            }\n         } else {\n             let (mut refs, spans): (Vec<_>, Vec<_>) = refs.unzip();\n             // Avoid `invalid reference to positional arguments 7 and 7 (there is 1 argument)`"}, {"sha": "eb96c61060b391d1baa4597258aa3bd75161a9d0", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -9,14 +9,14 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n-use std::sync::{Arc, mpsc};\n+use std::sync::Arc;\n use std::path::Path;\n use syntax::symbol::Symbol;\n use rustc::session::Session;\n use rustc::session::config::OutputFilenames;\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoader, MetadataLoaderDyn};\n use rustc::dep_graph::DepGraph;\n use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -41,7 +41,7 @@ impl MetadataLoader for NoLlvmMetadataLoader {\n struct TheBackend;\n \n impl CodegenBackend for TheBackend {\n-    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n+    fn metadata_loader(&self) -> Box<MetadataLoaderDyn> {\n         Box::new(NoLlvmMetadataLoader)\n     }\n "}, {"sha": "2d506787b3b8038a6269bc2a6a92157ec67a8321", "filename": "src/test/rustdoc/const-generics/const-impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -4,6 +4,7 @@\n \n #![crate_name = \"foo\"]\n \n+#[derive(PartialEq, Eq)]\n pub enum Order {\n     Sorted,\n     Unsorted,"}, {"sha": "78bd549ba791a456739aa62a60d2462aa4d8082f", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param-ungated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -1,6 +1,6 @@\n use std::marker::PhantomData;\n \n struct B<T, const N: T>(PhantomData<[T; N]>); //~ ERROR const generics are unstable\n-//~^ ERROR const parameters cannot depend on type parameters\n+//~^ ERROR the types of const generic parameters must derive `PartialEq` and `Eq`\n \n fn main() {}"}, {"sha": "a2872ab982da49ed13519285ddc23608e86c2405", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param-ungated.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -1,9 +1,3 @@\n-error[E0671]: const parameters cannot depend on type parameters\n-  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:22\n-   |\n-LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n-   |                      ^ const parameter depends on type parameter\n-\n error[E0658]: const generics are unstable\n   --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:19\n    |\n@@ -13,7 +7,13 @@ LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n    = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n    = help: add `#![feature(const_generics)]` to the crate attributes to enable\n \n+error[E0741]: the types of const generic parameters must derive `PartialEq` and `Eq`\n+  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:22\n+   |\n+LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n+   |                      ^ `T` doesn't derive both `PartialEq` and `Eq`\n+\n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0658, E0671.\n+Some errors have detailed explanations: E0658, E0741.\n For more information about an error, try `rustc --explain E0658`."}, {"sha": "b76209571b05cba8633f4f2606ee23bcc1071d5a", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -7,7 +7,6 @@\n // details.\n \n pub struct Dependent<T, const X: T>([(); X]);\n-//~^ ERROR const parameters cannot depend on type parameters\n-//~^^ ERROR parameter `T` is never used\n+//~^ ERROR the types of const generic parameters must derive `PartialEq` and `Eq`\n \n fn main() {}"}, {"sha": "c9d6db7e2c2200928a1462015bdda3918cd752a0", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param.stderr", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -1,9 +1,3 @@\n-error[E0671]: const parameters cannot depend on type parameters\n-  --> $DIR/const-param-type-depends-on-type-param.rs:9:34\n-   |\n-LL | pub struct Dependent<T, const X: T>([(); X]);\n-   |                                  ^ const parameter depends on type parameter\n-\n warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n   --> $DIR/const-param-type-depends-on-type-param.rs:1:12\n    |\n@@ -12,15 +6,12 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error[E0392]: parameter `T` is never used\n-  --> $DIR/const-param-type-depends-on-type-param.rs:9:22\n+error[E0741]: the types of const generic parameters must derive `PartialEq` and `Eq`\n+  --> $DIR/const-param-type-depends-on-type-param.rs:9:34\n    |\n LL | pub struct Dependent<T, const X: T>([(); X]);\n-   |                      ^ unused parameter\n-   |\n-   = help: consider removing `T`, referring to it in a field, or using a marker such as `std::marker::PhantomData`\n+   |                                  ^ `T` doesn't derive both `PartialEq` and `Eq`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0392, E0671.\n-For more information about an error, try `rustc --explain E0392`.\n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "7bc4f3986eb754ba7160739f6dadc49142f7282b", "filename": "src/test/ui/const-generics/forbid-non-structural_match-types.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -0,0 +1,13 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+#[derive(PartialEq, Eq)]\n+struct A;\n+\n+struct B<const X: A>; // ok\n+\n+struct C;\n+\n+struct D<const X: C>; //~ ERROR the types of const generic parameters must derive\n+\n+fn main() {}"}, {"sha": "0fd9e0599e80e47c91e987687af38b0f160810ce", "filename": "src/test/ui/const-generics/forbid-non-structural_match-types.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.stderr?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -0,0 +1,17 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/forbid-non-structural_match-types.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0741]: the types of const generic parameters must derive `PartialEq` and `Eq`\n+  --> $DIR/forbid-non-structural_match-types.rs:11:19\n+   |\n+LL | struct D<const X: C>;\n+   |                   ^ `C` doesn't derive both `PartialEq` and `Eq`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "691c06a2402c5352ec39c4650ff3d82bb0d76505", "filename": "src/test/ui/fmt/format-string-error.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -48,4 +48,6 @@ fn main() {\n \n \"###);\n     //~^^^ ERROR invalid format string: unmatched `}` found\n+    println!(\"{} {} {}\", 1, 2);\n+    //~^ ERROR 3 positional arguments in format string, but there are 2 arguments\n }"}, {"sha": "32119b18774b25585c1f00395a2a80b5fd04dbf0", "filename": "src/test/ui/fmt/format-string-error.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -107,5 +107,11 @@ LL |         }\n    |\n    = note: if you intended to print `}`, you can escape it using `}}`\n \n-error: aborting due to 12 previous errors\n+error: 3 positional arguments in format string, but there are 2 arguments\n+  --> $DIR/format-string-error.rs:51:15\n+   |\n+LL |     println!(\"{} {} {}\", 1, 2);\n+   |               ^^ ^^ ^^   -  -\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "c58cbc312335a6588553ec4967cd721672eb074d", "filename": "src/test/ui/if/ifmt-bad-arg.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fifmt-bad-arg.stderr?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -224,8 +224,9 @@ error: 4 positional arguments in format string, but there are 3 arguments\n   --> $DIR/ifmt-bad-arg.rs:78:15\n    |\n LL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n-   |               ^^ ^^--^ ^^      --- this parameter corresponds to the precision flag\n-   |                    |\n+   |               ^^ ^^--^ ^^   -  ---  -\n+   |                    |           |\n+   |                    |           this parameter corresponds to the precision flag\n    |                    this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n    |\n    = note: positional arguments are zero-based\n@@ -235,8 +236,9 @@ error: 4 positional arguments in format string, but there are 3 arguments\n   --> $DIR/ifmt-bad-arg.rs:81:15\n    |\n LL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n-   |               ^^ ^^^----^ ^^      --- this parameter corresponds to the precision flag\n-   |                     | |\n+   |               ^^ ^^^----^ ^^   -  ---  -\n+   |                     | |           |\n+   |                     | |           this parameter corresponds to the precision flag\n    |                     | this precision flag adds an extra required argument at position 1, which is why there are 4 arguments expected\n    |                     this width flag expects an `usize` argument at position 7, but there are 3 arguments\n    |"}, {"sha": "02e3139d2944483fc4300eabf2211b335b5b008b", "filename": "src/test/ui/intrinsics/intrinsic-alignment.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-alignment.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -19,7 +19,8 @@ mod rusti {\n           target_os = \"macos\",\n           target_os = \"netbsd\",\n           target_os = \"openbsd\",\n-          target_os = \"solaris\"))]\n+          target_os = \"solaris\",\n+          target_os = \"vxworks\"))]\n mod m {\n     #[main]\n     #[cfg(target_arch = \"x86\")]"}, {"sha": "b74ee1b0c6e54b6ffae430f3a7b8a0f2054dd29b", "filename": "src/test/ui/issues/issue-65611.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fissues%2Fissue-65611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fissues%2Fissue-65611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65611.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -0,0 +1,63 @@\n+use std::mem::MaybeUninit;\n+use std::ops::Deref;\n+\n+pub unsafe trait Array {\n+    /// The array\u2019s element type\n+    type Item;\n+    #[doc(hidden)]\n+    /// The smallest index type that indexes the array.\n+    type Index: Index;\n+    #[doc(hidden)]\n+    fn as_ptr(&self) -> *const Self::Item;\n+    #[doc(hidden)]\n+    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n+    #[doc(hidden)]\n+    fn capacity() -> usize;\n+}\n+\n+pub trait Index : PartialEq + Copy {\n+    fn to_usize(self) -> usize;\n+    fn from(usize) -> Self;\n+}\n+\n+impl Index for usize {\n+    fn to_usize(self) -> usize { self }\n+    fn from(val: usize) -> Self {\n+        val\n+    }\n+}\n+\n+unsafe impl<T> Array for [T; 1] {\n+    type Item = T;\n+    type Index = usize;\n+    fn as_ptr(&self) -> *const T { self as *const _ as *const _ }\n+    fn as_mut_ptr(&mut self) -> *mut T { self as *mut _ as *mut _}\n+    fn capacity() -> usize { 1 }\n+}\n+\n+impl<A: Array> Deref for ArrayVec<A> {\n+    type Target = [A::Item];\n+    #[inline]\n+    fn deref(&self) -> &[A::Item] {\n+        panic!()\n+    }\n+}\n+\n+pub struct ArrayVec<A: Array> {\n+    xs: MaybeUninit<A>,\n+    len: usize,\n+}\n+\n+impl<A: Array> ArrayVec<A> {\n+    pub fn new() -> ArrayVec<A> {\n+        panic!()\n+    }\n+}\n+\n+fn main() {\n+    let mut buffer = ArrayVec::new();\n+    let x = buffer.last().unwrap().0.clone();\n+    //~^ ERROR type annotations needed\n+    //~| ERROR no field `0` on type `&_`\n+    buffer.reverse();\n+}"}, {"sha": "cb441c13c6b9e9e1329eca7ee117b72f96ab9238", "filename": "src/test/ui/issues/issue-65611.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -0,0 +1,18 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-65611.rs:59:20\n+   |\n+LL |     let x = buffer.last().unwrap().0.clone();\n+   |                    ^^^^ cannot infer type for `T`\n+   |\n+   = note: type must be known at this point\n+\n+error[E0609]: no field `0` on type `&_`\n+  --> $DIR/issue-65611.rs:59:36\n+   |\n+LL |     let x = buffer.last().unwrap().0.clone();\n+   |                                    ^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0282, E0609.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "8fef66eac8de208d568ce678af9b4af32831383e", "filename": "src/test/ui/signal-alternate-stack-cleanup.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fsignal-alternate-stack-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fsignal-alternate-stack-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsignal-alternate-stack-cleanup.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -7,6 +7,7 @@\n // ignore-wasm32-bare no libc\n // ignore-windows\n // ignore-sgx no libc\n+// ignore-vxworks no SIGWINCH in user space\n \n #![feature(rustc_private)]\n extern crate libc;"}, {"sha": "680a690ba34e32a4d58077e26988a69f6e16a700", "filename": "src/test/ui/structs-enums/rec-align-u64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fstructs-enums%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Fstructs-enums%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Frec-align-u64.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -40,7 +40,8 @@ struct Outer {\n           target_os = \"macos\",\n           target_os = \"netbsd\",\n           target_os = \"openbsd\",\n-          target_os = \"solaris\"))]\n+          target_os = \"solaris\",\n+          target_os = \"vxworks\"))]\n mod m {\n     #[cfg(target_arch = \"x86\")]\n     pub mod m {"}, {"sha": "12eb75ae4c019d4b07987ef38c35109e8696d7fc", "filename": "src/test/ui/type-alias-impl-trait/issue-65679-inst-opaque-ty-from-val-twice.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54111afc061ef398cd8ce28984f9e8d70001b24/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type T = impl Sized;\n+// The concrete type referred by impl-trait-type-alias(`T`) is guaranteed\n+// to be the same as where it occurs, whereas `impl Trait`'s instance is location sensitive;\n+// so difference assertion should not be declared on impl-trait-type-alias's instances.\n+// for details, check RFC-2515:\n+// https://github.com/rust-lang/rfcs/blob/master/text/2515-type_alias_impl_trait.md\n+\n+fn take(_: fn() -> T) {}\n+\n+fn main() {\n+    take(|| {});\n+    take(|| {});\n+}"}, {"sha": "3ba5f27170db10af7a92f2b682e049397197b8fa", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=d54111afc061ef398cd8ce28984f9e8d70001b24", "patch": "@@ -1 +1 @@\n-Subproject commit 3a9abe3f065554a7fbc59f440df2baba4a6e47ee\n+Subproject commit 3ba5f27170db10af7a92f2b682e049397197b8fa"}]}