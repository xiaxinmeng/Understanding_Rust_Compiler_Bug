{"sha": "ef52fd543f4048d36e2c37281de4bc343871a62d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNTJmZDU0M2Y0MDQ4ZDM2ZTJjMzcyODFkZTRiYzM0Mzg3MWE2MmQ=", "commit": {"author": {"name": "Veetaha", "email": "gerzoh1@gmail.com", "date": "2020-03-07T12:08:08Z"}, "committer": {"name": "Veetaha", "email": "gerzoh1@gmail.com", "date": "2020-03-07T12:08:35Z"}, "message": "vscode: remove logic for caching editors as per @matklad", "tree": {"sha": "2cb9ce26adf52b3bd2c88c226752726926d5828b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cb9ce26adf52b3bd2c88c226752726926d5828b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef52fd543f4048d36e2c37281de4bc343871a62d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef52fd543f4048d36e2c37281de4bc343871a62d", "html_url": "https://github.com/rust-lang/rust/commit/ef52fd543f4048d36e2c37281de4bc343871a62d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef52fd543f4048d36e2c37281de4bc343871a62d/comments", "author": null, "committer": null, "parents": [{"sha": "a63446f2549afbeafe632c425112b7c38b5c9991", "url": "https://api.github.com/repos/rust-lang/rust/commits/a63446f2549afbeafe632c425112b7c38b5c9991", "html_url": "https://github.com/rust-lang/rust/commit/a63446f2549afbeafe632c425112b7c38b5c9991"}], "stats": {"total": 358, "additions": 136, "deletions": 222}, "files": [{"sha": "6d084362db8069c1258ab0a2ffbc26cbc75c1a20", "filename": "editors/code/src/inlay_hints.ts", "status": "modified", "additions": 136, "deletions": 222, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/ef52fd543f4048d36e2c37281de4bc343871a62d/editors%2Fcode%2Fsrc%2Finlay_hints.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ef52fd543f4048d36e2c37281de4bc343871a62d/editors%2Fcode%2Fsrc%2Finlay_hints.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finlay_hints.ts?ref=ef52fd543f4048d36e2c37281de4bc343871a62d", "patch": "@@ -2,48 +2,32 @@ import * as lc from \"vscode-languageclient\";\n import * as vscode from 'vscode';\n import * as ra from './rust-analyzer-api';\n \n-import { Ctx } from './ctx';\n-import { sendRequestWithRetry, assert } from './util';\n+import { Ctx, Disposable } from './ctx';\n+import { sendRequestWithRetry, isRustDocument, RustDocument, RustEditor, log } from './util';\n \n-export function activateInlayHints(ctx: Ctx) {\n-    const hintsUpdater = new HintsUpdater(ctx.client);\n-\n-    vscode.window.onDidChangeVisibleTextEditors(\n-        () => hintsUpdater.refreshVisibleRustEditors(),\n-        null,\n-        ctx.subscriptions\n-    );\n-\n-    vscode.workspace.onDidChangeTextDocument(\n-        ({ contentChanges, document }) => {\n-            if (contentChanges.length === 0) return;\n-            if (!isRustTextDocument(document)) return;\n \n-            hintsUpdater.forceRefreshVisibleRustEditors();\n+export function activateInlayHints(ctx: Ctx) {\n+    const maybeUpdater = {\n+        updater: null as null | HintsUpdater,\n+        onConfigChange() {\n+            if (!ctx.config.displayInlayHints) {\n+                return this.dispose();\n+            }\n+            if (!this.updater) this.updater = HintsUpdater.create(ctx);\n         },\n-        null,\n-        ctx.subscriptions\n-    );\n+        dispose() {\n+            this.updater?.dispose();\n+            this.updater = null;\n+        }\n+    };\n+\n+    ctx.pushCleanup(maybeUpdater);\n \n     vscode.workspace.onDidChangeConfiguration(\n-        async _ => {\n-            // FIXME: ctx.config may have not been refreshed at this point of time, i.e.\n-            // it's on onDidChangeConfiguration() handler may've not executed yet\n-            // (order of invokation is unspecified)\n-            // To fix this we should expose an event emitter from our `Config` itself.\n-            await hintsUpdater.setEnabled(ctx.config.displayInlayHints);\n-        },\n-        null,\n-        ctx.subscriptions\n+        maybeUpdater.onConfigChange, maybeUpdater, ctx.subscriptions\n     );\n \n-    ctx.pushCleanup({\n-        dispose() {\n-            hintsUpdater.clearHints();\n-        }\n-    });\n-\n-    hintsUpdater.setEnabled(ctx.config.displayInlayHints);\n+    maybeUpdater.onConfigChange();\n }\n \n \n@@ -79,239 +63,169 @@ const paramHints = {\n     }\n };\n \n-class HintsUpdater {\n-    private sourceFiles = new RustSourceFiles();\n-    private enabled = false;\n-\n-    constructor(readonly client: lc.LanguageClient) { }\n+class HintsUpdater implements Disposable {\n+    private sourceFiles = new Map<string, RustSourceFile>(); // map Uri -> RustSourceFile\n+    private readonly disposables: Disposable[] = [];\n \n-    setEnabled(enabled: boolean) {\n-        if (this.enabled === enabled) return;\n-        this.enabled = enabled;\n+    private constructor(readonly ctx: Ctx) { }\n \n-        if (this.enabled) {\n-            this.refreshVisibleRustEditors();\n-        } else {\n-            this.clearHints();\n-        }\n-    }\n-\n-    clearHints() {\n-        for (const file of this.sourceFiles) {\n-            file.inlaysRequest?.cancel();\n-            file.renderHints([], this.client.protocol2CodeConverter);\n-        }\n-    }\n-\n-    forceRefreshVisibleRustEditors() {\n-        if (!this.enabled) return;\n+    static create(ctx: Ctx) {\n+        const self = new HintsUpdater(ctx);\n \n-        for (const file of this.sourceFiles) {\n-            void file.fetchAndRenderHints(this.client);\n-        }\n-    }\n-\n-    refreshVisibleRustEditors() {\n-        if (!this.enabled) return;\n+        vscode.window.onDidChangeVisibleTextEditors(\n+            self.onDidChangeVisibleTextEditors,\n+            self,\n+            self.disposables\n+        );\n \n-        const visibleSourceFiles = this.sourceFiles.drainEditors(\n-            vscode.window.visibleTextEditors.filter(isRustTextEditor)\n+        vscode.workspace.onDidChangeTextDocument(\n+            self.onDidChangeTextDocument,\n+            self,\n+            self.disposables\n         );\n \n-        // Cancel requests for source files whose editors were disposed (leftovers after drain).\n-        for (const { inlaysRequest } of this.sourceFiles) inlaysRequest?.cancel();\n+        // Set up initial cache shape\n+        ctx.visibleRustEditors.forEach(editor => self.sourceFiles.set(\n+            editor.document.uri.toString(), {\n+                document: editor.document,\n+                inlaysRequest: null,\n+                cachedDecorations: null\n+            }\n+        ));\n \n-        this.sourceFiles = visibleSourceFiles;\n+        self.syncCacheAndRenderHints();\n \n-        for (const file of this.sourceFiles) {\n-            if (!file.rerenderHints()) {\n-                void file.fetchAndRenderHints(this.client);\n-            }\n-        }\n+        return self;\n     }\n-}\n-\n \n-/**\n- * This class encapsulates a map of file uris to respective inlay hints\n- * request cancellation token source (cts) and an array of editors.\n- * E.g.\n- * ```\n- * {\n- *    file1.rs -> (cts, (typeDecor, paramDecor), [editor1, editor2])\n- *                  ^-- there is a cts to cancel the in-flight request\n- *    file2.rs -> (cts, null, [editor3])\n- *                       ^-- no decorations are applied to this source file yet\n- *    file3.rs -> (null, (typeDecor, paramDecor), [editor4])\n- * }                ^-- there is no inflight request\n- * ```\n- *\n- * Invariants: each stored source file has at least 1 editor.\n- */\n-class RustSourceFiles {\n-    private files = new Map<string, RustSourceFile>();\n+    dispose() {\n+        this.sourceFiles.forEach(file => file.inlaysRequest?.cancel());\n+        this.ctx.visibleRustEditors.forEach(editor => this.renderDecorations(editor, { param: [], type: [] }));\n+        this.disposables.forEach(d => d.dispose());\n+    }\n \n-    /**\n-     * Removes `editors` from `this` source files and puts them into a returned\n-     * source files object. cts and decorations are moved to the returned source files.\n-     */\n-    drainEditors(editors: RustTextEditor[]): RustSourceFiles {\n-        const result = new RustSourceFiles;\n+    onDidChangeTextDocument({contentChanges, document}: vscode.TextDocumentChangeEvent) {\n+        if (contentChanges.length === 0 || !isRustDocument(document)) return;\n+        log.debug(`[inlays]: changed text doc!`);\n+        this.syncCacheAndRenderHints();\n+    }\n \n-        for (const editor of editors) {\n-            const oldFile = this.removeEditor(editor);\n-            const newFile = result.addEditor(editor);\n+    private syncCacheAndRenderHints() {\n+        // FIXME: make inlayHints request pass an array of files?\n+        this.sourceFiles.forEach((file, uri) => this.fetchHints(file).then(hints => {\n+            if (!hints) return;\n \n-            if (oldFile) newFile.stealCacheFrom(oldFile);\n-        }\n+            file.cachedDecorations = this.hintsToDecorations(hints);\n \n-        return result;\n+            for (const editor of this.ctx.visibleRustEditors) {\n+                if (editor.document.uri.toString() === uri) {\n+                    this.renderDecorations(editor, file.cachedDecorations);\n+                }\n+            }\n+        }));\n     }\n \n-    /**\n-     * Remove the editor and if it was the only editor for a source file,\n-     * the source file is removed altogether.\n-     *\n-     * @returns A reference to the source file for this editor or\n-     *          null if no such source file was not found.\n-     */\n-    private removeEditor(editor: RustTextEditor): null | RustSourceFile {\n-        const uri = editor.document.uri.toString();\n+    onDidChangeVisibleTextEditors() {\n+        log.debug(`[inlays]: changed visible text editors`);\n+        const newSourceFiles = new Map<string, RustSourceFile>();\n \n-        const file = this.files.get(uri);\n-        if (!file) return null;\n+        // Rerendering all, even up-to-date editors for simplicity\n+        this.ctx.visibleRustEditors.forEach(async editor => {\n+            const uri = editor.document.uri.toString();\n+            const file = this.sourceFiles.get(uri) ?? {\n+                document: editor.document,\n+                inlaysRequest: null,\n+                cachedDecorations: null\n+            };\n+            newSourceFiles.set(uri, file);\n \n-        const editorIndex = file.editors.findIndex(suspect => areEditorsEqual(suspect, editor));\n+            // No text documents changed, so we may try to use the cache\n+            if (!file.cachedDecorations) {\n+                file.inlaysRequest?.cancel();\n \n-        if (editorIndex >= 0) {\n-            file.editors.splice(editorIndex, 1);\n+                const hints = await this.fetchHints(file);\n+                if (!hints) return;\n \n-            if (file.editors.length === 0) this.files.delete(uri);\n-        }\n-\n-        return file;\n-    }\n-\n-    /**\n-     * @returns A reference to an existing source file or newly created one for the editor.\n-     */\n-    private addEditor(editor: RustTextEditor): RustSourceFile {\n-        const uri = editor.document.uri.toString();\n-        const file = this.files.get(uri);\n-\n-        if (!file) {\n-            const newFile = new RustSourceFile([editor]);\n-            this.files.set(uri, newFile);\n-            return newFile;\n-        }\n+                file.cachedDecorations = this.hintsToDecorations(hints);\n+            }\n \n-        if (!file.editors.find(suspect => areEditorsEqual(suspect, editor))) {\n-            file.editors.push(editor);\n-        }\n-        return file;\n-    }\n+            this.renderDecorations(editor, file.cachedDecorations);\n+        });\n \n-    getSourceFile(uri: string): undefined | RustSourceFile {\n-        return this.files.get(uri);\n-    }\n+        // Cancel requests for no longer visible (disposed) source files\n+        this.sourceFiles.forEach((file, uri) => {\n+            if (!newSourceFiles.has(uri)) file.inlaysRequest?.cancel();\n+        });\n \n-    [Symbol.iterator](): IterableIterator<RustSourceFile> {\n-        return this.files.values();\n-    }\n-}\n-class RustSourceFile {\n-    constructor(\n-        /**\n-         * Editors for this source file (one text document may be opened in multiple editors).\n-         * We keep this just an array, because most of the time we have 1 editor for 1 source file.\n-         */\n-        readonly editors: RustTextEditor[],\n-        /**\n-         * Source of the token to cancel in-flight inlay hints request if any.\n-         */\n-        public inlaysRequest: null | vscode.CancellationTokenSource = null,\n-\n-        public decorations: null | {\n-            type: vscode.DecorationOptions[];\n-            param: vscode.DecorationOptions[];\n-        } = null\n-    ) { }\n-\n-    stealCacheFrom(other: RustSourceFile) {\n-        if (other.inlaysRequest) this.inlaysRequest = other.inlaysRequest;\n-        if (other.decorations) this.decorations = other.decorations;\n-\n-        other.inlaysRequest = null;\n-        other.decorations = null;\n+        this.sourceFiles = newSourceFiles;\n     }\n \n-    rerenderHints(): boolean {\n-        if (!this.decorations) return false;\n-\n-        for (const editor of this.editors) {\n-            editor.setDecorations(typeHints.decorationType, this.decorations.type);\n-            editor.setDecorations(paramHints.decorationType, this.decorations.param);\n-        }\n-        return true;\n+    private renderDecorations(editor: RustEditor, decorations: InlaysDecorations) {\n+        editor.setDecorations(typeHints.decorationType, decorations.type);\n+        editor.setDecorations(paramHints.decorationType, decorations.param);\n     }\n \n-    renderHints(hints: ra.InlayHint[], conv: lc.Protocol2CodeConverter) {\n-        this.decorations = { type: [], param: [] };\n+    private hintsToDecorations(hints: ra.InlayHint[]): InlaysDecorations {\n+        const decorations: InlaysDecorations = { type: [], param: [] };\n+        const conv = this.ctx.client.protocol2CodeConverter;\n \n         for (const hint of hints) {\n             switch (hint.kind) {\n                 case ra.InlayHint.Kind.TypeHint: {\n-                    this.decorations.type.push(typeHints.toDecoration(hint, conv));\n+                    decorations.type.push(typeHints.toDecoration(hint, conv));\n                     continue;\n                 }\n                 case ra.InlayHint.Kind.ParamHint: {\n-                    this.decorations.param.push(paramHints.toDecoration(hint, conv));\n+                    decorations.param.push(paramHints.toDecoration(hint, conv));\n                     continue;\n                 }\n             }\n         }\n-        this.rerenderHints();\n+        return decorations;\n     }\n \n-    async fetchAndRenderHints(client: lc.LanguageClient): Promise<void> {\n-        this.inlaysRequest?.cancel();\n+    lastReqId = 0;\n+    private async fetchHints(file: RustSourceFile): Promise<null | ra.InlayHint[]> {\n+        const reqId = ++this.lastReqId;\n+\n+        log.debug(`[inlays]: ${reqId} requesting`);\n+        file.inlaysRequest?.cancel();\n \n         const tokenSource = new vscode.CancellationTokenSource();\n-        this.inlaysRequest = tokenSource;\n-\n-        const request = { textDocument: { uri: this.editors[0].document.uri.toString() } };\n-\n-        try {\n-            const hints = await sendRequestWithRetry(client, ra.inlayHints, request, tokenSource.token);\n-            this.renderHints(hints, client.protocol2CodeConverter);\n-        } catch {\n-            /* ignore */\n-        } finally {\n-            if (this.inlaysRequest === tokenSource) {\n-                this.inlaysRequest = null;\n-            }\n-        }\n+        file.inlaysRequest = tokenSource;\n+\n+        const request = { textDocument: { uri: file.document.uri.toString() } };\n+\n+        return sendRequestWithRetry(this.ctx.client, ra.inlayHints, request, tokenSource.token)\n+            .catch(_ => {\n+                log.debug(`[inlays]: ${reqId} err`);\n+                return null;\n+            })\n+            .finally(() => {\n+                if (file.inlaysRequest === tokenSource) {\n+                    file.inlaysRequest = null;\n+                    log.debug(`[inlays]: ${reqId} got response!`);\n+                } else {\n+                    log.debug(`[inlays]: ${reqId} cancelled!`);\n+                }\n+            })\n     }\n }\n \n-type RustTextDocument = vscode.TextDocument & { languageId: \"rust\" };\n-type RustTextEditor = vscode.TextEditor & { document: RustTextDocument; id: string };\n-\n-function areEditorsEqual(a: RustTextEditor, b: RustTextEditor): boolean {\n-    return a.id === b.id;\n+interface InlaysDecorations {\n+    type: vscode.DecorationOptions[];\n+    param: vscode.DecorationOptions[];\n }\n \n-function isRustTextEditor(suspect: vscode.TextEditor & { id?: unknown }): suspect is RustTextEditor {\n-    // Dirty hack, we need to access private vscode editor id,\n-    // see https://github.com/microsoft/vscode/issues/91788\n-    assert(\n-        typeof suspect.id === \"string\",\n-        \"Private text editor id is no longer available, please update the workaround!\"\n-    );\n-\n-    return isRustTextDocument(suspect.document);\n-}\n+interface RustSourceFile {\n+    /*\n+    * Source of the token to cancel in-flight inlay hints request if any.\n+    */\n+    inlaysRequest: null | vscode.CancellationTokenSource;\n+    /**\n+    * Last applied decorations.\n+    */\n+    cachedDecorations: null | InlaysDecorations;\n \n-function isRustTextDocument(suspect: vscode.TextDocument): suspect is RustTextDocument {\n-    return suspect.languageId === \"rust\";\n+    document: RustDocument\n }"}]}