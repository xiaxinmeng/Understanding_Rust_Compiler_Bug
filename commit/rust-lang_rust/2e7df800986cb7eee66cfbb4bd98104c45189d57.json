{"sha": "2e7df800986cb7eee66cfbb4bd98104c45189d57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlN2RmODAwOTg2Y2I3ZWVlNjZjZmJiNGJkOTgxMDRjNDUxODlkNTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-01T23:55:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-02T09:31:25Z"}, "message": "make metadata hashes determinstic\n\nWhen we hash the inputs to a MetaData node, we have to hash them in a\nconsistent order. We achieve this by sorting the stringfied `DefPath`\nentries. Also, micro-optimie by cache more results across the saving\nprocess.", "tree": {"sha": "ea255a832780ecf754e6caa1865884a1b182d82f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea255a832780ecf754e6caa1865884a1b182d82f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e7df800986cb7eee66cfbb4bd98104c45189d57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e7df800986cb7eee66cfbb4bd98104c45189d57", "html_url": "https://github.com/rust-lang/rust/commit/2e7df800986cb7eee66cfbb4bd98104c45189d57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e7df800986cb7eee66cfbb4bd98104c45189d57/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2797b2a5ca9c3cc38ff904c409e37ea19c42aa10", "url": "https://api.github.com/repos/rust-lang/rust/commits/2797b2a5ca9c3cc38ff904c409e37ea19c42aa10", "html_url": "https://github.com/rust-lang/rust/commit/2797b2a5ca9c3cc38ff904c409e37ea19c42aa10"}], "stats": {"total": 137, "additions": 79, "deletions": 58}, "files": [{"sha": "0247647fc14b691cdc6944524276620ad08f6784", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=2e7df800986cb7eee66cfbb4bd98104c45189d57", "patch": "@@ -12,8 +12,10 @@ use middle::cstore::LOCAL_CRATE;\n use hir::def_id::{DefId, DefIndex};\n use hir::map::def_collector::DefCollector;\n use rustc_data_structures::fnv::FnvHashMap;\n+use std::fmt::Write;\n use syntax::{ast, visit};\n use syntax::parse::token::InternedString;\n+use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n /// The definition table containing node definitions\n@@ -109,6 +111,28 @@ impl DefPath {\n         data.reverse();\n         DefPath { data: data, krate: krate }\n     }\n+\n+    pub fn to_string(&self, tcx: TyCtxt) -> String {\n+        let mut s = String::with_capacity(self.data.len() * 16);\n+\n+        if self.krate == LOCAL_CRATE {\n+            s.push_str(&tcx.crate_name(self.krate));\n+        } else {\n+            s.push_str(&tcx.sess.cstore.original_crate_name(self.krate));\n+        }\n+        s.push_str(\"/\");\n+        s.push_str(&tcx.crate_disambiguator(self.krate));\n+\n+        for component in &self.data {\n+            write!(s,\n+                   \"::{}[{}]\",\n+                   component.data.as_interned_str(),\n+                   component.disambiguator)\n+                .unwrap();\n+        }\n+\n+        s\n+    }\n }\n \n /// Root of an inlined item. We track the `DefPath` of the item within"}, {"sha": "6ab429ffe00579b8e53b099d8f34bf37583586c3", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=2e7df800986cb7eee66cfbb4bd98104c45189d57", "patch": "@@ -144,12 +144,7 @@ mod svh_visitor {\n         }\n \n         fn hash_def_path(&mut self, path: &DefPath) {\n-            self.tcx.crate_name(path.krate).hash(self.st);\n-            self.tcx.crate_disambiguator(path.krate).hash(self.st);\n-            for data in &path.data {\n-                data.data.as_interned_str().hash(self.st);\n-                data.disambiguator.hash(self.st);\n-            }\n+            path.to_string(self.tcx).hash(self.st);\n         }\n     }\n "}, {"sha": "85aa9d28e5f2d8f333df80a8e076fc83ee4b625c", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=2e7df800986cb7eee66cfbb4bd98104c45189d57", "patch": "@@ -159,12 +159,17 @@ impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n                  .clone()\n     }\n \n+    pub fn lookup_def_path(&self, id: DefPathIndex) -> &DefPath {\n+        &self.directory.paths[id.index as usize]\n+    }\n+\n+\n     pub fn map(&mut self, node: &DepNode<DefId>) -> DepNode<DefPathIndex> {\n         node.map_def(|&def_id| Some(self.add(def_id))).unwrap()\n     }\n \n-    pub fn into_directory(self) -> DefIdDirectory {\n-        self.directory\n+    pub fn directory(&self) -> &DefIdDirectory {\n+        &self.directory\n     }\n }\n "}, {"sha": "0cef5fab71a129e6470c8e169b100106d4dff205", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=2e7df800986cb7eee66cfbb4bd98104c45189d57", "patch": "@@ -39,19 +39,19 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<u64> {\n+    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<(DefId, u64)> {\n         match *dep_node {\n             // HIR nodes (which always come from our crate) are an input:\n             DepNode::Hir(def_id) => {\n-                Some(self.hir_hash(def_id))\n+                Some((def_id, self.hir_hash(def_id)))\n             }\n \n             // MetaData from other crates is an *input* to us.\n             // MetaData nodes from *our* crates are an *output*; we\n             // don't hash them, but we do compute a hash for them and\n             // save it for others to use.\n             DepNode::MetaData(def_id) if !def_id.is_local() => {\n-                Some(self.metadata_hash(def_id))\n+                Some((def_id, self.metadata_hash(def_id)))\n             }\n \n             _ => {"}, {"sha": "b47f2221e566d56ac1f42a5922dd96a1889d8d90", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=2e7df800986cb7eee66cfbb4bd98104c45189d57", "patch": "@@ -163,13 +163,14 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut items_removed = false;\n     let mut dirty_nodes = FnvHashSet();\n     for hash in hashes {\n-        debug!(\"initial_dirty_nodes: retracing {:?}\", hash);\n         match hash.node.map_def(|&i| retraced.def_id(i)) {\n             Some(dep_node) => {\n-                let current_hash = hcx.hash(&dep_node).unwrap();\n+                let (_, current_hash) = hcx.hash(&dep_node).unwrap();\n                 if current_hash != hash.hash {\n                     debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n-                           dep_node, current_hash, hash.hash);\n+                           dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n+                           current_hash,\n+                           hash.hash);\n                     dirty_nodes.insert(dep_node);\n                 }\n             }"}, {"sha": "64da7ad9ceb53d610b26cba52913062411b64494", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=2e7df800986cb7eee66cfbb4bd98104c45189d57", "patch": "@@ -16,7 +16,7 @@ use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_serialize::{Encodable as RustcEncodable};\n-use std::hash::{Hasher, SipHasher};\n+use std::hash::{Hash, Hasher, SipHasher};\n use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n use std::path::PathBuf;\n@@ -30,9 +30,14 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     debug!(\"save_dep_graph()\");\n     let _ignore = tcx.dep_graph.in_ignore();\n     let sess = tcx.sess;\n+    if sess.opts.incremental.is_none() {\n+        return;\n+    }\n     let mut hcx = HashContext::new(tcx);\n-    save_in(sess, dep_graph_path(tcx), |e| encode_dep_graph(&mut hcx, e));\n-    save_in(sess, metadata_hash_path(tcx, LOCAL_CRATE), |e| encode_metadata_hashes(&mut hcx, e));\n+    let mut builder = DefIdDirectoryBuilder::new(tcx);\n+    let query = tcx.dep_graph.query();\n+    save_in(sess, dep_graph_path(tcx), |e| encode_dep_graph(&mut hcx, &mut builder, &query, e));\n+    save_in(sess, metadata_hash_path(tcx, LOCAL_CRATE), |e| encode_metadata_hashes(&mut hcx, &mut builder, &query, e));\n }\n \n pub fn save_work_products(sess: &Session, local_crate_name: &str) {\n@@ -96,21 +101,19 @@ fn save_in<F>(sess: &Session,\n }\n \n pub fn encode_dep_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n+                                  builder: &mut DefIdDirectoryBuilder,\n+                                  query: &DepGraphQuery<DefId>,\n                                   encoder: &mut Encoder)\n                                   -> io::Result<()>\n {\n-    let tcx = hcx.tcx;\n-    let query = tcx.dep_graph.query();\n     let (nodes, edges) = post_process_graph(hcx, query);\n \n-    let mut builder = DefIdDirectoryBuilder::new(tcx);\n-\n     // Create hashes for inputs.\n     let hashes =\n         nodes.iter()\n              .filter_map(|dep_node| {\n                  hcx.hash(dep_node)\n-                    .map(|hash| {\n+                    .map(|(_, hash)| {\n                         let node = builder.map(dep_node);\n                         SerializedHash { node: node, hash: hash }\n                     })\n@@ -133,15 +136,14 @@ pub fn encode_dep_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n     debug!(\"graph = {:#?}\", graph);\n \n     // Encode the directory and then the graph data.\n-    let directory = builder.into_directory();\n-    try!(directory.encode(encoder));\n+    try!(builder.directory().encode(encoder));\n     try!(graph.encode(encoder));\n \n     Ok(())\n }\n \n pub fn post_process_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n-                                    query: DepGraphQuery<DefId>)\n+                                    query: &DepGraphQuery<DefId>)\n                                     -> (Vec<DepNode<DefId>>, Vec<(DepNode<DefId>, DepNode<DefId>)>)\n {\n     let tcx = hcx.tcx;\n@@ -192,11 +194,12 @@ pub fn post_process_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n \n \n pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n+                                        builder: &mut DefIdDirectoryBuilder,\n+                                        query: &DepGraphQuery<DefId>,\n                                         encoder: &mut Encoder)\n                                         -> io::Result<()>\n {\n     let tcx = hcx.tcx;\n-    let query = tcx.dep_graph.query();\n \n     let serialized_hashes = {\n         // Identify the `MetaData(X)` nodes where `X` is local. These are\n@@ -224,16 +227,32 @@ pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n                 let dep_node = DepNode::MetaData(def_id);\n                 let mut state = SipHasher::new();\n                 debug!(\"save: computing metadata hash for {:?}\", dep_node);\n-                for node in query.transitive_predecessors(&dep_node) {\n-                    if let Some(hash) = hcx.hash(&node) {\n-                        debug!(\"save: predecessor {:?} has hash {}\", node, hash);\n-                        state.write_u64(hash.to_le());\n-                    } else {\n-                        debug!(\"save: predecessor {:?} cannot be hashed\", node);\n-                    }\n+\n+                let predecessors = query.transitive_predecessors(&dep_node);\n+                let mut hashes: Vec<_> =\n+                    predecessors.iter()\n+                                .filter_map(|node| hcx.hash(&node))\n+                                .map(|(def_id, hash)| {\n+                                    let index = builder.add(def_id);\n+                                    let path = builder.lookup_def_path(index);\n+                                    (path.to_string(tcx), hash) // (*)\n+                                })\n+                                .collect();\n+\n+                // (*) creating a `String` from each def-path is a bit inefficient,\n+                // but it's the easiest way to get a deterministic ord/hash.\n+\n+                hashes.sort();\n+                state.write_usize(hashes.len());\n+                for (path, hash) in hashes {\n+                    debug!(\"save: predecessor {:?} has hash {}\", path, hash);\n+                    path.hash(&mut state);\n+                    state.write_u64(hash.to_le());\n                 }\n+\n                 let hash = state.finish();\n                 debug!(\"save: metadata hash for {:?} is {}\", dep_node, hash);\n+\n                 SerializedMetadataHash {\n                     def_index: def_id.index,\n                     hash: hash,"}, {"sha": "5e2c0805c2ea3a6c4bda553e9d773ffbdd58ff91", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7df800986cb7eee66cfbb4bd98104c45189d57/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=2e7df800986cb7eee66cfbb4bd98104c45189d57", "patch": "@@ -108,36 +108,13 @@ use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::hir::map::definitions::{DefPath, DefPathData};\n \n-use std::fmt::Write;\n use syntax::attr;\n use syntax::parse::token::{self, InternedString};\n use serialize::hex::ToHex;\n \n pub fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> String {\n     let def_path = tcx.def_path(def_id);\n-    def_path_to_string(tcx, &def_path)\n-}\n-\n-fn def_path_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_path: &DefPath) -> String {\n-    let mut s = String::with_capacity(def_path.data.len() * 16);\n-\n-    if def_path.krate == cstore::LOCAL_CRATE {\n-        s.push_str(&tcx.crate_name(def_path.krate));\n-    } else {\n-        s.push_str(&tcx.sess.cstore.original_crate_name(def_path.krate));\n-    }\n-    s.push_str(\"/\");\n-    s.push_str(&tcx.crate_disambiguator(def_path.krate));\n-\n-    for component in &def_path.data {\n-        write!(s,\n-               \"::{}[{}]\",\n-               component.data.as_interned_str(),\n-               component.disambiguator)\n-            .unwrap();\n-    }\n-\n-    s\n+    def_path.to_string(tcx)\n }\n \n fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n@@ -167,7 +144,7 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // the main symbol name is not necessarily unique; hash in the\n     // compiler's internal def-path, guaranteeing each symbol has a\n     // truly unique path\n-    hash_state.input_str(&def_path_to_string(tcx, def_path));\n+    hash_state.input_str(&def_path.to_string(tcx));\n \n     // Include the main item-type. Note that, in this case, the\n     // assertions about `needs_subst` may not hold, but this item-type"}]}