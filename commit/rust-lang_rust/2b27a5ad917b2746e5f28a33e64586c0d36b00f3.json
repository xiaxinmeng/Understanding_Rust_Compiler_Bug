{"sha": "2b27a5ad917b2746e5f28a33e64586c0d36b00f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMjdhNWFkOTE3YjI3NDZlNWYyOGEzM2U2NDU4NmMwZDM2YjAwZjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-04T17:01:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-04T17:01:57Z"}, "message": "auto merge of #12956 : killerswan/rust/docs, r=alexcrichton", "tree": {"sha": "ee2561e1d3f19136f4df365354d5194399f4b35a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee2561e1d3f19136f4df365354d5194399f4b35a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b27a5ad917b2746e5f28a33e64586c0d36b00f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b27a5ad917b2746e5f28a33e64586c0d36b00f3", "html_url": "https://github.com/rust-lang/rust/commit/2b27a5ad917b2746e5f28a33e64586c0d36b00f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b27a5ad917b2746e5f28a33e64586c0d36b00f3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eae265271089011c309ce6b8386bdd98f29f2aaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/eae265271089011c309ce6b8386bdd98f29f2aaf", "html_url": "https://github.com/rust-lang/rust/commit/eae265271089011c309ce6b8386bdd98f29f2aaf"}, {"sha": "02c9c94ddde6f88807c294d645331255d197cc74", "url": "https://api.github.com/repos/rust-lang/rust/commits/02c9c94ddde6f88807c294d645331255d197cc74", "html_url": "https://github.com/rust-lang/rust/commit/02c9c94ddde6f88807c294d645331255d197cc74"}], "stats": {"total": 108, "additions": 91, "deletions": 17}, "files": [{"sha": "6e62cd42e2cbe307524c9d2e0a702170cd6176ac", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 91, "deletions": 17, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/2b27a5ad917b2746e5f28a33e64586c0d36b00f3/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b27a5ad917b2746e5f28a33e64586c0d36b00f3/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=2b27a5ad917b2746e5f28a33e64586c0d36b00f3", "patch": "@@ -10,17 +10,36 @@\n \n /*!\n \n-The `Ord` and `Eq` comparison traits\n+Defines the `Ord` and `Eq` comparison traits.\n \n-This module contains the definition of both `Ord` and `Eq` which define\n-the common interfaces for doing comparison. Both are language items\n-that the compiler uses to implement the comparison operators. Rust code\n-may implement `Ord` to overload the `<`, `<=`, `>`, and `>=` operators,\n-and `Eq` to overload the `==` and `!=` operators.\n+This module defines both `Ord` and `Eq` traits which are used by the compiler\n+to implement comparison operators.\n+Rust programs may implement `Ord` to overload the `<`, `<=`, `>`, and `>=` operators,\n+and may implement `Eq` to overload the `==` and `!=` operators.\n \n-*/\n+For example, to define a type with a customized definition for the Eq operators,\n+you could do the following:\n+\n+```rust\n+// Our type.\n+struct SketchyNum {\n+    num : int\n+}\n+\n+// Our implementation of `Eq` to support `==` and `!=`.\n+impl Eq for SketchyNum {\n+    // Our custom eq allows numbers which are near eachother to be equal! :D\n+    fn eq(&self, other: &SketchyNum) -> bool {\n+        (self.num - other.num).abs() < 5\n+    }\n+}\n+\n+// Now these binary operators will work when applied!\n+assert!(SketchyNum {num: 37} == SketchyNum {num: 34});\n+assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n+```\n \n-#![allow(missing_doc)]\n+*/\n \n /**\n * Trait for values that can be compared for equality and inequality.\n@@ -35,8 +54,10 @@ and `Eq` to overload the `==` and `!=` operators.\n */\n #[lang=\"eq\"]\n pub trait Eq {\n+    /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n     fn eq(&self, other: &Self) -> bool;\n \n+    /// This method tests for `!=`.\n     #[inline]\n     fn ne(&self, other: &Self) -> bool { !self.eq(other) }\n }\n@@ -55,6 +76,7 @@ pub trait TotalEq: Eq {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n+/// A macro which defines an implementation of TotalEq for a given type.\n macro_rules! totaleq_impl(\n     ($t:ty) => {\n         impl TotalEq for $t {}\n@@ -78,11 +100,29 @@ totaleq_impl!(uint)\n \n totaleq_impl!(char)\n \n+/// An ordering is, e.g, a result of a comparison between two values.\n #[deriving(Clone, Eq, Show)]\n-pub enum Ordering { Less = -1, Equal = 0, Greater = 1 }\n+pub enum Ordering {\n+   /// An ordering where a compared value is less [than another].\n+   Less = -1,\n+   /// An ordering where a compared value is equal [to another].\n+   Equal = 0,\n+   /// An ordering where a compared value is greater [than another].\n+   Greater = 1\n+}\n \n-/// Trait for types that form a total order\n+/// Trait for types that form a total order.\n pub trait TotalOrd: TotalEq + Ord {\n+    /// This method returns an ordering between `self` and `other` values.\n+    ///\n+    /// By convention, `self.cmp(&other)` returns the ordering matching\n+    /// the expression `self <operator> other` if true.  For example:\n+    ///\n+    /// ```\n+    /// assert_eq!( 5u.cmp(&10), Less);     // because 5 < 10\n+    /// assert_eq!(10u.cmp(&5),  Greater);  // because 10 > 5\n+    /// assert_eq!( 5u.cmp(&5),  Equal);    // because 5 == 5\n+    /// ```\n     fn cmp(&self, other: &Self) -> Ordering;\n }\n \n@@ -99,6 +139,7 @@ impl Ord for Ordering {\n     fn lt(&self, other: &Ordering) -> bool { (*self as int) < (*other as int) }\n }\n \n+/// A macro which defines an implementation of TotalOrd for a given type.\n macro_rules! totalord_impl(\n     ($t:ty) => {\n         impl TotalOrd for $t {\n@@ -128,8 +169,11 @@ totalord_impl!(uint)\n totalord_impl!(char)\n \n /**\n-Return `o1` if it is not `Equal`, otherwise `o2`. Simulates the\n-lexical ordering on a type `(int, int)`.\n+ * Combine orderings, lexically.\n+ *\n+ * For example for a type `(int, int)`, two comparisons could be done.\n+ * If the first ordering is different, the first ordering is all that must be returned.\n+ * If the first ordering is equal, then second ordering is returned.\n */\n #[inline]\n pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n@@ -151,11 +195,18 @@ pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n */\n #[lang=\"ord\"]\n pub trait Ord: Eq {\n+    /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n     fn lt(&self, other: &Self) -> bool;\n+\n+    /// This method tests less than or equal to (`<=`).\n     #[inline]\n     fn le(&self, other: &Self) -> bool { !other.lt(self) }\n+\n+    /// This method tests greater than (`>`).\n     #[inline]\n     fn gt(&self, other: &Self) -> bool {  other.lt(self) }\n+\n+    /// This method tests greater than or equal to (`>=`).\n     #[inline]\n     fn ge(&self, other: &Self) -> bool { !self.lt(other) }\n }\n@@ -165,14 +216,17 @@ pub trait Ord: Eq {\n /// container types; e.g. it is often desirable to be able to use `&str`\n /// values to look up entries in a container with `~str` keys.\n pub trait Equiv<T> {\n+    /// Implement this function to decide equivalent values.\n     fn equiv(&self, other: &T) -> bool;\n }\n \n+/// Compare and return the minimum of two values.\n #[inline]\n pub fn min<T: TotalOrd>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n+/// Compare and return the maximum of two values.\n #[inline]\n pub fn max<T: TotalOrd>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n@@ -184,11 +238,11 @@ mod test {\n \n     #[test]\n     fn test_int_totalord() {\n-        assert_eq!(5.cmp(&10), Less);\n-        assert_eq!(10.cmp(&5), Greater);\n-        assert_eq!(5.cmp(&5), Equal);\n-        assert_eq!((-5).cmp(&12), Less);\n-        assert_eq!(12.cmp(-5), Greater);\n+        assert_eq!(5u.cmp(&10), Less);\n+        assert_eq!(10u.cmp(&5), Greater);\n+        assert_eq!(5u.cmp(&5), Equal);\n+        assert_eq!((-5u).cmp(&12), Less);\n+        assert_eq!(12u.cmp(-5), Greater);\n     }\n \n     #[test]\n@@ -210,4 +264,24 @@ mod test {\n             t(Greater, o, Greater);\n          }\n     }\n+\n+    #[test]\n+    fn test_user_defined_eq() {\n+        // Our type.\n+        struct SketchyNum {\n+            num : int\n+        }\n+\n+        // Our implementation of `Eq` to support `==` and `!=`.\n+        impl Eq for SketchyNum {\n+            // Our custom eq allows numbers which are near eachother to be equal! :D\n+            fn eq(&self, other: &SketchyNum) -> bool {\n+                (self.num - other.num).abs() < 5\n+            }\n+        }\n+\n+        // Now these binary operators will work when applied!\n+        assert!(SketchyNum {num: 37} == SketchyNum {num: 34});\n+        assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n+    }\n }"}]}