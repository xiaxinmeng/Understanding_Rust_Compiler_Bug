{"sha": "f38c5c8e5d76ea9a87fece143425ef7c703c706a", "node_id": "C_kwDOAAsO6NoAKGYzOGM1YzhlNWQ3NmVhOWE4N2ZlY2UxNDM0MjVlZjdjNzAzYzcwNmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-13T11:27:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-13T11:27:17Z"}, "message": "Auto merge of #95656 - cjgillot:no-id-hashing-mode, r=Aaron1011\n\nRemove NodeIdHashingMode.\n\nr? `@ghost`", "tree": {"sha": "05774f4f660bfb0765be683efe20655447a316f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05774f4f660bfb0765be683efe20655447a316f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f38c5c8e5d76ea9a87fece143425ef7c703c706a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f38c5c8e5d76ea9a87fece143425ef7c703c706a", "html_url": "https://github.com/rust-lang/rust/commit/f38c5c8e5d76ea9a87fece143425ef7c703c706a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f38c5c8e5d76ea9a87fece143425ef7c703c706a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3c43e64eceb00e13b1932229aa9b2d774e6af96", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3c43e64eceb00e13b1932229aa9b2d774e6af96", "html_url": "https://github.com/rust-lang/rust/commit/e3c43e64eceb00e13b1932229aa9b2d774e6af96"}, {"sha": "0927a35e807eccd0bffc3811e44e2fc3b8616849", "url": "https://api.github.com/repos/rust-lang/rust/commits/0927a35e807eccd0bffc3811e44e2fc3b8616849", "html_url": "https://github.com/rust-lang/rust/commit/0927a35e807eccd0bffc3811e44e2fc3b8616849"}], "stats": {"total": 474, "additions": 85, "deletions": 389}, "files": [{"sha": "87fbb737ea8a933f8f88179850f903c6feeb63b9", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/type_map.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -3,7 +3,7 @@ use std::cell::RefCell;\n use rustc_data_structures::{\n     fingerprint::Fingerprint,\n     fx::FxHashMap,\n-    stable_hasher::{HashStable, NodeIdHashingMode, StableHasher},\n+    stable_hasher::{HashStable, StableHasher},\n };\n use rustc_middle::{\n     bug,\n@@ -94,11 +94,7 @@ impl<'tcx> UniqueTypeId<'tcx> {\n     pub fn generate_unique_id_string(self, tcx: TyCtxt<'tcx>) -> String {\n         let mut hasher = StableHasher::new();\n         let mut hcx = tcx.create_stable_hashing_context();\n-        hcx.while_hashing_spans(false, |hcx| {\n-            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                self.hash_stable(hcx, &mut hasher);\n-            });\n-        });\n+        hcx.while_hashing_spans(false, |hcx| self.hash_stable(hcx, &mut hasher));\n         hasher.finish::<Fingerprint>().to_hex()\n     }\n "}, {"sha": "ae43464791d2371b3ed0f48656cd5de748b456cd", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -19,7 +19,6 @@ use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Mutability};\n use rustc_middle::ty::layout::{IntegerExt, TyAndLayout};\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, ExistentialProjection, GeneratorSubsts, ParamEnv, Ty, TyCtxt};\n-use rustc_query_system::ich::NodeIdHashingMode;\n use rustc_target::abi::{Integer, TagEncoding, Variants};\n use smallvec::SmallVec;\n \n@@ -704,11 +703,7 @@ fn push_const_param<'tcx>(tcx: TyCtxt<'tcx>, ct: ty::Const<'tcx>, output: &mut S\n                 // but we get a deterministic, virtually unique value for the constant.\n                 let hcx = &mut tcx.create_stable_hashing_context();\n                 let mut hasher = StableHasher::new();\n-                hcx.while_hashing_spans(false, |hcx| {\n-                    hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                        ct.val().hash_stable(hcx, &mut hasher);\n-                    });\n-                });\n+                hcx.while_hashing_spans(false, |hcx| ct.val().hash_stable(hcx, &mut hasher));\n                 // Let's only emit 64 bits of the hash value. That should be plenty for\n                 // avoiding collisions and will make the emitted type names shorter.\n                 let hash: u64 = hasher.finish();"}, {"sha": "85ad0f2f7f5ce5aca99f2f8ddc601ce1f7f45f6b", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -612,12 +612,6 @@ fn stable_hash_reduce<HCX, I, C, F>(\n     }\n }\n \n-#[derive(PartialEq, Eq, Clone, Copy, Hash, Debug)]\n-pub enum NodeIdHashingMode {\n-    Ignore,\n-    HashDefPath,\n-}\n-\n /// Controls what data we do or not not hash.\n /// Whenever a `HashStable` implementation caches its\n /// result, it needs to include `HashingControls` as part\n@@ -628,5 +622,4 @@ pub enum NodeIdHashingMode {\n #[derive(Clone, Hash, Eq, PartialEq, Debug)]\n pub struct HashingControls {\n     pub hash_spans: bool,\n-    pub node_id_hashing_mode: NodeIdHashingMode,\n }"}, {"sha": "ff8b13d31122ecfa6c4d132b01e06b6b38edc889", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -1299,7 +1299,7 @@ pub struct BodyId {\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n-#[derive(Debug)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Body<'hir> {\n     pub params: &'hir [Param<'hir>],\n     pub value: Expr<'hir>,\n@@ -2059,7 +2059,7 @@ pub struct FnSig<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the hir-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n pub struct TraitItemId {\n     pub def_id: LocalDefId,\n }\n@@ -2076,7 +2076,7 @@ impl TraitItemId {\n /// possibly including a default implementation. A trait item is\n /// either required (meaning it doesn't have an implementation, just a\n /// signature) or provided (meaning it has a default implementation).\n-#[derive(Debug)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n     pub def_id: LocalDefId,\n@@ -2122,7 +2122,7 @@ pub enum TraitItemKind<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the hir-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n pub struct ImplItemId {\n     pub def_id: LocalDefId,\n }\n@@ -2136,7 +2136,7 @@ impl ImplItemId {\n }\n \n /// Represents anything within an `impl` block.\n-#[derive(Debug)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n     pub def_id: LocalDefId,\n@@ -2637,7 +2637,7 @@ pub struct PolyTraitRef<'hir> {\n \n pub type Visibility<'hir> = Spanned<VisibilityKind<'hir>>;\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum VisibilityKind<'hir> {\n     Public,\n     Crate(CrateSugar),\n@@ -2713,7 +2713,7 @@ impl<'hir> VariantData<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the hir-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, Hash, HashStable_Generic)]\n pub struct ItemId {\n     pub def_id: LocalDefId,\n }\n@@ -2729,7 +2729,7 @@ impl ItemId {\n /// An item\n ///\n /// The name might be a dummy name in case of anonymous items\n-#[derive(Debug)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n     pub def_id: LocalDefId,\n@@ -2960,7 +2960,7 @@ pub enum AssocItemKind {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the hir-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n pub struct ForeignItemId {\n     pub def_id: LocalDefId,\n }\n@@ -2986,7 +2986,7 @@ pub struct ForeignItemRef {\n     pub span: Span,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct ForeignItem<'hir> {\n     pub ident: Ident,\n     pub kind: ForeignItemKind<'hir>,\n@@ -3028,7 +3028,7 @@ pub struct Upvar {\n // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used.\n-#[derive(Encodable, Decodable, Clone, Debug)]\n+#[derive(Encodable, Decodable, Clone, Debug, HashStable_Generic)]\n pub struct TraitCandidate {\n     pub def_id: DefId,\n     pub import_ids: SmallVec<[LocalDefId; 1]>,"}, {"sha": "3b5e4dcf5e01188db28d3edfcab62cc43167b28f", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -12,7 +12,7 @@ use std::fmt;\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-#[derive(Encodable, Decodable)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n #[rustc_pass_by_value]\n pub struct HirId {\n     pub owner: LocalDefId,"}, {"sha": "8ccd59e8e37ffd82342c154385965dbff4c9dc89", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 2, "deletions": 102, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -1,8 +1,8 @@\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n \n use crate::hir::{\n-    AttributeMap, BodyId, Crate, Expr, ForeignItem, ForeignItemId, ImplItem, ImplItemId, Item,\n-    ItemId, OwnerNodes, TraitCandidate, TraitItem, TraitItemId, Ty, VisibilityKind,\n+    AttributeMap, BodyId, Crate, Expr, ForeignItemId, ImplItemId, ItemId, OwnerNodes, TraitItemId,\n+    Ty,\n };\n use crate::hir_id::{HirId, ItemLocalId};\n use rustc_span::def_id::DefPathHash;\n@@ -13,14 +13,9 @@ use rustc_span::def_id::DefPathHash;\n pub trait HashStableContext:\n     rustc_ast::HashStableContext + rustc_target::HashStableContext\n {\n-    fn hash_hir_id(&mut self, _: HirId, hasher: &mut StableHasher);\n     fn hash_body_id(&mut self, _: BodyId, hasher: &mut StableHasher);\n-    fn hash_reference_to_item(&mut self, _: HirId, hasher: &mut StableHasher);\n     fn hash_hir_expr(&mut self, _: &Expr<'_>, hasher: &mut StableHasher);\n     fn hash_hir_ty(&mut self, _: &Ty<'_>, hasher: &mut StableHasher);\n-    fn hash_hir_visibility_kind(&mut self, _: &VisibilityKind<'_>, hasher: &mut StableHasher);\n-    fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self, f: F);\n-    fn hash_hir_trait_candidate(&mut self, _: &TraitCandidate, hasher: &mut StableHasher);\n }\n \n impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for HirId {\n@@ -88,12 +83,6 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ForeignItemId\n     }\n }\n \n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for HirId {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_hir_id(*self, hasher)\n-    }\n-}\n-\n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for BodyId {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n         hcx.hash_body_id(*self, hasher)\n@@ -107,30 +96,6 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for BodyId {\n // want to pick up on a reference changing its target, so we hash the NodeIds\n // in \"DefPath Mode\".\n \n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ItemId {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.hir_id(), hasher)\n-    }\n-}\n-\n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ForeignItemId {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.hir_id(), hasher)\n-    }\n-}\n-\n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ImplItemId {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.hir_id(), hasher)\n-    }\n-}\n-\n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitItemId {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.hir_id(), hasher)\n-    }\n-}\n-\n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Expr<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n         hcx.hash_hir_expr(self, hasher)\n@@ -143,65 +108,6 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Ty<'_> {\n     }\n }\n \n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for VisibilityKind<'_> {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_hir_visibility_kind(self, hasher)\n-    }\n-}\n-\n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitItem<'_> {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let TraitItem { def_id: _, ident, ref generics, ref kind, span } = *self;\n-\n-        hcx.hash_hir_item_like(|hcx| {\n-            ident.name.hash_stable(hcx, hasher);\n-            generics.hash_stable(hcx, hasher);\n-            kind.hash_stable(hcx, hasher);\n-            span.hash_stable(hcx, hasher);\n-        });\n-    }\n-}\n-\n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ImplItem<'_> {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let ImplItem { def_id: _, ident, ref vis, ref generics, ref kind, span } = *self;\n-\n-        hcx.hash_hir_item_like(|hcx| {\n-            ident.name.hash_stable(hcx, hasher);\n-            vis.hash_stable(hcx, hasher);\n-            generics.hash_stable(hcx, hasher);\n-            kind.hash_stable(hcx, hasher);\n-            span.hash_stable(hcx, hasher);\n-        });\n-    }\n-}\n-\n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ForeignItem<'_> {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let ForeignItem { def_id: _, ident, ref kind, span, ref vis } = *self;\n-\n-        hcx.hash_hir_item_like(|hcx| {\n-            ident.name.hash_stable(hcx, hasher);\n-            kind.hash_stable(hcx, hasher);\n-            span.hash_stable(hcx, hasher);\n-            vis.hash_stable(hcx, hasher);\n-        });\n-    }\n-}\n-\n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Item<'_> {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let Item { ident, def_id: _, ref kind, ref vis, span } = *self;\n-\n-        hcx.hash_hir_item_like(|hcx| {\n-            ident.name.hash_stable(hcx, hasher);\n-            kind.hash_stable(hcx, hasher);\n-            vis.hash_stable(hcx, hasher);\n-            span.hash_stable(hcx, hasher);\n-        });\n-    }\n-}\n-\n impl<'tcx, HirCtx: crate::HashStableContext> HashStable<HirCtx> for OwnerNodes<'tcx> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n         // We ignore the `nodes` and `bodies` fields since these refer to information included in\n@@ -235,9 +141,3 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Crate<'_> {\n         hir_hash.hash_stable(hcx, hasher)\n     }\n }\n-\n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitCandidate {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_hir_trait_candidate(self, hasher)\n-    }\n-}"}, {"sha": "751c7f464822503e3dfaac4493e83a0c931b5bb6", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -5,7 +5,7 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n-use rustc_query_system::ich::{NodeIdHashingMode, StableHashingContext};\n+use rustc_query_system::ich::StableHashingContext;\n use rustc_span::def_id::LocalDefId;\n use std::hash::Hash;\n \n@@ -58,9 +58,7 @@ impl<Id> Default for AccessLevels<Id> {\n \n impl<'a> HashStable<StableHashingContext<'a>> for AccessLevels {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            let AccessLevels { ref map } = *self;\n-            map.hash_stable(hcx, hasher);\n-        });\n+        let AccessLevels { ref map } = *self;\n+        map.hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "98da20baf026b9de87cef2c212e58fa81780b85f", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir as hir;\n use rustc_hir::Node;\n use rustc_macros::HashStable;\n-use rustc_query_system::ich::{NodeIdHashingMode, StableHashingContext};\n+use rustc_query_system::ich::StableHashingContext;\n use rustc_span::{Span, DUMMY_SP};\n \n use std::fmt;\n@@ -446,10 +446,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ScopeTree {\n             ref yield_in_scope,\n         } = *self;\n \n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            root_body.hash_stable(hcx, hasher)\n-        });\n-\n+        root_body.hash_stable(hcx, hasher);\n         body_expr_count.hash_stable(hcx, hasher);\n         parent_map.hash_stable(hcx, hasher);\n         var_map.hash_stable(hcx, hasher);"}, {"sha": "f76217d921d94599ebde867458c9a26503d0d963", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::ItemId;\n use rustc_index::vec::Idx;\n-use rustc_query_system::ich::{NodeIdHashingMode, StableHashingContext};\n+use rustc_query_system::ich::StableHashingContext;\n use rustc_session::config::OptLevel;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n@@ -40,7 +40,7 @@ pub enum InstantiationMode {\n     LocalCopy,\n }\n \n-#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n+#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash, HashStable)]\n pub enum MonoItem<'tcx> {\n     Fn(Instance<'tcx>),\n     Static(DefId),\n@@ -202,26 +202,6 @@ impl<'tcx> MonoItem<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            MonoItem::Fn(ref instance) => {\n-                instance.hash_stable(hcx, hasher);\n-            }\n-            MonoItem::Static(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            MonoItem::GlobalAsm(item_id) => {\n-                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                    item_id.hash_stable(hcx, hasher);\n-                })\n-            }\n-        }\n-    }\n-}\n-\n impl<'tcx> fmt::Display for MonoItem<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {"}, {"sha": "4e6be84ad7f8ff6f990a155de5be959c7d6d0772", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 58, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -47,7 +47,7 @@ use rustc_hir::{\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_middle::mir::FakeReadCause;\n-use rustc_query_system::ich::{NodeIdHashingMode, StableHashingContext};\n+use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n@@ -367,7 +367,7 @@ pub struct GeneratorInteriorTypeCause<'tcx> {\n     pub expr: Option<hir::HirId>,\n }\n \n-#[derive(TyEncodable, TyDecodable, Debug)]\n+#[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n pub struct TypeckResults<'tcx> {\n     /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n     pub hir_owner: LocalDefId,\n@@ -783,62 +783,6 @@ impl<'tcx> TypeckResults<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let ty::TypeckResults {\n-            hir_owner,\n-            ref type_dependent_defs,\n-            ref field_indices,\n-            ref user_provided_types,\n-            ref user_provided_sigs,\n-            ref node_types,\n-            ref node_substs,\n-            ref adjustments,\n-            ref pat_binding_modes,\n-            ref pat_adjustments,\n-            ref closure_kind_origins,\n-            ref liberated_fn_sigs,\n-            ref fru_field_types,\n-            ref coercion_casts,\n-            ref used_trait_imports,\n-            tainted_by_errors,\n-            ref concrete_opaque_types,\n-            ref closure_min_captures,\n-            ref closure_fake_reads,\n-            ref generator_interior_types,\n-            ref treat_byte_string_as_slice,\n-            ref closure_size_eval,\n-        } = *self;\n-\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            hcx.local_def_path_hash(hir_owner);\n-\n-            type_dependent_defs.hash_stable(hcx, hasher);\n-            field_indices.hash_stable(hcx, hasher);\n-            user_provided_types.hash_stable(hcx, hasher);\n-            user_provided_sigs.hash_stable(hcx, hasher);\n-            node_types.hash_stable(hcx, hasher);\n-            node_substs.hash_stable(hcx, hasher);\n-            adjustments.hash_stable(hcx, hasher);\n-            pat_binding_modes.hash_stable(hcx, hasher);\n-            pat_adjustments.hash_stable(hcx, hasher);\n-\n-            closure_kind_origins.hash_stable(hcx, hasher);\n-            liberated_fn_sigs.hash_stable(hcx, hasher);\n-            fru_field_types.hash_stable(hcx, hasher);\n-            coercion_casts.hash_stable(hcx, hasher);\n-            used_trait_imports.hash_stable(hcx, hasher);\n-            tainted_by_errors.hash_stable(hcx, hasher);\n-            concrete_opaque_types.hash_stable(hcx, hasher);\n-            closure_min_captures.hash_stable(hcx, hasher);\n-            closure_fake_reads.hash_stable(hcx, hasher);\n-            generator_interior_types.hash_stable(hcx, hasher);\n-            treat_byte_string_as_slice.hash_stable(hcx, hasher);\n-            closure_size_eval.hash_stable(hcx, hasher);\n-        })\n-    }\n-}\n-\n rustc_index::newtype_index! {\n     pub struct UserTypeAnnotationIndex {\n         derive [HashStable]"}, {"sha": "39038e85b11a086a52733ca6a542deea4018237a", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -18,7 +18,6 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n-use rustc_query_system::ich::NodeIdHashingMode;\n use rustc_span::{sym, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, TargetDataLayout};\n use smallvec::SmallVec;\n@@ -136,11 +135,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // regions, which is desirable too.\n         let ty = self.erase_regions(ty);\n \n-        hcx.while_hashing_spans(false, |hcx| {\n-            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                ty.hash_stable(hcx, &mut hasher);\n-            });\n-        });\n+        hcx.while_hashing_spans(false, |hcx| ty.hash_stable(hcx, &mut hasher));\n         hasher.finish()\n     }\n "}, {"sha": "03ef8578eb701125ced59ae15fcd42cbc696fb20", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -2,8 +2,7 @@ use crate::ich;\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::stable_hasher::{HashingControls, NodeIdHashingMode};\n+use rustc_data_structures::stable_hasher::{HashStable, HashingControls, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -69,10 +68,7 @@ impl<'a> StableHashingContext<'a> {\n             incremental_ignore_spans: sess.opts.debugging_opts.incremental_ignore_spans,\n             caching_source_map: None,\n             raw_source_map: sess.source_map(),\n-            hashing_controls: HashingControls {\n-                hash_spans: hash_spans_initial,\n-                node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n-            },\n+            hashing_controls: HashingControls { hash_spans: hash_spans_initial },\n         }\n     }\n \n@@ -138,18 +134,6 @@ impl<'a> StableHashingContext<'a> {\n         self.hashing_controls.hash_spans = prev_hash_spans;\n     }\n \n-    #[inline]\n-    pub fn with_node_id_hashing_mode<F: FnOnce(&mut Self)>(\n-        &mut self,\n-        mode: NodeIdHashingMode,\n-        f: F,\n-    ) {\n-        let prev = self.hashing_controls.node_id_hashing_mode;\n-        self.hashing_controls.node_id_hashing_mode = mode;\n-        f(self);\n-        self.hashing_controls.node_id_hashing_mode = prev;\n-    }\n-\n     #[inline]\n     pub fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n         if let Some(def_id) = def_id.as_local() {\n@@ -233,9 +217,7 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n \n impl<'a> rustc_data_structures::intern::InternedHashingContext for StableHashingContext<'a> {\n     fn with_def_path_and_no_spans(&mut self, f: impl FnOnce(&mut Self)) {\n-        self.while_hashing_spans(false, |hcx| {\n-            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| f(hcx))\n-        });\n+        self.while_hashing_spans(false, f);\n     }\n }\n "}, {"sha": "3390ed9eb42bb615171b4cd3d3f7789cfa0c5c10", "filename": "compiler/rustc_query_system/src/ich/impls_hir.rs", "status": "modified", "additions": 5, "deletions": 85, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -2,28 +2,11 @@\n //! types in no particular order.\n \n use crate::ich::hcx::BodyResolver;\n-use crate::ich::{NodeIdHashingMode, StableHashingContext};\n+use crate::ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir as hir;\n-use std::mem;\n \n impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n-    #[inline]\n-    fn hash_hir_id(&mut self, hir_id: hir::HirId, hasher: &mut StableHasher) {\n-        let hcx = self;\n-        match hcx.hashing_controls.node_id_hashing_mode {\n-            NodeIdHashingMode::Ignore => {\n-                // Don't do anything.\n-            }\n-            NodeIdHashingMode::HashDefPath => {\n-                let hir::HirId { owner, local_id } = hir_id;\n-\n-                hcx.local_def_path_hash(owner).hash_stable(hcx, hasher);\n-                local_id.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-\n     #[inline]\n     fn hash_body_id(&mut self, id: hir::BodyId, hasher: &mut StableHasher) {\n         let hcx = self;\n@@ -37,86 +20,23 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n         }\n     }\n \n-    #[inline]\n-    fn hash_reference_to_item(&mut self, id: hir::HirId, hasher: &mut StableHasher) {\n-        let hcx = self;\n-\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            id.hash_stable(hcx, hasher);\n-        })\n-    }\n-\n     fn hash_hir_expr(&mut self, expr: &hir::Expr<'_>, hasher: &mut StableHasher) {\n         self.while_hashing_hir_bodies(true, |hcx| {\n-            let hir::Expr { hir_id: _, ref span, ref kind } = *expr;\n+            let hir::Expr { hir_id, ref span, ref kind } = *expr;\n \n+            hir_id.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n             kind.hash_stable(hcx, hasher);\n         })\n     }\n \n     fn hash_hir_ty(&mut self, ty: &hir::Ty<'_>, hasher: &mut StableHasher) {\n         self.while_hashing_hir_bodies(true, |hcx| {\n-            let hir::Ty { hir_id: _, ref kind, ref span } = *ty;\n+            let hir::Ty { hir_id, ref kind, ref span } = *ty;\n \n+            hir_id.hash_stable(hcx, hasher);\n             kind.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         })\n     }\n-\n-    fn hash_hir_visibility_kind(\n-        &mut self,\n-        vis: &hir::VisibilityKind<'_>,\n-        hasher: &mut StableHasher,\n-    ) {\n-        let hcx = self;\n-        mem::discriminant(vis).hash_stable(hcx, hasher);\n-        match *vis {\n-            hir::VisibilityKind::Public | hir::VisibilityKind::Inherited => {\n-                // No fields to hash.\n-            }\n-            hir::VisibilityKind::Crate(sugar) => {\n-                sugar.hash_stable(hcx, hasher);\n-            }\n-            hir::VisibilityKind::Restricted { ref path, hir_id } => {\n-                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                    hir_id.hash_stable(hcx, hasher);\n-                });\n-                path.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self, f: F) {\n-        let prev_hash_node_ids = self.hashing_controls.node_id_hashing_mode;\n-        self.hashing_controls.node_id_hashing_mode = NodeIdHashingMode::Ignore;\n-\n-        f(self);\n-\n-        self.hashing_controls.node_id_hashing_mode = prev_hash_node_ids;\n-    }\n-\n-    #[inline]\n-    fn hash_hir_trait_candidate(&mut self, tc: &hir::TraitCandidate, hasher: &mut StableHasher) {\n-        self.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            let hir::TraitCandidate { def_id, import_ids } = tc;\n-\n-            def_id.hash_stable(hcx, hasher);\n-            import_ids.hash_stable(hcx, hasher);\n-        });\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Body<'_> {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let hir::Body { params, value, generator_kind } = self;\n-\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::Ignore, |hcx| {\n-            params.hash_stable(hcx, hasher);\n-            value.hash_stable(hcx, hasher);\n-            generator_kind.hash_stable(hcx, hasher);\n-        });\n-    }\n }"}, {"sha": "0a1c350b2db13cba843d89b34b5ff62aaf826946", "filename": "compiler/rustc_query_system/src/ich/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -1,7 +1,6 @@\n //! ICH - Incremental Compilation Hash\n \n pub use self::hcx::StableHashingContext;\n-pub use rustc_data_structures::stable_hasher::NodeIdHashingMode;\n use rustc_span::symbol::{sym, Symbol};\n \n mod hcx;"}, {"sha": "7ebf323e20d8889dacd9dc4c2aab2399c67ca9e8", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -117,7 +117,7 @@ fn assert_default_hashing_controls<CTX: HashStableContext>(ctx: &CTX, msg: &str)\n         // `-Z incremental-ignore-spans` option. Normally, this option is disabled,\n         // which will cause us to require that this method always be called with `Span` hashing\n         // enabled.\n-        HashingControls { hash_spans, node_id_hashing_mode: _ }\n+        HashingControls { hash_spans }\n             if hash_spans == !ctx.debug_opts_incremental_ignore_spans() => {}\n         other => panic!(\"Attempted hashing of {msg} with non-default HashingControls: {:?}\", other),\n     }"}, {"sha": "b3773d5be2874a4b3dbbf1cda9c0490b245066f8", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -6,7 +6,6 @@ use rustc_middle::ty::print::{PrettyPrinter, Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::util::common::record_time;\n-use rustc_query_system::ich::NodeIdHashingMode;\n \n use tracing::debug;\n \n@@ -111,30 +110,28 @@ fn get_symbol_hash<'tcx>(\n         // ought to be the same for every reference anyway.\n         assert!(!item_type.has_erasable_regions());\n         hcx.while_hashing_spans(false, |hcx| {\n-            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                item_type.hash_stable(hcx, &mut hasher);\n-\n-                // If this is a function, we hash the signature as well.\n-                // This is not *strictly* needed, but it may help in some\n-                // situations, see the `run-make/a-b-a-linker-guard` test.\n-                if let ty::FnDef(..) = item_type.kind() {\n-                    item_type.fn_sig(tcx).hash_stable(hcx, &mut hasher);\n-                }\n+            item_type.hash_stable(hcx, &mut hasher);\n \n-                // also include any type parameters (for generic items)\n-                substs.hash_stable(hcx, &mut hasher);\n+            // If this is a function, we hash the signature as well.\n+            // This is not *strictly* needed, but it may help in some\n+            // situations, see the `run-make/a-b-a-linker-guard` test.\n+            if let ty::FnDef(..) = item_type.kind() {\n+                item_type.fn_sig(tcx).hash_stable(hcx, &mut hasher);\n+            }\n \n-                if let Some(instantiating_crate) = instantiating_crate {\n-                    tcx.def_path_hash(instantiating_crate.as_def_id())\n-                        .stable_crate_id()\n-                        .hash_stable(hcx, &mut hasher);\n-                }\n+            // also include any type parameters (for generic items)\n+            substs.hash_stable(hcx, &mut hasher);\n+\n+            if let Some(instantiating_crate) = instantiating_crate {\n+                tcx.def_path_hash(instantiating_crate.as_def_id())\n+                    .stable_crate_id()\n+                    .hash_stable(hcx, &mut hasher);\n+            }\n \n-                // We want to avoid accidental collision between different types of instances.\n-                // Especially, `VtableShim`s and `ReifyShim`s may overlap with their original\n-                // instances without this.\n-                discriminant(&instance.def).hash_stable(hcx, &mut hasher);\n-            });\n+            // We want to avoid accidental collision between different types of instances.\n+            // Especially, `VtableShim`s and `ReifyShim`s may overlap with their original\n+            // instances without this.\n+            discriminant(&instance.def).hash_stable(hcx, &mut hasher);\n         });\n     });\n "}, {"sha": "37d67b946dacc694e3e5a38d49293c967fd01716", "filename": "src/test/incremental/hashes/if_expressions.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -30,9 +30,9 @@ pub fn change_condition(x: bool) -> u32 {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn change_condition(x: bool) -> u32 {\n     if !x {\n@@ -106,9 +106,9 @@ pub fn add_else_branch(x: bool) -> u32 {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn add_else_branch(x: bool) -> u32 {\n     let mut ret = 1;\n@@ -159,9 +159,9 @@ pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n     if let Some(x) = x {\n@@ -212,9 +212,9 @@ pub fn add_else_branch_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,typeck,optimized_mir\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,typeck,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn add_else_branch_if_let(x: Option<u32>) -> u32 {\n     let mut ret = 1;"}, {"sha": "12c4d9f1e2998b6641952777a41b555fc0322bab", "filename": "src/test/incremental/hashes/indexing_expressions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -77,9 +77,9 @@ fn add_lower_bound(slice: &[u32]) -> &[u32] {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner_nodes,typeck\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,typeck\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner_nodes,typeck\", cfg=\"cfail5\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,typeck\", cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n fn add_lower_bound(slice: &[u32]) -> &[u32] {\n     &slice[3..4]\n@@ -94,9 +94,9 @@ fn add_upper_bound(slice: &[u32]) -> &[u32] {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner_nodes,typeck\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,typeck\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner_nodes,typeck\", cfg=\"cfail5\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,typeck\", cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n fn add_upper_bound(slice: &[u32]) -> &[u32] {\n     &slice[3..7]\n@@ -128,9 +128,9 @@ fn exclusive_to_inclusive_range(slice: &[u32]) -> &[u32] {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner_nodes,typeck\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,typeck\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner_nodes,typeck\", cfg=\"cfail5\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,typeck\", cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n fn exclusive_to_inclusive_range(slice: &[u32]) -> &[u32] {\n     &slice[3..=7]"}, {"sha": "66a82e835dc924caa22a4d6e7b46b63c768c4012", "filename": "src/test/incremental/hashes/match_expressions.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -31,9 +31,9 @@ pub fn add_arm(x: u32) -> u32 {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn add_arm(x: u32) -> u32 {\n     match x {\n@@ -82,9 +82,9 @@ pub fn add_guard_clause(x: u32, y: bool) -> u32 {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn add_guard_clause(x: u32, y: bool) -> u32 {\n     match x {\n@@ -107,9 +107,9 @@ pub fn change_guard_clause(x: u32, y: bool) -> u32 {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn change_guard_clause(x: u32, y: bool) -> u32 {\n     match x {\n@@ -132,9 +132,9 @@ pub fn add_at_binding(x: u32) -> u32 {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn add_at_binding(x: u32) -> u32 {\n     match x {\n@@ -181,9 +181,9 @@ pub fn change_simple_name_to_pattern(x: u32) -> u32 {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn change_simple_name_to_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -275,9 +275,9 @@ pub fn add_amp_to_binding_in_pattern(x: u32) -> u32 {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn add_amp_to_binding_in_pattern(x: u32) -> u32 {\n     match (&x, x & 1) {\n@@ -324,9 +324,9 @@ pub fn add_alternative_to_arm(x: u32) -> u32 {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn add_alternative_to_arm(x: u32) -> u32 {\n     match x {"}, {"sha": "0f2966922bc8fd478003b54d86118a41f251866c", "filename": "src/test/incremental/hashes/struct_constructors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f38c5c8e5d76ea9a87fece143425ef7c703c706a/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f38c5c8e5d76ea9a87fece143425ef7c703c706a/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs?ref=f38c5c8e5d76ea9a87fece143425ef7c703c706a", "patch": "@@ -93,9 +93,9 @@ pub fn add_field_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn add_field_regular_struct() -> RegularStruct {\n     let struct1 = RegularStruct {"}]}