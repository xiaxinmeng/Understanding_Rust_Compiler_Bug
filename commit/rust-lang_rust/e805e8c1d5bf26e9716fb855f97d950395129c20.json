{"sha": "e805e8c1d5bf26e9716fb855f97d950395129c20", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MDVlOGMxZDViZjI2ZTk3MTZmYjg1NWY5N2Q5NTAzOTUxMjljMjA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-29T12:21:57Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-29T15:23:01Z"}, "message": "(T): make typification tests more data driven", "tree": {"sha": "d42f406a04551626fba261e75edd752ffb1894c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d42f406a04551626fba261e75edd752ffb1894c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e805e8c1d5bf26e9716fb855f97d950395129c20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e805e8c1d5bf26e9716fb855f97d950395129c20", "html_url": "https://github.com/rust-lang/rust/commit/e805e8c1d5bf26e9716fb855f97d950395129c20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e805e8c1d5bf26e9716fb855f97d950395129c20/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82ce5792ab70ab8d20a1afde72c5400c27b9c190", "url": "https://api.github.com/repos/rust-lang/rust/commits/82ce5792ab70ab8d20a1afde72c5400c27b9c190", "html_url": "https://github.com/rust-lang/rust/commit/82ce5792ab70ab8d20a1afde72c5400c27b9c190"}], "stats": {"total": 270, "additions": 137, "deletions": 133}, "files": [{"sha": "0481a7b12a46c7cff48b4c38cc68ca5d5b8942ef", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e805e8c1d5bf26e9716fb855f97d950395129c20/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e805e8c1d5bf26e9716fb855f97d950395129c20/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=e805e8c1d5bf26e9716fb855f97d950395129c20", "patch": "@@ -154,6 +154,19 @@ impl TestDB {\n         });\n         (buf, count)\n     }\n+\n+    pub fn all_files(&self) -> Vec<FileId> {\n+        let mut res = Vec::new();\n+        let crate_graph = self.crate_graph();\n+        for krate in crate_graph.iter() {\n+            let crate_def_map = self.crate_def_map(krate);\n+            for (module_id, _) in crate_def_map.modules.iter() {\n+                let file_id = crate_def_map[module_id].origin.file_id();\n+                res.extend(file_id)\n+            }\n+        }\n+        res\n+    }\n }\n \n impl TestDB {"}, {"sha": "4d0dc301151881e43dd47bcbb00d1dc2c910220e", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e805e8c1d5bf26e9716fb855f97d950395129c20/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e805e8c1d5bf26e9716fb855f97d950395129c20/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=e805e8c1d5bf26e9716fb855f97d950395129c20", "patch": "@@ -28,6 +28,7 @@ use ra_syntax::{\n     SyntaxNode,\n };\n use stdx::format_to;\n+use test_utils::extract_annotations;\n \n use crate::{\n     db::HirDatabase, display::HirDisplay, infer::TypeMismatch, test_db::TestDB, InferenceResult, Ty,\n@@ -37,6 +38,21 @@ use crate::{\n // against snapshots of the expected results using insta. Use cargo-insta to\n // update the snapshots.\n \n+fn check_types(ra_fixture: &str) {\n+    let db = TestDB::with_files(ra_fixture);\n+    let mut checked_one = false;\n+    for file_id in db.all_files() {\n+        let text = db.parse(file_id).syntax_node().to_string();\n+        let annotations = extract_annotations(&text);\n+        for (offset, expected) in annotations {\n+            let actual = type_at_pos(&db, FilePosition { file_id, offset });\n+            assert_eq!(expected, actual);\n+            checked_one = true;\n+        }\n+    }\n+    assert!(checked_one, \"no `//^` annotations found\");\n+}\n+\n fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n     type_at_pos_displayed(db, pos, |ty, _| ty.display(db).to_string())\n }"}, {"sha": "64d421d405719322f89b7dd1d03edb258f8219d4", "filename": "crates/ra_hir_ty/src/tests/never_type.rs", "status": "modified", "additions": 46, "deletions": 72, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/e805e8c1d5bf26e9716fb855f97d950395129c20/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e805e8c1d5bf26e9716fb855f97d950395129c20/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=e805e8c1d5bf26e9716fb855f97d950395129c20", "patch": "@@ -1,267 +1,241 @@\n use insta::assert_snapshot;\n \n-use super::{infer_with_mismatches, type_at};\n+use super::{check_types, infer_with_mismatches};\n \n #[test]\n fn infer_never1() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n fn test() {\n     let t = return;\n-    t<|>;\n-}\n+    t;\n+} //^ !\n \"#,\n     );\n-    assert_eq!(t, \"!\");\n }\n \n #[test]\n fn infer_never2() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n fn gen<T>() -> T { loop {} }\n \n fn test() {\n     let a = gen();\n     if false { a } else { loop {} };\n-    a<|>;\n-}\n+    a;\n+} //^ !\n \"#,\n     );\n-    assert_eq!(t, \"!\");\n }\n \n #[test]\n fn infer_never3() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n fn gen<T>() -> T { loop {} }\n \n fn test() {\n     let a = gen();\n     if false { loop {} } else { a };\n-    a<|>;\n+    a;\n+  //^ !\n }\n \"#,\n     );\n-    assert_eq!(t, \"!\");\n }\n \n #[test]\n fn never_type_in_generic_args() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n enum Option<T> { None, Some(T) }\n \n fn test() {\n     let a = if true { Option::None } else { Option::Some(return) };\n-    a<|>;\n-}\n+    a;\n+} //^ Option<!>\n \"#,\n     );\n-    assert_eq!(t, \"Option<!>\");\n }\n \n #[test]\n fn never_type_can_be_reinferred1() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n fn gen<T>() -> T { loop {} }\n \n fn test() {\n     let a = gen();\n     if false { loop {} } else { a };\n-    a<|>;\n+    a;\n+  //^ ()\n     if false { a };\n }\n \"#,\n     );\n-    assert_eq!(t, \"()\");\n }\n \n #[test]\n fn never_type_can_be_reinferred2() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n enum Option<T> { None, Some(T) }\n \n fn test() {\n     let a = if true { Option::None } else { Option::Some(return) };\n-    a<|>;\n+    a;\n+  //^ Option<i32>\n     match 42 {\n         42 => a,\n         _ => Option::Some(42),\n     };\n }\n \"#,\n     );\n-    assert_eq!(t, \"Option<i32>\");\n }\n \n #[test]\n fn never_type_can_be_reinferred3() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n enum Option<T> { None, Some(T) }\n \n fn test() {\n     let a = if true { Option::None } else { Option::Some(return) };\n-    a<|>;\n+    a;\n+  //^ Option<&str>\n     match 42 {\n         42 => a,\n         _ => Option::Some(\"str\"),\n     };\n }\n \"#,\n     );\n-    assert_eq!(t, \"Option<&str>\");\n }\n \n #[test]\n fn match_no_arm() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n enum Void {}\n \n fn test(a: Void) {\n     let t = match a {};\n-    t<|>;\n-}\n+    t;\n+} //^ !\n \"#,\n     );\n-    assert_eq!(t, \"!\");\n }\n \n #[test]\n fn match_unknown_arm() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n fn test(a: Option) {\n     let t = match 0 {\n         _ => unknown,\n     };\n-    t<|>;\n-}\n+    t;\n+} //^ {unknown}\n \"#,\n     );\n-    assert_eq!(t, \"{unknown}\");\n }\n \n #[test]\n fn if_never() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n fn test() {\n     let i = if true {\n         loop {}\n     } else {\n         3.0\n     };\n-    i<|>;\n-}\n+    i;\n+} //^ f64\n \"#,\n     );\n-    assert_eq!(t, \"f64\");\n }\n \n #[test]\n fn if_else_never() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n fn test(input: bool) {\n     let i = if input {\n         2.0\n     } else {\n         return\n     };\n-    i<|>;\n-}\n+    i;\n+} //^ f64\n \"#,\n     );\n-    assert_eq!(t, \"f64\");\n }\n \n #[test]\n fn match_first_arm_never() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n fn test(a: i32) {\n     let i = match a {\n         1 => return,\n         2 => 2.0,\n         3 => loop {},\n         _ => 3.0,\n     };\n-    i<|>;\n-}\n+    i;\n+} //^ f64\n \"#,\n     );\n-    assert_eq!(t, \"f64\");\n }\n \n #[test]\n fn match_second_arm_never() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n fn test(a: i32) {\n     let i = match a {\n         1 => 3.0,\n         2 => loop {},\n         3 => 3.0,\n         _ => return,\n     };\n-    i<|>;\n-}\n+    i;\n+} //^ f64\n \"#,\n     );\n-    assert_eq!(t, \"f64\");\n }\n \n #[test]\n fn match_all_arms_never() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n fn test(a: i32) {\n     let i = match a {\n         2 => return,\n         _ => loop {},\n     };\n-    i<|>;\n-}\n+    i;\n+} //^ !\n \"#,\n     );\n-    assert_eq!(t, \"!\");\n }\n \n #[test]\n fn match_no_never_arms() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n fn test(a: i32) {\n     let i = match a {\n         2 => 2.0,\n         _ => 3.0,\n     };\n-    i<|>;\n-}\n+    i;\n+} //^ f64\n \"#,\n     );\n-    assert_eq!(t, \"f64\");\n }\n \n #[test]"}, {"sha": "de63f4ccea9c8dd41f7031dbf2f71d24dd9c894d", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 28, "deletions": 61, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/e805e8c1d5bf26e9716fb855f97d950395129c20/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e805e8c1d5bf26e9716fb855f97d950395129c20/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=e805e8c1d5bf26e9716fb855f97d950395129c20", "patch": "@@ -1,19 +1,17 @@\n-use super::{infer, type_at, type_at_pos};\n-use crate::test_db::TestDB;\n use insta::assert_snapshot;\n-use ra_db::fixture::WithFixture;\n+\n+use super::{check_types, infer};\n \n #[test]\n fn infer_box() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:std\n-\n fn test() {\n     let x = box 1;\n     let t = (x, box x, box &1, box [1]);\n-    t<|>;\n-}\n+    t;\n+} //^ (Box<i32>, Box<Box<i32>>, Box<&i32>, Box<[i32; _]>)\n \n //- /std.rs crate:std\n #[prelude_import] use prelude::*;\n@@ -25,29 +23,24 @@ mod boxed {\n         inner: *mut T,\n     }\n }\n-\n \"#,\n     );\n-    assert_eq!(\"(Box<i32>, Box<Box<i32>>, Box<&i32>, Box<[i32; _]>)\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_adt_self() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n-//- /main.rs\n enum Nat { Succ(Self), Demo(Nat), Zero }\n \n fn test() {\n     let foo: Nat = Nat::Zero;\n     if let Nat::Succ(x) = foo {\n-        x<|>\n-    }\n+        x\n+    } //^ Nat\n }\n-\n \"#,\n     );\n-    assert_eq!(\"Nat\", type_at_pos(&db, pos));\n }\n \n #[test]\n@@ -93,7 +86,7 @@ fn foo() {\n \n #[test]\n fn infer_ranges() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:core\n fn test() {\n@@ -105,8 +98,8 @@ fn test() {\n     let f = 'a'..='z';\n \n     let t = (a, b, c, d, e, f);\n-    t<|>;\n-}\n+    t;\n+} //^ (RangeFull, RangeFrom<i32>, RangeTo<u32>, Range<usize>, RangeToInclusive<i32>, RangeInclusive<char>)\n \n //- /core.rs crate:core\n #[prelude_import] use prelude::*;\n@@ -135,29 +128,22 @@ pub mod ops {\n }\n \"#,\n     );\n-    assert_eq!(\n-        \"(RangeFull, RangeFrom<i32>, RangeTo<u32>, Range<usize>, RangeToInclusive<i32>, RangeInclusive<char>)\",\n-        type_at_pos(&db, pos),\n-    );\n }\n \n #[test]\n fn infer_while_let() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n-//- /main.rs\n enum Option<T> { Some(T), None }\n \n fn test() {\n     let foo: Option<f32> = None;\n     while let Option::Some(x) = foo {\n-        <|>x\n-    }\n+        x\n+    } //^ f32\n }\n-\n \"#,\n     );\n-    assert_eq!(\"f32\", type_at_pos(&db, pos));\n }\n \n #[test]\n@@ -1687,25 +1673,24 @@ fn test() {\n \n #[test]\n fn shadowing_primitive() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n struct i32;\n struct Foo;\n \n impl i32 { fn foo(&self) -> Foo { Foo } }\n \n fn main() {\n     let x: i32 = i32;\n-    x.foo()<|>;\n+    x.foo();\n+        //^ Foo\n }\"#,\n     );\n-    assert_eq!(t, \"Foo\");\n }\n \n #[test]\n fn not_shadowing_primitive_by_module() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n //- /str.rs\n fn foo() {}\n@@ -1715,15 +1700,15 @@ mod str;\n fn foo() -> &'static str { \"\" }\n \n fn main() {\n-    foo()<|>;\n+    foo();\n+      //^ &str\n }\"#,\n     );\n-    assert_eq!(t, \"&str\");\n }\n \n #[test]\n fn not_shadowing_module_by_primitive() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n //- /str.rs\n fn foo() -> u32 {0}\n@@ -1733,38 +1718,18 @@ mod str;\n fn foo() -> &'static str { \"\" }\n \n fn main() {\n-    str::foo()<|>;\n+    str::foo();\n+           //^ u32\n }\"#,\n     );\n-    assert_eq!(t, \"u32\");\n }\n \n // This test is actually testing the shadowing behavior within ra_hir_def. It\n // lives here because the testing infrastructure in ra_hir_def isn't currently\n // capable of asserting the necessary conditions.\n #[test]\n fn should_be_shadowing_imports() {\n-    let t = type_at(\n-        r#\"\n-mod a {\n-    pub fn foo() -> i8 {0}\n-    pub struct foo { a: i8 }\n-}\n-mod b { pub fn foo () -> u8 {0} }\n-mod c { pub struct foo { a: u8 } }\n-mod d {\n-    pub use super::a::*;\n-    pub use super::c::foo;\n-    pub use super::b::foo;\n-}\n-\n-fn main() {\n-    d::foo()<|>;\n-}\"#,\n-    );\n-    assert_eq!(t, \"u8\");\n-\n-    let t = type_at(\n+    check_types(\n         r#\"\n mod a {\n     pub fn foo() -> i8 {0}\n@@ -1779,10 +1744,12 @@ mod d {\n }\n \n fn main() {\n-    d::foo{a:0<|>};\n+    d::foo();\n+         //^ u8\n+    d::foo{a:0};\n+           //^ u8\n }\"#,\n     );\n-    assert_eq!(t, \"u8\");\n }\n \n #[test]"}, {"sha": "e74f3b263c71eea2ceac81e2770f9dfa5c00710e", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e805e8c1d5bf26e9716fb855f97d950395129c20/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e805e8c1d5bf26e9716fb855f97d950395129c20/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=e805e8c1d5bf26e9716fb855f97d950395129c20", "patch": "@@ -16,6 +16,7 @@ use std::{\n };\n \n use serde_json::Value;\n+use stdx::lines_with_ends;\n use text_size::{TextRange, TextSize};\n \n pub use difference::Changeset as __Changeset;\n@@ -159,6 +160,39 @@ pub fn add_cursor(text: &str, offset: TextSize) -> String {\n     res\n }\n \n+/// Extracts `//^ some text` annotations\n+pub fn extract_annotations(text: &str) -> Vec<(TextSize, String)> {\n+    let mut res = Vec::new();\n+    let mut prev_line_start: Option<TextSize> = None;\n+    let mut line_start: TextSize = 0.into();\n+    for line in lines_with_ends(text) {\n+        if let Some(idx) = line.find(\"//^\") {\n+            let offset = prev_line_start.unwrap() + TextSize::of(&line[..idx + \"//\".len()]);\n+            let data = line[idx + \"//^\".len()..].trim().to_string();\n+            res.push((offset, data))\n+        }\n+        prev_line_start = Some(line_start);\n+        line_start += TextSize::of(line);\n+    }\n+    res\n+}\n+\n+#[test]\n+fn test_extract_annotations() {\n+    let res = extract_annotations(&trim_indent(\n+        r#\"\n+fn main() {\n+    let x = 92;\n+      //^ def\n+\n+    x + 1\n+} //^ i32\n+    \"#,\n+    ));\n+\n+    assert_eq!(res, vec![(20.into(), \"def\".into()), (47.into(), \"i32\".into())]);\n+}\n+\n // Comparison functionality borrowed from cargo:\n \n /// Compare a line with an expected pattern."}]}