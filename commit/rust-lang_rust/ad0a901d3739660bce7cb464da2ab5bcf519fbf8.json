{"sha": "ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMGE5MDFkMzczOTY2MGJjZTdjYjQ2NGRhMmFiNWJjZjUxOWZiZjg=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-11T22:03:52Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:01:40Z"}, "message": "Remove *_builder", "tree": {"sha": "23d3832ad4220a91ea54f6cefdf1829dda38b1f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23d3832ad4220a91ea54f6cefdf1829dda38b1f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "html_url": "https://github.com/rust-lang/rust/commit/ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e77d9289907c413446c5d5fee633ef29b2a09368", "url": "https://api.github.com/repos/rust-lang/rust/commits/e77d9289907c413446c5d5fee633ef29b2a09368", "html_url": "https://github.com/rust-lang/rust/commit/e77d9289907c413446c5d5fee633ef29b2a09368"}], "stats": {"total": 195, "additions": 70, "deletions": 125}, "files": [{"sha": "7f8eef5a51df360314c1488c76f3c97509f6888e", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "patch": "@@ -494,19 +494,13 @@ fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>, t: Ty<'tcx>,\n-                                   val: MaybeSizedValue, discr: Disr, ix: usize) -> ValueRef {\n-    trans_field_ptr_builder(bcx, t, val, discr, ix)\n-}\n-\n-/// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n+pub fn trans_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                                            t: Ty<'tcx>,\n                                            val: MaybeSizedValue,\n                                            discr: Disr, ix: usize)\n                                            -> ValueRef {\n     let l = bcx.ccx().layout_of(t);\n-    debug!(\"trans_field_ptr_builder on {} represented as {:#?}\", t, l);\n+    debug!(\"trans_field_ptr on {} represented as {:#?}\", t, l);\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well."}, {"sha": "d8e4d05872e59545e6845b0ce87fadbddb21b621", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 33, "deletions": 73, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "patch": "@@ -172,22 +172,14 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     }\n }\n \n-pub fn get_meta(bcx: &BlockAndBuilder, fat_ptr: ValueRef) -> ValueRef {\n+pub fn get_meta(bcx: &Builder, fat_ptr: ValueRef) -> ValueRef {\n     bcx.struct_gep(fat_ptr, abi::FAT_PTR_EXTRA)\n }\n \n-pub fn get_dataptr(bcx: &BlockAndBuilder, fat_ptr: ValueRef) -> ValueRef {\n+pub fn get_dataptr(bcx: &Builder, fat_ptr: ValueRef) -> ValueRef {\n     bcx.struct_gep(fat_ptr, abi::FAT_PTR_ADDR)\n }\n \n-pub fn get_meta_builder(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n-    b.struct_gep(fat_ptr, abi::FAT_PTR_EXTRA)\n-}\n-\n-pub fn get_dataptr_builder(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n-    b.struct_gep(fat_ptr, abi::FAT_PTR_ADDR)\n-}\n-\n fn require_alloc_fn<'blk, 'tcx>(\n     bcx: &BlockAndBuilder<'blk, 'tcx>, info_ty: Ty<'tcx>, it: LangItem\n ) -> DefId {\n@@ -516,13 +508,7 @@ pub fn call_assume<'a, 'tcx>(b: &Builder<'a, 'tcx>, val: ValueRef) {\n /// Helper for loading values from memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values. Also handles various special cases where the type\n /// gives us better information about what we are loading.\n-pub fn load_ty<'blk, 'tcx>(\n-    cx: &BlockAndBuilder<'blk, 'tcx>, ptr: ValueRef, t: Ty<'tcx>\n-) -> ValueRef {\n-    load_ty_builder(cx, ptr, t)\n-}\n-\n-pub fn load_ty_builder<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n+pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n     let ccx = b.ccx;\n     if type_is_zero_size(ccx, t) {\n         return C_undef(type_of::type_of(ccx, t));\n@@ -581,30 +567,22 @@ pub fn store_fat_ptr<'blk, 'tcx>(cx: &BlockAndBuilder<'blk, 'tcx>,\n     cx.store(extra, get_meta(cx, dst));\n }\n \n-pub fn load_fat_ptr<'blk, 'tcx>(cx: &BlockAndBuilder<'blk, 'tcx>,\n-                                src: ValueRef,\n-                                ty: Ty<'tcx>)\n-                                -> (ValueRef, ValueRef)\n-{\n-    load_fat_ptr_builder(cx, src, ty)\n-}\n-\n-pub fn load_fat_ptr_builder<'a, 'tcx>(\n+pub fn load_fat_ptr<'a, 'tcx>(\n     b: &Builder<'a, 'tcx>,\n     src: ValueRef,\n     t: Ty<'tcx>)\n     -> (ValueRef, ValueRef)\n {\n \n-    let ptr = get_dataptr_builder(b, src);\n+    let ptr = get_dataptr(b, src);\n     let ptr = if t.is_region_ptr() || t.is_unique() {\n         b.load_nonnull(ptr)\n     } else {\n         b.load(ptr)\n     };\n \n     // FIXME: emit metadata on `meta`.\n-    let meta = b.load(get_meta_builder(b, src));\n+    let meta = b.load(get_meta(b, src));\n \n     (ptr, meta)\n }\n@@ -647,56 +625,38 @@ pub fn with_cond<'blk, 'tcx, F>(\n \n pub enum Lifetime { Start, End }\n \n-// If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n-// on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n-// and the intrinsic for `lt` and passes them to `emit`, which is in\n-// charge of generating code to call the passed intrinsic on whatever\n-// block of generated code is targetted for the intrinsic.\n-//\n-// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n-// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n-fn core_lifetime_emit<'blk, 'tcx, F>(ccx: &'blk CrateContext<'blk, 'tcx>,\n-                                     ptr: ValueRef,\n-                                     lt: Lifetime,\n-                                     emit: F)\n-    where F: FnOnce(&'blk CrateContext<'blk, 'tcx>, machine::llsize, ValueRef)\n-{\n-    if ccx.sess().opts.optimize == config::OptLevel::No {\n-        return;\n-    }\n-\n-    let _icx = push_ctxt(match lt {\n-        Lifetime::Start => \"lifetime_start\",\n-        Lifetime::End => \"lifetime_end\"\n-    });\n-\n-    let size = machine::llsize_of_alloc(ccx, val_ty(ptr).element_type());\n-    if size == 0 {\n-        return;\n-    }\n-\n-    let lifetime_intrinsic = ccx.get_intrinsic(match lt {\n-        Lifetime::Start => \"llvm.lifetime.start\",\n-        Lifetime::End => \"llvm.lifetime.end\"\n-    });\n-    emit(ccx, size, lifetime_intrinsic)\n-}\n-\n impl Lifetime {\n+    // If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n+    // on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n+    // and the intrinsic for `lt` and passes them to `emit`, which is in\n+    // charge of generating code to call the passed intrinsic on whatever\n+    // block of generated code is targetted for the intrinsic.\n+    //\n+    // If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n+    // off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n     pub fn call(self, b: &Builder, ptr: ValueRef) {\n-        core_lifetime_emit(b.ccx, ptr, self, |ccx, size, lifetime_intrinsic| {\n-            let ptr = b.pointercast(ptr, Type::i8p(ccx));\n-            b.call(lifetime_intrinsic, &[C_u64(ccx, size), ptr], None);\n+        if b.ccx.sess().opts.optimize == config::OptLevel::No {\n+            return;\n+        }\n+\n+        let _icx = push_ctxt(match self {\n+            Lifetime::Start => \"lifetime_start\",\n+            Lifetime::End => \"lifetime_end\"\n         });\n-    }\n-}\n \n-pub fn call_lifetime_start(bcx: &BlockAndBuilder, ptr: ValueRef) {\n-    Lifetime::Start.call(bcx, ptr);\n-}\n+        let size = machine::llsize_of_alloc(b.ccx, val_ty(ptr).element_type());\n+        if size == 0 {\n+            return;\n+        }\n+\n+        let lifetime_intrinsic = b.ccx.get_intrinsic(match self {\n+            Lifetime::Start => \"llvm.lifetime.start\",\n+            Lifetime::End => \"llvm.lifetime.end\"\n+        });\n \n-pub fn call_lifetime_end(bcx: &BlockAndBuilder, ptr: ValueRef) {\n-    Lifetime::End.call(bcx, ptr);\n+        let ptr = b.pointercast(ptr, Type::i8p(b.ccx));\n+        b.call(lifetime_intrinsic, &[C_u64(b.ccx, size), ptr], None);\n+    }\n }\n \n // Generates code for resumption of unwind at the end of a landing pad."}, {"sha": "d09f049ca18d9350745a3042ecd5a4d24a1aa467", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "patch": "@@ -1103,14 +1103,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn add_case(s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n+    pub fn add_case(&self, s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n         unsafe {\n             if llvm::LLVMIsUndef(s) == llvm::True { return; }\n             llvm::LLVMAddCase(s, on_val, dest)\n         }\n     }\n \n-    pub fn add_incoming_to_phi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n+    pub fn add_incoming_to_phi(&self, phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n         unsafe {\n             if llvm::LLVMIsUndef(phi) == llvm::True { return; }\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);"}, {"sha": "a3b4135fcc7ded53bf55672bfda67daa02efe2c9", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "patch": "@@ -117,7 +117,7 @@\n pub use self::EarlyExitLabel::*;\n \n use llvm::{BasicBlockRef, ValueRef};\n-use base;\n+use base::{self, Lifetime};\n use common;\n use common::{BlockAndBuilder, FunctionContext, LandingPad};\n use debuginfo::{DebugLoc};\n@@ -422,7 +422,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                                 let addr = self.landingpad_alloca.get()\n                                                .unwrap();\n                                 let lp = bcx.load(addr);\n-                                base::call_lifetime_end(&bcx, addr);\n+                                Lifetime::End.call(&bcx, addr);\n                                 base::trans_unwind_resume(&bcx, lp);\n                             }\n                             UnwindKind::CleanupPad(_) => {\n@@ -559,9 +559,8 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             let addr = match self.landingpad_alloca.get() {\n                 Some(addr) => addr,\n                 None => {\n-                    let addr = base::alloca(&pad_bcx, common::val_ty(llretval),\n-                                            \"\");\n-                    base::call_lifetime_start(&pad_bcx, addr);\n+                    let addr = base::alloca(&pad_bcx, common::val_ty(llretval), \"\");\n+                    Lifetime::Start.call(&pad_bcx, addr);\n                     self.landingpad_alloca.set(Some(addr));\n                     addr\n                 }"}, {"sha": "1283a7796f406e79e185405cf0f9497e6312c06b", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "patch": "@@ -15,7 +15,7 @@\n use session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef, TypeKind};\n-use llvm::{True, False, Bool, OperandBundleDef};\n+use llvm::{True, False, Bool, OperandBundleDef, get_param};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;"}, {"sha": "a9e2f00ee73bb0de9749fd0267492351bc5d6224", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "patch": "@@ -23,7 +23,6 @@ use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n use adt;\n use base::*;\n use callee::{Callee};\n-use builder::Builder;\n use common::*;\n use machine::*;\n use monomorphize;\n@@ -164,10 +163,10 @@ pub fn drop_ty_immediate<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n                                      -> BlockAndBuilder<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloc_ty(&bcx, t, \"\");\n-    call_lifetime_start(&bcx, vp);\n+    Lifetime::Start.call(&bcx, vp);\n     store_ty(&bcx, v, vp, t);\n     let bcx = drop_ty_core(bcx, vp, t, skip_dtor);\n-    call_lifetime_end(&bcx, vp);\n+    Lifetime::End.call(&bcx, vp);\n     bcx\n }\n \n@@ -602,7 +601,7 @@ fn drop_structural_ty<'blk, 'tcx>(cx: BlockAndBuilder<'blk, 'tcx>,\n                                 &variant.disr_val.to_string());\n                             let variant_cx = fcx.new_block(&variant_cx_name).build();\n                             let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n-                            Builder::add_case(llswitch, case_val, variant_cx.llbb());\n+                            variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n                             let variant_cx = iter_variant(variant_cx, t, value, variant, substs);\n                             variant_cx.br(next_cx.llbb());\n                         }"}, {"sha": "a37c6d0d2bb9014aadf84d2a0c930447ab5ed10d", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "patch": "@@ -15,11 +15,10 @@ use rustc::ty::{self, layout};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n use adt;\n-use base;\n+use base::{self, Lifetime};\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n use common::{self, Block, BlockAndBuilder, LandingPad};\n use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n-use builder::Builder;\n use consts;\n use debuginfo::DebugLoc;\n use Disr;\n@@ -122,7 +121,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                     let ps = self.get_personality_slot(&bcx);\n                     let lp = bcx.load(ps);\n-                    base::call_lifetime_end(&bcx, ps);\n+                    Lifetime::End.call(&bcx, ps);\n                     base::trans_unwind_resume(&bcx, lp);\n                 }\n             }\n@@ -167,7 +166,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if default_bb != Some(target) {\n                         let llbb = llblock(self, target);\n                         let llval = adt::trans_case(&bcx, ty, Disr::from(adt_variant.disr_val));\n-                        Builder::add_case(switch, llval, llbb)\n+                        bcx.add_case(switch, llval, llbb)\n                     }\n                 }\n             }\n@@ -180,7 +179,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 for (value, target) in values.iter().zip(targets) {\n                     let val = Const::from_constval(bcx.ccx(), value.clone(), switch_ty);\n                     let llbb = llblock(self, *target);\n-                    Builder::add_case(switch, val.llval, llbb)\n+                    bcx.add_case(switch, val.llval, llbb)\n                 }\n             }\n \n@@ -256,7 +255,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     // here that can be cleanly backported to beta, so\n                     // I want to avoid touching all of trans.\n                     let scratch = base::alloc_ty(&bcx, ty, \"drop\");\n-                    base::call_lifetime_start(&bcx, scratch);\n+                    Lifetime::Start.call(&bcx, scratch);\n                     bcx.store(lvalue.llval, base::get_dataptr(&bcx, scratch));\n                     bcx.store(lvalue.llextra, base::get_meta(&bcx, scratch));\n                     scratch\n@@ -478,7 +477,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         // here that can be cleanly backported to beta, so\n                         // I want to avoid touching all of trans.\n                         let scratch = base::alloc_ty(&bcx, ty, \"drop\");\n-                        base::call_lifetime_start(&bcx, scratch);\n+                        Lifetime::Start.call(&bcx, scratch);\n                         bcx.store(llval, base::get_dataptr(&bcx, scratch));\n                         bcx.store(llextra, base::get_meta(&bcx, scratch));\n                         scratch\n@@ -752,9 +751,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             Ref(llval) => {\n                 let base = adt::MaybeSizedValue::sized(llval);\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let ptr = adt::trans_field_ptr_builder(bcx, tuple.ty, base, Disr(0), n);\n+                    let ptr = adt::trans_field_ptr(bcx, tuple.ty, base, Disr(0), n);\n                     let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n-                        let (lldata, llextra) = base::load_fat_ptr_builder(bcx, ptr, ty);\n+                        let (lldata, llextra) = base::load_fat_ptr(bcx, ptr, ty);\n                         Pair(lldata, llextra)\n                     } else {\n                         // trans_argument will load this if it needs to\n@@ -817,7 +816,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n             let slot = base::alloca(bcx, llretty, \"personalityslot\");\n             self.llpersonalityslot = Some(slot);\n-            base::call_lifetime_start(bcx, slot);\n+            Lifetime::Start.call(bcx, slot);\n             slot\n         }\n     }"}, {"sha": "cb440eda18208f8cf0b5a55268eacc089f4463c1", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "patch": "@@ -146,8 +146,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         } else {\n                             adt::MaybeSizedValue::unsized_(tr_base.llval, tr_base.llextra)\n                         };\n-                        let llprojected = adt::trans_field_ptr_builder(bcx, base_ty, base,\n-                                                                       Disr(discr), field.index());\n+                        let llprojected = adt::trans_field_ptr(bcx, base_ty, base, Disr(discr),\n+                            field.index());\n                         let llextra = if is_sized {\n                             ptr::null_mut()\n                         } else {"}, {"sha": "27dea2fd231b962a552df279138b9af6c25ca175", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "patch": "@@ -361,10 +361,8 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                     // they are the two sub-fields of a single aggregate field.\n                     let meta = &fcx.fn_ty.args[idx];\n                     idx += 1;\n-                    arg.store_fn_arg(bcx, &mut llarg_idx,\n-                                     base::get_dataptr_builder(bcx, dst));\n-                    meta.store_fn_arg(bcx, &mut llarg_idx,\n-                                      base::get_meta_builder(bcx, dst));\n+                    arg.store_fn_arg(bcx, &mut llarg_idx, base::get_dataptr(bcx, dst));\n+                    meta.store_fn_arg(bcx, &mut llarg_idx, base::get_meta(bcx, dst));\n                 } else {\n                     arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n                 }\n@@ -436,10 +434,8 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                 // so make an alloca to store them in.\n                 let meta = &fcx.fn_ty.args[idx];\n                 idx += 1;\n-                arg.store_fn_arg(bcx, &mut llarg_idx,\n-                                 base::get_dataptr_builder(bcx, lltemp));\n-                meta.store_fn_arg(bcx, &mut llarg_idx,\n-                                  base::get_meta_builder(bcx, lltemp));\n+                arg.store_fn_arg(bcx, &mut llarg_idx, base::get_dataptr(bcx, lltemp));\n+                meta.store_fn_arg(bcx, &mut llarg_idx, base::get_meta(bcx, lltemp));\n             } else  {\n                 // otherwise, arg is passed by value, so make a\n                 // temporary and store it there"}, {"sha": "b3ea8d5c7632103def03173ee9a52440415aba87", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "patch": "@@ -144,19 +144,19 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         debug!(\"trans_load: {:?} @ {:?}\", Value(llval), ty);\n \n         let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n-            let (lldata, llextra) = base::load_fat_ptr_builder(bcx, llval, ty);\n+            let (lldata, llextra) = base::load_fat_ptr(bcx, llval, ty);\n             OperandValue::Pair(lldata, llextra)\n         } else if common::type_is_imm_pair(bcx.ccx(), ty) {\n             let [a_ty, b_ty] = common::type_pair_fields(bcx.ccx(), ty).unwrap();\n             let a_ptr = bcx.struct_gep(llval, 0);\n             let b_ptr = bcx.struct_gep(llval, 1);\n \n             OperandValue::Pair(\n-                base::load_ty_builder(bcx, a_ptr, a_ty),\n-                base::load_ty_builder(bcx, b_ptr, b_ty)\n+                base::load_ty(bcx, a_ptr, a_ty),\n+                base::load_ty(bcx, b_ptr, b_ty)\n             )\n         } else if common::type_is_immediate(bcx.ccx(), ty) {\n-            OperandValue::Immediate(base::load_ty_builder(bcx, llval, ty))\n+            OperandValue::Immediate(base::load_ty(bcx, llval, ty))\n         } else {\n             OperandValue::Ref(llval)\n         };"}, {"sha": "e32d25dc01ef60b0a8701397b710140f10ce7836", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "patch": "@@ -97,7 +97,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n                 let size = count.value.as_u64(bcx.tcx().sess.target.uint_type);\n                 let size = C_uint(bcx.ccx(), size);\n-                let base = base::get_dataptr_builder(&bcx, dest.llval);\n+                let base = base::get_dataptr(&bcx, dest.llval);\n                 let bcx = tvec::slice_for_each(bcx, base, tr_elem.ty, size, |bcx, llslot| {\n                     self.store_operand_direct(&bcx, llslot, tr_elem);\n                     bcx\n@@ -109,17 +109,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 match *kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n                         let disr = Disr::from(adt_def.variants[variant_index].disr_val);\n-                        adt::trans_set_discr(&bcx,\n-                            dest.ty.to_ty(bcx.tcx()), dest.llval, Disr::from(disr));\n+                        let dest_ty = dest.ty.to_ty(bcx.tcx());\n+                        adt::trans_set_discr(&bcx, dest_ty, dest.llval, Disr::from(disr));\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n                                 let val = adt::MaybeSizedValue::sized(dest.llval);\n                                 let field_index = active_field_index.unwrap_or(i);\n-                                let lldest_i = adt::trans_field_ptr_builder(&bcx,\n-                                    dest.ty.to_ty(bcx.tcx()),\n-                                    val, disr, field_index);\n+                                let lldest_i = adt::trans_field_ptr(&bcx, dest_ty, val, disr,\n+                                    field_index);\n                                 self.store_operand(&bcx, lldest_i, op);\n                             }\n                         }"}, {"sha": "931eb563e36355df166704302a127ab0cea7b049", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad0a901d3739660bce7cb464da2ab5bcf519fbf8/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "patch": "@@ -14,7 +14,6 @@ use llvm;\n use llvm::ValueRef;\n use base::*;\n use common::*;\n-use builder::Builder;\n use rustc::ty::Ty;\n \n pub fn slice_for_each<'blk, 'tcx, F>(bcx: BlockAndBuilder<'blk, 'tcx>,\n@@ -61,7 +60,7 @@ pub fn slice_for_each<'blk, 'tcx, F>(bcx: BlockAndBuilder<'blk, 'tcx>,\n     } else {\n         body_bcx.inbounds_gep(current, &[C_uint(bcx.ccx(), 1usize)])\n     };\n-    Builder::add_incoming_to_phi(current, next, body_bcx.llbb());\n+    body_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n     body_bcx.br(header_bcx.llbb());\n     next_bcx\n }"}]}