{"sha": "2af02cf2c4061f517d5fc81591c9ae6b53225d24", "node_id": "C_kwDOAAsO6NoAKDJhZjAyY2YyYzQwNjFmNTE3ZDVmYzgxNTkxYzlhZTZiNTMyMjVkMjQ", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-12-16T00:00:48Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:28Z"}, "message": "More comments and refactoring\n\nThe refactoring mainly keeps the separation between the modules clearer.\nFor example, process_deferred_edges function moved to cfg_build.rs since\nthat is really part of building the CFG, not finding the fixpoint.\n\nAlso, we use PostOrderId instead of usize in a lot more places now.", "tree": {"sha": "4dbd5300529ba79026ef412fd15eedafeaeb46cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dbd5300529ba79026ef412fd15eedafeaeb46cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2af02cf2c4061f517d5fc81591c9ae6b53225d24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2af02cf2c4061f517d5fc81591c9ae6b53225d24", "html_url": "https://github.com/rust-lang/rust/commit/2af02cf2c4061f517d5fc81591c9ae6b53225d24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2af02cf2c4061f517d5fc81591c9ae6b53225d24/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d82e4f7642a3675e7dc87a483d79cf02681d930", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d82e4f7642a3675e7dc87a483d79cf02681d930", "html_url": "https://github.com/rust-lang/rust/commit/7d82e4f7642a3675e7dc87a483d79cf02681d930"}], "stats": {"total": 192, "additions": 117, "deletions": 75}, "files": [{"sha": "9fbefcfb088c3fe9c86a76a6212bad89d3f5f8f9", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2af02cf2c4061f517d5fc81591c9ae6b53225d24/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af02cf2c4061f517d5fc81591c9ae6b53225d24/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=2af02cf2c4061f517d5fc81591c9ae6b53225d24", "patch": "@@ -41,7 +41,7 @@ pub fn compute_drop_ranges<'a, 'tcx>(\n \n     drop_ranges.propagate_to_fixpoint();\n \n-    drop_ranges\n+    DropRanges { hir_id_map: drop_ranges.hir_id_map, nodes: drop_ranges.nodes }\n }\n \n /// Applies `f` to consumable portion of a HIR node.\n@@ -77,12 +77,59 @@ rustc_index::newtype_index! {\n pub struct DropRanges {\n     hir_id_map: HirIdMap<HirIdIndex>,\n     nodes: IndexVec<PostOrderId, NodeInfo>,\n-    deferred_edges: Vec<(usize, HirId)>,\n-    // FIXME: This should only be used for loops and break/continue.\n-    post_order_map: HirIdMap<usize>,\n }\n \n-impl Debug for DropRanges {\n+impl DropRanges {\n+    pub fn is_dropped_at(&self, hir_id: HirId, location: usize) -> bool {\n+        self.hir_id_map\n+            .get(&hir_id)\n+            .copied()\n+            .map_or(false, |hir_id| self.expect_node(location.into()).drop_state.contains(hir_id))\n+    }\n+\n+    /// Returns a reference to the NodeInfo for a node, panicking if it does not exist\n+    fn expect_node(&self, id: PostOrderId) -> &NodeInfo {\n+        &self.nodes[id]\n+    }\n+}\n+\n+/// Tracks information needed to compute drop ranges.\n+struct DropRangesBuilder {\n+    /// The core of DropRangesBuilder is a set of nodes, which each represent\n+    /// one expression. We primarily refer to them by their index in a\n+    /// post-order traversal of the HIR tree,  since this is what\n+    /// generator_interior uses to talk about yield positions.\n+    ///\n+    /// This IndexVec keeps the relevant details for each node. See the\n+    /// NodeInfo struct for more details, but this information includes things\n+    /// such as the set of control-flow successors, which variables are dropped\n+    /// or reinitialized, and whether each variable has been inferred to be\n+    /// known-dropped or potentially reintiialized at each point.\n+    nodes: IndexVec<PostOrderId, NodeInfo>,\n+    /// We refer to values whose drop state we are tracking by the HirId of\n+    /// where they are defined. Within a NodeInfo, however, we store the\n+    /// drop-state in a bit vector indexed by a HirIdIndex\n+    /// (see NodeInfo::drop_state). The hir_id_map field stores the mapping\n+    /// from HirIds to the HirIdIndex that is used to represent that value in\n+    /// bitvector.\n+    hir_id_map: HirIdMap<HirIdIndex>,\n+\n+    /// When building the control flow graph, we don't always know the\n+    /// post-order index of the target node at the point we encounter it.\n+    /// For example, this happens with break and continue. In those cases,\n+    /// we store a pair of the PostOrderId of the source and the HirId\n+    /// of the target. Once we have gathered all of these edges, we make a\n+    /// pass over the set of deferred edges (see process_deferred_edges in\n+    /// cfg_build.rs), look up the PostOrderId for the target (since now the\n+    /// post-order index for all nodes is known), and add missing control flow\n+    /// edges.\n+    deferred_edges: Vec<(PostOrderId, HirId)>,\n+    /// This maps HirIds of expressions to their post-order index. It is\n+    /// used in process_deferred_edges to correctly add back-edges.\n+    post_order_map: HirIdMap<PostOrderId>,\n+}\n+\n+impl Debug for DropRangesBuilder {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         f.debug_struct(\"DropRanges\")\n             .field(\"hir_id_map\", &self.hir_id_map)\n@@ -98,32 +145,20 @@ impl Debug for DropRanges {\n /// by their index in the post-order traversal. At its core, DropRanges maps\n /// (hir_id, post_order_id) -> bool, where a true value indicates that the value is definitely\n /// dropped at the point of the node identified by post_order_id.\n-impl DropRanges {\n-    pub fn is_dropped_at(&mut self, hir_id: HirId, location: usize) -> bool {\n-        self.hir_id_map\n-            .get(&hir_id)\n-            .copied()\n-            .map_or(false, |hir_id| self.expect_node(location.into()).drop_state.contains(hir_id))\n-    }\n-\n+impl DropRangesBuilder {\n     /// Returns the number of values (hir_ids) that are tracked\n     fn num_values(&self) -> usize {\n         self.hir_id_map.len()\n     }\n \n-    /// Returns a reference to the NodeInfo for a node, panicking if it does not exist\n-    fn expect_node(&self, id: PostOrderId) -> &NodeInfo {\n-        &self.nodes[id]\n-    }\n-\n     fn node_mut(&mut self, id: PostOrderId) -> &mut NodeInfo {\n         let size = self.num_values();\n         self.nodes.ensure_contains_elem(id, || NodeInfo::new(size));\n         &mut self.nodes[id]\n     }\n \n-    fn add_control_edge(&mut self, from: usize, to: usize) {\n-        trace!(\"adding control edge from {} to {}\", from, to);\n+    fn add_control_edge(&mut self, from: PostOrderId, to: PostOrderId) {\n+        trace!(\"adding control edge from {:?} to {:?}\", from, to);\n         self.node_mut(from.into()).successors.push(to.into());\n     }\n }"}, {"sha": "32f423f3bfeef7fcde2502eec1b0340723e25ab0", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 51, "deletions": 33, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2af02cf2c4061f517d5fc81591c9ae6b53225d24/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af02cf2c4061f517d5fc81591c9ae6b53225d24/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=2af02cf2c4061f517d5fc81591c9ae6b53225d24", "patch": "@@ -1,6 +1,6 @@\n use super::{\n-    for_each_consumable, record_consumed_borrow::ConsumedAndBorrowedPlaces, DropRanges, HirIdIndex,\n-    NodeInfo,\n+    for_each_consumable, record_consumed_borrow::ConsumedAndBorrowedPlaces, DropRangesBuilder,\n+    HirIdIndex, NodeInfo, PostOrderId,\n };\n use hir::{\n     intravisit::{self, NestedVisitorMap, Visitor},\n@@ -9,20 +9,24 @@ use hir::{\n use rustc_hir as hir;\n use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::Map;\n+use std::mem::swap;\n \n /// Traverses the body to find the control flow graph and locations for the\n /// relevant places are dropped or reinitialized.\n ///\n /// The resulting structure still needs to be iterated to a fixed point, which\n /// can be done with propagate_to_fixpoint in cfg_propagate.\n-pub fn build_control_flow_graph<'tcx>(\n+pub(super) fn build_control_flow_graph<'tcx>(\n     hir: Map<'tcx>,\n     consumed_borrowed_places: ConsumedAndBorrowedPlaces,\n     body: &'tcx Body<'tcx>,\n     num_exprs: usize,\n-) -> DropRanges {\n+) -> DropRangesBuilder {\n     let mut drop_range_visitor = DropRangeVisitor::new(hir, consumed_borrowed_places, num_exprs);\n     intravisit::walk_body(&mut drop_range_visitor, body);\n+\n+    drop_range_visitor.drop_ranges.process_deferred_edges();\n+\n     drop_range_visitor.drop_ranges\n }\n \n@@ -35,35 +39,35 @@ pub fn build_control_flow_graph<'tcx>(\n struct DropRangeVisitor<'tcx> {\n     hir: Map<'tcx>,\n     places: ConsumedAndBorrowedPlaces,\n-    drop_ranges: DropRanges,\n-    expr_count: usize,\n+    drop_ranges: DropRangesBuilder,\n+    expr_index: PostOrderId,\n }\n \n impl<'tcx> DropRangeVisitor<'tcx> {\n     fn new(hir: Map<'tcx>, places: ConsumedAndBorrowedPlaces, num_exprs: usize) -> Self {\n         debug!(\"consumed_places: {:?}\", places.consumed);\n-        let drop_ranges = DropRanges::new(\n+        let drop_ranges = DropRangesBuilder::new(\n             places.consumed.iter().flat_map(|(_, places)| places.iter().copied()),\n             hir,\n             num_exprs,\n         );\n-        Self { hir, places, drop_ranges, expr_count: 0 }\n+        Self { hir, places, drop_ranges, expr_index: PostOrderId::from_u32(0) }\n     }\n \n     fn record_drop(&mut self, hir_id: HirId) {\n         if self.places.borrowed.contains(&hir_id) {\n             debug!(\"not marking {:?} as dropped because it is borrowed at some point\", hir_id);\n         } else {\n-            debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n-            let count = self.expr_count;\n+            debug!(\"marking {:?} as dropped at {:?}\", hir_id, self.expr_index);\n+            let count = self.expr_index;\n             self.drop_ranges.drop_at(hir_id, count);\n         }\n     }\n \n     /// ExprUseVisitor's consume callback doesn't go deep enough for our purposes in all\n     /// expressions. This method consumes a little deeper into the expression when needed.\n     fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n-        debug!(\"consuming expr {:?}, count={}\", expr.hir_id, self.expr_count);\n+        debug!(\"consuming expr {:?}, count={:?}\", expr.hir_id, self.expr_index);\n         let places = self\n             .places\n             .consumed\n@@ -80,8 +84,8 @@ impl<'tcx> DropRangeVisitor<'tcx> {\n             hir::Path { res: hir::def::Res::Local(hir_id), .. },\n         )) = expr.kind\n         {\n-            let location = self.expr_count;\n-            debug!(\"reinitializing {:?} at {}\", hir_id, location);\n+            let location = self.expr_index;\n+            debug!(\"reinitializing {:?} at {:?}\", hir_id, location);\n             self.drop_ranges.reinit_at(*hir_id, location);\n         } else {\n             debug!(\"reinitializing {:?} is not supported\", expr);\n@@ -102,18 +106,18 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n             ExprKind::If(test, if_true, if_false) => {\n                 self.visit_expr(test);\n \n-                let fork = self.expr_count;\n+                let fork = self.expr_index;\n \n-                self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n+                self.drop_ranges.add_control_edge(fork, self.expr_index + 1);\n                 self.visit_expr(if_true);\n-                let true_end = self.expr_count;\n+                let true_end = self.expr_index;\n \n-                self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n+                self.drop_ranges.add_control_edge(fork, self.expr_index + 1);\n                 if let Some(if_false) = if_false {\n                     self.visit_expr(if_false);\n                 }\n \n-                self.drop_ranges.add_control_edge(true_end, self.expr_count + 1);\n+                self.drop_ranges.add_control_edge(true_end, self.expr_index + 1);\n             }\n             ExprKind::Assign(lhs, rhs, _) => {\n                 self.visit_expr(lhs);\n@@ -122,18 +126,18 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n                 reinit = Some(lhs);\n             }\n             ExprKind::Loop(body, ..) => {\n-                let loop_begin = self.expr_count + 1;\n+                let loop_begin = self.expr_index + 1;\n                 self.visit_block(body);\n-                self.drop_ranges.add_control_edge(self.expr_count, loop_begin);\n+                self.drop_ranges.add_control_edge(self.expr_index, loop_begin);\n             }\n             ExprKind::Match(scrutinee, arms, ..) => {\n                 self.visit_expr(scrutinee);\n \n-                let fork = self.expr_count;\n+                let fork = self.expr_index;\n                 let arm_end_ids = arms\n                     .iter()\n                     .map(|hir::Arm { pat, body, guard, .. }| {\n-                        self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n+                        self.drop_ranges.add_control_edge(fork, self.expr_index + 1);\n                         self.visit_pat(pat);\n                         match guard {\n                             Some(Guard::If(expr)) => self.visit_expr(expr),\n@@ -144,23 +148,23 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n                             None => (),\n                         }\n                         self.visit_expr(body);\n-                        self.expr_count\n+                        self.expr_index\n                     })\n                     .collect::<Vec<_>>();\n                 arm_end_ids.into_iter().for_each(|arm_end| {\n-                    self.drop_ranges.add_control_edge(arm_end, self.expr_count + 1)\n+                    self.drop_ranges.add_control_edge(arm_end, self.expr_index + 1)\n                 });\n             }\n             ExprKind::Break(hir::Destination { target_id: Ok(target), .. }, ..)\n             | ExprKind::Continue(hir::Destination { target_id: Ok(target), .. }, ..) => {\n-                self.drop_ranges.add_control_edge_hir_id(self.expr_count, target);\n+                self.drop_ranges.add_control_edge_hir_id(self.expr_index, target);\n             }\n \n             _ => intravisit::walk_expr(self, expr),\n         }\n \n-        self.expr_count += 1;\n-        self.drop_ranges.add_node_mapping(expr.hir_id, self.expr_count);\n+        self.expr_index = self.expr_index + 1;\n+        self.drop_ranges.add_node_mapping(expr.hir_id, self.expr_index);\n         self.consume_expr(expr);\n         if let Some(expr) = reinit {\n             self.reinit_expr(expr);\n@@ -171,11 +175,11 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n         intravisit::walk_pat(self, pat);\n \n         // Increment expr_count here to match what InteriorVisitor expects.\n-        self.expr_count += 1;\n+        self.expr_index = self.expr_index + 1;\n     }\n }\n \n-impl DropRanges {\n+impl DropRangesBuilder {\n     fn new(hir_ids: impl Iterator<Item = HirId>, hir: Map<'_>, num_exprs: usize) -> Self {\n         let mut hir_id_map = HirIdMap::<HirIdIndex>::default();\n         let mut next = <_>::from(0u32);\n@@ -204,24 +208,24 @@ impl DropRanges {\n     /// Adds an entry in the mapping from HirIds to PostOrderIds\n     ///\n     /// Needed so that `add_control_edge_hir_id` can work.\n-    fn add_node_mapping(&mut self, hir_id: HirId, post_order_id: usize) {\n+    fn add_node_mapping(&mut self, hir_id: HirId, post_order_id: PostOrderId) {\n         self.post_order_map.insert(hir_id, post_order_id);\n     }\n \n     /// Like add_control_edge, but uses a hir_id as the target.\n     ///\n     /// This can be used for branches where we do not know the PostOrderId of the target yet,\n     /// such as when handling `break` or `continue`.\n-    fn add_control_edge_hir_id(&mut self, from: usize, to: HirId) {\n+    fn add_control_edge_hir_id(&mut self, from: PostOrderId, to: HirId) {\n         self.deferred_edges.push((from, to));\n     }\n \n-    fn drop_at(&mut self, value: HirId, location: usize) {\n+    fn drop_at(&mut self, value: HirId, location: PostOrderId) {\n         let value = self.hidx(value);\n         self.node_mut(location.into()).drops.push(value);\n     }\n \n-    fn reinit_at(&mut self, value: HirId, location: usize) {\n+    fn reinit_at(&mut self, value: HirId, location: PostOrderId) {\n         let value = match self.hir_id_map.get(&value) {\n             Some(value) => *value,\n             // If there's no value, this is never consumed and therefore is never dropped. We can\n@@ -230,4 +234,18 @@ impl DropRanges {\n         };\n         self.node_mut(location.into()).reinits.push(value);\n     }\n+\n+    /// Looks up PostOrderId for any control edges added by HirId and adds a proper edge for them.\n+    ///\n+    /// Should be called after visiting the HIR but before solving the control flow, otherwise some\n+    /// edges will be missed.\n+    fn process_deferred_edges(&mut self) {\n+        let mut edges = vec![];\n+        swap(&mut edges, &mut self.deferred_edges);\n+        edges.into_iter().for_each(|(from, to)| {\n+            let to = *self.post_order_map.get(&to).expect(\"Expression ID not found\");\n+            trace!(\"Adding deferred edge from {:?} to {:?}\", from, to);\n+            self.add_control_edge(from, to)\n+        });\n+    }\n }"}, {"sha": "22f7484abf3e2157baa9e1b73a287c7adb059683", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_propagate.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2af02cf2c4061f517d5fc81591c9ae6b53225d24/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af02cf2c4061f517d5fc81591c9ae6b53225d24/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs?ref=2af02cf2c4061f517d5fc81591c9ae6b53225d24", "patch": "@@ -1,12 +1,10 @@\n-use super::{DropRanges, PostOrderId};\n+use super::{DropRangesBuilder, PostOrderId};\n use rustc_index::{bit_set::BitSet, vec::IndexVec};\n use std::collections::BTreeMap;\n-use std::mem::swap;\n \n-impl DropRanges {\n+impl DropRangesBuilder {\n     pub fn propagate_to_fixpoint(&mut self) {\n         trace!(\"before fixpoint: {:#?}\", self);\n-        self.process_deferred_edges();\n         let preds = self.compute_predecessors();\n \n         trace!(\"predecessors: {:#?}\", preds.iter_enumerated().collect::<BTreeMap<_, _>>());\n@@ -53,6 +51,11 @@ impl DropRanges {\n     fn compute_predecessors(&self) -> IndexVec<PostOrderId, Vec<PostOrderId>> {\n         let mut preds = IndexVec::from_fn_n(|_| vec![], self.nodes.len());\n         for (id, node) in self.nodes.iter_enumerated() {\n+            // If the node has no explicit successors, we assume that control\n+            // will from this node into the next one.\n+            //\n+            // If there are successors listed, then we assume that all\n+            // possible successors are given and we do not include the default.\n             if node.successors.len() == 0 && id.index() != self.nodes.len() - 1 {\n                 preds[id + 1].push(id);\n             } else {\n@@ -63,18 +66,4 @@ impl DropRanges {\n         }\n         preds\n     }\n-\n-    /// Looks up PostOrderId for any control edges added by HirId and adds a proper edge for them.\n-    ///\n-    /// Should be called after visiting the HIR but before solving the control flow, otherwise some\n-    /// edges will be missed.\n-    fn process_deferred_edges(&mut self) {\n-        let mut edges = vec![];\n-        swap(&mut edges, &mut self.deferred_edges);\n-        edges.into_iter().for_each(|(from, to)| {\n-            let to = *self.post_order_map.get(&to).expect(\"Expression ID not found\");\n-            trace!(\"Adding deferred edge from {} to {}\", from, to);\n-            self.add_control_edge(from, to)\n-        });\n-    }\n }"}, {"sha": "b87b3dd9a5f967c008d73036f0ff7c958a9bab93", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_visualize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2af02cf2c4061f517d5fc81591c9ae6b53225d24/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af02cf2c4061f517d5fc81591c9ae6b53225d24/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs?ref=2af02cf2c4061f517d5fc81591c9ae6b53225d24", "patch": "@@ -3,9 +3,9 @@\n \n use rustc_graphviz as dot;\n \n-use super::{DropRanges, PostOrderId};\n+use super::{DropRangesBuilder, PostOrderId};\n \n-impl<'a> dot::GraphWalk<'a> for DropRanges {\n+impl<'a> dot::GraphWalk<'a> for DropRangesBuilder {\n     type Node = PostOrderId;\n \n     type Edge = (PostOrderId, PostOrderId);\n@@ -36,7 +36,7 @@ impl<'a> dot::GraphWalk<'a> for DropRanges {\n     }\n }\n \n-impl<'a> dot::Labeller<'a> for DropRanges {\n+impl<'a> dot::Labeller<'a> for DropRangesBuilder {\n     type Node = PostOrderId;\n \n     type Edge = (PostOrderId, PostOrderId);\n@@ -56,7 +56,7 @@ impl<'a> dot::Labeller<'a> for DropRanges {\n                 n,\n                 self.post_order_map\n                     .iter()\n-                    .find(|(_hir_id, &post_order_id)| post_order_id == n.index())\n+                    .find(|(_hir_id, &post_order_id)| post_order_id == *n)\n                     .map_or(\"<unknown>\".into(), |(hir_id, _)| format!(\n                         \"{}\",\n                         hir_id.local_id.index()"}]}