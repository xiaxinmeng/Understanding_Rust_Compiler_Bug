{"sha": "926892ddc0b75b50f5d0a3483d829e501aa8e895", "node_id": "C_kwDOAAsO6NoAKDkyNjg5MmRkYzBiNzViNTBmNWQwYTM0ODNkODI5ZTUwMWFhOGU4OTU", "commit": {"author": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2021-11-05T01:30:49Z"}, "committer": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2021-11-05T01:30:49Z"}, "message": "Add feature trigger and enable is_struct check", "tree": {"sha": "148ceb5b4d2372a04ee62f58972675fd2d5480aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/148ceb5b4d2372a04ee62f58972675fd2d5480aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/926892ddc0b75b50f5d0a3483d829e501aa8e895", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/926892ddc0b75b50f5d0a3483d829e501aa8e895", "html_url": "https://github.com/rust-lang/rust/commit/926892ddc0b75b50f5d0a3483d829e501aa8e895", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/926892ddc0b75b50f5d0a3483d829e501aa8e895/comments", "author": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ab2616b4da64218d359a87fdd043edf4167cf76", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ab2616b4da64218d359a87fdd043edf4167cf76", "html_url": "https://github.com/rust-lang/rust/commit/1ab2616b4da64218d359a87fdd043edf4167cf76"}], "stats": {"total": 200, "additions": 96, "deletions": 104}, "files": [{"sha": "ab53d64e9bfb5810588cb805fb096a7a517c3616", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 85, "deletions": 103, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/926892ddc0b75b50f5d0a3483d829e501aa8e895/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926892ddc0b75b50f5d0a3483d829e501aa8e895/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=926892ddc0b75b50f5d0a3483d829e501aa8e895", "patch": "@@ -36,7 +36,8 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::InferOk;\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n-use rustc_middle::ty::error::TypeError::FieldMisMatch;\n+use rustc_middle::ty::error::TypeError::{FieldMisMatch, Sorts};\n+use rustc_middle::ty::relate::expected_found_bool;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeFoldable;\n@@ -1375,124 +1376,105 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(base_expr) = base_expr {\n-            let expected = if self.tcx.features().type_changing_struct_update {\n-                NoExpectation\n-            } else {\n-                ExpectHasType(adt_ty)\n-            };\n-            let mut ty = self.check_expr_with_expectation(base_expr, expected);\n-\n-            let expected_ty = expected.to_option(&self).unwrap_or(adt_ty);\n-            // While we don't allow *arbitrary* coercions here, we *do* allow\n-            // coercions from ! to `expected`.\n-            if ty.is_never() {\n-                assert!(\n-                    !self.typeck_results.borrow().adjustments().contains_key(base_expr.hir_id),\n-                    \"expression with never type wound up being adjusted\"\n-                );\n-                let adj_ty = self.next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::AdjustmentType,\n-                    span: base_expr.span,\n-                });\n-                self.apply_adjustments(\n-                    base_expr,\n-                    vec![Adjustment { kind: Adjust::NeverToAny, target: adj_ty }],\n-                );\n-                ty = adj_ty;\n-            }\n-            let cause = self.misc(base_expr.span);\n-            let mut fru_tys = None;\n-            let mut err = None;\n-            let is_struct;\n-\n-            if let ty::Adt(adt, substs) = expected_ty.kind() {\n-                match ty.kind() {\n-                    ty::Adt(base_adt, base_subs) if adt == base_adt => {\n-                        if self.tcx.features().type_changing_struct_update {\n-                            let tys = variant\n-                                .fields\n-                                .iter()\n-                                .map(|f| {\n-                                    let fru_ty = self.normalize_associated_types_in(\n-                                        expr_span,\n-                                        self.field_ty(base_expr.span, f, base_subs),\n-                                    );\n-                                    let ident = self.tcx.adjust_ident(f.ident, variant.def_id);\n-                                    if let Some(_) = remaining_fields.remove(&ident) {\n-                                        let target_ty = self.field_ty(base_expr.span, f, substs);\n-                                        match self.at(&cause, self.param_env).sup(target_ty, fru_ty)\n-                                        {\n-                                            Ok(InferOk { obligations, value: () }) => {\n-                                                self.register_predicates(obligations)\n-                                            }\n-                                            // FIXME: Need better diagnostics for `FieldMisMatch` error\n-                                            Err(_) => {\n-                                                if err.is_none() {\n-                                                    err = Some(self.report_mismatched_types(\n+            // FIXME: We are currently creating two branches here in order to maintain\n+            // consistency. But they should be merged as much as possible.\n+            let fru_tys = if self.tcx.features().type_changing_struct_update {\n+                let base_ty = self.check_expr(base_expr);\n+                match adt_ty.kind() {\n+                    ty::Adt(adt, substs) if adt.is_struct() => {\n+                        match base_ty.kind() {\n+                            ty::Adt(base_adt, base_subs) if adt == base_adt => {\n+                                variant\n+                                    .fields\n+                                    .iter()\n+                                    .map(|f| {\n+                                        let fru_ty = self.normalize_associated_types_in(\n+                                            expr_span,\n+                                            self.field_ty(base_expr.span, f, base_subs),\n+                                        );\n+                                        let ident = self.tcx.adjust_ident(f.ident, variant.def_id);\n+                                        if let Some(_) = remaining_fields.remove(&ident) {\n+                                            let target_ty =\n+                                                self.field_ty(base_expr.span, f, substs);\n+                                            let cause = self.misc(base_expr.span);\n+                                            match self\n+                                                .at(&cause, self.param_env)\n+                                                .sup(target_ty, fru_ty)\n+                                            {\n+                                                Ok(InferOk { obligations, value: () }) => {\n+                                                    self.register_predicates(obligations)\n+                                                }\n+                                                // FIXME: Need better diagnostics for `FieldMisMatch` error\n+                                                Err(_) => self\n+                                                    .report_mismatched_types(\n                                                         &cause,\n                                                         target_ty,\n                                                         fru_ty,\n                                                         FieldMisMatch(\n                                                             variant.ident.name,\n                                                             ident.name,\n                                                         ),\n-                                                    ))\n-                                                }\n+                                                    )\n+                                                    .emit(),\n                                             }\n                                         }\n-                                    }\n-                                    fru_ty\n-                                })\n-                                .collect();\n-                            fru_tys = Some(tys);\n-                        } else {\n-                            err = self.demand_suptype_diag(base_expr.span, expected_ty, ty);\n-                            if err.is_some() && self.tcx.sess.is_nightly_build() {\n-                                feature_err(\n-                                    &self.tcx.sess.parse_sess,\n-                                    sym::type_changing_struct_update,\n-                                    base_expr.span,\n-                                    \"type changing struct updating is experimental\",\n-                                )\n-                                .emit();\n+                                        fru_ty\n+                                    })\n+                                    .collect()\n+                            }\n+                            _ => {\n+                                return self\n+                                    .report_mismatched_types(\n+                                        &self.misc(base_expr.span),\n+                                        adt_ty,\n+                                        base_ty,\n+                                        Sorts(expected_found_bool(true, adt_ty, base_ty)),\n+                                    )\n+                                    .emit();\n                             }\n                         }\n                     }\n                     _ => {\n-                        err = self.demand_suptype_diag(base_expr.span, expected_ty, ty);\n+                        return self\n+                            .tcx\n+                            .sess\n+                            .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n                     }\n                 }\n-                is_struct = adt.is_struct();\n-                if is_struct && fru_tys.is_none() {\n-                    fru_tys = Some(\n-                        variant\n-                            .fields\n-                            .iter()\n-                            .map(|f| {\n-                                self.normalize_associated_types_in(\n-                                    expr_span,\n-                                    f.ty(self.tcx, substs),\n-                                )\n-                            })\n-                            .collect(),\n-                    )\n-                }\n             } else {\n-                err = self.demand_suptype_diag(base_expr.span, expected_ty, ty);\n-                is_struct = false;\n-            }\n-            if let Some(mut err) = err {\n-                let expr = base_expr.peel_drop_temps();\n-                self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty, None);\n-                err.emit();\n-            }\n-            if let Some(fru_tys) = fru_tys {\n-                self.typeck_results.borrow_mut().fru_field_types_mut().insert(expr_id, fru_tys);\n-            }\n-            if !is_struct {\n-                let e = FunctionalRecordUpdateOnNonStruct { span: base_expr.span };\n-                self.tcx.sess.emit_err(e);\n-            }\n+                self.check_expr_has_type_or_error(base_expr, adt_ty, |_| {\n+                    let base_ty = self.check_expr(base_expr);\n+                    let same_adt = match (adt_ty.kind(), base_ty.kind()) {\n+                        (ty::Adt(adt, _), ty::Adt(base_adt, _)) if adt == base_adt => true,\n+                        _ => false,\n+                    };\n+                    if self.tcx.sess.is_nightly_build() && same_adt {\n+                        feature_err(\n+                            &self.tcx.sess.parse_sess,\n+                            sym::type_changing_struct_update,\n+                            base_expr.span,\n+                            \"type changing struct updating is experimental\",\n+                        )\n+                        .emit();\n+                    }\n+                });\n+                match adt_ty.kind() {\n+                    ty::Adt(adt, substs) if adt.is_struct() => variant\n+                        .fields\n+                        .iter()\n+                        .map(|f| {\n+                            self.normalize_associated_types_in(expr_span, f.ty(self.tcx, substs))\n+                        })\n+                        .collect(),\n+                    _ => {\n+                        return self\n+                            .tcx\n+                            .sess\n+                            .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n+                    }\n+                }\n+            };\n+            self.typeck_results.borrow_mut().fru_field_types_mut().insert(expr_id, fru_tys);\n         } else if kind_name != \"union\" && !remaining_fields.is_empty() {\n             let inaccessible_remaining_fields = remaining_fields.iter().any(|(_, (_, field))| {\n                 !field.vis.is_accessible_from(tcx.parent_module(expr_id).to_def_id(), tcx)"}, {"sha": "d8b1396a692a7c6b338357b1a12ee4df55363ef9", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/type-generic-update.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/926892ddc0b75b50f5d0a3483d829e501aa8e895/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926892ddc0b75b50f5d0a3483d829e501aa8e895/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.rs?ref=926892ddc0b75b50f5d0a3483d829e501aa8e895", "patch": "@@ -50,6 +50,7 @@ fn fail_update() {\n     let m3 = Machine::<i32, i32> {\n         ..m1\n         //~^ ERROR mismatched types [E0308]\n+        //~| ERROR mismatched types [E0308]\n     };\n }\n "}, {"sha": "fa8d6ee23d5ec86198e4976ee238b8518aa59b49", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/type-generic-update.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/926892ddc0b75b50f5d0a3483d829e501aa8e895/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/926892ddc0b75b50f5d0a3483d829e501aa8e895/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.stderr?ref=926892ddc0b75b50f5d0a3483d829e501aa8e895", "patch": "@@ -16,6 +16,15 @@ LL |         ..m1\n    = note: expected type `i32`\n               found type `f64`\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/type-generic-update.rs:51:11\n+   |\n+LL |         ..m1\n+   |           ^^ field type mismatch: Machine.message\n+   |\n+   = note: expected type `i32`\n+              found type `f64`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}