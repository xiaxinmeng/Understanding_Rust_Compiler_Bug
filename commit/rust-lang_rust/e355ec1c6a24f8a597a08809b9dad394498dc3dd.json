{"sha": "e355ec1c6a24f8a597a08809b9dad394498dc3dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNTVlYzFjNmEyNGY4YTU5N2EwODgwOWI5ZGFkMzk0NDk4ZGMzZGQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-08-24T21:06:31Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-09-01T13:43:44Z"}, "message": "incr.comp.: Add stable hashing of HIR spans to ICH.", "tree": {"sha": "8ac8b42b5e30e3e63bbbfdc76d15faa3fb3b1fe5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ac8b42b5e30e3e63bbbfdc76d15faa3fb3b1fe5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e355ec1c6a24f8a597a08809b9dad394498dc3dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e355ec1c6a24f8a597a08809b9dad394498dc3dd", "html_url": "https://github.com/rust-lang/rust/commit/e355ec1c6a24f8a597a08809b9dad394498dc3dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e355ec1c6a24f8a597a08809b9dad394498dc3dd/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e4f4810dcc7cc21aec13d421d211a94f29e413f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e4f4810dcc7cc21aec13d421d211a94f29e413f", "html_url": "https://github.com/rust-lang/rust/commit/8e4f4810dcc7cc21aec13d421d211a94f29e413f"}], "stats": {"total": 295, "additions": 226, "deletions": 69}, "files": [{"sha": "554a0e0a97cd300802fd1673062ae5bb1bee8f0a", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 158, "deletions": 49, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/e355ec1c6a24f8a597a08809b9dad394498dc3dd/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e355ec1c6a24f8a597a08809b9dad394498dc3dd/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=e355ec1c6a24f8a597a08809b9dad394498dc3dd", "patch": "@@ -17,24 +17,99 @@ use self::SawExprComponent::*;\n use self::SawAbiComponent::*;\n use syntax::ast::{self, Name, NodeId, Attribute};\n use syntax::parse::token;\n-use syntax_pos::Span;\n+use syntax::codemap::CodeMap;\n+use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos, FileMap};\n use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def::{Def, PathResolution};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n-\n+use std::rc::Rc;\n use std::hash::{Hash, SipHasher};\n \n use super::def_path_hash::DefPathHashes;\n \n+const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\"cfg\",\n+                                                      \"rustc_clean\",\n+                                                      \"rustc_dirty\"];\n+\n pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n     pub tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n     pub st: &'a mut SipHasher,\n     // collect a deterministic hash of def-ids that we have seen\n     def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n     hash_spans: bool,\n+    codemap: CachedCodemapView<'tcx>,\n+}\n+\n+struct CachedCodemapView<'tcx> {\n+    codemap: &'tcx CodeMap,\n+    // Format: (line number, line-start, line_end, file)\n+    line_cache: [(usize, BytePos, BytePos, Rc<FileMap>); 4],\n+    eviction_index: usize,\n+}\n+\n+impl<'tcx> CachedCodemapView<'tcx> {\n+    fn new<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CachedCodemapView<'tcx> {\n+        let codemap = tcx.sess.codemap();\n+        let first_file = codemap.files.borrow()[0].clone();\n+\n+        CachedCodemapView {\n+            codemap: codemap,\n+            line_cache: [(0, BytePos(0), BytePos(0), first_file.clone()),\n+                         (0, BytePos(0), BytePos(0), first_file.clone()),\n+                         (0, BytePos(0), BytePos(0), first_file.clone()),\n+                         (0, BytePos(0), BytePos(0), first_file.clone())],\n+            eviction_index: 0,\n+        }\n+    }\n+\n+    fn byte_pos_to_line_and_col(&mut self,\n+                                pos: BytePos)\n+                                -> (Rc<FileMap>, usize, BytePos) {\n+        // Check if the position is in one of the cached lines\n+        for &(line, start, end, ref file) in self.line_cache.iter() {\n+            if pos >= start && pos < end {\n+                return (file.clone(), line, pos - start);\n+            }\n+        }\n+\n+        // Check whether we have a cached line in the correct file, so we can\n+        // overwrite it without having to look up the file again.\n+        for &mut (ref mut line,\n+                  ref mut start,\n+                  ref mut end,\n+                  ref file) in self.line_cache.iter_mut() {\n+            if pos >= file.start_pos && pos < file.end_pos {\n+                let line_index = file.lookup_line(pos).unwrap();\n+                let (line_start, line_end) = file.line_bounds(line_index);\n+\n+                // Update the cache entry in place\n+                *line = line_index + 1;\n+                *start = line_start;\n+                *end = line_end;\n+\n+                return (file.clone(), line_index + 1, pos - line_start);\n+            }\n+        }\n+\n+        // No cache hit ...\n+        let file_index = self.codemap.lookup_filemap_idx(pos);\n+        let file = self.codemap.files.borrow()[file_index].clone();\n+        let line_index = file.lookup_line(pos).unwrap();\n+        let (line_start, line_end) = file.line_bounds(line_index);\n+\n+        // Just overwrite some cache entry. If we got this for, all of them\n+        // point to the wrong file.\n+        self.line_cache[self.eviction_index] = (line_index + 1,\n+                                                line_start,\n+                                                line_end,\n+                                                file.clone());\n+        self.eviction_index = (self.eviction_index + 1) % self.line_cache.len();\n+\n+        return (file, line_index + 1, pos - line_start);\n+    }\n }\n \n impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n@@ -48,17 +123,54 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             tcx: tcx,\n             def_path_hashes: def_path_hashes,\n             hash_spans: hash_spans,\n+            codemap: CachedCodemapView::new(tcx),\n         }\n     }\n \n     fn compute_def_id_hash(&mut self, def_id: DefId) -> u64 {\n         self.def_path_hashes.hash(def_id)\n     }\n \n-    #[inline]\n+    // Hash a span in a stable way. If we would just hash the spans BytePos\n+    // fields that would be similar hashing pointers since those or just offsets\n+    // into the CodeMap. Instead, we hash the (file name, line, column) triple,\n+    // which stays the same even if the containing FileMap has moved within the\n+    // CodeMap.\n+    // Also note that we are hashing byte offsets for the column, not unicode\n+    // codepoint offsets. For the purpose of the hash that's sufficient.\n     fn hash_span(&mut self, span: Span) {\n-        if self.hash_spans {\n-            let _ = span;\n+        debug_assert!(self.hash_spans);\n+        debug!(\"hash_span: st={:?}\", self.st);\n+\n+        // If this is not an empty or invalid span, we want to hash the last\n+        // position that belongs to it, as opposed to hashing the first\n+        // position past it.\n+        let span_hi = if span.hi > span.lo {\n+            // We might end up in the middle of a multibyte character here,\n+            // but that's OK, since we are not trying to decode anything at\n+            // this position.\n+            span.hi - BytePos(1)\n+        } else {\n+            span.hi\n+        };\n+\n+        let (file1, line1, col1) = self.codemap.byte_pos_to_line_and_col(span.lo);\n+        let (file2, line2, col2) = self.codemap.byte_pos_to_line_and_col(span_hi);\n+\n+        let expansion_kind = match span.expn_id {\n+            NO_EXPANSION => SawSpanExpnKind::NoExpansion,\n+            COMMAND_LINE_EXPN => SawSpanExpnKind::CommandLine,\n+            _ => SawSpanExpnKind::SomeExpansion,\n+        };\n+\n+        expansion_kind.hash(self.st);\n+\n+        SawSpan(&file1.name[..], line1, col1,\n+                &file2.name[..], line2, col2,\n+                expansion_kind).hash(self.st);\n+\n+        if expansion_kind == SawSpanExpnKind::SomeExpansion {\n+            self.hash_span(self.codemap.codemap.source_callsite(span));\n         }\n     }\n \n@@ -126,6 +238,7 @@ enum SawAbiComponent<'a> {\n     SawAssocTypeBinding,\n     SawAttribute(ast::AttrStyle, bool),\n     SawMacroDef,\n+    SawSpan(&'a str, usize, BytePos, &'a str, usize, BytePos, SawSpanExpnKind),\n }\n \n /// SawExprComponent carries all of the information that we want\n@@ -211,6 +324,13 @@ fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n     }\n }\n \n+#[derive(Clone, Copy, Hash, Eq, PartialEq)]\n+enum SawSpanExpnKind {\n+    NoExpansion,\n+    CommandLine,\n+    SomeExpansion,\n+}\n+\n macro_rules! hash_attrs {\n     ($visitor:expr, $attrs:expr) => ({\n         let attrs = $attrs;\n@@ -220,6 +340,14 @@ macro_rules! hash_attrs {\n     })\n }\n \n+macro_rules! hash_span {\n+    ($visitor:expr, $span:expr) => ({\n+        if $visitor.hash_spans {\n+            $visitor.hash_span($span);\n+        }\n+    })\n+}\n+\n impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     fn visit_nested_item(&mut self, _: ItemId) {\n         // Each item is hashed independently; ignore nested items.\n@@ -233,7 +361,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n                           span: Span) {\n         debug!(\"visit_variant_data: st={:?}\", self.st);\n         SawStructDef(name.as_str()).hash(self.st);\n-        self.hash_span(span);\n+        hash_span!(self, span);\n         visit::walk_struct_def(self, s);\n     }\n \n@@ -247,24 +375,10 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         visit::walk_variant(self, v, g, item_id)\n     }\n \n-    // All of the remaining methods just record (in the hash\n-    // SipHasher) that the visitor saw that particular variant\n-    // (with its payload), and continue walking as the default\n-    // visitor would.\n-    //\n-    // Some of the implementations have some notes as to how one\n-    // might try to make their SVH computation less discerning\n-    // (e.g. by incorporating reachability analysis).  But\n-    // currently all of their implementations are uniform and\n-    // uninteresting.\n-    //\n-    // (If you edit a method such that it deviates from the\n-    // pattern, please move that method up above this comment.)\n-\n     fn visit_name(&mut self, span: Span, name: Name) {\n         debug!(\"visit_name: st={:?}\", self.st);\n         SawIdent(name.as_str()).hash(self.st);\n-        self.hash_span(span);\n+        hash_span!(self, span);\n     }\n \n     fn visit_lifetime(&mut self, l: &'tcx Lifetime) {\n@@ -279,17 +393,12 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         visit::walk_lifetime_def(self, l);\n     }\n \n-    // We do recursively walk the bodies of functions/methods\n-    // (rather than omitting their bodies from the hash) since\n-    // monomorphization and cross-crate inlining generally implies\n-    // that a change to a crate body will require downstream\n-    // crates to be recompiled.\n     fn visit_expr(&mut self, ex: &'tcx Expr) {\n         debug!(\"visit_expr: st={:?}\", self.st);\n         SawExpr(saw_expr(&ex.node)).hash(self.st);\n         // No need to explicitly hash the discriminant here, since we are\n         // implicitly hashing the discriminant of SawExprComponent.\n-        self.hash_span(ex.span);\n+        hash_span!(self, ex.span);\n         hash_attrs!(self, &ex.attrs);\n         visit::walk_expr(self, ex)\n     }\n@@ -308,12 +417,12 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n             StmtExpr(..) => {\n                 SawStmt.hash(self.st);\n                 self.hash_discriminant(&s.node);\n-                self.hash_span(s.span);\n+                hash_span!(self, s.span);\n             }\n             StmtSemi(..) => {\n                 SawStmt.hash(self.st);\n                 self.hash_discriminant(&s.node);\n-                self.hash_span(s.span);\n+                hash_span!(self, s.span);\n             }\n         }\n \n@@ -323,12 +432,8 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n     fn visit_foreign_item(&mut self, i: &'tcx ForeignItem) {\n         debug!(\"visit_foreign_item: st={:?}\", self.st);\n \n-        // FIXME (#14132) ideally we would incorporate privacy (or\n-        // perhaps reachability) somewhere here, so foreign items\n-        // that do not leak into downstream crates would not be\n-        // part of the ABI.\n         SawForeignItem.hash(self.st);\n-        self.hash_span(i.span);\n+        hash_span!(self, i.span);\n         hash_attrs!(self, &i.attrs);\n         visit::walk_foreign_item(self, i)\n     }\n@@ -339,7 +444,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         SawItem.hash(self.st);\n         // Hash the value of the discriminant of the Item variant.\n         self.hash_discriminant(&i.node);\n-        self.hash_span(i.span);\n+        hash_span!(self, i.span);\n         hash_attrs!(self, &i.attrs);\n         visit::walk_item(self, i)\n     }\n@@ -352,7 +457,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n     fn visit_ty(&mut self, t: &'tcx Ty) {\n         debug!(\"visit_ty: st={:?}\", self.st);\n         SawTy.hash(self.st);\n-        self.hash_span(t.span);\n+        hash_span!(self, t.span);\n         visit::walk_ty(self, t)\n     }\n \n@@ -367,7 +472,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         debug!(\"visit_trait_item: st={:?}\", self.st);\n         SawTraitItem.hash(self.st);\n         self.hash_discriminant(&ti.node);\n-        self.hash_span(ti.span);\n+        hash_span!(self, ti.span);\n         hash_attrs!(self, &ti.attrs);\n         visit::walk_trait_item(self, ti)\n     }\n@@ -376,38 +481,38 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         debug!(\"visit_impl_item: st={:?}\", self.st);\n         SawImplItem.hash(self.st);\n         self.hash_discriminant(&ii.node);\n-        self.hash_span(ii.span);\n+        hash_span!(self, ii.span);\n         hash_attrs!(self, &ii.attrs);\n         visit::walk_impl_item(self, ii)\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx StructField) {\n         debug!(\"visit_struct_field: st={:?}\", self.st);\n         SawStructField.hash(self.st);\n-        self.hash_span(s.span);\n+        hash_span!(self, s.span);\n         hash_attrs!(self, &s.attrs);\n         visit::walk_struct_field(self, s)\n     }\n \n     fn visit_path(&mut self, path: &'tcx Path, _: ast::NodeId) {\n         debug!(\"visit_path: st={:?}\", self.st);\n         SawPath(path.global).hash(self.st);\n-        self.hash_span(path.span);\n+        hash_span!(self, path.span);\n         visit::walk_path(self, path)\n     }\n \n     fn visit_block(&mut self, b: &'tcx Block) {\n         debug!(\"visit_block: st={:?}\", self.st);\n         SawBlock.hash(self.st);\n-        self.hash_span(b.span);\n+        hash_span!(self, b.span);\n         visit::walk_block(self, b)\n     }\n \n     fn visit_pat(&mut self, p: &'tcx Pat) {\n         debug!(\"visit_pat: st={:?}\", self.st);\n         SawPat.hash(self.st);\n         self.hash_discriminant(&p.node);\n-        self.hash_span(p.span);\n+        hash_span!(self, p.span);\n         visit::walk_pat(self, p)\n     }\n \n@@ -466,7 +571,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         debug!(\"visit_path_list_item: st={:?}\", self.st);\n         SawPathListItem.hash(self.st);\n         self.hash_discriminant(&item.node);\n-        self.hash_span(item.span);\n+        hash_span!(self, item.span);\n         visit::walk_path_list_item(self, prefix, item)\n     }\n \n@@ -486,7 +591,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n     fn visit_assoc_type_binding(&mut self, type_binding: &'tcx TypeBinding) {\n         debug!(\"visit_assoc_type_binding: st={:?}\", self.st);\n         SawAssocTypeBinding.hash(self.st);\n-        self.hash_span(type_binding.span);\n+        hash_span!(self, type_binding.span);\n         visit::walk_assoc_type_binding(self, type_binding)\n     }\n \n@@ -602,21 +707,21 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     }\n \n     fn hash_meta_item(&mut self, meta_item: &ast::MetaItem) {\n+        debug!(\"hash_meta_item: st={:?}\", self.st);\n+\n         // ignoring span information, it doesn't matter here\n+        self.hash_discriminant(&meta_item.node);\n         match meta_item.node {\n             ast::MetaItemKind::Word(ref s) => {\n-                \"Word\".hash(self.st);\n                 s.len().hash(self.st);\n                 s.hash(self.st);\n             }\n             ast::MetaItemKind::NameValue(ref s, ref lit) => {\n-                \"NameValue\".hash(self.st);\n                 s.len().hash(self.st);\n                 s.hash(self.st);\n                 lit.node.hash(self.st);\n             }\n             ast::MetaItemKind::List(ref s, ref items) => {\n-                \"List\".hash(self.st);\n                 s.len().hash(self.st);\n                 s.hash(self.st);\n                 // Sort subitems so the hash does not depend on their order\n@@ -633,14 +738,18 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     }\n \n     pub fn hash_attributes(&mut self, attributes: &[Attribute]) {\n+        debug!(\"hash_attributes: st={:?}\", self.st);\n         let indices = self.indices_sorted_by(attributes, |attr| {\n             meta_item_sort_key(&attr.node.value)\n         });\n \n         for i in indices {\n             let attr = &attributes[i].node;\n-            SawAttribute(attr.style, attr.is_sugared_doc).hash(self.st);\n-            self.hash_meta_item(&*attr.value);\n+\n+            if !IGNORED_ATTRIBUTES.contains(&&*meta_item_sort_key(&attr.value)) {\n+                SawAttribute(attr.style, attr.is_sugared_doc).hash(self.st);\n+                self.hash_meta_item(&*attr.value);\n+            }\n         }\n     }\n "}, {"sha": "cd6f2874954b8656224fed5f55ad6f0ff423ed9f", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e355ec1c6a24f8a597a08809b9dad394498dc3dd/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e355ec1c6a24f8a597a08809b9dad394498dc3dd/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=e355ec1c6a24f8a597a08809b9dad394498dc3dd", "patch": "@@ -348,26 +348,10 @@ impl CodeMap {\n         let files = self.files.borrow();\n         let f = (*files)[idx].clone();\n \n-        let len = f.lines.borrow().len();\n-        if len == 0 {\n-            return Err(f);\n+        match f.lookup_line(pos) {\n+            Some(line) => Ok(FileMapAndLine { fm: f, line: line }),\n+            None => Err(f)\n         }\n-\n-        let mut a = 0;\n-        {\n-            let lines = f.lines.borrow();\n-            let mut b = lines.len();\n-            while b - a > 1 {\n-                let m = (a + b) / 2;\n-                if (*lines)[m] > pos {\n-                    b = m;\n-                } else {\n-                    a = m;\n-                }\n-            }\n-            assert!(a <= lines.len());\n-        }\n-        Ok(FileMapAndLine { fm: f, line: a })\n     }\n \n     pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n@@ -691,7 +675,7 @@ impl CodeMap {\n     }\n \n     // Return the index of the filemap (in self.files) which contains pos.\n-    fn lookup_filemap_idx(&self, pos: BytePos) -> usize {\n+    pub fn lookup_filemap_idx(&self, pos: BytePos) -> usize {\n         let files = self.files.borrow();\n         let files = &*files;\n         let count = files.len();"}, {"sha": "d835f8058fa0e70e8a511242d6b09f3d6c6653c9", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e355ec1c6a24f8a597a08809b9dad394498dc3dd/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e355ec1c6a24f8a597a08809b9dad394498dc3dd/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=e355ec1c6a24f8a597a08809b9dad394498dc3dd", "patch": "@@ -507,6 +507,39 @@ impl FileMap {\n     pub fn count_lines(&self) -> usize {\n         self.lines.borrow().len()\n     }\n+\n+    /// Find the line containing the given position. The return value is the\n+    /// index into the `lines` array of this FileMap, not the 1-based line\n+    /// number. If the filemap is empty or the position is located before the\n+    /// first line, None is returned.\n+    pub fn lookup_line(&self, pos: BytePos) -> Option<usize> {\n+        let lines = self.lines.borrow();\n+        if lines.len() == 0 {\n+            return None;\n+        }\n+\n+        let line_index = lookup_line(&lines[..], pos);\n+        assert!(line_index < lines.len() as isize);\n+        if line_index >= 0 {\n+            Some(line_index as usize)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn line_bounds(&self, line_index: usize) -> (BytePos, BytePos) {\n+        if self.start_pos == self.end_pos {\n+            return (self.start_pos, self.end_pos);\n+        }\n+\n+        let lines = self.lines.borrow();\n+        assert!(line_index < lines.len());\n+        if line_index == (lines.len() - 1) {\n+            (lines[line_index], self.end_pos)\n+        } else {\n+            (lines[line_index], lines[line_index + 1])\n+        }\n+    }\n }\n \n // _____________________________________________________________________________\n@@ -688,3 +721,34 @@ pub struct MalformedCodemapPositions {\n     pub end_pos: BytePos\n }\n \n+// Given a slice of line start positions and a position, returns the index of\n+// the line the position is on. Returns -1 if the position is located before\n+// the first line.\n+fn lookup_line(lines: &[BytePos], pos: BytePos) -> isize {\n+    match lines.binary_search(&pos) {\n+        Ok(line) => line as isize,\n+        Err(line) => line as isize - 1\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{lookup_line, BytePos};\n+\n+    #[test]\n+    fn test_lookup_line() {\n+\n+        let lines = &[BytePos(3), BytePos(17), BytePos(28)];\n+\n+        assert_eq!(lookup_line(lines, BytePos(0)), -1);\n+        assert_eq!(lookup_line(lines, BytePos(3)),  0);\n+        assert_eq!(lookup_line(lines, BytePos(4)),  0);\n+\n+        assert_eq!(lookup_line(lines, BytePos(16)), 0);\n+        assert_eq!(lookup_line(lines, BytePos(17)), 1);\n+        assert_eq!(lookup_line(lines, BytePos(18)), 1);\n+\n+        assert_eq!(lookup_line(lines, BytePos(28)), 2);\n+        assert_eq!(lookup_line(lines, BytePos(29)), 2);\n+    }\n+}"}]}