{"sha": "d161cc20718138ab7846b51303c0dc0db0172a8b", "node_id": "C_kwDOAAsO6NoAKGQxNjFjYzIwNzE4MTM4YWI3ODQ2YjUxMzAzYzBkYzBkYjAxNzJhOGI", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2021-10-25T14:04:15Z"}, "committer": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2021-11-29T13:19:48Z"}, "message": "Replace `ConstnessAnd<TraitRef>` with `TraitPredicate` which conveys the same information", "tree": {"sha": "55818aaa4b75b69e6f4af6aca881509d95e21b24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55818aaa4b75b69e6f4af6aca881509d95e21b24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d161cc20718138ab7846b51303c0dc0db0172a8b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE3RQPHNISvvEnSKtjbQF6ltjmwvkFAmGk03UACgkQbQF6ltjm\nwvnUFA/7BO6LZ6ICkEm9LSIvDNJ/dBwcnNQvjunEQlk9tW0lm4QpwD7H2W6HgQxR\n2B4b0oETk/sVbEkRRokan5BjlcvyhRJgpEMSa3Q3zIb2NR0VripI1jh98cRcctLi\ngau9LOxAlpmVwTWppkH82/FDsVEExIo4o/mw7x9679padfWuEDZ0OhLt7Cl84ZgQ\nCyHSvPSJdX2XtyRfssccSFTo53GR7ycOUiuAAYACuSJz5DoLOLqkljViP/DTqp02\nPZZBhkEccyZ+Xxe1XCib/Vb4FIa4yJp50VGuYB9fqo+gJfR0i7EZo2ADSxlIR7c1\nVfI3LnODOtxB2u5Hv0sKjBNlNHUjjTHnymQwg5HcKjgOc5on5nbyuU9czvg13KQ9\n7T0ga+a4/wylB2nwoDXax/ukK5d4R69MIUvUKHOMSFFWOUd5nDipb5uTX+kwVaLq\n/M+K6vCiTG7tYHP/B4w61WKQkBbhhbRGx/IAH5T8g16HlVTei0VtvRLYokWgHlDE\nv+x/+ekn+n4fYwElN6VHmRVwOr9fhA1AfExTPZ1pUmivDPm5KBa7ZMahqF770otg\nCnbCA0+BOfzbaiS8NHd2zkXLsXRbZkdZD9AOPMJaLl2/pjxi935nBefNjV30OBTM\nhsnJWnlf3Df47M4J2DkyIzm+IJ2p/tXrrlw024zH/KosMZi84SY=\n=hc1y\n-----END PGP SIGNATURE-----", "payload": "tree 55818aaa4b75b69e6f4af6aca881509d95e21b24\nparent b16c811f1cbaf4d2e7e61409a0bd39aef5a6b1b4\nauthor Oli Scherer <git-spam-no-reply9815368754983@oli-obk.de> 1635170655 +0000\ncommitter Deadbeef <ent3rm4n@gmail.com> 1638191988 +0800\n\nReplace `ConstnessAnd<TraitRef>` with `TraitPredicate` which conveys the same information\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d161cc20718138ab7846b51303c0dc0db0172a8b", "html_url": "https://github.com/rust-lang/rust/commit/d161cc20718138ab7846b51303c0dc0db0172a8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d161cc20718138ab7846b51303c0dc0db0172a8b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b16c811f1cbaf4d2e7e61409a0bd39aef5a6b1b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b16c811f1cbaf4d2e7e61409a0bd39aef5a6b1b4", "html_url": "https://github.com/rust-lang/rust/commit/b16c811f1cbaf4d2e7e61409a0bd39aef5a6b1b4"}], "stats": {"total": 115, "additions": 46, "deletions": 69}, "files": [{"sha": "ff711bff86f6127279ff800d7fd670268023111a", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d161cc20718138ab7846b51303c0dc0db0172a8b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d161cc20718138ab7846b51303c0dc0db0172a8b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=d161cc20718138ab7846b51303c0dc0db0172a8b", "patch": "@@ -16,10 +16,8 @@ pub type SelectionCache<'tcx> = Cache<\n     SelectionResult<'tcx, SelectionCandidate<'tcx>>,\n >;\n \n-pub type EvaluationCache<'tcx> = Cache<\n-    (ty::ParamEnvAnd<'tcx, ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>>, ty::ImplPolarity),\n-    EvaluationResult,\n->;\n+pub type EvaluationCache<'tcx> =\n+    Cache<ty::ParamEnvAnd<'tcx, ty::PolyTraitPredicate<'tcx>>, EvaluationResult>;\n \n /// The selection process begins by considering all impls, where\n /// clauses, and so forth that might resolve an obligation. Sometimes"}, {"sha": "55fd38ac261dd12e4f362f88431bc6cb2189f4b2", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 44, "deletions": 65, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/d161cc20718138ab7846b51303c0dc0db0172a8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d161cc20718138ab7846b51303c0dc0db0172a8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d161cc20718138ab7846b51303c0dc0db0172a8b", "patch": "@@ -39,7 +39,6 @@ use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n-use rustc_middle::ty::WithConstness;\n use rustc_middle::ty::{self, PolyProjectionPredicate, ToPolyTraitRef, ToPredicate};\n use rustc_middle::ty::{Ty, TyCtxt, TypeFoldable};\n use rustc_span::symbol::sym;\n@@ -138,9 +137,9 @@ pub struct SelectionContext<'cx, 'tcx> {\n struct TraitObligationStack<'prev, 'tcx> {\n     obligation: &'prev TraitObligation<'tcx>,\n \n-    /// The trait ref from `obligation` but \"freshened\" with the\n+    /// The trait predicate from `obligation` but \"freshened\" with the\n     /// selection-context's freshener. Used to check for recursion.\n-    fresh_trait_ref: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n+    fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n \n     /// Starts out equal to `depth` -- if, during evaluation, we\n     /// encounter a cycle, then we will set this flag to the minimum\n@@ -676,20 +675,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         let stack = self.push_stack(previous_stack, &obligation);\n-        let fresh_trait_ref = stack.fresh_trait_ref;\n+        let fresh_trait_pred = stack.fresh_trait_pred;\n \n-        debug!(?fresh_trait_ref);\n+        debug!(?fresh_trait_pred);\n \n-        if let Some(result) = self.check_evaluation_cache(\n-            obligation.param_env,\n-            fresh_trait_ref,\n-            obligation.polarity(),\n-        ) {\n+        if let Some(result) = self.check_evaluation_cache(obligation.param_env, fresh_trait_pred) {\n             debug!(?result, \"CACHE HIT\");\n             return Ok(result);\n         }\n \n-        if let Some(result) = stack.cache().get_provisional(fresh_trait_ref) {\n+        if let Some(result) = stack.cache().get_provisional(fresh_trait_pred) {\n             debug!(?result, \"PROVISIONAL CACHE HIT\");\n             stack.update_reached_depth(result.reached_depth);\n             return Ok(result.result);\n@@ -714,19 +709,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let reached_depth = stack.reached_depth.get();\n         if reached_depth >= stack.depth {\n             debug!(?result, \"CACHE MISS\");\n-            self.insert_evaluation_cache(\n-                obligation.param_env,\n-                fresh_trait_ref,\n-                obligation.polarity(),\n-                dep_node,\n-                result,\n-            );\n+            self.insert_evaluation_cache(obligation.param_env, fresh_trait_pred, dep_node, result);\n \n-            stack.cache().on_completion(stack.dfn, |fresh_trait_ref, provisional_result| {\n+            stack.cache().on_completion(stack.dfn, |fresh_trait_pred, provisional_result| {\n                 self.insert_evaluation_cache(\n                     obligation.param_env,\n-                    fresh_trait_ref,\n-                    obligation.polarity(),\n+                    fresh_trait_pred,\n                     dep_node,\n                     provisional_result.max(result),\n                 );\n@@ -736,10 +724,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             debug!(\n                 \"caching provisionally because {:?} \\\n                  is a cycle participant (at depth {}, reached depth {})\",\n-                fresh_trait_ref, stack.depth, reached_depth,\n+                fresh_trait_pred, stack.depth, reached_depth,\n             );\n \n-            stack.cache().insert_provisional(stack.dfn, reached_depth, fresh_trait_ref, result);\n+            stack.cache().insert_provisional(stack.dfn, reached_depth, fresh_trait_pred, result);\n         }\n \n         Ok(result)\n@@ -773,7 +761,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .skip(1) // Skip top-most frame.\n             .find(|prev| {\n                 stack.obligation.param_env == prev.obligation.param_env\n-                    && stack.fresh_trait_ref == prev.fresh_trait_ref\n+                    && stack.fresh_trait_pred == prev.fresh_trait_pred\n             })\n             .map(|stack| stack.depth)\n         {\n@@ -836,7 +824,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n         let unbound_input_types =\n-            stack.fresh_trait_ref.value.skip_binder().substs.types().any(|ty| ty.is_fresh());\n+            stack.fresh_trait_pred.skip_binder().trait_ref.substs.types().any(|ty| ty.is_fresh());\n \n         if stack.obligation.polarity() != ty::ImplPolarity::Negative {\n             // This check was an imperfect workaround for a bug in the old\n@@ -874,8 +862,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             && stack.iter().skip(1).any(|prev| {\n                 stack.obligation.param_env == prev.obligation.param_env\n                     && self.match_fresh_trait_refs(\n-                        stack.fresh_trait_ref,\n-                        prev.fresh_trait_ref,\n+                        stack.fresh_trait_pred,\n+                        prev.fresh_trait_pred,\n                         prev.obligation.param_env,\n                     )\n             })\n@@ -953,7 +941,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // not just the lifetime choice for this particular (non-erased)\n         // predicate.\n         // See issue #80691\n-        if stack.fresh_trait_ref.has_erased_regions() {\n+        if stack.fresh_trait_pred.has_erased_regions() {\n             result = result.max(EvaluatedToOkModuloRegions);\n         }\n \n@@ -964,8 +952,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn check_evaluation_cache(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n-        polarity: ty::ImplPolarity,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> Option<EvaluationResult> {\n         // Neither the global nor local cache is aware of intercrate\n         // mode, so don't do any caching. In particular, we might\n@@ -977,19 +964,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let tcx = self.tcx();\n         if self.can_use_global_caches(param_env) {\n-            if let Some(res) = tcx.evaluation_cache.get(&(param_env.and(trait_ref), polarity), tcx)\n-            {\n+            if let Some(res) = tcx.evaluation_cache.get(&param_env.and(trait_pred), tcx) {\n                 return Some(res);\n             }\n         }\n-        self.infcx.evaluation_cache.get(&(param_env.and(trait_ref), polarity), tcx)\n+        self.infcx.evaluation_cache.get(&param_env.and(trait_pred), tcx)\n     }\n \n     fn insert_evaluation_cache(\n         &mut self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n-        polarity: ty::ImplPolarity,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n         dep_node: DepNodeIndex,\n         result: EvaluationResult,\n     ) {\n@@ -1008,23 +993,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         if self.can_use_global_caches(param_env) {\n-            if !trait_ref.needs_infer() {\n-                debug!(?trait_ref, ?result, \"insert_evaluation_cache global\");\n+            if !trait_pred.needs_infer() {\n+                debug!(?trait_pred, ?result, \"insert_evaluation_cache global\");\n                 // This may overwrite the cache with the same value\n                 // FIXME: Due to #50507 this overwrites the different values\n                 // This should be changed to use HashMapExt::insert_same\n                 // when that is fixed\n-                self.tcx().evaluation_cache.insert(\n-                    (param_env.and(trait_ref), polarity),\n-                    dep_node,\n-                    result,\n-                );\n+                self.tcx().evaluation_cache.insert(param_env.and(trait_pred), dep_node, result);\n                 return;\n             }\n         }\n \n-        debug!(?trait_ref, ?result, \"insert_evaluation_cache\");\n-        self.infcx.evaluation_cache.insert((param_env.and(trait_ref), polarity), dep_node, result);\n+        debug!(?trait_pred, ?result, \"insert_evaluation_cache\");\n+        self.infcx.evaluation_cache.insert(param_env.and(trait_pred), dep_node, result);\n     }\n \n     /// For various reasons, it's possible for a subobligation\n@@ -2154,8 +2135,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_fresh_trait_refs(\n         &self,\n-        previous: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n-        current: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n+        previous: ty::PolyTraitPredicate<'tcx>,\n+        current: ty::PolyTraitPredicate<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n         let mut matcher = ty::_match::Match::new(self.tcx(), param_env);\n@@ -2167,18 +2148,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n         obligation: &'o TraitObligation<'tcx>,\n     ) -> TraitObligationStack<'o, 'tcx> {\n-        let fresh_trait_ref = obligation\n+        let fresh_trait_pred = obligation\n             .predicate\n-            .to_poly_trait_ref()\n             .fold_with(&mut self.freshener)\n-            .into_ok()\n-            .with_constness(obligation.predicate.skip_binder().constness);\n+            .into_ok();\n \n         let dfn = previous_stack.cache.next_dfn();\n         let depth = previous_stack.depth() + 1;\n         TraitObligationStack {\n             obligation,\n-            fresh_trait_ref,\n+            fresh_trait_pred,\n             reached_depth: Cell::new(depth),\n             previous: previous_stack,\n             dfn,\n@@ -2372,7 +2351,7 @@ impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n         debug!(reached_depth, \"update_reached_depth\");\n         let mut p = self;\n         while reached_depth < p.depth {\n-            debug!(?p.fresh_trait_ref, \"update_reached_depth: marking as cycle participant\");\n+            debug!(?p.fresh_trait_pred, \"update_reached_depth: marking as cycle participant\");\n             p.reached_depth.set(p.reached_depth.get().min(reached_depth));\n             p = p.previous.head.unwrap();\n         }\n@@ -2451,7 +2430,7 @@ struct ProvisionalEvaluationCache<'tcx> {\n     /// - then we determine that `E` is in error -- we will then clear\n     ///   all cache values whose DFN is >= 4 -- in this case, that\n     ///   means the cached value for `F`.\n-    map: RefCell<FxHashMap<ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>, ProvisionalEvaluation>>,\n+    map: RefCell<FxHashMap<ty::PolyTraitPredicate<'tcx>, ProvisionalEvaluation>>,\n }\n \n /// A cache value for the provisional cache: contains the depth-first\n@@ -2483,28 +2462,28 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n     /// `reached_depth` (from the returned value).\n     fn get_provisional(\n         &self,\n-        fresh_trait_ref: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n+        fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> Option<ProvisionalEvaluation> {\n         debug!(\n-            ?fresh_trait_ref,\n+            ?fresh_trait_pred,\n             \"get_provisional = {:#?}\",\n-            self.map.borrow().get(&fresh_trait_ref),\n+            self.map.borrow().get(&fresh_trait_pred),\n         );\n-        Some(*self.map.borrow().get(&fresh_trait_ref)?)\n+        Some(*self.map.borrow().get(&fresh_trait_pred)?)\n     }\n \n     /// Insert a provisional result into the cache. The result came\n     /// from the node with the given DFN. It accessed a minimum depth\n-    /// of `reached_depth` to compute. It evaluated `fresh_trait_ref`\n+    /// of `reached_depth` to compute. It evaluated `fresh_trait_pred`\n     /// and resulted in `result`.\n     fn insert_provisional(\n         &self,\n         from_dfn: usize,\n         reached_depth: usize,\n-        fresh_trait_ref: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n+        fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n         result: EvaluationResult,\n     ) {\n-        debug!(?from_dfn, ?fresh_trait_ref, ?result, \"insert_provisional\");\n+        debug!(?from_dfn, ?fresh_trait_pred, ?result, \"insert_provisional\");\n \n         let mut map = self.map.borrow_mut();\n \n@@ -2528,7 +2507,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n             }\n         }\n \n-        map.insert(fresh_trait_ref, ProvisionalEvaluation { from_dfn, reached_depth, result });\n+        map.insert(fresh_trait_pred, ProvisionalEvaluation { from_dfn, reached_depth, result });\n     }\n \n     /// Invoked when the node with dfn `dfn` does not get a successful\n@@ -2579,16 +2558,16 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n     fn on_completion(\n         &self,\n         dfn: usize,\n-        mut op: impl FnMut(ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>, EvaluationResult),\n+        mut op: impl FnMut(ty::PolyTraitPredicate<'tcx>, EvaluationResult),\n     ) {\n         debug!(?dfn, \"on_completion\");\n \n-        for (fresh_trait_ref, eval) in\n+        for (fresh_trait_pred, eval) in\n             self.map.borrow_mut().drain_filter(|_k, eval| eval.from_dfn >= dfn)\n         {\n-            debug!(?fresh_trait_ref, ?eval, \"on_completion\");\n+            debug!(?fresh_trait_pred, ?eval, \"on_completion\");\n \n-            op(fresh_trait_ref, eval.result);\n+            op(fresh_trait_pred, eval.result);\n         }\n     }\n }"}]}