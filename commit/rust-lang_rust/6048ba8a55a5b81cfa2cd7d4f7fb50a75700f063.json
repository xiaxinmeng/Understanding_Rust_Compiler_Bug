{"sha": "6048ba8a55a5b81cfa2cd7d4f7fb50a75700f063", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNDhiYThhNTVhNWI4MWNmYTJjZDdkNGY3ZmI1MGE3NTcwMGYwNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-10T20:20:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-10T20:20:15Z"}, "message": "Auto merge of #23249 - tbu-:pr_rm_core_str_macros, r=alexcrichton", "tree": {"sha": "021b0048d7016edd05f0c3d53b6d5c3a359747db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/021b0048d7016edd05f0c3d53b6d5c3a359747db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6048ba8a55a5b81cfa2cd7d4f7fb50a75700f063", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6048ba8a55a5b81cfa2cd7d4f7fb50a75700f063", "html_url": "https://github.com/rust-lang/rust/commit/6048ba8a55a5b81cfa2cd7d4f7fb50a75700f063", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6048ba8a55a5b81cfa2cd7d4f7fb50a75700f063/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d193233230453be80d38b05f8a04b7b561aec35a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d193233230453be80d38b05f8a04b7b561aec35a", "html_url": "https://github.com/rust-lang/rust/commit/d193233230453be80d38b05f8a04b7b561aec35a"}, {"sha": "fb297d102756f352d429cd7a9b262d02254ced6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb297d102756f352d429cd7a9b262d02254ced6d", "html_url": "https://github.com/rust-lang/rust/commit/fb297d102756f352d429cd7a9b262d02254ced6d"}], "stats": {"total": 81, "additions": 40, "deletions": 41}, "files": [{"sha": "4e8a56fbefb2581970bb4ee0f2216fe1f0b69b1a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6048ba8a55a5b81cfa2cd7d4f7fb50a75700f063/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6048ba8a55a5b81cfa2cd7d4f7fb50a75700f063/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=6048ba8a55a5b81cfa2cd7d4f7fb50a75700f063", "patch": "@@ -335,21 +335,20 @@ pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n }\n \n-// Return the initial codepoint accumulator for the first byte.\n-// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n-// for width 3, and 3 bits for width 4\n-macro_rules! utf8_first_byte {\n-    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n-}\n+/// Return the initial codepoint accumulator for the first byte.\n+/// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+/// for width 3, and 3 bits for width 4.\n+#[inline]\n+fn utf8_first_byte(byte: u8, width: u32) -> u32 { (byte & (0x7F >> width)) as u32 }\n \n-// return the value of $ch updated with continuation byte $byte\n-macro_rules! utf8_acc_cont_byte {\n-    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & CONT_MASK) as u32)\n-}\n+/// Return the value of `ch` updated with continuation byte `byte`.\n+#[inline]\n+fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 { (ch << 6) | (byte & CONT_MASK) as u32 }\n \n-macro_rules! utf8_is_cont_byte {\n-    ($byte:expr) => (($byte & !CONT_MASK) == TAG_CONT_U8)\n-}\n+/// Checks whether the byte is a UTF-8 continuation byte (i.e. starts with the\n+/// bits `10`).\n+#[inline]\n+fn utf8_is_cont_byte(byte: u8) -> bool { (byte & !CONT_MASK) == TAG_CONT_U8 }\n \n #[inline]\n fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n@@ -374,20 +373,20 @@ pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     // Multibyte case follows\n     // Decode from a byte combination out of: [[[x y] z] w]\n     // NOTE: Performance is sensitive to the exact formulation here\n-    let init = utf8_first_byte!(x, 2);\n+    let init = utf8_first_byte(x, 2);\n     let y = unwrap_or_0(bytes.next());\n-    let mut ch = utf8_acc_cont_byte!(init, y);\n+    let mut ch = utf8_acc_cont_byte(init, y);\n     if x >= 0xE0 {\n         // [[x y z] w] case\n         // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n         let z = unwrap_or_0(bytes.next());\n-        let y_z = utf8_acc_cont_byte!((y & CONT_MASK) as u32, z);\n+        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n         ch = init << 12 | y_z;\n         if x >= 0xF0 {\n             // [x y z w] case\n             // use only the lower 3 bits of `init`\n             let w = unwrap_or_0(bytes.next());\n-            ch = (init & 7) << 18 | utf8_acc_cont_byte!(y_z, w);\n+            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n         }\n     }\n \n@@ -410,18 +409,18 @@ pub fn next_code_point_reverse(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     // Decode from a byte combination out of: [x [y [z w]]]\n     let mut ch;\n     let z = unwrap_or_0(bytes.next_back());\n-    ch = utf8_first_byte!(z, 2);\n-    if utf8_is_cont_byte!(z) {\n+    ch = utf8_first_byte(z, 2);\n+    if utf8_is_cont_byte(z) {\n         let y = unwrap_or_0(bytes.next_back());\n-        ch = utf8_first_byte!(y, 3);\n-        if utf8_is_cont_byte!(y) {\n+        ch = utf8_first_byte(y, 3);\n+        if utf8_is_cont_byte(y) {\n             let x = unwrap_or_0(bytes.next_back());\n-            ch = utf8_first_byte!(x, 4);\n-            ch = utf8_acc_cont_byte!(ch, y);\n+            ch = utf8_first_byte(x, 4);\n+            ch = utf8_acc_cont_byte(ch, y);\n         }\n-        ch = utf8_acc_cont_byte!(ch, z);\n+        ch = utf8_acc_cont_byte(ch, z);\n     }\n-    ch = utf8_acc_cont_byte!(ch, w);\n+    ch = utf8_acc_cont_byte(ch, w);\n \n     Some(ch)\n }\n@@ -1040,7 +1039,7 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n         // ASCII characters are always valid, so only large\n         // bytes need more examination.\n         if first >= 128 {\n-            let w = UTF8_CHAR_WIDTH[first as usize] as usize;\n+            let w = UTF8_CHAR_WIDTH[first as usize];\n             let second = next!();\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n@@ -1594,14 +1593,14 @@ impl StrExt for str {\n                 i -= 1;\n             }\n \n-            let mut val = s.as_bytes()[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n-            assert!((w != 0));\n+            let first= s.as_bytes()[i];\n+            let w = UTF8_CHAR_WIDTH[first as usize];\n+            assert!(w != 0);\n \n-            val = utf8_first_byte!(val, w);\n-            val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 3]); }\n+            let mut val = utf8_first_byte(first, w as u32);\n+            val = utf8_acc_cont_byte(val, s.as_bytes()[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte(val, s.as_bytes()[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte(val, s.as_bytes()[i + 3]); }\n \n             return CharRange {ch: unsafe { mem::transmute(val) }, next: i};\n         }\n@@ -1686,16 +1685,16 @@ pub fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) {\n \n     // Multibyte case is a fn to allow char_range_at to inline cleanly\n     fn multibyte_char_range_at(bytes: &[u8], i: usize) -> (u32, usize) {\n-        let mut val = bytes[i] as u32;\n-        let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n-        assert!((w != 0));\n+        let first = bytes[i];\n+        let w = UTF8_CHAR_WIDTH[first as usize];\n+        assert!(w != 0);\n \n-        val = utf8_first_byte!(val, w);\n-        val = utf8_acc_cont_byte!(val, bytes[i + 1]);\n-        if w > 2 { val = utf8_acc_cont_byte!(val, bytes[i + 2]); }\n-        if w > 3 { val = utf8_acc_cont_byte!(val, bytes[i + 3]); }\n+        let mut val = utf8_first_byte(first, w as u32);\n+        val = utf8_acc_cont_byte(val, bytes[i + 1]);\n+        if w > 2 { val = utf8_acc_cont_byte(val, bytes[i + 2]); }\n+        if w > 3 { val = utf8_acc_cont_byte(val, bytes[i + 3]); }\n \n-        return (val, i + w);\n+        return (val, i + w as usize);\n     }\n \n     multibyte_char_range_at(bytes, i)"}]}