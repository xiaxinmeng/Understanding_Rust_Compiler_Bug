{"sha": "20ffea6938b5839c390252e07940b99e3b6a889a", "node_id": "C_kwDOAAsO6NoAKDIwZmZlYTY5MzhiNTgzOWMzOTAyNTJlMDc5NDBiOTllM2I2YTg4OWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-11T18:05:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-11T18:05:55Z"}, "message": "Auto merge of #100416 - Dylan-DPC:rollup-m344lh1, r=Dylan-DPC\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #92744 (Check if enum from foreign crate has any non exhaustive variants when attempting a cast)\n - #99110 (Determine match_has_guard from candidates instead of looking up thir table again)\n - #100184 (Stabilize ptr_const_cast)\n - #100192 ( Remove duplicated temporaries creating during box derefs elaboration)\n - #100232 (Do not consider method call receiver as an argument in AST.)\n - #100287 (linux: Use `pthread_setname_np` instead of `prctl`)\n - #100351 (Use `&mut Diagnostic` instead of `&mut DiagnosticBuilder` unless needed)\n - #100370 (Remove more Clean trait implementations)\n - #100391 (Improve size assertions)\n - #100398 (Improve `-Zhir-stats`)\n - #100403 (Improve error messages when running rustdoc GUI tests)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "2f04efd7c69095fca1a6949ae82cc43f80adeb4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f04efd7c69095fca1a6949ae82cc43f80adeb4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20ffea6938b5839c390252e07940b99e3b6a889a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20ffea6938b5839c390252e07940b99e3b6a889a", "html_url": "https://github.com/rust-lang/rust/commit/20ffea6938b5839c390252e07940b99e3b6a889a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20ffea6938b5839c390252e07940b99e3b6a889a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeb5067967ef58e4a324b19dd0dba2f385d5959f", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeb5067967ef58e4a324b19dd0dba2f385d5959f", "html_url": "https://github.com/rust-lang/rust/commit/aeb5067967ef58e4a324b19dd0dba2f385d5959f"}, {"sha": "f583bf611dcda66a5fd9845c8e0e7293b0053ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/f583bf611dcda66a5fd9845c8e0e7293b0053ece", "html_url": "https://github.com/rust-lang/rust/commit/f583bf611dcda66a5fd9845c8e0e7293b0053ece"}], "stats": {"total": 1424, "additions": 952, "deletions": 472}, "files": [{"sha": "6529f11100d2d0d9417306b36c4a1ddea39b69f6", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -19,7 +19,6 @@\n #![feature(rustc_attrs)]\n #![cfg_attr(test, feature(test))]\n #![feature(strict_provenance)]\n-#![feature(ptr_const_cast)]\n \n use smallvec::SmallVec;\n "}, {"sha": "2809f0b719f7ba21aa3990d0b00ce9fec010bf01", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -1338,14 +1338,13 @@ pub enum ExprKind {\n     ///\n     /// The `PathSegment` represents the method name and its generic arguments\n     /// (within the angle brackets).\n-    /// The first element of the vector of an `Expr` is the expression that evaluates\n-    /// to the object on which the method is being called on (the receiver),\n-    /// and the remaining elements are the rest of the arguments.\n-    /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n-    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n+    /// The standalone `Expr` is the receiver expression.\n+    /// The vector of `Expr` is the arguments.\n+    /// `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n+    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, x, [a, b, c, d])`.\n     /// This `Span` is the span of the function, without the dot and receiver\n     /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n-    MethodCall(PathSegment, Vec<P<Expr>>, Span),\n+    MethodCall(PathSegment, P<Expr>, Vec<P<Expr>>, Span),\n     /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(Vec<P<Expr>>),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n@@ -3030,22 +3029,25 @@ pub type ForeignItem = Item<ForeignItemKind>;\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     use super::*;\n+    use rustc_data_structures::static_assert_size;\n     // These are in alphabetical order, which is easy to maintain.\n-    rustc_data_structures::static_assert_size!(AssocItemKind, 72);\n-    rustc_data_structures::static_assert_size!(Attribute, 152);\n-    rustc_data_structures::static_assert_size!(Block, 48);\n-    rustc_data_structures::static_assert_size!(Expr, 104);\n-    rustc_data_structures::static_assert_size!(Fn, 192);\n-    rustc_data_structures::static_assert_size!(ForeignItemKind, 72);\n-    rustc_data_structures::static_assert_size!(GenericBound, 88);\n-    rustc_data_structures::static_assert_size!(Generics, 72);\n-    rustc_data_structures::static_assert_size!(Impl, 200);\n-    rustc_data_structures::static_assert_size!(Item, 200);\n-    rustc_data_structures::static_assert_size!(ItemKind, 112);\n-    rustc_data_structures::static_assert_size!(Lit, 48);\n-    rustc_data_structures::static_assert_size!(Pat, 120);\n-    rustc_data_structures::static_assert_size!(Path, 40);\n-    rustc_data_structures::static_assert_size!(PathSegment, 24);\n-    rustc_data_structures::static_assert_size!(Stmt, 32);\n-    rustc_data_structures::static_assert_size!(Ty, 96);\n+    static_assert_size!(AssocItem, 160);\n+    static_assert_size!(AssocItemKind, 72);\n+    static_assert_size!(Attribute, 152);\n+    static_assert_size!(Block, 48);\n+    static_assert_size!(Expr, 104);\n+    static_assert_size!(Fn, 192);\n+    static_assert_size!(ForeignItem, 160);\n+    static_assert_size!(ForeignItemKind, 72);\n+    static_assert_size!(GenericBound, 88);\n+    static_assert_size!(Generics, 72);\n+    static_assert_size!(Impl, 200);\n+    static_assert_size!(Item, 200);\n+    static_assert_size!(ItemKind, 112);\n+    static_assert_size!(Lit, 48);\n+    static_assert_size!(Pat, 120);\n+    static_assert_size!(Path, 40);\n+    static_assert_size!(PathSegment, 24);\n+    static_assert_size!(Stmt, 32);\n+    static_assert_size!(Ty, 96);\n }"}, {"sha": "230c73c88e9092997e88ee1c1d3b5cbeb5abb930", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -1302,10 +1302,11 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             vis.visit_expr(f);\n             visit_exprs(args, vis);\n         }\n-        ExprKind::MethodCall(PathSegment { ident, id, args }, exprs, span) => {\n+        ExprKind::MethodCall(PathSegment { ident, id, args }, receiver, exprs, span) => {\n             vis.visit_ident(ident);\n             vis.visit_id(id);\n             visit_opt(args, |args| vis.visit_generic_args(args));\n+            vis.visit_expr(receiver);\n             visit_exprs(exprs, vis);\n             vis.visit_span(span);\n         }"}, {"sha": "5edeb54be5f0f7a2240f56dac26439bb0740d8a2", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -396,9 +396,9 @@ pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n             contains_exterior_struct_lit(&x)\n         }\n \n-        ast::ExprKind::MethodCall(.., ref exprs, _) => {\n+        ast::ExprKind::MethodCall(_, ref receiver, _, _) => {\n             // X { y: 1 }.bar(...)\n-            contains_exterior_struct_lit(&exprs[0])\n+            contains_exterior_struct_lit(&receiver)\n         }\n \n         _ => false,"}, {"sha": "bedbb02f033c751e92f2e796e3ed02cb1b0364a8", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -813,8 +813,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::MethodCall(ref segment, ref arguments, _span) => {\n+        ExprKind::MethodCall(ref segment, ref receiver, ref arguments, _span) => {\n             visitor.visit_path_segment(expression.span, segment);\n+            visitor.visit_expr(receiver);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n         ExprKind::Binary(_, ref left_expression, ref right_expression) => {"}, {"sha": "c7d35fdb1fd561febda5db836f4a92d065fda16c", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -62,15 +62,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         hir::ExprKind::Call(f, self.lower_exprs(args))\n                     }\n                 }\n-                ExprKind::MethodCall(ref seg, ref args, span) => {\n+                ExprKind::MethodCall(ref seg, ref receiver, ref args, span) => {\n                     let hir_seg = self.arena.alloc(self.lower_path_segment(\n                         e.span,\n                         seg,\n                         ParamMode::Optional,\n                         ParenthesizedGenericArgs::Err,\n                         ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     ));\n-                    let args = self.lower_exprs(args);\n+                    let args = self.arena.alloc_from_iter(\n+                        [&*receiver].into_iter().chain(args.iter()).map(|x| self.lower_expr_mut(x)),\n+                    );\n                     hir::ExprKind::MethodCall(hir_seg, args, self.lower_span(span))\n                 }\n                 ExprKind::Binary(binop, ref lhs, ref rhs) => {"}, {"sha": "d94f8a9af884bc1e09bad0d212da7df6b8907269", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -13,9 +13,7 @@ use rustc_ast::walk_list;\n use rustc_ast::*;\n use rustc_ast_pretty::pprust::{self, State};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{\n-    error_code, pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed,\n-};\n+use rustc_errors::{error_code, pluralize, struct_span_err, Applicability, Diagnostic};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::{\n     DEPRECATED_WHERE_CLAUSE_LOCATION, MISSING_ABI, PATTERNS_IN_FNS_WITHOUT_BODY,\n@@ -477,7 +475,7 @@ impl<'a> AstValidator<'a> {\n         ctx: &str,\n         msg: &str,\n         sugg: &str,\n-        help: impl FnOnce(&mut DiagnosticBuilder<'_, ErrorGuaranteed>),\n+        help: impl FnOnce(&mut Diagnostic),\n     ) {\n         let source_map = self.session.source_map();\n         let end = source_map.end_point(sp);\n@@ -1196,7 +1194,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     let msg = \"free function without a body\";\n                     let ext = sig.header.ext;\n \n-                    let f = |e: &mut DiagnosticBuilder<'_, _>| {\n+                    let f = |e: &mut Diagnostic| {\n                         if let Extern::Implicit(start_span) | Extern::Explicit(_, start_span) = &ext\n                         {\n                             let start_suggestion = if let Extern::Explicit(abi, _) = ext {"}, {"sha": "bcefa8ce0b9ce6ca8ff078b10e3fb3cc8d722a0d", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -193,9 +193,13 @@ impl<'a> State<'a> {\n         self.print_call_post(args)\n     }\n \n-    fn print_expr_method_call(&mut self, segment: &ast::PathSegment, args: &[P<ast::Expr>]) {\n-        let base_args = &args[1..];\n-        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n+    fn print_expr_method_call(\n+        &mut self,\n+        segment: &ast::PathSegment,\n+        receiver: &ast::Expr,\n+        base_args: &[P<ast::Expr>],\n+    ) {\n+        self.print_expr_maybe_paren(receiver, parser::PREC_POSTFIX);\n         self.word(\".\");\n         self.print_ident(segment.ident);\n         if let Some(ref args) = segment.args {\n@@ -303,8 +307,8 @@ impl<'a> State<'a> {\n             ast::ExprKind::Call(ref func, ref args) => {\n                 self.print_expr_call(func, &args);\n             }\n-            ast::ExprKind::MethodCall(ref segment, ref args, _) => {\n-                self.print_expr_method_call(segment, &args);\n+            ast::ExprKind::MethodCall(ref segment, ref receiver, ref args, _) => {\n+                self.print_expr_method_call(segment, &receiver, &args);\n             }\n             ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n                 self.print_expr_binary(op, lhs, rhs);"}, {"sha": "84a0d4ba7ba10b67fea7fe8f95cc21270bb20a33", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -451,7 +451,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn suggest_borrow_fn_like(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        err: &mut Diagnostic,\n         ty: Ty<'tcx>,\n         move_sites: &[MoveSite],\n         value_name: &str,\n@@ -526,12 +526,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         true\n     }\n \n-    fn suggest_adding_copy_bounds(\n-        &self,\n-        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) {\n+    fn suggest_adding_copy_bounds(&self, err: &mut Diagnostic, ty: Ty<'tcx>, span: Span) {\n         let tcx = self.infcx.tcx;\n         let generics = tcx.generics_of(self.mir_def_id());\n "}, {"sha": "bd3a2a3d69496c84728ea5ef189cda004a49994d", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -783,7 +783,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n     fn maybe_suggest_constrain_dyn_trait_impl(\n         &self,\n-        diag: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        diag: &mut Diagnostic,\n         f: Region<'tcx>,\n         o: Region<'tcx>,\n         category: &ConstraintCategory<'tcx>,"}, {"sha": "c04d04020cc679cb06c386659684876795f3fb55", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -240,8 +240,8 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                 self.manage_cond_expr(prefix);\n                 self.manage_cond_expr(suffix);\n             }\n-            ExprKind::MethodCall(_, ref mut local_exprs, _) => {\n-                for local_expr in local_exprs.iter_mut().skip(1) {\n+            ExprKind::MethodCall(_, _,ref mut local_exprs, _) => {\n+                for local_expr in local_exprs.iter_mut() {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n@@ -377,14 +377,12 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                     id: DUMMY_NODE_ID,\n                     ident: Ident::new(sym::try_capture, self.span),\n                 },\n-                vec![\n-                    expr_paren(self.cx, self.span, self.cx.expr_addr_of(self.span, wrapper)),\n-                    expr_addr_of_mut(\n-                        self.cx,\n-                        self.span,\n-                        self.cx.expr_path(Path::from_ident(capture)),\n-                    ),\n-                ],\n+                expr_paren(self.cx, self.span, self.cx.expr_addr_of(self.span, wrapper)),\n+                vec![expr_addr_of_mut(\n+                    self.cx,\n+                    self.span,\n+                    self.cx.expr_path(Path::from_ident(capture)),\n+                )],\n                 self.span,\n             ))\n             .add_trailing_semicolon();\n@@ -442,10 +440,11 @@ fn expr_addr_of_mut(cx: &ExtCtxt<'_>, sp: Span, e: P<Expr>) -> P<Expr> {\n fn expr_method_call(\n     cx: &ExtCtxt<'_>,\n     path: PathSegment,\n+    receiver: P<Expr>,\n     args: Vec<P<Expr>>,\n     span: Span,\n ) -> P<Expr> {\n-    cx.expr(span, ExprKind::MethodCall(path, args, span))\n+    cx.expr(span, ExprKind::MethodCall(path, receiver, args, span))\n }\n \n fn expr_paren(cx: &ExtCtxt<'_>, sp: Span, e: P<Expr>) -> P<Expr> {"}, {"sha": "fe80a55dfd28ce9fbd6bb9a4273c4e04ea7b2960", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -823,9 +823,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     use super::*;\n+    use rustc_data_structures::static_assert_size;\n     // These are in alphabetical order, which is easy to maintain.\n-    rustc_data_structures::static_assert_size!(Immediate, 56);\n-    rustc_data_structures::static_assert_size!(ImmTy<'_>, 72);\n-    rustc_data_structures::static_assert_size!(Operand, 64);\n-    rustc_data_structures::static_assert_size!(OpTy<'_>, 88);\n+    static_assert_size!(Immediate, 56);\n+    static_assert_size!(ImmTy<'_>, 72);\n+    static_assert_size!(Operand, 64);\n+    static_assert_size!(OpTy<'_>, 88);\n }"}, {"sha": "97fe23cb5bcf3ee5f4e7741778635645c9730227", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -891,10 +891,11 @@ where\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     use super::*;\n+    use rustc_data_structures::static_assert_size;\n     // These are in alphabetical order, which is easy to maintain.\n-    rustc_data_structures::static_assert_size!(MemPlaceMeta, 24);\n-    rustc_data_structures::static_assert_size!(MemPlace, 40);\n-    rustc_data_structures::static_assert_size!(MPlaceTy<'_>, 64);\n-    rustc_data_structures::static_assert_size!(Place, 48);\n-    rustc_data_structures::static_assert_size!(PlaceTy<'_>, 72);\n+    static_assert_size!(MemPlaceMeta, 24);\n+    static_assert_size!(MemPlace, 40);\n+    static_assert_size!(MPlaceTy<'_>, 64);\n+    static_assert_size!(Place, 48);\n+    static_assert_size!(PlaceTy<'_>, 72);\n }"}, {"sha": "e009e4f7c68d09388b4e9c26388fdae6755528fd", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -14,7 +14,7 @@ use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder};\n use rustc_feature::Features;\n use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n@@ -608,11 +608,7 @@ enum ExplainDocComment {\n     },\n }\n \n-fn annotate_doc_comment(\n-    err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n-    sm: &SourceMap,\n-    span: Span,\n-) {\n+fn annotate_doc_comment(err: &mut Diagnostic, sm: &SourceMap, span: Span) {\n     if let Ok(src) = sm.span_to_snippet(span) {\n         if src.starts_with(\"///\") || src.starts_with(\"/**\") {\n             err.subdiagnostic(ExplainDocComment::Outer { span });"}, {"sha": "7a87a3e4882601700eb7e5ebd1ef9272d4769d8a", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -3491,16 +3491,16 @@ impl<'hir> Node<'hir> {\n mod size_asserts {\n     use super::*;\n     // These are in alphabetical order, which is easy to maintain.\n-    rustc_data_structures::static_assert_size!(Block<'static>, 48);\n-    rustc_data_structures::static_assert_size!(Expr<'static>, 56);\n-    rustc_data_structures::static_assert_size!(ForeignItem<'static>, 72);\n-    rustc_data_structures::static_assert_size!(GenericBound<'_>, 48);\n-    rustc_data_structures::static_assert_size!(Generics<'static>, 56);\n-    rustc_data_structures::static_assert_size!(ImplItem<'static>, 88);\n-    rustc_data_structures::static_assert_size!(Impl<'static>, 80);\n-    rustc_data_structures::static_assert_size!(Item<'static>, 80);\n-    rustc_data_structures::static_assert_size!(Pat<'static>, 88);\n-    rustc_data_structures::static_assert_size!(QPath<'static>, 24);\n-    rustc_data_structures::static_assert_size!(TraitItem<'static>, 96);\n-    rustc_data_structures::static_assert_size!(Ty<'static>, 72);\n+    static_assert_size!(Block<'static>, 48);\n+    static_assert_size!(Expr<'static>, 56);\n+    static_assert_size!(ForeignItem<'static>, 72);\n+    static_assert_size!(GenericBound<'_>, 48);\n+    static_assert_size!(Generics<'static>, 56);\n+    static_assert_size!(ImplItem<'static>, 88);\n+    static_assert_size!(Impl<'static>, 80);\n+    static_assert_size!(Item<'static>, 80);\n+    static_assert_size!(Pat<'static>, 88);\n+    static_assert_size!(QPath<'static>, 24);\n+    static_assert_size!(TraitItem<'static>, 96);\n+    static_assert_size!(Ty<'static>, 72);\n }"}, {"sha": "58b2f0a44161c273b62d6079aebfdd70acc55e00", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -608,8 +608,7 @@ trait UnusedDelimLint {\n             ref call_or_other => {\n                 let (args_to_check, ctx) = match *call_or_other {\n                     Call(_, ref args) => (&args[..], UnusedDelimsCtx::FunctionArg),\n-                    // first \"argument\" is self (which sometimes needs delims)\n-                    MethodCall(_, ref args, _) => (&args[1..], UnusedDelimsCtx::MethodArg),\n+                    MethodCall(_, _, ref args, _) => (&args[..], UnusedDelimsCtx::MethodArg),\n                     // actual catch-all arm\n                     _ => {\n                         return;"}, {"sha": "5e26a52900eaf404ce2e4f819ddaf64bd116f7f6", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -814,8 +814,8 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n mod size_asserts {\n     use super::*;\n     // These are in alphabetical order, which is easy to maintain.\n-    rustc_data_structures::static_assert_size!(Block, 56);\n-    rustc_data_structures::static_assert_size!(Expr<'_>, 104);\n-    rustc_data_structures::static_assert_size!(Pat<'_>, 24);\n-    rustc_data_structures::static_assert_size!(Stmt<'_>, 120);\n+    static_assert_size!(Block, 56);\n+    static_assert_size!(Expr<'_>, 104);\n+    static_assert_size!(Pat<'_>, 24);\n+    static_assert_size!(Stmt<'_>, 120);\n }"}, {"sha": "ce38283724dac892e7ebd5c3200f4c417d012b52", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -170,7 +170,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let mut arm_candidates = self.create_match_candidates(scrutinee_place.clone(), &arms);\n \n-        let match_has_guard = arms.iter().copied().any(|arm| self.thir[arm].guard.is_some());\n+        let match_has_guard = arm_candidates.iter().any(|(_, candidate)| candidate.has_guard);\n         let mut candidates =\n             arm_candidates.iter_mut().map(|(_, candidate)| candidate).collect::<Vec<_>>();\n "}, {"sha": "7652223368964290d918b62377e173b57318992d", "filename": "compiler/rustc_mir_transform/src/elaborate_box_derefs.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -70,7 +70,6 @@ impl<'tcx, 'a> MutVisitor<'tcx> for ElaborateBoxDerefVisitor<'tcx, 'a> {\n                 build_ptr_tys(tcx, base_ty.boxed_ty(), self.unique_did, self.nonnull_did);\n \n             let ptr_local = self.patch.new_temp(ptr_ty, source_info.span);\n-            self.local_decls.push(LocalDecl::new(ptr_ty, source_info.span));\n \n             self.patch.add_statement(location, StatementKind::StorageLive(ptr_local));\n \n@@ -125,13 +124,6 @@ impl<'tcx> MirPass<'tcx> for ElaborateBoxDerefs {\n                     index += 1;\n                 }\n \n-                if let Some(terminator) = terminator\n-                && !matches!(terminator.kind, TerminatorKind::Yield{..})\n-                {\n-                    let location = Location { block, statement_index: index };\n-                    visitor.visit_terminator(terminator, location);\n-                }\n-\n                 let location = Location { block, statement_index: index };\n                 match terminator {\n                     // yielding into a box is handled when lowering generators"}, {"sha": "f4c6b33a529243872292cfc1cfe15575b602db4e", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -19,7 +19,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{\n     fluent, Applicability, DiagnosticBuilder, DiagnosticMessage, Handler, MultiSpan, PResult,\n };\n-use rustc_errors::{pluralize, struct_span_err, Diagnostic, EmissionGuarantee, ErrorGuaranteed};\n+use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed};\n use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, Ident};\n@@ -228,13 +228,13 @@ struct MultiSugg {\n }\n \n impl MultiSugg {\n-    fn emit<G: EmissionGuarantee>(self, err: &mut DiagnosticBuilder<'_, G>) {\n+    fn emit(self, err: &mut Diagnostic) {\n         err.multipart_suggestion(&self.msg, self.patches, self.applicability);\n     }\n \n     /// Overrides individual messages and applicabilities.\n-    fn emit_many<G: EmissionGuarantee>(\n-        err: &mut DiagnosticBuilder<'_, G>,\n+    fn emit_many(\n+        err: &mut Diagnostic,\n         msg: &str,\n         applicability: Applicability,\n         suggestions: impl Iterator<Item = Self>,"}, {"sha": "2880ef78c8d276b278057052904696ef131bd809", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -850,7 +850,7 @@ impl<'a> Parser<'a> {\n                     ExprKind::Index(_, _) => \"indexing\",\n                     ExprKind::Try(_) => \"`?`\",\n                     ExprKind::Field(_, _) => \"a field access\",\n-                    ExprKind::MethodCall(_, _, _) => \"a method call\",\n+                    ExprKind::MethodCall(_, _, _, _) => \"a method call\",\n                     ExprKind::Call(_, _) => \"a function call\",\n                     ExprKind::Await(_) => \"`.await`\",\n                     ExprKind::Err => return Ok(with_postfix),\n@@ -859,7 +859,7 @@ impl<'a> Parser<'a> {\n             );\n             let mut err = self.struct_span_err(span, &msg);\n \n-            let suggest_parens = |err: &mut DiagnosticBuilder<'_, _>| {\n+            let suggest_parens = |err: &mut Diagnostic| {\n                 let suggestions = vec![\n                     (span.shrink_to_lo(), \"(\".to_string()),\n                     (span.shrink_to_hi(), \")\".to_string()),\n@@ -1280,12 +1280,14 @@ impl<'a> Parser<'a> {\n \n         if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             // Method call `expr.f()`\n-            let mut args = self.parse_paren_expr_seq()?;\n-            args.insert(0, self_arg);\n-\n+            let args = self.parse_paren_expr_seq()?;\n             let fn_span = fn_span_lo.to(self.prev_token.span);\n             let span = lo.to(self.prev_token.span);\n-            Ok(self.mk_expr(span, ExprKind::MethodCall(segment, args, fn_span), AttrVec::new()))\n+            Ok(self.mk_expr(\n+                span,\n+                ExprKind::MethodCall(segment, self_arg, args, fn_span),\n+                AttrVec::new(),\n+            ))\n         } else {\n             // Field access `expr.f`\n             if let Some(args) = segment.args {"}, {"sha": "ec070e6a9c5c63fdaabb85f126de05822fd4e12f", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 253, "deletions": 52, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -21,21 +21,55 @@ enum Id {\n     None,\n }\n \n-struct NodeData {\n+struct NodeStats {\n     count: usize,\n     size: usize,\n }\n \n+impl NodeStats {\n+    fn new() -> NodeStats {\n+        NodeStats { count: 0, size: 0 }\n+    }\n+}\n+\n+struct Node {\n+    stats: NodeStats,\n+    subnodes: FxHashMap<&'static str, NodeStats>,\n+}\n+\n+impl Node {\n+    fn new() -> Node {\n+        Node { stats: NodeStats::new(), subnodes: FxHashMap::default() }\n+    }\n+}\n+\n+/// This type measures the size of AST and HIR nodes, by implementing the AST\n+/// and HIR `Visitor` traits. But we don't measure every visited type because\n+/// that could cause double counting.\n+///\n+/// For example, `ast::Visitor` has `visit_ident`, but `Ident`s are always\n+/// stored inline within other AST nodes, so we don't implement `visit_ident`\n+/// here. In constrast, we do implement `visit_expr` because `ast::Expr` is\n+/// always stored as `P<ast::Expr>`, and every such expression should be\n+/// measured separately.\n+///\n+/// In general, a `visit_foo` method should be implemented here if the\n+/// corresponding `Foo` type is always stored on its own, e.g.: `P<Foo>`,\n+/// `Box<Foo>`, `Vec<Foo>`, `Box<[Foo]>`.\n+///\n+/// There are some types in the AST and HIR tree that the visitors do not have\n+/// a `visit_*` method for, and so we cannot measure these, which is\n+/// unfortunate.\n struct StatCollector<'k> {\n     krate: Option<Map<'k>>,\n-    data: FxHashMap<&'static str, NodeData>,\n+    nodes: FxHashMap<&'static str, Node>,\n     seen: FxHashSet<Id>,\n }\n \n pub fn print_hir_stats(tcx: TyCtxt<'_>) {\n     let mut collector = StatCollector {\n         krate: Some(tcx.hir()),\n-        data: FxHashMap::default(),\n+        nodes: FxHashMap::default(),\n         seen: FxHashSet::default(),\n     };\n     tcx.hir().walk_toplevel_module(&mut collector);\n@@ -44,49 +78,88 @@ pub fn print_hir_stats(tcx: TyCtxt<'_>) {\n }\n \n pub fn print_ast_stats(krate: &ast::Crate, title: &str) {\n+    use rustc_ast::visit::Visitor;\n+\n     let mut collector =\n-        StatCollector { krate: None, data: FxHashMap::default(), seen: FxHashSet::default() };\n-    ast_visit::walk_crate(&mut collector, krate);\n+        StatCollector { krate: None, nodes: FxHashMap::default(), seen: FxHashSet::default() };\n+    collector.visit_crate(krate);\n     collector.print(title);\n }\n \n impl<'k> StatCollector<'k> {\n-    fn record<T>(&mut self, label: &'static str, id: Id, node: &T) {\n+    // Record a top-level node.\n+    fn record<T>(&mut self, label: &'static str, id: Id, val: &T) {\n+        self.record_inner(label, None, id, val);\n+    }\n+\n+    // Record a two-level entry, with a top-level enum type and a variant.\n+    fn record_variant<T>(&mut self, label1: &'static str, label2: &'static str, id: Id, val: &T) {\n+        self.record_inner(label1, Some(label2), id, val);\n+    }\n+\n+    fn record_inner<T>(\n+        &mut self,\n+        label1: &'static str,\n+        label2: Option<&'static str>,\n+        id: Id,\n+        val: &T,\n+    ) {\n         if id != Id::None && !self.seen.insert(id) {\n             return;\n         }\n \n-        let entry = self.data.entry(label).or_insert(NodeData { count: 0, size: 0 });\n+        let node = self.nodes.entry(label1).or_insert(Node::new());\n+        node.stats.count += 1;\n+        node.stats.size = std::mem::size_of_val(val);\n \n-        entry.count += 1;\n-        entry.size = std::mem::size_of_val(node);\n+        if let Some(label2) = label2 {\n+            let subnode = node.subnodes.entry(label2).or_insert(NodeStats::new());\n+            subnode.count += 1;\n+            subnode.size = std::mem::size_of_val(val);\n+        }\n     }\n \n     fn print(&self, title: &str) {\n-        let mut stats: Vec<_> = self.data.iter().collect();\n-\n-        stats.sort_by_key(|&(_, ref d)| d.count * d.size);\n+        let mut nodes: Vec<_> = self.nodes.iter().collect();\n+        nodes.sort_by_key(|&(_, ref node)| node.stats.count * node.stats.size);\n \n-        let mut total_size = 0;\n+        let total_size = nodes.iter().map(|(_, node)| node.stats.count * node.stats.size).sum();\n \n         eprintln!(\"\\n{}\\n\", title);\n \n         eprintln!(\"{:<18}{:>18}{:>14}{:>14}\", \"Name\", \"Accumulated Size\", \"Count\", \"Item Size\");\n         eprintln!(\"----------------------------------------------------------------\");\n \n-        for (label, data) in stats {\n+        let percent = |m, n| (m * 100) as f64 / n as f64;\n+\n+        for (label, node) in nodes {\n+            let size = node.stats.count * node.stats.size;\n             eprintln!(\n-                \"{:<18}{:>18}{:>14}{:>14}\",\n+                \"{:<18}{:>10} ({:4.1}%){:>14}{:>14}\",\n                 label,\n-                to_readable_str(data.count * data.size),\n-                to_readable_str(data.count),\n-                to_readable_str(data.size)\n+                to_readable_str(size),\n+                percent(size, total_size),\n+                to_readable_str(node.stats.count),\n+                to_readable_str(node.stats.size)\n             );\n-\n-            total_size += data.count * data.size;\n+            if !node.subnodes.is_empty() {\n+                let mut subnodes: Vec<_> = node.subnodes.iter().collect();\n+                subnodes.sort_by_key(|&(_, ref subnode)| subnode.count * subnode.size);\n+\n+                for (label, subnode) in subnodes {\n+                    let size = subnode.count * subnode.size;\n+                    eprintln!(\n+                        \"- {:<18}{:>10} ({:4.1}%){:>14}\",\n+                        label,\n+                        to_readable_str(size),\n+                        percent(size, total_size),\n+                        to_readable_str(subnode.count),\n+                    );\n+                }\n+            }\n         }\n         eprintln!(\"----------------------------------------------------------------\");\n-        eprintln!(\"{:<18}{:>18}\\n\", \"Total\", to_readable_str(total_size));\n+        eprintln!(\"{:<18}{:>10}\\n\", \"Total\", to_readable_str(total_size));\n     }\n }\n \n@@ -228,6 +301,10 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_path(self, path)\n     }\n \n+    // `PathSegment` has one inline use (in `ast::ExprKind::MethodCall`) and\n+    // one non-inline use (in `Path::segments`). The latter case is more common\n+    // than the former case, so we implement this visitor and tolerate the\n+    // double counting in the former case.\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v hir::PathSegment<'v>) {\n         self.record(\"PathSegment\", Id::None, path_segment);\n         hir_visit::walk_path_segment(self, path_span, path_segment)\n@@ -243,14 +320,54 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n }\n \n+// Used to avoid boilerplate for types with many variants.\n+macro_rules! record_variants {\n+    (\n+        ($self:ident, $val:expr, $kind:expr, $ty:ty, $tykind:ident), // mandatory pieces\n+        [$($variant:ident),*]\n+    ) => {\n+        match $kind {\n+            $(\n+                ast::$tykind::$variant { .. } => {\n+                    $self.record_variant(stringify!($ty), stringify!($variant), Id::None, $val)\n+                }\n+            )*\n+        }\n+    };\n+}\n+\n impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_foreign_item(&mut self, i: &'v ast::ForeignItem) {\n-        self.record(\"ForeignItem\", Id::None, i);\n+        record_variants!(\n+            (self, i, i.kind, ForeignItem, ForeignItemKind),\n+            [Static, Fn, TyAlias, MacCall]\n+        );\n         ast_visit::walk_foreign_item(self, i)\n     }\n \n     fn visit_item(&mut self, i: &'v ast::Item) {\n-        self.record(\"Item\", Id::None, i);\n+        record_variants!(\n+            (self, i, i.kind, Item, ItemKind),\n+            [\n+                ExternCrate,\n+                Use,\n+                Static,\n+                Const,\n+                Fn,\n+                Mod,\n+                ForeignMod,\n+                GlobalAsm,\n+                TyAlias,\n+                Enum,\n+                Struct,\n+                Union,\n+                Trait,\n+                TraitAlias,\n+                Impl,\n+                MacCall,\n+                MacroDef\n+            ]\n+        );\n         ast_visit::walk_item(self, i)\n     }\n \n@@ -265,47 +382,116 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_stmt(&mut self, s: &'v ast::Stmt) {\n-        self.record(\"Stmt\", Id::None, s);\n+        record_variants!(\n+            (self, s, s.kind, Stmt, StmtKind),\n+            [Local, Item, Expr, Semi, Empty, MacCall]\n+        );\n         ast_visit::walk_stmt(self, s)\n     }\n \n+    fn visit_param(&mut self, p: &'v ast::Param) {\n+        self.record(\"Param\", Id::None, p);\n+        ast_visit::walk_param(self, p)\n+    }\n+\n     fn visit_arm(&mut self, a: &'v ast::Arm) {\n         self.record(\"Arm\", Id::None, a);\n         ast_visit::walk_arm(self, a)\n     }\n \n     fn visit_pat(&mut self, p: &'v ast::Pat) {\n-        self.record(\"Pat\", Id::None, p);\n+        record_variants!(\n+            (self, p, p.kind, Pat, PatKind),\n+            [\n+                Wild,\n+                Ident,\n+                Struct,\n+                TupleStruct,\n+                Or,\n+                Path,\n+                Tuple,\n+                Box,\n+                Ref,\n+                Lit,\n+                Range,\n+                Slice,\n+                Rest,\n+                Paren,\n+                MacCall\n+            ]\n+        );\n         ast_visit::walk_pat(self, p)\n     }\n \n-    fn visit_expr(&mut self, ex: &'v ast::Expr) {\n-        self.record(\"Expr\", Id::None, ex);\n-        ast_visit::walk_expr(self, ex)\n+    fn visit_expr(&mut self, e: &'v ast::Expr) {\n+        record_variants!(\n+            (self, e, e.kind, Expr, ExprKind),\n+            [\n+                Box, Array, ConstBlock, Call, MethodCall, Tup, Binary, Unary, Lit, Cast, Type, Let,\n+                If, While, ForLoop, Loop, Match, Closure, Block, Async, Await, TryBlock, Assign,\n+                AssignOp, Field, Index, Range, Underscore, Path, AddrOf, Break, Continue, Ret,\n+                InlineAsm, MacCall, Struct, Repeat, Paren, Try, Yield, Yeet, Err\n+            ]\n+        );\n+        ast_visit::walk_expr(self, e)\n     }\n \n     fn visit_ty(&mut self, t: &'v ast::Ty) {\n-        self.record(\"Ty\", Id::None, t);\n+        record_variants!(\n+            (self, t, t.kind, Ty, TyKind),\n+            [\n+                Slice,\n+                Array,\n+                Ptr,\n+                Rptr,\n+                BareFn,\n+                Never,\n+                Tup,\n+                Path,\n+                TraitObject,\n+                ImplTrait,\n+                Paren,\n+                Typeof,\n+                Infer,\n+                ImplicitSelf,\n+                MacCall,\n+                Err,\n+                CVarArgs\n+            ]\n+        );\n+\n         ast_visit::walk_ty(self, t)\n     }\n \n+    fn visit_generic_param(&mut self, g: &'v ast::GenericParam) {\n+        self.record(\"GenericParam\", Id::None, g);\n+        ast_visit::walk_generic_param(self, g)\n+    }\n+\n+    fn visit_where_predicate(&mut self, p: &'v ast::WherePredicate) {\n+        record_variants!(\n+            (self, p, p, WherePredicate, WherePredicate),\n+            [BoundPredicate, RegionPredicate, EqPredicate]\n+        );\n+        ast_visit::walk_where_predicate(self, p)\n+    }\n+\n     fn visit_fn(&mut self, fk: ast_visit::FnKind<'v>, s: Span, _: NodeId) {\n         self.record(\"FnDecl\", Id::None, fk.decl());\n         ast_visit::walk_fn(self, fk, s)\n     }\n \n-    fn visit_assoc_item(&mut self, item: &'v ast::AssocItem, ctxt: ast_visit::AssocCtxt) {\n-        let label = match ctxt {\n-            ast_visit::AssocCtxt::Trait => \"TraitItem\",\n-            ast_visit::AssocCtxt::Impl => \"ImplItem\",\n-        };\n-        self.record(label, Id::None, item);\n-        ast_visit::walk_assoc_item(self, item, ctxt);\n+    fn visit_assoc_item(&mut self, i: &'v ast::AssocItem, ctxt: ast_visit::AssocCtxt) {\n+        record_variants!(\n+            (self, i, i.kind, AssocItem, AssocItemKind),\n+            [Const, Fn, TyAlias, MacCall]\n+        );\n+        ast_visit::walk_assoc_item(self, i, ctxt);\n     }\n \n-    fn visit_param_bound(&mut self, bounds: &'v ast::GenericBound, _ctxt: BoundKind) {\n-        self.record(\"GenericBound\", Id::None, bounds);\n-        ast_visit::walk_param_bound(self, bounds)\n+    fn visit_param_bound(&mut self, b: &'v ast::GenericBound, _ctxt: BoundKind) {\n+        record_variants!((self, b, b, GenericBound, GenericBound), [Trait, Outlives]);\n+        ast_visit::walk_param_bound(self, b)\n     }\n \n     fn visit_field_def(&mut self, s: &'v ast::FieldDef) {\n@@ -318,27 +504,42 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         ast_visit::walk_variant(self, v)\n     }\n \n-    fn visit_lifetime(&mut self, lifetime: &'v ast::Lifetime, _: ast_visit::LifetimeCtxt) {\n-        self.record(\"Lifetime\", Id::None, lifetime);\n-        ast_visit::walk_lifetime(self, lifetime)\n-    }\n-\n-    fn visit_mac_call(&mut self, mac: &'v ast::MacCall) {\n-        self.record(\"MacCall\", Id::None, mac);\n-        ast_visit::walk_mac(self, mac)\n-    }\n+    // `UseTree` has one inline use (in `ast::ItemKind::Use`) and one\n+    // non-inline use (in `ast::UseTreeKind::Nested). The former case is more\n+    // common, so we don't implement `visit_use_tree` and tolerate the missed\n+    // coverage in the latter case.\n \n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v ast::PathSegment) {\n         self.record(\"PathSegment\", Id::None, path_segment);\n         ast_visit::walk_path_segment(self, path_span, path_segment)\n     }\n \n-    fn visit_assoc_constraint(&mut self, constraint: &'v ast::AssocConstraint) {\n-        self.record(\"AssocConstraint\", Id::None, constraint);\n-        ast_visit::walk_assoc_constraint(self, constraint)\n+    // `GenericArgs` has one inline use (in `ast::AssocConstraint::gen_args`) and one\n+    // non-inline use (in `ast::PathSegment::args`). The latter case is more\n+    // common, so we implement `visit_generic_args` and tolerate the double\n+    // counting in the former case.\n+    fn visit_generic_args(&mut self, sp: Span, g: &'v ast::GenericArgs) {\n+        record_variants!((self, g, g, GenericArgs, GenericArgs), [AngleBracketed, Parenthesized]);\n+        ast_visit::walk_generic_args(self, sp, g)\n     }\n \n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n-        self.record(\"Attribute\", Id::None, attr);\n+        record_variants!((self, attr, attr.kind, Attribute, AttrKind), [Normal, DocComment]);\n+        ast_visit::walk_attribute(self, attr)\n+    }\n+\n+    fn visit_expr_field(&mut self, f: &'v ast::ExprField) {\n+        self.record(\"ExprField\", Id::None, f);\n+        ast_visit::walk_expr_field(self, f)\n+    }\n+\n+    fn visit_crate(&mut self, krate: &'v ast::Crate) {\n+        self.record(\"Crate\", Id::None, krate);\n+        ast_visit::walk_crate(self, krate)\n+    }\n+\n+    fn visit_inline_asm(&mut self, asm: &'v ast::InlineAsm) {\n+        self.record(\"InlineAsm\", Id::None, asm);\n+        ast_visit::walk_inline_asm(self, asm)\n     }\n }"}, {"sha": "cbd0ca49c99bc3c5bbe6ff10a41e12b34482db6e", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -3796,9 +3796,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ExprKind::Field(ref subexpression, _) => {\n                 self.resolve_expr(subexpression, Some(expr));\n             }\n-            ExprKind::MethodCall(ref segment, ref arguments, _) => {\n-                let mut arguments = arguments.iter();\n-                self.resolve_expr(arguments.next().unwrap(), Some(expr));\n+            ExprKind::MethodCall(ref segment, ref receiver, ref arguments, _) => {\n+                self.resolve_expr(receiver, Some(expr));\n                 for argument in arguments {\n                     self.resolve_expr(argument, None);\n                 }"}, {"sha": "cb133841bca5a2ac7c9ce97cc322fb280dd34615", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -2021,9 +2021,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n     fn suggest_introducing_lifetime(\n         &self,\n-        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        err: &mut Diagnostic,\n         name: Option<&str>,\n-        suggest: impl Fn(&mut DiagnosticBuilder<'_, ErrorGuaranteed>, bool, Span, &str, String) -> bool,\n+        suggest: impl Fn(&mut Diagnostic, bool, Span, &str, String) -> bool,\n     ) {\n         let mut suggest_note = true;\n         for rib in self.lifetime_ribs.iter().rev() {\n@@ -2149,7 +2149,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n     pub(crate) fn add_missing_lifetime_specifiers_label(\n         &mut self,\n-        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        err: &mut Diagnostic,\n         lifetime_refs: Vec<MissingLifetime>,\n         function_param_lifetimes: Option<(Vec<MissingLifetime>, Vec<ElisionFnParameter>)>,\n     ) {"}, {"sha": "758f1ef97664f1d4c6572e837342907561829fcd", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -16,7 +16,8 @@ use crate::require_c_abi_if_c_variadic;\n use rustc_ast::TraitObjectSyntax;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{\n-    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, MultiSpan,\n+    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, FatalError,\n+    MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n@@ -2106,7 +2107,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn prohibit_generics<'a>(\n         &self,\n         segments: impl Iterator<Item = &'a hir::PathSegment<'a>> + Clone,\n-        extend: impl Fn(&mut DiagnosticBuilder<'tcx, ErrorGuaranteed>),\n+        extend: impl Fn(&mut Diagnostic),\n     ) -> bool {\n         let args = segments.clone().flat_map(|segment| segment.args().args);\n \n@@ -2984,11 +2985,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     /// Make sure that we are in the condition to suggest the blanket implementation.\n-    fn maybe_lint_blanket_trait_impl<T: rustc_errors::EmissionGuarantee>(\n-        &self,\n-        self_ty: &hir::Ty<'_>,\n-        diag: &mut DiagnosticBuilder<'_, T>,\n-    ) {\n+    fn maybe_lint_blanket_trait_impl(&self, self_ty: &hir::Ty<'_>, diag: &mut Diagnostic) {\n         let tcx = self.tcx();\n         let parent_id = tcx.hir().get_parent_item(self_ty.hir_id);\n         if let hir::Node::Item(hir::Item {\n@@ -3081,7 +3078,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             sugg,\n                             Applicability::MachineApplicable,\n                         );\n-                        self.maybe_lint_blanket_trait_impl::<()>(&self_ty, &mut diag);\n+                        self.maybe_lint_blanket_trait_impl(&self_ty, &mut diag);\n                         diag.emit();\n                     },\n                 );"}, {"sha": "6c7b2a2889fa49526241835a6ef0c43c6c358b83", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -32,6 +32,7 @@ use super::FnCtxt;\n \n use crate::hir::def_id::DefId;\n use crate::type_error_struct;\n+use hir::def_id::LOCAL_CRATE;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n@@ -40,7 +41,7 @@ use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::cast::{CastKind, CastTy};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, Ty, TypeAndMut, TypeVisitable};\n+use rustc_middle::ty::{self, Ty, TypeAndMut, TypeVisitable, VariantDef};\n use rustc_session::lint;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n@@ -173,6 +174,7 @@ pub enum CastError {\n     /// or \"a length\". If this argument is None, then the metadata is unknown, for example,\n     /// when we're typechecking a type parameter with a ?Sized bound.\n     IntToFatCast(Option<&'static str>),\n+    ForeignNonExhaustiveAdt,\n }\n \n impl From<ErrorGuaranteed> for CastError {\n@@ -591,6 +593,17 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 }\n                 err.emit();\n             }\n+            CastError::ForeignNonExhaustiveAdt => {\n+                make_invalid_casting_error(\n+                    fcx.tcx.sess,\n+                    self.span,\n+                    self.expr_ty,\n+                    self.cast_ty,\n+                    fcx,\n+                )\n+                .note(\"cannot cast an enum with a non-exhaustive variant when it's defined in another crate\")\n+                .emit();\n+            }\n         }\n     }\n \n@@ -789,6 +802,14 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             _ => return Err(CastError::NonScalar),\n         };\n \n+        if let ty::Adt(adt_def, _) = *self.expr_ty.kind() {\n+            if adt_def.did().krate != LOCAL_CRATE {\n+                if adt_def.variants().iter().any(VariantDef::is_field_list_non_exhaustive) {\n+                    return Err(CastError::ForeignNonExhaustiveAdt);\n+                }\n+            }\n+        }\n+\n         match (t_from, t_cast) {\n             // These types have invariants! can't cast into them.\n             (_, Int(CEnum) | FnPtr) => Err(CastError::NonScalar),"}, {"sha": "5cdb2acd9f3c5b24cf91b65549dafd2f5d527ee7", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -1525,9 +1525,7 @@ fn detect_discriminant_duplicate<'tcx>(\n ) {\n     // Helper closure to reduce duplicate code. This gets called everytime we detect a duplicate.\n     // Here `idx` refers to the order of which the discriminant appears, and its index in `vs`\n-    let report = |dis: Discr<'tcx>,\n-                  idx: usize,\n-                  err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>| {\n+    let report = |dis: Discr<'tcx>, idx: usize, err: &mut Diagnostic| {\n         let var = &vs[idx]; // HIR for the duplicate discriminant\n         let (span, display_discr) = match var.disr_expr {\n             Some(ref expr) => {"}, {"sha": "6c6bbfa22e30cab47a4cf5e52b86efb9aeca1df2", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -1585,9 +1585,9 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             }\n         }\n     }\n-    fn note_unreachable_loop_return<'a>(\n+    fn note_unreachable_loop_return(\n         &self,\n-        err: &mut DiagnosticBuilder<'a, ErrorGuaranteed>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'tcx>,\n         ret_exprs: &Vec<&'tcx hir::Expr<'tcx>>,\n     ) {"}, {"sha": "6a6c03a8cba836dfaabfad107b95d7a88e80fea8", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -28,7 +28,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticId,\n-    EmissionGuarantee, ErrorGuaranteed,\n+    ErrorGuaranteed,\n };\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n@@ -879,7 +879,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         lhs: &'tcx hir::Expr<'tcx>,\n         err_code: &'static str,\n         op_span: Span,\n-        adjust_err: impl FnOnce(&mut DiagnosticBuilder<'tcx, ErrorGuaranteed>),\n+        adjust_err: impl FnOnce(&mut Diagnostic),\n     ) {\n         if lhs.is_syntactic_place_expr() {\n             return;\n@@ -1089,8 +1089,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n \n-        let suggest_deref_binop = |err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n-                                   rhs_ty: Ty<'tcx>| {\n+        let suggest_deref_binop = |err: &mut Diagnostic, rhs_ty: Ty<'tcx>| {\n             if let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty) {\n                 // Can only assign if the type is sized, so if `DerefMut` yields a type that is\n                 // unsized, do not suggest dereferencing it.\n@@ -2205,9 +2204,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx().ty_error()\n     }\n \n-    fn check_call_constructor<G: EmissionGuarantee>(\n+    fn check_call_constructor(\n         &self,\n-        err: &mut DiagnosticBuilder<'_, G>,\n+        err: &mut Diagnostic,\n         base: &'tcx hir::Expr<'tcx>,\n         def_id: DefId,\n     ) {"}, {"sha": "1d1f755947fdcde4a167d5776f08a80c8746af3c", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -1778,7 +1778,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn label_fn_like(\n         &self,\n-        err: &mut rustc_errors::DiagnosticBuilder<'tcx, rustc_errors::ErrorGuaranteed>,\n+        err: &mut Diagnostic,\n         callable_def_id: Option<DefId>,\n         callee_ty: Option<Ty<'tcx>>,\n     ) {"}, {"sha": "44c7c148c7533145606e83e4275cec0f84e31b1e", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -904,7 +904,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                let label_span_not_found = |err: &mut DiagnosticBuilder<'_, _>| {\n+                let label_span_not_found = |err: &mut Diagnostic| {\n                     if unsatisfied_predicates.is_empty() {\n                         err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n                         let is_string_or_ref_str = match actual.kind() {\n@@ -1154,7 +1154,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         rcvr_ty: Ty<'tcx>,\n         expr: &hir::Expr<'_>,\n         item_name: Ident,\n-        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        err: &mut Diagnostic,\n     ) -> bool {\n         let tcx = self.tcx;\n         let field_receiver = self.autoderef(span, rcvr_ty).find_map(|(ty, _)| match ty.kind() {\n@@ -1331,7 +1331,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_for_field_method(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        err: &mut Diagnostic,\n         source: SelfSource<'tcx>,\n         span: Span,\n         actual: Ty<'tcx>,\n@@ -1380,7 +1380,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_for_unwrap_self(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        err: &mut Diagnostic,\n         source: SelfSource<'tcx>,\n         span: Span,\n         actual: Ty<'tcx>,"}, {"sha": "1b50209ee64ccdc1443e5d538760b5ba471957ce", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -104,7 +104,7 @@ use crate::astconv::AstConv;\n use crate::check::gather_locals::GatherLocalsVisitor;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{\n-    pluralize, struct_span_err, Applicability, DiagnosticBuilder, EmissionGuarantee, MultiSpan,\n+    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -973,12 +973,7 @@ fn has_expected_num_generic_args<'tcx>(\n /// * `span` - The span of the snippet\n /// * `params` - The number of parameters the constructor accepts\n /// * `err` - A mutable diagnostic builder to add the suggestion to\n-fn suggest_call_constructor<G: EmissionGuarantee>(\n-    span: Span,\n-    kind: CtorOf,\n-    params: usize,\n-    err: &mut DiagnosticBuilder<'_, G>,\n-) {\n+fn suggest_call_constructor(span: Span, kind: CtorOf, params: usize, err: &mut Diagnostic) {\n     // Note: tuple-structs don't have named fields, so just use placeholders\n     let args = vec![\"_\"; params].join(\", \");\n     let applicable = if params > 0 {"}, {"sha": "eb0c51bb2f9795052a3c7eac68668edeed476e31", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 {\n                     // Suppress this error, since we already emitted\n                     // a deref suggestion in check_overloaded_binop\n-                    err.delay_as_bug();\n+                    err.downgrade_to_delayed_bug();\n                 }\n             }\n         });"}, {"sha": "c0f609a01b5c85f8b794262fce70d3cd2ffa375a", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -95,8 +95,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This is a bit safer than `as` because it wouldn't silently change the type if the code is\n     /// refactored.\n-    #[unstable(feature = \"ptr_const_cast\", issue = \"92675\")]\n-    #[rustc_const_unstable(feature = \"ptr_const_cast\", issue = \"92675\")]\n+    #[stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n+    #[rustc_const_stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n     pub const fn cast_mut(self) -> *mut T {\n         self as _\n     }"}, {"sha": "7059d0008c4c4d1a3de189b5c94154c5c6def2e3", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -100,8 +100,8 @@ impl<T: ?Sized> *mut T {\n     /// coercion.\n     ///\n     /// [`cast_mut`]: #method.cast_mut\n-    #[unstable(feature = \"ptr_const_cast\", issue = \"92675\")]\n-    #[rustc_const_unstable(feature = \"ptr_const_cast\", issue = \"92675\")]\n+    #[stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n+    #[rustc_const_stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n     pub const fn cast_const(self) -> *const T {\n         self as _\n     }"}, {"sha": "7db3065dee0838c1e014b43bf9694d1dc7ecaad0", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -116,11 +116,9 @@ impl Thread {\n         debug_assert_eq!(ret, 0);\n     }\n \n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    #[cfg(target_os = \"android\")]\n     pub fn set_name(name: &CStr) {\n         const PR_SET_NAME: libc::c_int = 15;\n-        // pthread wrapper only appeared in glibc 2.12, so we use syscall\n-        // directly.\n         unsafe {\n             libc::prctl(\n                 PR_SET_NAME,\n@@ -132,6 +130,14 @@ impl Thread {\n         }\n     }\n \n+    #[cfg(target_os = \"linux\")]\n+    pub fn set_name(name: &CStr) {\n+        unsafe {\n+            // Available since glibc 2.12, musl 1.1.16, and uClibc 1.0.20.\n+            libc::pthread_setname_np(libc::pthread_self(), name.as_ptr());\n+        }\n+    }\n+\n     #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"openbsd\"))]\n     pub fn set_name(name: &CStr) {\n         unsafe {"}, {"sha": "baad0c75295a575b03ee00c06e5b4e92e9aecce2", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -924,6 +924,11 @@ fn compare_browser_ui_test_version(installed_version: &str, src: &Path) {\n                      one used in the CI (`{}`)\",\n                     installed_version, v\n                 );\n+                eprintln!(\n+                    \"You can install this version using `npm update browser-ui-test` or by using \\\n+                     `npm install browser-ui-test@{}`\",\n+                    v,\n+                );\n             }\n         }\n         Err(e) => eprintln!(\"Couldn't find the CI browser-ui-test version: {:?}\", e),"}, {"sha": "da15c3c2b1fabe2dd2ebf888fc2d7bb737077cdf", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             items: cx.tcx\n                                 .associated_items(impl_def_id)\n                                 .in_definition_order()\n-                                .map(|x| x.clean(cx))\n+                                .map(|x| clean_middle_assoc_item(x, cx))\n                                 .collect::<Vec<_>>(),\n                             polarity: ty::ImplPolarity::Positive,\n                             kind: ImplKind::Blanket(Box::new(clean_middle_ty(trait_ref.0.self_ty(), cx, None))),"}, {"sha": "e56a715e85780668e0a0a5915390d5c320300a35", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -16,9 +16,10 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n-    self, clean_fn_decl_from_did_and_sig, clean_generics, clean_impl_item, clean_middle_field,\n-    clean_middle_ty, clean_trait_ref_with_bindings, clean_ty, clean_ty_generics, clean_variant_def,\n-    clean_visibility, utils, Attributes, AttributesExt, Clean, ImplKind, ItemId, Type, Visibility,\n+    self, clean_fn_decl_from_did_and_sig, clean_generics, clean_impl_item, clean_middle_assoc_item,\n+    clean_middle_field, clean_middle_ty, clean_trait_ref_with_bindings, clean_ty,\n+    clean_ty_generics, clean_variant_def, clean_visibility, utils, Attributes, AttributesExt,\n+    ImplKind, ItemId, Type, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -217,7 +218,7 @@ pub(crate) fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean\n             // which causes methods to have a `pub` prefix, which is invalid since items in traits\n             // can not have a visibility prefix. Thus we override the visibility here manually.\n             // See https://github.com/rust-lang/rust/issues/81274\n-            clean::Item { visibility: Visibility::Inherited, ..item.clean(cx) }\n+            clean::Item { visibility: Visibility::Inherited, ..clean_middle_assoc_item(item, cx) }\n         })\n         .collect();\n \n@@ -452,7 +453,7 @@ pub(crate) fn build_impl(\n                         item.visibility(tcx).is_public()\n                     }\n                 })\n-                .map(|item| item.clean(cx))\n+                .map(|item| clean_middle_assoc_item(item, cx))\n                 .collect::<Vec<_>>(),\n             clean::enter_impl_trait(cx, |cx| {\n                 clean_ty_generics(cx, tcx.generics_of(did), predicates)"}, {"sha": "6e24638548979bfc71895839f23a335b712e636b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 206, "deletions": 196, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -123,7 +123,7 @@ fn clean_generic_bound<'tcx>(\n \n             let trait_ref = ty::TraitRef::identity(cx.tcx, def_id).skip_binder();\n \n-            let generic_args = generic_args.clean(cx);\n+            let generic_args = clean_generic_args(generic_args, cx);\n             let GenericArgs::AngleBracketed { bindings, .. } = generic_args\n             else {\n                 bug!(\"clean: parenthesized `GenericBound::LangItemTrait`\");\n@@ -1092,199 +1092,201 @@ pub(crate) fn clean_impl_item<'tcx>(\n     })\n }\n \n-impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        let tcx = cx.tcx;\n-        let kind = match self.kind {\n-            ty::AssocKind::Const => {\n-                let ty = clean_middle_ty(tcx.type_of(self.def_id), cx, Some(self.def_id));\n-\n-                let provided = match self.container {\n-                    ty::ImplContainer => true,\n-                    ty::TraitContainer => tcx.impl_defaultness(self.def_id).has_value(),\n-                };\n-                if provided {\n-                    AssocConstItem(ty, ConstantKind::Extern { def_id: self.def_id })\n-                } else {\n-                    TyAssocConstItem(ty)\n-                }\n+pub(crate) fn clean_middle_assoc_item<'tcx>(\n+    assoc_item: &ty::AssocItem,\n+    cx: &mut DocContext<'tcx>,\n+) -> Item {\n+    let tcx = cx.tcx;\n+    let kind = match assoc_item.kind {\n+        ty::AssocKind::Const => {\n+            let ty = clean_middle_ty(tcx.type_of(assoc_item.def_id), cx, Some(assoc_item.def_id));\n+\n+            let provided = match assoc_item.container {\n+                ty::ImplContainer => true,\n+                ty::TraitContainer => tcx.impl_defaultness(assoc_item.def_id).has_value(),\n+            };\n+            if provided {\n+                AssocConstItem(ty, ConstantKind::Extern { def_id: assoc_item.def_id })\n+            } else {\n+                TyAssocConstItem(ty)\n             }\n-            ty::AssocKind::Fn => {\n-                let generics = clean_ty_generics(\n-                    cx,\n-                    tcx.generics_of(self.def_id),\n-                    tcx.explicit_predicates_of(self.def_id),\n-                );\n-                let sig = tcx.fn_sig(self.def_id);\n-                let mut decl = clean_fn_decl_from_did_and_sig(cx, Some(self.def_id), sig);\n-\n-                if self.fn_has_self_parameter {\n-                    let self_ty = match self.container {\n-                        ty::ImplContainer => tcx.type_of(self.container_id(tcx)),\n-                        ty::TraitContainer => tcx.types.self_param,\n-                    };\n-                    let self_arg_ty = sig.input(0).skip_binder();\n-                    if self_arg_ty == self_ty {\n-                        decl.inputs.values[0].type_ = Generic(kw::SelfUpper);\n-                    } else if let ty::Ref(_, ty, _) = *self_arg_ty.kind() {\n-                        if ty == self_ty {\n-                            match decl.inputs.values[0].type_ {\n-                                BorrowedRef { ref mut type_, .. } => {\n-                                    **type_ = Generic(kw::SelfUpper)\n-                                }\n-                                _ => unreachable!(),\n-                            }\n+        }\n+        ty::AssocKind::Fn => {\n+            let generics = clean_ty_generics(\n+                cx,\n+                tcx.generics_of(assoc_item.def_id),\n+                tcx.explicit_predicates_of(assoc_item.def_id),\n+            );\n+            let sig = tcx.fn_sig(assoc_item.def_id);\n+            let mut decl = clean_fn_decl_from_did_and_sig(cx, Some(assoc_item.def_id), sig);\n+\n+            if assoc_item.fn_has_self_parameter {\n+                let self_ty = match assoc_item.container {\n+                    ty::ImplContainer => tcx.type_of(assoc_item.container_id(tcx)),\n+                    ty::TraitContainer => tcx.types.self_param,\n+                };\n+                let self_arg_ty = sig.input(0).skip_binder();\n+                if self_arg_ty == self_ty {\n+                    decl.inputs.values[0].type_ = Generic(kw::SelfUpper);\n+                } else if let ty::Ref(_, ty, _) = *self_arg_ty.kind() {\n+                    if ty == self_ty {\n+                        match decl.inputs.values[0].type_ {\n+                            BorrowedRef { ref mut type_, .. } => **type_ = Generic(kw::SelfUpper),\n+                            _ => unreachable!(),\n                         }\n                     }\n                 }\n+            }\n \n-                let provided = match self.container {\n-                    ty::ImplContainer => true,\n-                    ty::TraitContainer => self.defaultness(tcx).has_value(),\n+            let provided = match assoc_item.container {\n+                ty::ImplContainer => true,\n+                ty::TraitContainer => assoc_item.defaultness(tcx).has_value(),\n+            };\n+            if provided {\n+                let defaultness = match assoc_item.container {\n+                    ty::ImplContainer => Some(assoc_item.defaultness(tcx)),\n+                    ty::TraitContainer => None,\n                 };\n-                if provided {\n-                    let defaultness = match self.container {\n-                        ty::ImplContainer => Some(self.defaultness(tcx)),\n-                        ty::TraitContainer => None,\n-                    };\n-                    MethodItem(Box::new(Function { generics, decl }), defaultness)\n-                } else {\n-                    TyMethodItem(Box::new(Function { generics, decl }))\n-                }\n+                MethodItem(Box::new(Function { generics, decl }), defaultness)\n+            } else {\n+                TyMethodItem(Box::new(Function { generics, decl }))\n             }\n-            ty::AssocKind::Type => {\n-                let my_name = self.name;\n-\n-                fn param_eq_arg(param: &GenericParamDef, arg: &GenericArg) -> bool {\n-                    match (&param.kind, arg) {\n-                        (GenericParamDefKind::Type { .. }, GenericArg::Type(Type::Generic(ty)))\n-                            if *ty == param.name =>\n-                        {\n-                            true\n-                        }\n-                        (\n-                            GenericParamDefKind::Lifetime { .. },\n-                            GenericArg::Lifetime(Lifetime(lt)),\n-                        ) if *lt == param.name => true,\n-                        (GenericParamDefKind::Const { .. }, GenericArg::Const(c)) => {\n-                            match &c.kind {\n-                                ConstantKind::TyConst { expr } => expr == param.name.as_str(),\n-                                _ => false,\n-                            }\n-                        }\n-                        _ => false,\n+        }\n+        ty::AssocKind::Type => {\n+            let my_name = assoc_item.name;\n+\n+            fn param_eq_arg(param: &GenericParamDef, arg: &GenericArg) -> bool {\n+                match (&param.kind, arg) {\n+                    (GenericParamDefKind::Type { .. }, GenericArg::Type(Type::Generic(ty)))\n+                        if *ty == param.name =>\n+                    {\n+                        true\n+                    }\n+                    (GenericParamDefKind::Lifetime { .. }, GenericArg::Lifetime(Lifetime(lt)))\n+                        if *lt == param.name =>\n+                    {\n+                        true\n                     }\n+                    (GenericParamDefKind::Const { .. }, GenericArg::Const(c)) => match &c.kind {\n+                        ConstantKind::TyConst { expr } => expr == param.name.as_str(),\n+                        _ => false,\n+                    },\n+                    _ => false,\n                 }\n+            }\n \n-                if let ty::TraitContainer = self.container {\n-                    let bounds = tcx.explicit_item_bounds(self.def_id);\n-                    let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n-                    let mut generics =\n-                        clean_ty_generics(cx, tcx.generics_of(self.def_id), predicates);\n-                    // Filter out the bounds that are (likely?) directly attached to the associated type,\n-                    // as opposed to being located in the where clause.\n-                    let mut bounds = generics\n-                        .where_predicates\n-                        .drain_filter(|pred| match *pred {\n-                            WherePredicate::BoundPredicate {\n-                                ty: QPath { ref assoc, ref self_type, ref trait_, .. },\n-                                ..\n-                            } => {\n-                                if assoc.name != my_name {\n-                                    return false;\n-                                }\n-                                if trait_.def_id() != self.container_id(tcx) {\n-                                    return false;\n-                                }\n-                                match **self_type {\n-                                    Generic(ref s) if *s == kw::SelfUpper => {}\n-                                    _ => return false,\n-                                }\n-                                match &assoc.args {\n-                                    GenericArgs::AngleBracketed { args, bindings } => {\n-                                        if !bindings.is_empty()\n-                                            || generics\n-                                                .params\n-                                                .iter()\n-                                                .zip(args.iter())\n-                                                .any(|(param, arg)| !param_eq_arg(param, arg))\n-                                        {\n-                                            return false;\n-                                        }\n-                                    }\n-                                    GenericArgs::Parenthesized { .. } => {\n-                                        // The only time this happens is if we're inside the rustdoc for Fn(),\n-                                        // which only has one associated type, which is not a GAT, so whatever.\n+            if let ty::TraitContainer = assoc_item.container {\n+                let bounds = tcx.explicit_item_bounds(assoc_item.def_id);\n+                let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n+                let mut generics =\n+                    clean_ty_generics(cx, tcx.generics_of(assoc_item.def_id), predicates);\n+                // Filter out the bounds that are (likely?) directly attached to the associated type,\n+                // as opposed to being located in the where clause.\n+                let mut bounds = generics\n+                    .where_predicates\n+                    .drain_filter(|pred| match *pred {\n+                        WherePredicate::BoundPredicate {\n+                            ty: QPath { ref assoc, ref self_type, ref trait_, .. },\n+                            ..\n+                        } => {\n+                            if assoc.name != my_name {\n+                                return false;\n+                            }\n+                            if trait_.def_id() != assoc_item.container_id(tcx) {\n+                                return false;\n+                            }\n+                            match **self_type {\n+                                Generic(ref s) if *s == kw::SelfUpper => {}\n+                                _ => return false,\n+                            }\n+                            match &assoc.args {\n+                                GenericArgs::AngleBracketed { args, bindings } => {\n+                                    if !bindings.is_empty()\n+                                        || generics\n+                                            .params\n+                                            .iter()\n+                                            .zip(args.iter())\n+                                            .any(|(param, arg)| !param_eq_arg(param, arg))\n+                                    {\n+                                        return false;\n                                     }\n                                 }\n-                                true\n-                            }\n-                            _ => false,\n-                        })\n-                        .flat_map(|pred| {\n-                            if let WherePredicate::BoundPredicate { bounds, .. } = pred {\n-                                bounds\n-                            } else {\n-                                unreachable!()\n+                                GenericArgs::Parenthesized { .. } => {\n+                                    // The only time this happens is if we're inside the rustdoc for Fn(),\n+                                    // which only has one associated type, which is not a GAT, so whatever.\n+                                }\n                             }\n-                        })\n-                        .collect::<Vec<_>>();\n-                    // Our Sized/?Sized bound didn't get handled when creating the generics\n-                    // because we didn't actually get our whole set of bounds until just now\n-                    // (some of them may have come from the trait). If we do have a sized\n-                    // bound, we remove it, and if we don't then we add the `?Sized` bound\n-                    // at the end.\n-                    match bounds.iter().position(|b| b.is_sized_bound(cx)) {\n-                        Some(i) => {\n-                            bounds.remove(i);\n+                            true\n                         }\n-                        None => bounds.push(GenericBound::maybe_sized(cx)),\n+                        _ => false,\n+                    })\n+                    .flat_map(|pred| {\n+                        if let WherePredicate::BoundPredicate { bounds, .. } = pred {\n+                            bounds\n+                        } else {\n+                            unreachable!()\n+                        }\n+                    })\n+                    .collect::<Vec<_>>();\n+                // Our Sized/?Sized bound didn't get handled when creating the generics\n+                // because we didn't actually get our whole set of bounds until just now\n+                // (some of them may have come from the trait). If we do have a sized\n+                // bound, we remove it, and if we don't then we add the `?Sized` bound\n+                // at the end.\n+                match bounds.iter().position(|b| b.is_sized_bound(cx)) {\n+                    Some(i) => {\n+                        bounds.remove(i);\n                     }\n+                    None => bounds.push(GenericBound::maybe_sized(cx)),\n+                }\n \n-                    if tcx.impl_defaultness(self.def_id).has_value() {\n-                        AssocTypeItem(\n-                            Box::new(Typedef {\n-                                type_: clean_middle_ty(\n-                                    tcx.type_of(self.def_id),\n-                                    cx,\n-                                    Some(self.def_id),\n-                                ),\n-                                generics,\n-                                // FIXME: should we obtain the Type from HIR and pass it on here?\n-                                item_type: None,\n-                            }),\n-                            bounds,\n-                        )\n-                    } else {\n-                        TyAssocTypeItem(Box::new(generics), bounds)\n-                    }\n-                } else {\n-                    // FIXME: when could this happen? Associated items in inherent impls?\n+                if tcx.impl_defaultness(assoc_item.def_id).has_value() {\n                     AssocTypeItem(\n                         Box::new(Typedef {\n-                            type_: clean_middle_ty(tcx.type_of(self.def_id), cx, Some(self.def_id)),\n-                            generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n+                            type_: clean_middle_ty(\n+                                tcx.type_of(assoc_item.def_id),\n+                                cx,\n+                                Some(assoc_item.def_id),\n+                            ),\n+                            generics,\n+                            // FIXME: should we obtain the Type from HIR and pass it on here?\n                             item_type: None,\n                         }),\n-                        Vec::new(),\n+                        bounds,\n                     )\n+                } else {\n+                    TyAssocTypeItem(Box::new(generics), bounds)\n                 }\n+            } else {\n+                // FIXME: when could this happen? Associated items in inherent impls?\n+                AssocTypeItem(\n+                    Box::new(Typedef {\n+                        type_: clean_middle_ty(\n+                            tcx.type_of(assoc_item.def_id),\n+                            cx,\n+                            Some(assoc_item.def_id),\n+                        ),\n+                        generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n+                        item_type: None,\n+                    }),\n+                    Vec::new(),\n+                )\n             }\n-        };\n+        }\n+    };\n \n-        let mut what_rustc_thinks =\n-            Item::from_def_id_and_parts(self.def_id, Some(self.name), kind, cx);\n+    let mut what_rustc_thinks =\n+        Item::from_def_id_and_parts(assoc_item.def_id, Some(assoc_item.name), kind, cx);\n \n-        let impl_ref = tcx.impl_trait_ref(tcx.parent(self.def_id));\n+    let impl_ref = tcx.impl_trait_ref(tcx.parent(assoc_item.def_id));\n \n-        // Trait impl items always inherit the impl's visibility --\n-        // we don't want to show `pub`.\n-        if impl_ref.is_some() {\n-            what_rustc_thinks.visibility = Visibility::Inherited;\n-        }\n-\n-        what_rustc_thinks\n+    // Trait impl items always inherit the impl's visibility --\n+    // we don't want to show `pub`.\n+    if impl_ref.is_some() {\n+        what_rustc_thinks.visibility = Visibility::Inherited;\n     }\n+\n+    what_rustc_thinks\n }\n \n fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type {\n@@ -1824,39 +1826,44 @@ fn clean_path<'tcx>(path: &hir::Path<'tcx>, cx: &mut DocContext<'tcx>) -> Path {\n     Path { res: path.res, segments: path.segments.iter().map(|x| x.clean(cx)).collect() }\n }\n \n-impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericArgs {\n-        if self.parenthesized {\n-            let output = clean_ty(self.bindings[0].ty(), cx);\n-            let output =\n-                if output != Type::Tuple(Vec::new()) { Some(Box::new(output)) } else { None };\n-            let inputs = self.inputs().iter().map(|x| clean_ty(x, cx)).collect::<Vec<_>>().into();\n-            GenericArgs::Parenthesized { inputs, output }\n-        } else {\n-            let args = self\n-                .args\n-                .iter()\n-                .map(|arg| match arg {\n-                    hir::GenericArg::Lifetime(lt) if !lt.is_elided() => {\n-                        GenericArg::Lifetime(clean_lifetime(*lt, cx))\n-                    }\n-                    hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n-                    hir::GenericArg::Type(ty) => GenericArg::Type(clean_ty(ty, cx)),\n-                    hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(clean_const(ct, cx))),\n-                    hir::GenericArg::Infer(_inf) => GenericArg::Infer,\n-                })\n-                .collect::<Vec<_>>()\n-                .into();\n-            let bindings =\n-                self.bindings.iter().map(|x| clean_type_binding(x, cx)).collect::<Vec<_>>().into();\n-            GenericArgs::AngleBracketed { args, bindings }\n-        }\n+fn clean_generic_args<'tcx>(\n+    generic_args: &hir::GenericArgs<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> GenericArgs {\n+    if generic_args.parenthesized {\n+        let output = clean_ty(generic_args.bindings[0].ty(), cx);\n+        let output = if output != Type::Tuple(Vec::new()) { Some(Box::new(output)) } else { None };\n+        let inputs =\n+            generic_args.inputs().iter().map(|x| clean_ty(x, cx)).collect::<Vec<_>>().into();\n+        GenericArgs::Parenthesized { inputs, output }\n+    } else {\n+        let args = generic_args\n+            .args\n+            .iter()\n+            .map(|arg| match arg {\n+                hir::GenericArg::Lifetime(lt) if !lt.is_elided() => {\n+                    GenericArg::Lifetime(clean_lifetime(*lt, cx))\n+                }\n+                hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n+                hir::GenericArg::Type(ty) => GenericArg::Type(clean_ty(ty, cx)),\n+                hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(clean_const(ct, cx))),\n+                hir::GenericArg::Infer(_inf) => GenericArg::Infer,\n+            })\n+            .collect::<Vec<_>>()\n+            .into();\n+        let bindings = generic_args\n+            .bindings\n+            .iter()\n+            .map(|x| clean_type_binding(x, cx))\n+            .collect::<Vec<_>>()\n+            .into();\n+        GenericArgs::AngleBracketed { args, bindings }\n     }\n }\n \n impl<'tcx> Clean<'tcx, PathSegment> for hir::PathSegment<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> PathSegment {\n-        PathSegment { name: self.ident.name, args: self.args().clean(cx) }\n+        PathSegment { name: self.ident.name, args: clean_generic_args(self.args(), cx) }\n     }\n }\n \n@@ -2226,7 +2233,10 @@ fn clean_type_binding<'tcx>(\n     cx: &mut DocContext<'tcx>,\n ) -> TypeBinding {\n     TypeBinding {\n-        assoc: PathSegment { name: type_binding.ident.name, args: type_binding.gen_args.clean(cx) },\n+        assoc: PathSegment {\n+            name: type_binding.ident.name,\n+            args: clean_generic_args(type_binding.gen_args, cx),\n+        },\n         kind: match type_binding.kind {\n             hir::TypeBindingKind::Equality { ref term } => {\n                 TypeBindingKind::Equality { term: clean_hir_term(term, cx) }"}, {"sha": "91d5758077c94fd98b7f9d1c22425af573274dab", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -2495,14 +2495,15 @@ impl SubstParam {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     use super::*;\n+    use rustc_data_structures::static_assert_size;\n     // These are in alphabetical order, which is easy to maintain.\n-    rustc_data_structures::static_assert_size!(Crate, 72); // frequently moved by-value\n-    rustc_data_structures::static_assert_size!(DocFragment, 32);\n-    rustc_data_structures::static_assert_size!(GenericArg, 80);\n-    rustc_data_structures::static_assert_size!(GenericArgs, 32);\n-    rustc_data_structures::static_assert_size!(GenericParamDef, 56);\n-    rustc_data_structures::static_assert_size!(Item, 56);\n-    rustc_data_structures::static_assert_size!(ItemKind, 112);\n-    rustc_data_structures::static_assert_size!(PathSegment, 40);\n-    rustc_data_structures::static_assert_size!(Type, 72);\n+    static_assert_size!(Crate, 72); // frequently moved by-value\n+    static_assert_size!(DocFragment, 32);\n+    static_assert_size!(GenericArg, 80);\n+    static_assert_size!(GenericArgs, 32);\n+    static_assert_size!(GenericParamDef, 56);\n+    static_assert_size!(Item, 56);\n+    static_assert_size!(ItemKind, 112);\n+    static_assert_size!(PathSegment, 40);\n+    static_assert_size!(Type, 72);\n }"}, {"sha": "73fdf14049896a8f6d7c522b78a3c92271e4fc7f", "filename": "src/test/mir-opt/const_prop/boxes.main.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.main.ConstProp.diff?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -12,8 +12,6 @@\n       let mut _7: std::boxed::Box<i32>;    // in scope 0 at $DIR/boxes.rs:+1:14: +1:22\n       let mut _8: *const i32;              // in scope 0 at $DIR/boxes.rs:+1:14: +1:22\n       let mut _9: *const i32;              // in scope 0 at $DIR/boxes.rs:+1:14: +1:22\n-      let mut _10: *const i32;             // in scope 0 at $DIR/boxes.rs:+1:14: +1:22\n-      let mut _11: *const i32;             // in scope 0 at $DIR/boxes.rs:+1:14: +1:22\n       scope 1 {\n           debug x => _1;                   // in scope 1 at $DIR/boxes.rs:+1:9: +1:10\n       }"}, {"sha": "5dfcd2d54ca27ae63bcc29fc656485dc91e0d5f4", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.32bit.diff", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -10,15 +10,14 @@\n       let mut _5: std::boxed::Box<std::vec::Vec<u32>>; // in scope 0 at $DIR/inline-into-box-place.rs:+1:29: +1:43\n       let mut _6: ();                      // in scope 0 at $DIR/inline-into-box-place.rs:+1:42: +1:43\n       let mut _7: *const std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:+1:29: +1:43\n-      let mut _8: *const std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:+1:29: +1:43\n-+     let mut _9: &mut std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n++     let mut _8: &mut std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n       scope 1 {\n           debug _x => _1;                  // in scope 1 at $DIR/inline-into-box-place.rs:+1:9: +1:11\n       }\n       scope 2 {\n       }\n +     scope 3 (inlined Vec::<u32>::new) {  // at $DIR/inline-into-box-place.rs:8:33: 8:43\n-+         let mut _10: alloc::raw_vec::RawVec<u32>; // in scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         let mut _9: alloc::raw_vec::RawVec<u32>; // in scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +     }\n   \n       bb0: {\n@@ -37,10 +36,10 @@\n           StorageLive(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n           _7 = (((_5.0: std::ptr::Unique<std::vec::Vec<u32>>).0: std::ptr::NonNull<std::vec::Vec<u32>>).0: *const std::vec::Vec<u32>); // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n -         (*_7) = Vec::<u32>::new() -> [return: bb2, unwind: bb4]; // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n-+         StorageLive(_9);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n-+         _9 = &mut (*_7);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n-+         StorageLive(_10);                // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         _10 = const alloc::raw_vec::RawVec::<u32>::NEW; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         StorageLive(_8);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n++         _8 = &mut (*_7);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n++         StorageLive(_9);                 // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         _9 = const alloc::raw_vec::RawVec::<u32>::NEW; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n                                            // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:33: 8:41\n -                                          // + user_ty: UserType(1)\n@@ -51,11 +50,11 @@\n +                                          // + span: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +                                          // + user_ty: UserType(0)\n +                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Unevaluated(alloc::raw_vec::RawVec::<T>::NEW, [u32], None) }\n-+         Deinit((*_9));                   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         ((*_9).0: alloc::raw_vec::RawVec<u32>) = move _10; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         ((*_9).1: usize) = const 0_usize; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         StorageDead(_10);                // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         StorageDead(_9);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n++         Deinit((*_8));                   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         ((*_8).0: alloc::raw_vec::RawVec<u32>) = move _9; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         ((*_8).1: usize) = const 0_usize; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         StorageDead(_9);                 // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         StorageDead(_8);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n           StorageDead(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n           _1 = move _5;                    // scope 0 at $DIR/inline-into-box-place.rs:+1:29: +1:43\n           StorageDead(_5);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:42: +1:43"}, {"sha": "5dfcd2d54ca27ae63bcc29fc656485dc91e0d5f4", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.64bit.diff", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -10,15 +10,14 @@\n       let mut _5: std::boxed::Box<std::vec::Vec<u32>>; // in scope 0 at $DIR/inline-into-box-place.rs:+1:29: +1:43\n       let mut _6: ();                      // in scope 0 at $DIR/inline-into-box-place.rs:+1:42: +1:43\n       let mut _7: *const std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:+1:29: +1:43\n-      let mut _8: *const std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:+1:29: +1:43\n-+     let mut _9: &mut std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n++     let mut _8: &mut std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n       scope 1 {\n           debug _x => _1;                  // in scope 1 at $DIR/inline-into-box-place.rs:+1:9: +1:11\n       }\n       scope 2 {\n       }\n +     scope 3 (inlined Vec::<u32>::new) {  // at $DIR/inline-into-box-place.rs:8:33: 8:43\n-+         let mut _10: alloc::raw_vec::RawVec<u32>; // in scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         let mut _9: alloc::raw_vec::RawVec<u32>; // in scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +     }\n   \n       bb0: {\n@@ -37,10 +36,10 @@\n           StorageLive(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n           _7 = (((_5.0: std::ptr::Unique<std::vec::Vec<u32>>).0: std::ptr::NonNull<std::vec::Vec<u32>>).0: *const std::vec::Vec<u32>); // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n -         (*_7) = Vec::<u32>::new() -> [return: bb2, unwind: bb4]; // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n-+         StorageLive(_9);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n-+         _9 = &mut (*_7);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n-+         StorageLive(_10);                // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         _10 = const alloc::raw_vec::RawVec::<u32>::NEW; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         StorageLive(_8);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n++         _8 = &mut (*_7);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n++         StorageLive(_9);                 // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         _9 = const alloc::raw_vec::RawVec::<u32>::NEW; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n                                            // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:33: 8:41\n -                                          // + user_ty: UserType(1)\n@@ -51,11 +50,11 @@\n +                                          // + span: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +                                          // + user_ty: UserType(0)\n +                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Unevaluated(alloc::raw_vec::RawVec::<T>::NEW, [u32], None) }\n-+         Deinit((*_9));                   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         ((*_9).0: alloc::raw_vec::RawVec<u32>) = move _10; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         ((*_9).1: usize) = const 0_usize; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         StorageDead(_10);                // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         StorageDead(_9);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n++         Deinit((*_8));                   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         ((*_8).0: alloc::raw_vec::RawVec<u32>) = move _9; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         ((*_8).1: usize) = const 0_usize; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         StorageDead(_9);                 // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         StorageDead(_8);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n           StorageDead(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:33: +1:43\n           _1 = move _5;                    // scope 0 at $DIR/inline-into-box-place.rs:+1:29: +1:43\n           StorageDead(_5);                 // scope 0 at $DIR/inline-into-box-place.rs:+1:42: +1:43"}, {"sha": "0d9c9350efca4a0bbf7cb7bd93328e9bf509be9f", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -74,10 +74,10 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n             2 => {\n                 let seg = PathSegment::from_ident(Ident::from_str(\"x\"));\n                 iter_exprs(depth - 1, &mut |e| {\n-                    g(ExprKind::MethodCall(seg.clone(), vec![e, make_x()], DUMMY_SP))\n+                    g(ExprKind::MethodCall(seg.clone(), e, vec![make_x()], DUMMY_SP))\n                 });\n                 iter_exprs(depth - 1, &mut |e| {\n-                    g(ExprKind::MethodCall(seg.clone(), vec![make_x(), e], DUMMY_SP))\n+                    g(ExprKind::MethodCall(seg.clone(), make_x(), vec![e], DUMMY_SP))\n                 });\n             }\n             3..=8 => {"}, {"sha": "78a072f503fab086cae78f77fb39516484e51cd0", "filename": "src/test/ui/cfg/cfg-method-receiver.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -0,0 +1,12 @@\n+macro_rules! cbor_map {\n+    ($key:expr) => {\n+        $key.signum();\n+        //~^ ERROR can't call method `signum` on ambiguous numeric type `{integer}` [E0689]\n+    };\n+}\n+\n+fn main() {\n+    cbor_map! { #[cfg(test)] 4};\n+    //~^ ERROR attributes on expressions are experimental\n+    //~| ERROR removing an expression is not supported in this position\n+}"}, {"sha": "517fc8168e72d27172295420dff651f6c0484a7f", "filename": "src/test/ui/cfg/cfg-method-receiver.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver.stderr?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -0,0 +1,34 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/cfg-method-receiver.rs:9:17\n+   |\n+LL |     cbor_map! { #[cfg(test)] 4};\n+   |                 ^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error: removing an expression is not supported in this position\n+  --> $DIR/cfg-method-receiver.rs:9:17\n+   |\n+LL |     cbor_map! { #[cfg(test)] 4};\n+   |                 ^^^^^^^^^^^^\n+\n+error[E0689]: can't call method `signum` on ambiguous numeric type `{integer}`\n+  --> $DIR/cfg-method-receiver.rs:3:14\n+   |\n+LL |         $key.signum();\n+   |              ^^^^^^\n+...\n+LL |     cbor_map! { #[cfg(test)] 4};\n+   |     --------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `cbor_map` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: you must specify a concrete type for this numeric value, like `i32`\n+   |\n+LL |     cbor_map! { #[cfg(test)] 4_i32};\n+   |                              ~~~~~\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0658, E0689.\n+For more information about an error, try `rustc --explain E0658`."}, {"sha": "5dce8180f59206ecd1968ebdb635cdacee400c36", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum-as-cast.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum-as-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum-as-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum-as-cast.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -1,17 +1,11 @@\n // aux-build:enums.rs\n-// run-pass\n \n extern crate enums;\n \n use enums::FieldLessWithNonExhaustiveVariant;\n \n fn main() {\n     let e = FieldLessWithNonExhaustiveVariant::default();\n-    // FIXME: https://github.com/rust-lang/rust/issues/91161\n-    // This `as` cast *should* be an error, since it would fail\n-    // if the non-exhaustive variant got fields.  But today it\n-    // doesn't.  The fix for that will update this test to\n-    // show an error (and not be run-pass any more).\n-    let d = e as u8;\n+    let d = e as u8; //~ ERROR casting `FieldLessWithNonExhaustiveVariant` as `u8` is invalid [E0606]\n     assert_eq!(d, 0);\n }"}, {"sha": "a61dcf8399f17094d8ae373f2b8acb1d365243b4", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum-as-cast.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum-as-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum-as-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum-as-cast.stderr?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -0,0 +1,11 @@\n+error[E0606]: casting `FieldLessWithNonExhaustiveVariant` as `u8` is invalid\n+  --> $DIR/enum-as-cast.rs:9:13\n+   |\n+LL |     let d = e as u8;\n+   |             ^^^^^^^\n+   |\n+   = note: cannot cast an enum with a non-exhaustive variant when it's defined in another crate\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0606`."}, {"sha": "a24b3ada57e59547d67f0e7761b38984dccdd12f", "filename": "src/test/ui/stats/hir-stats.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui%2Fstats%2Fhir-stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui%2Fstats%2Fhir-stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstats%2Fhir-stats.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -0,0 +1,41 @@\n+// check-pass\n+// compile-flags: -Zhir-stats\n+// only-x86_64\n+\n+// The aim here is to include at least one of every different type of top-level\n+// AST/HIR node reported by `-Zhir-stats`.\n+\n+#![allow(dead_code)]\n+\n+use std::arch::asm;\n+use std::fmt::Debug;\n+use std::ffi::c_void;\n+\n+extern \"C\" { fn f(p: *mut c_void); }\n+\n+/// An enum.\n+enum E<'a, T: Copy> { A { t: T }, B(&'a u32) }\n+\n+trait Go {\n+    type G: Debug;\n+    fn go(self) -> u32;\n+}\n+\n+impl<'a, T: Copy> Go for E<'a, T> {\n+    type G = bool;\n+    fn go(self) -> u32 {\n+        99\n+    }\n+}\n+\n+fn f2<T>(t: T) where T: Debug {}\n+\n+fn main() {\n+    let x = E::A { t: 3 };\n+    match x {\n+        E::A { .. } => {}\n+        _ => {}\n+    }\n+\n+    unsafe { asm!(\"mov rdi, 1\"); }\n+}"}, {"sha": "f4874408c909400c5ad114e4ea452a261aa34894", "filename": "src/test/ui/stats/hir-stats.stderr", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -0,0 +1,151 @@\n+\n+PRE EXPANSION AST STATS\n+\n+Name                Accumulated Size         Count     Item Size\n+----------------------------------------------------------------\n+ExprField                 48 ( 0.5%)             1            48\n+GenericArgs               64 ( 0.7%)             1            64\n+- AngleBracketed            64 ( 0.7%)             1\n+Local                     72 ( 0.8%)             1            72\n+WherePredicate            72 ( 0.8%)             1            72\n+- BoundPredicate            72 ( 0.8%)             1\n+Crate                     72 ( 0.8%)             1            72\n+Arm                       96 ( 1.0%)             2            48\n+FieldDef                 160 ( 1.7%)             2            80\n+ForeignItem              160 ( 1.7%)             1           160\n+- Fn                       160 ( 1.7%)             1\n+Stmt                     160 ( 1.7%)             5            32\n+- Local                     32 ( 0.3%)             1\n+- MacCall                   32 ( 0.3%)             1\n+- Expr                      96 ( 1.0%)             3\n+Param                    160 ( 1.7%)             4            40\n+FnDecl                   200 ( 2.2%)             5            40\n+Variant                  240 ( 2.6%)             2           120\n+Block                    288 ( 3.1%)             6            48\n+Attribute                304 ( 3.3%)             2           152\n+- Normal                   152 ( 1.7%)             1\n+- DocComment               152 ( 1.7%)             1\n+GenericBound             352 ( 3.8%)             4            88\n+- Trait                    352 ( 3.8%)             4\n+GenericParam             520 ( 5.7%)             5           104\n+AssocItem                640 ( 7.0%)             4           160\n+- TyAlias                  320 ( 3.5%)             2\n+- Fn                       320 ( 3.5%)             2\n+PathSegment              720 ( 7.9%)            30            24\n+Expr                     832 ( 9.1%)             8           104\n+- Path                     104 ( 1.1%)             1\n+- Match                    104 ( 1.1%)             1\n+- Struct                   104 ( 1.1%)             1\n+- Lit                      208 ( 2.3%)             2\n+- Block                    312 ( 3.4%)             3\n+Pat                      840 ( 9.2%)             7           120\n+- Struct                   120 ( 1.3%)             1\n+- Wild                     120 ( 1.3%)             1\n+- Ident                    600 ( 6.6%)             5\n+Ty                     1_344 (14.7%)            14            96\n+- Rptr                      96 ( 1.0%)             1\n+- Ptr                       96 ( 1.0%)             1\n+- ImplicitSelf             192 ( 2.1%)             2\n+- Path                     960 (10.5%)            10\n+Item                   1_800 (19.7%)             9           200\n+- Trait                    200 ( 2.2%)             1\n+- Enum                     200 ( 2.2%)             1\n+- ForeignMod               200 ( 2.2%)             1\n+- Impl                     200 ( 2.2%)             1\n+- Fn                       400 ( 4.4%)             2\n+- Use                      600 ( 6.6%)             3\n+----------------------------------------------------------------\n+Total                  9_144\n+\n+\n+POST EXPANSION AST STATS\n+\n+Name                Accumulated Size         Count     Item Size\n+----------------------------------------------------------------\n+ExprField                 48 ( 0.5%)             1            48\n+GenericArgs               64 ( 0.6%)             1            64\n+- AngleBracketed            64 ( 0.6%)             1\n+Local                     72 ( 0.7%)             1            72\n+WherePredicate            72 ( 0.7%)             1            72\n+- BoundPredicate            72 ( 0.7%)             1\n+Crate                     72 ( 0.7%)             1            72\n+Arm                       96 ( 0.9%)             2            48\n+InlineAsm                120 ( 1.2%)             1           120\n+FieldDef                 160 ( 1.6%)             2            80\n+ForeignItem              160 ( 1.6%)             1           160\n+- Fn                       160 ( 1.6%)             1\n+Stmt                     160 ( 1.6%)             5            32\n+- Local                     32 ( 0.3%)             1\n+- Semi                      32 ( 0.3%)             1\n+- Expr                      96 ( 0.9%)             3\n+Param                    160 ( 1.6%)             4            40\n+FnDecl                   200 ( 2.0%)             5            40\n+Variant                  240 ( 2.4%)             2           120\n+Block                    288 ( 2.8%)             6            48\n+GenericBound             352 ( 3.5%)             4            88\n+- Trait                    352 ( 3.5%)             4\n+GenericParam             520 ( 5.1%)             5           104\n+Attribute                608 ( 6.0%)             4           152\n+- DocComment               152 ( 1.5%)             1\n+- Normal                   456 ( 4.5%)             3\n+AssocItem                640 ( 6.3%)             4           160\n+- TyAlias                  320 ( 3.2%)             2\n+- Fn                       320 ( 3.2%)             2\n+PathSegment              792 ( 7.8%)            33            24\n+Pat                      840 ( 8.3%)             7           120\n+- Struct                   120 ( 1.2%)             1\n+- Wild                     120 ( 1.2%)             1\n+- Ident                    600 ( 5.9%)             5\n+Expr                     936 ( 9.2%)             9           104\n+- Path                     104 ( 1.0%)             1\n+- Match                    104 ( 1.0%)             1\n+- Struct                   104 ( 1.0%)             1\n+- InlineAsm                104 ( 1.0%)             1\n+- Lit                      208 ( 2.1%)             2\n+- Block                    312 ( 3.1%)             3\n+Ty                     1_344 (13.2%)            14            96\n+- Rptr                      96 ( 0.9%)             1\n+- Ptr                       96 ( 0.9%)             1\n+- ImplicitSelf             192 ( 1.9%)             2\n+- Path                     960 ( 9.5%)            10\n+Item                   2_200 (21.7%)            11           200\n+- Trait                    200 ( 2.0%)             1\n+- Enum                     200 ( 2.0%)             1\n+- ExternCrate              200 ( 2.0%)             1\n+- ForeignMod               200 ( 2.0%)             1\n+- Impl                     200 ( 2.0%)             1\n+- Fn                       400 ( 3.9%)             2\n+- Use                      800 ( 7.9%)             4\n+----------------------------------------------------------------\n+Total                 10_144\n+\n+\n+HIR STATS\n+\n+Name                Accumulated Size         Count     Item Size\n+----------------------------------------------------------------\n+Param                     64 ( 0.7%)             2            32\n+Local                     64 ( 0.7%)             1            64\n+ForeignItem               72 ( 0.7%)             1            72\n+FieldDef                  96 ( 1.0%)             2            48\n+Arm                       96 ( 1.0%)             2            48\n+Stmt                      96 ( 1.0%)             3            32\n+FnDecl                   120 ( 1.2%)             3            40\n+Lifetime                 128 ( 1.3%)             4            32\n+Variant                  160 ( 1.6%)             2            80\n+ImplItem                 176 ( 1.8%)             2            88\n+GenericBound             192 ( 2.0%)             4            48\n+TraitItem                192 ( 2.0%)             2            96\n+WherePredicate           216 ( 2.2%)             3            72\n+Block                    288 ( 3.0%)             6            48\n+QPath                    408 ( 4.2%)            17            24\n+Pat                      440 ( 4.5%)             5            88\n+Attribute                608 ( 6.2%)             4           152\n+Expr                     672 ( 6.9%)            12            56\n+Item                     960 ( 9.9%)            12            80\n+Ty                     1_152 (11.8%)            16            72\n+Path                   1_296 (13.3%)            27            48\n+PathSegment            2_240 (23.0%)            40            56\n+----------------------------------------------------------------\n+Total                  9_736\n+"}, {"sha": "0f1d701865e7d711bbf8ae1bdb949c31d5214611", "filename": "src/tools/clippy/clippy_lints/src/double_parens.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_parens.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -61,9 +61,8 @@ impl EarlyLintPass for DoubleParens {\n                     }\n                 }\n             },\n-            ExprKind::MethodCall(_, ref params, _) => {\n-                if params.len() == 2 {\n-                    let param = &params[1];\n+            ExprKind::MethodCall(_, _, ref params, _) => {\n+                if let [ref param] = params[..] {\n                     if let ExprKind::Paren(_) = param.kind {\n                         span_lint(cx, DOUBLE_PARENS, param.span, msg);\n                     }"}, {"sha": "d9ee031c9f9756ffe11968f79499cd56b0277bca", "filename": "src/tools/clippy/clippy_lints/src/option_env_unwrap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_env_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_env_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_env_unwrap.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -37,9 +37,9 @@ declare_lint_pass!(OptionEnvUnwrap => [OPTION_ENV_UNWRAP]);\n impl EarlyLintPass for OptionEnvUnwrap {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path_segment, args, _) = &expr.kind;\n+            if let ExprKind::MethodCall(path_segment, receiver, _, _) = &expr.kind;\n             if matches!(path_segment.ident.name, sym::expect | sym::unwrap);\n-            if let ExprKind::Call(caller, _) = &args[0].kind;\n+            if let ExprKind::Call(caller, _) = &receiver.kind;\n             if is_direct_expn_of(caller.span, \"option_env\").is_some();\n             then {\n                 span_lint_and_help("}, {"sha": "e6e3ad05ad70abbee15e673653f9b076a43affff", "filename": "src/tools/clippy/clippy_lints/src/precedence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -109,12 +109,12 @@ impl EarlyLintPass for Precedence {\n             let mut arg = operand;\n \n             let mut all_odd = true;\n-            while let ExprKind::MethodCall(path_segment, args, _) = &arg.kind {\n+            while let ExprKind::MethodCall(path_segment, receiver, _, _) = &arg.kind {\n                 let path_segment_str = path_segment.ident.name.as_str();\n                 all_odd &= ALLOWED_ODD_FUNCTIONS\n                     .iter()\n                     .any(|odd_function| **odd_function == *path_segment_str);\n-                arg = args.first().expect(\"A method always has a receiver.\");\n+                arg = receiver;\n             }\n \n             if_chain! {"}, {"sha": "5d36f0f5ff8bc91cde11f88026437c7ceb826f21", "filename": "src/tools/clippy/clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -595,7 +595,7 @@ fn ident_difference_expr_with_base_location(\n         | (Unary(_, _), Unary(_, _))\n         | (Binary(_, _, _), Binary(_, _, _))\n         | (Tup(_), Tup(_))\n-        | (MethodCall(_, _, _), MethodCall(_, _, _))\n+        | (MethodCall(_, _, _, _), MethodCall(_, _, _, _))\n         | (Call(_, _), Call(_, _))\n         | (ConstBlock(_), ConstBlock(_))\n         | (Array(_), Array(_))"}, {"sha": "e1ec357838dbd88846e97ef43c602d33500ebe85", "filename": "src/tools/clippy/clippy_lints/src/unused_rounding.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -30,11 +30,10 @@ declare_clippy_lint! {\n declare_lint_pass!(UnusedRounding => [UNUSED_ROUNDING]);\n \n fn is_useless_rounding(expr: &Expr) -> Option<(&str, String)> {\n-    if let ExprKind::MethodCall(name_ident, args, _) = &expr.kind\n+    if let ExprKind::MethodCall(name_ident, receiver, _, _) = &expr.kind\n         && let method_name = name_ident.ident.name.as_str()\n         && (method_name == \"ceil\" || method_name == \"round\" || method_name == \"floor\")\n-        && !args.is_empty()\n-        && let ExprKind::Lit(spanned) = &args[0].kind\n+        && let ExprKind::Lit(spanned) = &receiver.kind\n         && let LitKind::Float(symbol, ty) = spanned.kind {\n             let f = symbol.as_str().parse::<f64>().unwrap();\n             let f_str = symbol.to_string() + if let LitFloatType::Suffixed(ty) = ty {"}, {"sha": "9f74729bdfa18487463011020784ac9c8873bbc7", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -147,7 +147,9 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Array(l), Array(r)) | (Tup(l), Tup(r)) => over(l, r, |l, r| eq_expr(l, r)),\n         (Repeat(le, ls), Repeat(re, rs)) => eq_expr(le, re) && eq_expr(&ls.value, &rs.value),\n         (Call(lc, la), Call(rc, ra)) => eq_expr(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n-        (MethodCall(lc, la, _), MethodCall(rc, ra, _)) => eq_path_seg(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n+        (MethodCall(lc, ls, la, _), MethodCall(rc, rs, ra, _)) => {\n+            eq_path_seg(lc, rc) && eq_expr(ls, rs) && over(la, ra, |l, r| eq_expr(l, r))\n+        },\n         (Binary(lo, ll, lr), Binary(ro, rl, rr)) => lo.node == ro.node && eq_expr(ll, rl) && eq_expr(lr, rr),\n         (Unary(lo, l), Unary(ro, r)) => mem::discriminant(lo) == mem::discriminant(ro) && eq_expr(l, r),\n         (Lit(l), Lit(r)) => l.kind == r.kind,"}, {"sha": "70d5f94472f6b598829a7256a47e95c642a0d2c6", "filename": "src/tools/rustdoc-gui/tester.js", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Frustdoc-gui%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Frustdoc-gui%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui%2Ftester.js?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -201,6 +201,19 @@ async function main(argv) {\n         process.setMaxListeners(opts[\"jobs\"] + 1);\n     }\n \n+    // We catch this \"event\" to display a nicer message in case of unexpected exit (because of a\n+    // missing `--no-sandbox`).\n+    const exitHandling = (code) => {\n+        if (!opts[\"no_sandbox\"]) {\n+            console.log(\"\");\n+            console.log(\n+                \"`browser-ui-test` crashed unexpectedly. Please try again with adding `--test-args \\\n+--no-sandbox` at the end. For example: `x.py test src/test/rustdoc-gui --test-args --no-sandbox`\");\n+            console.log(\"\");\n+        }\n+    };\n+    process.on('exit', exitHandling);\n+\n     const tests_queue = [];\n     let results = {\n         successful: [],\n@@ -247,6 +260,9 @@ async function main(argv) {\n     }\n     status_bar.finish();\n \n+    // We don't need this listener anymore.\n+    process.removeListener(\"exit\", exitHandling);\n+\n     if (debug) {\n         results.successful.sort(by_filename);\n         results.successful.forEach(r => {"}, {"sha": "fcc02eca42987c47c2d3f4393ce31253a81a3677", "filename": "src/tools/rustfmt/src/chains.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Frustfmt%2Fsrc%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ffea6938b5839c390252e07940b99e3b6a889a/src%2Ftools%2Frustfmt%2Fsrc%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fchains.rs?ref=20ffea6938b5839c390252e07940b99e3b6a889a", "patch": "@@ -145,7 +145,7 @@ impl ChainItemKind {\n \n     fn from_ast(context: &RewriteContext<'_>, expr: &ast::Expr) -> (ChainItemKind, Span) {\n         let (kind, span) = match expr.kind {\n-            ast::ExprKind::MethodCall(ref segment, ref expressions, _) => {\n+            ast::ExprKind::MethodCall(ref segment, ref receiver, ref expressions, _) => {\n                 let types = if let Some(ref generic_args) = segment.args {\n                     if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n                         data.args\n@@ -163,7 +163,7 @@ impl ChainItemKind {\n                 } else {\n                     vec![]\n                 };\n-                let span = mk_sp(expressions[0].span.hi(), expr.span.hi());\n+                let span = mk_sp(receiver.span.hi(), expr.span.hi());\n                 let kind = ChainItemKind::MethodCall(segment.clone(), types, expressions.clone());\n                 (kind, span)\n             }\n@@ -253,7 +253,7 @@ impl ChainItem {\n             format!(\"::<{}>\", type_list.join(\", \"))\n         };\n         let callee_str = format!(\".{}{}\", rewrite_ident(context, method_name), type_str);\n-        rewrite_call(context, &callee_str, &args[1..], span, shape)\n+        rewrite_call(context, &callee_str, &args, span, shape)\n     }\n }\n \n@@ -400,8 +400,8 @@ impl Chain {\n     // is a try! macro, we'll convert it to shorthand when the option is set.\n     fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext<'_>) -> Option<ast::Expr> {\n         match expr.kind {\n-            ast::ExprKind::MethodCall(_, ref expressions, _) => {\n-                Some(Self::convert_try(&expressions[0], context))\n+            ast::ExprKind::MethodCall(_, ref receiver, _, _) => {\n+                Some(Self::convert_try(&receiver, context))\n             }\n             ast::ExprKind::Field(ref subexpr, _)\n             | ast::ExprKind::Try(ref subexpr)"}]}