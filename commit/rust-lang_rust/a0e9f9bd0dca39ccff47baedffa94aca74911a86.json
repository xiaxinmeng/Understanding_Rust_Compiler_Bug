{"sha": "a0e9f9bd0dca39ccff47baedffa94aca74911a86", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZTlmOWJkMGRjYTM5Y2NmZjQ3YmFlZGZmYTk0YWNhNzQ5MTFhODY=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-05-28T13:45:24Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-05-28T13:45:24Z"}, "message": "Merge commit '7ea7cd165ad6705603852771bf82cc2fd6560db5' into clippyup2", "tree": {"sha": "ff326c800e6850dcb2109284dd5070d1126616f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff326c800e6850dcb2109284dd5070d1126616f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0e9f9bd0dca39ccff47baedffa94aca74911a86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0e9f9bd0dca39ccff47baedffa94aca74911a86", "html_url": "https://github.com/rust-lang/rust/commit/a0e9f9bd0dca39ccff47baedffa94aca74911a86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0e9f9bd0dca39ccff47baedffa94aca74911a86/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e820a03d1c905d58b27d7ac6d85f450f9754ba79", "url": "https://api.github.com/repos/rust-lang/rust/commits/e820a03d1c905d58b27d7ac6d85f450f9754ba79", "html_url": "https://github.com/rust-lang/rust/commit/e820a03d1c905d58b27d7ac6d85f450f9754ba79"}], "stats": {"total": 1983, "additions": 1550, "deletions": 433}, "files": [{"sha": "5fa8009a8b42c8fad795d61114ad70deacdcd5fc", "filename": ".github/workflows/clippy.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy.yml?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -49,7 +49,7 @@ jobs:\n       run: cargo update\n \n     - name: Cache cargo dir\n-      uses: actions/cache@v1\n+      uses: actions/cache@v2\n       with:\n         path: ~/.cargo\n         key: ${{ runner.os }}-x86_64-unknown-linux-gnu-${{ hashFiles('Cargo.lock') }}"}, {"sha": "3958ba012467b5c9428ccd4427766b8b8871d87e", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -94,7 +94,7 @@ jobs:\n       run: cargo update\n \n     - name: Cache cargo dir\n-      uses: actions/cache@v1\n+      uses: actions/cache@v2\n       with:\n         path: ~/.cargo\n         key: ${{ runner.os }}-${{ matrix.host }}-${{ hashFiles('Cargo.lock') }}\n@@ -190,7 +190,7 @@ jobs:\n       run: cargo update\n \n     - name: Cache cargo dir\n-      uses: actions/cache@v1\n+      uses: actions/cache@v2\n       with:\n         path: ~/.cargo\n         key: ${{ runner.os }}-x86_64-unknown-linux-gnu-${{ hashFiles('Cargo.lock') }}\n@@ -269,7 +269,7 @@ jobs:\n       run: cargo update\n \n     - name: Cache cargo dir\n-      uses: actions/cache@v1\n+      uses: actions/cache@v2\n       with:\n         path: ~/.cargo\n         key: ${{ runner.os }}-x86_64-unknown-linux-gnu-${{ hashFiles('Cargo.lock') }}\n@@ -312,7 +312,7 @@ jobs:\n     name: bors test finished\n     if: github.event.pusher.name == 'bors' && success()\n     runs-on: ubuntu-latest\n-    needs: [base, integration]\n+    needs: [changelog, base, integration_build, integration]\n \n     steps:\n       - name: Mark the job as successful\n@@ -322,7 +322,7 @@ jobs:\n     name: bors test finished\n     if: github.event.pusher.name == 'bors' && (failure() || cancelled())\n     runs-on: ubuntu-latest\n-    needs: [base, integration]\n+    needs: [changelog, base, integration_build, integration]\n \n     steps:\n       - name: Mark the job as a failure"}, {"sha": "2ac9057199ff33ff2f451a31900efe89b207c3ab", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1439,6 +1439,7 @@ Released 2018-09-13\n [`match_same_arms`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_same_arms\n [`match_single_binding`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_single_binding\n [`match_wild_err_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_wild_err_arm\n+[`match_wildcard_for_single_variants`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_wildcard_for_single_variants\n [`maybe_infinite_iter`]: https://rust-lang.github.io/rust-clippy/master/index.html#maybe_infinite_iter\n [`mem_discriminant_non_enum`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_discriminant_non_enum\n [`mem_forget`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_forget"}, {"sha": "0f47ac98fd20ab25bcab738968d3558e70ab5f4d", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 65, "deletions": 35, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -155,47 +155,77 @@ That's why the `else_if_without_else` example uses the `register_early_pass` fun\n \n ## Fixing build failures caused by Rust\n \n-Clippy will sometimes fail to build from source because building it depends on unstable internal Rust features. Most of\n-the times we have to adapt to the changes and only very rarely there's an actual bug in Rust. Fixing build failures\n-caused by Rust updates, can be a good way to learn about Rust internals.\n+Clippy currently gets built with `rustc` of the `rust-lang/rust` `master`\n+branch. Most of the times we have to adapt to the changes and only very rarely\n+there's an actual bug in Rust.\n+\n+If you decide to make Clippy work again with a Rust commit that breaks it, you\n+have to sync the `rust-lang/rust-clippy` repository with the `subtree` copy of\n+Clippy in the `rust-lang/rust` repository.\n+\n+For general information about `subtree`s in the Rust repository see [Rust's\n+`CONTRIBUTING.md`][subtree].\n+\n+Here is a TL;DR version of the sync process (all of the following commands have\n+to be run inside the `rust` directory):\n+\n+1. Clone the [`rust-lang/rust`] repository\n+2. Sync the changes to the rust-copy of Clippy to your Clippy fork:\n+    ```bash\n+    # Make sure to change `your-github-name` to your github name in the following command\n+    git subtree push -P src/tools/clippy git@github.com:your-github-name/rust-clippy sync-from-rust\n+    ```\n+    _Note:_ This will directly push to the remote repository. You can also push\n+    to your local copy by replacing the remote address with `/path/to/rust-clippy`\n+    directory.\n+\n+    _Note:_ Most of the time you have to create a merge commit in the\n+    `rust-clippy` repo (this has to be done in the Clippy repo, not in the\n+    rust-copy of Clippy):\n+    ```bash\n+    git fetch origin && git fetch upstream\n+    git checkout sync-from-rust\n+    git merge upstream/master\n+    ```\n+3. Open a PR to `rust-lang/rust-clippy` and wait for it to get merged (to\n+   accelerate the process ping the `@rust-lang/clippy` team in your PR and/or\n+   ~~annoy~~ ask them in the [Discord] channel.)\n+4. Sync the `rust-lang/rust-clippy` master to the rust-copy of Clippy:\n+    ```bash\n+    git checkout -b sync-from-clippy\n+    git subtree pull -P src/tools/clippy https://github.com/rust-lang/rust-clippy master\n+    ```\n+5. Open a PR to [`rust-lang/rust`]\n+\n+Also, you may want to define remotes, so you don't have to type out the remote\n+addresses on every sync. You can do this with the following commands (these\n+commands still have to be run inside the `rust` directory):\n \n-In order to find out why Clippy does not work properly with a new Rust commit, you can use the [rust-toolstate commit\n-history][toolstate_commit_history]. You will then have to look for the last commit that contains\n-`test-pass -> build-fail` or `test-pass -> test-fail` for the `clippy-driver` component.\n-[Here][toolstate_commit] is an example.\n-\n-The commit message contains a link to the PR. The PRs are usually small enough to discover the breaking API change and\n-if they are bigger, they likely include some discussion that may help you to fix Clippy.\n-\n-To check if Clippy is available for a specific target platform, you can check\n-the [rustup component history][rustup_component_history].\n-\n-If you decide to make Clippy work again with a Rust commit that breaks it,\n-you probably want to install the latest Rust from master locally and run Clippy\n-using that version of Rust.\n-\n-You can set up the master toolchain by running `./setup-toolchain.sh`. That script will install\n-[rustup-toolchain-install-master][rtim] and master toolchain, then run `rustup override set master`.\n-\n-After fixing the build failure on this repository, we can submit a pull request\n-to [`rust-lang/rust`] to fix the toolstate.\n+```bash\n+# Set clippy-upstream remote for pulls\n+$ git remote add clippy-upstream https://github.com/rust-lang/rust-clippy\n+# Make sure to not push to the upstream repo\n+$ git remote set-url --push clippy-upstream DISABLED\n+# Set clippy-origin remote to your fork for pushes\n+$ git remote add clippy-origin git@github.com:your-github-name/rust-clippy\n+# Set a local remote\n+$ git remote add clippy-local /path/to/rust-clippy\n+```\n \n-To submit a pull request, you should follow these steps:\n+You can then sync with the remote names from above, e.g.:\n \n ```bash\n-# Assuming you already cloned the rust-lang/rust repo and you're in the correct directory\n-git submodule update --remote src/tools/clippy\n-cargo update -p clippy\n-git add -u\n-git commit -m \"Update Clippy\"\n-./x.py test -i --stage 1 src/tools/clippy # This is optional and should succeed anyway\n-# Open a PR in rust-lang/rust\n+$ git subtree push -P src/tools/clippy clippy-local sync-from-rust\n ```\n \n-[rustup_component_history]: https://rust-lang.github.io/rustup-components-history\n-[toolstate_commit_history]: https://github.com/rust-lang-nursery/rust-toolstate/commits/master\n-[toolstate_commit]: https://github.com/rust-lang-nursery/rust-toolstate/commit/aad74d8294e198a7cf8ac81a91aebb7f3bbcf727\n-[rtim]: https://github.com/kennytm/rustup-toolchain-install-master\n+_Note:_ The first time running `git subtree push` a cache has to be built. This\n+involves going through the complete Clippy history once. For this you have to\n+increase the stack limit though, which you can do with `ulimit -s 60000`. For\n+this to work, you will need the fix of `git subtree` available\n+[here][gitgitgadget-pr].\n+\n+[gitgitgadget-pr]: https://github.com/gitgitgadget/git/pull/493\n+[subtree]: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#external-dependencies-subtree\n [`rust-lang/rust`]: https://github.com/rust-lang/rust\n \n ## Issue and PR triage"}, {"sha": "c0b2dac2f60ff0105364e0c371b54d6bfb244869", "filename": "clippy_dev/src/new_lint.rs", "status": "modified", "additions": 115, "deletions": 75, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fnew_lint.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1,91 +1,111 @@\n use crate::clippy_project_root;\n-use std::fs::{File, OpenOptions};\n-use std::io;\n+use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n-use std::io::ErrorKind;\n-use std::path::Path;\n+use std::io::{self, ErrorKind};\n+use std::path::{Path, PathBuf};\n+\n+struct LintData<'a> {\n+    pass: &'a str,\n+    name: &'a str,\n+    category: &'a str,\n+    project_root: PathBuf,\n+}\n+\n+trait Context {\n+    fn context<C: AsRef<str>>(self, text: C) -> Self;\n+}\n+\n+impl<T> Context for io::Result<T> {\n+    fn context<C: AsRef<str>>(self, text: C) -> Self {\n+        match self {\n+            Ok(t) => Ok(t),\n+            Err(e) => {\n+                let message = format!(\"{}: {}\", text.as_ref(), e);\n+                Err(io::Error::new(ErrorKind::Other, message))\n+            },\n+        }\n+    }\n+}\n \n-/// Creates files required to implement and test a new lint and runs `update_lints`.\n+/// Creates the files required to implement and test a new lint and runs `update_lints`.\n ///\n /// # Errors\n ///\n-/// This function errors, if the files couldn't be created\n-pub fn create(pass: Option<&str>, lint_name: Option<&str>, category: Option<&str>) -> Result<(), io::Error> {\n-    let pass = pass.expect(\"`pass` argument is validated by clap\");\n-    let lint_name = lint_name.expect(\"`name` argument is validated by clap\");\n-    let category = category.expect(\"`category` argument is validated by clap\");\n-\n-    match open_files(lint_name) {\n-        Ok((mut test_file, mut lint_file)) => {\n-            let (pass_type, pass_lifetimes, pass_import, context_import) = match pass {\n-                \"early\" => (\"EarlyLintPass\", \"\", \"use rustc_ast::ast::*;\", \"EarlyContext\"),\n-                \"late\" => (\"LateLintPass\", \"<'_, '_>\", \"use rustc_hir::*;\", \"LateContext\"),\n-                _ => {\n-                    unreachable!(\"`pass_type` should only ever be `early` or `late`!\");\n-                },\n-            };\n-\n-            let camel_case_name = to_camel_case(lint_name);\n-\n-            if let Err(e) = test_file.write_all(get_test_file_contents(lint_name).as_bytes()) {\n-                return Err(io::Error::new(\n-                    ErrorKind::Other,\n-                    format!(\"Could not write to test file: {}\", e),\n-                ));\n-            };\n-\n-            if let Err(e) = lint_file.write_all(\n-                get_lint_file_contents(\n-                    pass_type,\n-                    pass_lifetimes,\n-                    lint_name,\n-                    &camel_case_name,\n-                    category,\n-                    pass_import,\n-                    context_import,\n-                )\n-                .as_bytes(),\n-            ) {\n-                return Err(io::Error::new(\n-                    ErrorKind::Other,\n-                    format!(\"Could not write to lint file: {}\", e),\n-                ));\n-            }\n-            Ok(())\n+/// This function errors out if the files couldn't be created or written to.\n+pub fn create(pass: Option<&str>, lint_name: Option<&str>, category: Option<&str>) -> io::Result<()> {\n+    let lint = LintData {\n+        pass: pass.expect(\"`pass` argument is validated by clap\"),\n+        name: lint_name.expect(\"`name` argument is validated by clap\"),\n+        category: category.expect(\"`category` argument is validated by clap\"),\n+        project_root: clippy_project_root(),\n+    };\n+\n+    create_lint(&lint).context(\"Unable to create lint implementation\")?;\n+    create_test(&lint).context(\"Unable to create a test for the new lint\")\n+}\n+\n+fn create_lint(lint: &LintData) -> io::Result<()> {\n+    let (pass_type, pass_lifetimes, pass_import, context_import) = match lint.pass {\n+        \"early\" => (\"EarlyLintPass\", \"\", \"use rustc_ast::ast::*;\", \"EarlyContext\"),\n+        \"late\" => (\"LateLintPass\", \"<'_, '_>\", \"use rustc_hir::*;\", \"LateContext\"),\n+        _ => {\n+            unreachable!(\"`pass_type` should only ever be `early` or `late`!\");\n         },\n-        Err(e) => Err(io::Error::new(\n-            ErrorKind::Other,\n-            format!(\"Unable to create lint: {}\", e),\n-        )),\n-    }\n+    };\n+\n+    let camel_case_name = to_camel_case(lint.name);\n+    let lint_contents = get_lint_file_contents(\n+        pass_type,\n+        pass_lifetimes,\n+        lint.name,\n+        &camel_case_name,\n+        lint.category,\n+        pass_import,\n+        context_import,\n+    );\n+\n+    let lint_path = format!(\"clippy_lints/src/{}.rs\", lint.name);\n+    write_file(lint.project_root.join(&lint_path), lint_contents.as_bytes())\n }\n \n-fn open_files(lint_name: &str) -> Result<(File, File), io::Error> {\n-    let project_root = clippy_project_root();\n+fn create_test(lint: &LintData) -> io::Result<()> {\n+    fn create_project_layout<P: Into<PathBuf>>(lint_name: &str, location: P, case: &str, hint: &str) -> io::Result<()> {\n+        let mut path = location.into().join(case);\n+        fs::create_dir(&path)?;\n+        write_file(path.join(\"Cargo.toml\"), get_manifest_contents(lint_name, hint))?;\n \n-    let test_file_path = project_root.join(\"tests\").join(\"ui\").join(format!(\"{}.rs\", lint_name));\n-    let lint_file_path = project_root\n-        .join(\"clippy_lints\")\n-        .join(\"src\")\n-        .join(format!(\"{}.rs\", lint_name));\n+        path.push(\"src\");\n+        fs::create_dir(&path)?;\n+        let header = format!(\"// compile-flags: --crate-name={}\", lint_name);\n+        write_file(path.join(\"main.rs\"), get_test_file_contents(lint_name, Some(&header)))?;\n \n-    if Path::new(&test_file_path).exists() {\n-        return Err(io::Error::new(\n-            ErrorKind::AlreadyExists,\n-            format!(\"test file {:?} already exists\", test_file_path),\n-        ));\n+        Ok(())\n     }\n-    if Path::new(&lint_file_path).exists() {\n-        return Err(io::Error::new(\n-            ErrorKind::AlreadyExists,\n-            format!(\"lint file {:?} already exists\", lint_file_path),\n-        ));\n+\n+    if lint.category == \"cargo\" {\n+        let relative_test_dir = format!(\"tests/ui-cargo/{}\", lint.name);\n+        let test_dir = lint.project_root.join(relative_test_dir);\n+        fs::create_dir(&test_dir)?;\n+\n+        create_project_layout(lint.name, &test_dir, \"fail\", \"Content that triggers the lint goes here\")?;\n+        create_project_layout(lint.name, &test_dir, \"pass\", \"This file should not trigger the lint\")\n+    } else {\n+        let test_path = format!(\"tests/ui/{}.rs\", lint.name);\n+        let test_contents = get_test_file_contents(lint.name, None);\n+        write_file(lint.project_root.join(test_path), test_contents)\n     }\n+}\n \n-    let test_file = OpenOptions::new().write(true).create_new(true).open(test_file_path)?;\n-    let lint_file = OpenOptions::new().write(true).create_new(true).open(lint_file_path)?;\n+fn write_file<P: AsRef<Path>, C: AsRef<[u8]>>(path: P, contents: C) -> io::Result<()> {\n+    fn inner(path: &Path, contents: &[u8]) -> io::Result<()> {\n+        OpenOptions::new()\n+            .write(true)\n+            .create_new(true)\n+            .open(path)?\n+            .write_all(contents)\n+    }\n \n-    Ok((test_file, lint_file))\n+    inner(path.as_ref(), contents.as_ref()).context(format!(\"writing to file: {}\", path.as_ref().display()))\n }\n \n fn to_camel_case(name: &str) -> String {\n@@ -100,15 +120,35 @@ fn to_camel_case(name: &str) -> String {\n         .collect()\n }\n \n-fn get_test_file_contents(lint_name: &str) -> String {\n-    format!(\n+fn get_test_file_contents(lint_name: &str, header_commands: Option<&str>) -> String {\n+    let mut contents = format!(\n         \"#![warn(clippy::{})]\n \n fn main() {{\n     // test code goes here\n }}\n \",\n         lint_name\n+    );\n+\n+    if let Some(header) = header_commands {\n+        contents = format!(\"{}\\n{}\", header, contents);\n+    }\n+\n+    contents\n+}\n+\n+fn get_manifest_contents(lint_name: &str, hint: &str) -> String {\n+    format!(\n+        r#\"\n+# {}\n+\n+[package]\n+name = \"{}\"\n+version = \"0.1.0\"\n+publish = false\n+\"#,\n+        hint, lint_name\n     )\n }\n "}, {"sha": "76baf27fb2dbfad8f5ab38416e93c4eb6faaf09d", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -32,6 +32,8 @@ semver = \"0.9.0\"\n # NOTE: cargo requires serde feat in its url dep\n # see <https://github.com/rust-lang/rust/pull/63587#issuecomment-522343864>\n url = { version =  \"2.1.0\", features = [\"serde\"] }\n+quote = \"1\"\n+syn = { version = \"1\", features = [\"full\"] }\n \n [features]\n deny-warnings = []"}, {"sha": "41f125d48398fd4aba769e031d601631215715b3", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 43, "deletions": 32, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -248,7 +248,6 @@ declare_lint_pass!(Attributes => [\n     INLINE_ALWAYS,\n     DEPRECATED_SEMVER,\n     USELESS_ATTRIBUTE,\n-    EMPTY_LINE_AFTER_OUTER_ATTR,\n     UNKNOWN_CLIPPY_LINTS,\n ]);\n \n@@ -480,36 +479,6 @@ fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attrib\n     }\n \n     for attr in attrs {\n-        let attr_item = if let AttrKind::Normal(ref attr) = attr.kind {\n-            attr\n-        } else {\n-            continue;\n-        };\n-\n-        if attr.style == AttrStyle::Outer {\n-            if attr_item.args.inner_tokens().is_empty() || !is_present_in_source(cx, attr.span) {\n-                return;\n-            }\n-\n-            let begin_of_attr_to_item = Span::new(attr.span.lo(), span.lo(), span.ctxt());\n-            let end_of_attr_to_item = Span::new(attr.span.hi(), span.lo(), span.ctxt());\n-\n-            if let Some(snippet) = snippet_opt(cx, end_of_attr_to_item) {\n-                let lines = snippet.split('\\n').collect::<Vec<_>>();\n-                let lines = without_block_comments(lines);\n-\n-                if lines.iter().filter(|l| l.trim().is_empty()).count() > 2 {\n-                    span_lint(\n-                        cx,\n-                        EMPTY_LINE_AFTER_OUTER_ATTR,\n-                        begin_of_attr_to_item,\n-                        \"Found an empty line after an outer attribute. \\\n-                         Perhaps you forgot to add a `!` to make it an inner attribute?\",\n-                    );\n-                }\n-            }\n-        }\n-\n         if let Some(values) = attr.meta_item_list() {\n             if values.len() != 1 || !attr.check_name(sym!(inline)) {\n                 continue;\n@@ -551,15 +520,57 @@ fn is_word(nmi: &NestedMetaItem, expected: Symbol) -> bool {\n     }\n }\n \n-declare_lint_pass!(EarlyAttributes => [DEPRECATED_CFG_ATTR, MISMATCHED_TARGET_OS]);\n+declare_lint_pass!(EarlyAttributes => [\n+    DEPRECATED_CFG_ATTR,\n+    MISMATCHED_TARGET_OS,\n+    EMPTY_LINE_AFTER_OUTER_ATTR,\n+]);\n \n impl EarlyLintPass for EarlyAttributes {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &rustc_ast::ast::Item) {\n+        check_empty_line_after_outer_attr(cx, item);\n+    }\n+\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &Attribute) {\n         check_deprecated_cfg_attr(cx, attr);\n         check_mismatched_target_os(cx, attr);\n     }\n }\n \n+fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::ast::Item) {\n+    for attr in &item.attrs {\n+        let attr_item = if let AttrKind::Normal(ref attr) = attr.kind {\n+            attr\n+        } else {\n+            return;\n+        };\n+\n+        if attr.style == AttrStyle::Outer {\n+            if attr_item.args.inner_tokens().is_empty() || !is_present_in_source(cx, attr.span) {\n+                return;\n+            }\n+\n+            let begin_of_attr_to_item = Span::new(attr.span.lo(), item.span.lo(), item.span.ctxt());\n+            let end_of_attr_to_item = Span::new(attr.span.hi(), item.span.lo(), item.span.ctxt());\n+\n+            if let Some(snippet) = snippet_opt(cx, end_of_attr_to_item) {\n+                let lines = snippet.split('\\n').collect::<Vec<_>>();\n+                let lines = without_block_comments(lines);\n+\n+                if lines.iter().filter(|l| l.trim().is_empty()).count() > 2 {\n+                    span_lint(\n+                        cx,\n+                        EMPTY_LINE_AFTER_OUTER_ATTR,\n+                        begin_of_attr_to_item,\n+                        \"Found an empty line after an outer attribute. \\\n+                        Perhaps you forgot to add a `!` to make it an inner attribute?\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn check_deprecated_cfg_attr(cx: &EarlyContext<'_>, attr: &Attribute) {\n     if_chain! {\n         // check cfg_attr"}, {"sha": "16b46423c8f013da962bb37aa0ab4d348cc37e3d", "filename": "clippy_lints/src/cargo_common_metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -23,6 +23,7 @@ declare_clippy_lint! {\n     /// [package]\n     /// name = \"clippy\"\n     /// version = \"0.0.212\"\n+    /// authors = [\"Someone <someone@rust-lang.org>\"]\n     /// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n     /// repository = \"https://github.com/rust-lang/rust-clippy\"\n     /// readme = \"README.md\""}, {"sha": "4c604cd01075e66f783ce87beb7a7f062a82dd19", "filename": "clippy_lints/src/float_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_literal.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatLiteral {\n                 let type_suffix = match lit_float_ty {\n                     LitFloatType::Suffixed(FloatTy::F32) => Some(\"f32\"),\n                     LitFloatType::Suffixed(FloatTy::F64) => Some(\"f64\"),\n-                    _ => None\n+                    LitFloatType::Unsuffixed => None\n                 };\n                 let (is_whole, mut float_str) = match fty {\n                     FloatTy::F32 => {"}, {"sha": "902f3d56c1e4f6fb9d286acc0d3484120341683b", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -346,13 +346,8 @@ mod reexport {\n /// level (i.e `#![cfg_attr(...)]`) will still be expanded even when using a pre-expansion pass.\n ///\n /// Used in `./src/driver.rs`.\n-pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, conf: &Conf) {\n+pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore) {\n     store.register_pre_expansion_pass(|| box write::Write::default());\n-    store.register_pre_expansion_pass(|| box redundant_field_names::RedundantFieldNames);\n-    let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n-    store.register_pre_expansion_pass(move || box non_expressive_names::NonExpressiveNames {\n-        single_char_binding_names_threshold,\n-    });\n     store.register_pre_expansion_pass(|| box attrs::EarlyAttributes);\n     store.register_pre_expansion_pass(|| box dbg_macro::DbgMacro);\n }\n@@ -638,6 +633,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &matches::MATCH_OVERLAPPING_ARM,\n         &matches::MATCH_REF_PATS,\n         &matches::MATCH_SINGLE_BINDING,\n+        &matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n         &matches::MATCH_WILD_ERR_ARM,\n         &matches::REST_PAT_IN_FULLY_BOUND_STRUCTS,\n         &matches::SINGLE_MATCH,\n@@ -1065,6 +1061,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box match_on_vec_items::MatchOnVecItems);\n     store.register_early_pass(|| box manual_non_exhaustive::ManualNonExhaustive);\n     store.register_late_pass(|| box manual_async_fn::ManualAsyncFn);\n+    store.register_early_pass(|| box redundant_field_names::RedundantFieldNames);\n+    let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n+    store.register_early_pass(move || box non_expressive_names::NonExpressiveNames {\n+        single_char_binding_names_threshold,\n+    });\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1139,6 +1140,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&macro_use::MACRO_USE_IMPORTS),\n         LintId::of(&match_on_vec_items::MATCH_ON_VEC_ITEMS),\n         LintId::of(&matches::MATCH_BOOL),\n+        LintId::of(&matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS),\n+        LintId::of(&matches::MATCH_WILD_ERR_ARM),\n         LintId::of(&matches::SINGLE_MATCH_ELSE),\n         LintId::of(&methods::FILTER_MAP),\n         LintId::of(&methods::FILTER_MAP_NEXT),\n@@ -1283,7 +1286,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n         LintId::of(&matches::MATCH_REF_PATS),\n         LintId::of(&matches::MATCH_SINGLE_BINDING),\n-        LintId::of(&matches::MATCH_WILD_ERR_ARM),\n         LintId::of(&matches::SINGLE_MATCH),\n         LintId::of(&matches::WILDCARD_IN_OR_PATTERNS),\n         LintId::of(&mem_discriminant::MEM_DISCRIMINANT_NON_ENUM),\n@@ -1474,7 +1476,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n         LintId::of(&matches::MATCH_REF_PATS),\n-        LintId::of(&matches::MATCH_WILD_ERR_ARM),\n         LintId::of(&matches::SINGLE_MATCH),\n         LintId::of(&mem_replace::MEM_REPLACE_OPTION_WITH_NONE),\n         LintId::of(&mem_replace::MEM_REPLACE_WITH_DEFAULT),"}, {"sha": "94380acfcfd4cb767c84df6bcc46a9fd78e36cef", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -168,7 +168,7 @@ declare_clippy_lint! {\n     /// **What it does:** Checks for arm which matches all errors with `Err(_)`\n     /// and take drastic actions like `panic!`.\n     ///\n-    /// **Why is this bad?** It is generally a bad practice, just like\n+    /// **Why is this bad?** It is generally a bad practice, similar to\n     /// catching all exceptions in java with `catch(Exception)`\n     ///\n     /// **Known problems:** None.\n@@ -182,7 +182,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub MATCH_WILD_ERR_ARM,\n-    style,\n+    pedantic,\n     \"a `match` with `Err(_)` arm and take drastic actions\"\n }\n \n@@ -220,7 +220,7 @@ declare_clippy_lint! {\n     /// # enum Foo { A(usize), B(usize) }\n     /// # let x = Foo::B(1);\n     /// match x {\n-    ///     A => {},\n+    ///     Foo::A(_) => {},\n     ///     _ => {},\n     /// }\n     /// ```\n@@ -229,6 +229,40 @@ declare_clippy_lint! {\n     \"a wildcard enum match arm using `_`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for wildcard enum matches for a single variant.\n+    ///\n+    /// **Why is this bad?** New enum variants added by library updates can be missed.\n+    ///\n+    /// **Known problems:** Suggested replacements may not use correct path to enum\n+    /// if it's not present in the current scope.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// # enum Foo { A, B, C }\n+    /// # let x = Foo::B;\n+    /// match x {\n+    ///     Foo::A => {},\n+    ///     Foo::B => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # enum Foo { A, B, C }\n+    /// # let x = Foo::B;\n+    /// match x {\n+    ///     Foo::A => {},\n+    ///     Foo::B => {},\n+    ///     Foo::C => {},\n+    /// }\n+    /// ```\n+    pub MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+    pedantic,\n+    \"a wildcard enum match for a single variant\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for wildcard pattern used with others patterns in same match arm.\n     ///\n@@ -356,6 +390,7 @@ impl_lint_pass!(Matches => [\n     MATCH_WILD_ERR_ARM,\n     MATCH_AS_REF,\n     WILDCARD_ENUM_MATCH_ARM,\n+    MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n     WILDCARD_IN_OR_PATTERNS,\n     MATCH_SINGLE_BINDING,\n     INFALLIBLE_DESTRUCTURING_MATCH,\n@@ -676,7 +711,7 @@ fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n                                 arm.pat.span,\n                                 &format!(\"`Err({})` matches all errors\", &ident_bind_name),\n                                 None,\n-                                \"match each error separately or use the error output\",\n+                                \"match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\",\n                             );\n                         }\n                     }\n@@ -729,9 +764,21 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_\n                 if let QPath::Resolved(_, p) = path {\n                     missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n                 }\n-            } else if let PatKind::TupleStruct(ref path, ..) = arm.pat.kind {\n+            } else if let PatKind::TupleStruct(ref path, ref patterns, ..) = arm.pat.kind {\n                 if let QPath::Resolved(_, p) = path {\n-                    missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n+                    // Some simple checks for exhaustive patterns.\n+                    // There is a room for improvements to detect more cases,\n+                    // but it can be more expensive to do so.\n+                    let is_pattern_exhaustive = |pat: &&Pat<'_>| {\n+                        if let PatKind::Wild | PatKind::Binding(.., None) = pat.kind {\n+                            true\n+                        } else {\n+                            false\n+                        }\n+                    };\n+                    if patterns.iter().all(is_pattern_exhaustive) {\n+                        missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n+                    }\n                 }\n             }\n         }\n@@ -766,14 +813,27 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_\n             }\n         }\n \n+        if suggestion.len() == 1 {\n+            // No need to check for non-exhaustive enum as in that case len would be greater than 1\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+                wildcard_span,\n+                message,\n+                \"try this\",\n+                suggestion[0].clone(),\n+                Applicability::MaybeIncorrect,\n+            )\n+        };\n+\n         span_lint_and_sugg(\n             cx,\n             WILDCARD_ENUM_MATCH_ARM,\n             wildcard_span,\n             message,\n             \"try this\",\n             suggestion.join(\" | \"),\n-            Applicability::MachineApplicable,\n+            Applicability::MaybeIncorrect,\n         )\n     }\n }"}, {"sha": "52ca962e7ef978e6ad80474ea52b30d94fbbb270", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1496,17 +1496,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             if let ty::Opaque(def_id, _) = ret_ty.kind {\n                 // one of the associated types must be Self\n                 for predicate in cx.tcx.predicates_of(def_id).predicates {\n-                    match predicate.0.kind() {\n-                        ty::PredicateKind::Projection(poly_projection_predicate) => {\n-                            let binder = poly_projection_predicate.ty();\n-                            let associated_type = binder.skip_binder();\n-\n-                            // walk the associated type and check for Self\n-                            if contains_self_ty(associated_type) {\n-                                return;\n-                            }\n-                        },\n-                        _ => {},\n+                    if let ty::PredicateKind::Projection(poly_projection_predicate) = predicate.0.kind() {\n+                        let binder = poly_projection_predicate.ty();\n+                        let associated_type = binder.skip_binder();\n+\n+                        // walk the associated type and check for Self\n+                        if contains_self_ty(associated_type) {\n+                            return;\n+                        }\n                     }\n                 }\n             }\n@@ -1617,6 +1614,21 @@ fn lint_or_fun_call<'a, 'tcx>(\n         or_has_args: bool,\n         span: Span,\n     ) {\n+        if let hir::ExprKind::MethodCall(ref path, _, ref args) = &arg.kind {\n+            if path.ident.as_str() == \"len\" {\n+                let ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));\n+\n+                match ty.kind {\n+                    ty::Slice(_) | ty::Array(_, _) => return,\n+                    _ => (),\n+                }\n+\n+                if match_type(cx, ty, &paths::VEC) {\n+                    return;\n+                }\n+            }\n+        }\n+\n         // (path, fn_has_argument, methods, suffix)\n         let know_types: &[(&[_], _, &[_], _)] = &[\n             (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),"}, {"sha": "552222eba2ee2164abbd717f8d92f1db0cfd1cb0", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -379,7 +379,7 @@ impl EarlyLintPass for MiscEarlyLints {\n             let left_binding = match left {\n                 BindingMode::ByRef(Mutability::Mut) => \"ref mut \",\n                 BindingMode::ByRef(Mutability::Not) => \"ref \",\n-                _ => \"\",\n+                BindingMode::ByValue(..) => \"\",\n             };\n \n             if let PatKind::Wild = right.kind {"}, {"sha": "9cfc8d1913497882f4da26a404b768d7ceaf0b28", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingConstForFn {\n                     return;\n                 }\n             },\n-            _ => return,\n+            FnKind::Closure(..) => return,\n         }\n \n         let mir = cx.tcx.optimized_mir(def_id);"}, {"sha": "b6770804e180118736898314e6f94615d67a93ec", "filename": "clippy_lints/src/multiple_crate_versions.rs", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1,11 +1,14 @@\n //! lint on multiple versions of a crate being used\n \n use crate::utils::{run_lints, span_lint};\n+use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_hir::{Crate, CRATE_HIR_ID};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::DUMMY_SP;\n \n+use cargo_metadata::{DependencyKind, MetadataCommand, Node, Package, PackageId};\n+use if_chain::if_chain;\n use itertools::Itertools;\n \n declare_clippy_lint! {\n@@ -39,30 +42,61 @@ impl LateLintPass<'_, '_> for MultipleCrateVersions {\n             return;\n         }\n \n-        let metadata = if let Ok(metadata) = cargo_metadata::MetadataCommand::new().exec() {\n+        let metadata = if let Ok(metadata) = MetadataCommand::new().exec() {\n             metadata\n         } else {\n             span_lint(cx, MULTIPLE_CRATE_VERSIONS, DUMMY_SP, \"could not read cargo metadata\");\n-\n             return;\n         };\n \n+        let local_name = cx.tcx.crate_name(LOCAL_CRATE).as_str();\n         let mut packages = metadata.packages;\n         packages.sort_by(|a, b| a.name.cmp(&b.name));\n \n-        for (name, group) in &packages.into_iter().group_by(|p| p.name.clone()) {\n-            let group: Vec<cargo_metadata::Package> = group.collect();\n+        if_chain! {\n+            if let Some(resolve) = &metadata.resolve;\n+            if let Some(local_id) = packages\n+                .iter()\n+                .find_map(|p| if p.name == *local_name { Some(&p.id) } else { None });\n+            then {\n+                for (name, group) in &packages.iter().group_by(|p| p.name.clone()) {\n+                    let group: Vec<&Package> = group.collect();\n+\n+                    if group.len() <= 1 {\n+                        continue;\n+                    }\n \n-            if group.len() > 1 {\n-                let versions = group.into_iter().map(|p| p.version).join(\", \");\n+                    if group.iter().all(|p| is_normal_dep(&resolve.nodes, local_id, &p.id)) {\n+                        let mut versions: Vec<_> = group.into_iter().map(|p| &p.version).collect();\n+                        versions.sort();\n+                        let versions = versions.iter().join(\", \");\n \n-                span_lint(\n-                    cx,\n-                    MULTIPLE_CRATE_VERSIONS,\n-                    DUMMY_SP,\n-                    &format!(\"multiple versions for dependency `{}`: {}\", name, versions),\n-                );\n+                        span_lint(\n+                            cx,\n+                            MULTIPLE_CRATE_VERSIONS,\n+                            DUMMY_SP,\n+                            &format!(\"multiple versions for dependency `{}`: {}\", name, versions),\n+                        );\n+                    }\n+                }\n             }\n         }\n     }\n }\n+\n+fn is_normal_dep(nodes: &[Node], local_id: &PackageId, dep_id: &PackageId) -> bool {\n+    fn depends_on(node: &Node, dep_id: &PackageId) -> bool {\n+        node.deps.iter().any(|dep| {\n+            dep.pkg == *dep_id\n+                && dep\n+                    .dep_kinds\n+                    .iter()\n+                    .any(|info| matches!(info.kind, DependencyKind::Normal))\n+        })\n+    }\n+\n+    nodes\n+        .iter()\n+        .filter(|node| depends_on(node, dep_id))\n+        .any(|node| node.id == *local_id || is_normal_dep(nodes, local_id, &node.id))\n+}"}, {"sha": "67a1ac78a677749565e4fb5afd8968dfbef9809d", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n-    /// **What it does:** Detects giving a mutable reference to a function that only\n+    /// **What it does:** Detects passing a mutable reference to a function that only\n     /// requires an immutable reference.\n     ///\n     /// **Why is this bad?** The immutable reference rules out all other references"}, {"sha": "218b0d27f748620a0a320bd7e3ee6bcc0cde1a88", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 }\n             },\n             FnKind::Method(..) => (),\n-            _ => return,\n+            FnKind::Closure(..) => return,\n         }\n \n         // Exclude non-inherent impls"}, {"sha": "e556e5d59c188d02031ace0d36f258953e7a3ab4", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 28, "deletions": 100, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1,27 +1,20 @@\n use crate::utils::paths;\n use crate::utils::sugg::DiagnosticBuilderExt;\n-use crate::utils::{get_trait_def_id, implements_trait, return_ty, same_tys, span_lint_hir_and_then};\n+use crate::utils::{get_trait_def_id, return_ty, same_tys, span_lint_hir_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::HirIdSet;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::Ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for types with a `fn new() -> Self` method and no\n     /// implementation of\n     /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html).\n     ///\n-    /// It detects both the case when a manual\n-    /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n-    /// implementation is required and also when it can be created with\n-    /// `#[derive(Default)]`\n-    ///\n     /// **Why is this bad?** The user might expect to be able to use\n     /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) as the\n     /// type can be constructed without arguments.\n@@ -40,46 +33,17 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     ///\n-    /// Instead, use:\n+    /// To fix the lint, and a `Default` implementation that delegates to `new`:\n     ///\n     /// ```ignore\n     /// struct Foo(Bar);\n     ///\n     /// impl Default for Foo {\n     ///     fn default() -> Self {\n-    ///         Foo(Bar::new())\n+    ///         Foo::new()\n     ///     }\n     /// }\n     /// ```\n-    ///\n-    /// Or, if\n-    /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n-    /// can be derived by `#[derive(Default)]`:\n-    ///\n-    /// ```rust\n-    /// struct Foo;\n-    ///\n-    /// impl Foo {\n-    ///     fn new() -> Self {\n-    ///         Foo\n-    ///     }\n-    /// }\n-    /// ```\n-    ///\n-    /// Instead, use:\n-    ///\n-    /// ```rust\n-    /// #[derive(Default)]\n-    /// struct Foo;\n-    ///\n-    /// impl Foo {\n-    ///     fn new() -> Self {\n-    ///         Foo\n-    ///     }\n-    /// }\n-    /// ```\n-    ///\n-    /// You can also have `new()` call `Default::default()`.\n     pub NEW_WITHOUT_DEFAULT,\n     style,\n     \"`fn new() -> Self` method without `Default` implementation\"\n@@ -126,8 +90,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                             return;\n                         }\n                         if sig.decl.inputs.is_empty() && name == sym!(new) && cx.access_levels.is_reachable(id) {\n-                            let self_did = cx.tcx.hir().local_def_id(cx.tcx.hir().get_parent_item(id));\n-                            let self_ty = cx.tcx.type_of(self_did);\n+                            let self_def_id = cx.tcx.hir().local_def_id(cx.tcx.hir().get_parent_item(id));\n+                            let self_ty = cx.tcx.type_of(self_def_id);\n                             if_chain! {\n                                 if same_tys(cx, self_ty, return_ty(cx, id));\n                                 if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n@@ -148,56 +112,35 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                                     // generics\n                                     if_chain! {\n                                         if let Some(ref impling_types) = self.impling_types;\n-                                        if let Some(self_def) = cx.tcx.type_of(self_did).ty_adt_def();\n-                                        if let Some(self_def_id) = self_def.did.as_local();\n+                                        if let Some(self_def) = cx.tcx.type_of(self_def_id).ty_adt_def();\n+                                        if let Some(self_local_did) = self_def.did.as_local();\n                                         then {\n-                                            let self_id = cx.tcx.hir().local_def_id_to_hir_id(self_def_id);\n+                                            let self_id = cx.tcx.hir().local_def_id_to_hir_id(self_local_did);\n                                             if impling_types.contains(&self_id) {\n                                                 return;\n                                             }\n                                         }\n                                     }\n \n-                                    if let Some(sp) = can_derive_default(self_ty, cx, default_trait_id) {\n-                                        span_lint_hir_and_then(\n-                                            cx,\n-                                            NEW_WITHOUT_DEFAULT,\n-                                            id,\n-                                            impl_item.span,\n-                                            &format!(\n-                                                \"you should consider deriving a `Default` implementation for `{}`\",\n-                                                self_ty\n-                                            ),\n-                                            |diag| {\n-                                                diag.suggest_item_with_attr(\n-                                                    cx,\n-                                                    sp,\n-                                                    \"try this\",\n-                                                    \"#[derive(Default)]\",\n-                                                    Applicability::MaybeIncorrect,\n-                                                );\n-                                            });\n-                                    } else {\n-                                        span_lint_hir_and_then(\n-                                            cx,\n-                                            NEW_WITHOUT_DEFAULT,\n-                                            id,\n-                                            impl_item.span,\n-                                            &format!(\n-                                                \"you should consider adding a `Default` implementation for `{}`\",\n-                                                self_ty\n-                                            ),\n-                                            |diag| {\n-                                                diag.suggest_prepend_item(\n-                                                    cx,\n-                                                    item.span,\n-                                                    \"try this\",\n-                                                    &create_new_without_default_suggest_msg(self_ty),\n-                                                    Applicability::MaybeIncorrect,\n-                                                );\n-                                            },\n-                                        );\n-                                    }\n+                                    span_lint_hir_and_then(\n+                                        cx,\n+                                        NEW_WITHOUT_DEFAULT,\n+                                        id,\n+                                        impl_item.span,\n+                                        &format!(\n+                                            \"you should consider adding a `Default` implementation for `{}`\",\n+                                            self_ty\n+                                        ),\n+                                        |diag| {\n+                                            diag.suggest_prepend_item(\n+                                                cx,\n+                                                item.span,\n+                                                \"try this\",\n+                                                &create_new_without_default_suggest_msg(self_ty),\n+                                                Applicability::MaybeIncorrect,\n+                                            );\n+                                        },\n+                                    );\n                                 }\n                             }\n                         }\n@@ -217,18 +160,3 @@ fn create_new_without_default_suggest_msg(ty: Ty<'_>) -> String {\n     }}\n }}\", ty)\n }\n-\n-fn can_derive_default<'t, 'c>(ty: Ty<'t>, cx: &LateContext<'c, 't>, default_trait_id: DefId) -> Option<Span> {\n-    match ty.kind {\n-        ty::Adt(adt_def, substs) if adt_def.is_struct() => {\n-            for field in adt_def.all_fields() {\n-                let f_ty = field.ty(cx.tcx, substs);\n-                if !implements_trait(cx, f_ty, default_trait_id, &[]) {\n-                    return None;\n-                }\n-            }\n-            Some(cx.tcx.def_span(adt_def.did))\n-        },\n-        _ => None,\n-    }\n-}"}, {"sha": "5f14fe97afefad36255744823e9fe5799ea680d5", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -5,6 +5,7 @@ use rustc_ast::ast::{\n use rustc_ast::attr;\n use rustc_ast::visit::{walk_block, walk_expr, walk_pat, Visitor};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{Ident, SymbolStr};\n@@ -131,7 +132,11 @@ struct SimilarNamesNameVisitor<'a, 'tcx, 'b>(&'b mut SimilarNamesLocalVisitor<'a\n impl<'a, 'tcx, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n     fn visit_pat(&mut self, pat: &'tcx Pat) {\n         match pat.kind {\n-            PatKind::Ident(_, ident, _) => self.check_ident(ident),\n+            PatKind::Ident(_, ident, _) => {\n+                if !pat.span.from_expansion() {\n+                    self.check_ident(ident);\n+                }\n+            },\n             PatKind::Struct(_, ref fields, _) => {\n                 for field in fields {\n                     if !field.is_shorthand {\n@@ -354,12 +359,20 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n \n impl EarlyLintPass for NonExpressiveNames {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        if in_external_macro(cx.sess, item.span) {\n+            return;\n+        }\n+\n         if let ItemKind::Fn(_, ref sig, _, Some(ref blk)) = item.kind {\n             do_check(self, cx, &item.attrs, &sig.decl, blk);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &EarlyContext<'_>, item: &AssocItem) {\n+        if in_external_macro(cx.sess, item.span) {\n+            return;\n+        }\n+\n         if let AssocItemKind::Fn(_, ref sig, _, Some(ref blk)) = item.kind {\n             do_check(self, cx, &item.attrs, &sig.decl, blk);\n         }"}, {"sha": "4eac571f96620597bc37adea99c16cf7b8a74a4a", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -2,7 +2,7 @@\n \n use crate::utils::ptr::get_spans;\n use crate::utils::{\n-    is_type_diagnostic_item, match_qpath, match_type, paths, snippet_opt, span_lint, span_lint_and_sugg,\n+    is_allowed, is_type_diagnostic_item, match_qpath, match_type, paths, snippet_opt, span_lint, span_lint_and_sugg,\n     span_lint_and_then, walk_ptrs_hir_ty,\n };\n use if_chain::if_chain;\n@@ -150,8 +150,16 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_\n     let fn_def_id = cx.tcx.hir().local_def_id(fn_id);\n     let sig = cx.tcx.fn_sig(fn_def_id);\n     let fn_ty = sig.skip_binder();\n+    let body = opt_body_id.map(|id| cx.tcx.hir().body(id));\n \n     for (idx, (arg, ty)) in decl.inputs.iter().zip(fn_ty.inputs()).enumerate() {\n+        // Honor the allow attribute on parameters. See issue 5644.\n+        if let Some(body) = &body {\n+            if is_allowed(cx, PTR_ARG, body.params[idx].hir_id) {\n+                continue;\n+            }\n+        }\n+\n         if let ty::Ref(_, ty, Mutability::Not) = ty.kind {\n             if is_type_diagnostic_item(cx, ty, sym!(vec_type)) {\n                 let mut ty_snippet = None;"}, {"sha": "1eb26d97ed4d275faf644f0c029e2a841859285e", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -241,14 +241,14 @@ fn check_inclusive_range_minus_one(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n }\n \n fn check_reversed_empty_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n-    fn inside_indexing_expr(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n-        matches!(\n-            get_parent_expr(cx, expr),\n-            Some(Expr {\n+    fn inside_indexing_expr<'a>(cx: &'a LateContext<'_, '_>, expr: &Expr<'_>) -> Option<&'a Expr<'a>> {\n+        match get_parent_expr(cx, expr) {\n+            parent_expr @ Some(Expr {\n                 kind: ExprKind::Index(..),\n                 ..\n-            })\n-        )\n+            }) => parent_expr,\n+            _ => None,\n+        }\n     }\n \n     fn is_empty_range(limits: RangeLimits, ordering: Ordering) -> bool {\n@@ -267,18 +267,32 @@ fn check_reversed_empty_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         if let Some(ordering) = Constant::partial_cmp(cx.tcx, ty, &start_idx, &end_idx);\n         if is_empty_range(limits, ordering);\n         then {\n-            if inside_indexing_expr(cx, expr) {\n+            if let Some(parent_expr) = inside_indexing_expr(cx, expr) {\n                 let (reason, outcome) = if ordering == Ordering::Equal {\n                     (\"empty\", \"always yield an empty slice\")\n                 } else {\n                     (\"reversed\", \"panic at run-time\")\n                 };\n \n-                span_lint(\n+                span_lint_and_then(\n                     cx,\n                     REVERSED_EMPTY_RANGES,\n                     expr.span,\n                     &format!(\"this range is {} and using it to index a slice will {}\", reason, outcome),\n+                    |diag| {\n+                        if_chain! {\n+                            if ordering == Ordering::Equal;\n+                            if let ty::Slice(slice_ty) = cx.tables.expr_ty(parent_expr).kind;\n+                            then {\n+                                diag.span_suggestion(\n+                                    parent_expr.span,\n+                                    \"if you want an empty slice, use\",\n+                                    format!(\"[] as &[{}]\", slice_ty),\n+                                    Applicability::MaybeIncorrect\n+                                );\n+                            }\n+                        }\n+                    }\n                 );\n             } else {\n                 span_lint_and_then("}, {"sha": "2a81170e49e75026ce6c328adbb7eaa144ac30e6", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -2,6 +2,7 @@ use crate::utils::span_lint_and_sugg;\n use rustc_ast::ast::{Expr, ExprKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -36,6 +37,9 @@ declare_lint_pass!(RedundantFieldNames => [REDUNDANT_FIELD_NAMES]);\n \n impl EarlyLintPass for RedundantFieldNames {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if in_external_macro(cx.sess, expr.span) {\n+            return;\n+        }\n         if let ExprKind::Struct(_, ref fields, _) = expr.kind {\n             for field in fields {\n                 if field.is_shorthand {"}, {"sha": "8e0cb94317affc2ce1bf3c0e81d3407fda751bf9", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -161,7 +161,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n                 }\n             },\n             FnKind::Method(..) => (),\n-            _ => return,\n+            FnKind::Closure(..) => return,\n         }\n \n         // Exclude non-inherent impls"}, {"sha": "7fa97b246991219c204d6087949c3ecb9cc85c27", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 65, "deletions": 14, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1,14 +1,17 @@\n use crate::utils::{\n-    match_def_path, match_trait_method, paths, same_tys, snippet, snippet_with_macro_callsite, span_lint_and_sugg,\n+    is_type_diagnostic_item, match_def_path, match_trait_method, paths, same_tys, snippet, snippet_with_macro_callsite,\n+    span_lint_and_help, span_lint_and_sugg,\n };\n+use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, HirId, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for `Into`/`From`/`IntoIter` calls that useless converts\n-    /// to the same type as caller.\n+    /// **What it does:** Checks for `Into`, `TryInto`, `From`, `TryFrom`,`IntoIter` calls\n+    /// that useless converts to the same type as caller.\n     ///\n     /// **Why is this bad?** Redundant code.\n     ///\n@@ -26,7 +29,7 @@ declare_clippy_lint! {\n     /// ```\n     pub USELESS_CONVERSION,\n     complexity,\n-    \"calls to `Into`/`From`/`IntoIter` that performs useless conversions to the same type\"\n+    \"calls to `Into`, `TryInto`, `From`, `TryFrom`, `IntoIter` that performs useless conversions to the same type\"\n }\n \n #[derive(Default)]\n@@ -36,6 +39,7 @@ pub struct UselessConversion {\n \n impl_lint_pass!(UselessConversion => [USELESS_CONVERSION]);\n \n+#[allow(clippy::too_many_lines)]\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if e.span.from_expansion() {\n@@ -63,12 +67,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n                     let b = cx.tables.expr_ty(&args[0]);\n                     if same_tys(cx, a, b) {\n                         let sugg = snippet_with_macro_callsite(cx, args[0].span, \"<expr>\").to_string();\n-\n                         span_lint_and_sugg(\n                             cx,\n                             USELESS_CONVERSION,\n                             e.span,\n-                            \"useless conversion\",\n+                            \"useless conversion to the same type\",\n                             \"consider removing `.into()`\",\n                             sugg,\n                             Applicability::MachineApplicable, // snippet\n@@ -84,30 +87,78 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n                             cx,\n                             USELESS_CONVERSION,\n                             e.span,\n-                            \"useless conversion\",\n+                            \"useless conversion to the same type\",\n                             \"consider removing `.into_iter()`\",\n                             sugg,\n                             Applicability::MachineApplicable, // snippet\n                         );\n                     }\n                 }\n+                if match_trait_method(cx, e, &paths::TRY_INTO_TRAIT) && &*name.ident.as_str() == \"try_into\" {\n+                    if_chain! {\n+                        let a = cx.tables.expr_ty(e);\n+                        let b = cx.tables.expr_ty(&args[0]);\n+                        if is_type_diagnostic_item(cx, a, sym!(result_type));\n+                        if let ty::Adt(_, substs) = a.kind;\n+                        if let Some(a_type) = substs.types().next();\n+                        if same_tys(cx, a_type, b);\n+\n+                        then {\n+                            span_lint_and_help(\n+                                cx,\n+                                USELESS_CONVERSION,\n+                                e.span,\n+                                \"useless conversion to the same type\",\n+                                None,\n+                                \"consider removing `.try_into()`\",\n+                            );\n+                        }\n+                    }\n+                }\n             },\n \n             ExprKind::Call(ref path, ref args) => {\n-                if let ExprKind::Path(ref qpath) = path.kind {\n-                    if let Some(def_id) = cx.tables.qpath_res(qpath, path.hir_id).opt_def_id() {\n-                        if match_def_path(cx, def_id, &paths::FROM_FROM) {\n-                            let a = cx.tables.expr_ty(e);\n-                            let b = cx.tables.expr_ty(&args[0]);\n-                            if same_tys(cx, a, b) {\n+                if_chain! {\n+                    if args.len() == 1;\n+                    if let ExprKind::Path(ref qpath) = path.kind;\n+                    if let Some(def_id) = cx.tables.qpath_res(qpath, path.hir_id).opt_def_id();\n+                    let a = cx.tables.expr_ty(e);\n+                    let b = cx.tables.expr_ty(&args[0]);\n+\n+                    then {\n+                        if_chain! {\n+                            if match_def_path(cx, def_id, &paths::TRY_FROM);\n+                            if is_type_diagnostic_item(cx, a, sym!(result_type));\n+                            if let ty::Adt(_, substs) = a.kind;\n+                            if let Some(a_type) = substs.types().next();\n+                            if same_tys(cx, a_type, b);\n+\n+                            then {\n+                                let hint = format!(\"consider removing `{}()`\", snippet(cx, path.span, \"TryFrom::try_from\"));\n+                                span_lint_and_help(\n+                                    cx,\n+                                    USELESS_CONVERSION,\n+                                    e.span,\n+                                    \"useless conversion to the same type\",\n+                                    None,\n+                                    &hint,\n+                                );\n+                            }\n+                        }\n+\n+                        if_chain! {\n+                            if match_def_path(cx, def_id, &paths::FROM_FROM);\n+                            if same_tys(cx, a, b);\n+\n+                            then {\n                                 let sugg = snippet(cx, args[0].span.source_callsite(), \"<expr>\").into_owned();\n                                 let sugg_msg =\n                                     format!(\"consider removing `{}()`\", snippet(cx, path.span, \"From::from\"));\n                                 span_lint_and_sugg(\n                                     cx,\n                                     USELESS_CONVERSION,\n                                     e.span,\n-                                    \"useless conversion\",\n+                                    \"useless conversion to the same type\",\n                                     &sugg_msg,\n                                     sugg,\n                                     Applicability::MachineApplicable, // snippet"}, {"sha": "9e8e0ff30ec6b761a2d29566716163f6ca4ac014", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -120,10 +120,12 @@ define_Conf! {\n         \"GPLv2\", \"GPLv3\",\n         \"GitHub\", \"GitLab\",\n         \"IPv4\", \"IPv6\",\n-        \"JavaScript\",\n+        \"ClojureScript\", \"CoffeeScript\", \"JavaScript\", \"PureScript\", \"TypeScript\",\n         \"NaN\", \"NaNs\",\n         \"OAuth\",\n-        \"OpenGL\", \"OpenSSH\", \"OpenSSL\", \"OpenStreetMap\",\n+        \"OCaml\",\n+        \"OpenGL\", \"OpenMP\", \"OpenSSH\", \"OpenSSL\", \"OpenStreetMap\",\n+        \"TensorFlow\",\n         \"TrueType\",\n         \"iOS\", \"macOS\",\n         \"TeX\", \"LaTeX\", \"BibTeX\", \"BibLaTeX\","}, {"sha": "9b672b9ec225b989085dfbdd65917b0c99139e4e", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -289,21 +289,21 @@ fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, indent: usize) {\n             println!(\"{}operands:\", ind);\n             for op in asm.operands {\n                 match op {\n-                    hir::InlineAsmOperand::In { expr, .. } => print_expr(cx, expr, indent + 1),\n+                    hir::InlineAsmOperand::In { expr, .. }\n+                    | hir::InlineAsmOperand::InOut { expr, .. }\n+                    | hir::InlineAsmOperand::Const { expr }\n+                    | hir::InlineAsmOperand::Sym { expr } => print_expr(cx, expr, indent + 1),\n                     hir::InlineAsmOperand::Out { expr, .. } => {\n                         if let Some(expr) = expr {\n                             print_expr(cx, expr, indent + 1);\n                         }\n                     },\n-                    hir::InlineAsmOperand::InOut { expr, .. } => print_expr(cx, expr, indent + 1),\n                     hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n                         print_expr(cx, in_expr, indent + 1);\n                         if let Some(out_expr) = out_expr {\n                             print_expr(cx, out_expr, indent + 1);\n                         }\n                     },\n-                    hir::InlineAsmOperand::Const { expr } => print_expr(cx, expr, indent + 1),\n-                    hir::InlineAsmOperand::Sym { expr } => print_expr(cx, expr, indent + 1),\n                 }\n             }\n         },"}, {"sha": "6c1488664bf0086d9faf2b8a5e049aef450a57c2", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -358,7 +358,7 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'_, 'tcx>, hir_id: HirId) -> O\n pub fn has_drop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.ty_adt_def() {\n         Some(def) => def.has_dtor(cx.tcx),\n-        _ => false,\n+        None => false,\n     }\n }\n "}, {"sha": "779da7e6bf23ce01c423991f8a0b490022a77876", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -128,8 +128,10 @@ pub const TO_OWNED_METHOD: [&str; 4] = [\"alloc\", \"borrow\", \"ToOwned\", \"to_owned\"\n pub const TO_STRING: [&str; 3] = [\"alloc\", \"string\", \"ToString\"];\n pub const TO_STRING_METHOD: [&str; 4] = [\"alloc\", \"string\", \"ToString\", \"to_string\"];\n pub const TRANSMUTE: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n+pub const TRY_FROM: [&str; 4] = [\"core\", \"convert\", \"TryFrom\", \"try_from\"];\n pub const TRY_FROM_ERROR: [&str; 4] = [\"std\", \"ops\", \"Try\", \"from_error\"];\n pub const TRY_INTO_RESULT: [&str; 4] = [\"std\", \"ops\", \"Try\", \"into_result\"];\n+pub const TRY_INTO_TRAIT: [&str; 3] = [\"core\", \"convert\", \"TryInto\"];\n pub const VEC: [&str; 3] = [\"alloc\", \"vec\", \"Vec\"];\n pub const VEC_AS_MUT_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_mut_slice\"];\n pub const VEC_AS_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_slice\"];"}, {"sha": "73758b7eeb7eb28e27651a9ec36b9cc333e622d4", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -530,7 +530,7 @@ pub trait DiagnosticBuilderExt<'a, T: LintContext> {\n \n     /// Suggest to add an item before another.\n     ///\n-    /// The item should not be indented (expect for inner indentation).\n+    /// The item should not be indented (except for inner indentation).\n     ///\n     /// # Example\n     ///"}, {"sha": "8092be277cca01af4bfbf8905cee24e1bfc567c5", "filename": "doc/adding_lints.md", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -42,8 +42,10 @@ case), and we don't need type information so it will have an early pass type\n `cargo dev new_lint --name=foo_functions --pass=early --category=pedantic`\n (category will default to nursery if not provided). This command will create\n two files: `tests/ui/foo_functions.rs` and `clippy_lints/src/foo_functions.rs`,\n-as well as run `cargo dev update_lints` to register the new lint. Next, we'll\n-open up these files and add our lint!\n+as well as run `cargo dev update_lints` to register the new lint. For cargo lints,\n+two project hierarchies (fail/pass) will be created by default under `tests/ui-cargo`.\n+\n+Next, we'll open up these files and add our lint!\n \n ## Testing\n \n@@ -105,6 +107,24 @@ our lint, we need to commit the generated `.stderr` files, too. In general, you\n should only commit files changed by `tests/ui/update-all-references.sh` for the\n specific lint you are creating/editing.\n \n+### Cargo lints\n+\n+For cargo lints, the process of testing differs in that we are interested in\n+the `Cargo.toml` manifest file. We also need a minimal crate associated\n+with that manifest.\n+\n+If our new lint is named e.g. `foo_categories`, after running `cargo dev new_lint` \n+we will find by default two new crates, each with its manifest file:\n+\n+* `tests/ui-cargo/foo_categories/fail/Cargo.toml`: this file should cause the new lint to raise an error.\n+* `tests/ui-cargo/foo_categories/pass/Cargo.toml`: this file should not trigger the lint.\n+\n+If you need more cases, you can copy one of those crates (under `foo_categories`) and rename it.\n+\n+The process of generating the `.stderr` file is the same, and prepending the `TESTNAME`\n+variable to `cargo uitest` works too, but the script to update the references\n+is in another path: `tests/ui-cargo/update-all-references.sh`.\n+\n ## Rustfix tests\n \n If the lint you are working on is making use of structured suggestions, the\n@@ -445,6 +465,7 @@ Here are some pointers to things you are likely going to need for every lint:\n * [`from_expansion`][from_expansion] and [`in_external_macro`][in_external_macro]\n * [`Span`][span]\n * [`Applicability`][applicability]\n+* [Common tools for writing lints](common_tools_writing_lints.md) helps with common operations\n * [The rustc-dev-guide][rustc-dev-guide] explains a lot of internal compiler concepts\n * [The nightly rustc docs][nightly_docs] which has been linked to throughout\n   this guide"}, {"sha": "ed33b37c6bd1bb9598ec41cd46208b7df0f003d0", "filename": "doc/common_tools_writing_lints.md", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,152 @@\n+# Common tools for writing lints\n+\n+You may need following tooltips to catch up with common operations.\n+\n+- [Common tools for writing lints](#common-tools-for-writing-lints)\n+  - [Retrieving the type of an expression](#retrieving-the-type-of-an-expression)\n+  - [Checking if a type implements a specific trait](#checking-if-a-type-implements-a-specific-trait)\n+  - [Dealing with macros](#dealing-with-macros)\n+\n+Useful Rustc dev guide links:\n+- [Stages of compilation](https://rustc-dev-guide.rust-lang.org/compiler-src.html#the-main-stages-of-compilation)\n+- [Type checking](https://rustc-dev-guide.rust-lang.org/type-checking.html)\n+- [Ty module](https://rustc-dev-guide.rust-lang.org/ty.html)\n+\n+# Retrieving the type of an expression\n+\n+Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for example to answer following questions:\n+\n+- which type does this expression correspond to (using its [`TyKind`][TyKind])?\n+- is it a sized type? \n+- is it a primitive type?\n+- does it implement a trait?\n+\n+This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckTables`][TypeckTables] struct, \n+that gives you access to the underlying structure [`TyS`][TyS].\n+\n+Example of use:\n+```rust\n+impl LateLintPass<'_, '_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+        // Get type of `expr`\n+        let ty = cx.tables.expr_ty(expr);\n+        // Match its kind to enter its type\n+        match ty.kind {\n+            ty::Adt(adt_def, _) if adt_def.is_struct() => println!(\"Our `expr` is a struct!\"),\n+            _ => ()\n+        }\n+    }\n+}\n+```\n+\n+Similarly in [`TypeckTables`][TypeckTables] methods, you have the [`pat_ty()`][pat_ty] method \n+to retrieve a type from a pattern.\n+\n+Two noticeable items here:\n+- `cx` is the lint context [`LateContext`][LateContext]. \n+  The two most useful data structures in this context are `tcx` and `tables`, \n+  allowing us to jump to type definitions and other compilation stages such as HIR.\n+- `tables` is [`TypeckTables`][TypeckTables] and is created by type checking step, \n+  it includes useful information such as types of expressions, ways to resolve methods and so on.\n+\n+# Checking if a type implements a specific trait\n+\n+There are two ways to do this, depending if the target trait is part of lang items.\n+\n+```rust\n+use crate::utils::{implements_trait, match_trait_method, paths};\n+\n+impl LateLintPass<'_, '_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+        // 1. Using expression and Clippy's convenient method\n+        // we use `match_trait_method` function from Clippy's toolbox\n+        if match_trait_method(cx, expr, &paths::INTO) {\n+            // `expr` implements `Into` trait\n+        }\n+\n+        // 2. Using type context `TyCtxt`\n+        let ty = cx.tables.expr_ty(expr);\n+        if cx.tcx.lang_items()\n+            // we are looking for the `DefId` of `Drop` trait in lang items\n+            .drop_trait()\n+            // then we use it with our type `ty` by calling `implements_trait` from Clippy's utils\n+            .map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n+                // `expr` implements `Drop` trait\n+            }\n+    }\n+}\n+```\n+\n+> Prefer using lang items, if the target trait is available there.\n+\n+A list of defined paths for Clippy can be found in [paths.rs][paths]\n+\n+We access lang items through the type context `tcx`. `tcx` is of type [`TyCtxt`][TyCtxt] and is defined in the `rustc_middle` crate.\n+\n+# Dealing with macros\n+\n+There are several helpers in Clippy's utils to deal with macros:\n+\n+- `in_macro()`: detect if the given span is expanded by a macro\n+\n+You may want to use this for example to not start linting in any macro.\n+\n+```rust\n+macro_rules! foo {\n+    ($param:expr) => {\n+        match $param {\n+            \"bar\" => println!(\"whatever\"),\n+            _ => ()\n+        }\n+    };\n+}\n+\n+foo!(\"bar\");\n+\n+// if we lint the `match` of `foo` call and test its span\n+assert_eq!(in_macro(match_span), true);\n+```\n+\n+- `in_external_macro()`: detect if the given span is from an external macro, defined in a foreign crate\n+\n+You may want to use it for example to not start linting in macros from other crates\n+\n+```rust\n+#[macro_use]\n+extern crate a_crate_with_macros;\n+\n+// `foo` is defined in `a_crate_with_macros`\n+foo!(\"bar\");\n+\n+// if we lint the `match` of `foo` call and test its span\n+assert_eq!(in_external_macro(cx.sess(), match_span), true);\n+```\n+\n+- `differing_macro_contexts()`: returns true if the two given spans are not from the same context\n+\n+```rust\n+macro_rules! m {\n+    ($a:expr, $b:expr) => {\n+        if $a.is_some() {\n+            $b;\n+        }\n+    }\n+}\n+\n+let x: Option<u32> = Some(42);\n+m!(x, x.unwrap());\n+\n+// These spans are not from the same context\n+// x.is_some() is from inside the macro\n+// x.unwrap() is from outside the macro\n+assert_eq!(differing_macro_contexts(x_is_some_span, x_unwrap_span), true);\n+```\n+\n+[TyS]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html\n+[TyKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html\n+[TypeckTables]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckTables.html\n+[expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckTables.html#method.expr_ty\n+[LateContext]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html\n+[TyCtxt]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html\n+[pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckTables.html#method.pat_ty\n+[paths]: ../clippy_lints/src/utils/paths.rs"}, {"sha": "965b606f331b51d566b46025f9ff311a7aad0c12", "filename": "rustc_tools_util/LICENSE-APACHE", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/rustc_tools_util%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/rustc_tools_util%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tools_util%2FLICENSE-APACHE?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1 @@\n+../LICENSE-APACHE\n\\ No newline at end of file"}, {"sha": "76219eb72e8524f15c21ec93b9b2592da49b5460", "filename": "rustc_tools_util/LICENSE-MIT", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/rustc_tools_util%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/rustc_tools_util%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tools_util%2FLICENSE-MIT?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1 @@\n+../LICENSE-MIT\n\\ No newline at end of file"}, {"sha": "191ea4315a6b5a8a29e56f6440f88115c466e8b9", "filename": "setup-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/setup-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/setup-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/setup-toolchain.sh?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -32,5 +32,5 @@ else\n     TOOLCHAIN=()\n fi\n \n-rustup-toolchain-install-master -f -n master \"${TOOLCHAIN[@]}\" -c rustc-dev -- \"$RUST_COMMIT\"\n+rustup-toolchain-install-master -f -n master \"${TOOLCHAIN[@]}\" -c rustc-dev -c llvm-tools -- \"$RUST_COMMIT\"\n rustup override set master"}, {"sha": "70c47b426825e7f9b4a7cded8f9251ca5673adfc", "filename": "src/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -79,7 +79,7 @@ impl rustc_driver::Callbacks for ClippyCallbacks {\n \n             let conf = clippy_lints::read_conf(&[], &sess);\n             clippy_lints::register_plugins(&mut lint_store, &sess, &conf);\n-            clippy_lints::register_pre_expansion_lints(&mut lint_store, &conf);\n+            clippy_lints::register_pre_expansion_lints(&mut lint_store);\n             clippy_lints::register_renamed(&mut lint_store);\n         }));\n "}, {"sha": "f63301c7db0a6c9019ad83bd89c283c370437744", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1195,11 +1195,18 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     },\n     Lint {\n         name: \"match_wild_err_arm\",\n-        group: \"style\",\n+        group: \"pedantic\",\n         desc: \"a `match` with `Err(_)` arm and take drastic actions\",\n         deprecation: None,\n         module: \"matches\",\n     },\n+    Lint {\n+        name: \"match_wildcard_for_single_variants\",\n+        group: \"pedantic\",\n+        desc: \"a wildcard enum match for a single variant\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n     Lint {\n         name: \"maybe_infinite_iter\",\n         group: \"pedantic\",\n@@ -2414,7 +2421,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     Lint {\n         name: \"useless_conversion\",\n         group: \"complexity\",\n-        desc: \"calls to `Into`/`From`/`IntoIter` that performs useless conversions to the same type\",\n+        desc: \"calls to `Into`, `TryInto`, `From`, `TryFrom`, `IntoIter` that performs useless conversions to the same type\",\n         deprecation: None,\n         module: \"useless_conversion\",\n     },"}, {"sha": "2758b9a7e760439433abd5011244713d2b9c75c8", "filename": "tests/compile-test.rs", "status": "modified", "additions": 115, "deletions": 35, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -38,13 +38,13 @@ fn clippy_driver_path() -> PathBuf {\n //        as what we manually pass to `cargo` invocation\n fn third_party_crates() -> String {\n     use std::collections::HashMap;\n-    static CRATES: &[&str] = &[\"serde\", \"serde_derive\", \"regex\", \"clippy_lints\"];\n+    static CRATES: &[&str] = &[\"serde\", \"serde_derive\", \"regex\", \"clippy_lints\", \"syn\", \"quote\"];\n     let dep_dir = cargo::TARGET_LIB.join(\"deps\");\n     let mut crates: HashMap<&str, PathBuf> = HashMap::with_capacity(CRATES.len());\n     for entry in fs::read_dir(dep_dir).unwrap() {\n         let path = match entry {\n             Ok(entry) => entry.path(),\n-            _ => continue,\n+            Err(_) => continue,\n         };\n         if let Some(name) = path.file_name().and_then(OsStr::to_str) {\n             for dep in CRATES {\n@@ -101,54 +101,133 @@ fn run_mode(cfg: &mut compiletest::Config) {\n     compiletest::run_tests(&cfg);\n }\n \n-#[allow(clippy::identity_conversion)]\n-fn run_ui_toml_tests(config: &compiletest::Config, mut tests: Vec<tester::TestDescAndFn>) -> Result<bool, io::Error> {\n-    let mut result = true;\n-    let opts = compiletest::test_opts(config);\n-    for dir in fs::read_dir(&config.src_base)? {\n-        let dir = dir?;\n-        if !dir.file_type()?.is_dir() {\n-            continue;\n-        }\n-        let dir_path = dir.path();\n-        set_var(\"CARGO_MANIFEST_DIR\", &dir_path);\n-        for file in fs::read_dir(&dir_path)? {\n-            let file = file?;\n-            let file_path = file.path();\n-            if file.file_type()?.is_dir() {\n+fn run_ui_toml(config: &mut compiletest::Config) {\n+    fn run_tests(config: &compiletest::Config, mut tests: Vec<tester::TestDescAndFn>) -> Result<bool, io::Error> {\n+        let mut result = true;\n+        let opts = compiletest::test_opts(config);\n+        for dir in fs::read_dir(&config.src_base)? {\n+            let dir = dir?;\n+            if !dir.file_type()?.is_dir() {\n                 continue;\n             }\n-            if file_path.extension() != Some(OsStr::new(\"rs\")) {\n-                continue;\n+            let dir_path = dir.path();\n+            set_var(\"CARGO_MANIFEST_DIR\", &dir_path);\n+            for file in fs::read_dir(&dir_path)? {\n+                let file = file?;\n+                let file_path = file.path();\n+                if file.file_type()?.is_dir() {\n+                    continue;\n+                }\n+                if file_path.extension() != Some(OsStr::new(\"rs\")) {\n+                    continue;\n+                }\n+                let paths = compiletest::common::TestPaths {\n+                    file: file_path,\n+                    base: config.src_base.clone(),\n+                    relative_dir: dir_path.file_name().unwrap().into(),\n+                };\n+                let test_name = compiletest::make_test_name(&config, &paths);\n+                let index = tests\n+                    .iter()\n+                    .position(|test| test.desc.name == test_name)\n+                    .expect(\"The test should be in there\");\n+                result &= tester::run_tests_console(&opts, vec![tests.swap_remove(index)])?;\n             }\n-            let paths = compiletest::common::TestPaths {\n-                file: file_path,\n-                base: config.src_base.clone(),\n-                relative_dir: dir_path.file_name().unwrap().into(),\n-            };\n-            let test_name = compiletest::make_test_name(&config, &paths);\n-            let index = tests\n-                .iter()\n-                .position(|test| test.desc.name == test_name)\n-                .expect(\"The test should be in there\");\n-            result &= tester::run_tests_console(&opts, vec![tests.swap_remove(index)])?;\n         }\n+        Ok(result)\n     }\n-    Ok(result)\n-}\n \n-fn run_ui_toml(config: &mut compiletest::Config) {\n     config.mode = TestMode::Ui;\n     config.src_base = Path::new(\"tests\").join(\"ui-toml\").canonicalize().unwrap();\n \n     let tests = compiletest::make_tests(&config);\n \n-    let res = run_ui_toml_tests(&config, tests);\n+    let res = run_tests(&config, tests);\n+    match res {\n+        Ok(true) => {},\n+        Ok(false) => panic!(\"Some tests failed\"),\n+        Err(e) => {\n+            panic!(\"I/O failure during tests: {:?}\", e);\n+        },\n+    }\n+}\n+\n+fn run_ui_cargo(config: &mut compiletest::Config) {\n+    fn run_tests(\n+        config: &compiletest::Config,\n+        filter: &Option<String>,\n+        mut tests: Vec<tester::TestDescAndFn>,\n+    ) -> Result<bool, io::Error> {\n+        let mut result = true;\n+        let opts = compiletest::test_opts(config);\n+\n+        for dir in fs::read_dir(&config.src_base)? {\n+            let dir = dir?;\n+            if !dir.file_type()?.is_dir() {\n+                continue;\n+            }\n+\n+            // Use the filter if provided\n+            let dir_path = dir.path();\n+            match &filter {\n+                Some(name) if !dir_path.ends_with(name) => continue,\n+                _ => {},\n+            }\n+\n+            for case in fs::read_dir(&dir_path)? {\n+                let case = case?;\n+                if !case.file_type()?.is_dir() {\n+                    continue;\n+                }\n+\n+                let src_path = case.path().join(\"src\");\n+                env::set_current_dir(&src_path)?;\n+\n+                for file in fs::read_dir(&src_path)? {\n+                    let file = file?;\n+                    if file.file_type()?.is_dir() {\n+                        continue;\n+                    }\n+\n+                    // Search for the main file to avoid running a test for each file in the project\n+                    let file_path = file.path();\n+                    match file_path.file_name().and_then(OsStr::to_str) {\n+                        Some(\"main.rs\") => {},\n+                        _ => continue,\n+                    }\n+\n+                    let paths = compiletest::common::TestPaths {\n+                        file: file_path,\n+                        base: config.src_base.clone(),\n+                        relative_dir: src_path.strip_prefix(&config.src_base).unwrap().into(),\n+                    };\n+                    let test_name = compiletest::make_test_name(&config, &paths);\n+                    let index = tests\n+                        .iter()\n+                        .position(|test| test.desc.name == test_name)\n+                        .expect(\"The test should be in there\");\n+                    result &= tester::run_tests_console(&opts, vec![tests.swap_remove(index)])?;\n+                }\n+            }\n+        }\n+        Ok(result)\n+    }\n+\n+    config.mode = TestMode::Ui;\n+    config.src_base = Path::new(\"tests\").join(\"ui-cargo\").canonicalize().unwrap();\n+\n+    let tests = compiletest::make_tests(&config);\n+\n+    let current_dir = env::current_dir().unwrap();\n+    let filter = env::var(\"TESTNAME\").ok();\n+    let res = run_tests(&config, &filter, tests);\n+    env::set_current_dir(current_dir).unwrap();\n+\n     match res {\n         Ok(true) => {},\n         Ok(false) => panic!(\"Some tests failed\"),\n         Err(e) => {\n-            println!(\"I/O failure during tests: {:?}\", e);\n+            panic!(\"I/O failure during tests: {:?}\", e);\n         },\n     }\n }\n@@ -165,4 +244,5 @@ fn compile_test() {\n     let mut config = default_config();\n     run_mode(&mut config);\n     run_ui_toml(&mut config);\n+    run_ui_cargo(&mut config);\n }"}, {"sha": "c64adcf7c013154d895e6f8811d8f65b7ecb53d8", "filename": "tests/ui-cargo/cargo_common_metadata/fail/Cargo.toml", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2FCargo.toml?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,4 @@\n+[package]\n+name = \"cargo_common_metadata\"\n+version = \"0.1.0\"\n+publish = false"}, {"sha": "27841e18aa9ef830cb1daf4080d0acd19a3b3c97", "filename": "tests/ui-cargo/cargo_common_metadata/fail/src/main.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2Fsrc%2Fmain.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: --crate-name=cargo_common_metadata\n+#![warn(clippy::cargo_common_metadata)]\n+\n+fn main() {}"}, {"sha": "c8ae6c820df9de4de3f3561451d27e97c9416563", "filename": "tests/ui-cargo/cargo_common_metadata/fail/src/main.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2Fsrc%2Fmain.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,18 @@\n+error: package `cargo_common_metadata` is missing `package.authors` metadata\n+   |\n+   = note: `-D clippy::cargo-common-metadata` implied by `-D warnings`\n+\n+error: package `cargo_common_metadata` is missing `package.description` metadata\n+\n+error: package `cargo_common_metadata` is missing `either package.license or package.license_file` metadata\n+\n+error: package `cargo_common_metadata` is missing `package.repository` metadata\n+\n+error: package `cargo_common_metadata` is missing `package.readme` metadata\n+\n+error: package `cargo_common_metadata` is missing `package.keywords` metadata\n+\n+error: package `cargo_common_metadata` is missing `package.categories` metadata\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "c8233f328bb05a49de5cdfa5b7e7fba41e5b14be", "filename": "tests/ui-cargo/cargo_common_metadata/pass/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fcargo_common_metadata%2Fpass%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fcargo_common_metadata%2Fpass%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fcargo_common_metadata%2Fpass%2FCargo.toml?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+name = \"cargo_common_metadata\"\n+version = \"0.1.0\"\n+publish = false\n+authors = [\"Random person from the Internet <someone@someplace.org>\"]\n+description = \"A test package for the cargo_common_metadata lint\"\n+repository = \"https://github.com/someone/cargo_common_metadata\"\n+readme = \"README.md\"\n+license = \"MIT OR Apache-2.0\"\n+keywords = [\"metadata\", \"lint\", \"clippy\"]\n+categories = [\"development-tools::testing\"]"}, {"sha": "27841e18aa9ef830cb1daf4080d0acd19a3b3c97", "filename": "tests/ui-cargo/cargo_common_metadata/pass/src/main.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fcargo_common_metadata%2Fpass%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fcargo_common_metadata%2Fpass%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fcargo_common_metadata%2Fpass%2Fsrc%2Fmain.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: --crate-name=cargo_common_metadata\n+#![warn(clippy::cargo_common_metadata)]\n+\n+fn main() {}"}, {"sha": "72731fbc75d00c3e3587bc91de4ffc3d3bd31f23", "filename": "tests/ui-cargo/multiple_crate_versions/5041_allow_dev_build/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2F5041_allow_dev_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2F5041_allow_dev_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmultiple_crate_versions%2F5041_allow_dev_build%2FCargo.toml?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,17 @@\n+# Should not lint for dev or build dependencies. See issue 5041.\n+\n+[package]\n+name = \"multiple_crate_versions\"\n+version = \"0.1.0\"\n+publish = false\n+\n+# One of the versions of winapi is only a dev dependency: allowed\n+[dependencies]\n+ctrlc = \"=3.1.0\"\n+[dev-dependencies]\n+ansi_term = \"=0.11.0\"\n+\n+# Both versions of winapi are a build dependency: allowed\n+[build-dependencies]\n+ctrlc = \"=3.1.0\"\n+ansi_term = \"=0.11.0\""}, {"sha": "1b2d3ec9459f9520ec0c8201dad49ac265051fd8", "filename": "tests/ui-cargo/multiple_crate_versions/5041_allow_dev_build/src/main.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2F5041_allow_dev_build%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2F5041_allow_dev_build%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmultiple_crate_versions%2F5041_allow_dev_build%2Fsrc%2Fmain.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: --crate-name=multiple_crate_versions\n+#![warn(clippy::multiple_crate_versions)]\n+\n+fn main() {}"}, {"sha": "3a94b723f3fdbd02355135b49d6720c4eb2411e2", "filename": "tests/ui-cargo/multiple_crate_versions/fail/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2FCargo.toml?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"multiple_crate_versions\"\n+version = \"0.1.0\"\n+publish = false\n+\n+[dependencies]\n+ctrlc = \"=3.1.0\"\n+ansi_term = \"=0.11.0\""}, {"sha": "1b2d3ec9459f9520ec0c8201dad49ac265051fd8", "filename": "tests/ui-cargo/multiple_crate_versions/fail/src/main.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2Fsrc%2Fmain.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: --crate-name=multiple_crate_versions\n+#![warn(clippy::multiple_crate_versions)]\n+\n+fn main() {}"}, {"sha": "4f668599be950ffbae42e0af7bbd8c30f99887fa", "filename": "tests/ui-cargo/multiple_crate_versions/fail/src/main.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2Fsrc%2Fmain.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,6 @@\n+error: multiple versions for dependency `winapi`: 0.2.8, 0.3.8\n+   |\n+   = note: `-D clippy::multiple-crate-versions` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "a9b06420b333da3a7ee0cbdd0e3e751abd829b81", "filename": "tests/ui-cargo/multiple_crate_versions/pass/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2Fpass%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2Fpass%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmultiple_crate_versions%2Fpass%2FCargo.toml?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"cargo_common_metadata\"\n+version = \"0.1.0\"\n+publish = false\n+\n+[dependencies]\n+regex = \"1.3.7\"\n+serde = \"1.0.110\""}, {"sha": "1b2d3ec9459f9520ec0c8201dad49ac265051fd8", "filename": "tests/ui-cargo/multiple_crate_versions/pass/src/main.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2Fpass%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fmultiple_crate_versions%2Fpass%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmultiple_crate_versions%2Fpass%2Fsrc%2Fmain.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: --crate-name=multiple_crate_versions\n+#![warn(clippy::multiple_crate_versions)]\n+\n+fn main() {}"}, {"sha": "7028b251ea0307bb669524afb702a8d62a038924", "filename": "tests/ui-cargo/update-all-references.sh", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fupdate-all-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fupdate-all-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fupdate-all-references.sh?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,18 @@\n+#!/bin/bash\n+#\n+# A script to update the references for all tests. The idea is that\n+# you do a run, which will generate files in the build directory\n+# containing the (normalized) actual output of the compiler. You then\n+# run this script, which will copy those files over. If you find\n+# yourself manually editing a foo.stderr file, you're doing it wrong.\n+#\n+# See all `update-references.sh`, if you just want to update a single test.\n+\n+if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" ]]; then\n+    echo \"usage: $0\"\n+fi\n+\n+BUILD_DIR=$PWD/target/debug/test_build_base\n+MY_DIR=$(dirname \"$0\")\n+cd \"$MY_DIR\" || exit\n+find . -name '*.rs' -exec ./update-references.sh \"$BUILD_DIR\" {} +"}, {"sha": "50d42678734e9caca32b8d6c806ed576f4b04a8e", "filename": "tests/ui-cargo/update-references.sh", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fupdate-references.sh?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,38 @@\n+#!/bin/bash\n+\n+# A script to update the references for particular tests. The idea is\n+# that you do a run, which will generate files in the build directory\n+# containing the (normalized) actual output of the compiler. This\n+# script will then copy that output and replace the \"expected output\"\n+# files. You can then commit the changes.\n+#\n+# If you find yourself manually editing a foo.stderr file, you're\n+# doing it wrong.\n+\n+if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" || \"$1\" == \"\" || \"$2\" == \"\" ]]; then\n+    echo \"usage: $0 <build-directory> <relative-path-to-rs-files>\"\n+    echo \"\"\n+    echo \"For example:\"\n+    echo \"   $0 ../../../build/x86_64-apple-darwin/test/ui *.rs */*.rs\"\n+fi\n+\n+MYDIR=$(dirname \"$0\")\n+\n+BUILD_DIR=\"$1\"\n+shift\n+\n+while [[ \"$1\" != \"\" ]]; do\n+    STDERR_NAME=\"${1/%.rs/.stderr}\"\n+    STDOUT_NAME=\"${1/%.rs/.stdout}\"\n+    shift\n+    if [[ -f \"$BUILD_DIR\"/\"$STDOUT_NAME\" ]] && \\\n+           ! (cmp -s -- \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"); then\n+        echo updating \"$MYDIR\"/\"$STDOUT_NAME\"\n+        cp \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"\n+    fi\n+    if [[ -f \"$BUILD_DIR\"/\"$STDERR_NAME\" ]] && \\\n+           ! (cmp -s -- \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"); then\n+        echo updating \"$MYDIR\"/\"$STDERR_NAME\"\n+        cp \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"\n+    fi\n+done"}, {"sha": "fd2a341485683d6effcd79e3f45ef98a65b508d0", "filename": "tests/ui-cargo/wildcard_dependencies/fail/Cargo.toml", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fwildcard_dependencies%2Ffail%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fwildcard_dependencies%2Ffail%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fwildcard_dependencies%2Ffail%2FCargo.toml?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,7 @@\n+[package]\n+name = \"wildcard_dependencies\"\n+version = \"0.1.0\"\n+publish = false\n+\n+[dependencies]\n+regex = \"*\""}, {"sha": "581babfeacbff7445a7655f5cdb5c536f6bc18b8", "filename": "tests/ui-cargo/wildcard_dependencies/fail/src/main.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fwildcard_dependencies%2Ffail%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fwildcard_dependencies%2Ffail%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fwildcard_dependencies%2Ffail%2Fsrc%2Fmain.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: --crate-name=wildcard_dependencies\n+#![warn(clippy::wildcard_dependencies)]\n+\n+fn main() {}"}, {"sha": "9e65d2f99420a1c56c03d1c4073a0e8de6ced801", "filename": "tests/ui-cargo/wildcard_dependencies/fail/src/main.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fwildcard_dependencies%2Ffail%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fwildcard_dependencies%2Ffail%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fwildcard_dependencies%2Ffail%2Fsrc%2Fmain.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,6 @@\n+error: wildcard dependency for `regex`\n+   |\n+   = note: `-D clippy::wildcard-dependencies` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "38cb139146e0563f6ab556af93278c35fc586ac7", "filename": "tests/ui-cargo/wildcard_dependencies/pass/Cargo.toml", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fwildcard_dependencies%2Fpass%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fwildcard_dependencies%2Fpass%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fwildcard_dependencies%2Fpass%2FCargo.toml?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,7 @@\n+[package]\n+name = \"wildcard_dependencies\"\n+version = \"0.1.0\"\n+publish = false\n+\n+[dependencies]\n+regex = \"1\""}, {"sha": "581babfeacbff7445a7655f5cdb5c536f6bc18b8", "filename": "tests/ui-cargo/wildcard_dependencies/pass/src/main.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fwildcard_dependencies%2Fpass%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui-cargo%2Fwildcard_dependencies%2Fpass%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fwildcard_dependencies%2Fpass%2Fsrc%2Fmain.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: --crate-name=wildcard_dependencies\n+#![warn(clippy::wildcard_dependencies)]\n+\n+fn main() {}"}, {"sha": "e6626d57a772253f7db6def1ce4c17e99e25562a", "filename": "tests/ui/auxiliary/proc_macro_attr.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fauxiliary%2Fproc_macro_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fauxiliary%2Fproc_macro_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macro_attr.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,37 @@\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(repr128, proc_macro_hygiene, proc_macro_quote)]\n+#![allow(clippy::useless_conversion)]\n+\n+extern crate proc_macro;\n+extern crate quote;\n+extern crate syn;\n+\n+use proc_macro::TokenStream;\n+use quote::{quote, quote_spanned};\n+use syn::parse_macro_input;\n+use syn::{parse_quote, ItemTrait, TraitItem};\n+\n+#[proc_macro_attribute]\n+pub fn fake_async_trait(_args: TokenStream, input: TokenStream) -> TokenStream {\n+    let mut item = parse_macro_input!(input as ItemTrait);\n+    for inner in &mut item.items {\n+        if let TraitItem::Method(method) = inner {\n+            let sig = &method.sig;\n+            let block = &mut method.default;\n+            if let Some(block) = block {\n+                let brace = block.brace_token;\n+\n+                let my_block = quote_spanned!( brace.span => {\n+                    // Should not trigger `empty_line_after_outer_attr`\n+                    #[crate_type = \"lib\"]\n+                    #sig #block\n+                    Vec::new()\n+                });\n+                *block = parse_quote!(#my_block);\n+            }\n+        }\n+    }\n+    TokenStream::from(quote!(#item))\n+}"}, {"sha": "912e6788afddcacce8f7f3b2887ebe54ca85377a", "filename": "tests/ui/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcognitive_complexity.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1,6 +1,6 @@\n #![allow(clippy::all)]\n #![warn(clippy::cognitive_complexity)]\n-#![allow(unused)]\n+#![allow(unused, unused_crate_dependencies)]\n \n #[rustfmt::skip]\n fn main() {"}, {"sha": "771a26fc9a86d5f5257628eaf0a7024fdb13f1c9", "filename": "tests/ui/cognitive_complexity_attr_used.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fcognitive_complexity_attr_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fcognitive_complexity_attr_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcognitive_complexity_attr_used.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1,5 +1,5 @@\n-#![warn(clippy::cognitive_complexity)]\n-#![warn(unused)]\n+#![warn(unused, clippy::cognitive_complexity)]\n+#![allow(unused_crate_dependencies)]\n \n fn main() {\n     kaboom();"}, {"sha": "3e92bca986ab55b4990a8d32e4f3f64a89f65289", "filename": "tests/ui/empty_line_after_outer_attribute.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fempty_line_after_outer_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fempty_line_after_outer_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_line_after_outer_attribute.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1,8 +1,12 @@\n+// aux-build:proc_macro_attr.rs\n #![warn(clippy::empty_line_after_outer_attr)]\n #![allow(clippy::assertions_on_constants)]\n #![feature(custom_inner_attributes)]\n #![rustfmt::skip]\n \n+#[macro_use]\n+extern crate proc_macro_attr;\n+\n // This should produce a warning\n #[crate_type = \"lib\"]\n \n@@ -93,4 +97,17 @@ pub struct S;\n /* test */\n pub struct T;\n \n-fn main() { }\n+// This should not produce a warning\n+// See https://github.com/rust-lang/rust-clippy/issues/5567\n+#[fake_async_trait]\n+pub trait Bazz {\n+    fn foo() -> Vec<u8> {\n+        let _i = \"\";\n+\n+\n+\n+        vec![]\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "bf753a732f000f78c956833f7ea3f7f25bed7286", "filename": "tests/ui/empty_line_after_outer_attribute.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fempty_line_after_outer_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fempty_line_after_outer_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_line_after_outer_attribute.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1,5 +1,5 @@\n error: Found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n-  --> $DIR/empty_line_after_outer_attribute.rs:7:1\n+  --> $DIR/empty_line_after_outer_attribute.rs:11:1\n    |\n LL | / #[crate_type = \"lib\"]\n LL | |\n@@ -10,15 +10,15 @@ LL | | fn with_one_newline_and_comment() { assert!(true) }\n    = note: `-D clippy::empty-line-after-outer-attr` implied by `-D warnings`\n \n error: Found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n-  --> $DIR/empty_line_after_outer_attribute.rs:19:1\n+  --> $DIR/empty_line_after_outer_attribute.rs:23:1\n    |\n LL | / #[crate_type = \"lib\"]\n LL | |\n LL | | fn with_one_newline() { assert!(true) }\n    | |_\n \n error: Found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n-  --> $DIR/empty_line_after_outer_attribute.rs:24:1\n+  --> $DIR/empty_line_after_outer_attribute.rs:28:1\n    |\n LL | / #[crate_type = \"lib\"]\n LL | |\n@@ -27,23 +27,23 @@ LL | | fn with_two_newlines() { assert!(true) }\n    | |_\n \n error: Found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n-  --> $DIR/empty_line_after_outer_attribute.rs:31:1\n+  --> $DIR/empty_line_after_outer_attribute.rs:35:1\n    |\n LL | / #[crate_type = \"lib\"]\n LL | |\n LL | | enum Baz {\n    | |_\n \n error: Found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n-  --> $DIR/empty_line_after_outer_attribute.rs:39:1\n+  --> $DIR/empty_line_after_outer_attribute.rs:43:1\n    |\n LL | / #[crate_type = \"lib\"]\n LL | |\n LL | | struct Foo {\n    | |_\n \n error: Found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n-  --> $DIR/empty_line_after_outer_attribute.rs:47:1\n+  --> $DIR/empty_line_after_outer_attribute.rs:51:1\n    |\n LL | / #[crate_type = \"lib\"]\n LL | |"}, {"sha": "b59dbb3e76c6455ac99d678f4bba6cca14bd7fd6", "filename": "tests/ui/future_not_send.stderr", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Ffuture_not_send.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Ffuture_not_send.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffuture_not_send.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -47,17 +47,32 @@ error: future cannot be sent between threads safely\n   --> $DIR/future_not_send.rs:20:63\n    |\n LL | async fn private_future2(rc: Rc<[u8]>, cell: &Cell<usize>) -> bool {\n-   |                                                               ^^^^\n+   |                                                               ^^^^ future returned by `private_future2` is not `Send`\n    |\n+note: captured value is not `Send`\n+  --> $DIR/future_not_send.rs:20:26\n+   |\n+LL | async fn private_future2(rc: Rc<[u8]>, cell: &Cell<usize>) -> bool {\n+   |                          ^^ has type `std::rc::Rc<[u8]>` which is not `Send`\n    = note: `std::rc::Rc<[u8]>` doesn't implement `std::marker::Send`\n+note: captured value is not `Send`\n+  --> $DIR/future_not_send.rs:20:40\n+   |\n+LL | async fn private_future2(rc: Rc<[u8]>, cell: &Cell<usize>) -> bool {\n+   |                                        ^^^^ has type `&std::cell::Cell<usize>` which is not `Send`\n    = note: `std::cell::Cell<usize>` doesn't implement `std::marker::Sync`\n \n error: future cannot be sent between threads safely\n   --> $DIR/future_not_send.rs:24:43\n    |\n LL | pub async fn public_future2(rc: Rc<[u8]>) {}\n-   |                                           ^\n+   |                                           ^ future returned by `public_future2` is not `Send`\n    |\n+note: captured value is not `Send`\n+  --> $DIR/future_not_send.rs:24:29\n+   |\n+LL | pub async fn public_future2(rc: Rc<[u8]>) {}\n+   |                             ^^ has type `std::rc::Rc<[u8]>` which is not `Send`\n    = note: `std::rc::Rc<[u8]>` doesn't implement `std::marker::Send`\n \n error: future cannot be sent between threads safely\n@@ -117,8 +132,13 @@ error: future cannot be sent between threads safely\n   --> $DIR/future_not_send.rs:66:34\n    |\n LL | async fn unclear_future<T>(t: T) {}\n-   |                                  ^\n+   |                                  ^ future returned by `unclear_future` is not `Send`\n    |\n+note: captured value is not `Send`\n+  --> $DIR/future_not_send.rs:66:28\n+   |\n+LL | async fn unclear_future<T>(t: T) {}\n+   |                            ^ has type `T` which is not `Send`\n    = note: `T` doesn't implement `std::marker::Send`\n \n error: aborting due to 8 previous errors"}, {"sha": "6a2a02987dea7497b3773f4443c12b3d98fc76d9", "filename": "tests/ui/match_wild_err_arm.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fmatch_wild_err_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fmatch_wild_err_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wild_err_arm.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -5,31 +5,31 @@ LL |         Err(_) => panic!(\"err\"),\n    |         ^^^^^^\n    |\n    = note: `-D clippy::match-wild-err-arm` implied by `-D warnings`\n-   = note: match each error separately or use the error output\n+   = note: match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\n \n error: `Err(_)` matches all errors\n   --> $DIR/match_wild_err_arm.rs:17:9\n    |\n LL |         Err(_) => panic!(),\n    |         ^^^^^^\n    |\n-   = note: match each error separately or use the error output\n+   = note: match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\n \n error: `Err(_)` matches all errors\n   --> $DIR/match_wild_err_arm.rs:23:9\n    |\n LL |         Err(_) => {\n    |         ^^^^^^\n    |\n-   = note: match each error separately or use the error output\n+   = note: match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\n \n error: `Err(_e)` matches all errors\n   --> $DIR/match_wild_err_arm.rs:31:9\n    |\n LL |         Err(_e) => panic!(),\n    |         ^^^^^^^\n    |\n-   = note: match each error separately or use the error output\n+   = note: match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\n \n error: aborting due to 4 previous errors\n "}, {"sha": "519200977a798d4356e29bf8bea1b55dcce5fa16", "filename": "tests/ui/match_wildcard_for_single_variants.fixed", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,59 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_wildcard_for_single_variants)]\n+#![allow(dead_code)]\n+\n+enum Foo {\n+    A,\n+    B,\n+    C,\n+}\n+\n+enum Color {\n+    Red,\n+    Green,\n+    Blue,\n+    Rgb(u8, u8, u8),\n+}\n+\n+fn main() {\n+    let f = Foo::A;\n+    match f {\n+        Foo::A => {},\n+        Foo::B => {},\n+        Foo::C => {},\n+    }\n+\n+    let color = Color::Red;\n+\n+    // check exhaustive bindings\n+    match color {\n+        Color::Red => {},\n+        Color::Green => {},\n+        Color::Rgb(_r, _g, _b) => {},\n+        Color::Blue => {},\n+    }\n+\n+    // check exhaustive wild\n+    match color {\n+        Color::Red => {},\n+        Color::Green => {},\n+        Color::Rgb(..) => {},\n+        Color::Blue => {},\n+    }\n+    match color {\n+        Color::Red => {},\n+        Color::Green => {},\n+        Color::Rgb(_, _, _) => {},\n+        Color::Blue => {},\n+    }\n+\n+    // shouldn't lint as there is one missing variant\n+    // and one that isn't exhaustively covered\n+    match color {\n+        Color::Red => {},\n+        Color::Green => {},\n+        Color::Rgb(255, _, _) => {},\n+        _ => {},\n+    }\n+}"}, {"sha": "1df917e085c7123a947294226dae591e207e0f3f", "filename": "tests/ui/match_wildcard_for_single_variants.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fmatch_wildcard_for_single_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fmatch_wildcard_for_single_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wildcard_for_single_variants.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,59 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_wildcard_for_single_variants)]\n+#![allow(dead_code)]\n+\n+enum Foo {\n+    A,\n+    B,\n+    C,\n+}\n+\n+enum Color {\n+    Red,\n+    Green,\n+    Blue,\n+    Rgb(u8, u8, u8),\n+}\n+\n+fn main() {\n+    let f = Foo::A;\n+    match f {\n+        Foo::A => {},\n+        Foo::B => {},\n+        _ => {},\n+    }\n+\n+    let color = Color::Red;\n+\n+    // check exhaustive bindings\n+    match color {\n+        Color::Red => {},\n+        Color::Green => {},\n+        Color::Rgb(_r, _g, _b) => {},\n+        _ => {},\n+    }\n+\n+    // check exhaustive wild\n+    match color {\n+        Color::Red => {},\n+        Color::Green => {},\n+        Color::Rgb(..) => {},\n+        _ => {},\n+    }\n+    match color {\n+        Color::Red => {},\n+        Color::Green => {},\n+        Color::Rgb(_, _, _) => {},\n+        _ => {},\n+    }\n+\n+    // shouldn't lint as there is one missing variant\n+    // and one that isn't exhaustively covered\n+    match color {\n+        Color::Red => {},\n+        Color::Green => {},\n+        Color::Rgb(255, _, _) => {},\n+        _ => {},\n+    }\n+}"}, {"sha": "82790aa9e80bba14c4c5e652ac67654dc78f3554", "filename": "tests/ui/match_wildcard_for_single_variants.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fmatch_wildcard_for_single_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fmatch_wildcard_for_single_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wildcard_for_single_variants.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,28 @@\n+error: wildcard match will miss any future added variants\n+  --> $DIR/match_wildcard_for_single_variants.rs:24:9\n+   |\n+LL |         _ => {},\n+   |         ^ help: try this: `Foo::C`\n+   |\n+   = note: `-D clippy::match-wildcard-for-single-variants` implied by `-D warnings`\n+\n+error: wildcard match will miss any future added variants\n+  --> $DIR/match_wildcard_for_single_variants.rs:34:9\n+   |\n+LL |         _ => {},\n+   |         ^ help: try this: `Color::Blue`\n+\n+error: wildcard match will miss any future added variants\n+  --> $DIR/match_wildcard_for_single_variants.rs:42:9\n+   |\n+LL |         _ => {},\n+   |         ^ help: try this: `Color::Blue`\n+\n+error: wildcard match will miss any future added variants\n+  --> $DIR/match_wildcard_for_single_variants.rs:48:9\n+   |\n+LL |         _ => {},\n+   |         ^ help: try this: `Color::Blue`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "3b6041823d8786672ec6bb3d7bdae19acaeaa428", "filename": "tests/ui/new_without_default.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_without_default.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -148,4 +148,15 @@ impl AllowDerive {\n     }\n }\n \n+pub struct NewNotEqualToDerive {\n+    foo: i32,\n+}\n+\n+impl NewNotEqualToDerive {\n+    // This `new` implementation is not equal to a derived `Default`, so do not suggest deriving.\n+    pub fn new() -> Self {\n+        NewNotEqualToDerive { foo: 1 }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "e529e441eb735c6b60cb59d5090fa5a22763bfdb", "filename": "tests/ui/new_without_default.stderr", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fnew_without_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fnew_without_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_without_default.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1,4 +1,4 @@\n-error: you should consider deriving a `Default` implementation for `Foo`\n+error: you should consider adding a `Default` implementation for `Foo`\n   --> $DIR/new_without_default.rs:8:5\n    |\n LL | /     pub fn new() -> Foo {\n@@ -9,10 +9,14 @@ LL | |     }\n    = note: `-D clippy::new-without-default` implied by `-D warnings`\n help: try this\n    |\n-LL | #[derive(Default)]\n+LL | impl Default for Foo {\n+LL |     fn default() -> Self {\n+LL |         Self::new()\n+LL |     }\n+LL | }\n    |\n \n-error: you should consider deriving a `Default` implementation for `Bar`\n+error: you should consider adding a `Default` implementation for `Bar`\n   --> $DIR/new_without_default.rs:16:5\n    |\n LL | /     pub fn new() -> Self {\n@@ -22,7 +26,11 @@ LL | |     }\n    |\n help: try this\n    |\n-LL | #[derive(Default)]\n+LL | impl Default for Bar {\n+LL |     fn default() -> Self {\n+LL |         Self::new()\n+LL |     }\n+LL | }\n    |\n \n error: you should consider adding a `Default` implementation for `LtKo<'c>`\n@@ -42,5 +50,22 @@ LL |     }\n LL | }\n    |\n \n-error: aborting due to 3 previous errors\n+error: you should consider adding a `Default` implementation for `NewNotEqualToDerive`\n+  --> $DIR/new_without_default.rs:157:5\n+   |\n+LL | /     pub fn new() -> Self {\n+LL | |         NewNotEqualToDerive { foo: 1 }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL | impl Default for NewNotEqualToDerive {\n+LL |     fn default() -> Self {\n+LL |         Self::new()\n+LL |     }\n+LL | }\n+   |\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "a2617a13ecace67dd0543b49da8e62996b5bdec7", "filename": "tests/ui/option_option.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Foption_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Foption_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_option.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -60,3 +60,28 @@ fn main() {\n     // The lint allows this\n     let expr = Some(Some(true));\n }\n+\n+extern crate serde;\n+mod issue_4298 {\n+    use serde::{Deserialize, Deserializer, Serialize};\n+    use std::borrow::Cow;\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct Foo<'a> {\n+        #[serde(deserialize_with = \"func\")]\n+        #[serde(skip_serializing_if = \"Option::is_none\")]\n+        #[serde(default)]\n+        #[serde(borrow)]\n+        // FIXME: should not lint here\n+        #[allow(clippy::option_option)]\n+        foo: Option<Option<Cow<'a, str>>>,\n+    }\n+\n+    #[allow(clippy::option_option)]\n+    fn func<'a, D>(_: D) -> Result<Option<Option<Cow<'a, str>>>, D::Error>\n+    where\n+        D: Deserializer<'a>,\n+    {\n+        Ok(Some(Some(Cow::Borrowed(\"hi\"))))\n+    }\n+}"}, {"sha": "0cd4c96eb4f9a17988b9cc86bbd0c71c5ba42353", "filename": "tests/ui/option_option.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Foption_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Foption_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_option.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -58,5 +58,11 @@ error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enu\n LL |     Struct { x: Option<Option<u8>> },\n    |                 ^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n+  --> $DIR/option_option.rs:77:14\n+   |\n+LL |         foo: Option<Option<Cow<'a, str>>>,\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "7bb08797ef3960545251e6c9a79ea6d0d2572433", "filename": "tests/ui/or_fun_call.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2For_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2For_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.fixed?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -95,6 +95,15 @@ fn test_or_with_ctors() {\n     let b = \"b\".to_string();\n     let _ = Some(Bar(\"a\".to_string(), Duration::from_secs(1)))\n         .or(Some(Bar(b, Duration::from_secs(2))));\n+\n+    let vec = vec![\"foo\"];\n+    let _ = opt.ok_or(vec.len());\n+\n+    let array = [\"foo\"];\n+    let _ = opt.ok_or(array.len());\n+\n+    let slice = &[\"foo\"][..];\n+    let _ = opt.ok_or(slice.len());\n }\n \n // Issue 4514 - early return"}, {"sha": "522f31b72d01f4d94a590dd179a86c287d1c6db4", "filename": "tests/ui/or_fun_call.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -95,6 +95,15 @@ fn test_or_with_ctors() {\n     let b = \"b\".to_string();\n     let _ = Some(Bar(\"a\".to_string(), Duration::from_secs(1)))\n         .or(Some(Bar(b, Duration::from_secs(2))));\n+\n+    let vec = vec![\"foo\"];\n+    let _ = opt.ok_or(vec.len());\n+\n+    let array = [\"foo\"];\n+    let _ = opt.ok_or(array.len());\n+\n+    let slice = &[\"foo\"][..];\n+    let _ = opt.ok_or(slice.len());\n }\n \n // Issue 4514 - early return"}, {"sha": "541225e635102b73626c4c7e960c7796f2161f8f", "filename": "tests/ui/ptr_arg.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -71,7 +71,6 @@ fn false_positive_capacity_too(x: &String) -> String {\n #[allow(dead_code)]\n fn test_cow_with_ref(c: &Cow<[i32]>) {}\n \n-#[allow(dead_code)]\n fn test_cow(c: Cow<[i32]>) {\n     let _c = c;\n }\n@@ -84,3 +83,34 @@ trait Foo2 {\n impl Foo2 for String {\n     fn do_string(&self) {}\n }\n+\n+// Check that the allow attribute on parameters is honored\n+mod issue_5644 {\n+    use std::borrow::Cow;\n+\n+    fn allowed(\n+        #[allow(clippy::ptr_arg)] _v: &Vec<u32>,\n+        #[allow(clippy::ptr_arg)] _s: &String,\n+        #[allow(clippy::ptr_arg)] _c: &Cow<[i32]>,\n+    ) {\n+    }\n+\n+    struct S {}\n+    impl S {\n+        fn allowed(\n+            #[allow(clippy::ptr_arg)] _v: &Vec<u32>,\n+            #[allow(clippy::ptr_arg)] _s: &String,\n+            #[allow(clippy::ptr_arg)] _c: &Cow<[i32]>,\n+        ) {\n+        }\n+    }\n+\n+    trait T {\n+        fn allowed(\n+            #[allow(clippy::ptr_arg)] _v: &Vec<u32>,\n+            #[allow(clippy::ptr_arg)] _s: &String,\n+            #[allow(clippy::ptr_arg)] _c: &Cow<[i32]>,\n+        ) {\n+        }\n+    }\n+}"}, {"sha": "718e391e8bf697b59fbf1e02a4c38bad7108a716", "filename": "tests/ui/ptr_offset_with_cast.fixed", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fptr_offset_with_cast.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fptr_offset_with_cast.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_offset_with_cast.fixed?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -9,12 +9,12 @@ fn main() {\n     let offset_isize = 1_isize;\n \n     unsafe {\n-        ptr.add(offset_usize);\n-        ptr.offset(offset_isize as isize);\n-        ptr.offset(offset_u8 as isize);\n+        let _ = ptr.add(offset_usize);\n+        let _ = ptr.offset(offset_isize as isize);\n+        let _ = ptr.offset(offset_u8 as isize);\n \n-        ptr.wrapping_add(offset_usize);\n-        ptr.wrapping_offset(offset_isize as isize);\n-        ptr.wrapping_offset(offset_u8 as isize);\n+        let _ = ptr.wrapping_add(offset_usize);\n+        let _ = ptr.wrapping_offset(offset_isize as isize);\n+        let _ = ptr.wrapping_offset(offset_u8 as isize);\n     }\n }"}, {"sha": "f613742c741ef5660e339f0f560ce97576b8153a", "filename": "tests/ui/ptr_offset_with_cast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_offset_with_cast.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -9,12 +9,12 @@ fn main() {\n     let offset_isize = 1_isize;\n \n     unsafe {\n-        ptr.offset(offset_usize as isize);\n-        ptr.offset(offset_isize as isize);\n-        ptr.offset(offset_u8 as isize);\n+        let _ = ptr.offset(offset_usize as isize);\n+        let _ = ptr.offset(offset_isize as isize);\n+        let _ = ptr.offset(offset_u8 as isize);\n \n-        ptr.wrapping_offset(offset_usize as isize);\n-        ptr.wrapping_offset(offset_isize as isize);\n-        ptr.wrapping_offset(offset_u8 as isize);\n+        let _ = ptr.wrapping_offset(offset_usize as isize);\n+        let _ = ptr.wrapping_offset(offset_isize as isize);\n+        let _ = ptr.wrapping_offset(offset_u8 as isize);\n     }\n }"}, {"sha": "fd45224ca067fa3450bc07cd12f5ebef51052495", "filename": "tests/ui/ptr_offset_with_cast.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fptr_offset_with_cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fptr_offset_with_cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_offset_with_cast.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1,16 +1,16 @@\n error: use of `offset` with a `usize` casted to an `isize`\n-  --> $DIR/ptr_offset_with_cast.rs:12:9\n+  --> $DIR/ptr_offset_with_cast.rs:12:17\n    |\n-LL |         ptr.offset(offset_usize as isize);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr.add(offset_usize)`\n+LL |         let _ = ptr.offset(offset_usize as isize);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr.add(offset_usize)`\n    |\n    = note: `-D clippy::ptr-offset-with-cast` implied by `-D warnings`\n \n error: use of `wrapping_offset` with a `usize` casted to an `isize`\n-  --> $DIR/ptr_offset_with_cast.rs:16:9\n+  --> $DIR/ptr_offset_with_cast.rs:16:17\n    |\n-LL |         ptr.wrapping_offset(offset_usize as isize);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr.wrapping_add(offset_usize)`\n+LL |         let _ = ptr.wrapping_offset(offset_usize as isize);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr.wrapping_add(offset_usize)`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "332c0427ef65a224ffe323e5429fd08bb61bbc40", "filename": "tests/ui/reversed_empty_ranges_fixable.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Freversed_empty_ranges_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Freversed_empty_ranges_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_fixable.fixed?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -4,18 +4,23 @@\n const ANSWER: i32 = 42;\n \n fn main() {\n+    let arr = [1, 2, 3, 4, 5];\n+\n+    // These should be linted:\n+\n     (21..=42).rev().for_each(|x| println!(\"{}\", x));\n     let _ = (21..ANSWER).rev().filter(|x| x % 2 == 0).take(10).collect::<Vec<_>>();\n \n     for _ in (-42..=-21).rev() {}\n     for _ in (21u32..42u32).rev() {}\n \n+    let _ = &[] as &[i32];\n+\n     // These should be ignored as they are not empty ranges:\n \n     (21..=42).for_each(|x| println!(\"{}\", x));\n     (21..42).for_each(|x| println!(\"{}\", x));\n \n-    let arr = [1, 2, 3, 4, 5];\n     let _ = &arr[1..=3];\n     let _ = &arr[1..3];\n "}, {"sha": "901ec8bcc09f4e31eff5766e18959eccf4414edf", "filename": "tests/ui/reversed_empty_ranges_fixable.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Freversed_empty_ranges_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Freversed_empty_ranges_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_fixable.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -4,18 +4,23 @@\n const ANSWER: i32 = 42;\n \n fn main() {\n+    let arr = [1, 2, 3, 4, 5];\n+\n+    // These should be linted:\n+\n     (42..=21).for_each(|x| println!(\"{}\", x));\n     let _ = (ANSWER..21).filter(|x| x % 2 == 0).take(10).collect::<Vec<_>>();\n \n     for _ in -21..=-42 {}\n     for _ in 42u32..21u32 {}\n \n+    let _ = &arr[3..3];\n+\n     // These should be ignored as they are not empty ranges:\n \n     (21..=42).for_each(|x| println!(\"{}\", x));\n     (21..42).for_each(|x| println!(\"{}\", x));\n \n-    let arr = [1, 2, 3, 4, 5];\n     let _ = &arr[1..=3];\n     let _ = &arr[1..3];\n "}, {"sha": "9a646fd99398d5c97577ddef7cab0c70063f7372", "filename": "tests/ui/reversed_empty_ranges_fixable.stderr", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Freversed_empty_ranges_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Freversed_empty_ranges_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_fixable.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1,5 +1,5 @@\n error: this range is empty so it will yield no values\n-  --> $DIR/reversed_empty_ranges_fixable.rs:7:5\n+  --> $DIR/reversed_empty_ranges_fixable.rs:11:5\n    |\n LL |     (42..=21).for_each(|x| println!(\"{}\", x));\n    |     ^^^^^^^^^\n@@ -11,7 +11,7 @@ LL |     (21..=42).rev().for_each(|x| println!(\"{}\", x));\n    |     ^^^^^^^^^^^^^^^\n \n error: this range is empty so it will yield no values\n-  --> $DIR/reversed_empty_ranges_fixable.rs:8:13\n+  --> $DIR/reversed_empty_ranges_fixable.rs:12:13\n    |\n LL |     let _ = (ANSWER..21).filter(|x| x % 2 == 0).take(10).collect::<Vec<_>>();\n    |             ^^^^^^^^^^^^\n@@ -22,7 +22,7 @@ LL |     let _ = (21..ANSWER).rev().filter(|x| x % 2 == 0).take(10).collect::<Ve\n    |             ^^^^^^^^^^^^^^^^^^\n \n error: this range is empty so it will yield no values\n-  --> $DIR/reversed_empty_ranges_fixable.rs:10:14\n+  --> $DIR/reversed_empty_ranges_fixable.rs:14:14\n    |\n LL |     for _ in -21..=-42 {}\n    |              ^^^^^^^^^\n@@ -33,7 +33,7 @@ LL |     for _ in (-42..=-21).rev() {}\n    |              ^^^^^^^^^^^^^^^^^\n \n error: this range is empty so it will yield no values\n-  --> $DIR/reversed_empty_ranges_fixable.rs:11:14\n+  --> $DIR/reversed_empty_ranges_fixable.rs:15:14\n    |\n LL |     for _ in 42u32..21u32 {}\n    |              ^^^^^^^^^^^^\n@@ -43,5 +43,11 @@ help: consider using the following if you are attempting to iterate over this ra\n LL |     for _ in (21u32..42u32).rev() {}\n    |              ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: this range is empty and using it to index a slice will always yield an empty slice\n+  --> $DIR/reversed_empty_ranges_fixable.rs:17:18\n+   |\n+LL |     let _ = &arr[3..3];\n+   |              ----^^^^- help: if you want an empty slice, use: `[] as &[i32]`\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "561a35625f02ec6dcb799ced453ec9123467451f", "filename": "tests/ui/reversed_empty_ranges_unfixable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Freversed_empty_ranges_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Freversed_empty_ranges_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_unfixable.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -9,7 +9,6 @@ fn main() {\n     let arr = [1, 2, 3, 4, 5];\n     let _ = &arr[3usize..=1usize];\n     let _ = &arr[SOME_NUM..1];\n-    let _ = &arr[3..3];\n \n     for _ in ANSWER..ANSWER {}\n }"}, {"sha": "240188cbb46cb17b151748b279c6edf0433a3b29", "filename": "tests/ui/reversed_empty_ranges_unfixable.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Freversed_empty_ranges_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Freversed_empty_ranges_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freversed_empty_ranges_unfixable.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -18,17 +18,11 @@ error: this range is reversed and using it to index a slice will panic at run-ti\n LL |     let _ = &arr[SOME_NUM..1];\n    |                  ^^^^^^^^^^^\n \n-error: this range is empty and using it to index a slice will always yield an empty slice\n-  --> $DIR/reversed_empty_ranges_unfixable.rs:12:18\n-   |\n-LL |     let _ = &arr[3..3];\n-   |                  ^^^^\n-\n error: this range is empty so it will yield no values\n-  --> $DIR/reversed_empty_ranges_unfixable.rs:14:14\n+  --> $DIR/reversed_empty_ranges_unfixable.rs:13:14\n    |\n LL |     for _ in ANSWER..ANSWER {}\n    |              ^^^^^^^^^^^^^^\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "84ec53702788c12592f02387ec2deaef7f5c36c0", "filename": "tests/ui/useless_conversion.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fuseless_conversion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fuseless_conversion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -1,4 +1,4 @@\n-error: useless conversion\n+error: useless conversion to the same type\n   --> $DIR/useless_conversion.rs:6:13\n    |\n LL |     let _ = T::from(val);\n@@ -10,55 +10,55 @@ note: the lint level is defined here\n LL | #![deny(clippy::useless_conversion)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: useless conversion\n+error: useless conversion to the same type\n   --> $DIR/useless_conversion.rs:7:5\n    |\n LL |     val.into()\n    |     ^^^^^^^^^^ help: consider removing `.into()`: `val`\n \n-error: useless conversion\n+error: useless conversion to the same type\n   --> $DIR/useless_conversion.rs:19:22\n    |\n LL |         let _: i32 = 0i32.into();\n    |                      ^^^^^^^^^^^ help: consider removing `.into()`: `0i32`\n \n-error: useless conversion\n+error: useless conversion to the same type\n   --> $DIR/useless_conversion.rs:51:21\n    |\n LL |     let _: String = \"foo\".to_string().into();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into()`: `\"foo\".to_string()`\n \n-error: useless conversion\n+error: useless conversion to the same type\n   --> $DIR/useless_conversion.rs:52:21\n    |\n LL |     let _: String = From::from(\"foo\".to_string());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `From::from()`: `\"foo\".to_string()`\n \n-error: useless conversion\n+error: useless conversion to the same type\n   --> $DIR/useless_conversion.rs:53:13\n    |\n LL |     let _ = String::from(\"foo\".to_string());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `String::from()`: `\"foo\".to_string()`\n \n-error: useless conversion\n+error: useless conversion to the same type\n   --> $DIR/useless_conversion.rs:54:13\n    |\n LL |     let _ = String::from(format!(\"A: {:04}\", 123));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `String::from()`: `format!(\"A: {:04}\", 123)`\n \n-error: useless conversion\n+error: useless conversion to the same type\n   --> $DIR/useless_conversion.rs:55:13\n    |\n LL |     let _ = \"\".lines().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into_iter()`: `\"\".lines()`\n \n-error: useless conversion\n+error: useless conversion to the same type\n   --> $DIR/useless_conversion.rs:56:13\n    |\n LL |     let _ = vec![1, 2, 3].into_iter().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into_iter()`: `vec![1, 2, 3].into_iter()`\n \n-error: useless conversion\n+error: useless conversion to the same type\n   --> $DIR/useless_conversion.rs:57:21\n    |\n LL |     let _: String = format!(\"Hello {}\", \"world\").into();"}, {"sha": "3787ea991445cc45f9ff2baac1436883486a0008", "filename": "tests/ui/useless_conversion_try.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fuseless_conversion_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fuseless_conversion_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion_try.rs?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,42 @@\n+#![deny(clippy::useless_conversion)]\n+\n+use std::convert::{TryFrom, TryInto};\n+\n+fn test_generic<T: Copy>(val: T) -> T {\n+    let _ = T::try_from(val).unwrap();\n+    val.try_into().unwrap()\n+}\n+\n+fn test_generic2<T: Copy + Into<i32> + Into<U>, U: From<T>>(val: T) {\n+    // ok\n+    let _: i32 = val.try_into().unwrap();\n+    let _: U = val.try_into().unwrap();\n+    let _ = U::try_from(val).unwrap();\n+}\n+\n+fn main() {\n+    test_generic(10i32);\n+    test_generic2::<i32, i32>(10i32);\n+\n+    let _: String = \"foo\".try_into().unwrap();\n+    let _: String = TryFrom::try_from(\"foo\").unwrap();\n+    let _ = String::try_from(\"foo\").unwrap();\n+    #[allow(clippy::useless_conversion)]\n+    {\n+        let _ = String::try_from(\"foo\").unwrap();\n+        let _: String = \"foo\".try_into().unwrap();\n+    }\n+    let _: String = \"foo\".to_string().try_into().unwrap();\n+    let _: String = TryFrom::try_from(\"foo\".to_string()).unwrap();\n+    let _ = String::try_from(\"foo\".to_string()).unwrap();\n+    let _ = String::try_from(format!(\"A: {:04}\", 123)).unwrap();\n+    let _: String = format!(\"Hello {}\", \"world\").try_into().unwrap();\n+    let _: String = \"\".to_owned().try_into().unwrap();\n+    let _: String = match String::from(\"_\").try_into() {\n+        Ok(a) => a,\n+        Err(_) => \"\".into(),\n+    };\n+    // FIXME this is a false negative\n+    #[allow(clippy::cmp_owned)]\n+    if String::from(\"a\") == TryInto::<String>::try_into(String::from(\"a\")).unwrap() {}\n+}"}, {"sha": "b765727c168f5a5273cf55890b05ceebcf26a8a5", "filename": "tests/ui/useless_conversion_try.stderr", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fuseless_conversion_try.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0e9f9bd0dca39ccff47baedffa94aca74911a86/tests%2Fui%2Fuseless_conversion_try.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion_try.stderr?ref=a0e9f9bd0dca39ccff47baedffa94aca74911a86", "patch": "@@ -0,0 +1,79 @@\n+error: useless conversion to the same type\n+  --> $DIR/useless_conversion_try.rs:6:13\n+   |\n+LL |     let _ = T::try_from(val).unwrap();\n+   |             ^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/useless_conversion_try.rs:1:9\n+   |\n+LL | #![deny(clippy::useless_conversion)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: consider removing `T::try_from()`\n+\n+error: useless conversion to the same type\n+  --> $DIR/useless_conversion_try.rs:7:5\n+   |\n+LL |     val.try_into().unwrap()\n+   |     ^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing `.try_into()`\n+\n+error: useless conversion to the same type\n+  --> $DIR/useless_conversion_try.rs:29:21\n+   |\n+LL |     let _: String = \"foo\".to_string().try_into().unwrap();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing `.try_into()`\n+\n+error: useless conversion to the same type\n+  --> $DIR/useless_conversion_try.rs:30:21\n+   |\n+LL |     let _: String = TryFrom::try_from(\"foo\".to_string()).unwrap();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing `TryFrom::try_from()`\n+\n+error: useless conversion to the same type\n+  --> $DIR/useless_conversion_try.rs:31:13\n+   |\n+LL |     let _ = String::try_from(\"foo\".to_string()).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing `String::try_from()`\n+\n+error: useless conversion to the same type\n+  --> $DIR/useless_conversion_try.rs:32:13\n+   |\n+LL |     let _ = String::try_from(format!(\"A: {:04}\", 123)).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing `String::try_from()`\n+\n+error: useless conversion to the same type\n+  --> $DIR/useless_conversion_try.rs:33:21\n+   |\n+LL |     let _: String = format!(\"Hello {}\", \"world\").try_into().unwrap();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing `.try_into()`\n+\n+error: useless conversion to the same type\n+  --> $DIR/useless_conversion_try.rs:34:21\n+   |\n+LL |     let _: String = \"\".to_owned().try_into().unwrap();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing `.try_into()`\n+\n+error: useless conversion to the same type\n+  --> $DIR/useless_conversion_try.rs:35:27\n+   |\n+LL |     let _: String = match String::from(\"_\").try_into() {\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing `.try_into()`\n+\n+error: aborting due to 9 previous errors\n+"}]}