{"sha": "dff14069c966ad4e4c453a84a42579a846d4863b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZjE0MDY5Yzk2NmFkNGU0YzQ1M2E4NGE0MjU3OWE4NDZkNDg2M2I=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-24T13:46:55Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-24T14:26:33Z"}, "message": "Document SmallIntMap with examples.", "tree": {"sha": "dde03bf0dd9eef4aac83e39e158da788273722cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dde03bf0dd9eef4aac83e39e158da788273722cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dff14069c966ad4e4c453a84a42579a846d4863b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dff14069c966ad4e4c453a84a42579a846d4863b", "html_url": "https://github.com/rust-lang/rust/commit/dff14069c966ad4e4c453a84a42579a846d4863b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dff14069c966ad4e4c453a84a42579a846d4863b/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d93e53e70e450e770b6b00bfc6b6498c4513b8e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d93e53e70e450e770b6b00bfc6b6498c4513b8e7", "html_url": "https://github.com/rust-lang/rust/commit/d93e53e70e450e770b6b00bfc6b6498c4513b8e7"}], "stats": {"total": 121, "additions": 119, "deletions": 2}, "files": [{"sha": "3bc2dbe5cbbb399ff02674b287f628dd031ee3fa", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 119, "deletions": 2, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/dff14069c966ad4e4c453a84a42579a846d4863b/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff14069c966ad4e4c453a84a42579a846d4863b/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=dff14069c966ad4e4c453a84a42579a846d4863b", "patch": "@@ -24,7 +24,39 @@ use {Collection, Mutable, Map, MutableMap, MutableSeq};\n use {vec, slice};\n use vec::Vec;\n \n-#[allow(missing_doc)]\n+/// A map optimized for small integer keys.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::SmallIntMap;\n+///\n+/// let mut months = SmallIntMap::new();\n+/// months.insert(1, \"Jan\");\n+/// months.insert(2, \"Feb\");\n+/// months.insert(3, \"Mar\");\n+///\n+/// if !months.contains_key(&12) {\n+///     println!(\"The end is near!\");\n+/// }\n+///\n+/// assert_eq!(months.find(&1), Some(&\"Jan\"));\n+///\n+/// match months.find_mut(&3) {\n+///     Some(value) => *value = \"Venus\",\n+///     None => (),\n+/// }\n+///\n+/// assert_eq!(months.find(&3), Some(&\"Venus\"));\n+///\n+/// // Print out all months\n+/// for (key, value) in months.iter() {\n+///     println!(\"month {} is {}\", key, value);\n+/// }\n+///\n+/// months.clear();\n+/// assert!(months.is_empty());\n+/// ```\n pub struct SmallIntMap<T> {\n     v: Vec<Option<T>>,\n }\n@@ -120,19 +152,66 @@ impl<V> Default for SmallIntMap<V> {\n \n impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    /// let mut map: SmallIntMap<&str> = SmallIntMap::new();\n+    /// ```\n     pub fn new() -> SmallIntMap<V> { SmallIntMap{v: vec!()} }\n \n-    /// Create an empty SmallIntMap with capacity `capacity`.\n+    /// Create an empty SmallIntMap with space for at least `capacity` elements\n+    /// before resizing.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    /// let mut map: SmallIntMap<&str> = SmallIntMap::with_capacity(10);\n+    /// ```\n     pub fn with_capacity(capacity: uint) -> SmallIntMap<V> {\n         SmallIntMap { v: Vec::with_capacity(capacity) }\n     }\n \n+    /// Retrieves a value for the given key.\n+    /// See [`find`](../trait.Map.html#tymethod.find) for a non-failing alternative.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the key is not present.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.get(&1), &\"a\");\n+    /// ```\n     pub fn get<'a>(&'a self, key: &uint) -> &'a V {\n         self.find(key).expect(\"key not present\")\n     }\n \n     /// An iterator visiting all key-value pairs in ascending order by the keys.\n     /// Iterator element type is `(uint, &'r V)`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(3, \"c\");\n+    /// map.insert(2, \"b\");\n+    ///\n+    /// // Print `1: a` then `2: b` then `3: c`\n+    /// for (key, value) in map.iter() {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    /// ```\n     pub fn iter<'r>(&'r self) -> Entries<'r, V> {\n         Entries {\n             front: 0,\n@@ -144,6 +223,25 @@ impl<V> SmallIntMap<V> {\n     /// An iterator visiting all key-value pairs in ascending order by the keys,\n     /// with mutable references to the values\n     /// Iterator element type is `(uint, &'r mut V)`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// map.insert(3, \"c\");\n+    ///\n+    /// for (key, value) in map.mut_iter() {\n+    ///     *value = \"x\";\n+    /// }\n+    ///\n+    /// for (key, value) in map.iter() {\n+    ///     assert_eq!(value, &\"x\");\n+    /// }\n+    /// ```\n     pub fn mut_iter<'r>(&'r mut self) -> MutEntries<'r, V> {\n         MutEntries {\n             front: 0,\n@@ -153,6 +251,22 @@ impl<V> SmallIntMap<V> {\n     }\n \n     /// Empties the hash map, moving all values into the specified closure.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(3, \"c\");\n+    /// map.insert(2, \"b\");\n+    ///\n+    /// // Not possible with .iter()\n+    /// let vec: Vec<(uint, &str)> = map.move_iter().collect();\n+    ///\n+    /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+    /// ```\n     pub fn move_iter(&mut self)\n         -> FilterMap<(uint, Option<V>), (uint, V),\n                 Enumerate<vec::MoveItems<Option<V>>>>\n@@ -247,6 +361,7 @@ macro_rules! double_ended_iterator {\n     }\n }\n \n+/// Forward iterator over a map.\n pub struct Entries<'a, T> {\n     front: uint,\n     back: uint,\n@@ -256,6 +371,8 @@ pub struct Entries<'a, T> {\n iterator!(impl Entries -> (uint, &'a T), get_ref)\n double_ended_iterator!(impl Entries -> (uint, &'a T), get_ref)\n \n+/// Forward iterator over the key-value pairs of a map, with the\n+/// values being mutable.\n pub struct MutEntries<'a, T> {\n     front: uint,\n     back: uint,"}]}