{"sha": "1f4b3cfc3639f939b44396c4aa6074a4d60bc5c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNGIzY2ZjMzYzOWY5MzliNDQzOTZjNGFhNjA3NGE0ZDYwYmM1Yzc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-29T03:52:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-30T18:26:15Z"}, "message": "zero out alloca for preserving values\n\nconservatively do it always for now", "tree": {"sha": "ae7d9424b1a8206f735bd4e8a5a506af4aa08cc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae7d9424b1a8206f735bd4e8a5a506af4aa08cc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f4b3cfc3639f939b44396c4aa6074a4d60bc5c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4b3cfc3639f939b44396c4aa6074a4d60bc5c7", "html_url": "https://github.com/rust-lang/rust/commit/1f4b3cfc3639f939b44396c4aa6074a4d60bc5c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f4b3cfc3639f939b44396c4aa6074a4d60bc5c7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "555492e427035caf4a0849580b16130ede6dcf5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/555492e427035caf4a0849580b16130ede6dcf5b", "html_url": "https://github.com/rust-lang/rust/commit/555492e427035caf4a0849580b16130ede6dcf5b"}], "stats": {"total": 53, "additions": 31, "deletions": 22}, "files": [{"sha": "62153f9383def93a300e62cd45e699f5a22589db", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1f4b3cfc3639f939b44396c4aa6074a4d60bc5c7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4b3cfc3639f939b44396c4aa6074a4d60bc5c7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1f4b3cfc3639f939b44396c4aa6074a4d60bc5c7", "patch": "@@ -256,9 +256,29 @@ fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n }\n \n fn alloca(cx: block, t: TypeRef) -> ValueRef {\n+    alloca_maybe_zeroed(cx, t, false)\n+}\n+\n+fn alloca_zeroed(cx: block, t: TypeRef) -> ValueRef {\n+    alloca_maybe_zeroed(cx, t, true)\n+}\n+\n+fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"alloca\");\n     if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n-    ret Alloca(raw_block(cx.fcx, cx.fcx.llstaticallocas), t);\n+    let initcx = raw_block(cx.fcx, cx.fcx.llstaticallocas);\n+    let p = Alloca(initcx, t);\n+    if zero { Store(initcx, C_null(t), p); }\n+    ret p;\n+}\n+\n+fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) -> block {\n+    let _icx = cx.insn_ctxt(\"zero_mem\");\n+    let bcx = cx;\n+    let ccx = cx.ccx();\n+    let llty = type_of(ccx, t);\n+    Store(bcx, C_null(llty), llptr);\n+    ret bcx;\n }\n \n fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n@@ -1386,14 +1406,14 @@ fn move_val(cx: block, action: copy_action, dst: ValueRef,\n         if src.kind == owned { src_val = Load(cx, src_val); }\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         Store(cx, src_val, dst);\n-        if src.kind == owned { ret zero_alloca(cx, src.val, t); }\n+        if src.kind == owned { ret zero_mem(cx, src.val, t); }\n         // If we're here, it must be a temporary.\n         revoke_clean(cx, src_val);\n         ret cx;\n     } else if type_is_structural_or_param(t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         memmove_ty(cx, dst, src_val, t);\n-        if src.kind == owned { ret zero_alloca(cx, src_val, t); }\n+        if src.kind == owned { ret zero_mem(cx, src_val, t); }\n         // If we're here, it must be a temporary.\n         revoke_clean(cx, src_val);\n         ret cx;\n@@ -1695,7 +1715,7 @@ fn root_value(bcx: block, val: ValueRef, ty: ty::t,\n             #fmt[\"preserving until end of scope %d\", scope_id]);\n     }\n \n-    let root_loc = alloca(bcx, type_of(bcx.ccx(), ty));\n+    let root_loc = alloca_zeroed(bcx, type_of(bcx.ccx(), ty));\n     copy_val(bcx, INIT, root_loc, val, ty);\n     add_root_cleanup(bcx, scope_id, root_loc, ty);\n }\n@@ -2585,7 +2605,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n         }\n \n         let ty = expr_ty(lv.bcx, e);\n-        let root_loc = alloca(lv.bcx, type_of(cx.ccx(), ty));\n+        let root_loc = alloca_zeroed(lv.bcx, type_of(cx.ccx(), ty));\n         let bcx = store_temp_expr(lv.bcx, INIT, root_loc, lv, ty, false);\n         add_root_cleanup(bcx, scope_id, root_loc, ty);\n         {bcx: bcx with lv}\n@@ -2852,7 +2872,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n         if lv.kind == owned || !ty::type_is_immediate(arg.ty) {\n             memmove_ty(bcx, alloc, val, arg.ty);\n             if move_out && ty::type_needs_drop(ccx.tcx, arg.ty) {\n-                bcx = zero_alloca(bcx, val, arg.ty);\n+                bcx = zero_mem(bcx, val, arg.ty);\n             }\n         } else { Store(bcx, val, alloc); }\n         val = alloc;\n@@ -3422,7 +3442,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n                e.id, scope_id];\n \n         let ty = expr_ty(bcx, e);\n-        let root_loc = alloca(bcx, type_of(bcx.ccx(), ty));\n+        let root_loc = alloca_zeroed(bcx, type_of(bcx.ccx(), ty));\n         let bcx = unrooted(bcx, e, save_in(root_loc));\n \n         if !bcx.sess().no_asm_comments() {\n@@ -3674,7 +3694,7 @@ fn lval_result_to_dps(lv: lval_result, ty: ty::t,\n         } else if last_use {\n             *cell = Load(bcx, val);\n             if ty::type_needs_drop(ccx.tcx, ty) {\n-                bcx = zero_alloca(bcx, val, ty);\n+                bcx = zero_mem(bcx, val, ty);\n             }\n         } else {\n             if kind == owned { val = Load(bcx, val); }\n@@ -3982,23 +4002,13 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n             bcx = move_val(sub.bcx, INIT, llptr, sub, ty);\n         }\n       }\n-      _ { bcx = zero_alloca(bcx, llptr, ty); }\n+      _ { bcx = zero_mem(bcx, llptr, ty); }\n     }\n     // Make a note to drop this slot on the way out.\n     add_clean(bcx, llptr, ty);\n     ret alt::bind_irrefutable_pat(bcx, local.node.pat, llptr, false);\n }\n \n-fn zero_alloca(cx: block, llptr: ValueRef, t: ty::t)\n-    -> block {\n-    let _icx = cx.insn_ctxt(\"zero_alloca\");\n-    let bcx = cx;\n-    let ccx = cx.ccx();\n-    let llty = type_of(ccx, t);\n-    Store(bcx, C_null(llty), llptr);\n-    ret bcx;\n-}\n-\n fn trans_stmt(cx: block, s: ast::stmt) -> block {\n     let _icx = cx.insn_ctxt(\"trans_stmt\");\n     #debug[\"trans_stmt(%s)\", stmt_to_str(s)];\n@@ -4785,8 +4795,7 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   // drop their LHS\n   for fields.each {|field|\n      let ix = field_idx_strict(bcx.tcx(), sp, field.ident, fields);\n-     bcx = zero_alloca(bcx, GEPi(bcx, valptr, [0u, ix]),\n-                       field.mt.ty);\n+     bcx = zero_mem(bcx, GEPi(bcx, valptr, [0u, ix]), field.mt.ty);\n   }\n \n   // note we don't want to take *or* drop self."}, {"sha": "7f58053165d0e282d8e0a264500e494fba285d82", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f4b3cfc3639f939b44396c4aa6074a4d60bc5c7/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4b3cfc3639f939b44396c4aa6074a4d60bc5c7/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=1f4b3cfc3639f939b44396c4aa6074a4d60bc5c7", "patch": "@@ -321,7 +321,7 @@ fn build_closure(bcx0: block,\n           capture::cap_drop {\n             assert lv.kind == owned;\n             bcx = drop_ty(bcx, lv.val, ty);\n-            bcx = zero_alloca(bcx, lv.val, ty);\n+            bcx = zero_mem(bcx, lv.val, ty);\n           }\n         }\n     }"}]}