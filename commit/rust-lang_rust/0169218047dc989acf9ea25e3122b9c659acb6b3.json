{"sha": "0169218047dc989acf9ea25e3122b9c659acb6b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNjkyMTgwNDdkYzk4OWFjZjllYTI1ZTMxMjJiOWM2NTlhY2I2YjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-17T19:56:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-22T05:15:51Z"}, "message": "Fix fallout from Vec stabilization", "tree": {"sha": "8b1cd720a9e38c745359581e74d216a04e39e5ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b1cd720a9e38c745359581e74d216a04e39e5ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0169218047dc989acf9ea25e3122b9c659acb6b3", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0169218047dc989acf9ea25e3122b9c659acb6b3", "html_url": "https://github.com/rust-lang/rust/commit/0169218047dc989acf9ea25e3122b9c659acb6b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0169218047dc989acf9ea25e3122b9c659acb6b3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "087b9283a0ed8df68f47ab07a25e60bc6a3ca050", "url": "https://api.github.com/repos/rust-lang/rust/commits/087b9283a0ed8df68f47ab07a25e60bc6a3ca050", "html_url": "https://github.com/rust-lang/rust/commit/087b9283a0ed8df68f47ab07a25e60bc6a3ca050"}], "stats": {"total": 297, "additions": 141, "deletions": 156}, "files": [{"sha": "f3e9177fc6e11bc3b1cb5da8904beeab338a799e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -273,8 +273,8 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                             format!(\"--target={}\", config.target),\n                             \"-L\".to_string(),\n                             aux_dir.as_str().unwrap().to_string());\n-        args.push_all_move(split_maybe_args(&config.target_rustcflags));\n-        args.push_all_move(split_maybe_args(&props.compile_flags));\n+        args.extend(split_maybe_args(&config.target_rustcflags).into_iter());\n+        args.extend(split_maybe_args(&props.compile_flags).into_iter());\n         return ProcArgs {\n             prog: config.rustc_path.as_str().unwrap().to_string(),\n             args: args,\n@@ -321,8 +321,8 @@ actual:\\n\\\n                             config.build_base.as_str().unwrap().to_string(),\n                             \"-L\".to_string(),\n                             aux_dir.as_str().unwrap().to_string());\n-        args.push_all_move(split_maybe_args(&config.target_rustcflags));\n-        args.push_all_move(split_maybe_args(&props.compile_flags));\n+        args.extend(split_maybe_args(&config.target_rustcflags).into_iter());\n+        args.extend(split_maybe_args(&props.compile_flags).into_iter());\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         return ProcArgs {\n             prog: config.rustc_path.as_str().unwrap().to_string(),\n@@ -1095,11 +1095,12 @@ fn compile_test_(config: &Config, props: &TestProps,\n                  testfile: &Path, extra_args: &[String]) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(\"-L\".to_string(),\n-                         aux_dir.as_str().unwrap().to_string());\n+    let mut link_args = vec!(\"-L\".to_string(),\n+                             aux_dir.as_str().unwrap().to_string());\n+    link_args.extend(extra_args.iter().map(|s| s.clone()));\n     let args = make_compile_args(config,\n                                  props,\n-                                 link_args.append(extra_args),\n+                                 link_args,\n                                  |a, b| ThisFile(make_exe_name(a, b)), testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n@@ -1146,16 +1147,16 @@ fn compose_and_run_compiler(\n     for rel_ab in props.aux_builds.iter() {\n         let abs_ab = config.aux_base.join(rel_ab.as_slice());\n         let aux_props = header::load_props(&abs_ab);\n-        let crate_type = if aux_props.no_prefer_dynamic {\n+        let mut crate_type = if aux_props.no_prefer_dynamic {\n             Vec::new()\n         } else {\n             vec!(\"--crate-type=dylib\".to_string())\n         };\n+        crate_type.extend(extra_link_args.clone().into_iter());\n         let aux_args =\n             make_compile_args(config,\n                               &aux_props,\n-                              crate_type.append(\n-                                  extra_link_args.as_slice()),\n+                              crate_type,\n                               |a,b| {\n                                   let f = make_lib_name(a, b, testfile);\n                                   ThisDirectory(f.dir_path())\n@@ -1246,11 +1247,11 @@ fn make_compile_args(config: &Config,\n     };\n     args.push(path.as_str().unwrap().to_string());\n     if props.force_host {\n-        args.push_all_move(split_maybe_args(&config.host_rustcflags));\n+        args.extend(split_maybe_args(&config.host_rustcflags).into_iter());\n     } else {\n-        args.push_all_move(split_maybe_args(&config.target_rustcflags));\n+        args.extend(split_maybe_args(&config.target_rustcflags).into_iter());\n     }\n-    args.push_all_move(split_maybe_args(&props.compile_flags));\n+    args.extend(split_maybe_args(&props.compile_flags).into_iter());\n     return ProcArgs {\n         prog: config.rustc_path.as_str().unwrap().to_string(),\n         args: args,\n@@ -1267,10 +1268,9 @@ fn make_lib_name(config: &Config, auxfile: &Path, testfile: &Path) -> Path {\n fn make_exe_name(config: &Config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n     if !os::consts::EXE_SUFFIX.is_empty() {\n-        match f.filename().map(|s| Vec::from_slice(s).append(os::consts::EXE_SUFFIX.as_bytes())) {\n-            Some(v) => f.set_filename(v),\n-            None => ()\n-        }\n+        let mut fname = f.filename().unwrap().to_vec();\n+        fname.extend(os::consts::EXE_SUFFIX.bytes());\n+        f.set_filename(fname);\n     }\n     f\n }\n@@ -1286,7 +1286,7 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path) ->\n     args.push(exe_file.as_str().unwrap().to_string());\n \n     // Add the arguments in the run_flags directive\n-    args.push_all_move(split_maybe_args(&props.run_flags));\n+    args.extend(split_maybe_args(&props.run_flags).into_iter());\n \n     let prog = args.remove(0).unwrap();\n     return ProcArgs {\n@@ -1381,12 +1381,10 @@ fn make_out_name(config: &Config, testfile: &Path, extension: &str) -> Path {\n }\n \n fn aux_output_dir_name(config: &Config, testfile: &Path) -> Path {\n-    let mut f = output_base_name(config, testfile);\n-    match f.filename().map(|s| Vec::from_slice(s).append(b\".libaux\")) {\n-        Some(v) => f.set_filename(v),\n-        None => ()\n-    }\n-    f\n+    let f = output_base_name(config, testfile);\n+    let mut fname = f.filename().unwrap().to_vec();\n+    fname.extend(\"libaux\".bytes());\n+    f.with_filename(fname)\n }\n \n fn output_testname(testfile: &Path) -> Path {\n@@ -1598,22 +1596,25 @@ fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n     if suffix.len() == 0 {\n         (*p).clone()\n     } else {\n-        let stem = p.filestem().unwrap();\n-        p.with_filename(Vec::from_slice(stem).append(b\"-\").append(suffix.as_bytes()))\n+        let mut stem = p.filestem().unwrap().to_vec();\n+        stem.extend(\"-\".bytes());\n+        stem.extend(suffix.bytes());\n+        p.with_filename(stem)\n     }\n }\n \n fn compile_test_and_save_bitcode(config: &Config, props: &TestProps,\n                                  testfile: &Path) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(\"-L\".to_string(),\n-                         aux_dir.as_str().unwrap().to_string());\n+    let mut link_args = vec!(\"-L\".to_string(),\n+                             aux_dir.as_str().unwrap().to_string());\n     let llvm_args = vec!(\"--emit=bc,obj\".to_string(),\n                          \"--crate-type=lib\".to_string());\n+    link_args.extend(llvm_args.into_iter());\n     let args = make_compile_args(config,\n                                  props,\n-                                 link_args.append(llvm_args.as_slice()),\n+                                 link_args,\n                                  |a, b| ThisDirectory(output_base_name(a, b).dir_path()),\n                                  testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)"}, {"sha": "2ffe22cba7553b00660beec8f188860c82fc4e02", "filename": "src/doc/rust.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -3833,8 +3833,9 @@ fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> Vec<B> {\n        return vec![];\n     }\n     let first: B = f(xs[0].clone());\n-    let rest: Vec<B> = map(f, xs.slice(1, xs.len()));\n-    return vec![first].append(rest.as_slice());\n+    let mut rest: Vec<B> = map(f, xs.slice(1, xs.len()));\n+    rest.insert(0, first);\n+    return rest;\n }\n ~~~~\n "}, {"sha": "60c9dfcff187c1c03882d8e224130658286af35e", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -631,7 +631,7 @@ impl Bitv {\n         let old_size = self.storage.len();\n         let size = (size + uint::BITS - 1) / uint::BITS;\n         if old_size < size {\n-            self.storage.grow(size - old_size, &0);\n+            self.storage.grow(size - old_size, 0);\n         }\n     }\n \n@@ -687,7 +687,7 @@ impl Bitv {\n         // Allocate new words, if needed\n         if new_nwords > self.storage.len() {\n           let to_add = new_nwords - self.storage.len();\n-          self.storage.grow(to_add, &full_value);\n+          self.storage.grow(to_add, full_value);\n         }\n         // Adjust internal bit count\n         self.nbits = new_nbits;"}, {"sha": "44fe962fad4a06ed44b9b3524a833ffe9b6b648b", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -283,7 +283,11 @@ pub trait CloneableVector<T> {\n impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n-    fn to_vec(&self) -> Vec<T> { Vec::from_slice(*self) }\n+    fn to_vec(&self) -> Vec<T> {\n+        let mut vector = Vec::with_capacity(self.len());\n+        vector.push_all(*self);\n+        vector\n+    }\n \n     #[inline(always)]\n     fn into_vec(self) -> Vec<T> { self.to_vec() }\n@@ -1039,7 +1043,7 @@ mod tests {\n     fn test_grow() {\n         // Test on-stack grow().\n         let mut v = vec![];\n-        v.grow(2u, &1i);\n+        v.grow(2u, 1i);\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 2u);\n@@ -1048,7 +1052,7 @@ mod tests {\n         }\n \n         // Test on-heap grow().\n-        v.grow(3u, &2i);\n+        v.grow(3u, 2i);\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 5u);"}, {"sha": "f677b170bb3674dfb7c4f72d5fbb223c19f522ad", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -67,6 +67,7 @@ use core::prelude::{range};\n use {Deque, MutableSeq};\n use hash;\n use ringbuf::RingBuf;\n+use slice::CloneableVector;\n use string::String;\n use unicode;\n use vec::Vec;\n@@ -754,7 +755,7 @@ pub trait StrAllocating: Str {\n     #[inline]\n     fn to_owned(&self) -> String {\n         unsafe {\n-            mem::transmute(Vec::from_slice(self.as_slice().as_bytes()))\n+            mem::transmute(self.as_slice().as_bytes().to_vec())\n         }\n     }\n "}, {"sha": "bb66d271ee4d43e37ff17f391c668bfd221d248f", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -23,6 +23,7 @@ use core::raw::Slice as RawSlice;\n \n use {Mutable, MutableSeq};\n use hash;\n+use slice::CloneableVector;\n use str;\n use str::{CharRange, StrAllocating, MaybeOwned, Owned};\n use str::Slice as MaybeOwnedSlice; // So many `Slice`s...\n@@ -75,9 +76,7 @@ impl String {\n     /// ```\n     #[inline]\n     pub fn from_str(string: &str) -> String {\n-        String {\n-            vec: Vec::from_slice(string.as_bytes())\n-        }\n+        String { vec: string.as_bytes().to_vec() }\n     }\n \n     /// Deprecated. Replaced by `string::raw::from_parts`"}, {"sha": "d5ca48e605a644b30d021e6211e7b0dc4bccba51", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 10, "deletions": 39, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -273,38 +273,18 @@ impl<T> Vec<T> {\n }\n \n impl<T: Clone> Vec<T> {\n-    /// Iterates over the `second` vector, copying each element and appending it to\n-    /// the `first`. Afterwards, the `first` is then returned for use again.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2i];\n-    /// let vec = vec.append([3i, 4i]);\n-    /// assert_eq!(vec, vec![1, 2, 3, 4]);\n-    /// ```\n+    /// Deprecated, call `extend` instead.\n     #[inline]\n     #[deprecated = \"this function has been deprecated in favor of extend()\"]\n     pub fn append(mut self, second: &[T]) -> Vec<T> {\n         self.push_all(second);\n         self\n     }\n \n-    /// Constructs a `Vec` by cloning elements of a slice.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let slice = [1i, 2, 3];\n-    /// let vec = Vec::from_slice(slice);\n-    /// ```\n+    /// Deprecated, call `to_vec()` instead\n     #[inline]\n     #[deprecated = \"this function has been deprecated in favor of to_vec()\"]\n-    pub fn from_slice(values: &[T]) -> Vec<T> {\n-        let mut vector = Vec::new();\n-        vector.push_all(values);\n-        vector\n-    }\n+    pub fn from_slice(values: &[T]) -> Vec<T> { values.to_vec() }\n \n     /// Constructs a `Vec` with copies of a value.\n     ///\n@@ -442,9 +422,7 @@ impl<T: Clone> Vec<T> {\n \n #[unstable]\n impl<T:Clone> Clone for Vec<T> {\n-    fn clone(&self) -> Vec<T> {\n-        Vec::from_slice(self.as_slice())\n-    }\n+    fn clone(&self) -> Vec<T> { self.as_slice().to_vec() }\n \n     fn clone_from(&mut self, other: &Vec<T>) {\n         // drop anything in self that will not be overwritten\n@@ -736,16 +714,7 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Appends one element to the vector provided. The vector itself is then\n-    /// returned for use again.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2];\n-    /// let vec = vec.append_one(3);\n-    /// assert_eq!(vec, vec![1, 2, 3]);\n-    /// ```\n+    /// Deprecated, call `push` instead\n     #[inline]\n     #[deprecated = \"call .push() instead\"]\n     pub fn append_one(mut self, x: T) -> Vec<T> {\n@@ -765,7 +734,7 @@ impl<T> Vec<T> {\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[stable]\n+    #[unstable = \"waiting on failure semantics\"]\n     pub fn truncate(&mut self, len: uint) {\n         unsafe {\n             // drop any extra elements\n@@ -1123,7 +1092,7 @@ impl<T> Vec<T> {\n     /// vec.insert(4, 5);\n     /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n-    #[stable]\n+    #[unstable = \"failure semantics need settling\"]\n     pub fn insert(&mut self, index: uint, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n@@ -1160,7 +1129,7 @@ impl<T> Vec<T> {\n     /// // v is unchanged:\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n-    #[stable]\n+    #[unstable = \"failure semantics need settling\"]\n     pub fn remove(&mut self, index: uint) -> Option<T> {\n         let len = self.len();\n         if index < len {\n@@ -1192,11 +1161,13 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut vec = vec![box 1i];\n     /// vec.push_all_move(vec![box 2, box 3, box 4]);\n     /// assert_eq!(vec, vec![box 1, box 2, box 3, box 4]);\n     /// ```\n     #[inline]\n+    #[deprecated = \"use .extend(other.into_iter())\"]\n     pub fn push_all_move(&mut self, other: Vec<T>) {\n         self.extend(other.into_iter());\n     }"}, {"sha": "94e89dc6043cecd3fd43f2e71dab4be2a583d1ef", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -170,7 +170,7 @@ impl<'a,T:Clone> MaybeOwnedVector<'a,T> {\n     pub fn into_vec(self) -> Vec<T> {\n         match self {\n             Growable(v) => v,\n-            Borrowed(v) => Vec::from_slice(v),\n+            Borrowed(v) => v.to_vec(),\n         }\n     }\n }"}, {"sha": "648aa8668144b22610d082ff0d81545c5a769ce8", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -87,7 +87,7 @@ impl Writer for SeekableMemWriter {\n             // currently are\n             let difference = self.pos as i64 - self.buf.len() as i64;\n             if difference > 0 {\n-                self.buf.grow(difference as uint, &0);\n+                self.buf.grow(difference as uint, 0);\n             }\n \n             // Figure out what bytes will be used to overwrite what's currently"}, {"sha": "91c3da001628e62f300689da9090bd580e522e28", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -156,7 +156,7 @@ impl<'r> Compiler<'r> {\n             Capture(cap, name, x) => {\n                 let len = self.names.len();\n                 if cap >= len {\n-                    self.names.grow(10 + cap - len, &None)\n+                    self.names.grow(10 + cap - len, None)\n                 }\n                 *self.names.get_mut(cap) = name;\n "}, {"sha": "7f4289b128afeac769bd047362fef6bd2d72a0d2", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -986,9 +986,9 @@ fn combine_ranges(unordered: Vec<(char, char)>) -> Vec<(char, char)> {\n // (or any of their negated forms). Note that this does not handle negation.\n fn perl_unicode_class(which: char) -> Vec<(char, char)> {\n     match which.to_lowercase() {\n-        'd' => Vec::from_slice(PERLD),\n-        's' => Vec::from_slice(PERLS),\n-        'w' => Vec::from_slice(PERLW),\n+        'd' => PERLD.to_vec(),\n+        's' => PERLS.to_vec(),\n+        'w' => PERLW.to_vec(),\n         _ => unreachable!(),\n     }\n }\n@@ -997,7 +997,7 @@ fn perl_unicode_class(which: char) -> Vec<(char, char)> {\n // `Cat` expression will never be a direct child of another `Cat` expression.\n fn concat_flatten(x: Ast, y: Ast) -> Ast {\n     match (x, y) {\n-        (Cat(mut xs), Cat(ys)) => { xs.push_all_move(ys); Cat(xs) }\n+        (Cat(mut xs), Cat(ys)) => { xs.extend(ys.into_iter()); Cat(xs) }\n         (Cat(mut xs), ast) => { xs.push(ast); Cat(xs) }\n         (ast, Cat(mut xs)) => { xs.insert(0, ast); Cat(xs) }\n         (ast1, ast2) => Cat(vec!(ast1, ast2)),\n@@ -1019,7 +1019,7 @@ fn is_valid_cap(c: char) -> bool {\n \n fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n     match classes.binary_search(|&(s, _)| s.cmp(&name)) {\n-        slice::Found(i) => Some(Vec::from_slice(classes[i].val1())),\n+        slice::Found(i) => Some(classes[i].val1().to_vec()),\n         slice::NotFound(_) => None,\n     }\n }"}, {"sha": "cc6a8e27cda4aa727bd02e922682958c69549c8a", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -133,7 +133,7 @@ impl<'a> NfaGen<'a> {\n         let init_groups = self.vec_expr(range(0, num_cap_locs),\n                                         |cx, _| cx.expr_none(self.sp));\n \n-        let prefix_lit = Rc::new(Vec::from_slice(self.prog.prefix.as_slice().as_bytes()));\n+        let prefix_lit = Rc::new(self.prog.prefix.as_slice().as_bytes().to_vec());\n         let prefix_bytes = self.cx.expr_lit(self.sp, ast::LitBinary(prefix_lit));\n \n         let check_prefix = self.check_prefix();"}, {"sha": "660b6c7ade2b2e4a552c9c052e6562877d26c09f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -505,7 +505,7 @@ fn external_path(cx: &DocContext, name: &str, substs: &subst::Substs) -> Path {\n                     .iter()\n                     .filter_map(|v| v.clean(cx))\n                     .collect();\n-    let types = Vec::from_slice(substs.types.get_slice(subst::TypeSpace));\n+    let types = substs.types.get_slice(subst::TypeSpace).to_vec();\n     let types = types.clean(cx);\n     Path {\n         global: false,\n@@ -661,8 +661,8 @@ impl<'a> Clean<Generics> for (&'a ty::Generics, subst::ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n         let (me, space) = *self;\n         Generics {\n-            type_params: Vec::from_slice(me.types.get_slice(space)).clean(cx),\n-            lifetimes: Vec::from_slice(me.regions.get_slice(space)).clean(cx),\n+            type_params: me.types.get_slice(space).to_vec().clean(cx),\n+            lifetimes: me.regions.get_slice(space).to_vec().clean(cx),\n         }\n     }\n }\n@@ -991,7 +991,7 @@ impl Clean<Item> for ty::Method {\n                                                self.fty.sig.clone()),\n             s => {\n                 let sig = ty::FnSig {\n-                    inputs: Vec::from_slice(self.fty.sig.inputs.slice_from(1)),\n+                    inputs: self.fty.sig.inputs.slice_from(1).to_vec(),\n                     ..self.fty.sig.clone()\n                 };\n                 let s = match s {"}, {"sha": "8b72bd9e10283a6cbe7832feebc62e21524ee312", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -183,8 +183,8 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let p_16: Vec<u16> = p.as_str().unwrap().utf16_units().collect();\n-            let p_16 = p_16.append_one(0);\n+            let mut p_16: Vec<u16> = p.as_str().unwrap().utf16_units().collect();\n+            p_16.push(0);\n             let handle = unsafe {\n                 libc::CreateFileW(p_16.as_ptr(),\n                                   libc::FILE_GENERIC_READ |"}, {"sha": "c831015e5393683d05829849010bd3db3e9726ab", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -740,8 +740,9 @@ impl<'a> SourceCollector<'a> {\n             root_path.push_str(\"../\");\n         });\n \n-        cur.push(Vec::from_slice(p.filename().expect(\"source has no filename\"))\n-                 .append(b\".html\"));\n+        let mut fname = p.filename().expect(\"source has no filename\").to_vec();\n+        fname.extend(\".html\".bytes());\n+        cur.push(fname);\n         let mut w = BufferedWriter::new(try!(File::create(&cur)));\n \n         let title = format!(\"{} -- source\", cur.filename_display());"}, {"sha": "c0a17a720147377c2608a8655a44d178bf441e04", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -47,6 +47,7 @@ mod imp {\n     use core::prelude::*;\n \n     use alloc::boxed::Box;\n+    use collections::slice::CloneableVector;\n     use collections::vec::Vec;\n     use core::mem;\n     use core::slice;\n@@ -106,7 +107,7 @@ mod imp {\n             let mut len = 0;\n             while *base.offset(len) != 0 { len += 1; }\n             slice::raw::buf_as_slice(base, len as uint, |slice| {\n-                Vec::from_slice(slice)\n+                slice.to_vec()\n             })\n         })\n     }"}, {"sha": "d572d8ce58a53ef1b153b1c0de792587ac605140", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -655,7 +655,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n \n         // see comments in StreamWatcher::write for why we may allocate a buffer\n         // here.\n-        let data = if guard.can_timeout {Some(Vec::from_slice(buf))} else {None};\n+        let data = if guard.can_timeout {Some(buf.to_vec())} else {None};\n         let uv_buf = if guard.can_timeout {\n             slice_to_uv_buf(data.as_ref().unwrap().as_slice())\n         } else {"}, {"sha": "de49fd6cf0986539483a728bc68ad926a4c36f04", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -159,7 +159,7 @@ impl StreamWatcher {\n         //\n         // To do this, the write context has an optionally owned vector of\n         // bytes.\n-        let data = if may_timeout {Some(Vec::from_slice(buf))} else {None};\n+        let data = if may_timeout {Some(buf.to_vec())} else {None};\n         let uv_buf = if may_timeout {\n             slice_to_uv_buf(data.as_ref().unwrap().as_slice())\n         } else {"}, {"sha": "e8d570f30e614a808c845c456eed44376ec2fe99", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -281,6 +281,7 @@ pub mod dl {\n #[cfg(target_os = \"windows\")]\n pub mod dl {\n     use c_str::ToCStr;\n+    use collections::MutableSeq;\n     use iter::Iterator;\n     use libc;\n     use os;\n@@ -295,8 +296,8 @@ pub mod dl {\n         // Windows expects Unicode data\n         let filename_cstr = filename.to_c_str();\n         let filename_str = str::from_utf8(filename_cstr.as_bytes_no_nul()).unwrap();\n-        let filename_str: Vec<u16> = filename_str.utf16_units().collect();\n-        let filename_str = filename_str.append_one(0);\n+        let mut filename_str: Vec<u16> = filename_str.utf16_units().collect();\n+        filename_str.push(0);\n         LoadLibraryW(filename_str.as_ptr() as *const libc::c_void) as *mut u8\n     }\n "}, {"sha": "0a969fc37c924aa6dc01c82ce0f4f39f47ad8d27", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -15,7 +15,7 @@ use comm::{Sender, Receiver};\n use io;\n use option::{None, Option, Some};\n use result::{Ok, Err};\n-use slice::{bytes, MutableSlice, ImmutableSlice};\n+use slice::{bytes, MutableSlice, ImmutableSlice, CloneableVector};\n use str::StrSlice;\n use super::{Reader, Writer, IoResult};\n use vec::Vec;\n@@ -118,7 +118,7 @@ impl Clone for ChanWriter {\n \n impl Writer for ChanWriter {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.tx.send_opt(Vec::from_slice(buf)).map_err(|_| {\n+        self.tx.send_opt(buf.to_vec()).map_err(|_| {\n             io::IoError {\n                 kind: io::BrokenPipe,\n                 desc: \"Pipe closed\","}, {"sha": "b8e18fc44cbc6400205fd74f1fe2f7fdc0985f61", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -61,7 +61,7 @@ use io::{IoResult, IoError, FileStat, SeekStyle, Seek, Writer, Reader};\n use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n use io::UpdateIoError;\n use io;\n-use iter::Iterator;\n+use iter::{Iterator, Extendable};\n use kinds::Send;\n use libc;\n use option::{Some, None, Option};\n@@ -688,7 +688,7 @@ impl Iterator<Path> for Directories {\n                                                 e, path.display()));\n \n                     match result {\n-                        Ok(dirs) => { self.stack.push_all_move(dirs); }\n+                        Ok(dirs) => { self.stack.extend(dirs.into_iter()); }\n                         Err(..) => {}\n                     }\n                 }"}, {"sha": "81dd114ec7d063063fb2d345774344cd1b320151", "filename": "src/libstd/os.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -46,15 +46,14 @@ use ptr::RawPtr;\n use ptr;\n use result::{Err, Ok, Result};\n use slice::{Slice, ImmutableSlice, MutableSlice, ImmutablePartialEqSlice};\n+use slice::CloneableVector;\n use str::{Str, StrSlice, StrAllocating};\n use string::String;\n use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use vec::Vec;\n \n-#[cfg(unix)]\n-use c_str::ToCStr;\n-#[cfg(unix)]\n-use libc::c_char;\n+#[cfg(unix)] use c_str::ToCStr;\n+#[cfg(unix)] use libc::c_char;\n \n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n@@ -260,8 +259,11 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             let mut i = 0;\n             while *ch.offset(i) != 0 {\n                 let p = &*ch.offset(i);\n-                let len = ptr::position(p, |c| *c == 0);\n-                raw::buf_as_slice(p, len, |s| {\n+                let mut len = 0;\n+                while *(p as *const _).offset(len) != 0 {\n+                    len += 1;\n+                }\n+                raw::buf_as_slice(p, len as uint, |s| {\n                     result.push(String::from_utf16_lossy(s).into_bytes());\n                 });\n                 i += len as int + 1;\n@@ -284,7 +286,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             let mut result = Vec::new();\n             while *environ != 0 as *const _ {\n                 let env_pair =\n-                    Vec::from_slice(CString::new(*environ, false).as_bytes_no_nul());\n+                    CString::new(*environ, false).as_bytes_no_nul().to_vec();\n                 result.push(env_pair);\n                 environ = environ.offset(1);\n             }\n@@ -295,9 +297,9 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             let mut pairs = Vec::new();\n             for p in input.iter() {\n                 let mut it = p.as_slice().splitn(1, |b| *b == b'=');\n-                let key = Vec::from_slice(it.next().unwrap());\n+                let key = it.next().unwrap().to_vec();\n                 let default: &[u8] = &[];\n-                let val = Vec::from_slice(it.next().unwrap_or(default));\n+                let val = it.next().unwrap_or(default).to_vec();\n                 pairs.push((key, val));\n             }\n             pairs\n@@ -351,8 +353,7 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n             if s.is_null() {\n                 None\n             } else {\n-                Some(Vec::from_slice(CString::new(s as *const i8,\n-                                                  false).as_bytes_no_nul()))\n+                Some(CString::new(s as *const i8, false).as_bytes_no_nul().to_vec())\n             }\n         })\n     }\n@@ -365,8 +366,8 @@ pub fn getenv(n: &str) -> Option<String> {\n     unsafe {\n         with_env_lock(|| {\n             use os::windows::{fill_utf16_buf_and_decode};\n-            let n: Vec<u16> = n.utf16_units().collect();\n-            let n = n.append_one(0);\n+            let mut n: Vec<u16> = n.utf16_units().collect();\n+            n.push(0);\n             fill_utf16_buf_and_decode(|buf, sz| {\n                 libc::GetEnvironmentVariableW(n.as_ptr(), buf, sz)\n             })\n@@ -412,10 +413,10 @@ pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n \n     #[cfg(windows)]\n     fn _setenv(n: &str, v: &[u8]) {\n-        let n: Vec<u16> = n.utf16_units().collect();\n-        let n = n.append_one(0);\n-        let v: Vec<u16> = ::str::from_utf8(v).unwrap().utf16_units().collect();\n-        let v = v.append_one(0);\n+        let mut n: Vec<u16> = n.utf16_units().collect();\n+        n.push(0);\n+        let mut v: Vec<u16> = ::str::from_utf8(v).unwrap().utf16_units().collect();\n+        v.push(0);\n \n         unsafe {\n             with_env_lock(|| {\n@@ -442,8 +443,8 @@ pub fn unsetenv(n: &str) {\n \n     #[cfg(windows)]\n     fn _unsetenv(n: &str) {\n-        let n: Vec<u16> = n.utf16_units().collect();\n-        let n = n.append_one(0);\n+        let mut n: Vec<u16> = n.utf16_units().collect();\n+        n.push(0);\n         unsafe {\n             with_env_lock(|| {\n                 libc::SetEnvironmentVariableW(n.as_ptr(), ptr::null());\n@@ -883,7 +884,11 @@ pub fn change_dir(p: &Path) -> bool {\n     #[cfg(windows)]\n     fn chdir(p: &Path) -> bool {\n         let p = match p.as_str() {\n-            Some(s) => s.utf16_units().collect::<Vec<u16>>().append_one(0),\n+            Some(s) => {\n+                let mut p = s.utf16_units().collect::<Vec<u16>>();\n+                p.push(0);\n+                p\n+            }\n             None => return false,\n         };\n         unsafe {\n@@ -1100,8 +1105,7 @@ unsafe fn load_argc_and_argv(argc: int,\n     use c_str::CString;\n \n     Vec::from_fn(argc as uint, |i| {\n-        Vec::from_slice(CString::new(*argv.offset(i as int),\n-                                     false).as_bytes_no_nul())\n+        CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_vec()\n     })\n }\n \n@@ -1170,7 +1174,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n                 mem::transmute(objc_msgSend(tmp, utf8Sel));\n             let s = CString::new(utf_c_str, false);\n             if s.is_not_null() {\n-                res.push(Vec::from_slice(s.as_bytes_no_nul()))\n+                res.push(s.as_bytes_no_nul().to_vec())\n             }\n         }\n     }"}, {"sha": "16552daae36b7526b0e109f30c88bc8ae52f187c", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -76,7 +76,7 @@ use option::{Option, None, Some};\n use str;\n use str::{MaybeOwned, Str, StrSlice};\n use string::String;\n-use slice::Slice;\n+use slice::{Slice, CloneableVector};\n use slice::{ImmutablePartialEqSlice, ImmutableSlice};\n use vec::Vec;\n \n@@ -480,7 +480,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(Vec::from_slice(name.slice_to(idx))),\n+                (Some(idx), 0) => Some(name.slice_to(idx).to_vec()),\n                 (idx, extlen) => {\n                     let idx = match idx {\n                         None | Some(0) => name.len(),\n@@ -798,7 +798,7 @@ pub trait BytesContainer {\n     /// Consumes the receiver and converts it into Vec<u8>\n     #[inline]\n     fn container_into_owned_bytes(self) -> Vec<u8> {\n-        Vec::from_slice(self.container_as_bytes())\n+        self.container_as_bytes().to_vec()\n     }\n     /// Returns the receiver interpreted as a utf-8 string, if possible\n     #[inline]"}, {"sha": "9c4139853c540b275b44d91f59c7f7a39ad3c51e", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -399,7 +399,7 @@ impl Path {\n             }\n         };\n         match val {\n-            None => Vec::from_slice(v.as_slice()),\n+            None => v.as_slice().to_vec(),\n             Some(val) => val\n         }\n     }"}, {"sha": "3f598e5280624e7dce759f5071f71962f8e4fee4", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -371,7 +371,7 @@ impl GenericPath for Path {\n \n     #[inline]\n     fn into_vec(self) -> Vec<u8> {\n-        Vec::from_slice(self.repr.as_bytes())\n+        self.repr.into_bytes()\n     }\n \n     #[inline]\n@@ -815,12 +815,14 @@ impl Path {\n                         let mut s = String::with_capacity(n);\n                         match prefix {\n                             Some(DiskPrefix) => {\n-                                s.push_char(prefix_.as_bytes()[0].to_ascii().to_uppercase().to_char());\n+                                s.push_char(prefix_.as_bytes()[0].to_ascii()\n+                                                   .to_uppercase().to_char());\n                                 s.push_char(':');\n                             }\n                             Some(VerbatimDiskPrefix) => {\n                                 s.push_str(prefix_.slice_to(4));\n-                                s.push_char(prefix_.as_bytes()[4].to_ascii().to_uppercase().to_char());\n+                                s.push_char(prefix_.as_bytes()[4].to_ascii()\n+                                                   .to_uppercase().to_char());\n                                 s.push_str(prefix_.slice_from(5));\n                             }\n                             Some(UNCPrefix(a,b)) => {\n@@ -1619,7 +1621,7 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"e\"], b\"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"\\\\e\", b\"f\"], b\"\\\\e\\\\f\");\n-        t!(v: b\"a\\\\b\\\\c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")],\n+        t!(v: b\"a\\\\b\\\\c\", [b\"d\".to_vec(), b\"e\".to_vec()],\n            b\"a\\\\b\\\\c\\\\d\\\\e\");\n     }\n \n@@ -1759,7 +1761,7 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"e\"], b\"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: b\"a\\\\b\\\\c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")],\n+        t!(v: b\"a\\\\b\\\\c\", [b\"d\".to_vec(), b\"e\".to_vec()],\n            b\"a\\\\b\\\\c\\\\d\\\\e\");\n     }\n "}, {"sha": "3f626d716f88bcb2c4bf13ad656dc2e00308f151", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -505,8 +505,8 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n             if flags.precision > s.len() {\n                 let mut s_ = Vec::with_capacity(flags.precision);\n                 let n = flags.precision - s.len();\n-                s_.grow(n, &b'0');\n-                s_.push_all_move(s);\n+                s_.grow(n, b'0');\n+                s_.extend(s.into_iter());\n                 s = s_;\n             }\n             assert!(!s.is_empty(), \"string conversion produced empty result\");\n@@ -524,7 +524,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                 FormatHex => {\n                     if flags.alternate {\n                         let s_ = replace(&mut s, vec!(b'0', b'x'));\n-                        s.push_all_move(s_);\n+                        s.extend(s_.into_iter());\n                     }\n                 }\n                 FormatHEX => {\n@@ -536,7 +536,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                          .collect();\n                     if flags.alternate {\n                         let s_ = replace(&mut s, vec!(b'0', b'X'));\n-                        s.push_all_move(s_);\n+                        s.extend(s_.into_iter());\n                     }\n                 }\n                 FormatString => unreachable!()\n@@ -546,7 +546,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n         Words(s) => {\n             match op {\n                 FormatString => {\n-                    let mut s = Vec::from_slice(s.as_bytes());\n+                    let mut s = s.as_bytes().to_vec();\n                     if flags.precision > 0 && flags.precision < s.len() {\n                         s.truncate(flags.precision);\n                     }\n@@ -562,11 +562,11 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n     if flags.width > s.len() {\n         let n = flags.width - s.len();\n         if flags.left {\n-            s.grow(n, &b' ');\n+            s.grow(n, b' ');\n         } else {\n             let mut s_ = Vec::with_capacity(flags.width);\n-            s_.grow(n, &b' ');\n-            s_.push_all_move(s);\n+            s_.grow(n, b' ');\n+            s_.extend(s.into_iter());\n             s = s_;\n         }\n     }"}, {"sha": "f59a4465e1da4b4ad092e07c23cde8ed826ded95", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -290,9 +290,8 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_string(),\n-                                      Vec::from_slice(\n-                                          string_table.slice(offset as uint,\n-                                          offset as uint + len)))\n+                                      string_table.slice(offset as uint,\n+                                          offset as uint + len).to_vec())\n                 },\n                 None => {\n                     return Err(\"invalid file: missing NUL in \\\n@@ -314,10 +313,10 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n /// Create a dummy TermInfo struct for msys terminals\n pub fn msys_terminfo() -> Box<TermInfo> {\n     let mut strings = HashMap::new();\n-    strings.insert(\"sgr0\".to_string(), Vec::from_slice(b\"\\x1B[0m\"));\n-    strings.insert(\"bold\".to_string(), Vec::from_slice(b\"\\x1B[1m\"));\n-    strings.insert(\"setaf\".to_string(), Vec::from_slice(b\"\\x1B[3%p1%dm\"));\n-    strings.insert(\"setab\".to_string(), Vec::from_slice(b\"\\x1B[4%p1%dm\"));\n+    strings.insert(\"sgr0\".to_string(), b\"\\x1B[0m\".to_vec());\n+    strings.insert(\"bold\".to_string(), b\"\\x1B[1m\".to_vec());\n+    strings.insert(\"setaf\".to_string(), b\"\\x1B[3%p1%dm\".to_vec());\n+    strings.insert(\"setab\".to_string(), b\"\\x1B[4%p1%dm\".to_vec());\n     box TermInfo {\n         names: vec!(\"cygwin\".to_string()), // msys is a fork of an older cygwin version\n         bools: HashMap::new(),"}, {"sha": "ae70bb4b7925a6eb367681f5eeec0e2ffa9ed758", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -261,13 +261,13 @@ impl<'a, T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n     }\n \n     fn percentile(self, pct: T) -> T {\n-        let mut tmp = Vec::from_slice(self);\n+        let mut tmp = self.to_vec();\n         local_sort(tmp.as_mut_slice());\n         percentile_of_sorted(tmp.as_slice(), pct)\n     }\n \n     fn quartiles(self) -> (T,T,T) {\n-        let mut tmp = Vec::from_slice(self);\n+        let mut tmp = self.to_vec();\n         local_sort(tmp.as_mut_slice());\n         let first = FromPrimitive::from_uint(25).unwrap();\n         let a = percentile_of_sorted(tmp.as_slice(), first);\n@@ -318,7 +318,7 @@ fn percentile_of_sorted<T: Float + FromPrimitive>(sorted_samples: &[T],\n ///\n /// See: http://en.wikipedia.org/wiki/Winsorising\n pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n-    let mut tmp = Vec::from_slice(samples);\n+    let mut tmp = samples.to_vec();\n     local_sort(tmp.as_mut_slice());\n     let lo = percentile_of_sorted(tmp.as_slice(), pct);\n     let hundred: T = FromPrimitive::from_uint(100).unwrap();"}, {"sha": "cdfb384d47ca27580bec9743e38245ceee9e91fb", "filename": "src/test/compile-fail/borrowck-for-loop-head-linkage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169218047dc989acf9ea25e3122b9c659acb6b3/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs?ref=0169218047dc989acf9ea25e3122b9c659acb6b3", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     let mut vector = vec![1u, 2];\n     for &x in vector.iter() {\n         let cap = vector.capacity();\n-        vector.grow(cap, &0u);      //~ ERROR cannot borrow\n+        vector.grow(cap, 0u);      //~ ERROR cannot borrow\n         *vector.get_mut(1u) = 5u;   //~ ERROR cannot borrow\n     }\n }"}]}