{"sha": "86e402904ae68e3a72e5c88d0a1722ab753f98d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZTQwMjkwNGFlNjhlM2E3MmU1Yzg4ZDBhMTcyMmFiNzUzZjk4ZDg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-02T12:18:13Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T15:07:59Z"}, "message": "rustc_typeck: simplify AstConv requests as implemented by collect.", "tree": {"sha": "686f80e3683e1292635ebf6cca2c03dd4709b05c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/686f80e3683e1292635ebf6cca2c03dd4709b05c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86e402904ae68e3a72e5c88d0a1722ab753f98d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86e402904ae68e3a72e5c88d0a1722ab753f98d8", "html_url": "https://github.com/rust-lang/rust/commit/86e402904ae68e3a72e5c88d0a1722ab753f98d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86e402904ae68e3a72e5c88d0a1722ab753f98d8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8d01ea4c76f6f3cb4f71dbff261355f825d12bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8d01ea4c76f6f3cb4f71dbff261355f825d12bb", "html_url": "https://github.com/rust-lang/rust/commit/e8d01ea4c76f6f3cb4f71dbff261355f825d12bb"}], "stats": {"total": 892, "additions": 350, "deletions": 542}, "files": [{"sha": "cd7474cf50b8c6cf4627f7f2a408680c9f545f3c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 18, "deletions": 62, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/86e402904ae68e3a72e5c88d0a1722ab753f98d8/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e402904ae68e3a72e5c88d0a1722ab753f98d8/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=86e402904ae68e3a72e5c88d0a1722ab753f98d8", "patch": "@@ -52,16 +52,14 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>>;\n \n     /// Returns the generic type and lifetime parameters for an item.\n-    fn get_generics(&self, span: Span, id: DefId)\n-                    -> Result<&'tcx ty::Generics, ErrorReported>;\n+    fn get_generics(&self, id: DefId) -> &'tcx ty::Generics;\n \n     /// Identify the type for an item, like a type alias, fn, or struct.\n-    fn get_item_type(&self, span: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported>;\n+    fn get_item_type(&self, span: Span, id: DefId) -> Ty<'tcx>;\n \n     /// Returns the `TraitDef` for a given trait. This allows you to\n     /// figure out the set of type parameters defined on the trait.\n-    fn get_trait_def(&self, span: Span, id: DefId)\n-                     -> Result<&'tcx ty::TraitDef, ErrorReported>;\n+    fn get_trait_def(&self, id: DefId) -> &'tcx ty::TraitDef;\n \n     /// Ensure that the super-predicates for the trait with the given\n     /// id are available and also for the transitive set of\n@@ -251,14 +249,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n-        let decl_generics = match self.get_generics(span, def_id) {\n-            Ok(generics) => generics,\n-            Err(ErrorReported) => {\n-                // No convenient way to recover from a cycle here. Just bail. Sorry!\n-                self.tcx().sess.abort_if_errors();\n-                bug!(\"ErrorReported returned, but no errors reports?\")\n-            }\n-        };\n+        let decl_generics = self.get_generics(def_id);\n         let expected_num_region_params = decl_generics.regions.len();\n         let supplied_num_region_params = lifetimes.len();\n         if expected_num_region_params != supplied_num_region_params {\n@@ -279,8 +270,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n         let default_needs_object_self = |p: &ty::TypeParameterDef| {\n             if is_object && p.has_default {\n-                let default = self.get_item_type(span, p.def_id).ok();\n-                if default.has_self_ty() {\n+                if self.get_item_type(span, p.def_id).has_self_ty() {\n                     // There is no suitable inference default for a type parameter\n                     // that references self, in an object type.\n                     return true;\n@@ -347,10 +337,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     tcx.types.err\n                 } else {\n                     // This is a default type parameter.\n-                    match self.get_item_type(span, def.def_id) {\n-                        Ok(ty) => ty.subst_spanned(tcx, substs, Some(span)),\n-                        Err(ErrorReported) => tcx.types.err\n-                    }\n+                    self.get_item_type(span, def.def_id).subst_spanned(tcx, substs, Some(span))\n                 }\n             } else {\n                 // We've already errored above about the mismatch.\n@@ -499,14 +486,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\",\n                trait_segment);\n \n-        let trait_def = match self.get_trait_def(span, trait_def_id) {\n-            Ok(trait_def) => trait_def,\n-            Err(ErrorReported) => {\n-                // No convenient way to recover from a cycle here. Just bail. Sorry!\n-                self.tcx().sess.abort_if_errors();\n-                bug!(\"ErrorReported returned, but no errors reports?\")\n-            }\n-        };\n+        let trait_def = self.get_trait_def(trait_def_id);\n \n         match trait_segment.parameters {\n             hir::AngleBracketedParameters(_) => {\n@@ -647,16 +627,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         item_segment: &hir::PathSegment)\n         -> Ty<'tcx>\n     {\n-        let tcx = self.tcx();\n-        let decl_ty = match self.get_item_type(span, did) {\n-            Ok(ty) => ty,\n-            Err(ErrorReported) => {\n-                return tcx.types.err;\n-            }\n-        };\n-\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n-        decl_ty.subst(self.tcx(), substs)\n+        self.get_item_type(span, did).subst(self.tcx(), substs)\n     }\n \n     /// Transform a PolyTraitRef into a PolyExistentialTraitRef by\n@@ -1058,37 +1030,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 tcx.prohibit_type_params(&path.segments);\n \n                 let node_id = tcx.hir.as_local_node_id(did).unwrap();\n-                let item_def_id = tcx.hir.local_def_id(::ty_param_owner(tcx, node_id));\n-                let index = match self.get_generics(span, item_def_id) {\n-                    Ok(generics) => {\n-                        generics.type_param_to_index[&tcx.hir.local_def_id(node_id).index]\n-                    }\n-                    Err(ErrorReported) => return tcx.types.err\n-                };\n-                tcx.mk_param(index, ::ty_param_name(tcx, node_id))\n+                let item_id = tcx.hir.get_parent_node(node_id);\n+                let item_def_id = tcx.hir.local_def_id(item_id);\n+                let generics = self.get_generics(item_def_id);\n+                let index = generics.type_param_to_index[&tcx.hir.local_def_id(node_id).index];\n+                tcx.mk_param(index, tcx.hir.name(node_id))\n             }\n             Def::SelfTy(_, Some(def_id)) => {\n                 // Self in impl (we know the concrete type).\n \n                 assert_eq!(opt_self_ty, None);\n                 tcx.prohibit_type_params(&path.segments);\n \n-                // FIXME: Self type is not always computed when we are here because type parameter\n-                // bounds may affect Self type and have to be converted before it.\n-                let ty = if def_id.is_local() {\n-                    tcx.item_types.borrow().get(&def_id).cloned()\n-                } else {\n-                    Some(tcx.item_type(def_id))\n-                };\n-                if let Some(ty) = ty {\n-                    if let Some(free_substs) = self.get_free_substs() {\n-                        ty.subst(tcx, free_substs)\n-                    } else {\n-                        ty\n-                    }\n+                let ty = self.get_item_type(span, def_id);\n+                if let Some(free_substs) = self.get_free_substs() {\n+                    ty.subst(tcx, free_substs)\n                 } else {\n-                    tcx.sess.span_err(span, \"`Self` type is used before it's determined\");\n-                    tcx.types.err\n+                    ty\n                 }\n             }\n             Def::SelfTy(Some(_), None) => {\n@@ -1241,9 +1199,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Create the anonymized type.\n                 if allow {\n                     let def_id = tcx.hir.local_def_id(ast_ty.id);\n-                    if let Err(ErrorReported) = self.get_generics(ast_ty.span, def_id) {\n-                        return tcx.types.err;\n-                    }\n+                    self.get_generics(def_id);\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     let ty = tcx.mk_anon(tcx.hir.local_def_id(ast_ty.id), substs);\n "}, {"sha": "d4895d638ba0d2fbab3d024aa70dfe25cdcf7ea8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/86e402904ae68e3a72e5c88d0a1722ab753f98d8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e402904ae68e3a72e5c88d0a1722ab753f98d8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=86e402904ae68e3a72e5c88d0a1722ab753f98d8", "patch": "@@ -91,7 +91,7 @@ use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n-use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n+use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPolyTraitRef};\n use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n@@ -1359,21 +1359,16 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         &self.ast_ty_to_ty_cache\n     }\n \n-    fn get_generics(&self, _: Span, id: DefId)\n-                    -> Result<&'tcx ty::Generics, ErrorReported>\n-    {\n-        Ok(self.tcx().item_generics(id))\n+    fn get_generics(&self, id: DefId) -> &'tcx ty::Generics {\n+        self.tcx().item_generics(id)\n     }\n \n-    fn get_item_type(&self, _: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported>\n-    {\n-        Ok(self.tcx().item_type(id))\n+    fn get_item_type(&self, _: Span, id: DefId) -> Ty<'tcx> {\n+        self.tcx().item_type(id)\n     }\n \n-    fn get_trait_def(&self, _: Span, id: DefId)\n-                     -> Result<&'tcx ty::TraitDef, ErrorReported>\n-    {\n-        Ok(self.tcx().lookup_trait_def(id))\n+    fn get_trait_def(&self, id: DefId) -> &'tcx ty::TraitDef {\n+        self.tcx().lookup_trait_def(id)\n     }\n \n     fn ensure_super_predicates(&self, _: Span, _: DefId) -> Result<(), ErrorReported> {\n@@ -1391,7 +1386,8 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n                                  -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n     {\n         let tcx = self.tcx;\n-        let item_def_id = tcx.hir.local_def_id(::ty_param_owner(tcx, node_id));\n+        let item_id = ::ty_param_owner(tcx, node_id);\n+        let item_def_id = tcx.hir.local_def_id(item_id);\n         let generics = tcx.item_generics(item_def_id);\n         let index = generics.type_param_to_index[&tcx.hir.local_def_id(node_id).index];\n         let r = self.parameter_environment"}, {"sha": "975a9aa994624846e12226af2a51a18a6a0538ff", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 296, "deletions": 452, "changes": 748, "blob_url": "https://github.com/rust-lang/rust/blob/86e402904ae68e3a72e5c88d0a1722ab753f98d8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e402904ae68e3a72e5c88d0a1722ab753f98d8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=86e402904ae68e3a72e5c88d0a1722ab753f98d8", "patch": "@@ -104,21 +104,17 @@ pub fn collect_item_types(ccx: &CrateCtxt) {\n /// available in various different forms at various points in the\n /// process. So we can't just store a pointer to e.g. the AST or the\n /// parsed ty form, we have to be more flexible. To this end, the\n-/// `ItemCtxt` is parameterized by a `GetTypeParameterBounds` object\n-/// that it uses to satisfy `get_type_parameter_bounds` requests.\n-/// This object might draw the information from the AST\n-/// (`hir::Generics`) or it might draw from a `ty::GenericPredicates`\n-/// or both (a tuple).\n+/// `ItemCtxt` is parameterized by a `DefId` that it uses to satisfy\n+/// `get_type_parameter_bounds` requests, drawing the information from\n+/// the AST (`hir::Generics`), recursively.\n struct ItemCtxt<'a,'tcx:'a> {\n     ccx: &'a CrateCtxt<'a,'tcx>,\n-    param_bounds: &'a (GetTypeParameterBounds<'tcx>+'a),\n+    item_def_id: DefId,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum AstConvRequest {\n-    GetGenerics(DefId),\n-    GetItemTypeScheme(DefId),\n-    GetTraitDef(DefId),\n+    GetItemType(DefId),\n     EnsureSuperPredicates(DefId),\n     GetTypeParameterBounds(ast::NodeId),\n }\n@@ -234,10 +230,10 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n // Utility types and common code for the above passes.\n \n impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n-    fn icx(&'a self, param_bounds: &'a GetTypeParameterBounds<'tcx>) -> ItemCtxt<'a,'tcx> {\n+    fn icx(&'a self, item_def_id: DefId) -> ItemCtxt<'a,'tcx> {\n         ItemCtxt {\n             ccx: self,\n-            param_bounds: param_bounds,\n+            item_def_id: item_def_id,\n         }\n     }\n \n@@ -276,9 +272,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         err.span_label(span, &format!(\"cyclic reference\"));\n \n         match cycle[0] {\n-            AstConvRequest::GetGenerics(def_id) |\n-            AstConvRequest::GetItemTypeScheme(def_id) |\n-            AstConvRequest::GetTraitDef(def_id) => {\n+            AstConvRequest::GetItemType(def_id) => {\n                 err.note(\n                     &format!(\"the cycle begins when processing `{}`...\",\n                              tcx.item_path_str(def_id)));\n@@ -298,9 +292,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n         for request in &cycle[1..] {\n             match *request {\n-                AstConvRequest::GetGenerics(def_id) |\n-                AstConvRequest::GetItemTypeScheme(def_id) |\n-                AstConvRequest::GetTraitDef(def_id) => {\n+                AstConvRequest::GetItemType(def_id) => {\n                     err.note(\n                         &format!(\"...which then requires processing `{}`...\",\n                                  tcx.item_path_str(def_id)));\n@@ -320,9 +312,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         }\n \n         match cycle[0] {\n-            AstConvRequest::GetGenerics(def_id) |\n-            AstConvRequest::GetItemTypeScheme(def_id) |\n-            AstConvRequest::GetTraitDef(def_id) => {\n+            AstConvRequest::GetItemType(def_id) => {\n                 err.note(\n                     &format!(\"...which then again requires processing `{}`, completing the cycle.\",\n                              tcx.item_path_str(def_id)));\n@@ -343,25 +333,6 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         err.emit();\n     }\n \n-    /// Loads the trait def for a given trait, returning ErrorReported if a cycle arises.\n-    fn get_trait_def(&self, def_id: DefId)\n-                     -> &'tcx ty::TraitDef\n-    {\n-        let tcx = self.tcx;\n-\n-        if let Some(trait_id) = tcx.hir.as_local_node_id(def_id) {\n-            let item = match tcx.hir.get(trait_id) {\n-                hir_map::NodeItem(item) => item,\n-                _ => bug!(\"get_trait_def({:?}): not an item\", trait_id)\n-            };\n-\n-            generics_of_def_id(self, def_id);\n-            trait_def_of_item(self, &item)\n-        } else {\n-            tcx.lookup_trait_def(def_id)\n-        }\n-    }\n-\n     /// Ensure that the (transitive) super predicates for\n     /// `trait_def_id` are available. This will report a cycle error\n     /// if a trait `X` (transitively) extends itself in some form.\n@@ -393,26 +364,24 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         &self.ccx.ast_ty_to_ty_cache\n     }\n \n-    fn get_generics(&self, span: Span, id: DefId)\n-                    -> Result<&'tcx ty::Generics, ErrorReported>\n-    {\n-        self.ccx.cycle_check(span, AstConvRequest::GetGenerics(id), || {\n-            Ok(generics_of_def_id(self.ccx, id))\n-        })\n+    fn get_generics(&self, id: DefId) -> &'tcx ty::Generics {\n+        generics_of_def_id(self.ccx, id)\n     }\n \n-    fn get_item_type(&self, span: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported> {\n-        self.ccx.cycle_check(span, AstConvRequest::GetItemTypeScheme(id), || {\n+    fn get_item_type(&self, span: Span, id: DefId) -> Ty<'tcx> {\n+        self.ccx.cycle_check(span, AstConvRequest::GetItemType(id), || {\n             Ok(type_of_def_id(self.ccx, id))\n-        })\n+        }).unwrap_or(self.ccx.tcx.types.err)\n     }\n \n-    fn get_trait_def(&self, span: Span, id: DefId)\n-                     -> Result<&'tcx ty::TraitDef, ErrorReported>\n-    {\n-        self.ccx.cycle_check(span, AstConvRequest::GetTraitDef(id), || {\n-            Ok(self.ccx.get_trait_def(id))\n-        })\n+    fn get_trait_def(&self, def_id: DefId) -> &'tcx ty::TraitDef {\n+        let tcx = self.ccx.tcx;\n+\n+        if let Some(trait_id) = tcx.hir.as_local_node_id(def_id) {\n+            trait_def_of_item(self.ccx, tcx.hir.expect_item(trait_id))\n+        } else {\n+            tcx.lookup_trait_def(def_id)\n+        }\n     }\n \n     fn ensure_super_predicates(&self,\n@@ -426,17 +395,16 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         self.ccx.ensure_super_predicates(span, trait_def_id)\n     }\n \n-\n     fn get_type_parameter_bounds(&self,\n                                  span: Span,\n                                  node_id: ast::NodeId)\n                                  -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetTypeParameterBounds(node_id), || {\n-            let v = self.param_bounds.get_type_parameter_bounds(self, span, node_id)\n-                                     .into_iter()\n-                                     .filter_map(|p| p.to_opt_poly_trait_ref())\n-                                     .collect();\n+            let v = self.ccx.get_type_parameter_bounds(self.item_def_id, node_id)\n+                            .into_iter()\n+                            .filter_map(|p| p.to_opt_poly_trait_ref())\n+                            .collect();\n             Ok(v)\n         })\n     }\n@@ -492,130 +460,119 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n }\n \n-/// Interface used to find the bounds on a type parameter from within\n-/// an `ItemCtxt`. This allows us to use multiple kinds of sources.\n-trait GetTypeParameterBounds<'tcx> {\n-    fn get_type_parameter_bounds(&self,\n-                                 astconv: &AstConv<'tcx, 'tcx>,\n-                                 span: Span,\n-                                 node_id: ast::NodeId)\n-                                 -> Vec<ty::Predicate<'tcx>>;\n-}\n-\n-/// Find bounds from both elements of the tuple.\n-impl<'a,'b,'tcx,A,B> GetTypeParameterBounds<'tcx> for (&'a A,&'b B)\n-    where A : GetTypeParameterBounds<'tcx>, B : GetTypeParameterBounds<'tcx>\n-{\n+impl<'a, 'tcx> CrateCtxt<'a, 'tcx> {\n     fn get_type_parameter_bounds(&self,\n-                                 astconv: &AstConv<'tcx, 'tcx>,\n-                                 span: Span,\n-                                 node_id: ast::NodeId)\n+                                 item_def_id: DefId,\n+                                 param_id: ast::NodeId)\n                                  -> Vec<ty::Predicate<'tcx>>\n     {\n-        let mut v = self.0.get_type_parameter_bounds(astconv, span, node_id);\n-        v.extend(self.1.get_type_parameter_bounds(astconv, span, node_id));\n-        v\n-    }\n-}\n+        use rustc::hir::map::*;\n+        use rustc::hir::*;\n \n-/// Empty set of bounds.\n-impl<'tcx> GetTypeParameterBounds<'tcx> for () {\n-    fn get_type_parameter_bounds(&self,\n-                                 _astconv: &AstConv<'tcx, 'tcx>,\n-                                 _span: Span,\n-                                 _node_id: ast::NodeId)\n-                                 -> Vec<ty::Predicate<'tcx>>\n-    {\n-        Vec::new()\n-    }\n-}\n+        // In the AST, bounds can derive from two places. Either\n+        // written inline like `<T:Foo>` or in a where clause like\n+        // `where T:Foo`.\n \n-/// Find bounds from the parsed and converted predicates.  This is\n-/// used when converting methods, because by that time the predicates\n-/// from the trait/impl have been fully converted.\n-impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n-    fn get_type_parameter_bounds(&self,\n-                                 astconv: &AstConv<'tcx, 'tcx>,\n-                                 span: Span,\n-                                 node_id: ast::NodeId)\n-                                 -> Vec<ty::Predicate<'tcx>>\n-    {\n-        let tcx = astconv.tcx();\n-        let item_def_id = tcx.hir.local_def_id(::ty_param_owner(tcx, node_id));\n-        let generics = tcx.item_generics(item_def_id);\n-        let index = generics.type_param_to_index[&tcx.hir.local_def_id(node_id).index];\n-\n-        let mut results = self.parent.map_or(vec![], |def_id| {\n-            let parent = tcx.item_predicates(def_id);\n-            parent.get_type_parameter_bounds(astconv, span, node_id)\n+        let tcx = self.tcx;\n+        let param_owner_def_id = tcx.hir.local_def_id(::ty_param_owner(tcx, param_id));\n+        let generics = generics_of_def_id(self, param_owner_def_id);\n+        let index = generics.type_param_to_index[&tcx.hir.local_def_id(param_id).index];\n+        let ty = tcx.mk_param(index, ::ty_param_name(tcx, param_id));\n+\n+        // Don't look for bounds where the type parameter isn't in scope.\n+        let parent = if item_def_id == param_owner_def_id {\n+            None\n+        } else {\n+            generics_of_def_id(self, item_def_id).parent\n+        };\n+\n+        let mut results = parent.map_or(vec![], |def_id| {\n+            self.get_type_parameter_bounds(def_id, param_id)\n         });\n \n-        results.extend(self.predicates.iter().filter(|predicate| {\n-            match **predicate {\n-                ty::Predicate::Trait(ref data) => {\n-                    data.skip_binder().self_ty().is_param(index)\n+        let item_node_id = tcx.hir.as_local_node_id(item_def_id).unwrap();\n+        let ast_generics = match tcx.hir.get(item_node_id) {\n+            NodeTraitItem(item) => {\n+                match item.node {\n+                    TraitItemKind::Method(ref sig, _) => &sig.generics,\n+                    _ => return results\n                 }\n-                ty::Predicate::TypeOutlives(ref data) => {\n-                    data.skip_binder().0.is_param(index)\n+            }\n+\n+            NodeImplItem(item) => {\n+                match item.node {\n+                    ImplItemKind::Method(ref sig, _) => &sig.generics,\n+                    _ => return results\n                 }\n-                ty::Predicate::Equate(..) |\n-                ty::Predicate::RegionOutlives(..) |\n-                ty::Predicate::WellFormed(..) |\n-                ty::Predicate::ObjectSafe(..) |\n-                ty::Predicate::ClosureKind(..) |\n-                ty::Predicate::Projection(..) => {\n-                    false\n+            }\n+\n+            NodeItem(item) => {\n+                match item.node {\n+                    ItemFn(.., ref generics, _) |\n+                    ItemImpl(_, _, ref generics, ..) |\n+                    ItemTy(_, ref generics) |\n+                    ItemEnum(_, ref generics) |\n+                    ItemStruct(_, ref generics) |\n+                    ItemUnion(_, ref generics) => generics,\n+                    ItemTrait(_, ref generics, ..) => {\n+                        // Implied `Self: Trait` and supertrait bounds.\n+                        if param_id == item_node_id {\n+                            results.push(ty::TraitRef {\n+                                def_id: item_def_id,\n+                                substs: mk_item_substs(self, item_def_id)\n+                            }.to_predicate());\n+                        }\n+                        generics\n+                    }\n+                    _ => return results\n                 }\n             }\n-        }).cloned());\n \n+            NodeForeignItem(item) => {\n+                match item.node {\n+                    ForeignItemFn(_, _, ref generics) => generics,\n+                    _ => return results\n+                }\n+            }\n+\n+            _ => return results\n+        };\n+\n+        let icx = self.icx(item_def_id);\n+        results.extend(icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty));\n         results\n     }\n }\n \n-/// Find bounds from hir::Generics. This requires scanning through the\n-/// AST. We do this to avoid having to convert *all* the bounds, which\n-/// would create artificial cycles. Instead we can only convert the\n-/// bounds for a type parameter `X` if `X::Foo` is used.\n-impl<'tcx> GetTypeParameterBounds<'tcx> for hir::Generics {\n-    fn get_type_parameter_bounds(&self,\n-                                 astconv: &AstConv<'tcx, 'tcx>,\n-                                 span: Span,\n-                                 node_id: ast::NodeId)\n-                                 -> Vec<ty::Predicate<'tcx>>\n+impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n+    /// Find bounds from hir::Generics. This requires scanning through the\n+    /// AST. We do this to avoid having to convert *all* the bounds, which\n+    /// would create artificial cycles. Instead we can only convert the\n+    /// bounds for a type parameter `X` if `X::Foo` is used.\n+    fn type_parameter_bounds_in_generics(&self,\n+                                         ast_generics: &hir::Generics,\n+                                         param_id: ast::NodeId,\n+                                         ty: Ty<'tcx>)\n+                                         -> Vec<ty::Predicate<'tcx>>\n     {\n-        // In the AST, bounds can derive from two places. Either\n-        // written inline like `<T:Foo>` or in a where clause like\n-        // `where T:Foo`.\n-\n-        let tcx = astconv.tcx();\n-        let item_def_id = tcx.hir.local_def_id(::ty_param_owner(tcx, node_id));\n-        let index = match astconv.get_generics(span, item_def_id) {\n-            Ok(generics) => {\n-                generics.type_param_to_index[&tcx.hir.local_def_id(node_id).index]\n-            }\n-            Err(ErrorReported) => return vec![]\n-        };\n-        let ty = tcx.mk_param(index, ::ty_param_name(tcx, node_id));\n-\n         let from_ty_params =\n-            self.ty_params\n+            ast_generics.ty_params\n                 .iter()\n-                .filter(|p| p.id == node_id)\n+                .filter(|p| p.id == param_id)\n                 .flat_map(|p| p.bounds.iter())\n-                .flat_map(|b| predicates_from_bound(astconv, ty, b));\n+                .flat_map(|b| predicates_from_bound(self, ty, b));\n \n         let from_where_clauses =\n-            self.where_clause\n+            ast_generics.where_clause\n                 .predicates\n                 .iter()\n                 .filter_map(|wp| match *wp {\n                     hir::WherePredicate::BoundPredicate(ref bp) => Some(bp),\n                     _ => None\n                 })\n-                .filter(|bp| is_param(tcx, &bp.bounded_ty, node_id))\n+                .filter(|bp| is_param(self.ccx.tcx, &bp.bounded_ty, param_id))\n                 .flat_map(|bp| bp.bounds.iter())\n-                .flat_map(|b| predicates_from_bound(astconv, ty, b));\n+                .flat_map(|b| predicates_from_bound(self, ty, b));\n \n         from_ty_params.chain(from_where_clauses).collect()\n     }\n@@ -644,38 +601,27 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                           struct_generics: &'tcx ty::Generics,\n-                           struct_predicates: &ty::GenericPredicates<'tcx>,\n                            field: &hir::StructField,\n                            ty_f: &'tcx ty::FieldDef)\n {\n-    let tt = ccx.icx(struct_predicates).to_ty(&field.ty);\n+    generics_of_def_id(ccx, ty_f.did);\n+    let tt = ccx.icx(ty_f.did).to_ty(&field.ty);\n     ccx.tcx.item_types.borrow_mut().insert(ty_f.did, tt);\n-\n-    let def_id = ccx.tcx.hir.local_def_id(field.id);\n-    assert_eq!(def_id, ty_f.did);\n-    ccx.tcx.generics.borrow_mut().insert(def_id, struct_generics);\n-    ccx.tcx.predicates.borrow_mut().insert(def_id, struct_predicates.clone());\n+    ccx.tcx.predicates.borrow_mut().insert(ty_f.did, ty::GenericPredicates {\n+        parent: Some(ccx.tcx.hir.get_parent_did(field.id)),\n+        predicates: vec![]\n+    });\n }\n \n-fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                            id: ast::NodeId,\n-                            sig: &hir::MethodSig,\n-                            rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,) {\n+fn convert_method(ccx: &CrateCtxt, id: ast::NodeId, sig: &hir::MethodSig) {\n     let def_id = ccx.tcx.hir.local_def_id(id);\n-    let ty_generics = generics_of_def_id(ccx, def_id);\n-\n-    let ty_generic_predicates =\n-        ty_generic_predicates(ccx, &sig.generics, ty_generics.parent, vec![], false);\n-\n-    let fty = AstConv::ty_of_fn(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                                sig.unsafety, sig.abi, &sig.decl);\n \n-    let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                                ccx.tcx.hir.span(id), def_id);\n+    let fty = AstConv::ty_of_fn(&ccx.icx(def_id), sig.unsafety, sig.abi, &sig.decl);\n+    let substs = mk_item_substs(ccx, def_id);\n     let fty = ccx.tcx.mk_fn_def(def_id, substs, fty);\n     ccx.tcx.item_types.borrow_mut().insert(def_id, fty);\n-    ccx.tcx.predicates.borrow_mut().insert(def_id, ty_generic_predicates);\n+\n+    ty_generic_predicates(ccx, def_id, &sig.generics);\n }\n \n fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -752,6 +698,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", it.name, it.id);\n     let def_id = ccx.tcx.hir.local_def_id(it.id);\n+    let icx = ccx.icx(def_id);\n     match it.node {\n         // These don't define types.\n         hir::ItemExternCrate(_) | hir::ItemUse(..) | hir::ItemMod(_) => {\n@@ -762,19 +709,17 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n+            generics_of_def_id(ccx, def_id);\n+            predicates_of_item(ccx, it);\n             let ty = type_of_def_id(ccx, def_id);\n-            let generics = generics_of_def_id(ccx, def_id);\n-            let predicates = predicates_of_item(ccx, it);\n             convert_enum_variant_types(ccx,\n                                        tcx.lookup_adt_def(ccx.tcx.hir.local_def_id(it.id)),\n                                        ty,\n-                                       generics,\n-                                       predicates,\n                                        &enum_definition.variants);\n         },\n         hir::ItemDefaultImpl(_, ref ast_trait_ref) => {\n             let trait_ref =\n-                AstConv::instantiate_mono_trait_ref(&ccx.icx(&()),\n+                AstConv::instantiate_mono_trait_ref(&icx,\n                                                     ast_trait_ref,\n                                                     tcx.mk_self_type());\n \n@@ -783,73 +728,50 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             tcx.impl_trait_refs.borrow_mut().insert(ccx.tcx.hir.local_def_id(it.id),\n                                                     Some(trait_ref));\n         }\n-        hir::ItemImpl(..,\n-                      ref generics,\n-                      ref opt_trait_ref,\n-                      ref selfty,\n-                      _) => {\n-            // Create generics from the generics specified in the impl head.\n-            debug!(\"convert: ast_generics={:?}\", generics);\n+        hir::ItemImpl(.., ref opt_trait_ref, _, _) => {\n             generics_of_def_id(ccx, def_id);\n-            let mut ty_predicates =\n-                ty_generic_predicates(ccx, generics, None, vec![], false);\n-\n-            debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n-\n-            let selfty = ccx.icx(&ty_predicates).to_ty(&selfty);\n-            tcx.item_types.borrow_mut().insert(def_id, selfty);\n+            let selfty = type_of_def_id(ccx, def_id);\n \n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n-                AstConv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n-                                                    ast_trait_ref,\n-                                                    selfty)\n+                AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n             });\n             tcx.impl_trait_refs.borrow_mut().insert(def_id, trait_ref);\n \n-            // Subtle: before we store the predicates into the tcx, we\n-            // sort them so that predicates like `T: Foo<Item=U>` come\n-            // before uses of `U`.  This avoids false ambiguity errors\n-            // in trait checking. See `setup_constraining_predicates`\n-            // for details.\n-            ctp::setup_constraining_predicates(&mut ty_predicates.predicates,\n-                                               trait_ref,\n-                                               &mut ctp::parameters_for_impl(selfty, trait_ref));\n-\n-            tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n+            predicates_of_item(ccx, it);\n         },\n         hir::ItemTrait(..) => {\n             generics_of_def_id(ccx, def_id);\n             trait_def_of_item(ccx, it);\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n                 ccx.ensure_super_predicates(it.span, def_id);\n-            convert_trait_predicates(ccx, it);\n+            predicates_of_item(ccx, it);\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n+            generics_of_def_id(ccx, def_id);\n+            predicates_of_item(ccx, it);\n             let ty = type_of_def_id(ccx, def_id);\n-            let generics = generics_of_def_id(ccx, def_id);\n-            let predicates = predicates_of_item(ccx, it);\n \n             let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n             for (f, ty_f) in struct_def.fields().iter().zip(variant.fields.iter()) {\n-                convert_field(ccx, generics, &predicates, f, ty_f)\n+                convert_field(ccx, f, ty_f)\n             }\n \n             if !struct_def.is_struct() {\n-                convert_variant_ctor(ccx, struct_def.id(), variant, ty, predicates);\n+                convert_variant_ctor(ccx, struct_def.id(), variant, ty);\n             }\n         },\n         hir::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n-            type_of_def_id(ccx, def_id);\n             generics_of_def_id(ccx, def_id);\n             predicates_of_item(ccx, it);\n+            type_of_def_id(ccx, def_id);\n         },\n         _ => {\n-            type_of_def_id(ccx, def_id);\n             generics_of_def_id(ccx, def_id);\n             predicates_of_item(ccx, it);\n+            type_of_def_id(ccx, def_id);\n         },\n     }\n }\n@@ -860,32 +782,28 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n     // we can lookup details about the trait because items are visited\n     // before trait-items\n     let trait_def_id = tcx.hir.get_parent_did(trait_item.id);\n-    let trait_predicates = tcx.item_predicates(trait_def_id);\n \n+    let def_id = ccx.tcx.hir.local_def_id(trait_item.id);\n     match trait_item.node {\n         hir::TraitItemKind::Const(ref ty, _) => {\n-            let const_def_id = ccx.tcx.hir.local_def_id(trait_item.id);\n-            generics_of_def_id(ccx, const_def_id);\n-            let ty = ccx.icx(&trait_predicates).to_ty(&ty);\n+            generics_of_def_id(ccx, def_id);\n+            let ty = ccx.icx(def_id).to_ty(&ty);\n             convert_associated_const(ccx,\n                                      TraitContainer(trait_def_id),\n                                      trait_item.id,\n                                      ty);\n         }\n \n         hir::TraitItemKind::Type(_, ref opt_ty) => {\n-            let type_def_id = ccx.tcx.hir.local_def_id(trait_item.id);\n-            generics_of_def_id(ccx, type_def_id);\n+            generics_of_def_id(ccx, def_id);\n \n-            let typ = opt_ty.as_ref().map({\n-                |ty| ccx.icx(&trait_predicates).to_ty(&ty)\n-            });\n+            let typ = opt_ty.as_ref().map(|ty| ccx.icx(def_id).to_ty(&ty));\n \n             convert_associated_type(ccx, TraitContainer(trait_def_id), trait_item.id, typ);\n         }\n \n         hir::TraitItemKind::Method(ref sig, _) => {\n-            convert_method(ccx, trait_item.id, sig, &trait_predicates);\n+            convert_method(ccx, trait_item.id, sig);\n         }\n     }\n }\n@@ -896,53 +814,49 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n     // we can lookup details about the impl because items are visited\n     // before impl-items\n     let impl_def_id = tcx.hir.get_parent_did(impl_item.id);\n-    let impl_predicates = tcx.item_predicates(impl_def_id);\n-    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n \n+    let def_id = ccx.tcx.hir.local_def_id(impl_item.id);\n     match impl_item.node {\n         hir::ImplItemKind::Const(ref ty, _) => {\n-            let const_def_id = ccx.tcx.hir.local_def_id(impl_item.id);\n-            generics_of_def_id(ccx, const_def_id);\n-            let ty = ccx.icx(&impl_predicates).to_ty(&ty);\n+            generics_of_def_id(ccx, def_id);\n+            let ty = ccx.icx(def_id).to_ty(&ty);\n             convert_associated_const(ccx,\n                                      ImplContainer(impl_def_id),\n                                      impl_item.id,\n                                      ty);\n         }\n \n         hir::ImplItemKind::Type(ref ty) => {\n-            let type_def_id = ccx.tcx.hir.local_def_id(impl_item.id);\n-            generics_of_def_id(ccx, type_def_id);\n+            generics_of_def_id(ccx, def_id);\n \n-            if impl_trait_ref.is_none() {\n+            if tcx.impl_trait_ref(impl_def_id).is_none() {\n                 span_err!(tcx.sess, impl_item.span, E0202,\n                           \"associated types are not allowed in inherent impls\");\n             }\n \n-            let typ = ccx.icx(&impl_predicates).to_ty(ty);\n+            let typ = ccx.icx(def_id).to_ty(ty);\n \n             convert_associated_type(ccx, ImplContainer(impl_def_id), impl_item.id, Some(typ));\n         }\n \n         hir::ImplItemKind::Method(ref sig, _) => {\n-            convert_method(ccx, impl_item.id, sig, &impl_predicates);\n+            convert_method(ccx, impl_item.id, sig);\n         }\n     }\n }\n \n fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   ctor_id: ast::NodeId,\n                                   variant: &'tcx ty::VariantDef,\n-                                  ty: Ty<'tcx>,\n-                                  predicates: ty::GenericPredicates<'tcx>) {\n+                                  ty: Ty<'tcx>) {\n     let tcx = ccx.tcx;\n     let def_id = tcx.hir.local_def_id(ctor_id);\n     generics_of_def_id(ccx, def_id);\n     let ctor_ty = match variant.ctor_kind {\n         CtorKind::Fictive | CtorKind::Const => ty,\n         CtorKind::Fn => {\n             let inputs = variant.fields.iter().map(|field| tcx.item_type(field.did));\n-            let substs = mk_item_substs(&ccx.icx(&predicates), ccx.tcx.hir.span(ctor_id), def_id);\n+            let substs = mk_item_substs(ccx, def_id);\n             tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Abi::Rust,\n@@ -951,30 +865,25 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n     tcx.item_types.borrow_mut().insert(def_id, ctor_ty);\n-    tcx.predicates.borrow_mut().insert(tcx.hir.local_def_id(ctor_id), predicates);\n+    tcx.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n+        parent: Some(ccx.tcx.hir.get_parent_did(ctor_id)),\n+        predicates: vec![]\n+    });\n }\n \n fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                         def: &'tcx ty::AdtDef,\n                                         ty: Ty<'tcx>,\n-                                        generics: &'tcx ty::Generics,\n-                                        predicates: ty::GenericPredicates<'tcx>,\n                                         variants: &[hir::Variant]) {\n     // fill the field types\n     for (variant, ty_variant) in variants.iter().zip(def.variants.iter()) {\n         for (f, ty_f) in variant.node.data.fields().iter().zip(ty_variant.fields.iter()) {\n-            convert_field(ccx, generics, &predicates, f, ty_f)\n+            convert_field(ccx, f, ty_f)\n         }\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        convert_variant_ctor(\n-            ccx,\n-            variant.node.data.id(),\n-            ty_variant,\n-            ty,\n-            predicates.clone()\n-        );\n+        convert_variant_ctor(ccx, variant.node.data.id(), ty_variant, ty);\n     }\n }\n \n@@ -1180,24 +1089,11 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n                            \"ensure_super_predicates_step invoked on non-trait\"),\n         };\n \n-        // In-scope when converting the superbounds for `Trait` are\n-        // that `Self:Trait` as well as any bounds that appear on the\n-        // generic types:\n-        generics_of_def_id(ccx, trait_def_id);\n-        trait_def_of_item(ccx, item);\n-        let trait_ref = ty::TraitRef {\n-            def_id: trait_def_id,\n-            substs: Substs::identity_for_item(tcx, trait_def_id)\n-        };\n-        let self_predicate = ty::GenericPredicates {\n-            parent: None,\n-            predicates: vec![trait_ref.to_predicate()]\n-        };\n-        let scope = &(generics, &self_predicate);\n+        let icx = ccx.icx(trait_def_id);\n \n         // Convert the bounds that follow the colon, e.g. `Bar+Zed` in `trait Foo : Bar+Zed`.\n         let self_param_ty = tcx.mk_self_type();\n-        let superbounds1 = compute_bounds(&ccx.icx(scope),\n+        let superbounds1 = compute_bounds(&icx,\n                                           self_param_ty,\n                                           bounds,\n                                           SizedByDefault::No,\n@@ -1207,7 +1103,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n \n         // Convert any explicit superbounds in the where clause,\n         // e.g. `trait Foo where Self : Bar`:\n-        let superbounds2 = generics.get_type_parameter_bounds(&ccx.icx(scope), item.span, item.id);\n+        let superbounds2 = icx.type_parameter_bounds_in_generics(generics, item.id, self_param_ty);\n \n         // Combine the two lists to form the complete set of superbounds:\n         let superbounds = superbounds1.into_iter().chain(superbounds2).collect();\n@@ -1236,8 +1132,8 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n }\n \n fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) -> &'tcx ty::TraitDef {\n-    let def_id = ccx.tcx.hir.local_def_id(it.id);\n     let tcx = ccx.tcx;\n+    let def_id = tcx.hir.local_def_id(it.id);\n \n     tcx.trait_defs.memoize(def_id, || {\n         let unsafety = match it.node {\n@@ -1246,8 +1142,8 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) -> &'t\n         };\n \n         let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n-        if paren_sugar && !ccx.tcx.sess.features.borrow().unboxed_closures {\n-            let mut err = ccx.tcx.sess.struct_span_err(\n+        if paren_sugar && !tcx.sess.features.borrow().unboxed_closures {\n+            let mut err = tcx.sess.struct_span_err(\n                 it.span,\n                 \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n                 which traits can use parenthetical notation\");\n@@ -1262,86 +1158,6 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) -> &'t\n     })\n }\n \n-fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) {\n-    let tcx = ccx.tcx;\n-\n-    let def_id = ccx.tcx.hir.local_def_id(it.id);\n-\n-    generics_of_def_id(ccx, def_id);\n-    trait_def_of_item(ccx, it);\n-\n-    let (generics, items) = match it.node {\n-        hir::ItemTrait(_, ref generics, _, ref items) => (generics, items),\n-        ref s => {\n-            span_bug!(\n-                it.span,\n-                \"trait_def_of_item invoked on {:?}\",\n-                s);\n-        }\n-    };\n-\n-    let super_predicates = ccx.tcx.item_super_predicates(def_id);\n-\n-    // `ty_generic_predicates` below will consider the bounds on the type\n-    // parameters (including `Self`) and the explicit where-clauses,\n-    // but to get the full set of predicates on a trait we need to add\n-    // in the supertrait bounds and anything declared on the\n-    // associated types.\n-    let mut base_predicates = super_predicates.predicates;\n-\n-    // Add in a predicate that `Self:Trait` (where `Trait` is the\n-    // current trait).  This is needed for builtin bounds.\n-    let trait_ref = ty::TraitRef {\n-        def_id: def_id,\n-        substs: Substs::identity_for_item(tcx, def_id)\n-    };\n-    let self_predicate = trait_ref.to_poly_trait_ref().to_predicate();\n-    base_predicates.push(self_predicate);\n-\n-    // add in the explicit where-clauses\n-    let mut trait_predicates =\n-        ty_generic_predicates(ccx, generics, None, base_predicates, true);\n-\n-    let assoc_predicates = predicates_for_associated_types(ccx,\n-                                                           generics,\n-                                                           &trait_predicates,\n-                                                           trait_ref,\n-                                                           items);\n-    trait_predicates.predicates.extend(assoc_predicates);\n-\n-    tcx.predicates.borrow_mut().insert(def_id, trait_predicates);\n-    return;\n-\n-    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                 ast_generics: &hir::Generics,\n-                                                 trait_predicates: &ty::GenericPredicates<'tcx>,\n-                                                 self_trait_ref: ty::TraitRef<'tcx>,\n-                                                 trait_item_refs: &[hir::TraitItemRef])\n-                                                 -> Vec<ty::Predicate<'tcx>>\n-    {\n-        trait_item_refs.iter().flat_map(|trait_item_ref| {\n-            let trait_item = ccx.tcx.hir.trait_item(trait_item_ref.id);\n-            let bounds = match trait_item.node {\n-                hir::TraitItemKind::Type(ref bounds, _) => bounds,\n-                _ => {\n-                    return vec![].into_iter();\n-                }\n-            };\n-\n-            let assoc_ty = ccx.tcx.mk_projection(self_trait_ref,\n-                                                 trait_item.name);\n-\n-            let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),\n-                                        assoc_ty,\n-                                        bounds,\n-                                        SizedByDefault::Yes,\n-                                        trait_item.span);\n-\n-            bounds.predicates(ccx.tcx, assoc_ty).into_iter()\n-        }).collect()\n-    }\n-}\n-\n fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 def_id: DefId)\n                                 -> &'tcx ty::Generics {\n@@ -1360,7 +1176,8 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             NodeImplItem(_) |\n             NodeTraitItem(_) |\n             NodeVariant(_) |\n-            NodeStructCtor(_) => {\n+            NodeStructCtor(_) |\n+            NodeField(_) => {\n                 let parent_id = tcx.hir.get_parent(node_id);\n                 Some(tcx.hir.local_def_id(parent_id))\n             }\n@@ -1460,8 +1277,8 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n              generics.parent_types + generics.types.len() as u32)\n         });\n \n-        let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n-        let regions = early_lifetimes.iter().enumerate().map(|(i, l)| {\n+        let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n+        let regions = early_lifetimes.enumerate().map(|(i, l)| {\n             let issue_32330 = ccx.tcx.named_region_map.issue_32330\n                                                       .get(&l.lifetime.id)\n                                                       .cloned();\n@@ -1555,38 +1372,37 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // Alway bring in generics, as computing the type needs them.\n         generics_of_def_id(ccx, def_id);\n \n+        let icx = ccx.icx(def_id);\n+\n         let ty = match ccx.tcx.hir.get(node_id) {\n             NodeItem(item) => {\n                 match item.node {\n-                    ItemStatic(ref t, ..) | ItemConst(ref t, _) => {\n-                        ccx.icx(&()).to_ty(&t)\n+                    ItemStatic(ref t, ..) | ItemConst(ref t, _) |\n+                    ItemTy(ref t, _) | ItemImpl(.., ref t, _) => {\n+                        icx.to_ty(t)\n                     }\n-                    ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n-                        let tofd = AstConv::ty_of_fn(&ccx.icx(generics), unsafety, abi, &decl);\n-                        let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n+                    ItemFn(ref decl, unsafety, _, abi, _, _) => {\n+                        let tofd = AstConv::ty_of_fn(&icx, unsafety, abi, &decl);\n+                        let substs = mk_item_substs(ccx, def_id);\n                         ccx.tcx.mk_fn_def(def_id, substs, tofd)\n                     }\n-                    ItemTy(ref t, ref generics) => {\n-                        ccx.icx(generics).to_ty(&t)\n-                    }\n-                    ItemEnum(ref ei, ref generics) => {\n+                    ItemEnum(ref ei, _) => {\n                         let def = convert_enum_def(ccx, item, ei);\n-                        let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n+                        let substs = mk_item_substs(ccx, def_id);\n                         ccx.tcx.mk_adt(def, substs)\n                     }\n-                    ItemStruct(ref si, ref generics) => {\n+                    ItemStruct(ref si, _) => {\n                         let def = convert_struct_def(ccx, item, si);\n-                        let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n+                        let substs = mk_item_substs(ccx, def_id);\n                         ccx.tcx.mk_adt(def, substs)\n                     }\n-                    ItemUnion(ref un, ref generics) => {\n+                    ItemUnion(ref un, _) => {\n                         let def = convert_union_def(ccx, item, un);\n-                        let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n+                        let substs = mk_item_substs(ccx, def_id);\n                         ccx.tcx.mk_adt(def, substs)\n                     }\n                     ItemDefaultImpl(..) |\n                     ItemTrait(..) |\n-                    ItemImpl(..) |\n                     ItemMod(..) |\n                     ItemForeignMod(..) |\n                     ItemExternCrate(..) |\n@@ -1602,14 +1418,10 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let abi = ccx.tcx.hir.get_foreign_abi(node_id);\n \n                 match foreign_item.node {\n-                    ForeignItemFn(ref fn_decl, _, ref generics) => {\n-                        compute_type_of_foreign_fn_decl(\n-                            ccx, ccx.tcx.hir.local_def_id(foreign_item.id),\n-                            fn_decl, generics, abi)\n-                    }\n-                    ForeignItemStatic(ref t, _) => {\n-                        ccx.icx(&()).to_ty(t)\n+                    ForeignItemFn(ref fn_decl, _, _) => {\n+                        compute_type_of_foreign_fn_decl(ccx, def_id, fn_decl, abi)\n                     }\n+                    ForeignItemStatic(ref t, _) => icx.to_ty(t)\n                 }\n             }\n             NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n@@ -1623,7 +1435,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 ))\n             }\n             NodeTyParam(&hir::TyParam { default: Some(ref ty), .. }) => {\n-                ccx.icx(&()).to_ty(ty)\n+                icx.to_ty(ty)\n             }\n             x => {\n                 bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n@@ -1634,9 +1446,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     })\n }\n \n-fn predicates_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                it: &hir::Item)\n-                                -> ty::GenericPredicates<'tcx> {\n+fn predicates_of_item(ccx: &CrateCtxt, it: &hir::Item) {\n     let def_id = ccx.tcx.hir.local_def_id(it.id);\n \n     let no_generics = hir::Generics::empty();\n@@ -1645,14 +1455,13 @@ fn predicates_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         hir::ItemTy(_, ref generics) |\n         hir::ItemEnum(_, ref generics) |\n         hir::ItemStruct(_, ref generics) |\n-        hir::ItemUnion(_, ref generics) => generics,\n+        hir::ItemUnion(_, ref generics) |\n+        hir::ItemTrait(_, ref generics, _, _) |\n+        hir::ItemImpl(_, _, ref generics, ..) => generics,\n         _ => &no_generics\n     };\n \n-    let predicates = ty_generic_predicates(ccx, generics, None, vec![], false);\n-    ccx.tcx.predicates.borrow_mut().insert(def_id, predicates.clone());\n-\n-    predicates\n+    ty_generic_predicates(ccx, def_id, generics);\n }\n \n fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -1663,17 +1472,16 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n     let def_id = ccx.tcx.hir.local_def_id(it.id);\n-    type_of_def_id(ccx, def_id);\n     generics_of_def_id(ccx, def_id);\n+    type_of_def_id(ccx, def_id);\n \n     let no_generics = hir::Generics::empty();\n     let generics = match it.node {\n         hir::ForeignItemFn(_, _, ref generics) => generics,\n         hir::ForeignItemStatic(..) => &no_generics\n     };\n \n-    let predicates = ty_generic_predicates(ccx, generics, None, vec![], false);\n-    ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n+    ty_generic_predicates(ccx, def_id, generics);\n }\n \n // Is it marked with ?Sized\n@@ -1725,95 +1533,105 @@ fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n /// the lifetimes that are declared. For fns or methods, we have to\n /// screen out those that do not appear in any where-clauses etc using\n /// `resolve_lifetime::early_bound_lifetimes`.\n-fn early_bound_lifetimes_from_generics<'a, 'tcx, 'hir>(\n-    ccx: &CrateCtxt<'a, 'tcx>,\n-    ast_generics: &'hir hir::Generics)\n-    -> Vec<&'hir hir::LifetimeDef>\n+fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ast_generics: &'a hir::Generics)\n+    -> impl Iterator<Item=&'a hir::LifetimeDef>\n {\n     ast_generics\n         .lifetimes\n         .iter()\n-        .filter(|l| !ccx.tcx.named_region_map.late_bound.contains(&l.lifetime.id))\n-        .collect()\n+        .filter(move |l| !tcx.named_region_map.late_bound.contains(&l.lifetime.id))\n }\n \n-fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                  ast_generics: &hir::Generics,\n-                                  parent: Option<DefId>,\n-                                  super_predicates: Vec<ty::Predicate<'tcx>>,\n-                                  has_self: bool)\n-                                  -> ty::GenericPredicates<'tcx>\n-{\n+fn ty_generic_predicates(ccx: &CrateCtxt, def_id: DefId, ast_generics: &hir::Generics) {\n     let tcx = ccx.tcx;\n-    let parent_count = parent.map_or(0, |def_id| {\n-        let generics = generics_of_def_id(ccx, def_id);\n-        assert_eq!(generics.parent, None);\n-        assert_eq!(generics.parent_regions, 0);\n-        assert_eq!(generics.parent_types, 0);\n-        generics.count() as u32\n-    });\n-    let ref base_predicates = match parent {\n-        Some(def_id) => {\n-            assert_eq!(super_predicates, vec![]);\n-            tcx.item_predicates(def_id)\n-        }\n-        None => {\n-            ty::GenericPredicates {\n-                parent: None,\n-                predicates: super_predicates.clone()\n+    let icx = ccx.icx(def_id);\n+    let generics = generics_of_def_id(ccx, def_id);\n+    let parent_count = generics.parent_count() as u32;\n+    let has_own_self = generics.has_self && parent_count == 0;\n+\n+    let mut predicates = vec![];\n+\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let (is_trait, is_impl) = match tcx.hir.get(node_id) {\n+        hir::map::NodeItem(item) => {\n+            match item.node {\n+                hir::ItemTrait(.., ref items) => {\n+                    (Some((ty::TraitRef {\n+                        def_id: def_id,\n+                        substs: mk_item_substs(ccx, def_id)\n+                    }, items)), None)\n+                }\n+                hir::ItemImpl(..) => {\n+                    let self_ty = type_of_def_id(ccx, def_id);\n+                    let trait_ref = tcx.impl_trait_ref(def_id);\n+                    (None, Some((self_ty, trait_ref)))\n+                }\n+                _ => (None, None)\n             }\n         }\n+        _ => (None, None)\n     };\n-    let mut predicates = super_predicates;\n+\n+    // Below we'll consider the bounds on the type parameters (including `Self`)\n+    // and the explicit where-clauses, but to get the full set of predicates\n+    // on a trait we need to add in the supertrait bounds and bounds found on\n+    // associated types.\n+    if let Some((trait_ref, _)) = is_trait {\n+        predicates = tcx.item_super_predicates(def_id).predicates;\n+\n+        // Add in a predicate that `Self:Trait` (where `Trait` is the\n+        // current trait).  This is needed for builtin bounds.\n+        predicates.push(trait_ref.to_poly_trait_ref().to_predicate());\n+    }\n \n     // Collect the region predicates that were declared inline as\n     // well. In the case of parameters declared on a fn or method, we\n     // have to be careful to only iterate over early-bound regions.\n-    let own_start = parent_count + has_self as u32;\n-    let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n-    for (index, param) in early_lifetimes.iter().enumerate() {\n-        let index = own_start + index as u32;\n-        let region = ccx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+    let mut index = parent_count + has_own_self as u32;\n+    for param in early_bound_lifetimes_from_generics(tcx, ast_generics) {\n+        let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: index,\n             name: param.lifetime.name\n         }));\n+        index += 1;\n+\n         for bound in &param.bounds {\n-            let bound_region = AstConv::ast_region_to_region(&ccx.icx(&()), bound, None);\n+            let bound_region = AstConv::ast_region_to_region(&icx, bound, None);\n             let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n             predicates.push(outlives.to_predicate());\n         }\n     }\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n-    let type_start = own_start + early_lifetimes.len() as u32;\n-    for (index, param) in ast_generics.ty_params.iter().enumerate() {\n-        let index = type_start + index as u32;\n-        let param_ty = ty::ParamTy::new(index, param.name).to_ty(ccx.tcx);\n-        let bounds = compute_bounds(&ccx.icx(&(base_predicates, ast_generics)),\n+    for param in &ast_generics.ty_params {\n+        let param_ty = ty::ParamTy::new(index, param.name).to_ty(tcx);\n+        index += 1;\n+\n+        let bounds = compute_bounds(&icx,\n                                     param_ty,\n                                     &param.bounds,\n                                     SizedByDefault::Yes,\n                                     param.span);\n-        predicates.extend(bounds.predicates(ccx.tcx, param_ty));\n+        predicates.extend(bounds.predicates(tcx, param_ty));\n     }\n \n     // Add in the bounds that appear in the where-clause\n     let where_clause = &ast_generics.where_clause;\n     for predicate in &where_clause.predicates {\n         match predicate {\n             &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                let ty = AstConv::ast_ty_to_ty(&ccx.icx(&(base_predicates, ast_generics)),\n-                                               &bound_pred.bounded_ty);\n+                let ty = icx.to_ty(&bound_pred.bounded_ty);\n \n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n                         &hir::TyParamBound::TraitTyParamBound(ref poly_trait_ref, _) => {\n                             let mut projections = Vec::new();\n \n                             let trait_ref =\n-                                AstConv::instantiate_poly_trait_ref(&ccx.icx(&(base_predicates,\n-                                                                               ast_generics)),\n+                                AstConv::instantiate_poly_trait_ref(&icx,\n                                                                     poly_trait_ref,\n                                                                     ty,\n                                                                     &mut projections);\n@@ -1826,7 +1644,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         }\n \n                         &hir::TyParamBound::RegionTyParamBound(ref lifetime) => {\n-                            let region = AstConv::ast_region_to_region(&ccx.icx(&()),\n+                            let region = AstConv::ast_region_to_region(&icx,\n                                                                        lifetime,\n                                                                        None);\n                             let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n@@ -1837,9 +1655,9 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             }\n \n             &hir::WherePredicate::RegionPredicate(ref region_pred) => {\n-                let r1 = AstConv::ast_region_to_region(&ccx.icx(&()), &region_pred.lifetime, None);\n+                let r1 = AstConv::ast_region_to_region(&icx, &region_pred.lifetime, None);\n                 for bound in &region_pred.bounds {\n-                    let r2 = AstConv::ast_region_to_region(&ccx.icx(&()), bound, None);\n+                    let r2 = AstConv::ast_region_to_region(&icx, bound, None);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n                     predicates.push(ty::Predicate::RegionOutlives(pred))\n                 }\n@@ -1851,10 +1669,44 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n     }\n \n-    ty::GenericPredicates {\n-        parent: parent,\n-        predicates: predicates\n+    // Add predicates from associated type bounds.\n+    if let Some((self_trait_ref, trait_items)) = is_trait {\n+        predicates.extend(trait_items.iter().flat_map(|trait_item_ref| {\n+            let trait_item = tcx.hir.trait_item(trait_item_ref.id);\n+            let bounds = match trait_item.node {\n+                hir::TraitItemKind::Type(ref bounds, _) => bounds,\n+                _ => {\n+                    return vec![].into_iter();\n+                }\n+            };\n+\n+            let assoc_ty = tcx.mk_projection(self_trait_ref, trait_item.name);\n+\n+            let bounds = compute_bounds(&ccx.icx(def_id),\n+                                        assoc_ty,\n+                                        bounds,\n+                                        SizedByDefault::Yes,\n+                                        trait_item.span);\n+\n+            bounds.predicates(tcx, assoc_ty).into_iter()\n+        }))\n+    }\n+\n+    // Subtle: before we store the predicates into the tcx, we\n+    // sort them so that predicates like `T: Foo<Item=U>` come\n+    // before uses of `U`.  This avoids false ambiguity errors\n+    // in trait checking. See `setup_constraining_predicates`\n+    // for details.\n+    if let Some((self_ty, trait_ref)) = is_impl {\n+        ctp::setup_constraining_predicates(&mut predicates,\n+                                           trait_ref,\n+                                           &mut ctp::parameters_for_impl(self_ty, trait_ref));\n     }\n+\n+    tcx.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n+        parent: generics.parent,\n+        predicates: predicates\n+    });\n }\n \n pub enum SizedByDefault { Yes, No, }\n@@ -1947,11 +1799,10 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n     ccx: &CrateCtxt<'a, 'tcx>,\n     def_id: DefId,\n     decl: &hir::FnDecl,\n-    ast_generics: &hir::Generics,\n     abi: abi::Abi)\n     -> Ty<'tcx>\n {\n-    let fty = AstConv::ty_of_fn(&ccx.icx(ast_generics), hir::Unsafety::Unsafe, abi, decl);\n+    let fty = AstConv::ty_of_fn(&ccx.icx(def_id), hir::Unsafety::Unsafe, abi, decl);\n \n     // feature gate SIMD types in FFI, since I (huonw) am not sure the\n     // ABIs are handled at all correctly.\n@@ -1975,22 +1826,15 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let id = ccx.tcx.hir.as_local_node_id(def_id).unwrap();\n-    let substs = mk_item_substs(&ccx.icx(ast_generics), ccx.tcx.hir.span(id), def_id);\n+    let substs = mk_item_substs(ccx, def_id);\n     ccx.tcx.mk_fn_def(def_id, substs, fty)\n }\n \n-fn mk_item_substs<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n-                        span: Span,\n-                        def_id: DefId)\n-                        -> &'tcx Substs<'tcx> {\n-    let tcx = astconv.tcx();\n+fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                            def_id: DefId)\n+                            -> &'tcx Substs<'tcx> {\n     // FIXME(eddyb) Do this request from Substs::for_item in librustc.\n-    if let Err(ErrorReported) = astconv.get_generics(span, def_id) {\n-        // No convenient way to recover from a cycle here. Just bail. Sorry!\n-        tcx.sess.abort_if_errors();\n-        bug!(\"ErrorReported returned, but no errors reports?\")\n-    }\n+    generics_of_def_id(ccx, def_id);\n \n-    Substs::identity_for_item(tcx, def_id)\n+    Substs::identity_for_item(ccx.tcx, def_id)\n }"}, {"sha": "7a5ef3540e93d08224a1a754374411c4caab08cc", "filename": "src/test/compile-fail/resolve-self-in-impl.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/86e402904ae68e3a72e5c88d0a1722ab753f98d8/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e402904ae68e3a72e5c88d0a1722ab753f98d8/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs?ref=86e402904ae68e3a72e5c88d0a1722ab753f98d8", "patch": "@@ -8,22 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_type_defaults)]\n+\n struct S<T = u8>(T);\n-trait Tr<T = u8> {}\n+trait Tr<T = u8> {\n+    type A = ();\n+}\n \n impl Tr<Self> for S {} // OK\n+impl<T: Tr<Self>> Tr<T> for S {} // OK\n+impl<T = Self> Tr<T> for S {} // OK\n+impl Tr for S where Self: Copy {} // OK\n+impl Tr for S where S<Self>: Copy {} // OK\n+impl Tr for S where Self::A: Copy {} // OK\n \n-// FIXME: `Self` cannot be used in bounds because it depends on bounds itself.\n-impl<T: Tr<Self>> Tr<T> for S {} //~ ERROR `Self` type is used before it's determined\n-impl<T = Self> Tr<T> for S {}\n-impl Tr for S where Self: Copy {} //~ ERROR `Self` type is used before it's determined\n-impl Tr for S where S<Self>: Copy {} //~ ERROR `Self` type is used before it's determined\n-impl Tr for S where Self::Assoc: Copy {} //~ ERROR `Self` type is used before it's determined\n-                                         //~^ ERROR `Self` type is used before it's determined\n-impl Tr for Self {} //~ ERROR `Self` type is used before it's determined\n-impl Tr for S<Self> {} //~ ERROR `Self` type is used before it's determined\n-impl Self {} //~ ERROR `Self` type is used before it's determined\n-impl S<Self> {} //~ ERROR `Self` type is used before it's determined\n-impl Tr<Self::Assoc> for S {} //~ ERROR `Self` type is used before it's determined\n+impl Tr for Self {} //~ ERROR unsupported cyclic reference between types/traits detected\n+impl Tr for S<Self> {} //~ ERROR unsupported cyclic reference between types/traits detected\n+impl Self {} //~ ERROR unsupported cyclic reference between types/traits detected\n+impl S<Self> {} //~ ERROR unsupported cyclic reference between types/traits detected\n+impl Tr<Self::A> for S {} //~ ERROR `Self` type is used before it's determined\n \n fn main() {}"}, {"sha": "587fb3f80d6c8a810910d7a31aa2c0451202ef8e", "filename": "src/test/run-pass/associated-types-sugar-path.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86e402904ae68e3a72e5c88d0a1722ab753f98d8/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e402904ae68e3a72e5c88d0a1722ab753f98d8/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs?ref=86e402904ae68e3a72e5c88d0a1722ab753f98d8", "patch": "@@ -10,10 +10,13 @@\n \n // Test paths to associated types using the type-parameter-only sugar.\n \n+use std::ops::Deref;\n \n pub trait Foo {\n     type A;\n     fn boo(&self) -> Self::A;\n+\n+    fn baz(_: Self::Target) where Self: Deref {}\n }\n \n impl Foo for isize {"}, {"sha": "fda87de9b9c500bb2f3d151ec33aa14cc7d9ca59", "filename": "src/test/ui/resolve/issue-23305.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/86e402904ae68e3a72e5c88d0a1722ab753f98d8/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/86e402904ae68e3a72e5c88d0a1722ab753f98d8/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr?ref=86e402904ae68e3a72e5c88d0a1722ab753f98d8", "patch": "@@ -1,8 +1,15 @@\n-error: `Self` type is used before it's determined\n+error[E0391]: unsupported cyclic reference between types/traits detected\n   --> $DIR/issue-23305.rs:15:12\n    |\n 15 | impl ToNbt<Self> {}\n-   |            ^^^^\n+   |            ^^^^ cyclic reference\n+   |\n+note: the cycle begins when processing `<impl at $DIR/issue-23305.rs:15:1: 15:20>`...\n+  --> $DIR/issue-23305.rs:15:1\n+   |\n+15 | impl ToNbt<Self> {}\n+   | ^^^^^^^^^^^^^^^^^^^\n+   = note: ...which then again requires processing `<impl at $DIR/issue-23305.rs:15:1: 15:20>`, completing the cycle.\n \n error: aborting due to previous error\n "}]}