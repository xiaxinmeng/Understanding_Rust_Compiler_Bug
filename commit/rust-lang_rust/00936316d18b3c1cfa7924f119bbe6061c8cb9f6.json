{"sha": "00936316d18b3c1cfa7924f119bbe6061c8cb9f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwOTM2MzE2ZDE4YjNjMWNmYTc5MjRmMTE5YmJlNjA2MWM4Y2I5ZjY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-05T15:23:22Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-08T07:29:34Z"}, "message": "treat shared and raw borrows alike", "tree": {"sha": "61dc42a541b109ee5e0e0058eb5e8a30b87307b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61dc42a541b109ee5e0e0058eb5e8a30b87307b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00936316d18b3c1cfa7924f119bbe6061c8cb9f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00936316d18b3c1cfa7924f119bbe6061c8cb9f6", "html_url": "https://github.com/rust-lang/rust/commit/00936316d18b3c1cfa7924f119bbe6061c8cb9f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00936316d18b3c1cfa7924f119bbe6061c8cb9f6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74635a57e2c0d8791a49170bb8c06042a9b3a62e", "url": "https://api.github.com/repos/rust-lang/rust/commits/74635a57e2c0d8791a49170bb8c06042a9b3a62e", "html_url": "https://github.com/rust-lang/rust/commit/74635a57e2c0d8791a49170bb8c06042a9b3a62e"}], "stats": {"total": 26, "additions": 13, "deletions": 13}, "files": [{"sha": "e1abcb20af756ca21e662a23d84ea9b3f2707d7d", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/00936316d18b3c1cfa7924f119bbe6061c8cb9f6/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00936316d18b3c1cfa7924f119bbe6061c8cb9f6/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=00936316d18b3c1cfa7924f119bbe6061c8cb9f6", "patch": "@@ -139,13 +139,13 @@ pub struct Stacks {\n /// Core operations\n impl<'tcx> Stack {\n     /// Check if `bor` could be activated by unfreezing and popping.\n-    /// `usage` indicates whether this is being used to read/write (or, equivalently, to\n-    /// borrow as &/&mut), or to borrow as raw.\n+    /// `is_write` indicates whether this is being used to write (or, equivalently, to\n+    /// borrow as &mut).\n     /// Returns `Err` if the answer is \"no\"; otherwise the return value indicates what to\n     /// do: With `Some(n)` you need to unfreeze, and then additionally pop `n` items.\n-    fn reactivatable(&self, bor: Borrow, usage: UsageKind) -> Result<Option<usize>, String> {\n+    fn reactivatable(&self, bor: Borrow, is_write: bool) -> Result<Option<usize>, String> {\n         // Check if we can match the frozen \"item\".  Not possible on writes!\n-        if usage != UsageKind::Write {\n+        if !is_write {\n             // For now, we do NOT check the timestamp.  That might be surprising, but\n             // we cannot even notice when a location should be frozen but is not!\n             // Those checks are both done in `tag_dereference`, where we have type information.\n@@ -168,11 +168,11 @@ impl<'tcx> Stack {\n                 }\n                 (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n                     // Found matching unique item.\n-                    if usage == UsageKind::Read {\n+                    if !is_write {\n                         // As a special case, if we are reading and since we *did* find the `Uniq`,\n                         // we try to pop less: We are happy with making a `Shr` or `Frz` active;\n                         // that one will not mind concurrent reads.\n-                        match self.reactivatable(Borrow::default(), usage) {\n+                        match self.reactivatable(Borrow::default(), is_write) {\n                             // If we got something better that `idx`, use that\n                             Ok(None) => return Ok(None),\n                             Ok(Some(shr_idx)) if shr_idx <= idx => return Ok(Some(shr_idx)),\n@@ -194,10 +194,10 @@ impl<'tcx> Stack {\n         Err(format!(\"Borrow-to-reactivate {:?} does not exist on the stack\", bor))\n     }\n \n-    /// Reactive `bor` for this stack.  `usage` indicates whether this is being\n-    /// used to read/write (or, equivalently, to borrow as &/&mut), or to borrow as raw.\n-    fn reactivate(&mut self, bor: Borrow, usage: UsageKind) -> EvalResult<'tcx> {\n-        let mut pop = match self.reactivatable(bor, usage) {\n+    /// Reactive `bor` for this stack.  `is_write` indicates whether this is being\n+    /// used to write (or, equivalently, to borrow as &mut).\n+    fn reactivate(&mut self, bor: Borrow, is_write: bool) -> EvalResult<'tcx> {\n+        let mut pop = match self.reactivatable(bor, is_write) {\n             Ok(None) => return Ok(()),\n             Ok(Some(pop)) => pop,\n             Err(err) => return err!(MachineError(err)),\n@@ -272,7 +272,7 @@ impl State {\n \n /// Higher-level operations\n impl<'tcx> Stacks {\n-    /// The single most important operation: Make sure that using `ptr` as `usage` is okay,\n+    /// The single most important operation: Make sure that using `ptr` is okay,\n     /// and if `new_bor` is present then make that the new current borrow.\n     fn use_and_maybe_re_borrow(\n         &self,\n@@ -285,7 +285,7 @@ impl<'tcx> Stacks {\n             ptr.tag, usage, new_bor, ptr, size.bytes());\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.reactivate(ptr.tag, usage)?;\n+            stack.reactivate(ptr.tag, usage == UsageKind::Write)?;\n             if let Some(new_bor) = new_bor {\n                 stack.initiate(new_bor);\n             }\n@@ -317,7 +317,7 @@ impl<'tcx> Stacks {\n         // We need `iter_mut` because `iter` would skip gaps!\n         for stack in stacks.iter_mut(ptr.offset, size) {\n             // Conservatively assume we will just read\n-            if let Err(err) = stack.reactivatable(ptr.tag, UsageKind::Read) {\n+            if let Err(err) = stack.reactivatable(ptr.tag, /*is_write*/false) {\n                 return err!(MachineError(format!(\n                     \"Encountered reference with non-reactivatable tag: {}\",\n                     err"}]}