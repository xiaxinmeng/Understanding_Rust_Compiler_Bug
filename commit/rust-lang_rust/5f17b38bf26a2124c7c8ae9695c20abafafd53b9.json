{"sha": "5f17b38bf26a2124c7c8ae9695c20abafafd53b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMTdiMzhiZjI2YTIxMjRjN2M4YWU5Njk1YzIwYWJhZmFmZDUzYjk=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-01-24T14:53:16Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-01-24T14:53:16Z"}, "message": "Merge pull request #580 from mcarton/derive\n\nLint explicit Clone implementations on Copy type", "tree": {"sha": "fefa15c424d75ed9c9ef10577552449be2fdb6f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fefa15c424d75ed9c9ef10577552449be2fdb6f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f17b38bf26a2124c7c8ae9695c20abafafd53b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f17b38bf26a2124c7c8ae9695c20abafafd53b9", "html_url": "https://github.com/rust-lang/rust/commit/5f17b38bf26a2124c7c8ae9695c20abafafd53b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f17b38bf26a2124c7c8ae9695c20abafafd53b9/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30c7ea857c5103de9d89f70f014b018afd1cff7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/30c7ea857c5103de9d89f70f014b018afd1cff7e", "html_url": "https://github.com/rust-lang/rust/commit/30c7ea857c5103de9d89f70f014b018afd1cff7e"}, {"sha": "8ef0b86fab63cb548eb640f6fcebd8c5c9e451f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ef0b86fab63cb548eb640f6fcebd8c5c9e451f0", "html_url": "https://github.com/rust-lang/rust/commit/8ef0b86fab63cb548eb640f6fcebd8c5c9e451f0"}], "stats": {"total": 217, "additions": 170, "deletions": 47}, "files": [{"sha": "83ff6daa9f586589597bc78332c29a18b4ad1b52", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f17b38bf26a2124c7c8ae9695c20abafafd53b9/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f17b38bf26a2124c7c8ae9695c20abafafd53b9/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=5f17b38bf26a2124c7c8ae9695c20abafafd53b9", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 97 lints included in this crate:\n+There are 98 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -30,6 +30,7 @@ name\n [duplicate_underscore_argument](https://github.com/Manishearth/rust-clippy/wiki#duplicate_underscore_argument) | warn    | Function arguments having names which only differ by an underscore\n [empty_loop](https://github.com/Manishearth/rust-clippy/wiki#empty_loop)                                       | warn    | empty `loop {}` detected\n [eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                                 | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n+[expl_impl_clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#expl_impl_clone_on_copy)             | warn    | implementing `Clone` explicitly on `Copy` types\n [explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)                 | warn    | for-looping with an explicit counter when `_.enumerate()` would do\n [explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)                       | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n [filter_next](https://github.com/Manishearth/rust-clippy/wiki#filter_next)                                     | warn    | using `filter(p).next()`, which is more succinctly expressed as `.find(p)`"}, {"sha": "b1c0bde40a2e7e87038d115c63f322765b74ceb1", "filename": "src/derive.rs", "status": "modified", "additions": 124, "deletions": 43, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/5f17b38bf26a2124c7c8ae9695c20abafafd53b9/src%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f17b38bf26a2124c7c8ae9695c20abafafd53b9/src%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fderive.rs?ref=5f17b38bf26a2124c7c8ae9695c20abafafd53b9", "patch": "@@ -1,13 +1,15 @@\n use rustc::lint::*;\n+use rustc::middle::ty::fast_reject::simplify_type;\n+use rustc::middle::ty;\n use rustc_front::hir::*;\n use syntax::ast::{Attribute, MetaItem_};\n+use syntax::codemap::Span;\n+use utils::{CLONE_TRAIT_PATH, HASH_PATH};\n use utils::{match_path, span_lint_and_then};\n-use utils::HASH_PATH;\n-\n-use rustc::middle::ty::fast_reject::simplify_type;\n+use rustc::middle::ty::TypeVariants;\n \n /// **What it does:** This lint warns about deriving `Hash` but implementing `PartialEq`\n-/// explicitely.\n+/// explicitly.\n ///\n /// **Why is this bad?** The implementation of these traits must agree (for example for use with\n /// `HashMap`) so it\u2019s probably a bad idea to use a default-generated `Hash` implementation  with\n@@ -33,66 +35,145 @@ declare_lint! {\n     \"deriving `Hash` but implementing `PartialEq` explicitly\"\n }\n \n+/// **What it does:** This lint warns about explicit `Clone` implementation for `Copy` types.\n+///\n+/// **Why is this bad?** To avoid surprising behaviour, these traits should agree and the behaviour\n+/// of `Copy` cannot be overridden. In almost all situations a `Copy` type should have a `Clone`\n+/// implementation that does nothing more than copy the object, which is what\n+/// `#[derive(Copy, Clone)]` gets you.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// #[derive(Copy)]\n+/// struct Foo;\n+///\n+/// impl Clone for Foo {\n+///     ..\n+/// }\n+declare_lint! {\n+    pub EXPL_IMPL_CLONE_ON_COPY,\n+    Warn,\n+    \"implementing `Clone` explicitly on `Copy` types\"\n+}\n+\n pub struct Derive;\n \n impl LintPass for Derive {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(DERIVE_HASH_NOT_EQ)\n+        lint_array!(EXPL_IMPL_CLONE_ON_COPY, DERIVE_HASH_NOT_EQ)\n     }\n }\n \n impl LateLintPass for Derive {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        /// A `#[derive]`d implementation has a `#[automatically_derived]` attribute.\n-        fn is_automatically_derived(attr: &Attribute) -> bool {\n-            if let MetaItem_::MetaWord(ref word) = attr.node.value.node {\n-                word == &\"automatically_derived\"\n+        let ast_ty_to_ty_cache = cx.tcx.ast_ty_to_ty_cache.borrow();\n+\n+        if_let_chain! {[\n+            let ItemImpl(_, _, _, Some(ref trait_ref), ref ast_ty, _) = item.node,\n+            let Some(&ty) = ast_ty_to_ty_cache.get(&ast_ty.id)\n+        ], {\n+            if item.attrs.iter().any(is_automatically_derived) {\n+                check_hash_peq(cx, item.span, trait_ref, ty);\n             }\n             else {\n-                false\n+                check_copy_clone(cx, item.span, trait_ref, ty);\n             }\n-        }\n+        }}\n+    }\n+}\n \n-        // If `item` is an automatically derived `Hash` implementation\n+/// Implementation of the `DERIVE_HASH_NOT_EQ` lint.\n+fn check_hash_peq(cx: &LateContext, span: Span, trait_ref: &TraitRef, ty: ty::Ty) {\n+    // If `item` is an automatically derived `Hash` implementation\n+    if_let_chain! {[\n+        match_path(&trait_ref.path, &HASH_PATH),\n+        let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n+    ], {\n+        let peq_trait_def = cx.tcx.lookup_trait_def(peq_trait_def_id);\n+\n+        cx.tcx.populate_implementations_for_trait_if_necessary(peq_trait_def.trait_ref.def_id);\n+        let peq_impls = peq_trait_def.borrow_impl_lists(cx.tcx).1;\n+\n+        // Look for the PartialEq implementations for `ty`\n         if_let_chain! {[\n-            let ItemImpl(_, _, _, Some(ref trait_ref), ref ast_ty, _) = item.node,\n-            match_path(&trait_ref.path, &HASH_PATH),\n-            item.attrs.iter().any(is_automatically_derived),\n-            let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n+            let Some(simpl_ty) = simplify_type(cx.tcx, ty, false),\n+            let Some(impl_ids) = peq_impls.get(&simpl_ty)\n         ], {\n-            let peq_trait_def = cx.tcx.lookup_trait_def(peq_trait_def_id);\n+            for &impl_id in impl_ids {\n+                let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n \n-            cx.tcx.populate_implementations_for_trait_if_necessary(peq_trait_def.trait_ref.def_id);\n-            let peq_impls = peq_trait_def.borrow_impl_lists(cx.tcx).1;\n-            let ast_ty_to_ty_cache = cx.tcx.ast_ty_to_ty_cache.borrow();\n+                // Only care about `impl PartialEq<Foo> for Foo`\n+                if trait_ref.input_types()[0] == ty &&\n+                  !cx.tcx.get_attrs(impl_id).iter().any(is_automatically_derived) {\n+                    span_lint_and_then(\n+                        cx, DERIVE_HASH_NOT_EQ, span,\n+                        \"you are deriving `Hash` but have implemented `PartialEq` explicitly\",\n+                        |db| {\n+                        if let Some(node_id) = cx.tcx.map.as_local_node_id(impl_id) {\n+                            db.span_note(\n+                                cx.tcx.map.span(node_id),\n+                                \"`PartialEq` implemented here\"\n+                            );\n+                        }\n+                    });\n+                }\n+            }\n+        }}\n+    }}\n+}\n \n+/// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n+fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n+    if match_path(&trait_ref.path, &CLONE_TRAIT_PATH) {\n+        let parameter_environment = cx.tcx.empty_parameter_environment();\n \n-            // Look for the PartialEq implementations for `ty`\n-            if_let_chain! {[\n-                let Some(ty) = ast_ty_to_ty_cache.get(&ast_ty.id),\n-                let Some(simpl_ty) = simplify_type(cx.tcx, ty, false),\n-                let Some(impl_ids) = peq_impls.get(&simpl_ty)\n-            ], {\n-                for &impl_id in impl_ids {\n-                    let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n+        if ty.moves_by_default(&parameter_environment, span) {\n+            return; // ty is not Copy\n+        }\n \n-                    // Only care about `impl PartialEq<Foo> for Foo`\n-                    if trait_ref.input_types()[0] == *ty &&\n-                      !cx.tcx.get_attrs(impl_id).iter().any(is_automatically_derived) {\n-                        span_lint_and_then(\n-                            cx, DERIVE_HASH_NOT_EQ, item.span,\n-                            &format!(\"you are deriving `Hash` but have implemented \\\n-                                      `PartialEq` explicitely\"), |db| {\n-                            if let Some(node_id) = cx.tcx.map.as_local_node_id(impl_id) {\n-                                db.span_note(\n-                                    cx.tcx.map.span(node_id),\n-                                    \"`PartialEq` implemented here\"\n-                                );\n+        // Some types are not Clone by default but could be cloned `by hand` if necessary\n+        match ty.sty {\n+            TypeVariants::TyEnum(def, substs) | TypeVariants::TyStruct(def, substs) => {\n+                for variant in &def.variants {\n+                    for field in &variant.fields {\n+                        match field.ty(cx.tcx, substs).sty {\n+                            TypeVariants::TyArray(_, size) if size > 32 => {\n+                                return;\n                             }\n-                        });\n+                            TypeVariants::TyBareFn(..) => {\n+                                return;\n+                            }\n+                            TypeVariants::TyTuple(ref tys) if tys.len() > 12 => {\n+                                return;\n+                            }\n+                            _ => (),\n+                        }\n                     }\n                 }\n-            }}\n-        }}\n+            }\n+            _ => (),\n+        }\n+\n+        span_lint_and_then(\n+            cx, DERIVE_HASH_NOT_EQ, span,\n+            \"you are implementing `Clone` explicitly on a `Copy` type\",\n+            |db| {\n+                db.span_note(\n+                    span,\n+                    \"consider deriving `Clone` or removing `Copy`\"\n+                );\n+        });\n+    }\n+}\n+\n+/// Checks for the `#[automatically_derived]` attribute all `#[derive]`d implementations have.\n+fn is_automatically_derived(attr: &Attribute) -> bool {\n+    if let MetaItem_::MetaWord(ref word) = attr.node.value.node {\n+        word == &\"automatically_derived\"\n+    }\n+    else {\n+        false\n     }\n }"}, {"sha": "c43c01268fea7a12f438817cde1e0a8e5f9e1983", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f17b38bf26a2124c7c8ae9695c20abafafd53b9/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f17b38bf26a2124c7c8ae9695c20abafafd53b9/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5f17b38bf26a2124c7c8ae9695c20abafafd53b9", "patch": "@@ -173,6 +173,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         collapsible_if::COLLAPSIBLE_IF,\n         cyclomatic_complexity::CYCLOMATIC_COMPLEXITY,\n         derive::DERIVE_HASH_NOT_EQ,\n+        derive::EXPL_IMPL_CLONE_ON_COPY,\n         entry::MAP_ENTRY,\n         eq_op::EQ_OP,\n         escape::BOXED_LOCAL,"}, {"sha": "139e94dbc912788b44f4afe355729565b707d6bf", "filename": "src/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f17b38bf26a2124c7c8ae9695c20abafafd53b9/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f17b38bf26a2124c7c8ae9695c20abafafd53b9/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=5f17b38bf26a2124c7c8ae9695c20abafafd53b9", "patch": "@@ -22,7 +22,8 @@ pub type MethodArgs = HirVec<P<Expr>>;\n pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n pub const BTREEMAP_ENTRY_PATH: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"Entry\"];\n pub const BTREEMAP_PATH: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n-pub const CLONE_PATH: [&'static str; 2] = [\"Clone\", \"clone\"];\n+pub const CLONE_PATH: [&'static str; 3] = [\"clone\", \"Clone\", \"clone\"];\n+pub const CLONE_TRAIT_PATH: [&'static str; 2] = [\"clone\", \"Clone\"];\n pub const COW_PATH: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n pub const DEFAULT_TRAIT_PATH: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n pub const HASHMAP_ENTRY_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];"}, {"sha": "66b04a66d0fc0ffaf6d26c657ab840e8ca893f1b", "filename": "tests/compile-fail/derive.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5f17b38bf26a2124c7c8ae9695c20abafafd53b9/tests%2Fcompile-fail%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f17b38bf26a2124c7c8ae9695c20abafafd53b9/tests%2Fcompile-fail%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fderive.rs?ref=5f17b38bf26a2124c7c8ae9695c20abafafd53b9", "patch": "@@ -2,6 +2,7 @@\n #![plugin(clippy)]\n \n #![deny(warnings)]\n+#![allow(dead_code)]\n \n #[derive(PartialEq, Hash)]\n struct Foo;\n@@ -11,19 +12,57 @@ impl PartialEq<u64> for Foo {\n }\n \n #[derive(Hash)]\n-//~^ ERROR you are deriving `Hash` but have implemented `PartialEq` explicitely\n+//~^ ERROR you are deriving `Hash` but have implemented `PartialEq` explicitly\n struct Bar;\n \n impl PartialEq for Bar {\n     fn eq(&self, _: &Bar) -> bool { true }\n }\n \n #[derive(Hash)]\n-//~^ ERROR you are deriving `Hash` but have implemented `PartialEq` explicitely\n+//~^ ERROR you are deriving `Hash` but have implemented `PartialEq` explicitly\n struct Baz;\n \n impl PartialEq<Baz> for Baz {\n     fn eq(&self, _: &Baz) -> bool { true }\n }\n \n+#[derive(Copy)]\n+struct Qux;\n+\n+impl Clone for Qux {\n+//~^ ERROR you are implementing `Clone` explicitly on a `Copy` type\n+    fn clone(&self) -> Self { Qux }\n+}\n+\n+// Ok, `Clone` cannot be derived because of the big array\n+#[derive(Copy)]\n+struct BigArray {\n+    a: [u8; 65],\n+}\n+\n+impl Clone for BigArray {\n+    fn clone(&self) -> Self { unimplemented!() }\n+}\n+\n+// Ok, function pointers are not always Clone\n+#[derive(Copy)]\n+struct FnPtr {\n+    a: fn() -> !,\n+}\n+\n+impl Clone for FnPtr {\n+    fn clone(&self) -> Self { unimplemented!() }\n+}\n+\n+// Ok, generics\n+#[derive(Copy)]\n+struct Generic<T> {\n+    a: T,\n+}\n+\n+impl<T> Clone for Generic<T> {\n+    fn clone(&self) -> Self { unimplemented!() }\n+}\n+\n fn main() {}"}]}