{"sha": "d4b78b36abe896556ba04785610148b51aa67572", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0Yjc4YjM2YWJlODk2NTU2YmEwNDc4NTYxMDE0OGI1MWFhNjc1NzI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-17T13:15:53Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-17T13:15:53Z"}, "message": "stacked borrows: enforcement at memory accesses", "tree": {"sha": "038af28c415ccf4b77c807a27680ad8ddb374142", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/038af28c415ccf4b77c807a27680ad8ddb374142"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4b78b36abe896556ba04785610148b51aa67572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4b78b36abe896556ba04785610148b51aa67572", "html_url": "https://github.com/rust-lang/rust/commit/d4b78b36abe896556ba04785610148b51aa67572", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4b78b36abe896556ba04785610148b51aa67572/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6", "html_url": "https://github.com/rust-lang/rust/commit/66b4bb7cf2e7136ca0a31d04a2abe1754e89a5b6"}], "stats": {"total": 354, "additions": 259, "deletions": 95}, "files": [{"sha": "eb889c1d495acc7d2f913491fc0812e68b814162", "filename": "src/fn_call.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d4b78b36abe896556ba04785610148b51aa67572/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b78b36abe896556ba04785610148b51aa67572/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=d4b78b36abe896556ba04785610148b51aa67572", "patch": "@@ -118,6 +118,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             None => self.tcx.item_name(def_id).as_str(),\n         };\n \n+        // All these functions take raw pointers, so if we access memory directly\n+        // (as opposed to through a place), we have to remember to erase any tag\n+        // that might still hang around!\n+\n         match &link_name[..] {\n             \"malloc\" => {\n                 let size = self.read_scalar(args[0])?.to_usize(&self)?;\n@@ -131,10 +135,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n \n             \"free\" => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation, no tag\n                 if !ptr.is_null() {\n                     self.memory.deallocate(\n-                        ptr.to_ptr()?,\n+                        ptr.to_ptr()?.with_default_tag(),\n                         None,\n                         MiriMemoryKind::C.into(),\n                     )?;\n@@ -171,7 +175,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_dealloc\" => {\n-                let ptr = self.read_scalar(args[0])?.to_ptr()?;\n+                let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation, no tag\n                 let old_size = self.read_scalar(args[1])?.to_usize(&self)?;\n                 let align = self.read_scalar(args[2])?.to_usize(&self)?;\n                 if old_size == 0 {\n@@ -181,13 +185,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 self.memory.deallocate(\n-                    ptr,\n+                    ptr.with_default_tag(),\n                     Some((Size::from_bytes(old_size), Align::from_bytes(align, align).unwrap())),\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n             }\n             \"__rust_realloc\" => {\n-                let ptr = self.read_scalar(args[0])?.to_ptr()?;\n+                let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation, no tag\n                 let old_size = self.read_scalar(args[1])?.to_usize(&self)?;\n                 let align = self.read_scalar(args[2])?.to_usize(&self)?;\n                 let new_size = self.read_scalar(args[3])?.to_usize(&self)?;\n@@ -198,7 +202,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let new_ptr = self.memory.reallocate(\n-                    ptr,\n+                    ptr.with_default_tag(),\n                     Size::from_bytes(old_size),\n                     Align::from_bytes(align, align).unwrap(),\n                     Size::from_bytes(new_size),\n@@ -230,8 +234,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             \"dlsym\" => {\n                 let _handle = self.read_scalar(args[0])?;\n-                let symbol = self.read_scalar(args[1])?.to_ptr()?;\n-                let symbol_name = self.memory.read_c_str(symbol)?;\n+                let symbol = self.read_scalar(args[1])?.to_ptr()?.erase_tag();\n+                let symbol_name = self.memory.read_c_str(symbol.with_default_tag())?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n                 return err!(Unimplemented(format!(\n@@ -284,13 +288,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 return err!(MachineError(\"the evaluated program panicked\".to_string())),\n \n             \"memcmp\" => {\n-                let left = self.read_scalar(args[0])?.not_undef()?;\n-                let right = self.read_scalar(args[1])?.not_undef()?;\n+                let left = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n+                let right = self.read_scalar(args[1])?.not_undef()?.erase_tag(); // raw ptr operation\n                 let n = Size::from_bytes(self.read_scalar(args[2])?.to_usize(&self)?);\n \n                 let result = {\n-                    let left_bytes = self.memory.read_bytes(left, n)?;\n-                    let right_bytes = self.memory.read_bytes(right, n)?;\n+                    let left_bytes = self.memory.read_bytes(left.with_default_tag(), n)?;\n+                    let right_bytes = self.memory.read_bytes(right.with_default_tag(), n)?;\n \n                     use std::cmp::Ordering::*;\n                     match left_bytes.cmp(right_bytes) {\n@@ -307,12 +311,12 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n \n             \"memrchr\" => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n+                let ptr = ptr.with_default_tag();\n                 let val = self.read_scalar(args[1])?.to_bytes()? as u8;\n                 let num = self.read_scalar(args[2])?.to_usize(&self)?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().rev().position(\n-                    |&c| c == val,\n-                )\n+                if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?\n+                    .iter().rev().position(|&c| c == val)\n                 {\n                     let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), &self)?;\n                     self.write_scalar(new_ptr, dest)?;\n@@ -322,7 +326,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n \n             \"memchr\" => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n+                let ptr = ptr.with_default_tag();\n                 let val = self.read_scalar(args[1])?.to_bytes()? as u8;\n                 let num = self.read_scalar(args[2])?.to_usize(&self)?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n@@ -338,8 +343,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             \"getenv\" => {\n                 let result = {\n-                    let name_ptr = self.read_scalar(args[0])?.to_ptr()?;\n-                    let name = self.memory.read_c_str(name_ptr)?;\n+                    let name_ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation\n+                    let name = self.memory.read_c_str(name_ptr.with_default_tag())?;\n                     match self.machine.env_vars.get(name) {\n                         Some(&var) => Scalar::Ptr(var),\n                         None => Scalar::ptr_null(*self.tcx),\n@@ -351,9 +356,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"unsetenv\" => {\n                 let mut success = None;\n                 {\n-                    let name_ptr = self.read_scalar(args[0])?.not_undef()?;\n+                    let name_ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n                     if !name_ptr.is_null() {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n+                        let name = self.memory.read_c_str(name_ptr.to_ptr()?.with_default_tag())?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             success = Some(self.machine.env_vars.remove(name));\n                         }\n@@ -372,11 +377,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"setenv\" => {\n                 let mut new = None;\n                 {\n-                    let name_ptr = self.read_scalar(args[0])?.not_undef()?;\n-                    let value_ptr = self.read_scalar(args[1])?.to_ptr()?;\n-                    let value = self.memory.read_c_str(value_ptr)?;\n+                    let name_ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n+                    let value_ptr = self.read_scalar(args[1])?.to_ptr()?.erase_tag(); // raw ptr operation\n+                    let value = self.memory.read_c_str(value_ptr.with_default_tag())?;\n                     if !name_ptr.is_null() {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n+                        let name = self.memory.read_c_str(name_ptr.to_ptr()?.with_default_tag())?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             new = Some((name.to_owned(), value.to_owned()));\n                         }\n@@ -407,14 +412,14 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             \"write\" => {\n                 let fd = self.read_scalar(args[0])?.to_bytes()?;\n-                let buf = self.read_scalar(args[1])?.not_undef()?;\n+                let buf = self.read_scalar(args[1])?.not_undef()?.erase_tag();\n                 let n = self.read_scalar(args[2])?.to_bytes()? as u64;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 {\n                     // stdout/stderr\n                     use std::io::{self, Write};\n \n-                    let buf_cont = self.memory.read_bytes(buf, Size::from_bytes(n))?;\n+                    let buf_cont = self.memory.read_bytes(buf.with_default_tag(), Size::from_bytes(n))?;\n                     let res = if fd == 1 {\n                         io::stdout().write(buf_cont)\n                     } else {\n@@ -435,8 +440,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n \n             \"strlen\" => {\n-                let ptr = self.read_scalar(args[0])?.to_ptr()?;\n-                let n = self.memory.read_c_str(ptr)?.len();\n+                let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag();\n+                let n = self.memory.read_c_str(ptr.with_default_tag())?.len();\n                 self.write_scalar(Scalar::from_uint(n as u64, dest.layout.size), dest)?;\n             }\n \n@@ -482,7 +487,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n-                let key_ptr = self.read_scalar(args[0])?.to_ptr()?;\n+                let key_ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n                 let dtor = match self.read_scalar(args[1])?.not_undef()? {\n@@ -505,7 +510,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     return err!(OutOfTls);\n                 }\n                 self.memory.write_scalar(\n-                    key_ptr,\n+                    key_ptr.with_default_tag(),\n                     key_layout.align,\n                     Scalar::from_uint(key, key_layout.size).into(),\n                     key_layout.size,"}, {"sha": "2b02f22a382b07de04e542525dc4bc5bc1b3fc80", "filename": "src/intrinsic.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4b78b36abe896556ba04785610148b51aa67572/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b78b36abe896556ba04785610148b51aa67572/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=d4b78b36abe896556ba04785610148b51aa67572", "patch": "@@ -31,6 +31,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n \n         let substs = instance.substs;\n \n+        // All these intrinsics take raw pointers, so if we access memory directly\n+        // (as opposed to through a place), we have to remember to erase any tag\n+        // that might still hang around!\n+\n         let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n             \"arith_offset\" => {\n@@ -146,12 +150,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 let elem_size = elem_layout.size.bytes();\n                 let count = self.read_scalar(args[2])?.to_usize(&self)?;\n                 let elem_align = elem_layout.align;\n-                let src = self.read_scalar(args[0])?.not_undef()?;\n-                let dest = self.read_scalar(args[1])?.not_undef()?;\n+                // erase tags: this is a raw ptr operation\n+                let src = self.read_scalar(args[0])?.not_undef()?.erase_tag();\n+                let dest = self.read_scalar(args[1])?.not_undef()?.erase_tag();\n                 self.memory.copy(\n-                    src,\n+                    src.with_default_tag(),\n                     elem_align,\n-                    dest,\n+                    dest.with_default_tag(),\n                     elem_align,\n                     Size::from_bytes(count * elem_size),\n                     intrinsic_name.ends_with(\"_nonoverlapping\"),\n@@ -428,7 +433,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 let ty = substs.type_at(0);\n                 let ty_layout = self.layout_of(ty)?;\n                 let val_byte = self.read_scalar(args[1])?.to_u8()?;\n-                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag().with_default_tag();\n                 let count = self.read_scalar(args[2])?.to_usize(&self)?;\n                 self.memory.check_align(ptr, ty_layout.align)?;\n                 self.memory.write_repeat(ptr, val_byte, ty_layout.size * count)?;"}, {"sha": "c910911f5762bd649324ebd833a86e297b22e475", "filename": "src/lib.rs", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d4b78b36abe896556ba04785610148b51aa67572/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b78b36abe896556ba04785610148b51aa67572/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d4b78b36abe896556ba04785610148b51aa67572", "patch": "@@ -415,14 +415,48 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         Cow::Owned(alloc)\n     }\n \n+    #[inline(always)]\n+    fn memory_accessed(\n+        alloc: &Allocation<Borrow, Self::AllocExtra>,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+        access: MemoryAccess,\n+    ) -> EvalResult<'tcx> {\n+        alloc.extra.memory_accessed(ptr, size, access)\n+    }\n+\n+    #[inline(always)]\n+    fn memory_deallocated(\n+        alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n+        ptr: Pointer<Borrow>,\n+    ) -> EvalResult<'tcx> {\n+        alloc.extra.memory_deallocated(ptr)\n+    }\n+\n+    /*/// Hook for when a reference is cast to a raw pointer\n+    #[inline(always)]\n+    fn ref_to_raw_cast(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer<Borrow>,\n+        ptr_ty: Ty<'tcx>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        if !ecx.machine.validate {\n+            // No tracking.\n+            Ok(())\n+        } else {\n+            ecx.ref_to_raw_cast(ptr, ptr_ty, size)\n+        }\n+    }*/\n+\n     #[inline(always)]\n     fn tag_reference(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer<Self::PointerTag>,\n+        ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         pointee_size: Size,\n-        borrow_kind: mir::BorrowKind,\n-    ) -> EvalResult<'tcx, Self::PointerTag> {\n+        borrow_kind: Option<mir::BorrowKind>,\n+    ) -> EvalResult<'tcx, Borrow> {\n         if !ecx.machine.validate {\n             // No tracking\n             Ok(Borrow::default())\n@@ -434,9 +468,9 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     #[inline(always)]\n     fn tag_dereference(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer<Self::PointerTag>,\n+        ptr: Pointer<Borrow>,\n         ptr_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Self::PointerTag> {\n+    ) -> EvalResult<'tcx, Borrow> {\n         if !ecx.machine.validate {\n             // No tracking\n             Ok(Borrow::default())"}, {"sha": "74a49bf83b8198310c3ab6b8043d8bb9d8885ed2", "filename": "src/range_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4b78b36abe896556ba04785610148b51aa67572/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b78b36abe896556ba04785610148b51aa67572/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=d4b78b36abe896556ba04785610148b51aa67572", "patch": "@@ -99,6 +99,10 @@ impl<T> RangeMap<T> {\n         self.iter_with_range(offset.bytes(), len.bytes()).map(|(_, data)| data)\n     }\n \n+    pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n+        self.map.values_mut()\n+    }\n+\n     fn split_entry_at(&mut self, offset: u64)\n     where\n         T: Clone,"}, {"sha": "e4d2289bf34c78e3141aa769a661592ed293337d", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 113, "deletions": 52, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/d4b78b36abe896556ba04785610148b51aa67572/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b78b36abe896556ba04785610148b51aa67572/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=d4b78b36abe896556ba04785610148b51aa67572", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::{Ty, layout::Size};\n use rustc::mir;\n \n use super::{\n-    RangeMap, EvalResult,\n+    MemoryAccess, RangeMap, EvalResult,\n     Pointer,\n };\n \n@@ -13,10 +13,10 @@ pub type Timestamp = u64;\n /// Information about a potentially mutable borrow\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Mut {\n-  /// A unique, mutable reference\n-  Uniq(Timestamp),\n-  /// Any raw pointer, or a shared borrow with interior mutability\n-  Raw,\n+    /// A unique, mutable reference\n+    Uniq(Timestamp),\n+    /// Any raw pointer, or a shared borrow with interior mutability\n+    Raw,\n }\n \n impl Mut {\n@@ -27,34 +27,18 @@ impl Mut {\n             _ => false,\n         }\n     }\n-\n-    #[inline(always)]\n-    fn is_uniq(self) -> bool {\n-        match self {\n-            Mut::Uniq(_) => true,\n-            _ => false,\n-        }\n-    }\n }\n \n /// Information about any kind of borrow\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Borrow {\n-  /// A mutable borrow, a raw pointer, or a shared borrow with interior mutability\n-  Mut(Mut),\n-  /// A shared borrow without interior mutability\n-  Frz(Timestamp)\n+    /// A mutable borrow, a raw pointer, or a shared borrow with interior mutability\n+    Mut(Mut),\n+    /// A shared borrow without interior mutability\n+    Frz(Timestamp)\n }\n \n impl Borrow {\n-    #[inline(always)]\n-    fn is_mut(self) -> bool {\n-        match self {\n-            Borrow::Mut(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n     #[inline(always)]\n     fn is_uniq(self) -> bool {\n         match self {\n@@ -67,10 +51,11 @@ impl Borrow {\n /// An item in the borrow stack\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum BorStackItem {\n-  /// Defines which references are permitted to mutate *if* the location is not frozen\n-  Mut(Mut),\n-  /// A barrier, tracking the function it belongs to by its index on the call stack\n-  FnBarrier(usize)\n+    /// Defines which references are permitted to mutate *if* the location is not frozen\n+    Mut(Mut),\n+    /// A barrier, tracking the function it belongs to by its index on the call stack\n+    #[allow(dead_code)] // for future use\n+    FnBarrier(usize)\n }\n \n impl Default for Borrow {\n@@ -133,15 +118,19 @@ impl<'tcx> Stack {\n     /// Reactive `bor` for this stack.  If `force_mut` is set, we want to aggressively\n     /// unfreeze this location (because we are about to push a `Uniq`).\n     fn reactivate(&mut self, bor: Borrow, force_mut: bool) -> EvalResult<'tcx> {\n-        assert!(!force_mut || bor.is_mut()); // if `force_mut` is set, this must be a mutable borrow\n-        // Do NOT change anything if `bor` is already active -- in particular, if\n-        // it is a `Mut(Raw)` and we are frozen.\n+        // Unless mutation is bound to happen, do NOT change anything if `bor` is already active.\n+        // In particular, if it is a `Mut(Raw)` and we are frozen, this should be a NOP.\n         if !force_mut && self.check(bor) {\n             return Ok(());\n         }\n \n         let acc_m = match bor {\n-            Borrow::Frz(_) => return err!(MachineError(format!(\"Location should be frozen but it is not\"))),\n+            Borrow::Frz(_) =>\n+                if force_mut {\n+                    return err!(MachineError(format!(\"Using a shared borrow for mutation\")))\n+                } else {\n+                    return err!(MachineError(format!(\"Location should be frozen but it is not\")))\n+                }\n             Borrow::Mut(acc_m) => acc_m,\n         };\n         // We definitely have to unfreeze this, even if we use the topmost item.\n@@ -154,6 +143,7 @@ impl<'tcx> Stack {\n                 }\n                 BorStackItem::Mut(loc_m) => {\n                     if loc_m == acc_m { return Ok(()); }\n+                    trace!(\"reactivate: Popping {:?}\", itm);\n                     self.borrows.pop();\n                 }\n             }\n@@ -169,12 +159,14 @@ impl<'tcx> Stack {\n     fn initiate(&mut self, bor: Borrow) -> EvalResult<'tcx> {\n         match bor {\n             Borrow::Frz(t) => {\n+                trace!(\"initiate: Freezing\");\n                 match self.frozen_since {\n                     None => self.frozen_since = Some(t),\n                     Some(since) => assert!(since <= t),\n                 }\n             }\n             Borrow::Mut(m) => {\n+                trace!(\"initiate: Pushing {:?}\", bor);\n                 match self.frozen_since {\n                     None => self.borrows.push(BorStackItem::Mut(m)),\n                     Some(_) =>\n@@ -194,21 +186,80 @@ impl State {\n     }\n }\n \n+/// Higher-level operations\n+impl<'tcx> Stacks {\n+    pub fn memory_accessed(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+        access: MemoryAccess,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"memory_accessed({:?}) with tag {:?}: {:?}, size {}\", access, ptr.tag, ptr, size.bytes());\n+        let mut stacks = self.stacks.borrow_mut();\n+        for stack in stacks.iter_mut(ptr.offset, size) {\n+            // FIXME: Compare this with what the blog post says.\n+            stack.reactivate(ptr.tag, /*force_mut*/access == MemoryAccess::Write)?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn memory_deallocated(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"memory_deallocated with tag {:?}: {:?}\", ptr.tag, ptr);\n+        let stacks = self.stacks.get_mut();\n+        for stack in stacks.iter_mut_all() {\n+            // This is like mutating.\n+            stack.reactivate(ptr.tag, /*force_mut*/true)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn reborrow(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+        new_bor: Borrow,\n+    ) -> EvalResult<'tcx> {\n+        let mut stacks = self.stacks.borrow_mut();\n+        for stack in stacks.iter_mut(ptr.offset, size) {\n+            if stack.check(new_bor) {\n+                // The new borrow is already active!  This can happen when creating multiple\n+                // shared references from the same mutable reference.  Do nothing.\n+            } else {\n+                // FIXME: The blog post says we should `reset` if this is a local.\n+                stack.reactivate(ptr.tag, /*force_mut*/new_bor.is_uniq())?;\n+                stack.initiate(new_bor)?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n /// Machine hooks\n pub trait EvalContextExt<'tcx> {\n     fn tag_reference(\n         &mut self,\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        borrow_kind: mir::BorrowKind,\n+        borrow_kind: Option<mir::BorrowKind>,\n     ) -> EvalResult<'tcx, Borrow>;\n \n     fn tag_dereference(\n         &self,\n         ptr: Pointer<Borrow>,\n         ptr_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Borrow>;\n+\n+    fn ref_to_raw_cast(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n+        ptr_ty: Ty<'tcx>,\n+        size: Size,\n+    ) -> EvalResult<'tcx>;\n }\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n@@ -217,40 +268,31 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        borrow_kind: mir::BorrowKind,\n+        borrow_kind: Option<mir::BorrowKind>,\n     ) -> EvalResult<'tcx, Borrow> {\n-        let old_bor = ptr.tag;\n         let time = self.machine.stacked_borrows.increment_clock();\n-        // FIXME This does not do enough checking when only part of the data lacks\n+        // FIXME This does not do enough checking when only part of the data has\n         // interior mutability.\n         let new_bor = match borrow_kind {\n-            mir::BorrowKind::Mut { .. } => Borrow::Mut(Mut::Uniq(time)),\n-            _ =>\n+            Some(mir::BorrowKind::Mut { .. }) => Borrow::Mut(Mut::Uniq(time)),\n+            Some(_) =>\n                 if self.type_is_freeze(pointee_ty) {\n                     Borrow::Frz(time)\n                 } else {\n                     Borrow::Mut(Mut::Raw)\n-                }\n+                },\n+            None => Borrow::Mut(Mut::Raw),\n         };\n-        trace!(\"tag_reference: Creating new tag for {:?} (pointee {}, size {}): {:?}\", ptr, pointee_ty, size.bytes(), new_bor);\n+        trace!(\"tag_reference: Creating new reference ({:?}) for {:?} (pointee {}, size {}): {:?}\",\n+            borrow_kind, ptr, pointee_ty, size.bytes(), new_bor);\n \n         // Make sure this reference is not dangling or so\n         self.memory.check_bounds(ptr, size, false)?;\n \n         // Update the stacks.  We cannot use `get_mut` becuse this might be immutable\n         // memory.\n         let alloc = self.memory.get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        let mut stacks = alloc.extra.stacks.borrow_mut();\n-        for stack in stacks.iter_mut(ptr.offset, size) {\n-            if stack.check(new_bor) {\n-                // The new borrow is already active!  This can happen when creating multiple\n-                // shared references from the same mutable reference.  Do nothing.\n-            } else {\n-                // FIXME: The blog post says we should `reset` if this is a local.\n-                stack.reactivate(old_bor, /*force_mut*/new_bor.is_uniq())?;\n-                stack.initiate(new_bor)?;\n-            }\n-        }\n+        alloc.extra.reborrow(ptr, size, new_bor)?;\n \n         Ok(new_bor)\n     }\n@@ -269,4 +311,23 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             ptr.tag\n         })\n     }\n+\n+    fn ref_to_raw_cast(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n+        _ptr_ty: Ty<'tcx>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"ref_to_raw_cast: Escaping {:?}\", ptr);\n+\n+        // Make sure this reference is not dangling or so\n+        self.memory.check_bounds(ptr, size, false)?;\n+\n+        // Update the stacks.  We cannot use `get_mut` becuse this might be immutable\n+        // memory.\n+        let alloc = self.memory.get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        alloc.extra.reborrow(ptr, size, Borrow::Mut(Mut::Raw))?;\n+\n+        Ok(())\n+    }\n }"}, {"sha": "4fbbb270957b39d6ee71ee70e18d64078d661c8c", "filename": "tests/run-pass/raw.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d4b78b36abe896556ba04785610148b51aa67572/tests%2Frun-pass%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b78b36abe896556ba04785610148b51aa67572/tests%2Frun-pass%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fraw.rs?ref=d4b78b36abe896556ba04785610148b51aa67572", "patch": "@@ -0,0 +1,21 @@\n+fn basic_raw() {\n+    let mut x = 12;\n+    let x = &mut x;\n+\n+    assert_eq!(*x, 12);\n+\n+    let raw = x as *mut i32;\n+    unsafe { *raw = 42; }\n+\n+    assert_eq!(*x, 42);\n+\n+    let raw = x as *mut i32;\n+    unsafe { *raw = 12; }\n+    *x = 23;\n+\n+    assert_eq!(*x, 23);\n+}\n+\n+fn main() {\n+    basic_raw();\n+}"}, {"sha": "93cef1572a3e13d5c88b4e1315ecfe0357c2ec7e", "filename": "tests/run-pass/refcell.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d4b78b36abe896556ba04785610148b51aa67572/tests%2Frun-pass%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b78b36abe896556ba04785610148b51aa67572/tests%2Frun-pass%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frefcell.rs?ref=d4b78b36abe896556ba04785610148b51aa67572", "patch": "@@ -0,0 +1,33 @@\n+use std::cell::RefCell;\n+\n+fn main() {\n+    let c = RefCell::new(42);\n+    {\n+        let s1 = c.borrow();\n+        let _x: i32 = *s1;\n+        let s2 = c.borrow();\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+    }\n+    {\n+        let mut m = c.borrow_mut();\n+        let _z: i32 = *m;\n+        {\n+            let s: &i32 = &*m;\n+            let _x = *s;\n+        }\n+        *m = 23;\n+        let _z: i32 = *m;\n+    }\n+    {\n+        let s1 = c.borrow();\n+        let _x: i32 = *s1;\n+        let s2 = c.borrow();\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+    }\n+}"}, {"sha": "7ff967b29f344e591c4afeec638287206a835ec3", "filename": "tests/run-pass/std.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4b78b36abe896556ba04785610148b51aa67572/tests%2Frun-pass%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b78b36abe896556ba04785610148b51aa67572/tests%2Frun-pass%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstd.rs?ref=d4b78b36abe896556ba04785610148b51aa67572", "patch": "@@ -12,8 +12,9 @@ fn rc_cell() -> Rc<Cell<i32>> {\n fn rc_refcell() -> i32 {\n     let r = Rc::new(RefCell::new(42));\n     *r.borrow_mut() += 10;\n-    let x = *r.borrow();\n-    x\n+    let x = r.borrow();\n+    let y = r.borrow();\n+    (*x + *y)/2\n }\n \n fn arc() -> Arc<i32> {"}]}