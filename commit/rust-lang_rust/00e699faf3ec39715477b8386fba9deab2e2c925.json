{"sha": "00e699faf3ec39715477b8386fba9deab2e2c925", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZTY5OWZhZjNlYzM5NzE1NDc3YjgzODZmYmE5ZGVhYjJlMmM5MjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-15T00:25:00Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-17T19:21:45Z"}, "message": "change callback for expr/type to a fn pointer\n\nThe idea is that, this way, we can cleanly isolate ALL state that is\nbeing passed, since it goes as an argument to the fn pointer.", "tree": {"sha": "5e3777b3367f0691cbb23479d434f7e46d70ab50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e3777b3367f0691cbb23479d434f7e46d70ab50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00e699faf3ec39715477b8386fba9deab2e2c925", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00e699faf3ec39715477b8386fba9deab2e2c925", "html_url": "https://github.com/rust-lang/rust/commit/00e699faf3ec39715477b8386fba9deab2e2c925", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00e699faf3ec39715477b8386fba9deab2e2c925/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0c8ab9cd2728de9789ea76d8520b2be92bc1eb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c8ab9cd2728de9789ea76d8520b2be92bc1eb2", "html_url": "https://github.com/rust-lang/rust/commit/c0c8ab9cd2728de9789ea76d8520b2be92bc1eb2"}], "stats": {"total": 124, "additions": 62, "deletions": 62}, "files": [{"sha": "309347a5e5a7a913bcba1ff1d7897c21360378f2", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 57, "deletions": 59, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/00e699faf3ec39715477b8386fba9deab2e2c925/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00e699faf3ec39715477b8386fba9deab2e2c925/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=00e699faf3ec39715477b8386fba9deab2e2c925", "patch": "@@ -205,16 +205,17 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n         let def = ecx.tcx.lookup_adt_def(enum_did);\n         self.encode_fields(enum_did);\n         for (i, variant) in def.variants.iter().enumerate() {\n-            self.record(variant.did, |this| this.encode_enum_variant_info(enum_did, i, vis));\n+            self.record(variant.did,\n+                        ItemContentBuilder::encode_enum_variant_info,\n+                        (enum_did, i, vis));\n         }\n     }\n }\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_enum_variant_info(&mut self,\n-                                enum_did: DefId, // enum def-id\n-                                index: usize, // variant index\n-                                vis: &hir::Visibility) {\n+                                (enum_did, index, vis):\n+                                (DefId, usize, &hir::Visibility)) {\n         let ecx = self.ecx;\n         let def = ecx.tcx.lookup_adt_def(enum_did);\n         let variant = &def.variants[index];\n@@ -293,11 +294,8 @@ fn encode_reexports(ecx: &EncodeContext,\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_mod(&mut self,\n-                           md: &hir::Mod,\n-                           attrs: &[ast::Attribute],\n-                           id: NodeId,\n-                           name: Name,\n-                           vis: &hir::Visibility) {\n+                           (md, attrs, id, name, vis):\n+                           (&hir::Mod, &[ast::Attribute], NodeId, Name, &hir::Visibility)) {\n         let ecx = self.ecx();\n \n         encode_def_id_and_key(ecx, self.rbml_w, ecx.tcx.map.local_def_id(id));\n@@ -418,19 +416,18 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n         let def = self.ecx.tcx.lookup_adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter().enumerate() {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n-                self.record(field.did, |this| this.encode_field(adt_def_id,\n-                                                                variant_index,\n-                                                                field_index));\n+                self.record(field.did,\n+                            ItemContentBuilder::encode_field,\n+                            (adt_def_id, variant_index, field_index));\n             }\n         }\n     }\n }\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_field(&mut self,\n-                    adt_def_id: DefId,\n-                    variant_index: usize,\n-                    field_index: usize) {\n+                    (adt_def_id, variant_index, field_index):\n+                    (DefId, usize, usize)) {\n         let ecx = self.ecx();\n         let def = ecx.tcx.lookup_adt_def(adt_def_id);\n         let variant = &def.variants[variant_index];\n@@ -454,9 +451,8 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_struct_ctor(&mut self,\n-                          struct_def_id: DefId,\n-                          struct_node_id: ast::NodeId,\n-                          ctor_node_id: ast::NodeId) {\n+                          (struct_def_id, struct_node_id, ctor_node_id):\n+                          (DefId, ast::NodeId, ast::NodeId)) {\n         let ecx = self.ecx();\n         let def = ecx.tcx.lookup_adt_def(struct_def_id);\n         let variant = def.struct_variant();\n@@ -532,9 +528,8 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_trait_item(&mut self,\n-                                  trait_def_id: DefId,\n-                                  item_def_id: DefId,\n-                                  trait_item: &hir::TraitItem) {\n+                                  (trait_def_id, item_def_id, trait_item):\n+                                  (DefId, DefId, &hir::TraitItem)) {\n         let ecx = self.ecx;\n         let tcx = ecx.tcx;\n \n@@ -635,9 +630,8 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     }\n \n     fn encode_info_for_impl_item(&mut self,\n-                                 impl_id: NodeId,\n-                                 impl_item_def_id: DefId,\n-                                 ast_item: Option<&hir::ImplItem>) {\n+                                 (impl_id, impl_item_def_id, ast_item):\n+                                 (NodeId, DefId, Option<&hir::ImplItem>)) {\n         match self.ecx.tcx.impl_or_trait_item(impl_item_def_id) {\n             ty::ConstTraitItem(ref associated_const) => {\n                 self.encode_info_for_associated_const(&associated_const,\n@@ -882,8 +876,7 @@ fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_item(&mut self,\n-                            def_id: DefId,\n-                            item: &hir::Item) {\n+                            (def_id, item): (DefId, &hir::Item)) {\n         let ecx = self.ecx();\n         let tcx = ecx.tcx;\n \n@@ -943,11 +936,7 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 self.encode_method_argument_names(&decl);\n             }\n             hir::ItemMod(ref m) => {\n-                self.encode_info_for_mod(m,\n-                                         &item.attrs,\n-                                         item.id,\n-                                         item.name,\n-                                         &item.vis);\n+                self.encode_info_for_mod((m, &item.attrs, item.id, item.name, &item.vis));\n             }\n             hir::ItemForeignMod(ref fm) => {\n                 encode_def_id_and_key(ecx, self.rbml_w, def_id);\n@@ -1210,9 +1199,9 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                 // there is a value for structs like `struct\n                 // Foo()` and `struct Foo`\n                 let ctor_def_id = ecx.tcx.map.local_def_id(struct_node_id);\n-                self.record(ctor_def_id, |this| this.encode_struct_ctor(def_id,\n-                                                                        item.id,\n-                                                                        struct_node_id));\n+                self.record(ctor_def_id,\n+                            ItemContentBuilder::encode_struct_ctor,\n+                            (def_id, item.id, struct_node_id));\n             }\n         }\n     }\n@@ -1238,9 +1227,9 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n             };\n \n             let trait_item_def_id = trait_item_def_id.def_id();\n-            self.record(trait_item_def_id, |this| {\n-                this.encode_info_for_impl_item(impl_id, trait_item_def_id, ast_item)\n-            });\n+            self.record(trait_item_def_id,\n+                        ItemContentBuilder::encode_info_for_impl_item,\n+                        (impl_id, trait_item_def_id, ast_item));\n         }\n     }\n \n@@ -1253,17 +1242,16 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n         for (item_def_id, trait_item) in r.iter().zip(trait_items) {\n             let item_def_id = item_def_id.def_id();\n             assert!(item_def_id.is_local());\n-            self.record(item_def_id, |this| {\n-                this.encode_info_for_trait_item(def_id, item_def_id, trait_item)\n-            });\n+            self.record(item_def_id,\n+                        ItemContentBuilder::encode_info_for_trait_item,\n+                        (def_id, item_def_id, trait_item));\n         }\n     }\n }\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_foreign_item(&mut self,\n-                                    def_id: DefId,\n-                                    nitem: &hir::ForeignItem) {\n+                                    (def_id, nitem): (DefId, &hir::ForeignItem)) {\n         let ecx = self.ecx();\n \n         debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n@@ -1323,14 +1311,18 @@ impl<'a, 'ecx, 'tcx, 'encoder> Visitor<'tcx> for EncodeVisitor<'a, 'ecx, 'tcx, '\n         let def_id = self.index.ecx.tcx.map.local_def_id(item.id);\n         match item.node {\n             hir::ItemExternCrate(_) | hir::ItemUse(_) => (), // ignore these\n-            _ => self.index.record(def_id, |index| index.encode_info_for_item(def_id, item)),\n+            _ => self.index.record(def_id,\n+                                   ItemContentBuilder::encode_info_for_item,\n+                                   (def_id, item)),\n         }\n         self.index.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n         let def_id = self.index.ecx.tcx.map.local_def_id(ni.id);\n-        self.index.record(def_id, |index| index.encode_info_for_foreign_item(def_id, ni));\n+        self.index.record(def_id,\n+                          ItemContentBuilder::encode_info_for_foreign_item,\n+                          (def_id, ni));\n     }\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         intravisit::walk_ty(self, ty);\n@@ -1343,11 +1335,9 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n         let ecx = self.ecx();\n         if let hir::TyImplTrait(_) = ty.node {\n             let def_id = ecx.tcx.map.local_def_id(ty.id);\n-            self.record(def_id, |this| {\n-                encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-                encode_family(this.rbml_w, 'y');\n-                this.encode_bounds_and_type_for_item(ty.id);\n-            });\n+            self.record(def_id,\n+                        ItemContentBuilder::encode_info_for_anon_ty,\n+                        (def_id, ty.id));\n         }\n     }\n \n@@ -1357,16 +1347,24 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n         match expr.node {\n             hir::ExprClosure(..) => {\n                 let def_id = ecx.tcx.map.local_def_id(expr.id);\n-\n-                self.record(def_id, |this| this.encode_info_for_closure(def_id, expr.id));\n+                self.record(def_id,\n+                            ItemContentBuilder::encode_info_for_closure,\n+                            (def_id, expr.id));\n             }\n             _ => { }\n         }\n     }\n }\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n-    fn encode_info_for_closure(&mut self, def_id: DefId, expr_id: NodeId) {\n+    fn encode_info_for_anon_ty(&mut self, (def_id, ty_id): (DefId, NodeId)) {\n+        let ecx = self.ecx;\n+        encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+        encode_family(self.rbml_w, 'y');\n+        self.encode_bounds_and_type_for_item(ty_id);\n+    }\n+\n+    fn encode_info_for_closure(&mut self, (def_id, expr_id): (DefId, NodeId)) {\n         let ecx = self.ecx;\n         encode_def_id_and_key(ecx, self.rbml_w, def_id);\n         encode_name(self.rbml_w, syntax::parse::token::intern(\"<closure>\"));\n@@ -1395,13 +1393,13 @@ fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n     let fields = {\n         let mut index = IndexBuilder::new(ecx, rbml_w);\n-        index.record(DefId::local(CRATE_DEF_INDEX), |this| {\n-            this.encode_info_for_mod(&krate.module,\n-                                     &[],\n-                                     CRATE_NODE_ID,\n-                                     syntax::parse::token::intern(&ecx.link_meta.crate_name),\n-                                     &hir::Public);\n-        });\n+        index.record(DefId::local(CRATE_DEF_INDEX),\n+                     ItemContentBuilder::encode_info_for_mod,\n+                     (&krate.module,\n+                      &[],\n+                      CRATE_NODE_ID,\n+                      syntax::parse::token::intern(&ecx.link_meta.crate_name),\n+                      &hir::Public));\n         krate.visit_all_items(&mut EncodeVisitor {\n             index: &mut index,\n         });"}, {"sha": "a971c618a2120e85bb1714e56ec615e6940487bc", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00e699faf3ec39715477b8386fba9deab2e2c925/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00e699faf3ec39715477b8386fba9deab2e2c925/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=00e699faf3ec39715477b8386fba9deab2e2c925", "patch": "@@ -57,14 +57,16 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     ///\n     /// Returns a dep-graph task that you should keep live as long as\n     /// the data for this item is being emitted.\n-    pub fn record<OP>(&mut self, id: DefId, op: OP)\n-        where OP: FnOnce(&mut ItemContentBuilder<'a, 'tcx, 'encoder>)\n+    pub fn record<DATA>(&mut self,\n+                        id: DefId,\n+                        op: fn(&mut ItemContentBuilder<'a, 'tcx, 'encoder>, DATA),\n+                        data: DATA)\n     {\n         let position = self.rbml_w.mark_stable_position();\n         self.items.record(id, position);\n         let _task = self.ecx.tcx.dep_graph.in_task(DepNode::MetaData(id));\n         self.rbml_w.start_tag(tag_items_data_item).unwrap();\n-        op(self);\n+        op(self, data);\n         self.rbml_w.end_tag().unwrap();\n     }\n "}]}