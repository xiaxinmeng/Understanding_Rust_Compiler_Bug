{"sha": "439a8e6cef1aac30a65a36d7c4ac0bb701d11fa7", "node_id": "C_kwDOAAsO6NoAKDQzOWE4ZTZjZWYxYWFjMzBhNjVhMzZkN2M0YWMwYmI3MDFkMTFmYTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-21T13:11:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-21T13:11:13Z"}, "message": "Rollup merge of #104662 - nnethercote:tweak-deriving-for-packed-non-copy, r=jackh726\n\nStreamline deriving on packed structs.\n\nThe current approach to field accesses in derived code:\n- Normal case: `&self.0`\n- In a packed struct that derives `Copy`: `&{self.0}`\n- In a packed struct that doesn't derive `Copy`: `let Self(ref x) = *self`\n\nThe `let` pattern used in the third case is equivalent to the simpler field access in the first case. This commit changes the third case to use a field access.\n\nThe commit also combines two boolean arguments (`is_packed` and `always_copy`) into a single field (`copy_fields`) earlier, to save passing both around.\n\nr? ``@jackh726``", "tree": {"sha": "6cefea8d2b7f23722da99067e31f767654400cd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cefea8d2b7f23722da99067e31f767654400cd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/439a8e6cef1aac30a65a36d7c4ac0bb701d11fa7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJje3jxCRBK7hj4Ov3rIwAAgsAIAI1O8kBWA+9+Gqf8PuaLiUBK\njschFCPzeY3pg2Hz/48DNson2CczRdUO6mPVVorogpMc/xn8/Of3sgLymIbAgIek\nSrQCE6VhjTK4X7TZbDy4yMiQM5z/eHaTzIz2li85J51R+z2BfWmlk2sb2mqe/klm\nhbCcSVOvuWglgk9gsA4SHcODKiVcjUVqLRalZmktEgVWcnSLiMxm9E2YDF8VUFvt\nLGmX+6yhoeNHUHY3YH+u3B37ogPX/+JYm7ASm2t9E1Lb0QPlYqhx3yFuLYJ5M1Kf\nFerDNmjRfNb/5e8L09ckERYA1ioQUBK8xw4RSXtYpPiOC/PntBwNEhge9dmCTpM=\n=aZR8\n-----END PGP SIGNATURE-----\n", "payload": "tree 6cefea8d2b7f23722da99067e31f767654400cd0\nparent 5b9289215e0afb73efbf882e8d6f0af461fc99f2\nparent a6e09a19fc20cdf9043e1b856d15170ac0f96511\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1669036273 +0100\ncommitter GitHub <noreply@github.com> 1669036273 +0100\n\nRollup merge of #104662 - nnethercote:tweak-deriving-for-packed-non-copy, r=jackh726\n\nStreamline deriving on packed structs.\n\nThe current approach to field accesses in derived code:\n- Normal case: `&self.0`\n- In a packed struct that derives `Copy`: `&{self.0}`\n- In a packed struct that doesn't derive `Copy`: `let Self(ref x) = *self`\n\nThe `let` pattern used in the third case is equivalent to the simpler field access in the first case. This commit changes the third case to use a field access.\n\nThe commit also combines two boolean arguments (`is_packed` and `always_copy`) into a single field (`copy_fields`) earlier, to save passing both around.\n\nr? ``@jackh726``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/439a8e6cef1aac30a65a36d7c4ac0bb701d11fa7", "html_url": "https://github.com/rust-lang/rust/commit/439a8e6cef1aac30a65a36d7c4ac0bb701d11fa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/439a8e6cef1aac30a65a36d7c4ac0bb701d11fa7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b9289215e0afb73efbf882e8d6f0af461fc99f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b9289215e0afb73efbf882e8d6f0af461fc99f2", "html_url": "https://github.com/rust-lang/rust/commit/5b9289215e0afb73efbf882e8d6f0af461fc99f2"}, {"sha": "a6e09a19fc20cdf9043e1b856d15170ac0f96511", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6e09a19fc20cdf9043e1b856d15170ac0f96511", "html_url": "https://github.com/rust-lang/rust/commit/a6e09a19fc20cdf9043e1b856d15170ac0f96511"}], "stats": {"total": 117, "additions": 30, "deletions": 87}, "files": [{"sha": "3309fab224fb71112fac7cb5c37225f2ab26d5e8", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 24, "deletions": 70, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/439a8e6cef1aac30a65a36d7c4ac0bb701d11fa7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a8e6cef1aac30a65a36d7c4ac0bb701d11fa7/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=439a8e6cef1aac30a65a36d7c4ac0bb701d11fa7", "patch": "@@ -448,7 +448,8 @@ impl<'a> TraitDef<'a> {\n                     _ => unreachable!(),\n                 };\n                 let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n-                let always_copy = has_no_type_params && cx.resolver.has_derive_copy(container_id);\n+                let copy_fields =\n+                    is_packed && has_no_type_params && cx.resolver.has_derive_copy(container_id);\n \n                 let newitem = match item.kind {\n                     ast::ItemKind::Struct(ref struct_def, ref generics) => self.expand_struct_def(\n@@ -457,16 +458,14 @@ impl<'a> TraitDef<'a> {\n                         item.ident,\n                         generics,\n                         from_scratch,\n-                        is_packed,\n-                        always_copy,\n+                        copy_fields,\n                     ),\n                     ast::ItemKind::Enum(ref enum_def, ref generics) => {\n-                        // We ignore `is_packed`/`always_copy` here, because\n-                        // `repr(packed)` enums cause an error later on.\n+                        // We ignore `is_packed` here, because `repr(packed)`\n+                        // enums cause an error later on.\n                         //\n                         // This can only cause further compilation errors\n-                        // downstream in blatantly illegal code, so it\n-                        // is fine.\n+                        // downstream in blatantly illegal code, so it is fine.\n                         self.expand_enum_def(cx, enum_def, item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Union(ref struct_def, ref generics) => {\n@@ -477,8 +476,7 @@ impl<'a> TraitDef<'a> {\n                                 item.ident,\n                                 generics,\n                                 from_scratch,\n-                                is_packed,\n-                                always_copy,\n+                                copy_fields,\n                             )\n                         } else {\n                             cx.span_err(mitem.span, \"this trait cannot be derived for unions\");\n@@ -748,8 +746,7 @@ impl<'a> TraitDef<'a> {\n         type_ident: Ident,\n         generics: &Generics,\n         from_scratch: bool,\n-        is_packed: bool,\n-        always_copy: bool,\n+        copy_fields: bool,\n     ) -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> =\n             struct_def.fields().iter().map(|field| field.ty.clone()).collect();\n@@ -777,8 +774,7 @@ impl<'a> TraitDef<'a> {\n                         type_ident,\n                         &selflike_args,\n                         &nonselflike_args,\n-                        is_packed,\n-                        always_copy,\n+                        copy_fields,\n                     )\n                 };\n \n@@ -1016,19 +1012,9 @@ impl<'a> MethodDef<'a> {\n     ///     }\n     /// }\n     /// ```\n-    /// If the struct doesn't impl `Copy`, we use let-destructuring with `ref`:\n-    /// ```\n-    /// # struct A { x: u8, y: u8 }\n-    /// impl PartialEq for A {\n-    ///     fn eq(&self, other: &A) -> bool {\n-    ///         let Self { x: ref __self_0_0, y: ref __self_0_1 } = *self;\n-    ///         let Self { x: ref __self_1_0, y: ref __self_1_1 } = *other;\n-    ///         *__self_0_0 == *__self_1_0 && *__self_0_1 == *__self_1_1\n-    ///     }\n-    /// }\n-    /// ```\n-    /// This latter case only works if the fields match the alignment required\n-    /// by the `packed(N)` attribute. (We'll get errors later on if not.)\n+    /// If the struct doesn't impl `Copy`, we use the normal `&self.x`. This\n+    /// only works if the fields match the alignment required by the\n+    /// `packed(N)` attribute. (We'll get errors later on if not.)\n     fn expand_struct_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n@@ -1037,51 +1023,19 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         selflike_args: &[P<Expr>],\n         nonselflike_args: &[P<Expr>],\n-        is_packed: bool,\n-        always_copy: bool,\n+        copy_fields: bool,\n     ) -> BlockOrExpr {\n-        let span = trait_.span;\n         assert!(selflike_args.len() == 1 || selflike_args.len() == 2);\n \n-        let mk_body = |cx, selflike_fields| {\n-            self.call_substructure_method(\n-                cx,\n-                trait_,\n-                type_ident,\n-                nonselflike_args,\n-                &Struct(struct_def, selflike_fields),\n-            )\n-        };\n-\n-        if !is_packed {\n-            let selflike_fields =\n-                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, false);\n-            mk_body(cx, selflike_fields)\n-        } else if always_copy {\n-            let selflike_fields =\n-                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, true);\n-            mk_body(cx, selflike_fields)\n-        } else {\n-            // Packed and not copy. Need to use ref patterns.\n-            let prefixes: Vec<_> =\n-                (0..selflike_args.len()).map(|i| format!(\"__self_{}\", i)).collect();\n-            let selflike_fields = trait_.create_struct_pattern_fields(cx, struct_def, &prefixes);\n-            let mut body = mk_body(cx, selflike_fields);\n-\n-            let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-            let patterns =\n-                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, ByRef::Yes);\n-\n-            // Do the let-destructuring.\n-            let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n-                .map(|(selflike_arg_expr, pat)| {\n-                    let selflike_arg_expr = cx.expr_deref(span, selflike_arg_expr.clone());\n-                    cx.stmt_let_pat(span, pat, selflike_arg_expr)\n-                })\n-                .collect();\n-            stmts.extend(std::mem::take(&mut body.0));\n-            BlockOrExpr(stmts, body.1)\n-        }\n+        let selflike_fields =\n+            trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, copy_fields);\n+        self.call_substructure_method(\n+            cx,\n+            trait_,\n+            type_ident,\n+            nonselflike_args,\n+            &Struct(struct_def, selflike_fields),\n+        )\n     }\n \n     fn expand_static_struct_method_body(\n@@ -1531,7 +1485,7 @@ impl<'a> TraitDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         selflike_args: &[P<Expr>],\n         struct_def: &'a VariantData,\n-        copy: bool,\n+        copy_fields: bool,\n     ) -> Vec<FieldInfo> {\n         self.create_fields(struct_def, |i, struct_field, sp| {\n             selflike_args\n@@ -1550,7 +1504,7 @@ impl<'a> TraitDef<'a> {\n                             }),\n                         ),\n                     );\n-                    if copy {\n+                    if copy_fields {\n                         field_expr = cx.expr_block(\n                             cx.block(struct_field.span, vec![cx.stmt_expr(field_expr)]),\n                         );"}, {"sha": "a63cbd4ca7edea3d2227db9b81300925274fe3c4", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/439a8e6cef1aac30a65a36d7c4ac0bb701d11fa7/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/439a8e6cef1aac30a65a36d7c4ac0bb701d11fa7/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=439a8e6cef1aac30a65a36d7c4ac0bb701d11fa7", "patch": "@@ -463,16 +463,14 @@ struct PackedNonCopy(u8);\n impl ::core::clone::Clone for PackedNonCopy {\n     #[inline]\n     fn clone(&self) -> PackedNonCopy {\n-        let Self(ref __self_0_0) = *self;\n-        PackedNonCopy(::core::clone::Clone::clone(__self_0_0))\n+        PackedNonCopy(::core::clone::Clone::clone(&self.0))\n     }\n }\n #[automatically_derived]\n impl ::core::fmt::Debug for PackedNonCopy {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        let Self(ref __self_0_0) = *self;\n         ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"PackedNonCopy\",\n-            &__self_0_0)\n+            &&self.0)\n     }\n }\n #[automatically_derived]\n@@ -485,20 +483,15 @@ impl ::core::default::Default for PackedNonCopy {\n #[automatically_derived]\n impl ::core::hash::Hash for PackedNonCopy {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        let Self(ref __self_0_0) = *self;\n-        ::core::hash::Hash::hash(__self_0_0, state)\n+        ::core::hash::Hash::hash(&self.0, state)\n     }\n }\n #[automatically_derived]\n impl ::core::marker::StructuralPartialEq for PackedNonCopy { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for PackedNonCopy {\n     #[inline]\n-    fn eq(&self, other: &PackedNonCopy) -> bool {\n-        let Self(ref __self_0_0) = *self;\n-        let Self(ref __self_1_0) = *other;\n-        *__self_0_0 == *__self_1_0\n-    }\n+    fn eq(&self, other: &PackedNonCopy) -> bool { self.0 == other.0 }\n }\n #[automatically_derived]\n impl ::core::marker::StructuralEq for PackedNonCopy { }\n@@ -516,18 +509,14 @@ impl ::core::cmp::PartialOrd for PackedNonCopy {\n     #[inline]\n     fn partial_cmp(&self, other: &PackedNonCopy)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        let Self(ref __self_0_0) = *self;\n-        let Self(ref __self_1_0) = *other;\n-        ::core::cmp::PartialOrd::partial_cmp(__self_0_0, __self_1_0)\n+        ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)\n     }\n }\n #[automatically_derived]\n impl ::core::cmp::Ord for PackedNonCopy {\n     #[inline]\n     fn cmp(&self, other: &PackedNonCopy) -> ::core::cmp::Ordering {\n-        let Self(ref __self_0_0) = *self;\n-        let Self(ref __self_1_0) = *other;\n-        ::core::cmp::Ord::cmp(__self_0_0, __self_1_0)\n+        ::core::cmp::Ord::cmp(&self.0, &other.0)\n     }\n }\n "}]}