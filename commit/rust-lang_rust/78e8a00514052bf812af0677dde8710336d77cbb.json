{"sha": "78e8a00514052bf812af0677dde8710336d77cbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZThhMDA1MTQwNTJiZjgxMmFmMDY3N2RkZTg3MTAzMzZkNzdjYmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-20T01:39:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-20T01:39:50Z"}, "message": "Auto merge of #32306 - nikomatsakis:issue-32278, r=eddyb\n\ncreate fewer region variables in coercions\n\nFixes #32278.\n\nr? @eddyb", "tree": {"sha": "f028367e726ba4fa26b458b5c5e9d1e5c64561d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f028367e726ba4fa26b458b5c5e9d1e5c64561d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78e8a00514052bf812af0677dde8710336d77cbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78e8a00514052bf812af0677dde8710336d77cbb", "html_url": "https://github.com/rust-lang/rust/commit/78e8a00514052bf812af0677dde8710336d77cbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78e8a00514052bf812af0677dde8710336d77cbb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02310fd313cf3eed11fe5ac11921b73cc3b648d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/02310fd313cf3eed11fe5ac11921b73cc3b648d4", "html_url": "https://github.com/rust-lang/rust/commit/02310fd313cf3eed11fe5ac11921b73cc3b648d4"}, {"sha": "43aed96d0da2cfa6e5da3058c107f3de4a3c009b", "url": "https://api.github.com/repos/rust-lang/rust/commits/43aed96d0da2cfa6e5da3058c107f3de4a3c009b", "html_url": "https://github.com/rust-lang/rust/commit/43aed96d0da2cfa6e5da3058c107f3de4a3c009b"}], "stats": {"total": 585, "additions": 396, "deletions": 189}, "files": [{"sha": "089eae89d0492630c98f42bab5dae0bf10d697d8", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 138, "deletions": 76, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -68,6 +68,7 @@ use super::region_inference::SubSupConflict;\n use super::region_inference::GenericBoundFailure;\n use super::region_inference::GenericKind;\n use super::region_inference::ProcessedErrors;\n+use super::region_inference::ProcessedErrorOrigin;\n use super::region_inference::SameRegions;\n \n use std::collections::HashSet;\n@@ -232,7 +233,7 @@ pub trait ErrorReporting<'tcx> {\n                             errors: &Vec<RegionResolutionError<'tcx>>);\n \n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Vec<RegionResolutionError<'tcx>>;\n+                      -> Option<Vec<RegionResolutionError<'tcx>>>;\n \n     fn report_type_error(&self,\n                          trace: TypeTrace<'tcx>,\n@@ -246,7 +247,8 @@ pub trait ErrorReporting<'tcx> {\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n-                                     terr: &TypeError<'tcx>);\n+                                     terr: &TypeError<'tcx>)\n+                                     -> DiagnosticBuilder<'tcx>;\n \n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n@@ -258,7 +260,8 @@ pub trait ErrorReporting<'tcx> {\n     fn report_concrete_failure(&self,\n                                origin: SubregionOrigin<'tcx>,\n                                sub: Region,\n-                               sup: Region);\n+                               sup: Region)\n+                                -> DiagnosticBuilder<'tcx>;\n \n     fn report_generic_bound_failure(&self,\n                                     origin: SubregionOrigin<'tcx>,\n@@ -273,8 +276,7 @@ pub trait ErrorReporting<'tcx> {\n                                sup_region: Region);\n \n     fn report_processed_errors(&self,\n-                               var_origin: &[RegionVariableOrigin],\n-                               trace_origin: &[(TypeTrace<'tcx>, TypeError<'tcx>)],\n+                               origins: &[ProcessedErrorOrigin<'tcx>],\n                                same_regions: &[SameRegions]);\n \n     fn give_suggestion(&self, err: &mut DiagnosticBuilder, same_regions: &[SameRegions]);\n@@ -303,12 +305,19 @@ trait ErrorReportingHelpers<'tcx> {\n impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_region_errors(&self,\n                             errors: &Vec<RegionResolutionError<'tcx>>) {\n-        let p_errors = self.process_errors(errors);\n-        let errors = if p_errors.is_empty() { errors } else { &p_errors };\n+        debug!(\"report_region_errors(): {} errors to start\", errors.len());\n+\n+        // try to pre-process the errors, which will group some of them\n+        // together into a `ProcessedErrors` group:\n+        let processed_errors = self.process_errors(errors);\n+        let errors = processed_errors.as_ref().unwrap_or(errors);\n+\n+        debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n+\n         for error in errors {\n             match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n-                    self.report_concrete_failure(origin, sub, sup);\n+                    self.report_concrete_failure(origin, sub, sup).emit();\n                 }\n \n                 GenericBoundFailure(kind, param_ty, sub) => {\n@@ -323,13 +332,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                                  sup_origin, sup_r);\n                 }\n \n-                ProcessedErrors(ref var_origins,\n-                                ref trace_origins,\n+                ProcessedErrors(ref origins,\n                                 ref same_regions) => {\n                     if !same_regions.is_empty() {\n-                        self.report_processed_errors(&var_origins[..],\n-                                                     &trace_origins[..],\n-                                                     &same_regions[..]);\n+                        self.report_processed_errors(origins, same_regions);\n                     }\n                 }\n             }\n@@ -341,46 +347,73 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     // parameters to the user. This is done so that we can have a more\n     // complete view of what lifetimes should be the same.\n     // If the return value is an empty vector, it means that processing\n-    // failed (so the return value of this method should not be used)\n+    // failed (so the return value of this method should not be used).\n+    //\n+    // The method also attempts to weed out messages that seem like\n+    // duplicates that will be unhelpful to the end-user. But\n+    // obviously it never weeds out ALL errors.\n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Vec<RegionResolutionError<'tcx>> {\n+                      -> Option<Vec<RegionResolutionError<'tcx>>> {\n         debug!(\"process_errors()\");\n-        let mut var_origins = Vec::new();\n-        let mut trace_origins = Vec::new();\n+        let mut origins = Vec::new();\n+\n+        // we collect up ConcreteFailures and SubSupConflicts that are\n+        // relating free-regions bound on the fn-header and group them\n+        // together into this vector\n         let mut same_regions = Vec::new();\n-        let mut processed_errors = Vec::new();\n+\n+        // here we put errors that we will not be able to process nicely\n+        let mut other_errors = Vec::new();\n+\n+        // we collect up GenericBoundFailures in here.\n+        let mut bound_failures = Vec::new();\n+\n         for error in errors {\n-            match error.clone() {\n-                ConcreteFailure(origin, sub, sup) => {\n+            match *error {\n+                ConcreteFailure(ref origin, sub, sup) => {\n                     debug!(\"processing ConcreteFailure\");\n-                    let trace = match origin {\n-                        infer::Subtype(trace) => Some(trace),\n-                        _ => None,\n-                    };\n                     match free_regions_from_same_fn(self.tcx, sub, sup) {\n-                        Some(ref same_frs) if trace.is_some() => {\n-                            let trace = trace.unwrap();\n-                            let terr = TypeError::RegionsDoesNotOutlive(sup,\n-                                                                        sub);\n-                            trace_origins.push((trace, terr));\n+                        Some(ref same_frs) => {\n+                            origins.push(\n+                                ProcessedErrorOrigin::ConcreteFailure(\n+                                    origin.clone(),\n+                                    sub,\n+                                    sup));\n                             append_to_same_regions(&mut same_regions, same_frs);\n                         }\n-                        _ => processed_errors.push((*error).clone()),\n+                        _ => {\n+                            other_errors.push(error.clone());\n+                        }\n                     }\n                 }\n-                SubSupConflict(var_origin, _, sub_r, _, sup_r) => {\n+                SubSupConflict(ref var_origin, _, sub_r, _, sup_r) => {\n                     debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub_r, sup_r);\n                     match free_regions_from_same_fn(self.tcx, sub_r, sup_r) {\n                         Some(ref same_frs) => {\n-                            var_origins.push(var_origin);\n+                            origins.push(\n+                                ProcessedErrorOrigin::VariableFailure(\n+                                    var_origin.clone()));\n                             append_to_same_regions(&mut same_regions, same_frs);\n                         }\n-                        None => processed_errors.push((*error).clone()),\n+                        None => {\n+                            other_errors.push(error.clone());\n+                        }\n                     }\n                 }\n-                _ => ()  // This shouldn't happen\n+                GenericBoundFailure(ref origin, ref kind, region) => {\n+                    bound_failures.push((origin.clone(), kind.clone(), region));\n+                }\n+                ProcessedErrors(..) => {\n+                    panic!(\"should not encounter a `ProcessedErrors` yet: {:?}\", error)\n+                }\n             }\n         }\n+\n+        // ok, let's pull together the errors, sorted in an order that\n+        // we think will help user the best\n+        let mut processed_errors = vec![];\n+\n+        // first, put the processed errors, if any\n         if !same_regions.is_empty() {\n             let common_scope_id = same_regions[0].scope_id;\n             for sr in &same_regions {\n@@ -390,16 +423,39 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 if sr.scope_id != common_scope_id {\n                     debug!(\"returning empty result from process_errors because\n                             {} != {}\", sr.scope_id, common_scope_id);\n-                    return vec!();\n+                    return None;\n                 }\n             }\n-            let pe = ProcessedErrors(var_origins, trace_origins, same_regions);\n+            assert!(origins.len() > 0);\n+            let pe = ProcessedErrors(origins, same_regions);\n             debug!(\"errors processed: {:?}\", pe);\n             processed_errors.push(pe);\n         }\n-        return processed_errors;\n \n+        // next, put the other misc errors\n+        processed_errors.extend(other_errors);\n+\n+        // finally, put the `T: 'a` errors, but only if there were no\n+        // other errors. otherwise, these have a very high rate of\n+        // being unhelpful in practice. This is because they are\n+        // basically secondary checks that test the state of the\n+        // region graph after the rest of inference is done, and the\n+        // other kinds of errors indicate that the region constraint\n+        // graph is internally inconsistent, so these test results are\n+        // likely to be meaningless.\n+        if processed_errors.is_empty() {\n+            for (origin, kind, region) in bound_failures {\n+                processed_errors.push(GenericBoundFailure(origin, kind, region));\n+            }\n+        }\n+\n+        // we should always wind up with SOME errors, unless there were no\n+        // errors to start\n+        assert!(if errors.len() > 0 {processed_errors.len() > 0} else {true});\n \n+        return Some(processed_errors);\n+\n+        #[derive(Debug)]\n         struct FreeRegionsFromSameFn {\n             sub_fr: ty::FreeRegion,\n             sup_fr: ty::FreeRegion,\n@@ -459,11 +515,12 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n         fn append_to_same_regions(same_regions: &mut Vec<SameRegions>,\n                                   same_frs: &FreeRegionsFromSameFn) {\n+            debug!(\"append_to_same_regions(same_regions={:?}, same_frs={:?})\",\n+                   same_regions, same_frs);\n             let scope_id = same_frs.scope_id;\n             let (sub_fr, sup_fr) = (same_frs.sub_fr, same_frs.sup_fr);\n-            for sr in &mut *same_regions {\n-                if sr.contains(&sup_fr.bound_region)\n-                   && scope_id == sr.scope_id {\n+            for sr in same_regions.iter_mut() {\n+                if sr.contains(&sup_fr.bound_region) && scope_id == sr.scope_id {\n                     sr.push(sub_fr.bound_region);\n                     return\n                 }\n@@ -569,11 +626,12 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n-                                     terr: &TypeError<'tcx>) {\n+                                     terr: &TypeError<'tcx>)\n+                                     -> DiagnosticBuilder<'tcx> {\n         let span = trace.origin.span();\n         let mut err = self.report_type_error(trace, terr);\n         self.tcx.note_and_explain_type_err(&mut err, terr, span);\n-        err.emit();\n+        err\n     }\n \n     /// Returns a string of the form \"expected `{}`, found `{}`\", or None if this is a derived\n@@ -678,11 +736,12 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_concrete_failure(&self,\n                                origin: SubregionOrigin<'tcx>,\n                                sub: Region,\n-                               sup: Region) {\n+                               sup: Region)\n+                                -> DiagnosticBuilder<'tcx> {\n         match origin {\n             infer::Subtype(trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n-                self.report_and_explain_type_error(trace, &terr);\n+                self.report_and_explain_type_error(trace, &terr)\n             }\n             infer::Reborrow(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0312,\n@@ -696,7 +755,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"...but the borrowed content is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0313,\n@@ -712,7 +771,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                              self.tcx.local_var_name_str(upvar_id.var_id)),\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::InfStackClosure(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0314,\n@@ -725,7 +784,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"...but the closure's stack frame is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::InvokeClosure(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0315,\n@@ -734,7 +793,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the closure is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::DerefPointer(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0473,\n@@ -743,7 +802,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the reference is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::FreeVariable(span, id) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0474,\n@@ -757,7 +816,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"closure is valid for \",\n                     sub,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::IndexSlice(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0475,\n@@ -766,7 +825,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the slice is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::RelateObjectBound(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0476,\n@@ -780,7 +839,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"source pointer is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::RelateParamBound(span, ty) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0477,\n@@ -790,7 +849,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n-                err.emit();\n+                err\n             }\n             infer::RelateRegionParamBound(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0478,\n@@ -803,7 +862,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"but lifetime parameter must outlive \",\n                     sub,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::RelateDefaultParamBound(span, ty) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0479,\n@@ -814,7 +873,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n-                err.emit();\n+                err\n             }\n             infer::CallRcvr(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0480,\n@@ -824,7 +883,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the receiver is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::CallArg(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0481,\n@@ -834,7 +893,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the function argument is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::CallReturn(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0482,\n@@ -844,7 +903,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the return value is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::Operand(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0483,\n@@ -854,7 +913,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the operand is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::AddrOf(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0484,\n@@ -863,7 +922,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the borrow is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::AutoBorrow(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0485,\n@@ -873,7 +932,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the automatic borrow is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::ExprTypeIsNotInScope(t, span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0486,\n@@ -884,7 +943,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"type is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::SafeDestructor(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0487,\n@@ -899,7 +958,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"subregion: \",\n                     sub,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0488,\n@@ -908,7 +967,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the variable is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::ParameterInScope(_, span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0489,\n@@ -917,15 +976,15 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the parameter is only valid for \",\n                     sub,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::DataBorrowed(ty, span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0490,\n                           \"a value of type `{}` is borrowed for too long\",\n                           self.ty_to_string(ty));\n                 self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n                 self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n-                err.emit();\n+                err\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0491,\n@@ -940,7 +999,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"but the referenced data is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n         }\n     }\n@@ -970,19 +1029,22 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     }\n \n     fn report_processed_errors(&self,\n-                               var_origins: &[RegionVariableOrigin],\n-                               trace_origins: &[(TypeTrace<'tcx>, TypeError<'tcx>)],\n+                               origins: &[ProcessedErrorOrigin<'tcx>],\n                                same_regions: &[SameRegions]) {\n-        for (i, vo) in var_origins.iter().enumerate() {\n-            let mut err = self.report_inference_failure(vo.clone());\n-            if i == var_origins.len() - 1 {\n+        for (i, origin) in origins.iter().enumerate() {\n+            let mut err = match *origin {\n+                ProcessedErrorOrigin::VariableFailure(ref var_origin) =>\n+                    self.report_inference_failure(var_origin.clone()),\n+                ProcessedErrorOrigin::ConcreteFailure(ref sr_origin, sub, sup) =>\n+                    self.report_concrete_failure(sr_origin.clone(), sub, sup),\n+            };\n+\n+            // attach the suggestion to the last such error\n+            if i == origins.len() - 1 {\n                 self.give_suggestion(&mut err, same_regions);\n             }\n-            err.emit();\n-        }\n \n-        for &(ref trace, ref terr) in trace_origins {\n-            self.report_and_explain_type_error(trace.clone(), terr);\n+            err.emit();\n         }\n     }\n "}, {"sha": "290d9afa44981e35318588b3949538c18fcfc499", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -407,7 +407,7 @@ pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n     match result {\n         Ok(t) => t,\n         Err(ref err) => {\n-            cx.report_and_explain_type_error(trace, err);\n+            cx.report_and_explain_type_error(trace, err).emit();\n             cx.tcx.types.err\n         }\n     }\n@@ -1396,7 +1396,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 found: actual\n             })\n         };\n-        self.report_and_explain_type_error(trace, &err);\n+        self.report_and_explain_type_error(trace, &err).emit();\n     }\n \n     pub fn report_conflicting_default_types(&self,\n@@ -1411,11 +1411,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             })\n         };\n \n-        self.report_and_explain_type_error(trace,\n+        self.report_and_explain_type_error(\n+            trace,\n             &TypeError::TyParamDefaultMismatch(ExpectedFound {\n                 expected: expected,\n                 found: actual\n-        }));\n+            }))\n+            .emit();\n     }\n \n     pub fn replace_late_bound_regions_with_fresh_var<T>("}, {"sha": "7bba495e46779eab5a53f0e31fa161971abcabf2", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -17,7 +17,7 @@ pub use self::CombineMapType::*;\n pub use self::RegionResolutionError::*;\n pub use self::VarValue::*;\n \n-use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n+use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n use super::unify_key;\n \n use rustc_data_structures::graph::{self, Direction, NodeIndex};\n@@ -27,7 +27,6 @@ use middle::ty::{self, Ty, TyCtxt};\n use middle::ty::{BoundRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n-use middle::ty::error::TypeError;\n use util::common::indenter;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n@@ -152,11 +151,16 @@ pub enum RegionResolutionError<'tcx> {\n     /// more specific errors message by suggesting to the user where they\n     /// should put a lifetime. In those cases we process and put those errors\n     /// into `ProcessedErrors` before we do any reporting.\n-    ProcessedErrors(Vec<RegionVariableOrigin>,\n-                    Vec<(TypeTrace<'tcx>, TypeError<'tcx>)>,\n+    ProcessedErrors(Vec<ProcessedErrorOrigin<'tcx>>,\n                     Vec<SameRegions>),\n }\n \n+#[derive(Clone, Debug)]\n+pub enum ProcessedErrorOrigin<'tcx> {\n+    ConcreteFailure(SubregionOrigin<'tcx>, Region, Region),\n+    VariableFailure(RegionVariableOrigin),\n+}\n+\n /// SameRegions is used to group regions that we think are the same and would\n /// like to indicate so to the user.\n /// For example, the following function\n@@ -530,16 +534,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n-        match (a, b) {\n-            (ReStatic, _) | (_, ReStatic) => {\n-                ReStatic // nothing lives longer than static\n-            }\n-\n-            _ => {\n-                self.combine_vars(Lub, a, b, origin.clone(), |this, old_r, new_r| {\n-                    this.make_subregion(origin.clone(), old_r, new_r)\n-                })\n-            }\n+        if a == ty::ReStatic || b == ty::ReStatic {\n+            ReStatic // nothing lives longer than static\n+        } else if a == b {\n+            a // LUB(a,a) = a\n+        } else {\n+            self.combine_vars(Lub, a, b, origin.clone(), |this, old_r, new_r| {\n+                this.make_subregion(origin.clone(), old_r, new_r)\n+            })\n         }\n     }\n \n@@ -550,8 +552,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (ReStatic, r) | (r, ReStatic) => {\n-                // static lives longer than everything else\n-                r\n+                r // static lives longer than everything else\n+            }\n+\n+            _ if a == b => {\n+                a // GLB(a,a) = a\n             }\n \n             _ => {"}, {"sha": "bb27333025e072f52deacbacf7c75d2b81db1c9b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 159, "deletions": 40, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -71,7 +71,7 @@ use middle::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use middle::ty::{self, LvaluePreference, TypeAndMut, Ty, TyCtxt};\n use middle::ty::fold::TypeFoldable;\n use middle::ty::error::TypeError;\n-use middle::ty::relate::{relate_substs, RelateResult, TypeRelation};\n+use middle::ty::relate::{relate_substs, Relate, RelateResult, TypeRelation};\n use util::common::indent;\n \n use std::cell::RefCell;\n@@ -112,8 +112,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         self.fcx.tcx()\n     }\n \n-    /// Unify two types (using sub or lub) and produce a noop coercion.\n-    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let infcx = self.fcx.infcx();\n         infcx.commit_if_ok(|_| {\n             let trace = TypeTrace::types(self.origin, false, a, b);\n@@ -122,7 +121,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             } else {\n                 infcx.sub(false, trace).relate(&a, &b)\n             }\n-        }).and_then(|ty| self.identity(ty))\n+        })\n+    }\n+\n+    /// Unify two types (using sub or lub) and produce a noop coercion.\n+    fn unify_and_identity(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+        self.unify(&a, &b).and_then(|ty| self.identity(ty))\n     }\n \n     /// Synthesize an identity adjustment.\n@@ -166,8 +170,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 return self.coerce_unsafe_ptr(a, b, mt_b.mutbl);\n             }\n \n-            ty::TyRef(_, mt_b) => {\n-                return self.coerce_borrowed_pointer(exprs, a, b, mt_b.mutbl);\n+            ty::TyRef(r_b, mt_b) => {\n+                return self.coerce_borrowed_pointer(exprs, a, b, r_b, mt_b);\n             }\n \n             _ => {}\n@@ -187,7 +191,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             _ => {\n                 // Otherwise, just use unification rules.\n-                self.unify(a, b)\n+                self.unify_and_identity(a, b)\n             }\n         }\n     }\n@@ -199,7 +203,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                          exprs: &E,\n                                          a: Ty<'tcx>,\n                                          b: Ty<'tcx>,\n-                                         mutbl_b: hir::Mutability)\n+                                         r_b: &'tcx ty::Region,\n+                                         mt_b: TypeAndMut<'tcx>)\n                                          -> CoerceResult<'tcx>\n         // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n         where E: Fn() -> I,\n@@ -213,57 +218,171 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // to type check, we will construct the type that `&M*expr` would\n         // yield.\n \n-        match a.sty {\n-            ty::TyRef(_, mt_a) => {\n-                try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n+        let (r_a, mt_a) = match a.sty {\n+            ty::TyRef(r_a, mt_a) => {\n+                try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n+                (r_a, mt_a)\n             }\n-            _ => return self.unify(a, b)\n-        }\n+            _ => return self.unify_and_identity(a, b)\n+        };\n \n         let span = self.origin.span();\n-        let coercion = Coercion(span);\n-        let r_borrow = self.fcx.infcx().next_region_var(coercion);\n-        let r_borrow = self.tcx().mk_region(r_borrow);\n-        let autoref = Some(AutoPtr(r_borrow, mutbl_b));\n \n-        let lvalue_pref = LvaluePreference::from_mutbl(mutbl_b);\n+        let lvalue_pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n         let mut first_error = None;\n+        let mut r_borrow_var = None;\n         let (_, autoderefs, success) = autoderef(self.fcx, span, a, exprs,\n                                                  UnresolvedTypeAction::Ignore,\n                                                  lvalue_pref,\n-                                                 |inner_ty, autoderef| {\n+                                                 |referent_ty, autoderef|\n+        {\n             if autoderef == 0 {\n                 // Don't let this pass, otherwise it would cause\n                 // &T to autoref to &&T.\n                 return None;\n             }\n-            let ty = self.tcx().mk_ref(r_borrow,\n-                                        TypeAndMut {ty: inner_ty, mutbl: mutbl_b});\n-            match self.unify(ty, b) {\n+\n+            // At this point, we have deref'd `a` to `referent_ty`.  So\n+            // imagine we are coercing from `&'a mut Vec<T>` to `&'b mut [T]`.\n+            // In the autoderef loop for `&'a mut Vec<T>`, we would get\n+            // three callbacks:\n+            //\n+            // - `&'a mut Vec<T>` -- 0 derefs, just ignore it\n+            // - `Vec<T>` -- 1 deref\n+            // - `[T]` -- 2 deref\n+            //\n+            // At each point after the first callback, we want to\n+            // check to see whether this would match out target type\n+            // (`&'b mut [T]`) if we autoref'd it. We can't just\n+            // compare the referent types, though, because we still\n+            // have to consider the mutability. E.g., in the case\n+            // we've been considering, we have an `&mut` reference, so\n+            // the `T` in `[T]` needs to be unified with equality.\n+            //\n+            // Therefore, we construct reference types reflecting what\n+            // the types will be after we do the final auto-ref and\n+            // compare those. Note that this means we use the target\n+            // mutability [1], since it may be that we are coercing\n+            // from `&mut T` to `&U`.\n+            //\n+            // One fine point concerns the region that we use. We\n+            // choose the region such that the region of the final\n+            // type that results from `unify` will be the region we\n+            // want for the autoref:\n+            //\n+            // - if in sub mode, that means we want to use `'b` (the\n+            //   region from the target reference) for both\n+            //   pointers [2]. This is because sub mode (somewhat\n+            //   arbitrarily) returns the subtype region.  In the case\n+            //   where we are coercing to a target type, we know we\n+            //   want to use that target type region (`'b`) because --\n+            //   for the program to type-check -- it must be the\n+            //   smaller of the two.\n+            //   - One fine point. It may be surprising that we can\n+            //     use `'b` without relating `'a` and `'b`. The reason\n+            //     that this is ok is that what we produce is\n+            //     effectively a `&'b *x` expression (if you could\n+            //     annotate the region of a borrow), and regionck has\n+            //     code that adds edges from the region of a borrow\n+            //     (`'b`, here) into the regions in the borrowed\n+            //     expression (`*x`, here).  (Search for \"link\".)\n+            // - if in lub mode, things can get fairly complicated. The\n+            //   easiest thing is just to make a fresh\n+            //   region variable [4], which effectively means we defer\n+            //   the decision to region inference (and regionck, which will add\n+            //   some more edges to this variable). However, this can wind up\n+            //   creating a crippling number of variables in some cases --\n+            //   e.g. #32278 -- so we optimize one particular case [3].\n+            //   Let me try to explain with some examples:\n+            //   - The \"running example\" above represents the simple case,\n+            //     where we have one `&` reference at the outer level and\n+            //     ownership all the rest of the way down. In this case,\n+            //     we want `LUB('a, 'b)` as the resulting region.\n+            //   - However, if there are nested borrows, that region is\n+            //     too strong. Consider a coercion from `&'a &'x Rc<T>` to\n+            //     `&'b T`. In this case, `'a` is actually irrelevant.\n+            //     The pointer we want is `LUB('x, 'b`). If we choose `LUB('a,'b)`\n+            //     we get spurious errors (`run-pass/regions-lub-ref-ref-rc.rs`).\n+            //     (The errors actually show up in borrowck, typically, because\n+            //     this extra edge causes the region `'a` to be inferred to something\n+            //     too big, which then results in borrowck errors.)\n+            //   - We could track the innermost shared reference, but there is already\n+            //     code in regionck that has the job of creating links between\n+            //     the region of a borrow and the regions in the thing being\n+            //     borrowed (here, `'a` and `'x`), and it knows how to handle\n+            //     all the various cases. So instead we just make a region variable\n+            //     and let regionck figure it out.\n+            let r = if !self.use_lub {\n+                r_b // [2] above\n+            } else if autoderef == 1 {\n+                r_a // [3] above\n+            } else {\n+                if r_borrow_var.is_none() { // create var lazilly, at most once\n+                    let coercion = Coercion(span);\n+                    let r = self.fcx.infcx().next_region_var(coercion);\n+                    r_borrow_var = Some(self.tcx().mk_region(r)); // [4] above\n+                }\n+                r_borrow_var.unwrap()\n+            };\n+            let derefd_ty_a = self.tcx().mk_ref(r, TypeAndMut {\n+                ty: referent_ty,\n+                mutbl: mt_b.mutbl // [1] above\n+            });\n+            match self.unify(derefd_ty_a, b) {\n+                Ok(ty) => Some(ty),\n                 Err(err) => {\n                     if first_error.is_none() {\n                         first_error = Some(err);\n                     }\n                     None\n                 }\n-                Ok((ty, _)) => Some(ty)\n             }\n         });\n \n-        match success {\n-            Some(ty) => {\n-                Ok((ty, AdjustDerefRef(AutoDerefRef {\n-                    autoderefs: autoderefs,\n-                    autoref: autoref,\n-                    unsize: None\n-                })))\n-            }\n+        // Extract type or return an error. We return the first error\n+        // we got, which should be from relating the \"base\" type\n+        // (e.g., in example above, the failure from relating `Vec<T>`\n+        // to the target type), since that should be the least\n+        // confusing.\n+        let ty = match success {\n+            Some(ty) => ty,\n             None => {\n-                // Return original error as if overloaded deref was never\n-                // attempted, to avoid irrelevant/confusing error messages.\n-                Err(first_error.expect(\"coerce_borrowed_pointer failed with no error?\"))\n+                let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n+                debug!(\"coerce_borrowed_pointer: failed with err = {:?}\", err);\n+                return Err(err);\n             }\n+        };\n+\n+        // Now apply the autoref. We have to extract the region out of\n+        // the final ref type we got.\n+        if ty == a && mt_a.mutbl == hir::MutImmutable && autoderefs == 1 {\n+            // As a special case, if we would produce `&'a *x`, that's\n+            // a total no-op. We end up with the type `&'a T` just as\n+            // we started with.  In that case, just skip it\n+            // altogether. This is just an optimization.\n+            //\n+            // Note that for `&mut`, we DO want to reborrow --\n+            // otherwise, this would be a move, which might be an\n+            // error. For example `foo(self.x)` where `self` and\n+            // `self.x` both have `&mut `type would be a move of\n+            // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n+            // which is a borrow.\n+            assert_eq!(mt_b.mutbl, hir::MutImmutable); // can only coerce &T -> &U\n+            return self.identity(ty);\n         }\n+        let r_borrow = match ty.sty {\n+            ty::TyRef(r_borrow, _) => r_borrow,\n+            _ => self.tcx().sess.span_bug(span,\n+                                          &format!(\"expected a ref type, got {:?}\", ty))\n+        };\n+        let autoref = Some(AutoPtr(r_borrow, mt_b.mutbl));\n+        debug!(\"coerce_borrowed_pointer: succeeded ty={:?} autoderefs={:?} autoref={:?}\",\n+               ty, autoderefs, autoref);\n+        Ok((ty, AdjustDerefRef(AutoDerefRef {\n+            autoderefs: autoderefs,\n+            autoref: autoref,\n+            unsize: None\n+        })))\n     }\n \n \n@@ -392,14 +511,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx().safe_to_unsafe_fn_ty(fn_ty_a);\n-                    return self.unify(unsafe_a, b).map(|(ty, _)| {\n+                    return self.unify_and_identity(unsafe_a, b).map(|(ty, _)| {\n                         (ty, AdjustUnsafeFnPointer)\n                     });\n                 }\n                 _ => {}\n             }\n         }\n-        self.unify(a, b)\n+        self.unify_and_identity(a, b)\n     }\n \n     fn coerce_from_fn_item(&self,\n@@ -418,11 +537,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         match b.sty {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx().mk_ty(ty::TyFnPtr(fn_ty_a));\n-                self.unify(a_fn_pointer, b).map(|(ty, _)| {\n+                self.unify_and_identity(a_fn_pointer, b).map(|(ty, _)| {\n                     (ty, AdjustReifyFnPointer)\n                 })\n             }\n-            _ => self.unify(a, b)\n+            _ => self.unify_and_identity(a, b)\n         }\n     }\n \n@@ -439,13 +558,13 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::TyRef(_, mt) => (true, mt),\n             ty::TyRawPtr(mt) => (false, mt),\n             _ => {\n-                return self.unify(a, b);\n+                return self.unify_and_identity(a, b);\n             }\n         };\n \n         // Check that the types which they point at are compatible.\n         let a_unsafe = self.tcx().mk_ptr(ty::TypeAndMut{ mutbl: mutbl_b, ty: mt_a.ty });\n-        let (ty, noop) = try!(self.unify(a_unsafe, b));\n+        let (ty, noop) = try!(self.unify_and_identity(a_unsafe, b));\n         try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n \n         // Although references and unsafe ptrs have the same"}, {"sha": "43255db2ff3ab96ea443117ed3e70fcbebb6cf97", "filename": "src/test/compile-fail/issue-10291.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -11,8 +11,7 @@\n fn test<'x>(x: &'x isize) {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     drop::<Box<for<'z> FnMut(&'z isize) -> &'z isize>>(Box::new(|z| {\n-        x\n-        //~^ ERROR cannot infer an appropriate lifetime\n+        x //~ ERROR E0312\n     }));\n }\n "}, {"sha": "b552d7678d563701f3282fa6ef290365ecc67fc4", "filename": "src/test/compile-fail/issue-13058.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -36,9 +36,5 @@ fn check<'r, I: Iterator<Item=usize>, T: Itble<'r, usize, I>>(cont: &T) -> bool\n fn main() {\n     check((3, 5));\n //~^ ERROR mismatched types\n-//~| expected `&_`\n-//~| found `(_, _)`\n-//~| expected &-ptr\n-//~| found tuple\n //~| HELP run `rustc --explain E0308` to see a detailed explanation\n }"}, {"sha": "d13da1d9fd94817727296b389166f40fe7ceb97f", "filename": "src/test/compile-fail/issue-7573.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -24,11 +24,9 @@ impl CrateId {\n }\n \n pub fn remove_package_from_database() {\n-    let mut lines_to_use: Vec<&CrateId> = Vec::new();\n+    let mut lines_to_use: Vec<&CrateId> = Vec::new(); //~ ERROR E0495\n     let push_id = |installed_id: &CrateId| {\n         lines_to_use.push(installed_id);\n-        //~^ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n-        // conflicting requirements\n     };\n     list_database(push_id);\n "}, {"sha": "e0ea1ed74340783001fd75971980b68550f2e7bd", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-3.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -14,19 +14,19 @@ use std::marker::PhantomData;\n \n struct Bar<'x, 'y, 'z> { bar: &'y i32, baz: i32, marker: PhantomData<(&'x(),&'y(),&'z())> }\n fn bar1<'a>(x: &Bar) -> (&'a i32, &'a i32, &'a i32) {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn bar1<'b, 'c, 'a>(x: &'a Bar<'b, 'a, 'c>) -> (&'a i32, &'a i32, &'a i32)\n+    //~^ HELP: consider using an explicit lifetime parameter as shown: fn bar1<'a>(x: &'a Bar) -> (&'a i32, &'a i32, &'a i32)\n     (x.bar, &x.baz, &x.baz)\n-    //~^ ERROR: cannot infer\n-    //~^^ ERROR: cannot infer\n-    //~^^^ ERROR: cannot infer\n+    //~^ ERROR E0312\n+    //~| ERROR cannot infer\n+    //~| ERROR cannot infer\n }\n \n fn bar2<'a, 'b, 'c>(x: &Bar<'a, 'b, 'c>) -> (&'a i32, &'a i32, &'a i32) {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn bar2<'a, 'c>(x: &'a Bar<'a, 'a, 'c>) -> (&'a i32, &'a i32, &'a i32)\n+    //~^ HELP: consider using an explicit lifetime parameter as shown: fn bar2<'a, 'c>(x: &'a Bar<'a, 'a, 'c>) -> (&'a i32, &'a i32, &'a i32)\n     (x.bar, &x.baz, &x.baz)\n-    //~^ ERROR: cannot infer\n-    //~^^ ERROR: cannot infer\n-    //~^^^ ERROR: cannot infer\n+    //~^ ERROR E0312\n+    //~| ERROR cannot infer\n+    //~| ERROR cannot infer\n }\n \n fn main() { }"}, {"sha": "73d89beb2202f84369e048588a346945b6cd2179", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -39,8 +39,8 @@ struct Cat<'x, T> { cat: &'x isize, t: T }\n struct Dog<'y> { dog: &'y isize }\n \n fn cat2<'x, 'y>(x: Cat<'x, Dog<'y>>) -> &'x isize {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn cat2<'x>(x: Cat<'x, Dog<'x>>) -> &'x isize\n-    x.t.dog //~ ERROR: cannot infer\n+    //~^ HELP consider using an explicit lifetime parameter as shown: fn cat2<'x>(x: Cat<'x, Dog<'x>>) -> &'x isize\n+    x.t.dog //~ ERROR E0312\n }\n \n struct Baz<'x> {\n@@ -49,11 +49,9 @@ struct Baz<'x> {\n \n impl<'a> Baz<'a> {\n     fn baz2<'b>(&self, x: &isize) -> (&'b isize, &'b isize) {\n-         //~^ HELP: parameter as shown: fn baz2<'b>(&self, x: &'b isize) -> (&'a isize, &'a isize)\n-        // The lifetime that gets assigned to `x` seems somewhat random.\n-        // I have disabled this test for the time being. --pcwalton\n-        (self.bar, x) //~ ERROR: cannot infer\n-        //~^ ERROR: cannot infer\n+        //~^ HELP consider using an explicit lifetime parameter as shown: fn baz2<'b>(&self, x: &'b isize) -> (&'a isize, &'a isize)\n+        (self.bar, x) //~ ERROR E0312\n+        //~^ ERROR E0312\n     }\n }\n "}, {"sha": "8d2a0fd07e80a3e4436cb2ff221109491e2be3e3", "filename": "src/test/compile-fail/lub-if.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-if.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -35,14 +35,14 @@ pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n         \"(none)\"\n     } else {\n         let s: &'a str = maybestr.as_ref().unwrap();\n-        s  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to conflicting\n+        s  //~ ERROR E0312\n     }\n }\n \n pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {\n     if maybestr.is_some() {\n         let s: &'a str = maybestr.as_ref().unwrap();\n-        s  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to conflicting\n+        s  //~ ERROR E0312\n     } else {\n         \"(none)\"\n     }"}, {"sha": "b9423feb5c1cde561d8f586ad7a132cf4073c953", "filename": "src/test/compile-fail/lub-match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-match.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -37,8 +37,7 @@ pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n         None => \"(none)\",\n         Some(ref s) => {\n             let s: &'a str = s;\n-            s\n-            //~^ ERROR cannot infer an appropriate lifetime\n+            s //~ ERROR E0312\n         }\n     }\n }\n@@ -47,8 +46,7 @@ pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {\n     match *maybestr {\n         Some(ref s) => {\n             let s: &'a str = s;\n-            s\n-            //~^ ERROR cannot infer an appropriate lifetime\n+            s //~ ERROR E0312\n         }\n         None => \"(none)\",\n     }"}, {"sha": "014b0c1e80e71467da8875a63f55fac28f1bd8dd", "filename": "src/test/compile-fail/object-lifetime-default-mybox.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -34,8 +34,7 @@ fn load1<'a,'b>(a: &'a MyBox<SomeTrait>,\n                 b: &'b MyBox<SomeTrait>)\n                 -> &'b MyBox<SomeTrait>\n {\n-    a\n-      //~^ ERROR cannot infer\n+    a //~ ERROR E0312\n }\n \n fn load2<'a>(ss: &MyBox<SomeTrait+'a>) -> MyBox<SomeTrait+'a> {"}, {"sha": "6364db1f4b49c2e33bf095020ab237b3257144c9", "filename": "src/test/compile-fail/region-lifetime-bounds-on-fns-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -15,7 +15,7 @@ fn a<'a, 'b>(x: &mut &'a isize, y: &mut &'b isize) where 'b: 'a {\n \n fn b<'a, 'b>(x: &mut &'a isize, y: &mut &'b isize) {\n     // Illegal now because there is no `'b:'a` declaration.\n-    *x = *y; //~ ERROR cannot infer\n+    *x = *y; //~ ERROR E0312\n }\n \n fn c<'a,'b>(x: &mut &'a isize, y: &mut &'b isize) {"}, {"sha": "154135eba38baf7bd4cbf6b175429a7824c66c9d", "filename": "src/test/compile-fail/region-multiple-lifetime-bounds-on-fns-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -16,8 +16,8 @@ fn a<'a, 'b, 'c>(x: &mut &'a isize, y: &mut &'b isize, z: &mut &'c isize) where\n \n fn b<'a, 'b, 'c>(x: &mut &'a isize, y: &mut &'b isize, z: &mut &'c isize) {\n     // Illegal now because there is no `'b:'a` declaration.\n-    *x = *y; //~ ERROR cannot infer\n-    *z = *y; //~ ERROR cannot infer\n+    *x = *y; //~ ERROR E0312\n+    *z = *y; //~ ERROR E0312\n }\n \n fn c<'a,'b, 'c>(x: &mut &'a isize, y: &mut &'b isize, z: &mut &'c isize) {"}, {"sha": "8cc35272282c41dbf4b5744e6d7604d59b6c91f9", "filename": "src/test/compile-fail/regions-early-bound-error-method.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -28,8 +28,7 @@ impl<'a> GetRef<'a> for Box<'a> {\n impl<'a> Box<'a> {\n     fn or<'b,G:GetRef<'b>>(&self, g2: G) -> &'a isize {\n         g2.get()\n-        //~^ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n-        //~| ERROR mismatched types\n+        //~^ ERROR mismatched types\n         //~| expected `&'a isize`\n         //~| found `&'b isize`\n         //~| lifetime mismatch"}, {"sha": "1fc3b4b3c6a620279653f39d68b0143be1961817", "filename": "src/test/compile-fail/regions-early-bound-error.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -27,11 +27,7 @@ impl<'a,T:Clone> GetRef<'a,T> for Box<'a,T> {\n \n fn get<'a,'b,G:GetRef<'a, isize>>(g1: G, b: &'b isize) -> &'b isize {\n     g1.get()\n-    //~^ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n-    //~| ERROR mismatched types\n-    //~| expected `&'b isize`\n-    //~| found `&'a isize`\n-    //~| lifetime mismatch\n+    //~^ ERROR mismatched types\n }\n \n fn main() {"}, {"sha": "c2e4fbac3c9416f449a2b19743333245a78ee22b", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -22,9 +22,9 @@ mod argparse {\n \n     impl<'a> Flag<'a> {\n         pub fn set_desc(self, s: &str) -> Flag<'a> {\n-            Flag {\n+            Flag { //~ ERROR cannot infer\n                 name: self.name,\n-                desc: s, //~ ERROR cannot infer an appropriate lifetime for automatic coercion due t\n+                desc: s,\n                 max_count: self.max_count,\n                 value: self.value\n             }"}, {"sha": "89254516ac600554386c34b54394a76c3e80cbdf", "filename": "src/test/compile-fail/regions-lifetime-bounds-on-fns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -15,13 +15,13 @@ fn a<'a, 'b:'a>(x: &mut &'a isize, y: &mut &'b isize) {\n \n fn b<'a, 'b>(x: &mut &'a isize, y: &mut &'b isize) {\n     // Illegal now because there is no `'b:'a` declaration.\n-    *x = *y; //~ ERROR cannot infer\n+    *x = *y; //~ ERROR E0312\n }\n \n fn c<'a,'b>(x: &mut &'a isize, y: &mut &'b isize) {\n     // Here we try to call `foo` but do not know that `'a` and `'b` are\n     // related as required.\n-    a(x, y); //~ ERROR cannot infer\n+    a(x, y); //~ ERROR E0495\n }\n \n fn d() {"}, {"sha": "5ef2a701a6005f37c2c54cfc208ae856bef4fcec", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -14,16 +14,16 @@ fn ignore<T>(t: T) {}\n \n fn nested<'x>(x: &'x isize) {\n     let y = 3;\n-    let mut ay = &y;\n+    let mut ay = &y; //~ ERROR E0495\n \n     ignore::<Box<for<'z> FnMut(&'z isize)>>(Box::new(|z| {\n-        ay = x; //~ ERROR cannot infer\n+        ay = x;\n         ay = &y;\n         ay = z;\n     }));\n \n     ignore::< Box<for<'z> FnMut(&'z isize) -> &'z isize>>(Box::new(|z| {\n-        if false { return x; }  //~ ERROR cannot infer an appropriate lifetime for automatic\n+        if false { return x; } //~ ERROR E0312\n         if false { return ay; }\n         return z;\n     }));"}, {"sha": "de695e72d07e4bab6bb979e71d515313f4764bc8", "filename": "src/test/compile-fail/regions-static-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -13,7 +13,7 @@ fn static_id<'a,'b>(t: &'a ()) -> &'static ()\n fn static_id_indirect<'a,'b>(t: &'a ()) -> &'static ()\n     where 'a: 'b, 'b: 'static { t }\n fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {\n-    t //~ ERROR cannot infer an appropriate lifetime\n+    t //~ ERROR E0312\n }\n \n fn error(u: &(), v: &()) {"}, {"sha": "1e2b01856e71bb923d34fb6557684479e1943042", "filename": "src/test/compile-fail/unboxed-closures-infer-argument-types-two-region-pointers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-argument-types-two-region-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-argument-types-two-region-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-argument-types-two-region-pointers.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -24,6 +24,6 @@ fn doit<T,F>(val: T, f: &F)\n \n pub fn main() {\n     doit(0, &|x, y| {\n-        x.set(y); //~ ERROR cannot infer\n+        x.set(y); //~ ERROR E0312\n     });\n }"}, {"sha": "e99957c79142738ac8ab7df1990ac943ec80dba9", "filename": "src/test/compile-fail/wf-static-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fwf-static-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Fcompile-fail%2Fwf-static-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-static-method.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -24,7 +24,7 @@ struct Evil<'a, 'b: 'a>(Option<&'a &'b ()>);\n impl<'a, 'b> Foo<'a, 'b, Evil<'a, 'b>> for () {\n     fn make_me() -> Self { }\n     fn static_evil(u: &'b u32) -> &'a u32 {\n-        u //~ ERROR cannot infer an appropriate lifetime\n+        u //~ ERROR E0312\n     }\n }\n \n@@ -40,7 +40,7 @@ impl<'a, 'b> Foo<'a, 'b, ()> for IndirectEvil<'a, 'b> {\n \n impl<'a, 'b> Evil<'a, 'b> {\n     fn inherent_evil(u: &'b u32) -> &'a u32 {\n-        u //~ ERROR cannot infer an appropriate lifetime\n+        u //~ ERROR E0312\n     }\n }\n "}, {"sha": "41c64197acbe835d2f2b4ff9119c3e8326dce0bc", "filename": "src/test/run-pass/regions-lub-ref-ref-rc.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Frun-pass%2Fregions-lub-ref-ref-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e8a00514052bf812af0677dde8710336d77cbb/src%2Ftest%2Frun-pass%2Fregions-lub-ref-ref-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-lub-ref-ref-rc.rs?ref=78e8a00514052bf812af0677dde8710336d77cbb", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a corner case of LUB coercion. In this case, one arm of the\n+// match requires a deref coercion and other other doesn't, and there\n+// is an extra `&` on the `rc`. We want to be sure that the lifetime\n+// assigned to this `&rc` value is not `'a` but something smaller.  In\n+// other words, the type from `rc` is `&'a Rc<String>` and the type\n+// from `&rc` should be `&'x &'a Rc<String>`, where `'x` is something\n+// small.\n+\n+use std::rc::Rc;\n+\n+#[derive(Clone)]\n+enum CachedMir<'mir> {\n+    Ref(&'mir String),\n+    Owned(Rc<String>),\n+}\n+\n+impl<'mir> CachedMir<'mir> {\n+    fn get_ref<'a>(&'a self) -> &'a String {\n+        match *self {\n+            CachedMir::Ref(r) => r,\n+            CachedMir::Owned(ref rc) => &rc,\n+        }\n+    }\n+}\n+\n+fn main() { }"}]}