{"sha": "278e5fd2152bfba3234f97560a378bdb03e24a3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OGU1ZmQyMTUyYmZiYTMyMzRmOTc1NjBhMzc4YmRiMDNlMjRhM2Q=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-06-06T14:56:07Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-07-12T20:51:56Z"}, "message": "rustbuild: Improve assert about building tools once\n\nIn developing #61557 I noticed that there were two parts of our tools\nthat were rebuilt twice on CI. One was rustfmt fixed in #61557, but\nanother was Cargo. The actual fix for Cargo's double compile was\nrust-lang/cargo#7010 and took some time to propagate here. In an effort\nto continue to assert that Cargo is itself not compiled twice, I updated\nthe assertion in rustbuild at the time of working on #61557 but couldn't\nland it because the fix wouldn't be ready until the next bootstrap.\n\nThe next bootstrap is now here, so the fix can now land! This does not\nchange the behavior of rustbuild but it is intended to catch the\nprevious iteration of compiling cargo twice. The main update here was to\nconsider more files than those in `$target/release/deps` but also\nconsider those in `$target/release`. That's where, for example,\n`libcargo.rlib` shows up and it's the file we learn about, and that's\nwhat we want to deduplicate.", "tree": {"sha": "e27c7dc3db6f9d7991ddf3172b0aa1954e5fd040", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e27c7dc3db6f9d7991ddf3172b0aa1954e5fd040"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/278e5fd2152bfba3234f97560a378bdb03e24a3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/278e5fd2152bfba3234f97560a378bdb03e24a3d", "html_url": "https://github.com/rust-lang/rust/commit/278e5fd2152bfba3234f97560a378bdb03e24a3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/278e5fd2152bfba3234f97560a378bdb03e24a3d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71f9384e3bec467158a628e2d11e77ffada16a90", "url": "https://api.github.com/repos/rust-lang/rust/commits/71f9384e3bec467158a628e2d11e77ffada16a90", "html_url": "https://github.com/rust-lang/rust/commit/71f9384e3bec467158a628e2d11e77ffada16a90"}], "stats": {"total": 69, "additions": 48, "deletions": 21}, "files": [{"sha": "a9269a7ad24aba7a9f65808b4937bc0605e77690", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/278e5fd2152bfba3234f97560a378bdb03e24a3d/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278e5fd2152bfba3234f97560a378bdb03e24a3d/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=278e5fd2152bfba3234f97560a378bdb03e24a3d", "patch": "@@ -109,36 +109,63 @@ impl Step for ToolBuild {\n                     continue\n                 }\n \n-                // Don't worry about libs that turn out to be host dependencies\n-                // or build scripts, we only care about target dependencies that\n-                // are in `deps`.\n-                if let Some(maybe_target) = val.1\n-                    .parent()                   // chop off file name\n-                    .and_then(|p| p.parent())   // chop off `deps`\n-                    .and_then(|p| p.parent())   // chop off `release`\n-                    .and_then(|p| p.file_name())\n-                    .and_then(|p| p.to_str())\n-                {\n-                    if maybe_target != &*target {\n-                        continue\n+                // Don't worry about compiles that turn out to be host\n+                // dependencies or build scripts. To skip these we look for\n+                // anything that goes in `.../release/deps` but *doesn't* go in\n+                // `$target/release/deps`. This ensure that outputs in\n+                // `$target/release` are still considered candidates for\n+                // deduplication.\n+                if let Some(parent) = val.1.parent() {\n+                    if parent.ends_with(\"release/deps\") {\n+                        let maybe_target = parent\n+                            .parent()\n+                            .and_then(|p| p.parent())\n+                            .and_then(|p| p.file_name())\n+                            .and_then(|p| p.to_str())\n+                            .unwrap();\n+                        if maybe_target != &*target {\n+                            continue;\n+                        }\n                     }\n                 }\n \n+                // Record that we've built an artifact for `id`, and if one was\n+                // already listed then we need to see if we reused the same\n+                // artifact or produced a duplicate.\n                 let mut artifacts = builder.tool_artifacts.borrow_mut();\n                 let prev_artifacts = artifacts\n                     .entry(target)\n                     .or_default();\n-                if let Some(prev) = prev_artifacts.get(&*id) {\n-                    if prev.1 != val.1 {\n-                        duplicates.push((\n-                            id.to_string(),\n-                            val,\n-                            prev.clone(),\n-                        ));\n+                let prev = match prev_artifacts.get(&*id) {\n+                    Some(prev) => prev,\n+                    None => {\n+                        prev_artifacts.insert(id.to_string(), val);\n+                        continue;\n                     }\n-                    return\n+                };\n+                if prev.1 == val.1 {\n+                    return; // same path, same artifact\n                 }\n-                prev_artifacts.insert(id.to_string(), val);\n+\n+                // If the paths are different and one of them *isn't* inside of\n+                // `release/deps`, then it means it's probably in\n+                // `$target/release`, or it's some final artifact like\n+                // `libcargo.rlib`. In these situations Cargo probably just\n+                // copied it up from `$target/release/deps/libcargo-xxxx.rlib`,\n+                // so if the features are equal we can just skip it.\n+                let prev_no_hash = prev.1.parent().unwrap().ends_with(\"release/deps\");\n+                let val_no_hash = val.1.parent().unwrap().ends_with(\"release/deps\");\n+                if prev.2 == val.2 || !prev_no_hash || !val_no_hash {\n+                    return;\n+                }\n+\n+                // ... and otherwise this looks like we duplicated some sort of\n+                // compilation, so record it to generate an error later.\n+                duplicates.push((\n+                    id.to_string(),\n+                    val,\n+                    prev.clone(),\n+                ));\n             }\n         });\n "}]}