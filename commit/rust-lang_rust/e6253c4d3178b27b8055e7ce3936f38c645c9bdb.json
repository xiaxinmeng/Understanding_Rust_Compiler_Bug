{"sha": "e6253c4d3178b27b8055e7ce3936f38c645c9bdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MjUzYzRkMzE3OGIyN2I4MDU1ZTdjZTM5MzZmMzhjNjQ1YzliZGI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-11-13T02:26:33Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-11-13T02:27:16Z"}, "message": "Extract a closures module", "tree": {"sha": "e2437e7578f0ad244a8817af7abb385a4953b331", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2437e7578f0ad244a8817af7abb385a4953b331"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6253c4d3178b27b8055e7ce3936f38c645c9bdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6253c4d3178b27b8055e7ce3936f38c645c9bdb", "html_url": "https://github.com/rust-lang/rust/commit/e6253c4d3178b27b8055e7ce3936f38c645c9bdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6253c4d3178b27b8055e7ce3936f38c645c9bdb/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10bce817d9e9a3d3cbd4ab49d52a3af064e9ce3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/10bce817d9e9a3d3cbd4ab49d52a3af064e9ce3d", "html_url": "https://github.com/rust-lang/rust/commit/10bce817d9e9a3d3cbd4ab49d52a3af064e9ce3d"}], "stats": {"total": 676, "additions": 349, "deletions": 327}, "files": [{"sha": "6eff97af29512c20d7d55b010083408e178d9caa", "filename": "src/closures.rs", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/e6253c4d3178b27b8055e7ce3936f38c645c9bdb/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6253c4d3178b27b8055e7ce3936f38c645c9bdb/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=e6253c4d3178b27b8055e7ce3936f38c645c9bdb", "patch": "@@ -0,0 +1,338 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::{ast, ptr};\n+use syntax::codemap::Span;\n+use syntax::parse::classify;\n+\n+use codemap::SpanUtils;\n+use expr::{block_contains_comment, is_simple_block, is_unsafe_block, need_block_indent,\n+           rewrite_cond, ToExpr};\n+use items::{span_hi_for_arg, span_lo_for_arg};\n+use lists::{definitive_tactic, itemize_list, write_list, DefinitiveListTactic, ListFormatting,\n+            ListTactic, Separator, SeparatorPlace, SeparatorTactic};\n+use rewrite::{Rewrite, RewriteContext};\n+use shape::Shape;\n+use utils::{last_line_width, left_most_sub_expr, stmt_expr};\n+\n+// This functions is pretty messy because of the rules around closures and blocks:\n+// FIXME - the below is probably no longer true in full.\n+//   * if there is a return type, then there must be braces,\n+//   * given a closure with braces, whether that is parsed to give an inner block\n+//     or not depends on if there is a return type and if there are statements\n+//     in that block,\n+//   * if the first expression in the body ends with a block (i.e., is a\n+//     statement without needing a semi-colon), then adding or removing braces\n+//     can change whether it is treated as an expression or statement.\n+pub fn rewrite_closure(\n+    capture: ast::CaptureBy,\n+    fn_decl: &ast::FnDecl,\n+    body: &ast::Expr,\n+    span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n+    debug!(\"rewrite_closure {:?}\", body);\n+\n+    let (prefix, extra_offset) =\n+        rewrite_closure_fn_decl(capture, fn_decl, body, span, context, shape)?;\n+    // 1 = space between `|...|` and body.\n+    let body_shape = shape.offset_left(extra_offset)?;\n+\n+    if let ast::ExprKind::Block(ref block) = body.node {\n+        // The body of the closure is an empty block.\n+        if block.stmts.is_empty() && !block_contains_comment(block, context.codemap) {\n+            return Some(format!(\"{} {{}}\", prefix));\n+        }\n+\n+        let no_return_type = match fn_decl.output {\n+            ast::FunctionRetTy::Default(_) => true,\n+            _ => false,\n+        };\n+\n+        // Figure out if the block is necessary.\n+        let needs_block = is_unsafe_block(block) || block.stmts.len() > 1 || context.inside_macro\n+            || block_contains_comment(block, context.codemap)\n+            || prefix.contains('\\n');\n+\n+        if no_return_type && !needs_block {\n+            // block.stmts.len() == 1\n+            if let Some(expr) = stmt_expr(&block.stmts[0]) {\n+                let result = if is_block_closure_forced(expr) {\n+                    rewrite_closure_with_block(expr, &prefix, context, shape)\n+                } else {\n+                    rewrite_closure_expr(expr, &prefix, context, body_shape)\n+                };\n+                if result.is_some() {\n+                    return result;\n+                }\n+            }\n+        }\n+\n+        // Either we require a block, or tried without and failed.\n+        rewrite_closure_block(block, &prefix, context, body_shape)\n+    } else {\n+        rewrite_closure_expr(body, &prefix, context, body_shape).or_else(|| {\n+            // The closure originally had a non-block expression, but we can't fit on\n+            // one line, so we'll insert a block.\n+            rewrite_closure_with_block(body, &prefix, context, body_shape)\n+        })\n+    }\n+}\n+\n+// Rewrite closure with a single expression wrapping its body with block.\n+fn rewrite_closure_with_block(\n+    body: &ast::Expr,\n+    prefix: &str,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n+    let block = ast::Block {\n+        stmts: vec![\n+            ast::Stmt {\n+                id: ast::NodeId::new(0),\n+                node: ast::StmtKind::Expr(ptr::P(body.clone())),\n+                span: body.span,\n+            },\n+        ],\n+        id: ast::NodeId::new(0),\n+        rules: ast::BlockCheckMode::Default,\n+        span: body.span,\n+    };\n+    rewrite_closure_block(&block, prefix, context, shape)\n+}\n+\n+// Rewrite closure with a single expression without wrapping its body with block.\n+fn rewrite_closure_expr(\n+    expr: &ast::Expr,\n+    prefix: &str,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n+    let mut rewrite = expr.rewrite(context, shape);\n+    if classify::expr_requires_semi_to_be_stmt(left_most_sub_expr(expr)) {\n+        rewrite = and_one_line(rewrite);\n+    }\n+    rewrite = rewrite.and_then(|rw| {\n+        if context.config.multiline_closure_forces_block() && rw.contains('\\n') {\n+            None\n+        } else {\n+            Some(rw)\n+        }\n+    });\n+    rewrite.map(|rw| format!(\"{} {}\", prefix, rw))\n+}\n+\n+// Rewrite closure whose body is block.\n+fn rewrite_closure_block(\n+    block: &ast::Block,\n+    prefix: &str,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n+    // Start with visual indent, then fall back to block indent if the\n+    // closure is large.\n+    let block_threshold = context.config.closure_block_indent_threshold();\n+    if block_threshold >= 0 {\n+        if let Some(block_str) = block.rewrite(context, shape) {\n+            if block_str.matches('\\n').count() <= block_threshold as usize\n+                && !need_block_indent(&block_str, shape)\n+            {\n+                return Some(format!(\"{} {}\", prefix, block_str));\n+            }\n+        }\n+    }\n+\n+    // The body of the closure is big enough to be block indented, that\n+    // means we must re-format.\n+    let block_shape = shape.block();\n+    let block_str = block.rewrite(context, block_shape)?;\n+    Some(format!(\"{} {}\", prefix, block_str))\n+}\n+\n+// Return type is (prefix, extra_offset)\n+fn rewrite_closure_fn_decl(\n+    capture: ast::CaptureBy,\n+    fn_decl: &ast::FnDecl,\n+    body: &ast::Expr,\n+    span: Span,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<(String, usize)> {\n+    let mover = if capture == ast::CaptureBy::Value {\n+        \"move \"\n+    } else {\n+        \"\"\n+    };\n+    // 4 = \"|| {\".len(), which is overconservative when the closure consists of\n+    // a single expression.\n+    let nested_shape = shape.shrink_left(mover.len())?.sub_width(4)?;\n+\n+    // 1 = |\n+    let argument_offset = nested_shape.indent + 1;\n+    let arg_shape = nested_shape.offset_left(1)?.visual_indent(0);\n+    let ret_str = fn_decl.output.rewrite(context, arg_shape)?;\n+\n+    let arg_items = itemize_list(\n+        context.codemap,\n+        fn_decl.inputs.iter(),\n+        \"|\",\n+        |arg| span_lo_for_arg(arg),\n+        |arg| span_hi_for_arg(context, arg),\n+        |arg| arg.rewrite(context, arg_shape),\n+        context.codemap.span_after(span, \"|\"),\n+        body.span.lo(),\n+        false,\n+    );\n+    let item_vec = arg_items.collect::<Vec<_>>();\n+    // 1 = space between arguments and return type.\n+    let horizontal_budget = nested_shape\n+        .width\n+        .checked_sub(ret_str.len() + 1)\n+        .unwrap_or(0);\n+    let tactic = definitive_tactic(\n+        &item_vec,\n+        ListTactic::HorizontalVertical,\n+        Separator::Comma,\n+        horizontal_budget,\n+    );\n+    let arg_shape = match tactic {\n+        DefinitiveListTactic::Horizontal => arg_shape.sub_width(ret_str.len() + 1)?,\n+        _ => arg_shape,\n+    };\n+\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \",\",\n+        trailing_separator: SeparatorTactic::Never,\n+        separator_place: SeparatorPlace::Back,\n+        shape: arg_shape,\n+        ends_with_newline: false,\n+        preserve_newline: true,\n+        config: context.config,\n+    };\n+    let list_str = write_list(&item_vec, &fmt)?;\n+    let mut prefix = format!(\"{}|{}|\", mover, list_str);\n+\n+    if !ret_str.is_empty() {\n+        if prefix.contains('\\n') {\n+            prefix.push('\\n');\n+            prefix.push_str(&argument_offset.to_string(context.config));\n+        } else {\n+            prefix.push(' ');\n+        }\n+        prefix.push_str(&ret_str);\n+    }\n+    // 1 = space between `|...|` and body.\n+    let extra_offset = last_line_width(&prefix) + 1;\n+\n+    Some((prefix, extra_offset))\n+}\n+\n+// Rewriting closure which is placed at the end of the function call's arg.\n+// Returns `None` if the reformatted closure 'looks bad'.\n+pub fn rewrite_last_closure(\n+    context: &RewriteContext,\n+    expr: &ast::Expr,\n+    shape: Shape,\n+) -> Option<String> {\n+    if let ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) = expr.node {\n+        let body = match body.node {\n+            ast::ExprKind::Block(ref block) if is_simple_block(block, context.codemap) => {\n+                stmt_expr(&block.stmts[0]).unwrap_or(body)\n+            }\n+            _ => body,\n+        };\n+        let (prefix, extra_offset) =\n+            rewrite_closure_fn_decl(capture, fn_decl, body, expr.span, context, shape)?;\n+        // If the closure goes multi line before its body, do not overflow the closure.\n+        if prefix.contains('\\n') {\n+            return None;\n+        }\n+        // If we are inside macro, we do not want to add or remove block from closure body.\n+        if context.inside_macro {\n+            return expr.rewrite(context, shape);\n+        }\n+\n+        let body_shape = shape.offset_left(extra_offset)?;\n+\n+        // We force to use block for the body of the closure for certain kinds of expressions.\n+        if is_block_closure_forced(body) {\n+            return rewrite_closure_with_block(body, &prefix, context, body_shape).and_then(\n+                |body_str| {\n+                    // If the expression can fit in a single line, we need not force block closure.\n+                    if body_str.lines().count() <= 7 {\n+                        match rewrite_closure_expr(body, &prefix, context, shape) {\n+                            Some(ref single_line_body_str)\n+                                if !single_line_body_str.contains('\\n') =>\n+                            {\n+                                Some(single_line_body_str.clone())\n+                            }\n+                            _ => Some(body_str),\n+                        }\n+                    } else {\n+                        Some(body_str)\n+                    }\n+                },\n+            );\n+        }\n+\n+        // When overflowing the closure which consists of a single control flow expression,\n+        // force to use block if its condition uses multi line.\n+        let is_multi_lined_cond = rewrite_cond(context, body, body_shape)\n+            .map(|cond| cond.contains('\\n') || cond.len() > body_shape.width)\n+            .unwrap_or(false);\n+        if is_multi_lined_cond {\n+            return rewrite_closure_with_block(body, &prefix, context, body_shape);\n+        }\n+\n+        // Seems fine, just format the closure in usual manner.\n+        return expr.rewrite(context, shape);\n+    }\n+    None\n+}\n+\n+/// Returns true if the given vector of arguments has more than one `ast::ExprKind::Closure`.\n+pub fn args_have_many_closure<T>(args: &[&T]) -> bool\n+where\n+    T: ToExpr,\n+{\n+    args.iter()\n+        .filter(|arg| {\n+            arg.to_expr()\n+                .map(|e| match e.node {\n+                    ast::ExprKind::Closure(..) => true,\n+                    _ => false,\n+                })\n+                .unwrap_or(false)\n+        })\n+        .count() > 1\n+}\n+\n+fn is_block_closure_forced(expr: &ast::Expr) -> bool {\n+    match expr.node {\n+        ast::ExprKind::If(..) |\n+        ast::ExprKind::IfLet(..) |\n+        ast::ExprKind::Loop(..) |\n+        ast::ExprKind::While(..) |\n+        ast::ExprKind::WhileLet(..) |\n+        ast::ExprKind::ForLoop(..) => true,\n+        ast::ExprKind::AddrOf(_, ref expr) |\n+        ast::ExprKind::Box(ref expr) |\n+        ast::ExprKind::Try(ref expr) |\n+        ast::ExprKind::Unary(_, ref expr) |\n+        ast::ExprKind::Cast(ref expr, _) => is_block_closure_forced(expr),\n+        _ => false,\n+    }\n+}\n+\n+fn and_one_line(x: Option<String>) -> Option<String> {\n+    x.and_then(|x| if x.contains('\\n') { None } else { Some(x) })\n+}"}, {"sha": "bea5fab17fadc278c9917305f868e11d68852aae", "filename": "src/expr.rs", "status": "modified", "additions": 10, "deletions": 327, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/e6253c4d3178b27b8055e7ce3936f38c645c9bdb/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6253c4d3178b27b8055e7ce3936f38c645c9bdb/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=e6253c4d3178b27b8055e7ce3936f38c645c9bdb", "patch": "@@ -14,15 +14,14 @@ use std::iter::{repeat, ExactSizeIterator};\n \n use syntax::{ast, ptr};\n use syntax::codemap::{BytePos, CodeMap, Span};\n-use syntax::parse::classify;\n \n use spanned::Spanned;\n use chains::rewrite_chain;\n+use closures;\n use codemap::{LineRangeUtils, SpanUtils};\n use comment::{combine_strs_with_missing_comments, contains_comment, recover_comment_removed,\n               rewrite_comment, rewrite_missing_comment, FindUncommented};\n use config::{Config, ControlBraceStyle, IndentStyle, MultilineStyle, Style};\n-use items::{span_hi_for_arg, span_lo_for_arg};\n use lists::{definitive_tactic, itemize_list, shape_for_tactic, struct_lit_formatting,\n             struct_lit_shape, struct_lit_tactic, write_list, DefinitiveListTactic, ListFormatting,\n             ListItem, ListTactic, Separator, SeparatorPlace, SeparatorTactic};\n@@ -33,9 +32,8 @@ use shape::{Indent, Shape};\n use string::{rewrite_string, StringFormat};\n use types::{can_be_overflowed_type, rewrite_path, PathContext};\n use utils::{colon_spaces, contains_skip, extra_offset, first_line_width, inner_attributes,\n-            last_line_extendable, last_line_width, left_most_sub_expr, mk_sp, outer_attributes,\n-            paren_overhead, ptr_vec_to_ref_vec, semicolon_for_stmt, stmt_expr,\n-            trimmed_last_line_width, wrap_str};\n+            last_line_extendable, last_line_width, mk_sp, outer_attributes, paren_overhead,\n+            ptr_vec_to_ref_vec, semicolon_for_stmt, trimmed_last_line_width, wrap_str};\n use vertical::rewrite_with_alignment;\n use visitor::FmtVisitor;\n \n@@ -161,7 +159,7 @@ pub fn format_expr(\n             Some(\"yield\".to_string())\n         },\n         ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) => {\n-            rewrite_closure(capture, fn_decl, body, expr.span, context, shape)\n+            closures::rewrite_closure(capture, fn_decl, body, expr.span, context, shape)\n         }\n         ast::ExprKind::Try(..) |\n         ast::ExprKind::Field(..) |\n@@ -520,224 +518,6 @@ where\n     Some(result)\n }\n \n-// Return type is (prefix, extra_offset)\n-fn rewrite_closure_fn_decl(\n-    capture: ast::CaptureBy,\n-    fn_decl: &ast::FnDecl,\n-    body: &ast::Expr,\n-    span: Span,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> Option<(String, usize)> {\n-    let mover = if capture == ast::CaptureBy::Value {\n-        \"move \"\n-    } else {\n-        \"\"\n-    };\n-    // 4 = \"|| {\".len(), which is overconservative when the closure consists of\n-    // a single expression.\n-    let nested_shape = shape.shrink_left(mover.len())?.sub_width(4)?;\n-\n-    // 1 = |\n-    let argument_offset = nested_shape.indent + 1;\n-    let arg_shape = nested_shape.offset_left(1)?.visual_indent(0);\n-    let ret_str = fn_decl.output.rewrite(context, arg_shape)?;\n-\n-    let arg_items = itemize_list(\n-        context.codemap,\n-        fn_decl.inputs.iter(),\n-        \"|\",\n-        |arg| span_lo_for_arg(arg),\n-        |arg| span_hi_for_arg(context, arg),\n-        |arg| arg.rewrite(context, arg_shape),\n-        context.codemap.span_after(span, \"|\"),\n-        body.span.lo(),\n-        false,\n-    );\n-    let item_vec = arg_items.collect::<Vec<_>>();\n-    // 1 = space between arguments and return type.\n-    let horizontal_budget = nested_shape\n-        .width\n-        .checked_sub(ret_str.len() + 1)\n-        .unwrap_or(0);\n-    let tactic = definitive_tactic(\n-        &item_vec,\n-        ListTactic::HorizontalVertical,\n-        Separator::Comma,\n-        horizontal_budget,\n-    );\n-    let arg_shape = match tactic {\n-        DefinitiveListTactic::Horizontal => arg_shape.sub_width(ret_str.len() + 1)?,\n-        _ => arg_shape,\n-    };\n-\n-    let fmt = ListFormatting {\n-        tactic: tactic,\n-        separator: \",\",\n-        trailing_separator: SeparatorTactic::Never,\n-        separator_place: SeparatorPlace::Back,\n-        shape: arg_shape,\n-        ends_with_newline: false,\n-        preserve_newline: true,\n-        config: context.config,\n-    };\n-    let list_str = write_list(&item_vec, &fmt)?;\n-    let mut prefix = format!(\"{}|{}|\", mover, list_str);\n-\n-    if !ret_str.is_empty() {\n-        if prefix.contains('\\n') {\n-            prefix.push('\\n');\n-            prefix.push_str(&argument_offset.to_string(context.config));\n-        } else {\n-            prefix.push(' ');\n-        }\n-        prefix.push_str(&ret_str);\n-    }\n-    // 1 = space between `|...|` and body.\n-    let extra_offset = last_line_width(&prefix) + 1;\n-\n-    Some((prefix, extra_offset))\n-}\n-\n-// This functions is pretty messy because of the rules around closures and blocks:\n-// FIXME - the below is probably no longer true in full.\n-//   * if there is a return type, then there must be braces,\n-//   * given a closure with braces, whether that is parsed to give an inner block\n-//     or not depends on if there is a return type and if there are statements\n-//     in that block,\n-//   * if the first expression in the body ends with a block (i.e., is a\n-//     statement without needing a semi-colon), then adding or removing braces\n-//     can change whether it is treated as an expression or statement.\n-fn rewrite_closure(\n-    capture: ast::CaptureBy,\n-    fn_decl: &ast::FnDecl,\n-    body: &ast::Expr,\n-    span: Span,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> Option<String> {\n-    debug!(\"rewrite_closure {:?}\", body);\n-\n-    let (prefix, extra_offset) =\n-        rewrite_closure_fn_decl(capture, fn_decl, body, span, context, shape)?;\n-    // 1 = space between `|...|` and body.\n-    let body_shape = shape.offset_left(extra_offset)?;\n-\n-    if let ast::ExprKind::Block(ref block) = body.node {\n-        // The body of the closure is an empty block.\n-        if block.stmts.is_empty() && !block_contains_comment(block, context.codemap) {\n-            return Some(format!(\"{} {{}}\", prefix));\n-        }\n-\n-        let no_return_type = match fn_decl.output {\n-            ast::FunctionRetTy::Default(_) => true,\n-            _ => false,\n-        };\n-\n-        // Figure out if the block is necessary.\n-        let needs_block = is_unsafe_block(block) || block.stmts.len() > 1 || context.inside_macro\n-            || block_contains_comment(block, context.codemap)\n-            || prefix.contains('\\n');\n-\n-        if no_return_type && !needs_block {\n-            // block.stmts.len() == 1\n-            if let Some(expr) = stmt_expr(&block.stmts[0]) {\n-                let result = if is_block_closure_forced(expr) {\n-                    rewrite_closure_with_block(expr, &prefix, context, shape)\n-                } else {\n-                    rewrite_closure_expr(expr, &prefix, context, body_shape)\n-                };\n-                if result.is_some() {\n-                    return result;\n-                }\n-            }\n-        }\n-\n-        // Either we require a block, or tried without and failed.\n-        rewrite_closure_block(block, &prefix, context, body_shape)\n-    } else {\n-        rewrite_closure_expr(body, &prefix, context, body_shape).or_else(|| {\n-            // The closure originally had a non-block expression, but we can't fit on\n-            // one line, so we'll insert a block.\n-            rewrite_closure_with_block(body, &prefix, context, body_shape)\n-        })\n-    }\n-}\n-\n-// Rewrite closure with a single expression wrapping its body with block.\n-fn rewrite_closure_with_block(\n-    body: &ast::Expr,\n-    prefix: &str,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> Option<String> {\n-    let block = ast::Block {\n-        stmts: vec![\n-            ast::Stmt {\n-                id: ast::NodeId::new(0),\n-                node: ast::StmtKind::Expr(ptr::P(body.clone())),\n-                span: body.span,\n-            },\n-        ],\n-        id: ast::NodeId::new(0),\n-        rules: ast::BlockCheckMode::Default,\n-        span: body.span,\n-    };\n-    rewrite_closure_block(&block, prefix, context, shape)\n-}\n-\n-// Rewrite closure with a single expression without wrapping its body with block.\n-fn rewrite_closure_expr(\n-    expr: &ast::Expr,\n-    prefix: &str,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> Option<String> {\n-    let mut rewrite = expr.rewrite(context, shape);\n-    if classify::expr_requires_semi_to_be_stmt(left_most_sub_expr(expr)) {\n-        rewrite = and_one_line(rewrite);\n-    }\n-    rewrite = rewrite.and_then(|rw| {\n-        if context.config.multiline_closure_forces_block() && rw.contains('\\n') {\n-            None\n-        } else {\n-            Some(rw)\n-        }\n-    });\n-    rewrite.map(|rw| format!(\"{} {}\", prefix, rw))\n-}\n-\n-// Rewrite closure whose body is block.\n-fn rewrite_closure_block(\n-    block: &ast::Block,\n-    prefix: &str,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> Option<String> {\n-    // Start with visual indent, then fall back to block indent if the\n-    // closure is large.\n-    let block_threshold = context.config.closure_block_indent_threshold();\n-    if block_threshold >= 0 {\n-        if let Some(block_str) = block.rewrite(context, shape) {\n-            if block_str.matches('\\n').count() <= block_threshold as usize\n-                && !need_block_indent(&block_str, shape)\n-            {\n-                return Some(format!(\"{} {}\", prefix, block_str));\n-            }\n-        }\n-    }\n-\n-    // The body of the closure is big enough to be block indented, that\n-    // means we must re-format.\n-    let block_shape = shape.block();\n-    let block_str = block.rewrite(context, block_shape)?;\n-    Some(format!(\"{} {}\", prefix, block_str))\n-}\n-\n-fn and_one_line(x: Option<String>) -> Option<String> {\n-    x.and_then(|x| if x.contains('\\n') { None } else { Some(x) })\n-}\n-\n fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String> {\n     debug!(\"nop_block_collapse {:?} {}\", block_str, budget);\n     block_str.map(|block_str| {\n@@ -893,7 +673,7 @@ impl Rewrite for ast::Stmt {\n }\n \n // Rewrite condition if the given expression has one.\n-fn rewrite_cond(context: &RewriteContext, expr: &ast::Expr, shape: Shape) -> Option<String> {\n+pub fn rewrite_cond(context: &RewriteContext, expr: &ast::Expr, shape: Shape) -> Option<String> {\n     match expr.node {\n         ast::ExprKind::Match(ref cond, _) => {\n             // `match `cond` {`\n@@ -1383,7 +1163,7 @@ fn extract_comment(span: Span, context: &RewriteContext, shape: Shape) -> Option\n     }\n }\n \n-fn block_contains_comment(block: &ast::Block, codemap: &CodeMap) -> bool {\n+pub fn block_contains_comment(block: &ast::Block, codemap: &CodeMap) -> bool {\n     let snippet = codemap.span_to_snippet(block.span).unwrap();\n     contains_comment(&snippet)\n }\n@@ -1413,7 +1193,7 @@ pub fn stmt_is_expr(stmt: &ast::Stmt) -> bool {\n     }\n }\n \n-fn is_unsafe_block(block: &ast::Block) -> bool {\n+pub fn is_unsafe_block(block: &ast::Block) -> bool {\n     if let ast::BlockCheckMode::Unsafe(..) = block.rules {\n         true\n     } else {\n@@ -2071,7 +1851,7 @@ where\n     ))\n }\n \n-fn need_block_indent(s: &str, shape: Shape) -> bool {\n+pub fn need_block_indent(s: &str, shape: Shape) -> bool {\n     s.lines().skip(1).any(|s| {\n         s.find(|c| !char::is_whitespace(c))\n             .map_or(false, |w| w + 1 < shape.indent.width())\n@@ -2228,86 +2008,6 @@ fn last_arg_shape(\n     })\n }\n \n-// Rewriting closure which is placed at the end of the function call's arg.\n-// Returns `None` if the reformatted closure 'looks bad'.\n-fn rewrite_last_closure(\n-    context: &RewriteContext,\n-    expr: &ast::Expr,\n-    shape: Shape,\n-) -> Option<String> {\n-    if let ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) = expr.node {\n-        let body = match body.node {\n-            ast::ExprKind::Block(ref block) if is_simple_block(block, context.codemap) => {\n-                stmt_expr(&block.stmts[0]).unwrap_or(body)\n-            }\n-            _ => body,\n-        };\n-        let (prefix, extra_offset) =\n-            rewrite_closure_fn_decl(capture, fn_decl, body, expr.span, context, shape)?;\n-        // If the closure goes multi line before its body, do not overflow the closure.\n-        if prefix.contains('\\n') {\n-            return None;\n-        }\n-        // If we are inside macro, we do not want to add or remove block from closure body.\n-        if context.inside_macro {\n-            return expr.rewrite(context, shape);\n-        }\n-\n-        let body_shape = shape.offset_left(extra_offset)?;\n-\n-        // We force to use block for the body of the closure for certain kinds of expressions.\n-        if is_block_closure_forced(body) {\n-            return rewrite_closure_with_block(body, &prefix, context, body_shape).and_then(\n-                |body_str| {\n-                    // If the expression can fit in a single line, we need not force block closure.\n-                    if body_str.lines().count() <= 7 {\n-                        match rewrite_closure_expr(body, &prefix, context, shape) {\n-                            Some(ref single_line_body_str)\n-                                if !single_line_body_str.contains('\\n') =>\n-                            {\n-                                Some(single_line_body_str.clone())\n-                            }\n-                            _ => Some(body_str),\n-                        }\n-                    } else {\n-                        Some(body_str)\n-                    }\n-                },\n-            );\n-        }\n-\n-        // When overflowing the closure which consists of a single control flow expression,\n-        // force to use block if its condition uses multi line.\n-        let is_multi_lined_cond = rewrite_cond(context, body, body_shape)\n-            .map(|cond| cond.contains('\\n') || cond.len() > body_shape.width)\n-            .unwrap_or(false);\n-        if is_multi_lined_cond {\n-            return rewrite_closure_with_block(body, &prefix, context, body_shape);\n-        }\n-\n-        // Seems fine, just format the closure in usual manner.\n-        return expr.rewrite(context, shape);\n-    }\n-    None\n-}\n-\n-fn is_block_closure_forced(expr: &ast::Expr) -> bool {\n-    match expr.node {\n-        ast::ExprKind::If(..) |\n-        ast::ExprKind::IfLet(..) |\n-        ast::ExprKind::Loop(..) |\n-        ast::ExprKind::While(..) |\n-        ast::ExprKind::WhileLet(..) |\n-        ast::ExprKind::ForLoop(..) => true,\n-        ast::ExprKind::AddrOf(_, ref expr) |\n-        ast::ExprKind::Box(ref expr) |\n-        ast::ExprKind::Try(ref expr) |\n-        ast::ExprKind::Unary(_, ref expr) |\n-        ast::ExprKind::Cast(ref expr, _) => is_block_closure_forced(expr),\n-        _ => false,\n-    }\n-}\n-\n fn rewrite_last_arg_with_overflow<'a, T>(\n     context: &RewriteContext,\n     args: &[&T],\n@@ -2325,10 +2025,10 @@ where\n             ast::ExprKind::Closure(..) => {\n                 // If the argument consists of multiple closures, we do not overflow\n                 // the last closure.\n-                if args_have_many_closure(args) {\n+                if closures::args_have_many_closure(args) {\n                     None\n                 } else {\n-                    rewrite_last_closure(context, expr, shape)\n+                    closures::rewrite_last_closure(context, expr, shape)\n                 }\n             }\n             _ => expr.rewrite(context, shape),\n@@ -2346,23 +2046,6 @@ where\n     }\n }\n \n-/// Returns true if the given vector of arguments has more than one `ast::ExprKind::Closure`.\n-fn args_have_many_closure<T>(args: &[&T]) -> bool\n-where\n-    T: ToExpr,\n-{\n-    args.iter()\n-        .filter(|arg| {\n-            arg.to_expr()\n-                .map(|e| match e.node {\n-                    ast::ExprKind::Closure(..) => true,\n-                    _ => false,\n-                })\n-                .unwrap_or(false)\n-        })\n-        .count() > 1\n-}\n-\n fn can_be_overflowed<'a, T>(context: &RewriteContext, args: &[&T]) -> bool\n where\n     T: Rewrite + Spanned + ToExpr + 'a,"}, {"sha": "771fe785339557a6d1aa6a0f12b51c33d1dd069f", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6253c4d3178b27b8055e7ce3936f38c645c9bdb/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6253c4d3178b27b8055e7ce3936f38c645c9bdb/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e6253c4d3178b27b8055e7ce3936f38c645c9bdb", "patch": "@@ -59,6 +59,7 @@ pub mod filemap;\n pub mod file_lines;\n pub mod visitor;\n mod checkstyle;\n+mod closures;\n mod items;\n mod missed_spans;\n mod lists;"}]}