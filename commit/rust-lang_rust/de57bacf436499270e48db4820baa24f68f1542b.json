{"sha": "de57bacf436499270e48db4820baa24f68f1542b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNTdiYWNmNDM2NDk5MjcwZTQ4ZGI0ODIwYmFhMjRmNjhmMTU0MmI=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2013-02-17T07:51:55Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2013-02-17T10:25:26Z"}, "message": "libsyntax: Explicit-self-ify pipes compiler.", "tree": {"sha": "3a45ab8d84101aea8ecc44123a2d62f85ad593b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a45ab8d84101aea8ecc44123a2d62f85ad593b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de57bacf436499270e48db4820baa24f68f1542b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de57bacf436499270e48db4820baa24f68f1542b", "html_url": "https://github.com/rust-lang/rust/commit/de57bacf436499270e48db4820baa24f68f1542b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de57bacf436499270e48db4820baa24f68f1542b/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0126af314463a84f8e3f4c0247e940db71b53fa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0126af314463a84f8e3f4c0247e940db71b53fa4", "html_url": "https://github.com/rust-lang/rust/commit/0126af314463a84f8e3f4c0247e940db71b53fa4"}], "stats": {"total": 232, "additions": 110, "deletions": 122}, "files": [{"sha": "661a2dd667902be4be550583d28160f57e2472b1", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 60, "deletions": 65, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/de57bacf436499270e48db4820baa24f68f1542b/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de57bacf436499270e48db4820baa24f68f1542b/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=de57bacf436499270e48db4820baa24f68f1542b", "patch": "@@ -67,65 +67,65 @@ pub impl append_types for @ast::path {\n }\n \n pub trait ext_ctxt_ast_builder {\n-    fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n+    fn ty_param(&self, id: ast::ident, +bounds: ~[ast::ty_param_bound])\n         -> ast::ty_param;\n-    fn arg(name: ident, ty: @ast::Ty) -> ast::arg;\n-    fn expr_block(e: @ast::expr) -> ast::blk;\n-    fn fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n-    fn item(name: ident, span: span, +node: ast::item_) -> @ast::item;\n-    fn item_fn_poly(name: ident,\n+    fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg;\n+    fn expr_block(&self, e: @ast::expr) -> ast::blk;\n+    fn fn_decl(&self, +inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n+    fn item(&self, name: ident, span: span, +node: ast::item_) -> @ast::item;\n+    fn item_fn_poly(&self, name: ident,\n                     +inputs: ~[ast::arg],\n                     output: @ast::Ty,\n                     +ty_params: ~[ast::ty_param],\n                     +body: ast::blk) -> @ast::item;\n-    fn item_fn(name: ident,\n+    fn item_fn(&self, name: ident,\n                +inputs: ~[ast::arg],\n                output: @ast::Ty,\n                +body: ast::blk) -> @ast::item;\n-    fn item_enum_poly(name: ident,\n+    fn item_enum_poly(&self, name: ident,\n                       span: span,\n                       +enum_definition: ast::enum_def,\n                       +ty_params: ~[ast::ty_param]) -> @ast::item;\n-    fn item_enum(name: ident, span: span,\n+    fn item_enum(&self, name: ident, span: span,\n                  +enum_definition: ast::enum_def) -> @ast::item;\n-    fn item_struct_poly(name: ident, span: span,\n+    fn item_struct_poly(&self, name: ident, span: span,\n                         struct_def: ast::struct_def,\n                         ty_params: ~[ast::ty_param]) -> @ast::item;\n-    fn item_struct(name: ident, span: span,\n+    fn item_struct(&self, name: ident, span: span,\n                    struct_def: ast::struct_def) -> @ast::item;\n-    fn struct_expr(path: @ast::path, fields: ~[ast::field]) -> @ast::expr;\n-    fn variant(name: ident, span: span, +tys: ~[@ast::Ty]) -> ast::variant;\n-    fn item_mod(name: ident, span: span, +items: ~[@ast::item]) -> @ast::item;\n-    fn ty_path_ast_builder(path: @ast::path) -> @ast::Ty;\n-    fn item_ty_poly(name: ident,\n+    fn struct_expr(&self, path: @ast::path, fields: ~[ast::field]) -> @ast::expr;\n+    fn variant(&self, name: ident, span: span, +tys: ~[@ast::Ty]) -> ast::variant;\n+    fn item_mod(&self, name: ident, span: span, +items: ~[@ast::item]) -> @ast::item;\n+    fn ty_path_ast_builder(&self, path: @ast::path) -> @ast::Ty;\n+    fn item_ty_poly(&self, name: ident,\n                     span: span,\n                     ty: @ast::Ty,\n                     +params: ~[ast::ty_param]) -> @ast::item;\n-    fn item_ty(name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n-    fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::Ty];\n-    fn ty_vars_global(+ty_params: ~[ast::ty_param]) -> ~[@ast::Ty];\n-    fn ty_field_imm(name: ident, ty: @ast::Ty) -> ast::ty_field;\n-    fn field_imm(name: ident, e: @ast::expr) -> ast::field;\n-    fn block(+stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n-    fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt;\n-    fn stmt_expr(e: @ast::expr) -> @ast::stmt;\n-    fn block_expr(b: ast::blk) -> @ast::expr;\n-    fn ty_option(ty: @ast::Ty) -> @ast::Ty;\n-    fn ty_infer() -> @ast::Ty;\n-    fn ty_nil_ast_builder() -> @ast::Ty;\n-    fn strip_bounds(bounds: &[ast::ty_param]) -> ~[ast::ty_param];\n+    fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n+    fn ty_vars(&self, +ty_params: ~[ast::ty_param]) -> ~[@ast::Ty];\n+    fn ty_vars_global(&self, +ty_params: ~[ast::ty_param]) -> ~[@ast::Ty];\n+    fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field;\n+    fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field;\n+    fn block(&self, +stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n+    fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt;\n+    fn stmt_expr(&self, e: @ast::expr) -> @ast::stmt;\n+    fn block_expr(&self, b: ast::blk) -> @ast::expr;\n+    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n+    fn ty_infer(&self) -> @ast::Ty;\n+    fn ty_nil_ast_builder(&self) -> @ast::Ty;\n+    fn strip_bounds(&self, bounds: &[ast::ty_param]) -> ~[ast::ty_param];\n }\n \n pub impl ext_ctxt_ast_builder for ext_ctxt {\n-    fn ty_option(ty: @ast::Ty) -> @ast::Ty {\n+    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n         self.ty_path_ast_builder(path_global(~[\n             self.ident_of(~\"core\"),\n             self.ident_of(~\"option\"),\n             self.ident_of(~\"Option\")\n         ], dummy_sp()).add_ty(ty))\n     }\n \n-    fn block_expr(b: ast::blk) -> @ast::expr {\n+    fn block_expr(&self, b: ast::blk) -> @ast::expr {\n         @expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),\n@@ -134,24 +134,24 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn stmt_expr(e: @ast::expr) -> @ast::stmt {\n+    fn stmt_expr(&self, e: @ast::expr) -> @ast::stmt {\n         @spanned { node: ast::stmt_expr(e, self.next_id()),\n                    span: dummy_sp()}\n     }\n \n-    fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt {\n-        let ext_cx = self;\n+    fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt {\n+        let ext_cx = *self;\n         quote_stmt!( let $ident = $e; )\n     }\n \n-    fn field_imm(name: ident, e: @ast::expr) -> ast::field {\n+    fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field {\n         spanned {\n             node: ast::field_ { mutbl: ast::m_imm, ident: name, expr: e },\n             span: dummy_sp(),\n         }\n     }\n \n-    fn ty_field_imm(name: ident, ty: @ast::Ty) -> ast::ty_field {\n+    fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field {\n         spanned {\n             node: ast::ty_field_ {\n                 ident: name,\n@@ -161,21 +161,21 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn ty_infer() -> @ast::Ty {\n+    fn ty_infer(&self) -> @ast::Ty {\n         @ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_infer,\n             span: dummy_sp(),\n         }\n     }\n \n-    fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n+    fn ty_param(&self, id: ast::ident, +bounds: ~[ast::ty_param_bound])\n         -> ast::ty_param\n     {\n         ast::ty_param { ident: id, id: self.next_id(), bounds: @bounds }\n     }\n \n-    fn arg(name: ident, ty: @ast::Ty) -> ast::arg {\n+    fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg {\n         ast::arg {\n             mode: ast::infer(self.next_id()),\n             is_mutbl: false,\n@@ -192,7 +192,7 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn block(+stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n+    fn block(&self, +stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n         let blk = ast::blk_ {\n             view_items: ~[],\n             stmts: stmts,\n@@ -204,11 +204,11 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         spanned { node: blk, span: dummy_sp() }\n     }\n \n-    fn expr_block(e: @ast::expr) -> ast::blk {\n+    fn expr_block(&self, e: @ast::expr) -> ast::blk {\n         self.block(~[], e)\n     }\n \n-    fn fn_decl(+inputs: ~[ast::arg],\n+    fn fn_decl(&self, +inputs: ~[ast::arg],\n                output: @ast::Ty) -> ast::fn_decl {\n         ast::fn_decl {\n             inputs: inputs,\n@@ -217,8 +217,7 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn item(name: ident,\n-            span: span,\n+    fn item(&self, name: ident, span: span,\n             +node: ast::item_) -> @ast::item {\n \n         // XXX: Would be nice if our generated code didn't violate\n@@ -241,7 +240,7 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n                      span: span }\n     }\n \n-    fn item_fn_poly(name: ident,\n+    fn item_fn_poly(&self, name: ident,\n                     +inputs: ~[ast::arg],\n                     output: @ast::Ty,\n                     +ty_params: ~[ast::ty_param],\n@@ -254,37 +253,36 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n                                body))\n     }\n \n-    fn item_fn(name: ident,\n+    fn item_fn(&self, name: ident,\n                +inputs: ~[ast::arg],\n                output: @ast::Ty,\n                +body: ast::blk) -> @ast::item {\n         self.item_fn_poly(name, inputs, output, ~[], body)\n     }\n \n-    fn item_enum_poly(name: ident,\n-                      span: span,\n+    fn item_enum_poly(&self, name: ident, span: span,\n                       +enum_definition: ast::enum_def,\n                       +ty_params: ~[ast::ty_param]) -> @ast::item {\n         self.item(name, span, ast::item_enum(enum_definition, ty_params))\n     }\n \n-    fn item_enum(name: ident, span: span,\n+    fn item_enum(&self, name: ident, span: span,\n                  +enum_definition: ast::enum_def) -> @ast::item {\n         self.item_enum_poly(name, span, enum_definition, ~[])\n     }\n \n-    fn item_struct(name: ident, span: span,\n+    fn item_struct(&self, name: ident, span: span,\n                    struct_def: ast::struct_def) -> @ast::item {\n         self.item_struct_poly(name, span, struct_def, ~[])\n     }\n \n-    fn item_struct_poly(name: ident, span: span,\n+    fn item_struct_poly(&self, name: ident, span: span,\n                         struct_def: ast::struct_def,\n                         ty_params: ~[ast::ty_param]) -> @ast::item {\n         self.item(name, span, ast::item_struct(@struct_def, ty_params))\n     }\n \n-    fn struct_expr(path: @ast::path, fields: ~[ast::field]) -> @ast::expr {\n+    fn struct_expr(&self, path: @ast::path, fields: ~[ast::field]) -> @ast::expr {\n         @ast::expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),\n@@ -293,8 +291,7 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn variant(name: ident,\n-               span: span,\n+    fn variant(&self, name: ident, span: span,\n                +tys: ~[@ast::Ty]) -> ast::variant {\n         let args = do tys.map |ty| {\n             ast::variant_arg { ty: *ty, id: self.next_id() }\n@@ -313,9 +310,9 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn item_mod(name: ident,\n-                span: span,\n+    fn item_mod(&self, name: ident, span: span,\n                 +items: ~[@ast::item]) -> @ast::item {\n+\n         // XXX: Total hack: import `core::kinds::Owned` to work around a\n         // parser bug whereby `fn f<T: ::kinds::Owned>` doesn't parse.\n         let vi = ast::view_item_import(~[\n@@ -353,45 +350,43 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         )\n     }\n \n-    fn ty_path_ast_builder(path: @ast::path) -> @ast::Ty {\n+    fn ty_path_ast_builder(&self, path: @ast::path) -> @ast::Ty {\n         @ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_path(path, self.next_id()),\n             span: path.span,\n         }\n     }\n \n-    fn ty_nil_ast_builder() -> @ast::Ty {\n+    fn ty_nil_ast_builder(&self) -> @ast::Ty {\n         @ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_nil,\n             span: dummy_sp(),\n         }\n     }\n \n-    fn strip_bounds(bounds: &[ast::ty_param]) -> ~[ast::ty_param] {\n+    fn strip_bounds(&self, bounds: &[ast::ty_param]) -> ~[ast::ty_param] {\n         do bounds.map |ty_param| {\n             ast::ty_param { bounds: @~[], ..copy *ty_param }\n         }\n     }\n \n-    fn item_ty_poly(name: ident,\n-                    span: span,\n-                    ty: @ast::Ty,\n+    fn item_ty_poly(&self, name: ident, span: span, ty: @ast::Ty,\n                     +params: ~[ast::ty_param]) -> @ast::item {\n         self.item(name, span, ast::item_ty(ty, params))\n     }\n \n-    fn item_ty(name: ident, span: span, ty: @ast::Ty) -> @ast::item {\n+    fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item {\n         self.item_ty_poly(name, span, ty, ~[])\n     }\n \n-    fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::Ty] {\n+    fn ty_vars(&self, +ty_params: ~[ast::ty_param]) -> ~[@ast::Ty] {\n         ty_params.map(|p| self.ty_path_ast_builder(\n             path(~[p.ident], dummy_sp())))\n     }\n \n-    fn ty_vars_global(+ty_params: ~[ast::ty_param]) -> ~[@ast::Ty] {\n+    fn ty_vars_global(&self, +ty_params: ~[ast::ty_param]) -> ~[@ast::Ty] {\n         ty_params.map(|p| self.ty_path_ast_builder(\n             path(~[p.ident], dummy_sp())))\n     }"}, {"sha": "4676b5ed39363067dd2a83cd789eb2986d5fa7df", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de57bacf436499270e48db4820baa24f68f1542b/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de57bacf436499270e48db4820baa24f68f1542b/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=de57bacf436499270e48db4820baa24f68f1542b", "patch": "@@ -38,10 +38,10 @@ use ext::pipes::proto::{state, protocol, next_state};\n use ext::pipes::proto;\n \n pub impl proto::visitor<(), (), ()> for ext_ctxt {\n-    fn visit_proto(_proto: protocol,\n+    fn visit_proto(&self, _proto: protocol,\n                    _states: &[()]) { }\n \n-    fn visit_state(state: state, _m: &[()]) {\n+    fn visit_state(&self, state: state, _m: &[()]) {\n         if state.messages.len() == 0 {\n             self.span_warn(\n                 state.span, // use a real span!\n@@ -51,7 +51,7 @@ pub impl proto::visitor<(), (), ()> for ext_ctxt {\n         }\n     }\n \n-    fn visit_message(name: ~str, _span: span, _tys: &[@ast::Ty],\n+    fn visit_message(&self, name: ~str, _span: span, _tys: &[@ast::Ty],\n                      this: state, next: Option<next_state>) {\n         match next {\n           Some(next_state { state: ref next, tys: next_tys }) => {"}, {"sha": "7c17660cea7681e37b4df28c2693f2ec93f52a08", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de57bacf436499270e48db4820baa24f68f1542b/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de57bacf436499270e48db4820baa24f68f1542b/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=de57bacf436499270e48db4820baa24f68f1542b", "patch": "@@ -17,13 +17,13 @@ use parse::token;\n use core::prelude::*;\n \n pub trait proto_parser {\n-    fn parse_proto(id: ~str) -> protocol;\n-    fn parse_state(proto: protocol);\n-    fn parse_message(state: state);\n+    fn parse_proto(&self, id: ~str) -> protocol;\n+    fn parse_state(&self, proto: protocol);\n+    fn parse_message(&self, state: state);\n }\n \n pub impl proto_parser for parser::Parser {\n-    fn parse_proto(id: ~str) -> protocol {\n+    fn parse_proto(&self, id: ~str) -> protocol {\n         let proto = protocol(id, self.span);\n \n         self.parse_seq_to_before_end(token::EOF,\n@@ -33,7 +33,7 @@ pub impl proto_parser for parser::Parser {\n         return proto;\n     }\n \n-    fn parse_state(proto: protocol) {\n+    fn parse_state(&self, proto: protocol) {\n         let id = self.parse_ident();\n         let name = *self.interner.get(id);\n \n@@ -63,7 +63,7 @@ pub impl proto_parser for parser::Parser {\n             |self| self.parse_message(state));\n     }\n \n-    fn parse_message(state: state) {\n+    fn parse_message(&self, state: state) {\n         let mname = *self.interner.get(self.parse_ident());\n \n         let args = if self.token == token::LPAREN {"}, {"sha": "9a572c726274a135371b270d31753984ae887c9c", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/de57bacf436499270e48db4820baa24f68f1542b/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de57bacf436499270e48db4820baa24f68f1542b/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=de57bacf436499270e48db4820baa24f68f1542b", "patch": "@@ -27,28 +27,28 @@ use core::to_str::ToStr;\n use core::vec;\n \n pub trait gen_send {\n-    fn gen_send(cx: ext_ctxt, try: bool) -> @ast::item;\n-    fn to_ty(cx: ext_ctxt) -> @ast::Ty;\n+    fn gen_send(&self, cx: ext_ctxt, try: bool) -> @ast::item;\n+    fn to_ty(&self, cx: ext_ctxt) -> @ast::Ty;\n }\n \n pub trait to_type_decls {\n-    fn to_type_decls(cx: ext_ctxt) -> ~[@ast::item];\n-    fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> ~[@ast::item];\n+    fn to_type_decls(&self, cx: ext_ctxt) -> ~[@ast::item];\n+    fn to_endpoint_decls(&self, cx: ext_ctxt, dir: direction) -> ~[@ast::item];\n }\n \n pub trait gen_init {\n-    fn gen_init(cx: ext_ctxt) -> @ast::item;\n-    fn compile(cx: ext_ctxt) -> @ast::item;\n-    fn buffer_ty_path(cx: ext_ctxt) -> @ast::Ty;\n-    fn gen_buffer_type(cx: ext_ctxt) -> @ast::item;\n-    fn gen_buffer_init(ext_cx: ext_ctxt) -> @ast::expr;\n-    fn gen_init_bounded(ext_cx: ext_ctxt) -> @ast::expr;\n+    fn gen_init(&self, cx: ext_ctxt) -> @ast::item;\n+    fn compile(&self, cx: ext_ctxt) -> @ast::item;\n+    fn buffer_ty_path(&self, cx: ext_ctxt) -> @ast::Ty;\n+    fn gen_buffer_type(&self, cx: ext_ctxt) -> @ast::item;\n+    fn gen_buffer_init(&self, ext_cx: ext_ctxt) -> @ast::expr;\n+    fn gen_init_bounded(&self, ext_cx: ext_ctxt) -> @ast::expr;\n }\n \n pub impl gen_send for message {\n-    fn gen_send(cx: ext_ctxt, try: bool) -> @ast::item {\n+    fn gen_send(&self, cx: ext_ctxt, try: bool) -> @ast::item {\n         debug!(\"pipec: gen_send\");\n-        match self {\n+        match *self {\n           message(ref _id, span, tys, this,\n                   Some(next_state {state: ref next, tys: next_tys})) => {\n             debug!(\"pipec: next state exists\");\n@@ -195,14 +195,14 @@ pub impl gen_send for message {\n           }\n         }\n \n-    fn to_ty(cx: ext_ctxt) -> @ast::Ty {\n+    fn to_ty(&self, cx: ext_ctxt) -> @ast::Ty {\n         cx.ty_path_ast_builder(path(~[cx.ident_of(self.name())], self.span())\n           .add_tys(cx.ty_vars_global(self.get_params())))\n     }\n }\n \n pub impl to_type_decls for state {\n-    fn to_type_decls(cx: ext_ctxt) -> ~[@ast::item] {\n+    fn to_type_decls(&self, cx: ext_ctxt) -> ~[@ast::item] {\n         debug!(\"pipec: to_type_decls\");\n         // This compiles into two different type declarations. Say the\n         // state is called ping. This will generate both `ping` and\n@@ -253,7 +253,7 @@ pub impl to_type_decls for state {\n         ]\n     }\n \n-    fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> ~[@ast::item] {\n+    fn to_endpoint_decls(&self, cx: ext_ctxt, dir: direction) -> ~[@ast::item] {\n         debug!(\"pipec: to_endpoint_decls\");\n         let dir = match dir {\n           send => (*self).dir,\n@@ -306,7 +306,7 @@ pub impl to_type_decls for state {\n }\n \n pub impl gen_init for protocol {\n-    fn gen_init(cx: ext_ctxt) -> @ast::item {\n+    fn gen_init(&self, cx: ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n \n         debug!(\"gen_init\");\n@@ -344,7 +344,7 @@ pub impl gen_init for protocol {\n                            body.to_source(cx)))\n     }\n \n-    fn gen_buffer_init(ext_cx: ext_ctxt) -> @ast::expr {\n+    fn gen_buffer_init(&self, ext_cx: ext_ctxt) -> @ast::expr {\n         ext_cx.struct_expr(path(~[ext_cx.ident_of(~\"__Buffer\")],\n                                 dummy_sp()),\n                       self.states.map_to_vec(|s| {\n@@ -356,7 +356,7 @@ pub impl gen_init for protocol {\n         }))\n     }\n \n-    fn gen_init_bounded(ext_cx: ext_ctxt) -> @ast::expr {\n+    fn gen_init_bounded(&self, ext_cx: ext_ctxt) -> @ast::expr {\n         debug!(\"gen_init_bounded\");\n         let buffer_fields = self.gen_buffer_init(ext_cx);\n         let buffer = quote_expr!(~::pipes::Buffer {\n@@ -382,7 +382,7 @@ pub impl gen_init for protocol {\n         })\n     }\n \n-    fn buffer_ty_path(cx: ext_ctxt) -> @ast::Ty {\n+    fn buffer_ty_path(&self, cx: ext_ctxt) -> @ast::Ty {\n         let mut params: ~[ast::ty_param] = ~[];\n         for (copy self.states).each |s| {\n             for s.ty_params.each |tp| {\n@@ -398,7 +398,7 @@ pub impl gen_init for protocol {\n                                .add_tys(cx.ty_vars_global(params)))\n     }\n \n-    fn gen_buffer_type(cx: ext_ctxt) -> @ast::item {\n+    fn gen_buffer_type(&self, cx: ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n         let mut params: ~[ast::ty_param] = ~[];\n         let fields = do (copy self.states).map_to_vec |s| {\n@@ -435,7 +435,7 @@ pub impl gen_init for protocol {\n             cx.strip_bounds(params))\n     }\n \n-    fn compile(cx: ext_ctxt) -> @ast::item {\n+    fn compile(&self, cx: ext_ctxt) -> @ast::item {\n         let mut items = ~[self.gen_init(cx)];\n         let mut client_states = ~[];\n         let mut server_states = ~[];"}, {"sha": "da67e48dfa6e6cf1c4e5dd8fcf409e205309cd05", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/de57bacf436499270e48db4820baa24f68f1542b/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de57bacf436499270e48db4820baa24f68f1542b/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=de57bacf436499270e48db4820baa24f68f1542b", "patch": "@@ -32,8 +32,8 @@ pub impl ToStr for direction {\n }\n \n pub impl direction {\n-    fn reverse() -> direction {\n-        match self {\n+    fn reverse(&self) -> direction {\n+        match *self {\n           send => recv,\n           recv => send\n         }\n@@ -51,21 +51,21 @@ pub enum message {\n }\n \n pub impl message {\n-    fn name() -> ~str {\n-        match self {\n+    fn name(&self) -> ~str {\n+        match *self {\n           message(ref id, _, _, _, _) => (*id)\n         }\n     }\n \n-    fn span() -> span {\n-        match self {\n+    fn span(&self) -> span {\n+        match *self {\n           message(_, span, _, _, _) => span\n         }\n     }\n \n     /// Return the type parameters actually used by this message\n-    fn get_params() -> ~[ast::ty_param] {\n-        match self {\n+    fn get_params(&self) -> ~[ast::ty_param] {\n+        match *self {\n           message(_, _, _, this, _) => this.ty_params\n         }\n     }\n@@ -146,45 +146,38 @@ pub struct protocol_ {\n \n pub impl protocol_ {\n     /// Get a state.\n-    fn get_state(name: ~str) -> state {\n+    fn get_state(&self, name: ~str) -> state {\n         self.states.find(|i| i.name == name).get()\n     }\n \n-    fn get_state_by_id(id: uint) -> state { self.states[id] }\n+    fn get_state_by_id(&self, id: uint) -> state { self.states[id] }\n \n-    fn has_state(name: ~str) -> bool {\n+    fn has_state(&self, name: ~str) -> bool {\n         self.states.find(|i| i.name == name).is_some()\n     }\n \n-    fn filename() -> ~str {\n+    fn filename(&self) -> ~str {\n         ~\"proto://\" + self.name\n     }\n \n-    fn num_states() -> uint { self.states.len() }\n+    fn num_states(&self) -> uint { self.states.len() }\n \n-    fn has_ty_params() -> bool {\n+    fn has_ty_params(&self) -> bool {\n         for self.states.each |s| {\n             if s.ty_params.len() > 0 {\n                 return true;\n             }\n         }\n         false\n     }\n-    fn is_bounded() -> bool {\n+    fn is_bounded(&self) -> bool {\n         let bounded = self.bounded.get();\n         bounded\n-        //if bounded && self.has_ty_params() {\n-        //    debug!(\"protocol %s has is bounded, but type parameters\\\n-        //            are not yet supported.\",\n-        //           *self.name);\n-        //    false\n-        //}\n-        //else { bounded }\n     }\n }\n \n pub impl protocol {\n-    fn add_state_poly(name: ~str, ident: ast::ident, dir: direction,\n+    fn add_state_poly(&self, name: ~str, ident: ast::ident, dir: direction,\n                       +ty_params: ~[ast::ty_param]) -> state {\n         let messages = DVec();\n \n@@ -196,7 +189,7 @@ pub impl protocol {\n             dir: dir,\n             ty_params: ty_params,\n             messages: messages,\n-            proto: self\n+            proto: *self\n         };\n \n         self.states.push(state);\n@@ -205,9 +198,9 @@ pub impl protocol {\n }\n \n pub trait visitor<Tproto, Tstate, Tmessage> {\n-    fn visit_proto(proto: protocol, st: &[Tstate]) -> Tproto;\n-    fn visit_state(state: state, m: &[Tmessage]) -> Tstate;\n-    fn visit_message(name: ~str, spane: span, tys: &[@ast::Ty],\n+    fn visit_proto(&self, proto: protocol, st: &[Tstate]) -> Tproto;\n+    fn visit_state(&self, state: state, m: &[Tmessage]) -> Tstate;\n+    fn visit_message(&self, name: ~str, spane: span, tys: &[@ast::Ty],\n                      this: state, next: Option<next_state>) -> Tmessage;\n }\n "}]}