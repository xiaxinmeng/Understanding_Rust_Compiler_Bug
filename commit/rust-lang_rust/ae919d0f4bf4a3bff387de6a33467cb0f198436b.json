{"sha": "ae919d0f4bf4a3bff387de6a33467cb0f198436b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlOTE5ZDBmNGJmNGEzYmZmMzg3ZGU2YTMzNDY3Y2IwZjE5ODQzNmI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-02-11T16:05:28Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-02-19T23:54:58Z"}, "message": "type-check lvalues", "tree": {"sha": "9f0fa7a56f876e6f441a3887a07facc0a2efad7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f0fa7a56f876e6f441a3887a07facc0a2efad7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae919d0f4bf4a3bff387de6a33467cb0f198436b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae919d0f4bf4a3bff387de6a33467cb0f198436b", "html_url": "https://github.com/rust-lang/rust/commit/ae919d0f4bf4a3bff387de6a33467cb0f198436b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae919d0f4bf4a3bff387de6a33467cb0f198436b/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "880b6c260afc13df012d81c52a5fc1cc4348976e", "url": "https://api.github.com/repos/rust-lang/rust/commits/880b6c260afc13df012d81c52a5fc1cc4348976e", "html_url": "https://github.com/rust-lang/rust/commit/880b6c260afc13df012d81c52a5fc1cc4348976e"}], "stats": {"total": 228, "additions": 218, "deletions": 10}, "files": [{"sha": "5d915f37f6ebf8653ffbcfc6e1081f4eac617e54", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae919d0f4bf4a3bff387de6a33467cb0f198436b/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae919d0f4bf4a3bff387de6a33467cb0f198436b/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=ae919d0f4bf4a3bff387de6a33467cb0f198436b", "patch": "@@ -20,6 +20,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![cfg_attr(not(stage0), deny(warnings))]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n \n+#![feature(box_patterns)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n "}, {"sha": "010e3274253849674a9567f8c64e78d2b3a870d7", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 217, "deletions": 10, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/ae919d0f4bf4a3bff387de6a33467cb0f198436b/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae919d0f4bf4a3bff387de6a33467cb0f198436b/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=ae919d0f4bf4a3bff387de6a33467cb0f198436b", "patch": "@@ -12,9 +12,11 @@\n #![allow(unreachable_code)]\n \n use rustc::middle::infer;\n+use rustc::middle::traits;\n use rustc::middle::ty::{self, Ty};\n use rustc::middle::ty::fold::TypeFoldable;\n use rustc::mir::repr::*;\n+use rustc::mir::tcx::LvalueTy;\n use rustc::mir::transform::MirPass;\n use rustc::mir::visit::{self, Visitor};\n \n@@ -25,11 +27,27 @@ macro_rules! span_mirbug {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n         $context.tcx().sess.span_warn(\n             $context.last_span,\n-            &format!(\"broken MIR ({:?}): {:?}\", $elem, format!($($message)*))\n+            &format!(\"broken MIR ({:?}): {}\", $elem, format!($($message)*))\n         )\n     })\n }\n \n+macro_rules! span_mirbug_and_err {\n+    ($context:expr, $elem:expr, $($message:tt)*) => ({\n+        {\n+            $context.tcx().sess.span_bug(\n+                $context.last_span,\n+                &format!(\"broken MIR ({:?}): {:?}\", $elem, format!($($message)*))\n+            );\n+            $context.error()\n+        }\n+    })\n+}\n+\n+enum FieldAccessError {\n+    OutOfRange { field_count: usize }\n+}\n+\n /// Verifies that MIR types are sane to not crash further\n /// checks.\n struct TypeVerifier<'a, 'tcx: 'a> {\n@@ -46,11 +64,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: visit::LvalueContext) {\n-        self.super_lvalue(lvalue, context);\n-        debug!(\"visiting lvalue {:?}\", lvalue);\n-        let lv_ty = self.mir.lvalue_ty(self.tcx(), lvalue).to_ty(self.tcx());\n-        self.sanitize_type(lvalue, lv_ty);\n+    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, _context: visit::LvalueContext) {\n+        self.sanitize_lvalue(lvalue);\n     }\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>) {\n@@ -78,6 +93,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'tcx> {\n         for (n, tmp_decl) in mir.temp_decls.iter().enumerate() {\n             self.sanitize_type(&(n, tmp_decl), tmp_decl.ty);\n         }\n+        if self.errors_reported {\n+            return;\n+        }\n         self.super_mir(mir);\n     }\n }\n@@ -96,12 +114,201 @@ impl<'a, 'tcx> TypeVerifier<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn sanitize_type(&mut self, parent: &fmt::Debug, ty: Ty<'tcx>) {\n-        if !(ty.needs_infer() || ty.has_escaping_regions()) {\n-            return;\n+    fn sanitize_type(&mut self, parent: &fmt::Debug, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if !(ty.needs_infer() || ty.has_escaping_regions() ||\n+             ty.references_error()) {\n+            return ty;\n+        }\n+        span_mirbug_and_err!(self, parent, \"bad type {:?}\", ty)\n+    }\n+\n+    fn sanitize_lvalue(&mut self, lvalue: &Lvalue<'tcx>) -> LvalueTy<'tcx> {\n+        debug!(\"sanitize_lvalue: {:?}\", lvalue);\n+        match *lvalue {\n+            Lvalue::Var(index) => LvalueTy::Ty { ty: self.mir.var_decls[index as usize].ty },\n+            Lvalue::Temp(index) =>\n+                LvalueTy::Ty { ty: self.mir.temp_decls[index as usize].ty },\n+            Lvalue::Arg(index) =>\n+                LvalueTy::Ty { ty: self.mir.arg_decls[index as usize].ty },\n+            Lvalue::Static(def_id) =>\n+                LvalueTy::Ty { ty: self.tcx().lookup_item_type(def_id).ty },\n+            Lvalue::ReturnPointer => {\n+                if let ty::FnConverging(return_ty) = self.mir.return_ty {\n+                    LvalueTy::Ty { ty: return_ty }\n+                } else {\n+                    LvalueTy::Ty {\n+                        ty: span_mirbug_and_err!(\n+                            self, lvalue, \"return in diverging function\")\n+                    }\n+                }\n+            }\n+            Lvalue::Projection(ref proj) => {\n+                let base_ty = self.sanitize_lvalue(&proj.base);\n+                if let LvalueTy::Ty { ty } = base_ty {\n+                    if ty.references_error() {\n+                        assert!(self.errors_reported);\n+                        return LvalueTy::Ty { ty: self.tcx().types.err };\n+                    }\n+                }\n+                self.sanitize_projection(base_ty, &proj.elem, lvalue)\n+            }\n+        }\n+    }\n+\n+    fn sanitize_projection(&mut self,\n+                           base: LvalueTy<'tcx>,\n+                           pi: &LvalueElem<'tcx>,\n+                           lvalue: &Lvalue<'tcx>)\n+                           -> LvalueTy<'tcx> {\n+        debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, lvalue);\n+        let tcx = self.tcx();\n+        let base_ty = base.to_ty(tcx);\n+        match *pi {\n+            ProjectionElem::Deref => {\n+                let deref_ty = base_ty.builtin_deref(true, ty::LvaluePreference::NoPreference);\n+                LvalueTy::Ty {\n+                    ty: deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n+                        span_mirbug_and_err!(\n+                            self, lvalue, \"deref of non-pointer {:?}\", base_ty)\n+                    })\n+                }\n+            }\n+            ProjectionElem::Index(ref i) => {\n+                self.visit_operand(i);\n+                let index_ty = self.mir.operand_ty(tcx, i);\n+                if index_ty != tcx.types.usize {\n+                    LvalueTy::Ty {\n+                        ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i)\n+                    }\n+                } else {\n+                    LvalueTy::Ty {\n+                        ty: base_ty.builtin_index().unwrap_or_else(|| {\n+                            span_mirbug_and_err!(\n+                                self, lvalue, \"index of non-array {:?}\", base_ty)\n+                        })\n+                    }\n+                }\n+            }\n+            ProjectionElem::ConstantIndex { .. } => {\n+                // consider verifying in-bounds\n+                LvalueTy::Ty {\n+                    ty: base_ty.builtin_index().unwrap_or_else(|| {\n+                        span_mirbug_and_err!(\n+                            self, lvalue, \"index of non-array {:?}\", base_ty)\n+                    })\n+                }\n+            }\n+            ProjectionElem::Downcast(adt_def1, index) =>\n+                match base_ty.sty {\n+                    ty::TyEnum(adt_def, substs) if adt_def == adt_def1 => {\n+                        if index >= adt_def.variants.len() {\n+                            LvalueTy::Ty {\n+                                ty: span_mirbug_and_err!(\n+                                    self,\n+                                    lvalue,\n+                                    \"cast to variant #{:?} but enum only has {:?}\",\n+                                    index,\n+                                    adt_def.variants.len())\n+                            }\n+                        } else {\n+                            LvalueTy::Downcast {\n+                                adt_def: adt_def,\n+                                substs: substs,\n+                                variant_index: index\n+                            }\n+                        }\n+                    }\n+                    _ => LvalueTy::Ty {\n+                        ty: span_mirbug_and_err!(\n+                            self, lvalue, \"can't downcast {:?}\", base_ty)\n+                    }\n+                },\n+            ProjectionElem::Field(field, fty) => {\n+                let fty = self.sanitize_type(lvalue, fty);\n+                match self.field_ty(lvalue, base, field) {\n+                    Ok(ty) => {\n+                        if let Err(terr) = infer::can_mk_subty(self.infcx, ty, fty) {\n+                            span_mirbug!(\n+                                self, lvalue, \"bad field access ({:?}: {:?}): {:?}\",\n+                                ty, fty, terr);\n+                        }\n+                    }\n+                    Err(FieldAccessError::OutOfRange { field_count }) => {\n+                        span_mirbug!(\n+                            self, lvalue, \"accessed field #{} but variant only has {}\",\n+                            field.index(), field_count)\n+                    }\n+                }\n+                LvalueTy::Ty { ty: fty }\n+            }\n         }\n-        span_mirbug!(self, parent, \"bad type {:?}\", ty);\n+    }\n+\n+    fn error(&mut self) -> Ty<'tcx> {\n         self.errors_reported = true;\n+        self.tcx().types.err\n+    }\n+\n+    fn field_ty(&mut self,\n+                parent: &fmt::Debug,\n+                base_ty: LvalueTy<'tcx>,\n+                field: Field)\n+                -> Result<Ty<'tcx>, FieldAccessError>\n+    {\n+        let tcx = self.tcx();\n+\n+        let (variant, substs) = match base_ty {\n+            LvalueTy::Downcast { adt_def, substs, variant_index } => {\n+                (&adt_def.variants[variant_index], substs)\n+            }\n+            LvalueTy::Ty { ty } => match ty.sty {\n+                ty::TyStruct(adt_def, substs) | ty::TyEnum(adt_def, substs)\n+                    if adt_def.is_univariant() => {\n+                        (&adt_def.variants[0], substs)\n+                    }\n+                ty::TyTuple(ref tys) | ty::TyClosure(_, box ty::ClosureSubsts {\n+                    upvar_tys: ref tys, ..\n+                }) => {\n+                    return match tys.get(field.index()) {\n+                        Some(&ty) => Ok(ty),\n+                        None => Err(FieldAccessError::OutOfRange {\n+                            field_count: tys.len()\n+                        })\n+                    }\n+                }\n+                _ => return Ok(span_mirbug_and_err!(\n+                    self, parent, \"can't project out of {:?}\", base_ty))\n+            }\n+        };\n+\n+        if let Some(field) = variant.fields.get(field.index()) {\n+            Ok(self.normalize(parent, field.ty(tcx, substs)))\n+        } else {\n+            Err(FieldAccessError::OutOfRange { field_count: variant.fields.len() })\n+        }\n+    }\n+\n+    fn normalize(&mut self, parent: &fmt::Debug, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let mut selcx = traits::SelectionContext::new(&self.infcx);\n+        let cause = traits::ObligationCause::misc(self.last_span, 0);\n+        let traits::Normalized { value: ty, obligations } =\n+            traits::normalize(&mut selcx, cause, &ty);\n+\n+        debug!(\"normalize: ty={:?} obligations={:?}\",\n+               ty,\n+               obligations);\n+\n+        let mut fulfill_cx = self.infcx.fulfillment_cx.borrow_mut();\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(&self.infcx, obligation);\n+        }\n+\n+        match infer::drain_fulfillment_cx(&self.infcx, &mut fulfill_cx, &ty) {\n+            Ok(ty) => ty,\n+            Err(e) => {\n+                span_mirbug_and_err!(self, parent, \"trait fulfillment failed: {:?}\", e)\n+            }\n+        }\n     }\n }\n "}]}