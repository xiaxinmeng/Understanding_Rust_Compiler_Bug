{"sha": "0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MjRmOWRiNGFlYWE1NjgxOTQxNzUwYzNhMWExN2NhNWZiYjdlNzI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-03-04T06:22:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-07T20:58:08Z"}, "message": "Add a pretty-printer\n\nAdds a -pp option to the compiler which will cause it to simply\npretty-print the given file.", "tree": {"sha": "91844d79c0c5614ce660c3c20f1c67eaef2d5021", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91844d79c0c5614ce660c3c20f1c67eaef2d5021"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "html_url": "https://github.com/rust-lang/rust/commit/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8047957b9981c4f3539ba3d307a65e0255477e81", "url": "https://api.github.com/repos/rust-lang/rust/commits/8047957b9981c4f3539ba3d307a65e0255477e81", "html_url": "https://github.com/rust-lang/rust/commit/8047957b9981c4f3539ba3d307a65e0255477e81"}], "stats": {"total": 1038, "additions": 1013, "deletions": 25}, "files": [{"sha": "7ad0cdc74fde9d6b2b59f303b49dd230d0da3ea7", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "patch": "@@ -61,6 +61,14 @@ impure fn compile_input(session.session sess,\n     trans.trans_crate(sess, crate, output, shared);\n }\n \n+impure fn pretty_print_input(session.session sess,\n+                             eval.env env,\n+                             str input) {\n+    auto p = front.parser.new_parser(sess, env, 0, input);\n+    auto crate = front.parser.parse_crate_from_source_file(p);\n+    pretty.pprust.print_ast(crate.node.module);\n+}\n+\n fn warn_wrong_compiler() {\n     log \"This is the rust 'self-hosted' compiler.\";\n     log \"The one written in rust.\";\n@@ -75,6 +83,7 @@ fn usage(session.session sess, str argv0) {\n     log \"    -o <filename>      write output to <filename>\";\n     log \"    -nowarn            suppress wrong-compiler warning\";\n     log \"    -shared            compile a shared-library crate\";\n+    log \"    -pp                pretty-print the input instead of compiling\";\n     log \"    -h                 display this message\";\n     log \"\";\n     log \"\";\n@@ -101,6 +110,7 @@ impure fn main(vec[str] args) {\n     let option.t[str] output_file = none[str];\n     let bool do_warn = true;\n     let bool shared = false;\n+    let bool pretty = false;\n \n     auto i = 1u;\n     auto len = _vec.len[str](args);\n@@ -113,6 +123,8 @@ impure fn main(vec[str] args) {\n                 do_warn = false;\n             } else if (_str.eq(arg, \"-shared\")) {\n                 shared = true;\n+            } else if (_str.eq(arg, \"-pp\")) {\n+                pretty = true;\n             } else if (_str.eq(arg, \"-o\")) {\n                 if (i+1u < len) {\n                     output_file = some(args.(i+1u));\n@@ -153,24 +165,27 @@ impure fn main(vec[str] args) {\n         case (some[str](?ifile)) {\n \n             auto env = default_environment(sess, args.(0), ifile);\n-\n-            alt (output_file) {\n-                case (none[str]) {\n-                    let vec[str] parts = _str.split(ifile, '.' as u8);\n-                    parts = _vec.pop[str](parts);\n-                    parts += \".bc\";\n-                    auto ofile = _str.concat(parts);\n-                    compile_input(sess, env, ifile, ofile, shared);\n-                }\n-                case (some[str](?ofile)) {\n-                    compile_input(sess, env, ifile, ofile, shared);\n+            if (pretty) {\n+                pretty_print_input(sess, env, ifile);\n+            }\n+            else {\n+                alt (output_file) {\n+                    case (none[str]) {\n+                        let vec[str] parts = _str.split(ifile, '.' as u8);\n+                        parts = _vec.pop[str](parts);\n+                        parts += \".bc\";\n+                        auto ofile = _str.concat(parts);\n+                        compile_input(sess, env, ifile, ofile, shared);\n+                    }\n+                    case (some[str](?ofile)) {\n+                        compile_input(sess, env, ifile, ofile, shared);\n+                    }\n                 }\n             }\n         }\n     }\n }\n \n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "d45260f3ad101d0c6acf0cf063c32104498149c5", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "patch": "@@ -122,6 +122,31 @@ tag binop {\n     gt;\n }\n \n+fn binop_to_str(binop op) -> str {\n+    alt (op) {\n+        case (add) {ret \"+\";}\n+        case (sub) {ret \"-\";}\n+        case (mul) {ret \"*\";}\n+        case (div) {ret \"/\";}\n+        case (rem) {ret \"%\";}\n+        case (and) {ret \"&&\";}\n+        case (or) {ret \"||\";}\n+        case (bitxor) {ret \"^\";}\n+        case (bitand) {ret \"&\";}\n+        case (bitor) {ret \"|\";}\n+        case (lsl) {ret \"<<\";}\n+        case (lsr) {ret \">>\";}\n+        case (asr) {ret \">>>\";}\n+        case (eq) {ret \"==\";}\n+        case (lt) {ret \"<\";}\n+        case (le) {ret \"<=\";}\n+        case (ne) {ret \"!=\";}\n+        case (ge) {ret \">=\";}\n+        case (gt) {ret \">\";}\n+    }\n+}\n+\n+\n tag unop {\n     box;\n     deref;\n@@ -131,6 +156,17 @@ tag unop {\n     _mutable;\n }\n \n+fn unop_to_str(unop op) -> str {\n+    alt (op) {\n+        case (box) {ret \"@\";}\n+        case (deref) {ret \"*\";}\n+        case (bitnot) {ret \"~\";}\n+        case (not) {ret \"!\";}\n+        case (neg) {ret \"-\";}\n+        case (_mutable) {ret \"mutable\";}\n+    }\n+}\n+\n tag mode {\n     val;\n     alias;"}, {"sha": "f60ff36b65f961ba3332d8b533d590cf0681deea", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "patch": "@@ -983,6 +983,7 @@ impure fn parse_prefix_expr(parser p) -> @ast.expr {\n \n type op_spec = rec(token.token tok, ast.binop op, int prec);\n \n+// FIXME make this a const, don't store it in parser state\n fn prec_table() -> vec[op_spec] {\n     ret vec(rec(tok=token.BINOP(token.STAR), op=ast.mul, prec=11),\n             rec(tok=token.BINOP(token.SLASH), op=ast.div, prec=11),"}, {"sha": "2fd58126cee9f12abe24dafdd5f3904b9465a28c", "filename": "src/comp/front/pretty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Ffront%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Ffront%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fpretty.rs?ref=0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "patch": "@@ -5,6 +5,8 @@ import std._vec;\n \n export print_expr;\n \n+// FIXME this is superseded by ../pretty/pprust.rs. can it be dropped?\n+\n fn unknown() -> str {\n     ret \"<unknown ast node>\";\n }"}, {"sha": "c33b5d8d17d2123aaf9948af78d5c55319fdd828", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "patch": "@@ -169,6 +169,8 @@ fn path_to_str(&ast.path pth) -> str {\n     ret result;\n }\n \n+// FIXME use the pretty-printer for this once it has a concept of an\n+// abstract stream\n fn ty_to_str(&@t typ) -> str {\n \n     fn fn_input_to_str(&rec(ast.mode mode, @t ty) input) -> str {"}, {"sha": "43a9220f4e508f5855684fcb314a6ee919eab619", "filename": "src/comp/pretty/pp.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "patch": "@@ -0,0 +1,207 @@\n+import std.io;\n+import std._vec;\n+import std._str;\n+\n+tag boxtype {box_h; box_v; box_hv; box_align;}\n+tag contexttype {cx_h; cx_v;}\n+\n+tag token {\n+  brk(uint);\n+  word(str);\n+  cword(str); // closing token\n+  open(boxtype, uint);\n+  close;\n+}\n+\n+type context = rec(contexttype tp, uint indent);\n+\n+type ps = @rec(mutable vec[context] context,\n+               uint width,\n+               mutable vec[token] buffered,\n+               mutable uint scandepth,\n+               mutable uint bufferedcol,\n+               mutable uint col,\n+               mutable bool start_of_line);\n+\n+fn mkstate(uint width) -> ps {\n+  let vec[context] stack = vec(rec(tp=cx_v, indent=0u));\n+  let vec[token] buff = vec();\n+  ret @rec(mutable context=stack,\n+           width=width,\n+           mutable buffered=buff,\n+           mutable scandepth=0u,\n+           mutable bufferedcol=0u,\n+           mutable col=0u,\n+           mutable start_of_line=true);\n+}\n+\n+impure fn push_context(ps p, contexttype tp, uint indent) {\n+  before_print(p, false);\n+  p.context = _vec.push[context](p.context, rec(tp=tp, indent=base_indent(p)\n+                                                + indent));\n+}\n+\n+impure fn pop_context(ps p) {\n+  p.context = _vec.pop[context](p.context);\n+}\n+\n+impure fn add_token(ps p, token tok) {\n+  if (p.scandepth == 0u) {do_token(p, tok);}\n+  else {buffer_token(p, tok);}\n+}\n+\n+impure fn buffer_token(ps p, token tok) {\n+  p.buffered += vec(tok);\n+  p.bufferedcol += token_size(tok);\n+  alt (p.buffered.(0)) {\n+    case (brk(_)) {\n+      alt (tok) {\n+        case (brk(_)) {\n+          if (p.scandepth == 1u) {finish_break_scan(p);}\n+        }\n+        case (open(box_h,_)) {p.scandepth += 1u;}\n+        case (open(_,_)) {finish_break_scan(p);}\n+        case (close) {\n+          p.scandepth -= 1u;\n+          if (p.scandepth == 0u) {finish_break_scan(p);}\n+        }\n+        case (_) {}\n+      }\n+    }\n+    case (open(_,_)) {\n+      if (p.bufferedcol > p.width) {finish_block_scan(p, cx_v);}\n+      else {\n+        alt (tok) {\n+          case (open(_,_)) {p.scandepth += 1u;}\n+          case (close) {\n+            p.scandepth -= 1u;\n+            if (p.scandepth == 0u) {finish_block_scan(p, cx_h);}\n+          }\n+          case (_) {}\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+impure fn finish_block_scan(ps p, contexttype tp) {\n+  auto indent;\n+  alt (p.buffered.(0)){\n+    case (open(box_hv,?ind)) {\n+      indent = ind;\n+    }\n+    case (open(box_align, _)) {\n+      indent = p.col - base_indent(p);\n+    }\n+  }\n+  p.scandepth = 0u;\n+  push_context(p, tp, indent);\n+  for (token t in _vec.shift[token](p.buffered)) {add_token(p, t);}\n+}\n+\n+impure fn finish_break_scan(ps p) {\n+  if (p.bufferedcol > p.width) {\n+    write_str(\"\\n\");\n+    p.col = 0u;\n+  }\n+  else {\n+    auto width;\n+    alt (p.buffered.(0)) {case(brk(?w)) {width = w;}}\n+    auto i = 0u;\n+    while (i < width) {write_str(\" \"); i+=1u;}\n+    p.col += width;\n+  }\n+  p.scandepth = 0u;\n+  for (token t in _vec.shift[token](p.buffered)) {add_token(p, t);}\n+}\n+\n+impure fn start_scan(ps p, token tok) {\n+  p.buffered = vec(tok);\n+  p.scandepth = 1u;\n+  p.bufferedcol = p.col;\n+}\n+\n+fn cur_context(ps p) -> context {\n+  ret p.context.(_vec.len[context](p.context)-1u);\n+}\n+fn base_indent(ps p) -> uint {\n+  auto i = _vec.len[context](p.context);\n+  while (i > 0u) {\n+    i -= 1u;\n+    auto cx = p.context.(i);\n+    if (cx.tp == cx_v) {ret cx.indent;}\n+  }\n+}\n+\n+impure fn do_token(ps p, token tok) {\n+  alt (tok) {\n+    case (brk(?sz)) {\n+      alt (cur_context(p).tp) {\n+        case (cx_h) {\n+          before_print(p, false);\n+          start_scan(p, tok);\n+        }\n+        case (cx_v) {\n+          write_str(\"\\n\");\n+          p.col = 0u;\n+          p.start_of_line = true;\n+        }\n+      }\n+    }\n+    case (word(?w)) {\n+      before_print(p, false);\n+      write_str(w);\n+      p.col += _str.byte_len(w); // TODO char_len\n+    }\n+    case (cword(?w)) {\n+      before_print(p, true);\n+      write_str(w);\n+      p.col += _str.byte_len(w); // TODO char_len\n+    }\n+    case (open(?tp, ?indent)) {\n+      alt (tp) {\n+        case (box_hv) {start_scan(p, tok);}\n+        case (box_align) {start_scan(p, tok);}\n+        case (box_h) {push_context(p, cx_h, indent);}\n+        case (box_v) {push_context(p, cx_v, indent);}\n+      }\n+    }\n+    case (close) {pop_context(p);}\n+  }\n+}\n+\n+impure fn before_print(ps p, bool closing) {\n+  if (p.start_of_line) {\n+    p.start_of_line = false;\n+    auto ind;\n+    if (closing) {ind = base_indent(p);}\n+    else {ind = cur_context(p).indent;}\n+    p.col = ind;\n+    while (ind > 0u) {write_str(\" \"); ind -= 1u;}\n+  }\n+}\n+\n+fn write_str(str s) {\n+  io.writefd(1, _str.bytes(s));\n+}\n+\n+fn token_size(token tok) -> uint {\n+  alt (tok) {\n+    case (brk(?sz)) {ret sz;}\n+    case (word(?w)) {ret _str.byte_len(w);}\n+    case (cword(?w)) {ret _str.byte_len(w);}\n+    case (open(_, _)) {ret 0u;} // TODO exception for V blocks?\n+    case (close) {ret 0u;}\n+  }\n+}\n+\n+impure fn box(ps p, uint indent) {add_token(p, open(box_hv, indent));}\n+impure fn abox(ps p) {add_token(p, open(box_align, 0u));}\n+impure fn vbox(ps p, uint indent) {add_token(p, open(box_v, indent));}\n+impure fn hbox(ps p, uint indent) {add_token(p, open(box_h, indent));}\n+impure fn end(ps p) {add_token(p, close);}\n+impure fn wrd(ps p, str wrd) {add_token(p, word(wrd));}\n+impure fn cwrd(ps p, str wrd) {add_token(p, cword(wrd));}\n+impure fn space(ps p) {add_token(p, brk(1u));}\n+impure fn spaces(ps p, uint n) {add_token(p, brk(n));}\n+impure fn line(ps p) {add_token(p, brk(0u));}"}, {"sha": "d10f5e7cdaa237ce76fdb32f62d0ab85ac2967ef", "filename": "src/comp/pretty/pprust.rs", "status": "added", "additions": 716, "deletions": 0, "changes": 716, "blob_url": "https://github.com/rust-lang/rust/blob/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "patch": "@@ -0,0 +1,716 @@\n+import std._vec;\n+import std._str;\n+import std.option;\n+import front.ast;\n+import pp.box; import pp.abox; import pp.vbox;\n+import pp.end; import pp.wrd; import pp.space; import pp.line;\n+import pp.ps;\n+\n+import foo = std.io;\n+\n+const uint indent_unit = 2u;\n+const int as_prec = 5;\n+\n+impure fn print_ast(ast._mod _mod) {\n+  auto s = pp.mkstate(80u);\n+  for (@ast.view_item vitem in _mod.view_items) {print_view_item(s, vitem);}\n+  line(s);\n+  for (@ast.item item in _mod.items) {print_item(s, item);}\n+}\n+\n+impure fn hbox(ps s) {\n+  pp.hbox(s, indent_unit);\n+}\n+impure fn wrd1(ps s, str word) {\n+  wrd(s, word);\n+  space(s);\n+}\n+impure fn popen(ps s) {\n+  wrd(s, \"(\");\n+  abox(s);\n+}\n+impure fn pclose(ps s) {\n+  end(s);\n+  wrd(s, \")\");\n+}\n+impure fn bopen(ps s) {\n+  wrd1(s, \"{\");\n+  vbox(s, indent_unit);\n+  line(s);\n+}\n+impure fn bclose(ps s) {\n+  end(s);\n+  pp.cwrd(s, \"}\");\n+}\n+impure fn commasep[IN](ps s, vec[IN] elts, impure fn (ps, IN) op) {\n+  auto first = true;\n+  for (IN elt in elts) {\n+    if (first) {first = false;}\n+    else {wrd1(s, \",\");}\n+    op(s, elt);\n+  }\n+}\n+\n+impure fn print_type(ps s, @ast.ty ty) {\n+  hbox(s);\n+  alt (ty.node) {\n+    case (ast.ty_nil) {wrd(s, \"()\");}\n+    case (ast.ty_bool) {wrd(s, \"bool\");}\n+    case (ast.ty_int) {wrd(s, \"int\");}\n+    case (ast.ty_uint) {wrd(s, \"uint\");}\n+    case (ast.ty_machine(?tm)) {wrd(s, util.common.ty_mach_to_str(tm));}\n+    case (ast.ty_char) {wrd(s, \"char\");}\n+    case (ast.ty_str) {wrd(s, \"str\");}\n+    case (ast.ty_box(?t)) {wrd(s, \"@\"); print_type(s, t);}\n+    case (ast.ty_vec(?t)) {wrd(s, \"vec[\"); print_type(s, t); wrd(s, \"]\");}\n+    case (ast.ty_type) {wrd(s, \"type\");}\n+    case (ast.ty_tup(?elts)) {\n+      wrd(s, \"tup\");\n+      popen(s);\n+      auto f = print_type;\n+      commasep[@ast.ty](s, elts, f);\n+      pclose(s);\n+    }\n+    case (ast.ty_rec(?fields)) {\n+      wrd(s, \"rec\");\n+      popen(s);\n+      impure fn print_field(ps s, ast.ty_field f) {\n+        hbox(s);\n+        print_type(s, f.ty);\n+        space(s);\n+        wrd(s, f.ident);\n+        end(s);\n+      }\n+      auto f = print_field;\n+      commasep[ast.ty_field](s, fields, f);\n+      pclose(s);\n+    }\n+    case (ast.ty_fn(?proto,?inputs,?output)) {\n+      if (proto == ast.proto_fn) {wrd(s, \"fn\");}\n+      else {wrd(s, \"iter\");}\n+      popen(s);\n+      impure fn print_arg(ps s, ast.ty_arg input) {\n+        if (middle.ty.mode_is_alias(input.mode)) {wrd(s, \"&\");}\n+        print_type(s, input.ty);\n+      }\n+      auto f = print_arg;\n+      commasep[ast.ty_arg](s, inputs, f);\n+      pclose(s);\n+      if (output.node != ast.ty_nil) {\n+        space(s);\n+        hbox(s);\n+        wrd1(s, \"->\");\n+        print_type(s, output);\n+        end(s);\n+      }\n+    }\n+    case (ast.ty_path(?path,_)) {\n+      print_path(s, path);\n+    }\n+    case (ast.ty_mutable(?t)) {\n+      wrd1(s, \"mutable\");\n+      print_type(s, t);\n+    }\n+  }\n+  end(s);\n+}\n+\n+impure fn print_item(ps s, @ast.item item) {\n+  hbox(s);\n+  alt (item.node) {\n+    case (ast.item_const(?id, ?ty, ?expr, _, _)) {\n+      wrd1(s, \"const\");\n+      print_type(s, ty);\n+      space(s);\n+      wrd1(s, id);\n+      wrd1(s, \"=\");\n+      print_expr(s, expr);\n+      wrd(s, \";\");\n+    }\n+    case (ast.item_fn(?name,?_fn,?typarams,_,_)) {\n+      print_fn(s, _fn.decl, name, typarams);\n+      space(s);\n+      print_block(s, _fn.body);\n+    }\n+    case (ast.item_mod(?id,?_mod,_)) {\n+      wrd1(s, \"mod\");\n+      wrd1(s, id);\n+      bopen(s);\n+      for (@ast.item itm in _mod.items) {print_item(s, itm);}\n+      bclose(s);\n+    }\n+    case (ast.item_native_mod(?id,?nmod,_)) {\n+      wrd1(s, \"native\");\n+      alt (nmod.abi) {\n+        case (ast.native_abi_rust) {wrd1(s, \"\\\"rust\\\"\");}\n+        case (ast.native_abi_cdecl) {wrd1(s, \"\\\"cdecl\\\"\");}\n+      }\n+      wrd1(s, \"mod\");\n+      wrd1(s, id);\n+      bopen(s);\n+      for (@ast.native_item item in nmod.items) {\n+        hbox(s);\n+        alt (item.node) {\n+          case (ast.native_item_ty(?id,_)) {\n+            wrd1(s, \"type\");\n+            wrd(s, id);\n+          }\n+          case (ast.native_item_fn(?id,?decl,?typarams,_,_)) {\n+            print_fn(s, decl, id, typarams);\n+          }\n+        }\n+        wrd(s, \";\");\n+        end(s);\n+      }\n+      bclose(s);\n+    }\n+    case (ast.item_ty(?id,?ty,?params,_,_)) {\n+      wrd1(s, \"type\");\n+      wrd(s, id);\n+      print_type_params(s, params);\n+      space(s);\n+      wrd1(s, \"=\");\n+      print_type(s, ty);\n+      wrd(s, \";\");\n+    }\n+    case (ast.item_tag(?id,?variants,?params,_)) {\n+      wrd1(s, \"tag\");\n+      wrd(s, id);\n+      print_type_params(s, params);\n+      space(s);\n+      bopen(s);\n+      for (ast.variant v in variants) {\n+        wrd(s, v.name);\n+        if (_vec.len[ast.variant_arg](v.args) > 0u) {\n+          popen(s);\n+          impure fn print_variant_arg(ps s, ast.variant_arg arg) {\n+            print_type(s, arg.ty);\n+          }\n+          auto f = print_variant_arg;\n+          commasep[ast.variant_arg](s, v.args, f);\n+          pclose(s);\n+        }\n+        wrd(s, \";\");\n+        line(s);\n+      }\n+      bclose(s);\n+    }\n+    case (ast.item_obj(?id,?_obj,?params,_,_)) {\n+      wrd1(s, \"obj\");\n+      wrd(s, id);\n+      print_type_params(s, params);\n+      popen(s);\n+      impure fn print_field(ps s, ast.obj_field field) {\n+        hbox(s);\n+        print_type(s, field.ty);\n+        space(s);\n+        wrd(s, field.ident);\n+        end(s);\n+      }\n+      auto f = print_field;\n+      commasep[ast.obj_field](s, _obj.fields, f);\n+      pclose(s);\n+      space(s);\n+      bopen(s);\n+      for (@ast.method meth in _obj.methods) {\n+        hbox(s);\n+        let vec[ast.ty_param] typarams = vec();\n+        print_fn(s, meth.node.meth.decl, meth.node.ident, typarams);\n+        space(s);\n+        print_block(s, meth.node.meth.body);\n+        end(s);\n+        line(s);\n+      }\n+      alt (_obj.dtor) {\n+        case (option.some[ast.block](?dtor)) {\n+          hbox(s);\n+          wrd1(s, \"close\");\n+          print_block(s, dtor);\n+          end(s);\n+          line(s);\n+        }\n+        case (_) {}\n+      }\n+      bclose(s);\n+    }\n+  }\n+  end(s);\n+  line(s);\n+  line(s);\n+}\n+\n+impure fn print_block(ps s, ast.block blk) {\n+  bopen(s);\n+  for (@ast.stmt st in blk.node.stmts) {\n+    alt (st.node) {\n+      case (ast.stmt_decl(?decl)) {print_decl(s, decl);}\n+      case (ast.stmt_expr(?expr)) {print_expr(s, expr);}\n+    }\n+    if (front.parser.stmt_ends_with_semi(st)) {wrd(s, \";\");}\n+    line(s);\n+  }\n+  alt (blk.node.expr) {\n+    case (option.some[@ast.expr](?expr)) {\n+      print_expr(s, expr);\n+      line(s);\n+    }\n+    case (_) {}\n+  }\n+  bclose(s);\n+}\n+\n+impure fn print_literal(ps s, @ast.lit lit) {\n+  alt (lit.node) {\n+    case (ast.lit_str(?st)) {print_string(s, st);}\n+    case (ast.lit_char(?ch)) {\n+      wrd(s, \"'\" + escape_str(_str.from_bytes(vec(ch as u8)), '\\'') + \"'\");\n+    }\n+    case (ast.lit_int(?val)) {\n+      wrd(s, util.common.istr(val));\n+    }\n+    case (ast.lit_uint(?val)) { // TODO clipping? uistr?\n+      wrd(s, util.common.istr(val as int) + \"u\");\n+    }\n+    case (ast.lit_mach_int(?mach,?val)) {\n+      wrd(s, util.common.istr(val as int));\n+      wrd(s, util.common.ty_mach_to_str(mach));\n+    }\n+    case (ast.lit_nil) {wrd(s, \"()\");}\n+    case (ast.lit_bool(?val)) {\n+      if (val) {wrd(s, \"true\");} else {wrd(s, \"false\");}\n+    }\n+  }\n+}\n+\n+impure fn print_expr(ps s, @ast.expr expr) {\n+  auto pe = print_expr;\n+  hbox(s);\n+  alt (expr.node) {\n+    case (ast.expr_vec(?exprs,_)) {\n+      wrd(s, \"vec\");\n+      popen(s);\n+      commasep[@ast.expr](s, exprs, pe);\n+      pclose(s);\n+    }\n+    case (ast.expr_tup(?exprs,_)) {\n+      impure fn printElt(ps s, ast.elt elt) {\n+        hbox(s);\n+        if (elt.mut == ast.mut) {wrd1(s, \"mutable\");}\n+        print_expr(s, elt.expr);\n+        end(s);\n+      }\n+      wrd(s, \"tup\");\n+      popen(s);\n+      auto f = printElt;\n+      commasep[ast.elt](s, exprs, f);\n+      pclose(s);\n+    }\n+    case (ast.expr_rec(?fields,_,_)) {\n+      impure fn print_field(ps s, ast.field field) {\n+        hbox(s);\n+        if (field.mut == ast.mut) {wrd1(s, \"mutable\");}\n+        wrd(s, field.ident);\n+        wrd(s, \"=\");\n+        print_expr(s, field.expr);\n+        end(s);\n+      }\n+      wrd(s, \"rec\");\n+      popen(s);\n+      auto f = print_field;\n+      commasep[ast.field](s, fields, f);\n+      pclose(s);\n+    }\n+    case (ast.expr_call(?func,?args,_)) {\n+      print_expr(s, func);\n+      popen(s);\n+      commasep[@ast.expr](s, args, pe);\n+      pclose(s);\n+    }\n+    case (ast.expr_bind(?func,?args,_)) {\n+      impure fn print_opt(ps s, option.t[@ast.expr] expr) {\n+        alt (expr) {\n+          case (option.some[@ast.expr](?expr)) {\n+            print_expr(s, expr);\n+          }\n+          case (_) {wrd(s, \"_\");}\n+        }\n+      }\n+      wrd1(s, \"bind\");\n+      print_expr(s, func);\n+      popen(s);\n+      auto f = print_opt;\n+      commasep[option.t[@ast.expr]](s, args, f);\n+      pclose(s);\n+    }\n+    case (ast.expr_binary(?op,?lhs,?rhs,_)) {\n+      auto prec = operator_prec(op);\n+      print_maybe_parens(s, lhs, prec);\n+      space(s);\n+      wrd1(s, ast.binop_to_str(op));\n+      print_maybe_parens(s, rhs, prec + 1);\n+    }\n+    case (ast.expr_unary(?op,?expr,_)) {\n+      wrd(s, ast.unop_to_str(op));\n+      if (op == ast._mutable) {space(s);}\n+      print_expr(s, expr);\n+    }\n+    case (ast.expr_lit(?lit,_)) {\n+      print_literal(s, lit);\n+    }\n+    case (ast.expr_cast(?expr,?ty,_)) {\n+      print_maybe_parens(s, expr, as_prec);\n+      space(s);\n+      wrd1(s, \"as\");\n+      print_type(s, ty);\n+    }\n+    case (ast.expr_if(?test,?block,?clauses,?_else,_)) {\n+      impure fn print_clause(ps s, @ast.expr test, ast.block blk) {\n+        wrd1(s, \"if\");\n+        popen(s);\n+        print_expr(s, test);\n+        pclose(s);\n+        space(s);\n+        print_block(s, blk);\n+      }\n+      print_clause(s, test, block);\n+      for (tup(@ast.expr, ast.block) clause in clauses) {\n+        space(s);\n+        wrd1(s, \"else\");\n+        print_clause(s, clause._0, clause._1);\n+      }\n+      alt (_else) {\n+        case (option.some[ast.block](?blk)) {\n+          space(s);\n+          wrd1(s, \"else\");\n+          print_block(s, blk);\n+        }\n+      }\n+    }\n+    case (ast.expr_while(?test,?block,_)) {\n+      wrd1(s, \"while\");\n+      popen(s);\n+      print_expr(s, test);\n+      pclose(s);\n+      space(s);\n+      print_block(s, block);\n+    }\n+    case (ast.expr_for(?decl,?expr,?block,_)) {\n+      wrd1(s, \"for\");\n+      popen(s);\n+      print_decl(s, decl);\n+      space(s);\n+      wrd1(s, \"in\");\n+      print_expr(s, expr);\n+      pclose(s);\n+      space(s);\n+      print_block(s, block);\n+    }\n+    case (ast.expr_for_each(?decl,?expr,?block,_)) {\n+      wrd1(s, \"for each\");\n+      popen(s);\n+      print_decl(s, decl);\n+      space(s);\n+      wrd1(s, \"in\");\n+      print_expr(s, expr);\n+      space(s);\n+      print_block(s, block);\n+    }\n+    case (ast.expr_do_while(?block,?expr,_)) {\n+      wrd1(s, \"do\");\n+      space(s);\n+      print_block(s, block);\n+      space(s);\n+      wrd1(s, \"while\");\n+      popen(s);\n+      print_expr(s, expr);\n+      pclose(s);\n+    }\n+    case (ast.expr_alt(?expr,?arms,_)) {\n+      wrd1(s, \"alt\");\n+      popen(s);\n+      print_expr(s, expr);\n+      pclose(s);\n+      space(s);\n+      bopen(s);\n+      for (ast.arm arm in arms) {\n+        hbox(s);\n+        wrd1(s, \"case\");\n+        popen(s);\n+        print_pat(s, arm.pat);\n+        pclose(s);\n+        space(s);\n+        print_block(s, arm.block);\n+        end(s);\n+        line(s);\n+      }\n+      bclose(s);\n+    }\n+    case (ast.expr_block(?block,_)) {\n+      print_block(s, block);\n+    }\n+    case (ast.expr_assign(?lhs,?rhs,_)) {\n+      print_expr(s, lhs);\n+      space(s);\n+      wrd1(s, \"=\");\n+      print_expr(s, rhs);\n+    }\n+    case (ast.expr_assign_op(?op,?lhs,?rhs,_)) {\n+      print_expr(s, lhs);\n+      space(s);\n+      wrd(s, ast.binop_to_str(op));\n+      wrd1(s, \"=\");\n+      print_expr(s, rhs);\n+    }\n+    case (ast.expr_field(?expr,?id,_)) {\n+      print_expr(s, expr);\n+      wrd(s, \".\");\n+      wrd(s, id);\n+    }\n+    case (ast.expr_index(?expr,?index,_)) {\n+      print_expr(s, expr);\n+      wrd(s, \".\");\n+      popen(s);\n+      print_expr(s, index);\n+      pclose(s);\n+    }\n+    case (ast.expr_path(?path,_,_)) {\n+      print_path(s, path);\n+    }\n+    case (ast.expr_fail) {\n+      wrd(s, \"fail\");\n+    }\n+    case (ast.expr_ret(?result)) {\n+      wrd(s, \"ret\");\n+      alt (result) {\n+        case (option.some[@ast.expr](?expr)) {\n+          space(s);\n+          print_expr(s, expr);\n+        }\n+        case (_) {}\n+      }\n+    }\n+    case (ast.expr_put(?result)) {\n+      wrd(s, \"put\");\n+      alt (result) {\n+        case (option.some[@ast.expr](?expr)) {\n+          space(s);\n+          print_expr(s, expr);\n+        }\n+        case (_) {}\n+      }\n+    }\n+    case (ast.expr_be(?result)) {\n+      wrd1(s, \"be\");\n+      print_expr(s, result);\n+    }\n+    case (ast.expr_log(?expr)) {\n+      wrd1(s, \"log\");\n+      print_expr(s, expr);\n+    }\n+    case (ast.expr_check_expr(?expr)) {\n+      wrd1(s, \"check\");\n+      print_expr(s, expr);\n+    }\n+    case (_) {wrd(s, \"X\");}\n+    // TODO expr_ext(path, vec[@expr], option.t[@expr], @expr, ann);\n+  }\n+  end(s);\n+}\n+\n+impure fn print_decl(ps s, @ast.decl decl) {\n+  hbox(s);\n+  alt (decl.node) {\n+    case (ast.decl_local(?loc)) {\n+      alt (loc.ty) {\n+        case (option.some[@ast.ty](?ty)) {\n+          wrd1(s, \"let\");\n+          print_type(s, ty);\n+          space(s);\n+        }\n+        case (_) {\n+          wrd1(s, \"auto\");\n+        }\n+      }\n+      wrd(s, loc.ident);\n+      alt (loc.init) {\n+        case (option.some[@ast.expr](?init)) {\n+          space(s);\n+          wrd1(s, \"=\");\n+          print_expr(s, init);\n+        }\n+        case (_) {}\n+      }\n+    }\n+    case (ast.decl_item(?item)) {\n+      print_item(s, item);\n+    }\n+  }\n+  end(s);\n+}\n+\n+impure fn print_path(ps s, ast.path path) {\n+  auto first = true;\n+  for (str id in path.node.idents) {\n+    if (first) {first = false;}\n+    else {wrd(s, \".\");}\n+    wrd(s, id);\n+  }\n+  if (_vec.len[@ast.ty](path.node.types) > 0u) {\n+    wrd(s, \"[\");\n+    auto f = print_type;\n+    commasep[@ast.ty](s, path.node.types, f);\n+    wrd(s, \"]\");\n+  }\n+}\n+\n+impure fn print_pat(ps s, @ast.pat pat) {\n+  alt (pat.node) {\n+    case (ast.pat_wild(_)) {wrd(s, \"_\");}\n+    case (ast.pat_bind(?id,_,_)) {wrd(s, \"?\" + id);}\n+    case (ast.pat_lit(?lit,_)) {print_literal(s, lit);}\n+    case (ast.pat_tag(?path,?args,_,_)) {\n+      print_path(s, path);\n+      if (_vec.len[@ast.pat](args) > 0u) {\n+        popen(s);\n+        auto f = print_pat;\n+        commasep[@ast.pat](s, args, f);\n+        pclose(s);\n+      }\n+    }\n+  }\n+}\n+\n+impure fn print_fn(ps s, ast.fn_decl decl, str name,\n+                   vec[ast.ty_param] typarams) {\n+  alt (decl.effect) {\n+    case (ast.eff_impure) {wrd1(s, \"impure\");}\n+    case (ast.eff_unsafe) {wrd1(s, \"unsafe\");}\n+    case (_) {}\n+  }\n+  wrd1(s, \"fn\");\n+  wrd(s, name);\n+  print_type_params(s, typarams);\n+  popen(s);\n+  impure fn print_arg(ps s, ast.arg x) {\n+    hbox(s);\n+    print_type(s, x.ty);\n+    space(s);\n+    wrd(s, x.ident);\n+    end(s);\n+  }\n+  auto f = print_arg;\n+  commasep[ast.arg](s, decl.inputs, f);\n+  pclose(s);\n+  if (decl.output.node != ast.ty_nil) {\n+    space(s);\n+    hbox(s);\n+    wrd1(s, \"->\");\n+    print_type(s, decl.output);\n+    end(s);\n+  }\n+}\n+\n+impure fn print_type_params(ps s, vec[ast.ty_param] params) {\n+  if (_vec.len[ast.ty_param](params) > 0u) {\n+    wrd(s, \"[\");\n+    impure fn printParam(ps s, ast.ty_param param) {wrd(s, param.ident);}\n+    auto f = printParam;\n+    commasep[ast.ty_param](s, params, f);\n+    wrd(s, \"]\");\n+  }\n+}\n+\n+impure fn print_view_item(ps s, @ast.view_item item) {\n+  hbox(s);\n+  alt (item.node) {\n+    case (ast.view_item_use(?id,?mta,_)) {\n+      wrd1(s, \"use\");\n+      wrd(s, id);\n+      if (_vec.len[@ast.meta_item](mta) > 0u) {\n+        popen(s);\n+        impure fn print_meta(ps s, @ast.meta_item item) {\n+          hbox(s);\n+          wrd1(s, item.node.name);\n+          wrd1(s, \"=\");\n+          print_string(s, item.node.value);\n+          end(s);\n+        }\n+        auto f = print_meta;\n+        commasep[@ast.meta_item](s, mta, f);\n+        pclose(s);\n+      }\n+    }\n+    case (ast.view_item_import(?id,?ids,_,_)) {\n+      wrd1(s, \"import\");\n+      if (!_str.eq(id, ids.(_vec.len[str](ids)-1u))) {\n+        wrd1(s, id);\n+        wrd1(s, \"=\");\n+      }\n+      auto first = true;\n+      for (str elt in ids) {\n+        if (first) {first = false;}\n+        else {wrd(s, \".\");}\n+        wrd(s, elt);\n+      }\n+    }\n+    case (ast.view_item_export(?id)) {\n+      wrd1(s, \"export\");\n+      wrd(s, id);\n+    }\n+  }\n+  end(s);\n+  wrd(s, \";\");\n+  line(s);\n+}\n+\n+// FIXME: The fact that this builds up the table anew for every call is\n+// not good. Eventually, table should be a const.\n+fn operator_prec(ast.binop op) -> int {\n+  for (front.parser.op_spec spec in front.parser.prec_table()) {\n+    if (spec.op == op) {ret spec.prec;}\n+  }\n+  fail;\n+}\n+\n+impure fn print_maybe_parens(ps s, @ast.expr expr, int outer_prec) {\n+  auto add_them;\n+  alt (expr.node) {\n+    case (ast.expr_binary(?op,_,_,_)) {\n+      add_them = operator_prec(op) < outer_prec;\n+    }\n+    case (ast.expr_cast(_,_,_)) {\n+      add_them = as_prec < outer_prec;\n+    }\n+    case (_) {\n+      add_them = false;\n+    }\n+  }\n+  if (add_them) {popen(s);}\n+  print_expr(s, expr);\n+  if (add_them) {pclose(s);}\n+}\n+\n+// TODO non-ascii\n+fn escape_str(str st, char to_escape) -> str {\n+  let str out = \"\";\n+  auto len = _str.byte_len(st);\n+  auto i = 0u;\n+  while (i < len) {\n+    alt (st.(i) as char) {\n+      case ('\\n') {out += \"\\\\n\";}\n+      case ('\\t') {out += \"\\\\t\";}\n+      case ('\\r') {out += \"\\\\r\";}\n+      case ('\\\\') {out += \"\\\\\\\\\";}\n+      case (?cur) {\n+        if (cur == to_escape) {out += \"\\\\\";}\n+        out += cur as u8;\n+      }\n+    }\n+    i += 1u;\n+  }\n+  ret out;\n+}\n+\n+impure fn print_string(ps s, str st) {\n+  wrd(s, \"\\\"\"); wrd(s, escape_str(st, '\"')); wrd(s, \"\\\"\");\n+}"}, {"sha": "e483340949ee4fa9b21ea654511321959822f441", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "patch": "@@ -31,6 +31,11 @@ mod driver {\n     mod session;\n }\n \n+mod pretty {\n+    mod pp;\n+    mod pprust;\n+}\n+\n mod util {\n     mod common;\n }"}, {"sha": "0c4eb39e1aa00f4f3c760defe529d193c96c9089", "filename": "src/lib/io.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0624f9db4aeaa5681941750c3a1a17ca5fbb7e72/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=0624f9db4aeaa5681941750c3a1a17ca5fbb7e72", "patch": "@@ -91,24 +91,28 @@ tag fileflag {\n     truncate;\n }\n \n+fn writefd(int fd, vec[u8] v) {\n+    auto len = _vec.len[u8](v);\n+    auto count = 0u;\n+    auto vbuf;\n+    while (count < len) {\n+        vbuf = _vec.buf_off[u8](v, count);\n+        auto nout = os.libc.write(fd, vbuf, len);\n+        if (nout < 0) {\n+            log \"error dumping buffer\";\n+            log sys.rustrt.last_os_error();\n+            fail;\n+        }\n+        count += nout as uint;\n+    }\n+}\n+\n fn new_buf_writer(str path, vec[fileflag] flags) -> buf_writer {\n \n     state obj fd_buf_writer(int fd) {\n \n         fn write(vec[u8] v) {\n-            auto len = _vec.len[u8](v);\n-            auto count = 0u;\n-            auto vbuf;\n-            while (count < len) {\n-                vbuf = _vec.buf_off[u8](v, count);\n-                auto nout = os.libc.write(fd, vbuf, len);\n-                if (nout < 0) {\n-                    log \"error dumping buffer\";\n-                    log sys.rustrt.last_os_error();\n-                    fail;\n-                }\n-                count += nout as uint;\n-            }\n+            writefd(fd, v);\n         }\n \n         drop {"}]}