{"sha": "ba98228b4d4c2676edd074e39029952d8e841502", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhOTgyMjhiNGQ0YzI2NzZlZGQwNzRlMzkwMjk5NTJkOGU4NDE1MDI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-08-15T17:39:28Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-08-15T17:39:28Z"}, "message": "clean-up ExprStruct and PatStruct type-checking\n\nThis fixes the crazy \"transparent aliases\" bug, which I hope nobody\nrelied on.", "tree": {"sha": "80909a1a5c232c7be3c8c64c8f501a3cdc241ae4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80909a1a5c232c7be3c8c64c8f501a3cdc241ae4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba98228b4d4c2676edd074e39029952d8e841502", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba98228b4d4c2676edd074e39029952d8e841502", "html_url": "https://github.com/rust-lang/rust/commit/ba98228b4d4c2676edd074e39029952d8e841502", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba98228b4d4c2676edd074e39029952d8e841502/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b87c2926271dcf3d0556b16ae3ea8fec75058d4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b87c2926271dcf3d0556b16ae3ea8fec75058d4a", "html_url": "https://github.com/rust-lang/rust/commit/b87c2926271dcf3d0556b16ae3ea8fec75058d4a"}], "stats": {"total": 390, "additions": 145, "deletions": 245}, "files": [{"sha": "3757c55a162f30ea8ebee922cc737952b86e03ef", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 17, "deletions": 47, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ba98228b4d4c2676edd074e39029952d8e841502/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba98228b4d4c2676edd074e39029952d8e841502/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ba98228b4d4c2676edd074e39029952d8e841502", "patch": "@@ -19,6 +19,7 @@ use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n use check::{check_expr_with_lvalue_pref, LvaluePreference};\n use check::{instantiate_path, resolve_ty_and_def_ufcs, structurally_resolved_type};\n+use TypeAndSubsts;\n use require_same_types;\n use util::nodemap::FnvHashMap;\n \n@@ -526,62 +527,31 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n                                   etc: bool, expected: Ty<'tcx>) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n-    let report_nonstruct = || {\n-        let name = pprust::path_to_string(path);\n-        span_err!(tcx.sess, pat.span, E0163,\n-                  \"`{}` does not name a struct or a struct variant\", name);\n-        fcx.write_error(pat.id);\n-\n-        for field in fields {\n-            check_pat(pcx, &field.node.pat, tcx.types.err);\n-        }\n-    };\n \n     let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-    let (adt_def, variant) = match def {\n-        def::DefTy(did, _) | def::DefStruct(did) => {\n-            match tcx.lookup_item_type(did).ty.sty {\n-                ty::TyStruct(struct_def, _) =>\n-                    (struct_def, struct_def.struct_variant()),\n-                _ => {\n-                    report_nonstruct();\n-                    return;\n-                }\n-            }\n-        }\n-        def::DefVariant(eid, vid, true) => {\n-            match tcx.lookup_item_type(vid).ty.sty {\n-                ty::TyEnum(enum_def, _) if enum_def.did == eid => {\n-                    (enum_def, enum_def.variant_with_id(vid))\n-                }\n-                _ => tcx.sess.span_bug(pat.span, \"variant's type is not its enum\")\n+    let variant = match fcx.def_struct_variant(def) {\n+        Some((_, variant)) => variant,\n+        None => {\n+            let name = pprust::path_to_string(path);\n+            span_err!(tcx.sess, pat.span, E0163,\n+                      \"`{}` does not name a struct or a struct variant\", name);\n+            fcx.write_error(pat.id);\n+\n+            for field in fields {\n+                check_pat(pcx, &field.node.pat, tcx.types.err);\n             }\n-        }\n-        _ => {\n-            report_nonstruct();\n             return;\n         }\n     };\n \n-    instantiate_path(pcx.fcx,\n-                     &path.segments,\n-                     adt_def.type_scheme(tcx),\n-                     &adt_def.predicates(tcx),\n-                     None,\n-                     def,\n-                     pat.span,\n-                     pat.id);\n-\n-    let pat_ty = fcx.node_ty(pat.id);\n+    let TypeAndSubsts {\n+        ty: pat_ty, substs: item_substs\n+    } = pcx.fcx.instantiate_type(def.def_id(), path);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n-\n-    let item_substs = fcx\n-        .item_substs()\n-        .get(&pat.id)\n-        .map(|substs| substs.substs.clone())\n-        .unwrap_or_else(|| Substs::empty());\n-\n     check_struct_pat_fields(pcx, pat.span, fields, variant, &item_substs, etc);\n+\n+    fcx.write_ty(pat.id, pat_ty);\n+    fcx.write_substs(pat.id, ty::ItemSubsts { substs: item_substs });\n }\n \n pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,"}, {"sha": "facd60de6c283d097a3b1d23457104fc9a03f6fe", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 86, "deletions": 182, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/ba98228b4d4c2676edd074e39029952d8e841502/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba98228b4d4c2676edd074e39029952d8e841502/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ba98228b4d4c2676edd074e39029952d8e841502", "patch": "@@ -1379,65 +1379,64 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                        cause)\n     }\n \n-    /// Returns the type of `def_id` with all generics replaced by by fresh type/region variables.\n-    /// Also returns the substitution from the type parameters on `def_id` to the fresh variables.\n-    /// Registers any trait obligations specified on `def_id` at the same time.\n+    /// Instantiates the type in `did` with the generics in `path` and returns\n+    /// it (registering the necessary trait obligations along the way).\n     ///\n-    /// Note that function is only intended to be used with types (notably, not fns). This is\n-    /// because it doesn't do any instantiation of late-bound regions.\n+    /// Note that this function is only intended to be used with type-paths,\n+    /// not with value-paths.\n     pub fn instantiate_type(&self,\n-                            span: Span,\n-                            def_id: ast::DefId)\n+                            did: ast::DefId,\n+                            path: &ast::Path)\n                             -> TypeAndSubsts<'tcx>\n     {\n+        debug!(\"instantiate_type(did={:?}, path={:?})\", did, path);\n         let type_scheme =\n-            self.tcx().lookup_item_type(def_id);\n+            self.tcx().lookup_item_type(did);\n         let type_predicates =\n-            self.tcx().lookup_predicates(def_id);\n-        let substs =\n-            self.infcx().fresh_substs_for_generics(\n-                span,\n-                &type_scheme.generics);\n+            self.tcx().lookup_predicates(did);\n+        let substs = astconv::ast_path_substs_for_ty(self, self,\n+                                                     path.span,\n+                                                     PathParamMode::Optional,\n+                                                     &type_scheme.generics,\n+                                                     path.segments.last().unwrap());\n+        debug!(\"instantiate_type: ty={:?} substs={:?}\", &type_scheme.ty, &substs);\n         let bounds =\n-            self.instantiate_bounds(span, &substs, &type_predicates);\n+            self.instantiate_bounds(path.span, &substs, &type_predicates);\n         self.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n-                span,\n+                path.span,\n                 self.body_id,\n-                traits::ItemObligation(def_id)),\n+                traits::ItemObligation(did)),\n             &bounds);\n-        let monotype =\n-            self.instantiate_type_scheme(span, &substs, &type_scheme.ty);\n \n         TypeAndSubsts {\n-            ty: monotype,\n+            ty: self.instantiate_type_scheme(path.span, &substs, &type_scheme.ty),\n             substs: substs\n         }\n     }\n \n-    /// Returns the type that this AST path refers to. If the path has no type\n-    /// parameters and the corresponding type has type parameters, fresh type\n-    /// and/or region variables are substituted.\n-    ///\n-    /// This is used when checking the constructor in struct literals.\n-    fn instantiate_struct_literal_ty(&self,\n-                                     struct_ty: ty::TypeScheme<'tcx>,\n-                                     path: &ast::Path)\n-                                     -> TypeAndSubsts<'tcx>\n+    pub fn def_struct_variant(&self,\n+                              def: def::Def)\n+                              -> Option<(ty::AdtDef<'tcx>, ty::VariantDef<'tcx>)>\n     {\n-        let ty::TypeScheme { generics, ty: decl_ty } = struct_ty;\n-\n-        let substs = astconv::ast_path_substs_for_ty(self, self,\n-                                                     path.span,\n-                                                     PathParamMode::Optional,\n-                                                     &generics,\n-                                                     path.segments.last().unwrap());\n-\n-        let ty = self.instantiate_type_scheme(path.span, &substs, &decl_ty);\n-\n-        TypeAndSubsts { substs: substs, ty: ty }\n+        match def {\n+            def::DefVariant(enum_id, variant_id, true) => {\n+                let adt = self.tcx().lookup_adt_def(enum_id);\n+                Some((adt, adt.variant_with_id(variant_id)))\n+            }\n+            def::DefTy(did, _) | def::DefStruct(did) => {\n+                let typ = self.tcx().lookup_item_type(did);\n+                if let ty::TyStruct(adt, _) = typ.ty.sty {\n+                    Some((adt, adt.struct_variant()))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None\n+        }\n     }\n \n+\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx().mk_nil());\n     }\n@@ -3028,18 +3027,17 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n \n-    fn check_struct_or_variant_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                adt_ty: Ty<'tcx>,\n-                                                span: Span,\n-                                                variant_id: ast::DefId,\n-                                                ast_fields: &'tcx [ast::Field],\n-                                                check_completeness: bool) -> Result<(),()> {\n+    fn check_expr_struct_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                          adt_ty: Ty<'tcx>,\n+                                          span: Span,\n+                                          variant: ty::VariantDef<'tcx>,\n+                                          ast_fields: &'tcx [ast::Field],\n+                                          check_completeness: bool) {\n         let tcx = fcx.ccx.tcx;\n-        let (adt_def, substs) = match adt_ty.sty {\n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => (def, substs),\n-            _ => tcx.sess.span_bug(span, \"non-ADT passed to check_struct_or_variant_fields\")\n+        let substs = match adt_ty.sty {\n+            ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n+            _ => tcx.sess.span_bug(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n-        let variant = adt_def.variant_with_id(variant_id);\n \n         let mut remaining_fields = FnvHashMap();\n         for field in &variant.fields {\n@@ -3076,7 +3074,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             !error_happened &&\n             !remaining_fields.is_empty()\n         {\n-            error_happened = true;\n             span_err!(tcx.sess, span, E0063,\n                       \"missing field{}: {}\",\n                       if remaining_fields.len() == 1 {\"\"} else {\"s\"},\n@@ -3085,68 +3082,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                       .collect::<Vec<_>>()\n                                       .join(\", \"));\n         }\n-\n-        if error_happened { Err(()) } else { Ok(()) }\n-    }\n-\n-    fn check_struct_constructor<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                         id: ast::NodeId,\n-                                         span: codemap::Span,\n-                                         struct_def: ty::AdtDef<'tcx>,\n-                                         fields: &'tcx [ast::Field],\n-                                         base_expr: Option<&'tcx ast::Expr>) {\n-        let tcx = fcx.ccx.tcx;\n-\n-        // Generate the struct type.\n-        let TypeAndSubsts {\n-            ty: mut struct_type,\n-            substs: _\n-        } = fcx.instantiate_type(span, struct_def.did);\n-\n-        // Look up and check the fields.\n-        let res = check_struct_or_variant_fields(fcx,\n-                                                 struct_type,\n-                                                 span,\n-                                                 struct_def.did,\n-                                                 fields,\n-                                                 base_expr.is_none());\n-        if res.is_err() {\n-            struct_type = tcx.types.err;\n-        }\n-\n-        // Check the base expression if necessary.\n-        match base_expr {\n-            None => {}\n-            Some(base_expr) => {\n-                check_expr_has_type(fcx, &*base_expr, struct_type);\n-            }\n-        }\n-\n-        // Write in the resulting type.\n-        fcx.write_ty(id, struct_type);\n-    }\n-\n-    fn check_struct_enum_variant<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                          id: ast::NodeId,\n-                                          span: codemap::Span,\n-                                          enum_id: ast::DefId,\n-                                          variant_id: ast::DefId,\n-                                          fields: &'tcx [ast::Field]) {\n-        // Look up the number of type parameters and the raw type, and\n-        // determine whether the enum is region-parameterized.\n-        let TypeAndSubsts {\n-            ty: enum_type,\n-            substs: _\n-        } = fcx.instantiate_type(span, enum_id);\n-\n-        // Look up and check the enum variant fields.\n-        let _ = check_struct_or_variant_fields(fcx,\n-                                               enum_type,\n-                                               span,\n-                                               variant_id,\n-                                               fields,\n-                                               true);\n-        fcx.write_ty(id, enum_type);\n     }\n \n     fn check_struct_fields_on_error<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n@@ -3165,16 +3100,42 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n-    fn report_exprstruct_on_nondict<'a, 'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                              id: ast::NodeId,\n-                                              fields: &'tcx [ast::Field],\n-                                              base_expr: &'tcx Option<P<ast::Expr>>,\n-                                              path: &ast::Path)\n+    fn check_expr_struct<'a, 'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                   expr: &ast::Expr,\n+                                   path: &ast::Path,\n+                                   fields: &'tcx [ast::Field],\n+                                   base_expr: &'tcx Option<P<ast::Expr>>)\n     {\n-        span_err!(fcx.tcx().sess, path.span, E0071,\n-                  \"`{}` does not name a structure\",\n-                  pprust::path_to_string(path));\n-        check_struct_fields_on_error(fcx, id, fields, base_expr)\n+        let tcx = fcx.tcx();\n+\n+        // Find the relevant variant\n+        let def = lookup_full_def(tcx, path.span, expr.id);\n+        let (adt, variant) = match fcx.def_struct_variant(def) {\n+            Some((adt, variant)) => (adt, variant),\n+            None => {\n+                span_err!(fcx.tcx().sess, path.span, E0071,\n+                          \"`{}` does not name a structure\",\n+                          pprust::path_to_string(path));\n+                check_struct_fields_on_error(fcx, expr.id, fields, base_expr);\n+                return;\n+            }\n+        };\n+\n+        let TypeAndSubsts {\n+            ty: expr_ty, ..\n+        } = fcx.instantiate_type(def.def_id(), path);\n+        fcx.write_ty(expr.id, expr_ty);\n+\n+        check_expr_struct_fields(fcx, expr_ty, expr.span, variant, fields,\n+                                 base_expr.is_none());\n+\n+        if let &Some(ref base_expr) = base_expr {\n+            check_expr_has_type(fcx, base_expr, expr_ty);\n+            if adt.adt_kind() == ty::AdtKind::Enum {\n+                span_err!(tcx.sess, base_expr.span, E0436,\n+                          \"functional record update syntax requires a struct\");\n+            }\n+        }\n     }\n \n     type ExprCheckerWithTy = fn(&FnCtxt, &ast::Expr, Ty);\n@@ -3625,67 +3586,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       ast::ExprStruct(ref path, ref fields, ref base_expr) => {\n-        // Resolve the path.\n-        let def = lookup_full_def(tcx, path.span, id);\n-\n-        let struct_ty = match def {\n-            def::DefVariant(enum_id, variant_id, true) => {\n-                if let &Some(ref base_expr) = base_expr {\n-                    span_err!(tcx.sess, base_expr.span, E0436,\n-                              \"functional record update syntax requires a struct\");\n-                    fcx.write_error(base_expr.id);\n-                }\n-                check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, &fields[..]);\n-                Some(tcx.lookup_item_type(enum_id))\n-            }\n-            def::DefTy(did, _) | def::DefStruct(did) => {\n-                // Verify that this was actually a struct.\n-                let typ = tcx.lookup_item_type(did);\n-                if let ty::TyStruct(struct_def, _) = typ.ty.sty {\n-                    check_struct_constructor(fcx,\n-                                             id,\n-                                             expr.span,\n-                                             struct_def,\n-                                             &fields,\n-                                             base_expr.as_ref().map(|e| &**e));\n-                } else {\n-                    report_exprstruct_on_nondict(fcx, id, &fields, base_expr, path);\n-                }\n-                Some(typ)\n-            }\n-            _ => {\n-                report_exprstruct_on_nondict(fcx, id, &fields, base_expr, path);\n-                None\n-            }\n-        };\n-\n-        // Turn the path into a type and verify that that type unifies with\n-        // the resulting structure type. This is needed to handle type\n-        // parameters correctly.\n-        if let Some(struct_ty) = struct_ty {\n-            let expr_ty = fcx.expr_ty(&expr);\n-            let type_and_substs = fcx.instantiate_struct_literal_ty(struct_ty, path);\n-            match fcx.mk_subty(false,\n-                               infer::Misc(path.span),\n-                               expr_ty,\n-                               type_and_substs.ty) {\n-                Ok(()) => {}\n-                Err(type_error) => {\n-                    span_err!(fcx.tcx().sess, path.span, E0235,\n-                                 \"structure constructor specifies a \\\n-                                         structure of type `{}`, but this \\\n-                                         structure has type `{}`: {}\",\n-                                         fcx.infcx()\n-                                            .ty_to_string(type_and_substs.ty),\n-                                         fcx.infcx()\n-                                            .ty_to_string(expr_ty),\n-                                         type_error);\n-                    tcx.note_and_explain_type_err(&type_error, path.span);\n-                }\n-            }\n-        }\n-\n+        check_expr_struct(fcx, expr, path, fields, base_expr);\n         fcx.require_expr_have_sized_type(expr, traits::StructInitializerSized);\n       }\n       ast::ExprField(ref base, ref field) => {\n@@ -4673,6 +4574,9 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n+    debug!(\"instantiate_path: type of {:?} is {:?}\",\n+           node_id,\n+           ty_substituted);\n     fcx.write_ty(node_id, ty_substituted);\n     fcx.write_substs(node_id, ty::ItemSubsts { substs: substs });\n     return;"}, {"sha": "e10b53f7eaf22008737109f147044dcb893ae845", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ba98228b4d4c2676edd074e39029952d8e841502/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba98228b4d4c2676edd074e39029952d8e841502/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ba98228b4d4c2676edd074e39029952d8e841502", "patch": "@@ -746,7 +746,8 @@ enum Foo { FirstValue(i32) };\n let u = Foo::FirstValue { value: 0i32 }; // error: Foo::FirstValue\n                                          // isn't a structure!\n // or even simpler, if the name doesn't refer to a structure at all.\n-let t = u32 { value: 4 }; // error: `u32` does not name a structure.```\n+let t = u32 { value: 4 }; // error: `u32` does not name a structure.\n+```\n \n To fix this, ensure that the name was correctly spelled, and that\n the correct form of initializer was used.\n@@ -2681,7 +2682,7 @@ register_diagnostics! {\n     E0231, // only named substitution parameters are allowed\n     E0233,\n     E0234,\n-    E0235, // structure constructor specifies a structure of type but\n+//  E0235, // structure constructor specifies a structure of type but\n     E0236, // no lang item for range syntax\n     E0237, // no lang item for range syntax\n     E0238, // parenthesized parameters may only be used with a trait"}, {"sha": "69e10b90bfeba917a6e89378512172d9d93fcb19", "filename": "src/test/compile-fail/issue-15034.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba98228b4d4c2676edd074e39029952d8e841502/src%2Ftest%2Fcompile-fail%2Fissue-15034.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba98228b4d4c2676edd074e39029952d8e841502/src%2Ftest%2Fcompile-fail%2Fissue-15034.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15034.rs?ref=ba98228b4d4c2676edd074e39029952d8e841502", "patch": "@@ -25,7 +25,7 @@ struct Parser<'a> {\n impl<'a> Parser<'a> {\n     pub fn new(lexer: &'a mut Lexer) -> Parser<'a> {\n         Parser { lexer: lexer }\n-        //~^ ERROR cannot infer an appropriate lifetime for lifetime parameter\n+        //~^ ERROR cannot infer an appropriate lifetime\n     }\n }\n "}, {"sha": "7a6b8ff662240314cfa9086b1055639a24bbc544", "filename": "src/test/compile-fail/structure-constructor-type-mismatch.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ba98228b4d4c2676edd074e39029952d8e841502/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba98228b4d4c2676edd074e39029952d8e841502/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs?ref=ba98228b4d4c2676edd074e39029952d8e841502", "patch": "@@ -24,41 +24,66 @@ type PairF<U> = Pair<f32,U>;\n \n fn main() {\n     let pt = PointF {\n-        //~^ ERROR structure constructor specifies a structure of type\n+        x: 1,\n+        //~^ ERROR mismatched types\n         //~| expected f32\n         //~| found integral variable\n-        x: 1,\n         y: 2,\n+        //~^ ERROR mismatched types\n+        //~| expected f32\n+        //~| found integral variable\n     };\n \n     let pt2 = Point::<f32> {\n-        //~^ ERROR structure constructor specifies a structure of type\n+        x: 3,\n+        //~^ ERROR mismatched types\n         //~| expected f32\n         //~| found integral variable\n-        x: 3,\n         y: 4,\n+        //~^ ERROR mismatched types\n+        //~| expected f32\n+        //~| found integral variable\n     };\n \n     let pair = PairF {\n-        //~^ ERROR structure constructor specifies a structure of type\n+        x: 5,\n+        //~^ ERROR mismatched types\n         //~| expected f32\n         //~| found integral variable\n-        x: 5,\n         y: 6,\n     };\n \n     let pair2 = PairF::<i32> {\n-        //~^ ERROR structure constructor specifies a structure of type\n+        x: 7,\n+        //~^ ERROR mismatched types\n         //~| expected f32\n         //~| found integral variable\n-        x: 7,\n         y: 8,\n     };\n \n-    let pt3 = PointF::<i32> {\n-        //~^ ERROR wrong number of type arguments\n-        //~| ERROR structure constructor specifies a structure of type\n-        x: 9,\n-        y: 10,\n+    let pt3 = PointF::<i32> { //~ ERROR wrong number of type arguments\n+        x: 9,  //~ ERROR mismatched types\n+        y: 10, //~ ERROR mismatched types\n     };\n+\n+    match (Point { x: 1, y: 2 }) {\n+        PointF::<u32> { .. } => {} //~ ERROR wrong number of type arguments\n+        //~^ ERROR mismatched types\n+    }\n+\n+    match (Point { x: 1, y: 2 }) {\n+        PointF { .. } => {} //~ ERROR mismatched types\n+    }\n+\n+    match (Point { x: 1.0, y: 2.0 }) {\n+        PointF { .. } => {} // ok\n+    }\n+\n+    match (Pair { x: 1, y: 2 }) {\n+        PairF::<u32> { .. } => {} //~ ERROR mismatched types\n+    }\n+\n+    match (Pair { x: 1.0, y: 2 }) {\n+        PairF::<u32> { .. } => {} // ok\n+    }\n }"}]}