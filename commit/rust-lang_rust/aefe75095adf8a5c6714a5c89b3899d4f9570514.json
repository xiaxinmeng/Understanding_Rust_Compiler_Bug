{"sha": "aefe75095adf8a5c6714a5c89b3899d4f9570514", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZmU3NTA5NWFkZjhhNWM2NzE0YTVjODliMzg5OWQ0Zjk1NzA1MTQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-03-07T15:47:40Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-03-21T21:49:43Z"}, "message": "Add bounds for return types as well", "tree": {"sha": "0a28773ae7f560b55cc1118c1b10b5aed16ab832", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a28773ae7f560b55cc1118c1b10b5aed16ab832"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aefe75095adf8a5c6714a5c89b3899d4f9570514", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aefe75095adf8a5c6714a5c89b3899d4f9570514", "html_url": "https://github.com/rust-lang/rust/commit/aefe75095adf8a5c6714a5c89b3899d4f9570514", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aefe75095adf8a5c6714a5c89b3899d4f9570514/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ae73e2ff607e6d7dc8b49ce223961f12471cc38", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ae73e2ff607e6d7dc8b49ce223961f12471cc38", "html_url": "https://github.com/rust-lang/rust/commit/6ae73e2ff607e6d7dc8b49ce223961f12471cc38"}], "stats": {"total": 89, "additions": 59, "deletions": 30}, "files": [{"sha": "af724a659cde473a59bf4de109ab4914d245a6b8", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aefe75095adf8a5c6714a5c89b3899d4f9570514/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aefe75095adf8a5c6714a5c89b3899d4f9570514/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=aefe75095adf8a5c6714a5c89b3899d4f9570514", "patch": "@@ -214,7 +214,7 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     let predicates = cx.tcx.predicates_of(did);\n     let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n     let decl = (did, sig).clean(cx);\n-    let all_types = clean::get_all_types(&generics, &decl, cx);\n+    let (all_types, ret_types) = clean::get_all_types(&generics, &decl, cx);\n     clean::Function {\n         decl,\n         generics,\n@@ -225,6 +225,7 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n             asyncness: hir::IsAsync::NotAsync,\n         },\n         all_types,\n+        ret_types,\n     }\n }\n "}, {"sha": "415d031840743f103a49e252117f85ee5ee22773", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/aefe75095adf8a5c6714a5c89b3899d4f9570514/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aefe75095adf8a5c6714a5c89b3899d4f9570514/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=aefe75095adf8a5c6714a5c89b3899d4f9570514", "patch": "@@ -1751,7 +1751,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n }\n \n // The point is to replace bounds with types.\n-pub fn get_real_types(\n+fn get_real_types(\n     generics: &Generics,\n     arg: &Type,\n     cx: &DocContext<'_, '_, '_>,\n@@ -1822,7 +1822,7 @@ pub fn get_all_types(\n     generics: &Generics,\n     decl: &FnDecl,\n     cx: &DocContext<'_, '_, '_>,\n-) -> Vec<Type> {\n+) -> (Vec<Type>, Vec<Type>) {\n     let mut all_types = Vec::new();\n     for arg in decl.inputs.values.iter() {\n         if arg.type_.is_self_type() {\n@@ -1837,7 +1837,23 @@ pub fn get_all_types(\n     // FIXME: use a HashSet instead?\n     all_types.sort_unstable_by(|a, b| a.to_string().partial_cmp(&b.to_string()).unwrap());\n     all_types.dedup();\n-    all_types\n+\n+    let mut ret_types = match decl.output {\n+        FunctionRetTy::Return(ref return_type) => {\n+            let mut ret = Vec::new();\n+            if let Some(mut args) = get_real_types(generics, &return_type, cx) {\n+                ret.append(&mut args);\n+            } else {\n+                ret.push(return_type.clone());\n+            }\n+            ret\n+        }\n+        _ => Vec::new(),\n+    };\n+    // FIXME: use a HashSet instead?\n+    ret_types.sort_unstable_by(|a, b| a.to_string().partial_cmp(&b.to_string()).unwrap());\n+    ret_types.dedup();\n+    (all_types, ret_types)\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -1847,6 +1863,7 @@ pub struct Method {\n     pub header: hir::FnHeader,\n     pub defaultness: Option<hir::Defaultness>,\n     pub all_types: Vec<Type>,\n+    pub ret_types: Vec<Type>,\n }\n \n impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId,\n@@ -1855,13 +1872,14 @@ impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId,\n         let (generics, decl) = enter_impl_trait(cx, || {\n             (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx))\n         });\n-        let all_types = get_all_types(&generics, &decl, cx);\n+        let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n         Method {\n             decl,\n             generics,\n             header: self.0.header,\n             defaultness: self.3,\n             all_types,\n+            ret_types,\n         }\n     }\n }\n@@ -1872,6 +1890,7 @@ pub struct TyMethod {\n     pub decl: FnDecl,\n     pub generics: Generics,\n     pub all_types: Vec<Type>,\n+    pub ret_types: Vec<Type>,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -1880,6 +1899,7 @@ pub struct Function {\n     pub generics: Generics,\n     pub header: hir::FnHeader,\n     pub all_types: Vec<Type>,\n+    pub ret_types: Vec<Type>,\n }\n \n impl Clean<Item> for doctree::Function {\n@@ -1894,7 +1914,7 @@ impl Clean<Item> for doctree::Function {\n         } else {\n             hir::Constness::NotConst\n         };\n-        let all_types = get_all_types(&generics, &decl, cx);\n+        let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -1908,6 +1928,7 @@ impl Clean<Item> for doctree::Function {\n                 generics,\n                 header: hir::FnHeader { constness, ..self.header },\n                 all_types,\n+                ret_types,\n             }),\n         }\n     }\n@@ -2177,12 +2198,13 @@ impl Clean<Item> for hir::TraitItem {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                 });\n-                let all_types = get_all_types(&generics, &decl, cx);\n+                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 TyMethodItem(TyMethod {\n                     header: sig.header,\n                     decl,\n                     generics,\n                     all_types,\n+                    ret_types,\n                 })\n             }\n             hir::TraitItemKind::Type(ref bounds, ref default) => {\n@@ -2280,7 +2302,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     ty::ImplContainer(_) => true,\n                     ty::TraitContainer(_) => self.defaultness.has_value()\n                 };\n-                let all_types = get_all_types(&generics, &decl, cx);\n+                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 if provided {\n                     let constness = if cx.tcx.is_min_const_fn(self.def_id) {\n                         hir::Constness::Const\n@@ -2298,6 +2320,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                         },\n                         defaultness: Some(self.defaultness),\n                         all_types,\n+                        ret_types,\n                     })\n                 } else {\n                     TyMethodItem(TyMethod {\n@@ -2310,6 +2333,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                             asyncness: hir::IsAsync::NotAsync,\n                         },\n                         all_types,\n+                        ret_types,\n                     })\n                 }\n             }\n@@ -3976,7 +4000,7 @@ impl Clean<Item> for hir::ForeignItem {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n                 });\n-                let all_types = get_all_types(&generics, &decl, cx);\n+                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 ForeignFunctionItem(Function {\n                     decl,\n                     generics,\n@@ -3987,6 +4011,7 @@ impl Clean<Item> for hir::ForeignItem {\n                         asyncness: hir::IsAsync::NotAsync,\n                     },\n                     all_types,\n+                    ret_types,\n                 })\n             }\n             hir::ForeignItemKind::Static(ref ty, mutbl) => {"}, {"sha": "ec93bbbf9be69a41827bbd337f79a6dc1be96cfd", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/aefe75095adf8a5c6714a5c89b3899d4f9570514/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aefe75095adf8a5c6714a5c89b3899d4f9570514/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=aefe75095adf8a5c6714a5c89b3899d4f9570514", "patch": "@@ -446,7 +446,7 @@ impl ToJson for Type {\n                 }\n                 Json::Array(data)\n             }\n-            None => Json::Null\n+            None => Json::Null,\n         }\n     }\n }\n@@ -455,7 +455,7 @@ impl ToJson for Type {\n #[derive(Debug)]\n struct IndexItemFunctionType {\n     inputs: Vec<Type>,\n-    output: Option<Type>,\n+    output: Vec<Type>,\n }\n \n impl ToJson for IndexItemFunctionType {\n@@ -466,8 +466,8 @@ impl ToJson for IndexItemFunctionType {\n         } else {\n             let mut data = Vec::with_capacity(2);\n             data.push(self.inputs.to_json());\n-            if let Some(ref output) = self.output {\n-                data.push(output.to_json());\n+            if !self.output.is_empty() {\n+                data.push(self.output.to_json());\n             }\n             Json::Array(data)\n         }\n@@ -5025,24 +5025,21 @@ fn make_item_keywords(it: &clean::Item) -> String {\n }\n \n fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n-    let (decl, all_types) = match item.inner {\n-        clean::FunctionItem(ref f) => (&f.decl, &f.all_types),\n-        clean::MethodItem(ref m) => (&m.decl, &m.all_types),\n-        clean::TyMethodItem(ref m) => (&m.decl, &m.all_types),\n+    let (all_types, ret_types) = match item.inner {\n+        clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n+        clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),\n         _ => return None,\n     };\n \n     let inputs = all_types.iter().map(|arg| {\n         get_index_type(&arg)\n     }).collect();\n-    let output = match decl.output {\n-        clean::FunctionRetTy::Return(ref return_type) => {\n-            Some(get_index_type(return_type))\n-        },\n-        _ => None,\n-    };\n+    let output = ret_types.iter().map(|arg| {\n+        get_index_type(&arg)\n+    }).collect();\n \n-    Some(IndexItemFunctionType { inputs: inputs, output: output })\n+    Some(IndexItemFunctionType { inputs, output })\n }\n \n fn get_index_type(clean_type: &clean::Type) -> Type {"}, {"sha": "c9880f4c4117706c37ce44dc86150b30aa4c4151", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aefe75095adf8a5c6714a5c89b3899d4f9570514/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/aefe75095adf8a5c6714a5c89b3899d4f9570514/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=aefe75095adf8a5c6714a5c89b3899d4f9570514", "patch": "@@ -755,13 +755,19 @@ if (!DOMTokenList.prototype.remove) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n \n                 if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n-                    var tmp = checkType(obj.type[OUTPUT_DATA], val, literalSearch);\n-                    if (literalSearch === true && tmp === true) {\n-                        return true;\n+                    var ret = obj.type[OUTPUT_DATA];\n+                    if (!obj.type[OUTPUT_DATA].length) {\n+                        ret = [ret];\n                     }\n-                    lev_distance = Math.min(tmp, lev_distance);\n-                    if (lev_distance === 0) {\n-                        return 0;\n+                    for (var x = 0; x < ret.length; ++x) {\n+                        var tmp = checkType(ret[x], val, literalSearch);\n+                        if (literalSearch === true && tmp === true) {\n+                            return true;\n+                        }\n+                        lev_distance = Math.min(tmp, lev_distance);\n+                        if (lev_distance === 0) {\n+                            return 0;\n+                        }\n                     }\n                 }\n                 return literalSearch === true ? false : lev_distance;"}]}