{"sha": "1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "node_id": "C_kwDOAAsO6NoAKDFmZjViMmNhYjQ4NzE2ZTI2M2YzZTljMzljZjFlZmE5YmI5MDc3OTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-14T20:20:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-14T20:20:01Z"}, "message": "Auto merge of #12251 - matklad:lsp-server, r=matklad\n\ninternal: vendor lsp-server", "tree": {"sha": "25295c283f45e523ceaeb3230c3c306ee0f36495", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25295c283f45e523ceaeb3230c3c306ee0f36495"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "html_url": "https://github.com/rust-lang/rust/commit/1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50ed1a507e2332ab5da715798a9f3fd1532bc8e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/50ed1a507e2332ab5da715798a9f3fd1532bc8e1", "html_url": "https://github.com/rust-lang/rust/commit/50ed1a507e2332ab5da715798a9f3fd1532bc8e1"}, {"sha": "57cb65bb7a0c52965e0a5ea55ba6cb7c3811abb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/57cb65bb7a0c52965e0a5ea55ba6cb7c3811abb8", "html_url": "https://github.com/rust-lang/rust/commit/57cb65bb7a0c52965e0a5ea55ba6cb7c3811abb8"}], "stats": {"total": 955, "additions": 946, "deletions": 9}, "files": [{"sha": "917eed6d12174c84cb32d6571b71296f8acc1276", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -866,11 +866,10 @@ dependencies = [\n [[package]]\n name = \"lsp-server\"\n version = \"0.6.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f70570c1c29cf6654029b8fe201a5507c153f0d85be6f234d471d756bc36775a\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"log\",\n+ \"lsp-types\",\n  \"serde\",\n  \"serde_json\",\n ]"}, {"sha": "82222129361b8c6f15a4b3240067e7b179c65b3a", "filename": "crates/hir-def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/crates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/crates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2FCargo.toml?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -26,7 +26,7 @@ itertools = \"0.10.3\"\n indexmap = \"1.8.0\"\n smallvec = \"1.8.0\"\n arrayvec = \"0.7.2\"\n-la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n+la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n base-db = { path = \"../base-db\", version = \"0.0.0\" }"}, {"sha": "2a7e26fa2e959ba0ea8dfb8eec8a36f020306d68", "filename": "crates/hir-expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/crates%2Fhir-expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/crates%2Fhir-expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2FCargo.toml?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -14,7 +14,7 @@ cov-mark = \"2.0.0-pre.1\"\n tracing = \"0.1.32\"\n either = \"1.6.1\"\n rustc-hash = \"1.1.0\"\n-la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n+la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n itertools = \"0.10.3\"\n hashbrown = { version = \"0.12.0\", features = [\n     \"inline-more\","}, {"sha": "10362f390bbc2f6b4b259d46a54f09e32c68c1f5", "filename": "crates/hir-ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/crates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/crates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2FCargo.toml?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -21,7 +21,7 @@ scoped-tls = \"1.0.0\"\n chalk-solve = { version = \"0.82.0\", default-features = false }\n chalk-ir = \"0.82.0\"\n chalk-recursive = { version = \"0.82.0\", default-features = false }\n-la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n+la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n once_cell = \"1.10.0\"\n typed-arena = \"2.0.1\"\n "}, {"sha": "f37b362ebd6186323f23d2235becef75c8fa8337", "filename": "crates/profile/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/crates%2Fprofile%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/crates%2Fprofile%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fprofile%2FCargo.toml?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -13,7 +13,7 @@ doctest = false\n once_cell = \"1.10.0\"\n cfg-if = \"1.0.0\"\n libc = \"0.2.121\"\n-la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n+la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n countme = { version = \"3.0.1\", features = [\"enable\"] }\n jemalloc-ctl = { version = \"0.4.2\", package = \"tikv-jemalloc-ctl\", optional = true }\n "}, {"sha": "ecf3bcc8aba32de2db4e89c258d1c8d1dc728bd9", "filename": "crates/project-model/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/crates%2Fproject-model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/crates%2Fproject-model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2FCargo.toml?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -18,7 +18,7 @@ serde = { version = \"1.0.136\", features = [\"derive\"] }\n serde_json = \"1.0.79\"\n anyhow = \"1.0.56\"\n expect-test = \"1.2.2\"\n-la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n+la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n \n cfg = { path = \"../cfg\", version = \"0.0.0\" }\n base-db = { path = \"../base-db\", version = \"0.0.0\" }"}, {"sha": "133459bf1d2154b6cf5889c1de056df4281ff7fe", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -33,7 +33,7 @@ threadpool = \"1.8.1\"\n rayon = \"1.5.1\"\n num_cpus = \"1.13.1\"\n mimalloc = { version = \"0.1.28\", default-features = false, optional = true }\n-lsp-server = \"0.6.0\"\n+lsp-server = { version = \"0.6.0\", path = \"../../lib/lsp-server\" }\n tracing = \"0.1.32\"\n tracing-subscriber = { version = \"0.3.9\", default-features = false, features = [\n     \"env-filter\","}, {"sha": "ec5ba8ba00c8f7a2768096b9be62cf826cb0dda4", "filename": "lib/la-arena/Cargo.toml", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Fla-arena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Fla-arena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2FCargo.toml?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -3,7 +3,7 @@ name = \"la-arena\"\n version = \"0.3.0\"\n description = \"Simple index-based arena without deletion.\"\n license = \"MIT OR Apache-2.0\"\n-repository = \"https://github.com/rust-lang/rust-analyzer\"\n+repository = \"https://github.com/rust-lang/rust-analyzer/tree/master/lib/la-arena\"\n documentation = \"https://docs.rs/la-arena\"\n categories = [\"data-structures\", \"memory-management\", \"rust-patterns\"]\n edition = \"2021\"", "previous_filename": "lib/arena/Cargo.toml"}, {"sha": "9fe6d6062342175c6ac60320a6281a8982353858", "filename": "lib/la-arena/src/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Flib.rs?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "previous_filename": "lib/arena/src/lib.rs"}, {"sha": "d27f086d37bf22350413667bae9b37d8fa88cff2", "filename": "lib/la-arena/src/map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Fla-arena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Fla-arena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Fmap.rs?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "previous_filename": "lib/arena/src/map.rs"}, {"sha": "fd92cbe195f321e69153d0e1ae9087beb744753e", "filename": "lib/lsp-server/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2FCargo.toml?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -0,0 +1,16 @@\n+[package]\n+name = \"lsp-server\"\n+version = \"0.6.0\"\n+description = \"Generic LSP server scaffold.\"\n+license = \"MIT OR Apache-2.0\"\n+repository = \"https://github.com/rust-analyzer/rust-analyzer/tree/master/lib/lsp-server\"\n+edition = \"2021\"\n+\n+[dependencies]\n+log = \"0.4.3\"\n+serde_json = \"1.0.34\"\n+serde = { version = \"1.0.83\", features = [\"derive\"] }\n+crossbeam-channel = \"0.5.4\"\n+\n+[dev-dependencies]\n+lsp-types = \"0.93.0\""}, {"sha": "ca7ad0b53673933ed0be41d9855812276ce2ef56", "filename": "lib/lsp-server/examples/goto_def.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fexamples%2Fgoto_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fexamples%2Fgoto_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2Fexamples%2Fgoto_def.rs?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -0,0 +1,121 @@\n+//! A minimal example LSP server that can only respond to the `gotoDefinition` request. To use\n+//! this example, execute it and then send an `initialize` request.\n+//!\n+//! ```no_run\n+//! Content-Length: 85\n+//!\n+//! {\"jsonrpc\": \"2.0\", \"method\": \"initialize\", \"id\": 1, \"params\": {\"capabilities\": {}}}\n+//! ```\n+//!\n+//! This will respond with a server response. Then send it a `initialized` notification which will\n+//! have no response.\n+//!\n+//! ```no_run\n+//! Content-Length: 59\n+//!\n+//! {\"jsonrpc\": \"2.0\", \"method\": \"initialized\", \"params\": {}}\n+//! ```\n+//!\n+//! Once these two are sent, then we enter the main loop of the server. The only request this\n+//! example can handle is `gotoDefinition`:\n+//!\n+//! ```no_run\n+//! Content-Length: 159\n+//!\n+//! {\"jsonrpc\": \"2.0\", \"method\": \"textDocument/definition\", \"id\": 2, \"params\": {\"textDocument\": {\"uri\": \"file://temp\"}, \"position\": {\"line\": 1, \"character\": 1}}}\n+//! ```\n+//!\n+//! To finish up without errors, send a shutdown request:\n+//!\n+//! ```no_run\n+//! Content-Length: 67\n+//!\n+//! {\"jsonrpc\": \"2.0\", \"method\": \"shutdown\", \"id\": 3, \"params\": null}\n+//! ```\n+//!\n+//! The server will exit the main loop and finally we send a `shutdown` notification to stop\n+//! the server.\n+//!\n+//! ```\n+//! Content-Length: 54\n+//!\n+//! {\"jsonrpc\": \"2.0\", \"method\": \"exit\", \"params\": null}\n+//! ```\n+use std::error::Error;\n+\n+use lsp_types::OneOf;\n+use lsp_types::{\n+    request::GotoDefinition, GotoDefinitionResponse, InitializeParams, ServerCapabilities,\n+};\n+\n+use lsp_server::{Connection, ExtractError, Message, Request, RequestId, Response};\n+\n+fn main() -> Result<(), Box<dyn Error + Sync + Send>> {\n+    // Note that  we must have our logging only write out to stderr.\n+    eprintln!(\"starting generic LSP server\");\n+\n+    // Create the transport. Includes the stdio (stdin and stdout) versions but this could\n+    // also be implemented to use sockets or HTTP.\n+    let (connection, io_threads) = Connection::stdio();\n+\n+    // Run the server and wait for the two threads to end (typically by trigger LSP Exit event).\n+    let server_capabilities = serde_json::to_value(&ServerCapabilities {\n+        definition_provider: Some(OneOf::Left(true)),\n+        ..Default::default()\n+    })\n+    .unwrap();\n+    let initialization_params = connection.initialize(server_capabilities)?;\n+    main_loop(connection, initialization_params)?;\n+    io_threads.join()?;\n+\n+    // Shut down gracefully.\n+    eprintln!(\"shutting down server\");\n+    Ok(())\n+}\n+\n+fn main_loop(\n+    connection: Connection,\n+    params: serde_json::Value,\n+) -> Result<(), Box<dyn Error + Sync + Send>> {\n+    let _params: InitializeParams = serde_json::from_value(params).unwrap();\n+    eprintln!(\"starting example main loop\");\n+    for msg in &connection.receiver {\n+        eprintln!(\"got msg: {:?}\", msg);\n+        match msg {\n+            Message::Request(req) => {\n+                if connection.handle_shutdown(&req)? {\n+                    return Ok(());\n+                }\n+                eprintln!(\"got request: {:?}\", req);\n+                match cast::<GotoDefinition>(req) {\n+                    Ok((id, params)) => {\n+                        eprintln!(\"got gotoDefinition request #{}: {:?}\", id, params);\n+                        let result = Some(GotoDefinitionResponse::Array(Vec::new()));\n+                        let result = serde_json::to_value(&result).unwrap();\n+                        let resp = Response { id, result: Some(result), error: None };\n+                        connection.sender.send(Message::Response(resp))?;\n+                        continue;\n+                    }\n+                    Err(err @ ExtractError::JsonError { .. }) => panic!(\"{:?}\", err),\n+                    Err(ExtractError::MethodMismatch(req)) => req,\n+                };\n+                // ...\n+            }\n+            Message::Response(resp) => {\n+                eprintln!(\"got response: {:?}\", resp);\n+            }\n+            Message::Notification(not) => {\n+                eprintln!(\"got notification: {:?}\", not);\n+            }\n+        }\n+    }\n+    Ok(())\n+}\n+\n+fn cast<R>(req: Request) -> Result<(RequestId, R::Params), ExtractError<Request>>\n+where\n+    R: lsp_types::request::Request,\n+    R::Params: serde::de::DeserializeOwned,\n+{\n+    req.extract(R::METHOD)\n+}"}, {"sha": "4c934d9ecca5d9c9edc0067a5c60ba8d3289e27a", "filename": "lib/lsp-server/src/error.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2Fsrc%2Ferror.rs?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -0,0 +1,50 @@\n+use std::fmt;\n+\n+use crate::{Notification, Request};\n+\n+#[derive(Debug, Clone)]\n+pub struct ProtocolError(pub(crate) String);\n+\n+impl std::error::Error for ProtocolError {}\n+\n+impl fmt::Display for ProtocolError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum ExtractError<T> {\n+    /// The extracted message was of a different method than expected.\n+    MethodMismatch(T),\n+    /// Failed to deserialize the message.\n+    JsonError { method: String, error: serde_json::Error },\n+}\n+\n+impl std::error::Error for ExtractError<Request> {}\n+impl fmt::Display for ExtractError<Request> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            ExtractError::MethodMismatch(req) => {\n+                write!(f, \"Method mismatch for request '{}'\", req.method)\n+            }\n+            ExtractError::JsonError { method, error } => {\n+                write!(f, \"Invalid request\\nMethod: {method}\\n error: {error}\",)\n+            }\n+        }\n+    }\n+}\n+\n+impl std::error::Error for ExtractError<Notification> {}\n+impl fmt::Display for ExtractError<Notification> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            ExtractError::MethodMismatch(req) => {\n+                write!(f, \"Method mismatch for notification '{}'\", req.method)\n+            }\n+            ExtractError::JsonError { method, error } => {\n+                write!(f, \"Invalid notification\\nMethod: {method}\\n error: {error}\")\n+            }\n+        }\n+    }\n+}"}, {"sha": "1aaf327da0ff29efda3957c5edce1fad90513f13", "filename": "lib/lsp-server/src/lib.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2Fsrc%2Flib.rs?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -0,0 +1,229 @@\n+//! A language server scaffold, exposing a synchronous crossbeam-channel based API.\n+//! This crate handles protocol handshaking and parsing messages, while you\n+//! control the message dispatch loop yourself.\n+//!\n+//! Run with `RUST_LOG=lsp_server=debug` to see all the messages.\n+mod msg;\n+mod stdio;\n+mod error;\n+mod socket;\n+mod req_queue;\n+\n+use std::{\n+    io,\n+    net::{TcpListener, TcpStream, ToSocketAddrs},\n+};\n+\n+use crossbeam_channel::{Receiver, Sender};\n+\n+pub use crate::{\n+    error::{ExtractError, ProtocolError},\n+    msg::{ErrorCode, Message, Notification, Request, RequestId, Response, ResponseError},\n+    req_queue::{Incoming, Outgoing, ReqQueue},\n+    stdio::IoThreads,\n+};\n+\n+/// Connection is just a pair of channels of LSP messages.\n+pub struct Connection {\n+    pub sender: Sender<Message>,\n+    pub receiver: Receiver<Message>,\n+}\n+\n+impl Connection {\n+    /// Create connection over standard in/standard out.\n+    ///\n+    /// Use this to create a real language server.\n+    pub fn stdio() -> (Connection, IoThreads) {\n+        let (sender, receiver, io_threads) = stdio::stdio_transport();\n+        (Connection { sender, receiver }, io_threads)\n+    }\n+\n+    /// Open a connection over tcp.\n+    /// This call blocks until a connection is established.\n+    ///\n+    /// Use this to create a real language server.\n+    pub fn connect<A: ToSocketAddrs>(addr: A) -> io::Result<(Connection, IoThreads)> {\n+        let stream = TcpStream::connect(addr)?;\n+        let (sender, receiver, io_threads) = socket::socket_transport(stream);\n+        Ok((Connection { sender, receiver }, io_threads))\n+    }\n+\n+    /// Listen for a connection over tcp.\n+    /// This call blocks until a connection is established.\n+    ///\n+    /// Use this to create a real language server.\n+    pub fn listen<A: ToSocketAddrs>(addr: A) -> io::Result<(Connection, IoThreads)> {\n+        let listener = TcpListener::bind(addr)?;\n+        let (stream, _) = listener.accept()?;\n+        let (sender, receiver, io_threads) = socket::socket_transport(stream);\n+        Ok((Connection { sender, receiver }, io_threads))\n+    }\n+\n+    /// Creates a pair of connected connections.\n+    ///\n+    /// Use this for testing.\n+    pub fn memory() -> (Connection, Connection) {\n+        let (s1, r1) = crossbeam_channel::unbounded();\n+        let (s2, r2) = crossbeam_channel::unbounded();\n+        (Connection { sender: s1, receiver: r2 }, Connection { sender: s2, receiver: r1 })\n+    }\n+\n+    /// Starts the initialization process by waiting for an initialize\n+    /// request from the client. Use this for more advanced customization than\n+    /// `initialize` can provide.\n+    ///\n+    /// Returns the request id and serialized `InitializeParams` from the client.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// use std::error::Error;\n+    /// use lsp_types::{ClientCapabilities, InitializeParams, ServerCapabilities};\n+    ///\n+    /// use lsp_server::{Connection, Message, Request, RequestId, Response};\n+    ///\n+    /// fn main() -> Result<(), Box<dyn Error + Sync + Send>> {\n+    ///    // Create the transport. Includes the stdio (stdin and stdout) versions but this could\n+    ///    // also be implemented to use sockets or HTTP.\n+    ///    let (connection, io_threads) = Connection::stdio();\n+    ///\n+    ///    // Run the server\n+    ///    let (id, params) = connection.initialize_start()?;\n+    ///\n+    ///    let init_params: InitializeParams = serde_json::from_value(params).unwrap();\n+    ///    let client_capabilities: ClientCapabilities = init_params.capabilities;\n+    ///    let server_capabilities = ServerCapabilities::default();\n+    ///\n+    ///    let initialize_data = serde_json::json!({\n+    ///        \"capabilities\": server_capabilities,\n+    ///        \"serverInfo\": {\n+    ///            \"name\": \"lsp-server-test\",\n+    ///            \"version\": \"0.1\"\n+    ///        }\n+    ///    });\n+    ///\n+    ///    connection.initialize_finish(id, initialize_data)?;\n+    ///\n+    ///    // ... Run main loop ...\n+    ///\n+    ///    Ok(())\n+    /// }\n+    /// ```\n+    pub fn initialize_start(&self) -> Result<(RequestId, serde_json::Value), ProtocolError> {\n+        loop {\n+            match self.receiver.recv() {\n+                Ok(Message::Request(req)) if req.is_initialize() => {\n+                    return Ok((req.id, req.params))\n+                }\n+                // Respond to non-initialize requests with ServerNotInitialized\n+                Ok(Message::Request(req)) => {\n+                    let resp = Response::new_err(\n+                        req.id.clone(),\n+                        ErrorCode::ServerNotInitialized as i32,\n+                        format!(\"expected initialize request, got {:?}\", req),\n+                    );\n+                    self.sender.send(resp.into()).unwrap();\n+                }\n+                Ok(msg) => {\n+                    return Err(ProtocolError(format!(\n+                        \"expected initialize request, got {:?}\",\n+                        msg\n+                    )))\n+                }\n+                Err(e) => {\n+                    return Err(ProtocolError(format!(\n+                        \"expected initialize request, got error: {}\",\n+                        e\n+                    )))\n+                }\n+            };\n+        }\n+    }\n+\n+    /// Finishes the initialization process by sending an `InitializeResult` to the client\n+    pub fn initialize_finish(\n+        &self,\n+        initialize_id: RequestId,\n+        initialize_result: serde_json::Value,\n+    ) -> Result<(), ProtocolError> {\n+        let resp = Response::new_ok(initialize_id, initialize_result);\n+        self.sender.send(resp.into()).unwrap();\n+        match &self.receiver.recv() {\n+            Ok(Message::Notification(n)) if n.is_initialized() => (),\n+            Ok(msg) => {\n+                return Err(ProtocolError(format!(\n+                    \"expected Message::Notification, got: {:?}\",\n+                    msg,\n+                )))\n+            }\n+            Err(e) => {\n+                return Err(ProtocolError(format!(\n+                    \"expected initialized notification, got error: {}\",\n+                    e,\n+                )))\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Initialize the connection. Sends the server capabilities\n+    /// to the client and returns the serialized client capabilities\n+    /// on success. If more fine-grained initialization is required use\n+    /// `initialize_start`/`initialize_finish`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// use std::error::Error;\n+    /// use lsp_types::ServerCapabilities;\n+    ///\n+    /// use lsp_server::{Connection, Message, Request, RequestId, Response};\n+    ///\n+    /// fn main() -> Result<(), Box<dyn Error + Sync + Send>> {\n+    ///    // Create the transport. Includes the stdio (stdin and stdout) versions but this could\n+    ///    // also be implemented to use sockets or HTTP.\n+    ///    let (connection, io_threads) = Connection::stdio();\n+    ///\n+    ///    // Run the server\n+    ///    let server_capabilities = serde_json::to_value(&ServerCapabilities::default()).unwrap();\n+    ///    let initialization_params = connection.initialize(server_capabilities)?;\n+    ///\n+    ///    // ... Run main loop ...\n+    ///\n+    ///    Ok(())\n+    /// }\n+    /// ```\n+    pub fn initialize(\n+        &self,\n+        server_capabilities: serde_json::Value,\n+    ) -> Result<serde_json::Value, ProtocolError> {\n+        let (id, params) = self.initialize_start()?;\n+\n+        let initialize_data = serde_json::json!({\n+            \"capabilities\": server_capabilities,\n+        });\n+\n+        self.initialize_finish(id, initialize_data)?;\n+\n+        Ok(params)\n+    }\n+\n+    /// If `req` is `Shutdown`, respond to it and return `true`, otherwise return `false`\n+    pub fn handle_shutdown(&self, req: &Request) -> Result<bool, ProtocolError> {\n+        if !req.is_shutdown() {\n+            return Ok(false);\n+        }\n+        let resp = Response::new_ok(req.id.clone(), ());\n+        let _ = self.sender.send(resp.into());\n+        match &self.receiver.recv_timeout(std::time::Duration::from_secs(30)) {\n+            Ok(Message::Notification(n)) if n.is_exit() => (),\n+            Ok(msg) => {\n+                return Err(ProtocolError(format!(\"unexpected message during shutdown: {:?}\", msg)))\n+            }\n+            Err(e) => {\n+                return Err(ProtocolError(format!(\"unexpected error during shutdown: {}\", e)))\n+            }\n+        }\n+        Ok(true)\n+    }\n+}"}, {"sha": "97e5bd35ce0eea8848c68aebba2979a9dfa7a267", "filename": "lib/lsp-server/src/msg.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2Fsrc%2Fmsg.rs?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -0,0 +1,343 @@\n+use std::{\n+    fmt,\n+    io::{self, BufRead, Write},\n+};\n+\n+use serde::{de::DeserializeOwned, Deserialize, Serialize};\n+\n+use crate::error::ExtractError;\n+\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+#[serde(untagged)]\n+pub enum Message {\n+    Request(Request),\n+    Response(Response),\n+    Notification(Notification),\n+}\n+\n+impl From<Request> for Message {\n+    fn from(request: Request) -> Message {\n+        Message::Request(request)\n+    }\n+}\n+\n+impl From<Response> for Message {\n+    fn from(response: Response) -> Message {\n+        Message::Response(response)\n+    }\n+}\n+\n+impl From<Notification> for Message {\n+    fn from(notification: Notification) -> Message {\n+        Message::Notification(notification)\n+    }\n+}\n+\n+#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[serde(transparent)]\n+pub struct RequestId(IdRepr);\n+\n+#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[serde(untagged)]\n+enum IdRepr {\n+    I32(i32),\n+    String(String),\n+}\n+\n+impl From<i32> for RequestId {\n+    fn from(id: i32) -> RequestId {\n+        RequestId(IdRepr::I32(id))\n+    }\n+}\n+\n+impl From<String> for RequestId {\n+    fn from(id: String) -> RequestId {\n+        RequestId(IdRepr::String(id))\n+    }\n+}\n+\n+impl fmt::Display for RequestId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match &self.0 {\n+            IdRepr::I32(it) => fmt::Display::fmt(it, f),\n+            // Use debug here, to make it clear that `92` and `\"92\"` are\n+            // different, and to reduce WTF factor if the sever uses `\" \"` as an\n+            // ID.\n+            IdRepr::String(it) => fmt::Debug::fmt(it, f),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Serialize, Deserialize, Clone)]\n+pub struct Request {\n+    pub id: RequestId,\n+    pub method: String,\n+    #[serde(default = \"serde_json::Value::default\")]\n+    #[serde(skip_serializing_if = \"serde_json::Value::is_null\")]\n+    pub params: serde_json::Value,\n+}\n+\n+#[derive(Debug, Serialize, Deserialize, Clone)]\n+pub struct Response {\n+    // JSON RPC allows this to be null if it was impossible\n+    // to decode the request's id. Ignore this special case\n+    // and just die horribly.\n+    pub id: RequestId,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub result: Option<serde_json::Value>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub error: Option<ResponseError>,\n+}\n+\n+#[derive(Debug, Serialize, Deserialize, Clone)]\n+pub struct ResponseError {\n+    pub code: i32,\n+    pub message: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub data: Option<serde_json::Value>,\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+#[allow(unused)]\n+pub enum ErrorCode {\n+    // Defined by JSON RPC:\n+    ParseError = -32700,\n+    InvalidRequest = -32600,\n+    MethodNotFound = -32601,\n+    InvalidParams = -32602,\n+    InternalError = -32603,\n+    ServerErrorStart = -32099,\n+    ServerErrorEnd = -32000,\n+\n+    /// Error code indicating that a server received a notification or\n+    /// request before the server has received the `initialize` request.\n+    ServerNotInitialized = -32002,\n+    UnknownErrorCode = -32001,\n+\n+    // Defined by the protocol:\n+    /// The client has canceled a request and a server has detected\n+    /// the cancel.\n+    RequestCanceled = -32800,\n+\n+    /// The server detected that the content of a document got\n+    /// modified outside normal conditions. A server should\n+    /// NOT send this error code if it detects a content change\n+    /// in it unprocessed messages. The result even computed\n+    /// on an older state might still be useful for the client.\n+    ///\n+    /// If a client decides that a result is not of any use anymore\n+    /// the client should cancel the request.\n+    ContentModified = -32801,\n+\n+    /// The server cancelled the request. This error code should\n+    /// only be used for requests that explicitly support being\n+    /// server cancellable.\n+    ///\n+    /// @since 3.17.0\n+    ServerCancelled = -32802,\n+}\n+\n+#[derive(Debug, Serialize, Deserialize, Clone)]\n+pub struct Notification {\n+    pub method: String,\n+    #[serde(default = \"serde_json::Value::default\")]\n+    #[serde(skip_serializing_if = \"serde_json::Value::is_null\")]\n+    pub params: serde_json::Value,\n+}\n+\n+impl Message {\n+    pub fn read(r: &mut impl BufRead) -> io::Result<Option<Message>> {\n+        Message::_read(r)\n+    }\n+    fn _read(r: &mut dyn BufRead) -> io::Result<Option<Message>> {\n+        let text = match read_msg_text(r)? {\n+            None => return Ok(None),\n+            Some(text) => text,\n+        };\n+        let msg = serde_json::from_str(&text)?;\n+        Ok(Some(msg))\n+    }\n+    pub fn write(self, w: &mut impl Write) -> io::Result<()> {\n+        self._write(w)\n+    }\n+    fn _write(self, w: &mut dyn Write) -> io::Result<()> {\n+        #[derive(Serialize)]\n+        struct JsonRpc {\n+            jsonrpc: &'static str,\n+            #[serde(flatten)]\n+            msg: Message,\n+        }\n+        let text = serde_json::to_string(&JsonRpc { jsonrpc: \"2.0\", msg: self })?;\n+        write_msg_text(w, &text)\n+    }\n+}\n+\n+impl Response {\n+    pub fn new_ok<R: Serialize>(id: RequestId, result: R) -> Response {\n+        Response { id, result: Some(serde_json::to_value(result).unwrap()), error: None }\n+    }\n+    pub fn new_err(id: RequestId, code: i32, message: String) -> Response {\n+        let error = ResponseError { code, message, data: None };\n+        Response { id, result: None, error: Some(error) }\n+    }\n+}\n+\n+impl Request {\n+    pub fn new<P: Serialize>(id: RequestId, method: String, params: P) -> Request {\n+        Request { id, method, params: serde_json::to_value(params).unwrap() }\n+    }\n+    pub fn extract<P: DeserializeOwned>(\n+        self,\n+        method: &str,\n+    ) -> Result<(RequestId, P), ExtractError<Request>> {\n+        if self.method != method {\n+            return Err(ExtractError::MethodMismatch(self));\n+        }\n+        match serde_json::from_value(self.params) {\n+            Ok(params) => Ok((self.id, params)),\n+            Err(error) => Err(ExtractError::JsonError { method: self.method, error }),\n+        }\n+    }\n+\n+    pub(crate) fn is_shutdown(&self) -> bool {\n+        self.method == \"shutdown\"\n+    }\n+    pub(crate) fn is_initialize(&self) -> bool {\n+        self.method == \"initialize\"\n+    }\n+}\n+\n+impl Notification {\n+    pub fn new(method: String, params: impl Serialize) -> Notification {\n+        Notification { method, params: serde_json::to_value(params).unwrap() }\n+    }\n+    pub fn extract<P: DeserializeOwned>(\n+        self,\n+        method: &str,\n+    ) -> Result<P, ExtractError<Notification>> {\n+        if self.method != method {\n+            return Err(ExtractError::MethodMismatch(self));\n+        }\n+        match serde_json::from_value(self.params) {\n+            Ok(params) => Ok(params),\n+            Err(error) => Err(ExtractError::JsonError { method: self.method, error }),\n+        }\n+    }\n+    pub(crate) fn is_exit(&self) -> bool {\n+        self.method == \"exit\"\n+    }\n+    pub(crate) fn is_initialized(&self) -> bool {\n+        self.method == \"initialized\"\n+    }\n+}\n+\n+fn read_msg_text(inp: &mut dyn BufRead) -> io::Result<Option<String>> {\n+    fn invalid_data(error: impl Into<Box<dyn std::error::Error + Send + Sync>>) -> io::Error {\n+        io::Error::new(io::ErrorKind::InvalidData, error)\n+    }\n+    macro_rules! invalid_data {\n+        ($($tt:tt)*) => (invalid_data(format!($($tt)*)))\n+    }\n+\n+    let mut size = None;\n+    let mut buf = String::new();\n+    loop {\n+        buf.clear();\n+        if inp.read_line(&mut buf)? == 0 {\n+            return Ok(None);\n+        }\n+        if !buf.ends_with(\"\\r\\n\") {\n+            return Err(invalid_data!(\"malformed header: {:?}\", buf));\n+        }\n+        let buf = &buf[..buf.len() - 2];\n+        if buf.is_empty() {\n+            break;\n+        }\n+        let mut parts = buf.splitn(2, \": \");\n+        let header_name = parts.next().unwrap();\n+        let header_value =\n+            parts.next().ok_or_else(|| invalid_data!(\"malformed header: {:?}\", buf))?;\n+        if header_name == \"Content-Length\" {\n+            size = Some(header_value.parse::<usize>().map_err(invalid_data)?);\n+        }\n+    }\n+    let size: usize = size.ok_or_else(|| invalid_data!(\"no Content-Length\"))?;\n+    let mut buf = buf.into_bytes();\n+    buf.resize(size, 0);\n+    inp.read_exact(&mut buf)?;\n+    let buf = String::from_utf8(buf).map_err(invalid_data)?;\n+    log::debug!(\"< {}\", buf);\n+    Ok(Some(buf))\n+}\n+\n+fn write_msg_text(out: &mut dyn Write, msg: &str) -> io::Result<()> {\n+    log::debug!(\"> {}\", msg);\n+    write!(out, \"Content-Length: {}\\r\\n\\r\\n\", msg.len())?;\n+    out.write_all(msg.as_bytes())?;\n+    out.flush()?;\n+    Ok(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{Message, Notification, Request, RequestId};\n+\n+    #[test]\n+    fn shutdown_with_explicit_null() {\n+        let text = \"{\\\"jsonrpc\\\": \\\"2.0\\\",\\\"id\\\": 3,\\\"method\\\": \\\"shutdown\\\", \\\"params\\\": null }\";\n+        let msg: Message = serde_json::from_str(text).unwrap();\n+\n+        assert!(\n+            matches!(msg, Message::Request(req) if req.id == 3.into() && req.method == \"shutdown\")\n+        );\n+    }\n+\n+    #[test]\n+    fn shutdown_with_no_params() {\n+        let text = \"{\\\"jsonrpc\\\": \\\"2.0\\\",\\\"id\\\": 3,\\\"method\\\": \\\"shutdown\\\"}\";\n+        let msg: Message = serde_json::from_str(text).unwrap();\n+\n+        assert!(\n+            matches!(msg, Message::Request(req) if req.id == 3.into() && req.method == \"shutdown\")\n+        );\n+    }\n+\n+    #[test]\n+    fn notification_with_explicit_null() {\n+        let text = \"{\\\"jsonrpc\\\": \\\"2.0\\\",\\\"method\\\": \\\"exit\\\", \\\"params\\\": null }\";\n+        let msg: Message = serde_json::from_str(text).unwrap();\n+\n+        assert!(matches!(msg, Message::Notification(not) if not.method == \"exit\"));\n+    }\n+\n+    #[test]\n+    fn notification_with_no_params() {\n+        let text = \"{\\\"jsonrpc\\\": \\\"2.0\\\",\\\"method\\\": \\\"exit\\\"}\";\n+        let msg: Message = serde_json::from_str(text).unwrap();\n+\n+        assert!(matches!(msg, Message::Notification(not) if not.method == \"exit\"));\n+    }\n+\n+    #[test]\n+    fn serialize_request_with_null_params() {\n+        let msg = Message::Request(Request {\n+            id: RequestId::from(3),\n+            method: \"shutdown\".into(),\n+            params: serde_json::Value::Null,\n+        });\n+        let serialized = serde_json::to_string(&msg).unwrap();\n+\n+        assert_eq!(\"{\\\"id\\\":3,\\\"method\\\":\\\"shutdown\\\"}\", serialized);\n+    }\n+\n+    #[test]\n+    fn serialize_notification_with_null_params() {\n+        let msg = Message::Notification(Notification {\n+            method: \"exit\".into(),\n+            params: serde_json::Value::Null,\n+        });\n+        let serialized = serde_json::to_string(&msg).unwrap();\n+\n+        assert_eq!(\"{\\\"method\\\":\\\"exit\\\"}\", serialized);\n+    }\n+}"}, {"sha": "1f3d447153bd07b9a6edfb34c8d7bca3d944f362", "filename": "lib/lsp-server/src/req_queue.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fsrc%2Freq_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fsrc%2Freq_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2Fsrc%2Freq_queue.rs?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -0,0 +1,62 @@\n+use std::collections::HashMap;\n+\n+use serde::Serialize;\n+\n+use crate::{ErrorCode, Request, RequestId, Response, ResponseError};\n+\n+/// Manages the set of pending requests, both incoming and outgoing.\n+#[derive(Debug)]\n+pub struct ReqQueue<I, O> {\n+    pub incoming: Incoming<I>,\n+    pub outgoing: Outgoing<O>,\n+}\n+\n+impl<I, O> Default for ReqQueue<I, O> {\n+    fn default() -> ReqQueue<I, O> {\n+        ReqQueue {\n+            incoming: Incoming { pending: HashMap::default() },\n+            outgoing: Outgoing { next_id: 0, pending: HashMap::default() },\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Incoming<I> {\n+    pending: HashMap<RequestId, I>,\n+}\n+\n+#[derive(Debug)]\n+pub struct Outgoing<O> {\n+    next_id: i32,\n+    pending: HashMap<RequestId, O>,\n+}\n+\n+impl<I> Incoming<I> {\n+    pub fn register(&mut self, id: RequestId, data: I) {\n+        self.pending.insert(id, data);\n+    }\n+    pub fn cancel(&mut self, id: RequestId) -> Option<Response> {\n+        let _data = self.complete(id.clone())?;\n+        let error = ResponseError {\n+            code: ErrorCode::RequestCanceled as i32,\n+            message: \"canceled by client\".to_string(),\n+            data: None,\n+        };\n+        Some(Response { id, result: None, error: Some(error) })\n+    }\n+    pub fn complete(&mut self, id: RequestId) -> Option<I> {\n+        self.pending.remove(&id)\n+    }\n+}\n+\n+impl<O> Outgoing<O> {\n+    pub fn register<P: Serialize>(&mut self, method: String, params: P, data: O) -> Request {\n+        let id = RequestId::from(self.next_id);\n+        self.pending.insert(id.clone(), data);\n+        self.next_id += 1;\n+        Request::new(id, method, params)\n+    }\n+    pub fn complete(&mut self, id: RequestId) -> Option<O> {\n+        self.pending.remove(&id)\n+    }\n+}"}, {"sha": "4a59c4c0fad050a65372a56b2c2281cdd4ca0423", "filename": "lib/lsp-server/src/socket.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fsrc%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fsrc%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2Fsrc%2Fsocket.rs?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -0,0 +1,46 @@\n+use std::{\n+    io::{self, BufReader},\n+    net::TcpStream,\n+    thread,\n+};\n+\n+use crossbeam_channel::{bounded, Receiver, Sender};\n+\n+use crate::{\n+    stdio::{make_io_threads, IoThreads},\n+    Message,\n+};\n+\n+pub(crate) fn socket_transport(\n+    stream: TcpStream,\n+) -> (Sender<Message>, Receiver<Message>, IoThreads) {\n+    let (reader_receiver, reader) = make_reader(stream.try_clone().unwrap());\n+    let (writer_sender, writer) = make_write(stream.try_clone().unwrap());\n+    let io_threads = make_io_threads(reader, writer);\n+    (writer_sender, reader_receiver, io_threads)\n+}\n+\n+fn make_reader(stream: TcpStream) -> (Receiver<Message>, thread::JoinHandle<io::Result<()>>) {\n+    let (reader_sender, reader_receiver) = bounded::<Message>(0);\n+    let reader = thread::spawn(move || {\n+        let mut buf_read = BufReader::new(stream);\n+        while let Some(msg) = Message::read(&mut buf_read).unwrap() {\n+            let is_exit = matches!(&msg, Message::Notification(n) if n.is_exit());\n+            reader_sender.send(msg).unwrap();\n+            if is_exit {\n+                break;\n+            }\n+        }\n+        Ok(())\n+    });\n+    (reader_receiver, reader)\n+}\n+\n+fn make_write(mut stream: TcpStream) -> (Sender<Message>, thread::JoinHandle<io::Result<()>>) {\n+    let (writer_sender, writer_receiver) = bounded::<Message>(0);\n+    let writer = thread::spawn(move || {\n+        writer_receiver.into_iter().try_for_each(|it| it.write(&mut stream)).unwrap();\n+        Ok(())\n+    });\n+    (writer_sender, writer)\n+}"}, {"sha": "cdee6432df8478053503d2aad4d1d20e3d8256ee", "filename": "lib/lsp-server/src/stdio.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fsrc%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff5b2cab48716e263f3e9c39cf1efa9bb907795/lib%2Flsp-server%2Fsrc%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2Fsrc%2Fstdio.rs?ref=1ff5b2cab48716e263f3e9c39cf1efa9bb907795", "patch": "@@ -0,0 +1,71 @@\n+use std::{\n+    io::{self, stdin, stdout},\n+    thread,\n+};\n+\n+use crossbeam_channel::{bounded, Receiver, Sender};\n+\n+use crate::Message;\n+\n+/// Creates an LSP connection via stdio.\n+pub(crate) fn stdio_transport() -> (Sender<Message>, Receiver<Message>, IoThreads) {\n+    let (writer_sender, writer_receiver) = bounded::<Message>(0);\n+    let writer = thread::spawn(move || {\n+        let stdout = stdout();\n+        let mut stdout = stdout.lock();\n+        writer_receiver.into_iter().try_for_each(|it| it.write(&mut stdout))?;\n+        Ok(())\n+    });\n+    let (reader_sender, reader_receiver) = bounded::<Message>(0);\n+    let reader = thread::spawn(move || {\n+        let stdin = stdin();\n+        let mut stdin = stdin.lock();\n+        while let Some(msg) = Message::read(&mut stdin)? {\n+            let is_exit = match &msg {\n+                Message::Notification(n) => n.is_exit(),\n+                _ => false,\n+            };\n+\n+            reader_sender.send(msg).unwrap();\n+\n+            if is_exit {\n+                break;\n+            }\n+        }\n+        Ok(())\n+    });\n+    let threads = IoThreads { reader, writer };\n+    (writer_sender, reader_receiver, threads)\n+}\n+\n+// Creates an IoThreads\n+pub(crate) fn make_io_threads(\n+    reader: thread::JoinHandle<io::Result<()>>,\n+    writer: thread::JoinHandle<io::Result<()>>,\n+) -> IoThreads {\n+    IoThreads { reader, writer }\n+}\n+\n+pub struct IoThreads {\n+    reader: thread::JoinHandle<io::Result<()>>,\n+    writer: thread::JoinHandle<io::Result<()>>,\n+}\n+\n+impl IoThreads {\n+    pub fn join(self) -> io::Result<()> {\n+        match self.reader.join() {\n+            Ok(r) => r?,\n+            Err(err) => {\n+                println!(\"reader panicked!\");\n+                std::panic::panic_any(err)\n+            }\n+        }\n+        match self.writer.join() {\n+            Ok(r) => r,\n+            Err(err) => {\n+                println!(\"writer panicked!\");\n+                std::panic::panic_any(err);\n+            }\n+        }\n+    }\n+}"}]}