{"sha": "6d96c8979d37dd137d29a992fc9b962ebe089aaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkOTZjODk3OWQzN2RkMTM3ZDI5YTk5MmZjOWI5NjJlYmUwODlhYWY=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-02-17T10:01:46Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-04-01T19:24:46Z"}, "message": "SGX target: convert a bunch of panics to aborts", "tree": {"sha": "0972344239ea49d311c352d4ef775c1d0be05059", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0972344239ea49d311c352d4ef775c1d0be05059"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d96c8979d37dd137d29a992fc9b962ebe089aaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d96c8979d37dd137d29a992fc9b962ebe089aaf", "html_url": "https://github.com/rust-lang/rust/commit/6d96c8979d37dd137d29a992fc9b962ebe089aaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d96c8979d37dd137d29a992fc9b962ebe089aaf/comments", "author": null, "committer": null, "parents": [{"sha": "eab3eb38df8dca99110b6149b3a15deeb4ef0413", "url": "https://api.github.com/repos/rust-lang/rust/commits/eab3eb38df8dca99110b6149b3a15deeb4ef0413", "html_url": "https://github.com/rust-lang/rust/commit/eab3eb38df8dca99110b6149b3a15deeb4ef0413"}], "stats": {"total": 109, "additions": 61, "deletions": 48}, "files": [{"sha": "1f433e25ee16ccf4669f84d6ae2b44e93ecc27be", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=6d96c8979d37dd137d29a992fc9b962ebe089aaf", "patch": "@@ -69,9 +69,9 @@ extern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64\n         }\n \n         // check entry is being called according to ABI\n-        assert_eq!(p3, 0);\n-        assert_eq!(p4, 0);\n-        assert_eq!(p5, 0);\n+        rtassert!(p3 == 0);\n+        rtassert!(p4 == 0);\n+        rtassert!(p5 == 0);\n \n         unsafe {\n             // The actual types of these arguments are `p1: *const Arg, p2:"}, {"sha": "6dd24c524fc3067506817de8c9ada99fc33270b1", "filename": "src/libstd/sys/sgx/abi/reloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs?ref=6d96c8979d37dd137d29a992fc9b962ebe089aaf", "patch": "@@ -23,7 +23,7 @@ pub fn relocate_elf_rela() {\n     };\n     for rela in relas {\n         if rela.info != (/*0 << 32 |*/ R_X86_64_RELATIVE as u64) {\n-            panic!(\"Invalid relocation\");\n+            rtabort!(\"Invalid relocation\");\n         }\n         unsafe { *mem::rel_ptr_mut::<*const ()>(rela.offset) = mem::rel_ptr(rela.addend) };\n     }"}, {"sha": "03e08ad547d3655a40db005b94e8aa3e083db547", "filename": "src/libstd/sys/sgx/abi/tls.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs?ref=6d96c8979d37dd137d29a992fc9b962ebe089aaf", "patch": "@@ -100,20 +100,24 @@ impl Tls {\n     }\n \n     pub fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-        let index = TLS_KEY_IN_USE.set().expect(\"TLS limit exceeded\");\n+        let index = if let Some(index) = TLS_KEY_IN_USE.set() {\n+            index\n+        } else {\n+            rtabort!(\"TLS limit exceeded\")\n+        };\n         TLS_DESTRUCTOR[index].store(dtor.map_or(0, |f| f as usize), Ordering::Relaxed);\n         Key::from_index(index)\n     }\n \n     pub fn set(key: Key, value: *mut u8) {\n         let index = key.to_index();\n-        assert!(TLS_KEY_IN_USE.get(index));\n+        rtassert!(TLS_KEY_IN_USE.get(index));\n         unsafe { Self::current() }.data[index].set(value);\n     }\n \n     pub fn get(key: Key) -> *mut u8 {\n         let index = key.to_index();\n-        assert!(TLS_KEY_IN_USE.get(index));\n+        rtassert!(TLS_KEY_IN_USE.get(index));\n         unsafe { Self::current() }.data[index].get()\n     }\n "}, {"sha": "22ae2a8e07d313a3745c903a0513e94404684219", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=6d96c8979d37dd137d29a992fc9b962ebe089aaf", "patch": "@@ -190,11 +190,15 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n         unsafe {\n             // Mustn't call alloc with size 0.\n             let ptr = if size > 0 {\n-                super::alloc(size, T::align_of()).expect(\"User memory allocation failed\") as _\n+                rtunwrap!(Ok, super::alloc(size, T::align_of())) as _\n             } else {\n                 T::align_of() as _ // dangling pointer ok for size 0\n             };\n-            User(NonNull::new_userref(T::from_raw_sized(ptr, size)))\n+            if let Ok(v) = crate::panic::catch_unwind(|| T::from_raw_sized(ptr, size)) {\n+                User(NonNull::new_userref(v))\n+            } else {\n+                rtabort!(\"Got invalid pointer from alloc() usercall\")\n+            }\n         }\n     }\n "}, {"sha": "0abfc26bced0025d4188ef341c8302d773295e9e", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=6d96c8979d37dd137d29a992fc9b962ebe089aaf", "patch": "@@ -52,7 +52,7 @@ pub fn close(fd: Fd) {\n \n fn string_from_bytebuffer(buf: &alloc::UserRef<ByteBuffer>, usercall: &str, arg: &str) -> String {\n     String::from_utf8(buf.copy_user_buffer())\n-        .unwrap_or_else(|_| panic!(\"Usercall {}: expected {} to be valid UTF-8\", usercall, arg))\n+        .unwrap_or_else(|_| rtabort!(\"Usercall {}: expected {} to be valid UTF-8\", usercall, arg))\n }\n \n /// Usercall `bind_stream`. See the ABI documentation for more information.\n@@ -176,7 +176,7 @@ fn check_os_error(err: Result) -> i32 {\n     {\n         err\n     } else {\n-        panic!(\"Usercall: returned invalid error value {}\", err)\n+        rtabort!(\"Usercall: returned invalid error value {}\", err)\n     }\n }\n "}, {"sha": "e4694a8827a0d8b20e1307eba1ec4947f149cce4", "filename": "src/libstd/sys/sgx/abi/usercalls/raw.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs?ref=6d96c8979d37dd137d29a992fc9b962ebe089aaf", "patch": "@@ -131,22 +131,22 @@ impl<T: RegisterArgument> RegisterArgument for Option<NonNull<T>> {\n \n impl ReturnValue for ! {\n     fn from_registers(call: &'static str, _regs: (Register, Register)) -> Self {\n-        panic!(\"Usercall {}: did not expect to be re-entered\", call);\n+        rtabort!(\"Usercall {}: did not expect to be re-entered\", call);\n     }\n }\n \n impl ReturnValue for () {\n-    fn from_registers(call: &'static str, regs: (Register, Register)) -> Self {\n-        assert_eq!(regs.0, 0, \"Usercall {}: expected {} return value to be 0\", call, \"1st\");\n-        assert_eq!(regs.1, 0, \"Usercall {}: expected {} return value to be 0\", call, \"2nd\");\n+    fn from_registers(call: &'static str, usercall_retval: (Register, Register)) -> Self {\n+        rtassert!(usercall_retval.0 == 0);\n+        rtassert!(usercall_retval.1 == 0);\n         ()\n     }\n }\n \n impl<T: RegisterArgument> ReturnValue for T {\n-    fn from_registers(call: &'static str, regs: (Register, Register)) -> Self {\n-        assert_eq!(regs.1, 0, \"Usercall {}: expected {} return value to be 0\", call, \"2nd\");\n-        T::from_register(regs.0)\n+    fn from_registers(call: &'static str, usercall_retval: (Register, Register)) -> Self {\n+        rtassert!(usercall_retval.1 == 0);\n+        T::from_register(usercall_retval.0)\n     }\n }\n \n@@ -174,8 +174,7 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3, $n4: $t4) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                NonZeroU64::new(Usercalls::$f as Register)\n-                    .expect(\"Usercall number must be non-zero\"),\n+                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                 RegisterArgument::into_register($n1),\n                 RegisterArgument::into_register($n2),\n                 RegisterArgument::into_register($n3),\n@@ -191,8 +190,7 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                NonZeroU64::new(Usercalls::$f as Register)\n-                    .expect(\"Usercall number must be non-zero\"),\n+                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                 RegisterArgument::into_register($n1),\n                 RegisterArgument::into_register($n2),\n                 RegisterArgument::into_register($n3),\n@@ -208,8 +206,7 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                NonZeroU64::new(Usercalls::$f as Register)\n-                    .expect(\"Usercall number must be non-zero\"),\n+                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                 RegisterArgument::into_register($n1),\n                 RegisterArgument::into_register($n2),\n                 0,0,\n@@ -224,8 +221,7 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                NonZeroU64::new(Usercalls::$f as Register)\n-                    .expect(\"Usercall number must be non-zero\"),\n+                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                 RegisterArgument::into_register($n1),\n                 0,0,0,\n                 return_type_is_abort!($r)\n@@ -239,8 +235,7 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[inline(always)]\n         pub unsafe fn $f() -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                NonZeroU64::new(Usercalls::$f as Register)\n-                    .expect(\"Usercall number must be non-zero\"),\n+                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                 0,0,0,0,\n                 return_type_is_abort!($r)\n             ))"}, {"sha": "000bb19f2692ae8807551a5f7ba94271f41db1b8", "filename": "src/libstd/sys/sgx/condvar.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs?ref=6d96c8979d37dd137d29a992fc9b962ebe089aaf", "patch": "@@ -32,9 +32,8 @@ impl Condvar {\n         mutex.lock()\n     }\n \n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, _dur: Duration) -> bool {\n-        mutex.unlock(); // don't hold the lock while panicking\n-        panic!(\"timeout not supported in SGX\");\n+    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n+        rtabort!(\"timeout not supported in SGX\");\n     }\n \n     #[inline]"}, {"sha": "b0679f65f0d68fc028064dbd8dfd14e7113fbb1e", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=6d96c8979d37dd137d29a992fc9b962ebe089aaf", "patch": "@@ -139,7 +139,7 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n                     return ret;\n                 }\n             }\n-            panic!(\"Failed to obtain random data\");\n+            rtabort!(\"Failed to obtain random data\");\n         }\n     }\n     (rdrand64(), rdrand64())"}, {"sha": "09b5ffb199676d07464b7113daeb09d080517a9b", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=6d96c8979d37dd137d29a992fc9b962ebe089aaf", "patch": "@@ -105,7 +105,7 @@ impl RWLock {\n                 *wguard.lock_var_mut() = true;\n             } else {\n                 // No writers were waiting, the lock is released\n-                assert!(rguard.queue_empty());\n+                rtassert!(rguard.queue_empty());\n             }\n         }\n     }"}, {"sha": "565a523ebe06f3461907456a162965b169c2ac57", "filename": "src/libstd/sys/sgx/thread.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=6d96c8979d37dd137d29a992fc9b962ebe089aaf", "patch": "@@ -62,25 +62,23 @@ impl Thread {\n     }\n \n     pub(super) fn entry() {\n-        let mut guard = task_queue::lock();\n-        let task = guard.pop().expect(\"Thread started but no tasks pending\");\n-        drop(guard); // make sure to not hold the task queue lock longer than necessary\n+        let mut pending_tasks = task_queue::lock();\n+        let task = rtunwrap!(Some, pending_tasks.pop());\n+        drop(pending_tasks); // make sure to not hold the task queue lock longer than necessary\n         task.run()\n     }\n \n     pub fn yield_now() {\n-        assert_eq!(\n-            usercalls::wait(0, usercalls::raw::WAIT_NO).unwrap_err().kind(),\n-            io::ErrorKind::WouldBlock\n-        );\n+        let wait_error = rtunwrap!(Err, usercalls::wait(0, usercalls::raw::WAIT_NO));\n+        rtassert!(wait_error.kind() == io::ErrorKind::WouldBlock);\n     }\n \n     pub fn set_name(_name: &CStr) {\n         // FIXME: could store this pointer in TLS somewhere\n     }\n \n     pub fn sleep(_dur: Duration) {\n-        panic!(\"can't sleep\"); // FIXME\n+        rtabort!(\"can't sleep\"); // FIXME\n     }\n \n     pub fn join(self) {"}, {"sha": "d542f9b41012793bc4b90d62e827c901dde9515a", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=6d96c8979d37dd137d29a992fc9b962ebe089aaf", "patch": "@@ -121,7 +121,7 @@ impl<'a, T> Drop for WaitGuard<'a, T> {\n             NotifiedTcs::Single(tcs) => Some(tcs),\n             NotifiedTcs::All { .. } => None\n         };\n-        usercalls::send(EV_UNPARK, target_tcs).unwrap();\n+        rtunwrap!(Ok, usercalls::send(EV_UNPARK, target_tcs));\n     }\n }\n \n@@ -141,6 +141,7 @@ impl WaitQueue {\n     ///\n     /// This function does not return until this thread has been awoken.\n     pub fn wait<T>(mut guard: SpinMutexGuard<'_, WaitVariable<T>>) {\n+        // very unsafe: check requirements of UnsafeList::push\n         unsafe {\n             let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n                 tcs: thread::current(),\n@@ -149,10 +150,9 @@ impl WaitQueue {\n             let entry = guard.queue.inner.push(&mut entry);\n             drop(guard);\n             while !entry.lock().wake {\n-                assert_eq!(\n-                    usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap() & EV_UNPARK,\n-                    EV_UNPARK\n-                );\n+                // don't panic, this would invalidate `entry` during unwinding\n+                let eventset = rtunwrap!(Ok, usercalls::wait(EV_UNPARK, WAIT_INDEFINITE));\n+                rtassert!(eventset & EV_UNPARK == EV_UNPARK);\n             }\n         }\n     }\n@@ -269,7 +269,7 @@ mod unsafe_list {\n                         // ,-------> /---------\\ next ---,\n                         // |         |head_tail|         |\n                         // `--- prev \\---------/ <-------`\n-                        assert_eq!(self.head_tail.as_ref().prev, first);\n+                        rtassert!(self.head_tail.as_ref().prev == first);\n                         true\n                     } else {\n                         false\n@@ -285,7 +285,9 @@ mod unsafe_list {\n         /// # Safety\n         ///\n         /// The entry must remain allocated until the entry is removed from the\n-        /// list AND the caller who popped is done using the entry.\n+        /// list AND the caller who popped is done using the entry. Special\n+        /// care must be taken in the caller of `push` to ensure unwinding does\n+        /// not destroy the stack frame containing the entry.\n         pub unsafe fn push<'a>(&mut self, entry: &'a mut UnsafeListEntry<T>) -> &'a T {\n             self.init();\n \n@@ -303,6 +305,7 @@ mod unsafe_list {\n             entry.as_mut().prev = prev_tail;\n             entry.as_mut().next = self.head_tail;\n             prev_tail.as_mut().next = entry;\n+            // unwrap ok: always `Some` on non-dummy entries\n             (*entry.as_ptr()).value.as_ref().unwrap()\n         }\n \n@@ -333,6 +336,7 @@ mod unsafe_list {\n                 second.as_mut().prev = self.head_tail;\n                 first.as_mut().next = NonNull::dangling();\n                 first.as_mut().prev = NonNull::dangling();\n+                // unwrap ok: always `Some` on non-dummy entries\n                 Some((*first.as_ptr()).value.as_ref().unwrap())\n             }\n         }"}, {"sha": "4c64e9f3afba7731cf0b7d461fa895f1623d3007", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d96c8979d37dd137d29a992fc9b962ebe089aaf/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=6d96c8979d37dd137d29a992fc9b962ebe089aaf", "patch": "@@ -28,6 +28,15 @@ macro_rules! rtassert {\n     })\n }\n \n+#[allow(unused_macros)] // not used on all platforms\n+macro_rules! rtunwrap {\n+    ($ok:ident, $e:expr) => (if let $ok(v) = $e {\n+        v\n+    } else {\n+        rtabort!(concat!(\"unwrap failed: \", stringify!($e)));\n+    })\n+}\n+\n pub mod alloc;\n pub mod at_exit_imp;\n #[cfg(feature = \"backtrace\")]"}]}