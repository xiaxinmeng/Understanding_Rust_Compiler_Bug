{"sha": "8cbc02238da9f36245d61e1d77ecd214eeed2e6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjYmMwMjIzOGRhOWYzNjI0NWQ2MWUxZDc3ZWNkMjE0ZWVlZDJlNmU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-13T14:13:44Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-13T14:13:44Z"}, "message": "incr.comp.: Include header when loading cache files in order to get the same byte offsets as when saving.", "tree": {"sha": "f7dccab684b8dd496fcce9183a932a4aea97bd11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7dccab684b8dd496fcce9183a932a4aea97bd11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cbc02238da9f36245d61e1d77ecd214eeed2e6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cbc02238da9f36245d61e1d77ecd214eeed2e6e", "html_url": "https://github.com/rust-lang/rust/commit/8cbc02238da9f36245d61e1d77ecd214eeed2e6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cbc02238da9f36245d61e1d77ecd214eeed2e6e/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67d2b1b7fd2d0efed9734bcab0f25528b9e37492", "url": "https://api.github.com/repos/rust-lang/rust/commits/67d2b1b7fd2d0efed9734bcab0f25528b9e37492", "html_url": "https://github.com/rust-lang/rust/commit/67d2b1b7fd2d0efed9734bcab0f25528b9e37492"}], "stats": {"total": 48, "additions": 28, "deletions": 20}, "files": [{"sha": "a301b0ce6a7de0d3c27b1dfafa36a038ae40a4d0", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbc02238da9f36245d61e1d77ecd214eeed2e6e/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbc02238da9f36245d61e1d77ecd214eeed2e6e/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=8cbc02238da9f36245d61e1d77ecd214eeed2e6e", "patch": "@@ -58,10 +58,10 @@ impl<'sess> OnDiskCache<'sess> {\n     /// so far) will eagerly deserialize the complete cache. Once we are\n     /// dealing with larger amounts of data (i.e. cached query results),\n     /// deserialization will need to happen lazily.\n-    pub fn new(sess: &'sess Session, data: &[u8]) -> OnDiskCache<'sess> {\n+    pub fn new(sess: &'sess Session, data: &[u8], start_pos: usize) -> OnDiskCache<'sess> {\n         debug_assert!(sess.opts.incremental.is_some());\n \n-        let mut decoder = opaque::Decoder::new(&data[..], 0);\n+        let mut decoder = opaque::Decoder::new(&data[..], start_pos);\n         let header = Header::decode(&mut decoder).unwrap();\n \n         let prev_diagnostics: FxHashMap<_, _> = {"}, {"sha": "7d27b842a68a7def7bb6ccf626be9180c7cb7618", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8cbc02238da9f36245d61e1d77ecd214eeed2e6e/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbc02238da9f36245d61e1d77ecd214eeed2e6e/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=8cbc02238da9f36245d61e1d77ecd214eeed2e6e", "patch": "@@ -53,19 +53,25 @@ pub fn write_file_header<W: io::Write>(stream: &mut W) -> io::Result<()> {\n \n /// Reads the contents of a file with a file header as defined in this module.\n ///\n-/// - Returns `Ok(Some(data))` if the file existed and was generated by a\n+/// - Returns `Ok(Some(data, pos))` if the file existed and was generated by a\n ///   compatible compiler version. `data` is the entire contents of the file\n-///   *after* the header.\n+///   and `pos` points to the first byte after the header.\n /// - Returns `Ok(None)` if the file did not exist or was generated by an\n ///   incompatible version of the compiler.\n /// - Returns `Err(..)` if some kind of IO error occurred while reading the\n ///   file.\n-pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<Vec<u8>>> {\n+pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<(Vec<u8>, usize)>> {\n     if !path.exists() {\n         return Ok(None);\n     }\n \n     let mut file = File::open(path)?;\n+    let file_size = file.metadata()?.len() as usize;\n+\n+    let mut data = Vec::with_capacity(file_size);\n+    file.read_to_end(&mut data)?;\n+\n+    let mut file = io::Cursor::new(data);\n \n     // Check FILE_MAGIC\n     {\n@@ -107,10 +113,8 @@ pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<Vec<u8>>> {\n         }\n     }\n \n-    let mut data = vec![];\n-    file.read_to_end(&mut data)?;\n-\n-    Ok(Some(data))\n+    let post_header_start_pos = file.position() as usize;\n+    Ok(Some((file.into_inner(), post_header_start_pos)))\n }\n \n fn report_format_mismatch(sess: &Session, file: &Path, message: &str) {"}, {"sha": "624a9ed930ad05778ac7046e42e8d79d1c6bd452", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8cbc02238da9f36245d61e1d77ecd214eeed2e6e/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbc02238da9f36245d61e1d77ecd214eeed2e6e/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=8cbc02238da9f36245d61e1d77ecd214eeed2e6e", "patch": "@@ -42,9 +42,9 @@ pub fn dep_graph_tcx_init<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n \n     let work_products_path = work_products_path(tcx.sess);\n-    if let Some(work_products_data) = load_data(tcx.sess, &work_products_path) {\n+    if let Some((work_products_data, start_pos)) = load_data(tcx.sess, &work_products_path) {\n         // Decode the list of work_products\n-        let mut work_product_decoder = Decoder::new(&work_products_data[..], 0);\n+        let mut work_product_decoder = Decoder::new(&work_products_data[..], start_pos);\n         let work_products: Vec<SerializedWorkProduct> =\n             RustcDecodable::decode(&mut work_product_decoder).unwrap_or_else(|e| {\n                 let msg = format!(\"Error decoding `work-products` from incremental \\\n@@ -77,9 +77,9 @@ pub fn dep_graph_tcx_init<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n-fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n+fn load_data(sess: &Session, path: &Path) -> Option<(Vec<u8>, usize)> {\n     match file_format::read_file(sess, path) {\n-        Ok(Some(data)) => return Some(data),\n+        Ok(Some(data_and_pos)) => return Some(data_and_pos),\n         Ok(None) => {\n             // The file either didn't exist or was produced by an incompatible\n             // compiler version. Neither is an error.\n@@ -126,8 +126,8 @@ pub fn load_prev_metadata_hashes(tcx: TyCtxt) -> DefIdMap<Fingerprint> {\n \n     debug!(\"load_prev_metadata_hashes() - File: {}\", file_path.display());\n \n-    let data = match file_format::read_file(tcx.sess, &file_path) {\n-        Ok(Some(data)) => data,\n+    let (data, start_pos) = match file_format::read_file(tcx.sess, &file_path) {\n+        Ok(Some(data_and_pos)) => data_and_pos,\n         Ok(None) => {\n             debug!(\"load_prev_metadata_hashes() - File produced by incompatible \\\n                     compiler version: {}\", file_path.display());\n@@ -141,7 +141,7 @@ pub fn load_prev_metadata_hashes(tcx: TyCtxt) -> DefIdMap<Fingerprint> {\n     };\n \n     debug!(\"load_prev_metadata_hashes() - Decoding hashes\");\n-    let mut decoder = Decoder::new(&data, 0);\n+    let mut decoder = Decoder::new(&data, start_pos);\n     let _ = Svh::decode(&mut decoder).unwrap();\n     let serialized_hashes = SerializedMetadataHashes::decode(&mut decoder).unwrap();\n \n@@ -171,8 +171,8 @@ pub fn load_dep_graph(sess: &Session) -> PreviousDepGraph {\n         return empty\n     }\n \n-    if let Some(bytes) = load_data(sess, &dep_graph_path(sess)) {\n-        let mut decoder = Decoder::new(&bytes, 0);\n+    if let Some((bytes, start_pos)) = load_data(sess, &dep_graph_path(sess)) {\n+        let mut decoder = Decoder::new(&bytes, start_pos);\n         let prev_commandline_args_hash = u64::decode(&mut decoder)\n             .expect(\"Error reading commandline arg hash from cached dep-graph\");\n \n@@ -184,6 +184,10 @@ pub fn load_dep_graph(sess: &Session) -> PreviousDepGraph {\n             // We can't reuse the cache, purge it.\n             debug!(\"load_dep_graph_new: differing commandline arg hashes\");\n \n+            delete_all_session_dir_contents(sess)\n+                .expect(\"Failed to delete invalidated incr. comp. session \\\n+                         directory contents.\");\n+\n             // No need to do any further work\n             return empty\n         }\n@@ -202,8 +206,8 @@ pub fn load_query_result_cache<'sess>(sess: &'sess Session) -> OnDiskCache<'sess\n         return OnDiskCache::new_empty(sess.codemap());\n     }\n \n-    if let Some(bytes) = load_data(sess, &query_cache_path(sess)) {\n-        OnDiskCache::new(sess, &bytes[..])\n+    if let Some((bytes, start_pos)) = load_data(sess, &query_cache_path(sess)) {\n+        OnDiskCache::new(sess, &bytes[..], start_pos)\n     } else {\n         OnDiskCache::new_empty(sess.codemap())\n     }"}]}