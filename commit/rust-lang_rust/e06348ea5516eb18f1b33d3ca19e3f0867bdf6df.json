{"sha": "e06348ea5516eb18f1b33d3ca19e3f0867bdf6df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNjM0OGVhNTUxNmViMThmMWIzM2QzY2ExOWUzZjA4NjdiZGY2ZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-24T19:06:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-24T19:06:58Z"}, "message": "auto merge of #13049 : alexcrichton/rust/io-fill, r=huonw\n\nThis method can be used to fill a byte slice of data entirely, and it's considered an error if any error happens before its entirely filled.", "tree": {"sha": "f4dc757b09e2c4a9434828f2165dfabdbb8f153a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4dc757b09e2c4a9434828f2165dfabdbb8f153a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e06348ea5516eb18f1b33d3ca19e3f0867bdf6df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e06348ea5516eb18f1b33d3ca19e3f0867bdf6df", "html_url": "https://github.com/rust-lang/rust/commit/e06348ea5516eb18f1b33d3ca19e3f0867bdf6df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e06348ea5516eb18f1b33d3ca19e3f0867bdf6df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6468a82151c073130dc1c6517890bb41929ad11", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6468a82151c073130dc1c6517890bb41929ad11", "html_url": "https://github.com/rust-lang/rust/commit/e6468a82151c073130dc1c6517890bb41929ad11"}, {"sha": "02dab5a3e79a48c77d28c9aa6dcfea173584933b", "url": "https://api.github.com/repos/rust-lang/rust/commits/02dab5a3e79a48c77d28c9aa6dcfea173584933b", "html_url": "https://github.com/rust-lang/rust/commit/02dab5a3e79a48c77d28c9aa6dcfea173584933b"}], "stats": {"total": 51, "additions": 40, "deletions": 11}, "files": [{"sha": "9e7e38d27239a85fa9d0f2c70c894fe8bc6c43e5", "filename": "src/librand/reader.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e06348ea5516eb18f1b33d3ca19e3f0867bdf6df/src%2Flibrand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e06348ea5516eb18f1b33d3ca19e3f0867bdf6df/src%2Flibrand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freader.rs?ref=e06348ea5516eb18f1b33d3ca19e3f0867bdf6df", "patch": "@@ -60,10 +60,8 @@ impl<R: Reader> Rng for ReaderRng<R> {\n     }\n     fn fill_bytes(&mut self, v: &mut [u8]) {\n         if v.len() == 0 { return }\n-        match self.reader.read(v) {\n-            Ok(n) if n == v.len() => return,\n-            Ok(n) => fail!(\"ReaderRng.fill_bytes could not fill buffer: \\\n-                            read {} out of {} bytes.\", n, v.len()),\n+        match self.reader.fill(v) {\n+            Ok(()) => {}\n             Err(e) => fail!(\"ReaderRng.fill_bytes error: {}\", e)\n         }\n     }"}, {"sha": "fed47dfcff36636d4abdf5f11f2b34dabbe27a3f", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e06348ea5516eb18f1b33d3ca19e3f0867bdf6df/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e06348ea5516eb18f1b33d3ca19e3f0867bdf6df/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=e06348ea5516eb18f1b33d3ca19e3f0867bdf6df", "patch": "@@ -86,7 +86,7 @@ impl<R: Reader> BufferedReader<R> {\n }\n \n impl<R: Reader> Buffer for BufferedReader<R> {\n-    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos == self.cap {\n             self.cap = try!(self.inner.read(self.buf.as_mut_slice()));\n             self.pos = 0;\n@@ -103,7 +103,7 @@ impl<R: Reader> Buffer for BufferedReader<R> {\n impl<R: Reader> Reader for BufferedReader<R> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let nread = {\n-            let available = try!(self.fill());\n+            let available = try!(self.fill_buf());\n             let nread = cmp::min(available.len(), buf.len());\n             slice::bytes::copy_memory(buf, available.slice_to(nread));\n             nread\n@@ -345,7 +345,7 @@ impl<S: Stream> BufferedStream<S> {\n }\n \n impl<S: Stream> Buffer for BufferedStream<S> {\n-    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill() }\n+    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }\n     fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n }\n "}, {"sha": "7ae717cfccf971c0bb059a8b93db298c5dac8127", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e06348ea5516eb18f1b33d3ca19e3f0867bdf6df/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e06348ea5516eb18f1b33d3ca19e3f0867bdf6df/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=e06348ea5516eb18f1b33d3ca19e3f0867bdf6df", "patch": "@@ -190,7 +190,7 @@ impl Seek for MemReader {\n }\n \n impl Buffer for MemReader {\n-    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n             Ok(self.buf.slice_from(self.pos))\n         } else {\n@@ -322,7 +322,7 @@ impl<'a> Seek for BufReader<'a> {\n }\n \n impl<'a> Buffer for BufReader<'a> {\n-    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n             Ok(self.buf.slice_from(self.pos))\n         } else {\n@@ -555,4 +555,18 @@ mod test {\n         let mut r = BufWriter::new(buf);\n         assert!(r.seek(-1, SeekSet).is_err());\n     }\n+\n+    #[test]\n+    fn io_fill() {\n+        let mut r = MemReader::new(~[1, 2, 3, 4, 5, 6, 7, 8]);\n+        let mut buf = [0, ..3];\n+        assert_eq!(r.fill(buf), Ok(()));\n+        assert_eq!(buf.as_slice(), &[1, 2, 3]);\n+        assert_eq!(r.fill(buf.mut_slice_to(0)), Ok(()));\n+        assert_eq!(buf.as_slice(), &[1, 2, 3]);\n+        assert_eq!(r.fill(buf), Ok(()));\n+        assert_eq!(buf.as_slice(), &[4, 5, 6]);\n+        assert!(r.fill(buf).is_err());\n+        assert_eq!(buf.as_slice(), &[7, 8, 6]);\n+    }\n }"}, {"sha": "6bd8f119ba29b408f9036f2802b6ed26786e384a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e06348ea5516eb18f1b33d3ca19e3f0867bdf6df/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e06348ea5516eb18f1b33d3ca19e3f0867bdf6df/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e06348ea5516eb18f1b33d3ca19e3f0867bdf6df", "patch": "@@ -360,6 +360,23 @@ pub trait Reader {\n         }\n     }\n \n+    /// Fills the provided slice with bytes from this reader\n+    ///\n+    /// This will continue to call `read` until the slice has been completely\n+    /// filled with bytes.\n+    ///\n+    /// # Error\n+    ///\n+    /// If an error occurs at any point, that error is returned, and no further\n+    /// bytes are read.\n+    fn fill(&mut self, buf: &mut [u8]) -> IoResult<()> {\n+        let mut read = 0;\n+        while read < buf.len() {\n+            read += try!(self.read(buf.mut_slice_from(read)));\n+        }\n+        Ok(())\n+    }\n+\n     /// Reads exactly `len` bytes and appends them to a vector.\n     ///\n     /// May push fewer than the requested number of bytes on error\n@@ -1045,7 +1062,7 @@ pub trait Buffer: Reader {\n     /// This function will return an I/O error if the underlying reader was\n     /// read, but returned an error. Note that it is not an error to return a\n     /// 0-length buffer.\n-    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]>;\n+    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]>;\n \n     /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n     /// so they should no longer be returned in calls to `fill` or `read`.\n@@ -1116,7 +1133,7 @@ pub trait Buffer: Reader {\n         let mut used;\n         loop {\n             {\n-                let available = match self.fill() {\n+                let available = match self.fill_buf() {\n                     Ok(n) => n,\n                     Err(ref e) if res.len() > 0 && e.kind == EndOfFile => {\n                         used = 0;"}]}