{"sha": "4908017d59da8694b9ceaf743baf1163c1e19086", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5MDgwMTdkNTlkYTg2OTRiOWNlYWY3NDNiYWYxMTYzYzFlMTkwODY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-10T17:02:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-22T03:09:55Z"}, "message": "std: Stabilize the std::str module\n\nThis commit starts out by consolidating all `str` extension traits into one\n`StrExt` trait to be included in the prelude. This means that\n`UnicodeStrPrelude`, `StrPrelude`, and `StrAllocating` have all been merged into\none `StrExt` exported by the standard library. Some functionality is currently\nduplicated with the `StrExt` present in libcore.\n\nThis commit also currently avoids any methods which require any form of pattern\nto operate. These functions will be stabilized via a separate RFC.\n\nNext, stability of methods and structures are as follows:\n\nStable\n\n* from_utf8_unchecked\n* CowString - after moving to std::string\n* StrExt::as_bytes\n* StrExt::as_ptr\n* StrExt::bytes/Bytes - also made a struct instead of a typedef\n* StrExt::char_indices/CharIndices - CharOffsets was renamed\n* StrExt::chars/Chars\n* StrExt::is_empty\n* StrExt::len\n* StrExt::lines/Lines\n* StrExt::lines_any/LinesAny\n* StrExt::slice_unchecked\n* StrExt::trim\n* StrExt::trim_left\n* StrExt::trim_right\n* StrExt::words/Words - also made a struct instead of a typedef\n\nUnstable\n\n* from_utf8 - the error type was changed to a `Result`, but the error type has\n              yet to prove itself\n* from_c_str - this function will be handled by the c_str RFC\n* FromStr - this trait will have an associated error type eventually\n* StrExt::escape_default - needs iterators at least, unsure if it should make\n                           the cut\n* StrExt::escape_unicode - needs iterators at least, unsure if it should make\n                           the cut\n* StrExt::slice_chars - this function has yet to prove itself\n* StrExt::slice_shift_char - awaiting conventions about slicing and shifting\n* StrExt::graphemes/Graphemes - this functionality may only be in libunicode\n* StrExt::grapheme_indices/GraphemeIndices - this functionality may only be in\n                                             libunicode\n* StrExt::width - this functionality may only be in libunicode\n* StrExt::utf16_units - this functionality may only be in libunicode\n* StrExt::nfd_chars - this functionality may only be in libunicode\n* StrExt::nfkd_chars - this functionality may only be in libunicode\n* StrExt::nfc_chars - this functionality may only be in libunicode\n* StrExt::nfkc_chars - this functionality may only be in libunicode\n* StrExt::is_char_boundary - naming is uncertain with container conventions\n* StrExt::char_range_at - naming is uncertain with container conventions\n* StrExt::char_range_at_reverse - naming is uncertain with container conventions\n* StrExt::char_at - naming is uncertain with container conventions\n* StrExt::char_at_reverse - naming is uncertain with container conventions\n* StrVector::concat - this functionality may be replaced with iterators, but\n                      it's not certain at this time\n* StrVector::connect - as with concat, may be deprecated in favor of iterators\n\nDeprecated\n\n* StrAllocating and UnicodeStrPrelude have been merged into StrExit\n* eq_slice - compiler implementation detail\n* from_str - use the inherent parse() method\n* is_utf8 - call from_utf8 instead\n* replace - call the method instead\n* truncate_utf16_at_nul - this is an implementation detail of windows and does\n                          not need to be exposed.\n* utf8_char_width - moved to libunicode\n* utf16_items - moved to libunicode\n* is_utf16 - moved to libunicode\n* Utf16Items - moved to libunicode\n* Utf16Item - moved to libunicode\n* Utf16Encoder - moved to libunicode\n* AnyLines - renamed to LinesAny and made a struct\n* SendStr - use CowString<'static> instead\n* str::raw - all functionality is deprecated\n* StrExt::into_string - call to_string() instead\n* StrExt::repeat - use iterators instead\n* StrExt::char_len - use .chars().count() instead\n* StrExt::is_alphanumeric - use .chars().all(..)\n* StrExt::is_whitespace - use .chars().all(..)\n\nPending deprecation -- while slicing syntax is being worked out, these methods\nare all #[unstable]\n\n* Str - while currently used for generic programming, this trait will be\n        replaced with one of [], deref coercions, or a generic conversion trait.\n* StrExt::slice - use slicing syntax instead\n* StrExt::slice_to - use slicing syntax instead\n* StrExt::slice_from - use slicing syntax instead\n* StrExt::lev_distance - deprecated with no replacement\n\nAwaiting stabilization due to patterns and/or matching\n\n* StrExt::contains\n* StrExt::contains_char\n* StrExt::split\n* StrExt::splitn\n* StrExt::split_terminator\n* StrExt::rsplitn\n* StrExt::match_indices\n* StrExt::split_str\n* StrExt::starts_with\n* StrExt::ends_with\n* StrExt::trim_chars\n* StrExt::trim_left_chars\n* StrExt::trim_right_chars\n* StrExt::find\n* StrExt::rfind\n* StrExt::find_str\n* StrExt::subslice_offset", "tree": {"sha": "1d3fba24a20e8c7a4e5cc5a477fb7779700755ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d3fba24a20e8c7a4e5cc5a477fb7779700755ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4908017d59da8694b9ceaf743baf1163c1e19086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4908017d59da8694b9ceaf743baf1163c1e19086", "html_url": "https://github.com/rust-lang/rust/commit/4908017d59da8694b9ceaf743baf1163c1e19086", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4908017d59da8694b9ceaf743baf1163c1e19086/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34d680009205de2302b902d8f9f5f7ae7a042f1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d680009205de2302b902d8f9f5f7ae7a042f1a", "html_url": "https://github.com/rust-lang/rust/commit/34d680009205de2302b902d8f9f5f7ae7a042f1a"}], "stats": {"total": 2589, "additions": 1511, "deletions": 1078}, "files": [{"sha": "8c9346639b3426d8e7dea416be20a059b9b2491b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 983, "deletions": 139, "changes": 1122, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -55,34 +55,31 @@ use self::MaybeOwned::*;\n use self::RecompositionState::*;\n use self::DecompositionType::*;\n \n+use core::prelude::*;\n+\n use core::borrow::{BorrowFrom, Cow, ToOwned};\n-use core::clone::Clone;\n+use core::cmp::{mod, Equiv, PartialEq, Eq, PartialOrd, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash;\n-use core::char::Char;\n-use core::cmp::{mod, Eq, Equiv, Ord, Ordering, PartialEq, PartialOrd};\n-use core::iter::{range, AdditiveIterator, Iterator, IteratorExt};\n-use core::kinds::Sized;\n-use core::option::Option::{mod, Some, None};\n-use core::slice::{AsSlice, SliceExt};\n+use core::iter::AdditiveIterator;\n+use core::iter::{mod, range, Iterator, IteratorExt};\n+use core::str as core_str;\n+use unicode::str::{UnicodeStr, Utf16Encoder};\n \n use ring_buf::RingBuf;\n-use string::String;\n+use string::{String, ToString};\n use unicode;\n use vec::Vec;\n \n-pub use core::str::{from_utf8, CharEq, Chars, CharOffsets};\n+pub use core::str::{from_utf8, CharEq, Chars, CharIndices};\n pub use core::str::{Bytes, CharSplits};\n-pub use core::str::{CharSplitsN, AnyLines, MatchIndices, StrSplits};\n-pub use core::str::{Utf16Encoder, Utf16CodeUnits};\n-pub use core::str::{eq_slice, is_utf8, is_utf16, Utf16Items};\n-pub use core::str::{Utf16Item, ScalarValue, LoneSurrogate, utf16_items};\n-pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n-pub use core::str::{FromStr, from_str};\n-pub use core::str::{Str, StrPrelude};\n+pub use core::str::{CharSplitsN, Lines, LinesAny, MatchIndices, StrSplits};\n+pub use core::str::{CharRange};\n+pub use core::str::{FromStr, from_str, Utf8Error};\n+pub use core::str::Str;\n pub use core::str::{from_utf8_unchecked, from_c_str};\n-pub use unicode::str::{UnicodeStrPrelude, Words, Graphemes, GraphemeIndices};\n+pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n \n // FIXME(conventions): ensure bit/char conventions are followed by str's API\n \n@@ -91,6 +88,7 @@ Section: Creating a string\n */\n \n /// Methods for vectors of strings.\n+#[unstable = \"functionality may be replaced with iterators\"]\n pub trait StrVector for Sized? {\n     /// Concatenates a vector of strings.\n     ///\n@@ -117,6 +115,7 @@ pub trait StrVector for Sized? {\n     fn connect(&self, sep: &str) -> String;\n }\n \n+#[allow(deprecated)]\n impl<S: Str> StrVector for [S] {\n     fn concat(&self) -> String {\n         if self.is_empty() {\n@@ -129,7 +128,7 @@ impl<S: Str> StrVector for [S] {\n         let mut result = String::with_capacity(len);\n \n         for s in self.iter() {\n-            result.push_str(s.as_slice())\n+            result.push_str(s.as_slice());\n         }\n \n         result\n@@ -379,6 +378,21 @@ impl<'a> Iterator<char> for Recompositions<'a> {\n     }\n }\n \n+/// External iterator for a string's UTF16 codeunits.\n+/// Use with the `std::iter` module.\n+#[deriving(Clone)]\n+pub struct Utf16Units<'a> {\n+    encoder: Utf16Encoder<Chars<'a>>\n+}\n+\n+impl<'a> Iterator<u16> for Utf16Units<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> { self.encoder.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.encoder.size_hint() }\n+}\n+\n /// Replaces all occurrences of one string with another.\n ///\n /// # Arguments\n@@ -399,16 +413,9 @@ impl<'a> Iterator<char> for Recompositions<'a> {\n /// let new_string = str::replace(string, \"or\", \"str\");\n /// assert_eq!(new_string.as_slice(), \"strange\");\n /// ```\n+#[deprecated = \"call the inherent method instead\"]\n pub fn replace(s: &str, from: &str, to: &str) -> String {\n-    let mut result = String::new();\n-    let mut last_end = 0;\n-    for (start, end) in s.match_indices(from) {\n-        result.push_str(unsafe { s.slice_unchecked(last_end, start) });\n-        result.push_str(to);\n-        last_end = end;\n-    }\n-    result.push_str(unsafe { s.slice_unchecked(last_end, s.len()) });\n-    result\n+    s.replace(from, to)\n }\n \n /*\n@@ -434,7 +441,7 @@ Section: MaybeOwned\n /// A string type that can hold either a `String` or a `&str`.\n /// This can be useful as an optimization when an allocation is sometimes\n /// needed but not always.\n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use stding::string::CowString\"]\n pub enum MaybeOwned<'a> {\n     /// A borrowed string.\n     Slice(&'a str),\n@@ -443,9 +450,10 @@ pub enum MaybeOwned<'a> {\n }\n \n /// A specialization of `CowString` to be sendable.\n+#[deprecated = \"use std::string::CowString<'static>\"]\n pub type SendStr = CowString<'static>;\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> MaybeOwned<'a> {\n     /// Returns `true` if this `MaybeOwned` wraps an owned string.\n     ///\n@@ -483,6 +491,7 @@ impl<'a> MaybeOwned<'a> {\n \n     /// Return the number of bytes in this string.\n     #[inline]\n+    #[allow(deprecated)]\n     pub fn len(&self) -> uint { self.as_slice().len() }\n \n     /// Returns true if the string contains no bytes\n@@ -545,45 +554,47 @@ impl<'a> IntoMaybeOwned<'a> for MaybeOwned<'a> {\n     fn into_maybe_owned(self) -> MaybeOwned<'a> { self }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n+#[allow(deprecated)]\n impl<'a> PartialEq for MaybeOwned<'a> {\n     #[inline]\n     fn eq(&self, other: &MaybeOwned) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> Eq for MaybeOwned<'a> {}\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> PartialOrd for MaybeOwned<'a> {\n     #[inline]\n     fn partial_cmp(&self, other: &MaybeOwned) -> Option<Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> Ord for MaybeOwned<'a> {\n     #[inline]\n+    #[allow(deprecated)]\n     fn cmp(&self, other: &MaybeOwned) -> Ordering {\n         self.as_slice().cmp(other.as_slice())\n     }\n }\n \n #[allow(deprecated)]\n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a, S: Str> Equiv<S> for MaybeOwned<'a> {\n     #[inline]\n     fn equiv(&self, other: &S) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n+#[allow(deprecated)]\n impl<'a> Str for MaybeOwned<'a> {\n-    #[allow(deprecated)]\n     #[inline]\n     fn as_slice<'b>(&'b self) -> &'b str {\n         match *self {\n@@ -593,19 +604,7 @@ impl<'a> Str for MaybeOwned<'a> {\n     }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n-impl<'a> StrAllocating for MaybeOwned<'a> {\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn into_string(self) -> String {\n-        match self {\n-            Slice(s) => String::from_str(s),\n-            Owned(s) => s\n-        }\n-    }\n-}\n-\n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> Clone for MaybeOwned<'a> {\n     #[allow(deprecated)]\n     #[inline]\n@@ -617,22 +616,23 @@ impl<'a> Clone for MaybeOwned<'a> {\n     }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> Default for MaybeOwned<'a> {\n     #[allow(deprecated)]\n     #[inline]\n     fn default() -> MaybeOwned<'a> { Slice(\"\") }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n+#[allow(deprecated)]\n impl<'a, H: hash::Writer> hash::Hash<H> for MaybeOwned<'a> {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         self.as_slice().hash(hasher)\n     }\n }\n \n-#[deprecated = \"use std::str::CowString\"]\n+#[deprecated = \"use std::string::CowString\"]\n impl<'a> fmt::Show for MaybeOwned<'a> {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -650,10 +650,11 @@ impl BorrowFrom<String> for str {\n \n #[unstable = \"trait is unstable\"]\n impl ToOwned<String> for str {\n-    fn to_owned(&self) -> String { self.into_string() }\n+    fn to_owned(&self) -> String { self.to_string() }\n }\n \n /// Unsafe string operations.\n+#[deprecated]\n pub mod raw {\n     pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n     pub use core::str::raw::{slice_unchecked};\n@@ -664,46 +665,25 @@ Section: CowString\n */\n \n /// A clone-on-write string\n+#[deprecated = \"use std::string::CowString instead\"]\n pub type CowString<'a> = Cow<'a, String, str>;\n \n-impl<'a> Str for CowString<'a> {\n-    #[inline]\n-    fn as_slice<'b>(&'b self) -> &'b str {\n-        (**self).as_slice()\n-    }\n-}\n-\n /*\n Section: Trait implementations\n */\n \n /// Any string that can be represented as a slice.\n-pub trait StrAllocating: Str {\n-    /// Converts `self` into a `String`, not making a copy if possible.\n-    fn into_string(self) -> String;\n-\n+pub trait StrExt for Sized?: Slice<uint, str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n+    #[unstable = \"return type may change to be an iterator\"]\n     fn escape_default(&self) -> String {\n-        let me = self.as_slice();\n-        let mut out = String::with_capacity(me.len());\n-        for c in me.chars() {\n-            for c in c.escape_default() {\n-                out.push(c);\n-            }\n-        }\n-        out\n+        self.chars().flat_map(|c| c.escape_default()).collect()\n     }\n \n     /// Escapes each char in `s` with `char::escape_unicode`.\n+    #[unstable = \"return type may change to be an iterator\"]\n     fn escape_unicode(&self) -> String {\n-        let me = self.as_slice();\n-        let mut out = String::with_capacity(me.len());\n-        for c in me.chars() {\n-            for c in c.escape_unicode() {\n-                out.push(c);\n-            }\n-        }\n-        out\n+        self.chars().flat_map(|c| c.escape_unicode()).collect()\n     }\n \n     /// Replaces all occurrences of one string with another.\n@@ -730,25 +710,31 @@ pub trait StrAllocating: Str {\n     /// // not found, so no change.\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n     fn replace(&self, from: &str, to: &str) -> String {\n-        replace(self.as_slice(), from, to)\n+        let mut result = String::new();\n+        let mut last_end = 0;\n+        for (start, end) in self.match_indices(from) {\n+            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n+            result.push_str(to);\n+            last_end = end;\n+        }\n+        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n+        result\n     }\n \n     /// Given a string, makes a new string with repeated copies of it.\n+    #[deprecated = \"user repeat(self).take(n).collect() instead\"]\n     fn repeat(&self, nn: uint) -> String {\n-        let me = self.as_slice();\n-        let mut ret = String::with_capacity(nn * me.len());\n-        for _ in range(0, nn) {\n-            ret.push_str(me);\n-        }\n-        ret\n+        iter::repeat(self[]).take(nn).collect()\n     }\n \n     /// Returns the Levenshtein Distance between two strings.\n+    #[deprecated = \"this function will be removed\"]\n     fn lev_distance(&self, t: &str) -> uint {\n-        let me = self.as_slice();\n-        if me.is_empty() { return t.char_len(); }\n-        if t.is_empty() { return me.char_len(); }\n+        let me = self[];\n+        if me.is_empty() { return t.chars().count(); }\n+        if t.is_empty() { return me.chars().count(); }\n \n         let mut dcol = Vec::from_fn(t.len() + 1, |x| x);\n         let mut t_last = 0;\n@@ -780,9 +766,10 @@ pub trait StrAllocating: Str {\n     /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n+    #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n-            iter: self.as_slice().chars(),\n+            iter: self[].chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Canonical\n@@ -792,9 +779,10 @@ pub trait StrAllocating: Str {\n     /// Returns an iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n+    #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n-            iter: self.as_slice().chars(),\n+            iter: self[].chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Compatible\n@@ -804,6 +792,7 @@ pub trait StrAllocating: Str {\n     /// An Iterator over the string in Unicode Normalization Form C\n     /// (canonical decomposition followed by canonical composition).\n     #[inline]\n+    #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn nfc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n             iter: self.nfd_chars(),\n@@ -817,6 +806,7 @@ pub trait StrAllocating: Str {\n     /// An Iterator over the string in Unicode Normalization Form KC\n     /// (compatibility decomposition followed by canonical composition).\n     #[inline]\n+    #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn nfkc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n             iter: self.nfkd_chars(),\n@@ -826,15 +816,912 @@ pub trait StrAllocating: Str {\n             last_ccc: None\n         }\n     }\n-}\n \n-impl<'a> StrAllocating for &'a str {\n+    /// Returns true if one string contains another\n+    ///\n+    /// # Arguments\n+    ///\n+    /// - needle - The string to look for\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\"bananas\".contains(\"nana\"));\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn contains(&self, needle: &str) -> bool {\n+        core_str::StrExt::contains(self[], needle)\n+    }\n+\n+    /// Returns true if a string contains a char.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// - needle - The char to look for\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\"hello\".contains_char('e'));\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn contains_char(&self, needle: char) -> bool {\n+        core_str::StrExt::contains_char(self[], needle)\n+    }\n+\n+    /// An iterator over the characters of `self`. Note, this iterates\n+    /// over Unicode code-points, not Unicode graphemes.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n+    /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// ```\n+    #[stable]\n+    fn chars(&self) -> Chars {\n+        core_str::StrExt::chars(self[])\n+    }\n+\n+    /// An iterator over the bytes of `self`\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<u8> = \"bors\".bytes().collect();\n+    /// assert_eq!(v, b\"bors\".to_vec());\n+    /// ```\n+    #[stable]\n+    fn bytes(&self) -> Bytes {\n+        core_str::StrExt::bytes(self[])\n+    }\n+\n+    /// An iterator over the characters of `self` and their byte offsets.\n+    #[stable]\n+    fn char_indices(&self) -> CharIndices {\n+        core_str::StrExt::char_indices(self[])\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, vec![\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".split('X').collect();\n+    /// assert_eq!(v, vec![\"\"]);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<Sep> {\n+        core_str::StrExt::split(self[], sep)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, restricted to splitting at most `count`\n+    /// times.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n+    /// assert_eq!(v, vec![\"lion\", \"\", \"tigerXleopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(0, 'X').collect();\n+    /// assert_eq!(v, vec![\"abcXdef\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, vec![\"\"]);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn splitn<Sep: CharEq>(&self, count: uint, sep: Sep) -> CharSplitsN<Sep> {\n+        core_str::StrExt::splitn(self[], count, sep)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`.\n+    ///\n+    /// Equivalent to `split`, except that the trailing substring\n+    /// is skipped if empty (terminator semantics).\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n+    /// assert_eq!(v, vec![\"A\", \"B\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n+    /// assert_eq!(v, vec![\"A\", \"\", \"B\", \"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').rev().collect();\n+    /// assert_eq!(v, vec![\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).rev().collect();\n+    /// assert_eq!(v, vec![\"ghi\", \"def\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n+    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<Sep> {\n+        core_str::StrExt::split_terminator(self[], sep)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, starting from the end of the string.\n+    /// Restricted to splitting at most `count` times.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n+    /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n+    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn rsplitn<Sep: CharEq>(&self, count: uint, sep: Sep) -> CharSplitsN<Sep> {\n+        core_str::StrExt::rsplitn(self[], count, sep)\n+    }\n+\n+    /// An iterator over the start and end indices of the disjoint\n+    /// matches of `sep` within `self`.\n+    ///\n+    /// That is, each returned value `(start, end)` satisfies\n+    /// `self.slice(start, end) == sep`. For matches of `sep` within\n+    /// `self` that overlap, only the indices corresponding to the\n+    /// first match are returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<(uint, uint)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, vec![(0,3), (6,9), (12,15)]);\n+    ///\n+    /// let v: Vec<(uint, uint)> = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, vec![(1,4), (4,7)]);\n+    ///\n+    /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n+    /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a> {\n+        core_str::StrExt::match_indices(self[], sep)\n+    }\n+\n+    /// An iterator over the substrings of `self` separated by `sep`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, vec![\"\", \"XXX\", \"YYY\", \"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn split_str<'a>(&'a self, s: &'a str) -> StrSplits<'a> {\n+        core_str::StrExt::split_str(self[], s)\n+    }\n+\n+    /// An iterator over the lines of a string (subsequences separated\n+    /// by `\\n`). This does not include the empty string after a\n+    /// trailing `\\n`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n+    /// let v: Vec<&str> = four_lines.lines().collect();\n+    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    #[stable]\n+    fn lines(&self) -> Lines {\n+        core_str::StrExt::lines(self[])\n+    }\n+\n+    /// An iterator over the lines of a string, separated by either\n+    /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n+    /// empty trailing line.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n+    /// let v: Vec<&str> = four_lines.lines_any().collect();\n+    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    #[stable]\n+    fn lines_any(&self) -> LinesAny {\n+        core_str::StrExt::lines_any(self[])\n+    }\n+\n+    /// Returns the number of Unicode code points (`char`) that a\n+    /// string holds.\n+    ///\n+    /// This does not perform any normalization, and is `O(n)`, since\n+    /// UTF-8 is a variable width encoding of code points.\n+    ///\n+    /// *Warning*: The number of code points in a string does not directly\n+    /// correspond to the number of visible characters or width of the\n+    /// visible text due to composing characters, and double- and\n+    /// zero-width ones.\n+    ///\n+    /// See also `.len()` for the byte length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// // composed forms of `\u00f6` and `\u00e9`\n+    /// let c = \"L\u00f6we \u8001\u864e L\u00e9opard\"; // German, Simplified Chinese, French\n+    /// // decomposed forms of `\u00f6` and `\u00e9`\n+    /// let d = \"Lo\\u0308we \u8001\u864e Le\\u0301opard\";\n+    ///\n+    /// assert_eq!(c.char_len(), 15);\n+    /// assert_eq!(d.char_len(), 17);\n+    ///\n+    /// assert_eq!(c.len(), 21);\n+    /// assert_eq!(d.len(), 23);\n+    ///\n+    /// // the two strings *look* the same\n+    /// println!(\"{}\", c);\n+    /// println!(\"{}\", d);\n+    /// ```\n+    #[deprecated = \"call .chars().count() instead\"]\n+    fn char_len(&self) -> uint {\n+        core_str::StrExt::char_len(self[])\n+    }\n+\n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Panics when `begin` and `end` do not point to valid characters\n+    /// or point beyond the last character of the string.\n+    ///\n+    /// See also `slice_to` and `slice_from` for slicing prefixes and\n+    /// suffixes of strings, and `slice_chars` for slicing based on\n+    /// code point counts.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(s.slice(0, 1), \"L\");\n+    ///\n+    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n+    ///\n+    /// // these will panic:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // s.slice(2, 3);\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // s.slice(1, 8);\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // s.slice(3, 100);\n+    /// ```\n+    #[unstable = \"use slice notation [a..b] instead\"]\n+    fn slice(&self, begin: uint, end: uint) -> &str {\n+        core_str::StrExt::slice(self[], begin, end)\n+    }\n+\n+    /// Returns a slice of the string from `begin` to its end.\n+    ///\n+    /// Equivalent to `self.slice(begin, self.len())`.\n+    ///\n+    /// Panics when `begin` does not point to a valid character, or is\n+    /// out of bounds.\n+    ///\n+    /// See also `slice`, `slice_to` and `slice_chars`.\n+    #[unstable = \"use slice notation [a..] instead\"]\n+    fn slice_from(&self, begin: uint) -> &str {\n+        core_str::StrExt::slice_from(self[], begin)\n+    }\n+\n+    /// Returns a slice of the string from the beginning to byte\n+    /// `end`.\n+    ///\n+    /// Equivalent to `self.slice(0, end)`.\n+    ///\n+    /// Panics when `end` does not point to a valid character, or is\n+    /// out of bounds.\n+    ///\n+    /// See also `slice`, `slice_from` and `slice_chars`.\n+    #[unstable = \"use slice notation [0..a] instead\"]\n+    fn slice_to(&self, end: uint) -> &str {\n+        core_str::StrExt::slice_to(self[], end)\n+    }\n+\n+    /// Returns a slice of the string from the character range\n+    /// [`begin`..`end`).\n+    ///\n+    /// That is, start at the `begin`-th code point of the string and\n+    /// continue to the `end`-th code point. This does not detect or\n+    /// handle edge cases such as leaving a combining character as the\n+    /// first code point of the string.\n+    ///\n+    /// Due to the design of UTF-8, this operation is `O(end)`.\n+    /// See `slice`, `slice_to` and `slice_from` for `O(1)`\n+    /// variants that use byte indices rather than code point\n+    /// indices.\n+    ///\n+    /// Panics if `begin` > `end` or the either `begin` or `end` are\n+    /// beyond the last character of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n+    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n+    /// ```\n+    #[unstable = \"may have yet to prove its worth\"]\n+    fn slice_chars(&self, begin: uint, end: uint) -> &str {\n+        core_str::StrExt::slice_chars(self[], begin, end)\n+    }\n+\n+    /// Takes a bytewise (not UTF-8) slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// Caller must check both UTF-8 character boundaries and the boundaries of\n+    /// the entire slice as well.\n+    #[stable]\n+    unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n+        core_str::StrExt::slice_unchecked(self[], begin, end)\n+    }\n+\n+    /// Returns true if `needle` is a prefix of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\"banana\".starts_with(\"ba\"));\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn starts_with(&self, needle: &str) -> bool {\n+        core_str::StrExt::starts_with(self[], needle)\n+    }\n+\n+    /// Returns true if `needle` is a suffix of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\"banana\".ends_with(\"nana\"));\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn ends_with(&self, needle: &str) -> bool {\n+        core_str::StrExt::ends_with(self[], needle)\n+    }\n+\n+    /// Returns a string with characters that match `to_trim` removed from the left and the right.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_numeric()), \"foo1bar\")\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn trim_chars<C: CharEq>(&self, to_trim: C) -> &str {\n+        core_str::StrExt::trim_chars(self[], to_trim)\n+    }\n+\n+    /// Returns a string with leading `chars_to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\")\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_numeric()), \"foo1bar123\")\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &str {\n+        core_str::StrExt::trim_left_chars(self[], to_trim)\n+    }\n+\n+    /// Returns a string with trailing `chars_to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_numeric()), \"123foo1bar\")\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &str {\n+        core_str::StrExt::trim_right_chars(self[], to_trim)\n+    }\n+\n+    /// Check that `index`-th byte lies at the start and/or end of a\n+    /// UTF-8 code point sequence.\n+    ///\n+    /// The start and end of the string (when `index == self.len()`)\n+    /// are considered to be boundaries.\n+    ///\n+    /// Panics if `index` is greater than `self.len()`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert!(s.is_char_boundary(0));\n+    /// // start of `\u8001`\n+    /// assert!(s.is_char_boundary(6));\n+    /// assert!(s.is_char_boundary(s.len()));\n+    ///\n+    /// // second byte of `\u00f6`\n+    /// assert!(!s.is_char_boundary(2));\n+    ///\n+    /// // third byte of `\u8001`\n+    /// assert!(!s.is_char_boundary(8));\n+    /// ```\n+    #[unstable = \"naming is uncertain with container conventions\"]\n+    fn is_char_boundary(&self, index: uint) -> bool {\n+        core_str::StrExt::is_char_boundary(self[], index)\n+    }\n+\n+    /// Pluck a character out of a string and return the index of the next\n+    /// character.\n+    ///\n+    /// This function can be used to iterate over the Unicode characters of a\n+    /// string.\n+    ///\n+    /// # Example\n+    ///\n+    /// This example manually iterates through the characters of a\n+    /// string; this should normally be done by `.chars()` or\n+    /// `.char_indices`.\n+    ///\n+    /// ```rust\n+    /// use std::str::CharRange;\n+    ///\n+    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let mut i = 0u;\n+    /// while i < s.len() {\n+    ///     let CharRange {ch, next} = s.char_range_at(i);\n+    ///     println!(\"{}: {}\", i, ch);\n+    ///     i = next;\n+    /// }\n+    /// ```\n+    ///\n+    /// This outputs:\n+    ///\n+    /// ```text\n+    /// 0: \u4e2d\n+    /// 3: \u534e\n+    /// 6: V\n+    /// 7: i\n+    /// 8: \u1ec7\n+    /// 11: t\n+    /// 12:\n+    /// 13: N\n+    /// 14: a\n+    /// 15: m\n+    /// ```\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - The string\n+    /// * i - The byte offset of the char to extract\n+    ///\n+    /// # Return value\n+    ///\n+    /// A record {ch: char, next: uint} containing the char value and the byte\n+    /// index of the next Unicode character.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    #[unstable = \"naming is uncertain with container conventions\"]\n+    fn char_range_at(&self, start: uint) -> CharRange {\n+        core_str::StrExt::char_range_at(self[], start)\n+    }\n+\n+    /// Given a byte position and a str, return the previous char and its position.\n+    ///\n+    /// This function can be used to iterate over a Unicode string in reverse.\n+    ///\n+    /// Returns 0 for next index if called on start index 0.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `i` is greater than the length of the string.\n+    /// If `i` is not an index following a valid UTF-8 character.\n+    #[unstable = \"naming is uncertain with container conventions\"]\n+    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n+        core_str::StrExt::char_range_at_reverse(self[], start)\n+    }\n+\n+    /// Plucks the character starting at the `i`th byte of a string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"ab\u03c0c\";\n+    /// assert_eq!(s.char_at(1), 'b');\n+    /// assert_eq!(s.char_at(2), '\u03c0');\n+    /// assert_eq!(s.char_at(4), 'c');\n+    /// ```\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    #[unstable = \"naming is uncertain with container conventions\"]\n+    fn char_at(&self, i: uint) -> char {\n+        core_str::StrExt::char_at(self[], i)\n+    }\n+\n+    /// Plucks the character ending at the `i`th byte of a string.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `i` is greater than the length of the string.\n+    /// If `i` is not an index following a valid UTF-8 character.\n+    #[unstable = \"naming is uncertain with container conventions\"]\n+    fn char_at_reverse(&self, i: uint) -> char {\n+        core_str::StrExt::char_at_reverse(self[], i)\n+    }\n+\n+    /// Work with the byte buffer of a string as a byte slice.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n+    /// ```\n+    #[stable]\n+    fn as_bytes(&self) -> &[u8] {\n+        core_str::StrExt::as_bytes(self[])\n+    }\n+\n+    /// Returns the byte index of the first character of `self` that\n+    /// matches `search`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the last matching character\n+    /// or `None` if there is no match\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find('L'), Some(0));\n+    /// assert_eq!(s.find('\u00e9'), Some(14));\n+    ///\n+    /// // the first space\n+    /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n+    ///\n+    /// // neither are found\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(s.find(x), None);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n+        core_str::StrExt::find(self[], search)\n+    }\n+\n+    /// Returns the byte index of the last character of `self` that\n+    /// matches `search`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the last matching character\n+    /// or `None` if there is no match.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind('L'), Some(13));\n+    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    ///\n+    /// // the second space\n+    /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n+    ///\n+    /// // searches for an occurrence of either `1` or `2`, but neither are found\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(s.rfind(x), None);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n+        core_str::StrExt::rfind(self[], search)\n+    }\n+\n+    /// Returns the byte index of the first matching substring\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `needle` - The string to search for\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the first matching substring\n+    /// or `None` if there is no match.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n+    /// assert_eq!(s.find_str(\"muffin man\"), None);\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn find_str(&self, needle: &str) -> Option<uint> {\n+        core_str::StrExt::find_str(self[], needle)\n+    }\n+\n+    /// Retrieves the first character from a string slice and returns\n+    /// it. This does not allocate a new string; instead, it returns a\n+    /// slice that point one character beyond the character that was\n+    /// shifted. If the string does not contain any characters,\n+    /// None is returned instead.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let (c, s1) = s.slice_shift_char().unwrap();\n+    /// assert_eq!(c, 'L');\n+    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n+    ///\n+    /// let (c, s2) = s1.slice_shift_char().unwrap();\n+    /// assert_eq!(c, '\u00f6');\n+    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n+    /// ```\n+    #[unstable = \"awaiting conventions about shifting and slices\"]\n+    fn slice_shift_char(&self) -> Option<(char, &str)> {\n+        core_str::StrExt::slice_shift_char(self[])\n+    }\n+\n+    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n+    ///\n+    /// Panics if `inner` is not a direct slice contained within self.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let string = \"a\\nb\\nc\";\n+    /// let lines: Vec<&str> = string.lines().collect();\n+    ///\n+    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n+    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n+    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n+    /// ```\n+    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    fn subslice_offset(&self, inner: &str) -> uint {\n+        core_str::StrExt::subslice_offset(self[], inner)\n+    }\n+\n+    /// Return an unsafe pointer to the strings buffer.\n+    ///\n+    /// The caller must ensure that the string outlives this pointer,\n+    /// and that it is not reallocated (e.g. by pushing to the\n+    /// string).\n+    #[stable]\n     #[inline]\n-    fn into_string(self) -> String {\n-        String::from_str(self)\n+    fn as_ptr(&self) -> *const u8 {\n+        core_str::StrExt::as_ptr(self[])\n+    }\n+\n+    /// Return an iterator of `u16` over the string encoded as UTF-16.\n+    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    fn utf16_units(&self) -> Utf16Units {\n+        Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n+    }\n+\n+    /// Return the number of bytes in this string\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// assert_eq!(\"foo\".len(), 3);\n+    /// assert_eq!(\"\u0192oo\".len(), 4);\n+    /// ```\n+    #[stable]\n+    #[inline]\n+    fn len(&self) -> uint {\n+        core_str::StrExt::len(self[])\n+    }\n+\n+    /// Returns true if this slice contains no bytes\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// assert!(\"\".is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn is_empty(&self) -> bool {\n+        core_str::StrExt::is_empty(self[])\n+    }\n+\n+    /// Parse this string into the specified type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// assert_eq!(\"4\".parse::<u32>(), Some(4));\n+    /// assert_eq!(\"j\".parse::<u32>(), None);\n+    /// ```\n+    #[inline]\n+    #[unstable = \"this method was just created\"]\n+    fn parse<F: FromStr>(&self) -> Option<F> {\n+        FromStr::from_str(self[])\n+    }\n+\n+    /// Returns an iterator over the\n+    /// [grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n+    /// of the string.\n+    ///\n+    /// If `is_extended` is true, the iterator is over the *extended grapheme clusters*;\n+    /// otherwise, the iterator is over the *legacy grapheme clusters*.\n+    /// [UAX#29](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n+    /// recommends extended grapheme cluster boundaries for general processing.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let gr1 = \"a\\u0310e\\u0301o\\u0308\\u0332\".graphemes(true).collect::<Vec<&str>>();\n+    /// let b: &[_] = &[\"a\\u0310\", \"e\\u0301\", \"o\\u0308\\u0332\"];\n+    /// assert_eq!(gr1.as_slice(), b);\n+    /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n+    /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n+    /// assert_eq!(gr2.as_slice(), b);\n+    /// ```\n+    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    fn graphemes(&self, is_extended: bool) -> Graphemes {\n+        UnicodeStr::graphemes(self[], is_extended)\n+    }\n+\n+    /// Returns an iterator over the grapheme clusters of self and their byte offsets.\n+    /// See `graphemes()` method for more information.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n+    /// let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+    /// assert_eq!(gr_inds.as_slice(), b);\n+    /// ```\n+    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n+        UnicodeStr::grapheme_indices(self[], is_extended)\n+    }\n+\n+    /// An iterator over the words of a string (subsequences separated\n+    /// by any sequence of whitespace). Sequences of whitespace are\n+    /// collapsed, so empty \"words\" are not included.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let v: Vec<&str> = some_words.words().collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// ```\n+    #[stable]\n+    fn words(&self) -> Words {\n+        UnicodeStr::words(self[])\n+    }\n+\n+    /// Returns true if the string contains only whitespace.\n+    ///\n+    /// Whitespace characters are determined by `char::is_whitespace`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\" \\t\\n\".is_whitespace());\n+    /// assert!(\"\".is_whitespace());\n+    ///\n+    /// assert!( !\"abc\".is_whitespace());\n+    /// ```\n+    #[deprecated = \"use .chars().all(|c| c.is_whitespace())\"]\n+    fn is_whitespace(&self) -> bool {\n+        UnicodeStr::is_whitespace(self[])\n+    }\n+\n+    /// Returns true if the string contains only alphanumeric code\n+    /// points.\n+    ///\n+    /// Alphanumeric characters are determined by `char::is_alphanumeric`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\"L\u00f6we\u8001\u864eL\u00e9opard123\".is_alphanumeric());\n+    /// assert!(\"\".is_alphanumeric());\n+    ///\n+    /// assert!( !\" &*~\".is_alphanumeric());\n+    /// ```\n+    #[deprecated = \"use .chars().all(|c| c.is_alphanumeric())\"]\n+    fn is_alphanumeric(&self) -> bool {\n+        UnicodeStr::is_alphanumeric(self[])\n+    }\n+\n+    /// Returns a string's displayed width in columns, treating control\n+    /// characters as zero-width.\n+    ///\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n+    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n+    /// In CJK locales, `is_cjk` should be `true`, else it should be `false`.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+    /// recommends that these characters be treated as 1 column (i.e.,\n+    /// `is_cjk` = `false`) if the locale is unknown.\n+    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    fn width(&self, is_cjk: bool) -> uint {\n+        UnicodeStr::width(self[], is_cjk)\n+    }\n+\n+    /// Returns a string with leading and trailing whitespace removed.\n+    #[stable]\n+    fn trim(&self) -> &str {\n+        UnicodeStr::trim(self[])\n+    }\n+\n+    /// Returns a string with leading whitespace removed.\n+    #[stable]\n+    fn trim_left(&self) -> &str {\n+        UnicodeStr::trim_left(self[])\n+    }\n+\n+    /// Returns a string with trailing whitespace removed.\n+    #[stable]\n+    fn trim_right(&self) -> &str {\n+        UnicodeStr::trim_right(self[])\n     }\n }\n \n+impl StrExt for str {}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n@@ -1541,28 +2428,6 @@ mod tests {\n         assert!(!\"\".contains_char('a'));\n     }\n \n-    #[test]\n-    fn test_truncate_utf16_at_nul() {\n-        let v = [];\n-        let b: &[u16] = &[];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n-\n-        let v = [0, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n-\n-        let v = [1, 0, 3];\n-        let b: &[u16] = &[1];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n-\n-        let v = [1, 2, 0];\n-        let b: &[u16] = &[1, 2];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n-\n-        let v = [1, 2, 3];\n-        let b: &[u16] = &[1, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n-    }\n-\n     #[test]\n     fn test_char_at() {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -1814,27 +2679,6 @@ mod tests {\n         assert_eq!(words, vec![\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n     }\n \n-    #[test]\n-    fn test_lev_distance() {\n-        use core::char::{ from_u32, MAX };\n-        // Test bytelength agnosticity\n-        for c in range(0u32, MAX as u32)\n-                 .filter_map(|i| from_u32(i))\n-                 .map(|i| String::from_char(1, i)) {\n-            assert_eq!(c[].lev_distance(c[]), 0);\n-        }\n-\n-        let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-        let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-        let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-        assert_eq!(a.lev_distance(b), 1);\n-        assert_eq!(b.lev_distance(a), 1);\n-        assert_eq!(a.lev_distance(c), 2);\n-        assert_eq!(c.lev_distance(a), 2);\n-        assert_eq!(b.lev_distance(c), 1);\n-        assert_eq!(c.lev_distance(b), 1);\n-    }\n-\n     #[test]\n     fn test_nfd_chars() {\n         macro_rules! t {"}, {"sha": "0e2b514d92d4c2d349d28fba0c00a145b1825107", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -21,13 +21,12 @@ use core::hash;\n use core::mem;\n use core::ptr;\n use core::ops;\n-// FIXME: ICE's abound if you import the `Slice` type while importing `Slice` trait\n use core::raw::Slice as RawSlice;\n+use unicode::str as unicode_str;\n+use unicode::str::Utf16Item;\n \n use slice::CloneSliceExt;\n-use str;\n-use str::{CharRange, CowString, FromStr, StrAllocating};\n-use str::MaybeOwned::Owned;\n+use str::{mod, CharRange, FromStr, StrExt, Owned, Utf8Error};\n use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -87,8 +86,10 @@ impl String {\n     /// Returns the vector as a string buffer, if possible, taking care not to\n     /// copy it.\n     ///\n-    /// Returns `Err` with the original vector if the vector contains invalid\n-    /// UTF-8.\n+    /// # Failure\n+    ///\n+    /// If the given vector is not valid UTF-8, then the original vector and the\n+    /// corresponding error is returned.\n     ///\n     /// # Examples\n     ///\n@@ -103,11 +104,10 @@ impl String {\n     /// ```\n     #[inline]\n     #[unstable = \"error type may change\"]\n-    pub fn from_utf8(vec: Vec<u8>) -> Result<String, Vec<u8>> {\n-        if str::is_utf8(vec.as_slice()) {\n-            Ok(String { vec: vec })\n-        } else {\n-            Err(vec)\n+    pub fn from_utf8(vec: Vec<u8>) -> Result<String, (Vec<u8>, Utf8Error)> {\n+        match str::from_utf8(vec.as_slice()) {\n+            Ok(..) => Ok(String { vec: vec }),\n+            Err(e) => Err((vec, e))\n         }\n     }\n \n@@ -123,8 +123,9 @@ impl String {\n     /// ```\n     #[unstable = \"return type may change\"]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n-        if str::is_utf8(v) {\n-            return Cow::Borrowed(unsafe { mem::transmute(v) })\n+        match str::from_utf8(v) {\n+            Ok(s) => return Cow::Borrowed(s),\n+            Err(..) => {}\n         }\n \n         static TAG_CONT_U8: u8 = 128u8;\n@@ -173,7 +174,7 @@ impl String {\n             if byte < 128u8 {\n                 // subseqidx handles this\n             } else {\n-                let w = str::utf8_char_width(byte);\n+                let w = unicode_str::utf8_char_width(byte);\n \n                 match w {\n                     2 => {\n@@ -235,7 +236,7 @@ impl String {\n                 res.as_mut_vec().push_all(v[subseqidx..total])\n             };\n         }\n-        Cow::Owned(res.into_string())\n+        Cow::Owned(res)\n     }\n \n     /// Decode a UTF-16 encoded vector `v` into a `String`, returning `None`\n@@ -256,10 +257,10 @@ impl String {\n     #[unstable = \"error value in return may change\"]\n     pub fn from_utf16(v: &[u16]) -> Option<String> {\n         let mut s = String::with_capacity(v.len());\n-        for c in str::utf16_items(v) {\n+        for c in unicode_str::utf16_items(v) {\n             match c {\n-                str::ScalarValue(c) => s.push(c),\n-                str::LoneSurrogate(_) => return None\n+                Utf16Item::ScalarValue(c) => s.push(c),\n+                Utf16Item::LoneSurrogate(_) => return None\n             }\n         }\n         Some(s)\n@@ -281,7 +282,7 @@ impl String {\n     /// ```\n     #[stable]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n-        str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n+        unicode_str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n     }\n \n     /// Convert a vector of `char`s to a `String`.\n@@ -812,21 +813,12 @@ impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n }\n \n #[experimental = \"waiting on Str stabilization\"]\n+#[allow(deprecated)]\n impl Str for String {\n     #[inline]\n     #[stable]\n     fn as_slice<'a>(&'a self) -> &'a str {\n-        unsafe {\n-            mem::transmute(self.vec.as_slice())\n-        }\n-    }\n-}\n-\n-#[experimental = \"waiting on StrAllocating stabilization\"]\n-impl StrAllocating for String {\n-    #[inline]\n-    fn into_string(self) -> String {\n-        self\n+        unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n }\n \n@@ -841,15 +833,15 @@ impl Default for String {\n #[experimental = \"waiting on Show stabilization\"]\n impl fmt::Show for String {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_slice().fmt(f)\n+        (*self).fmt(f)\n     }\n }\n \n #[experimental = \"waiting on Hash stabilization\"]\n impl<H: hash::Writer> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n-        self.as_slice().hash(hasher)\n+        (*self).hash(hasher)\n     }\n }\n \n@@ -873,7 +865,7 @@ impl<'a> Add<&'a str, String> for String {\n impl ops::Slice<uint, str> for String {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a str {\n-        self.as_slice()\n+        unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n \n     #[inline]\n@@ -894,7 +886,9 @@ impl ops::Slice<uint, str> for String {\n \n #[experimental = \"waiting on Deref stabilization\"]\n impl ops::Deref<str> for String {\n-    fn deref<'a>(&'a self) -> &'a str { self.as_slice() }\n+    fn deref<'a>(&'a self) -> &'a str {\n+        unsafe { mem::transmute(self.vec[]) }\n+    }\n }\n \n /// Wrapper type providing a `&String` reference via `Deref`.\n@@ -1015,6 +1009,18 @@ pub mod raw {\n     }\n }\n \n+/// A clone-on-write string\n+#[stable]\n+pub type CowString<'a> = Cow<'a, String, str>;\n+\n+#[allow(deprecated)]\n+impl<'a> Str for CowString<'a> {\n+    #[inline]\n+    fn as_slice<'b>(&'b self) -> &'b str {\n+        (**self).as_slice()\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}, {"sha": "9ab450efd2272d86e61b469960adbf45cac6ae64", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -23,7 +23,7 @@ use num::cast;\n use ops::FnOnce;\n use result::Result::Ok;\n use slice::{mod, SliceExt};\n-use str::StrPrelude;\n+use str::StrExt;\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n pub enum ExponentFormat {"}, {"sha": "29815e2fc854221a786ebf07e081acddf2529207", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -24,7 +24,7 @@ use result::Result::{Ok, Err};\n use result;\n use slice::SliceExt;\n use slice;\n-use str::StrPrelude;\n+use str::{StrExt, Utf8Error};\n \n pub use self::num::radix;\n pub use self::num::Radix;\n@@ -795,5 +795,18 @@ impl<'b, T: Show> Show for RefMut<'b, T> {\n     }\n }\n \n+impl Show for Utf8Error {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        match *self {\n+            Utf8Error::InvalidByte(n) => {\n+                write!(f, \"invalid utf-8: invalid byte at index {}\", n)\n+            }\n+            Utf8Error::TooShort => {\n+                write!(f, \"invalid utf-8: byte slice too short\")\n+            }\n+        }\n+    }\n+}\n+\n // If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n // it's a lot easier than creating all of the rt::Piece structures here."}, {"sha": "60735879213d8cbfcfbe8e6e559178d1d2f1a07e", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -32,7 +32,7 @@ use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option;\n use option::Option::{Some, None};\n-use str::{FromStr, from_str, StrPrelude};\n+use str::{FromStr, from_str, StrExt};\n \n /// Simultaneous division and remainder\n #[inline]"}, {"sha": "f6abc8da79c0c9d1ddb6bbea9445d4f56a7f035b", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -60,7 +60,7 @@ pub use option::Option::{Some, None};\n pub use ptr::RawPtr;\n pub use result::Result;\n pub use result::Result::{Ok, Err};\n-pub use str::{Str, StrPrelude};\n+pub use str::{Str, StrExt};\n pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};"}, {"sha": "60d4262a9b12d485500ee1a1d276af155a3fe12f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 130, "deletions": 880, "changes": 1010, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -16,38 +16,38 @@\n \n #![doc(primitive = \"str\")]\n \n-pub use self::Utf16Item::*;\n-pub use self::Searcher::{Naive, TwoWay, TwoWayLong};\n+use self::Searcher::{Naive, TwoWay, TwoWayLong};\n \n-use char::Char;\n-use char;\n+use char::{mod, Char};\n use clone::Clone;\n-use cmp::{Eq, mod};\n+use cmp::{mod, Eq};\n use default::Default;\n-use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n-use iter::{DoubleEndedIteratorExt, ExactSizeIterator};\n use iter::range;\n-use kinds::Sized;\n+use iter::{DoubleEndedIteratorExt, ExactSizeIterator};\n+use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n+use kinds::{Copy, Sized};\n use mem;\n use num::Int;\n-use option::Option;\n-use option::Option::{None, Some};\n use ops::{Fn, FnMut};\n+use option::Option::{mod, None, Some};\n use ptr::RawPtr;\n use raw::{Repr, Slice};\n+use result::Result::{mod, Ok, Err};\n use slice::{mod, SliceExt};\n use uint;\n \n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n-#[experimental = \"might need to return Result\"]\n+// FIXME(#17307): there should be an `E` associated type for a `Result` return\n+#[unstable = \"will return a Result once associated types are working\"]\n pub trait FromStr {\n     /// Parses a string `s` to return an optional value of this type. If the\n     /// string is ill-formatted, the None is returned.\n     fn from_str(s: &str) -> Option<Self>;\n }\n \n /// A utility function that just calls FromStr::from_str\n+#[deprecated = \"call the .parse() method on the string instead\"]\n pub fn from_str<A: FromStr>(s: &str) -> Option<A> {\n     FromStr::from_str(s)\n }\n@@ -78,22 +78,38 @@ impl FromStr for bool {\n Section: Creating a string\n */\n \n-/// Converts a slice of bytes to a string slice without performing any allocations.\n+/// Errors which can occur when attempting to interpret a byte slice as a `str`.\n+pub enum Utf8Error {\n+    /// An invalid byte was detected at the byte offset given.\n+    ///\n+    /// The offset is guaranteed to be in bounds of the slice in question, and\n+    /// the byte at the specified offset was the first invalid byte in the\n+    /// sequence detected.\n+    InvalidByte(uint),\n+\n+    /// The byte slice was invalid because more bytes were needed but no more\n+    /// bytes were available.\n+    TooShort,\n+}\n+\n+/// Converts a slice of bytes to a string slice without performing any\n+/// allocations.\n ///\n /// Once the slice has been validated as utf-8, it is transmuted in-place and\n /// returned as a '&str' instead of a '&[u8]'\n ///\n-/// Returns None if the slice is not utf-8.\n-pub fn from_utf8<'a>(v: &'a [u8]) -> Option<&'a str> {\n-    if is_utf8(v) {\n-        Some(unsafe { from_utf8_unchecked(v) })\n-    } else {\n-        None\n-    }\n+/// # Failure\n+///\n+/// Returns `Err` if the slice is not utf-8 with a description as to why the\n+/// provided slice is not utf-8.\n+pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n+    try!(run_utf8_validation_iterator(&mut v.iter()));\n+    Ok(unsafe { from_utf8_unchecked(v) })\n }\n \n /// Converts a slice of bytes to a string slice without checking\n /// that the string contains valid UTF-8.\n+#[stable]\n pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n     mem::transmute(v)\n }\n@@ -111,17 +127,19 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n /// # Panics\n ///\n /// This function will panic if the string pointed to by `s` is not valid UTF-8.\n+#[unstable = \"may change location based on the outcome of the c_str module\"]\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n     let mut len = 0u;\n     while *s.offset(len as int) != 0 {\n         len += 1u;\n     }\n     let v: &'static [u8] = ::mem::transmute(Slice { data: s, len: len });\n-    from_utf8(v).expect(\"from_c_str passed invalid utf-8 data\")\n+    from_utf8(v).ok().expect(\"from_c_str passed invalid utf-8 data\")\n }\n \n /// Something that can be used to compare against a character\n+#[unstable = \"definition may change as pattern-related methods are stabilized\"]\n pub trait CharEq {\n     /// Determine if the splitter should split at the given character\n     fn matches(&mut self, char) -> bool;\n@@ -273,12 +291,12 @@ impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n /// External iterator for a string's characters and their byte offsets.\n /// Use with the `std::iter` module.\n #[deriving(Clone)]\n-pub struct CharOffsets<'a> {\n+pub struct CharIndices<'a> {\n     front_offset: uint,\n     iter: Chars<'a>,\n }\n \n-impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n+impl<'a> Iterator<(uint, char)> for CharIndices<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, char)> {\n         let (pre_len, _) = self.iter.iter.size_hint();\n@@ -299,7 +317,7 @@ impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n     }\n }\n \n-impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n+impl<'a> DoubleEndedIterator<(uint, char)> for CharIndices<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n         match self.iter.next_back() {\n@@ -315,13 +333,15 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n \n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n-pub type Bytes<'a> = Map<&'a u8, u8, slice::Items<'a, u8>, BytesFn>;\n+#[stable]\n+pub struct Bytes<'a> {\n+    inner: Map<&'a u8, u8, slice::Items<'a, u8>, BytesFn>,\n+}\n \n /// A temporary new type wrapper that ensures that the `Bytes` iterator\n /// is cloneable.\n #[deriving(Copy)]\n-#[experimental = \"iterator type instability\"]\n-pub struct BytesFn(fn(&u8) -> u8);\n+struct BytesFn(fn(&u8) -> u8);\n \n impl<'a> Fn(&'a u8) -> u8 for BytesFn {\n     extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n@@ -355,8 +375,17 @@ pub struct CharSplitsN<'a, Sep> {\n     invert: bool,\n }\n \n+/// An iterator over the lines of a string, separated by `\\n`.\n+#[stable]\n+pub struct Lines<'a> {\n+    inner: CharSplits<'a, char>,\n+}\n+\n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-pub type AnyLines<'a> = Map<&'a str, &'a str, CharSplits<'a, char>, fn(&str) -> &str>;\n+#[stable]\n+pub struct LinesAny<'a> {\n+    inner: Map<&'a str, &'a str, Lines<'a>, fn(&str) -> &str>,\n+}\n \n impl<'a, Sep> CharSplits<'a, Sep> {\n     #[inline]\n@@ -799,63 +828,6 @@ impl<'a> Iterator<&'a str> for StrSplits<'a> {\n     }\n }\n \n-/// External iterator for a string's UTF16 codeunits.\n-/// Use with the `std::iter` module.\n-#[deriving(Clone)]\n-pub struct Utf16CodeUnits<'a> {\n-    encoder: Utf16Encoder<Chars<'a>>\n-}\n-\n-impl<'a> Iterator<u16> for Utf16CodeUnits<'a> {\n-    #[inline]\n-    fn next(&mut self) -> Option<u16> { self.encoder.next() }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.encoder.size_hint() }\n-}\n-\n-\n-/// Iterator adaptor for encoding `char`s to UTF-16.\n-#[deriving(Clone)]\n-pub struct Utf16Encoder<I> {\n-    chars: I,\n-    extra: u16\n-}\n-\n-impl<I> Utf16Encoder<I> {\n-    /// Create an UTF-16 encoder from any `char` iterator.\n-    pub fn new(chars: I) -> Utf16Encoder<I> where I: Iterator<char> {\n-        Utf16Encoder { chars: chars, extra: 0 }\n-    }\n-}\n-\n-impl<I> Iterator<u16> for Utf16Encoder<I> where I: Iterator<char> {\n-    #[inline]\n-    fn next(&mut self) -> Option<u16> {\n-        if self.extra != 0 {\n-            let tmp = self.extra;\n-            self.extra = 0;\n-            return Some(tmp);\n-        }\n-\n-        let mut buf = [0u16, ..2];\n-        self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(buf[mut]).unwrap_or(0);\n-            if n == 2 { self.extra = buf[1]; }\n-            buf[0]\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let (low, high) = self.chars.size_hint();\n-        // every char gets either one u16 or two u16,\n-        // so this iterator is between 1 or 2 times as\n-        // long as the underlying iterator.\n-        (low, high.and_then(|n| n.checked_mul(2)))\n-    }\n-}\n-\n /*\n Section: Comparing strings\n */\n@@ -880,7 +852,7 @@ fn eq_slice_(a: &str, b: &str) -> bool {\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n #[lang=\"str_eq\"]\n #[inline]\n-pub fn eq_slice(a: &str, b: &str) -> bool {\n+fn eq_slice(a: &str, b: &str) -> bool {\n     eq_slice_(a, b)\n }\n \n@@ -893,32 +865,37 @@ Section: Misc\n /// `iter` reset such that it is pointing at the first byte in the\n /// invalid sequence.\n #[inline(always)]\n-fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n+fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>)\n+                                -> Result<(), Utf8Error> {\n+    let whole = iter.as_slice();\n     loop {\n         // save the current thing we're pointing at.\n         let old = *iter;\n \n         // restore the iterator we had at the start of this codepoint.\n-        macro_rules! err ( () => { {*iter = old; return false} });\n+        macro_rules! err (() => { {\n+            *iter = old;\n+            return Err(Utf8Error::InvalidByte(whole.len() - iter.as_slice().len()))\n+        } });\n         macro_rules! next ( () => {\n-                match iter.next() {\n-                    Some(a) => *a,\n-                    // we needed data, but there was none: error!\n-                    None => err!()\n-                }\n-            });\n+            match iter.next() {\n+                Some(a) => *a,\n+                // we needed data, but there was none: error!\n+                None => return Err(Utf8Error::TooShort),\n+            }\n+        });\n \n         let first = match iter.next() {\n             Some(&b) => b,\n             // we're at the end of the iterator and a codepoint\n             // boundary at the same time, so this string is valid.\n-            None => return true\n+            None => return Ok(())\n         };\n \n         // ASCII characters are always valid, so only large\n         // bytes need more examination.\n         if first >= 128 {\n-            let w = utf8_char_width(first);\n+            let w = UTF8_CHAR_WIDTH[first as uint] as uint;\n             let second = next!();\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n@@ -964,125 +941,9 @@ fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n }\n \n /// Determines if a vector of bytes contains valid UTF-8.\n+#[deprecated = \"call from_utf8 instead\"]\n pub fn is_utf8(v: &[u8]) -> bool {\n-    run_utf8_validation_iterator(&mut v.iter())\n-}\n-\n-/// Determines if a vector of `u16` contains valid UTF-16\n-pub fn is_utf16(v: &[u16]) -> bool {\n-    let mut it = v.iter();\n-    macro_rules! next ( ($ret:expr) => {\n-            match it.next() { Some(u) => *u, None => return $ret }\n-        }\n-    );\n-    loop {\n-        let u = next!(true);\n-\n-        match char::from_u32(u as u32) {\n-            Some(_) => {}\n-            None => {\n-                let u2 = next!(false);\n-                if u < 0xD7FF || u > 0xDBFF ||\n-                    u2 < 0xDC00 || u2 > 0xDFFF { return false; }\n-            }\n-        }\n-    }\n-}\n-\n-/// An iterator that decodes UTF-16 encoded codepoints from a vector\n-/// of `u16`s.\n-#[deriving(Clone)]\n-pub struct Utf16Items<'a> {\n-    iter: slice::Items<'a, u16>\n-}\n-/// The possibilities for values decoded from a `u16` stream.\n-#[deriving(Copy, PartialEq, Eq, Clone, Show)]\n-pub enum Utf16Item {\n-    /// A valid codepoint.\n-    ScalarValue(char),\n-    /// An invalid surrogate without its pair.\n-    LoneSurrogate(u16)\n-}\n-\n-impl Utf16Item {\n-    /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n-    /// replacement character (U+FFFD).\n-    #[inline]\n-    pub fn to_char_lossy(&self) -> char {\n-        match *self {\n-            ScalarValue(c) => c,\n-            LoneSurrogate(_) => '\\u{FFFD}'\n-        }\n-    }\n-}\n-\n-impl<'a> Iterator<Utf16Item> for Utf16Items<'a> {\n-    fn next(&mut self) -> Option<Utf16Item> {\n-        let u = match self.iter.next() {\n-            Some(u) => *u,\n-            None => return None\n-        };\n-\n-        if u < 0xD800 || 0xDFFF < u {\n-            // not a surrogate\n-            Some(ScalarValue(unsafe {mem::transmute(u as u32)}))\n-        } else if u >= 0xDC00 {\n-            // a trailing surrogate\n-            Some(LoneSurrogate(u))\n-        } else {\n-            // preserve state for rewinding.\n-            let old = self.iter;\n-\n-            let u2 = match self.iter.next() {\n-                Some(u2) => *u2,\n-                // eof\n-                None => return Some(LoneSurrogate(u))\n-            };\n-            if u2 < 0xDC00 || u2 > 0xDFFF {\n-                // not a trailing surrogate so we're not a valid\n-                // surrogate pair, so rewind to redecode u2 next time.\n-                self.iter = old;\n-                return Some(LoneSurrogate(u))\n-            }\n-\n-            // all ok, so lets decode it.\n-            let c = ((u - 0xD800) as u32 << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n-            Some(ScalarValue(unsafe {mem::transmute(c)}))\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let (low, high) = self.iter.size_hint();\n-        // we could be entirely valid surrogates (2 elements per\n-        // char), or entirely non-surrogates (1 element per char)\n-        (low / 2, high)\n-    }\n-}\n-\n-/// Create an iterator over the UTF-16 encoded codepoints in `v`,\n-/// returning invalid surrogates as `LoneSurrogate`s.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-/// use std::str::{ScalarValue, LoneSurrogate};\n-///\n-/// // \ud834\udd1emus<invalid>ic<invalid>\n-/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///          0x0073, 0xDD1E, 0x0069, 0x0063,\n-///          0xD834];\n-///\n-/// assert_eq!(str::utf16_items(&v).collect::<Vec<_>>(),\n-///            vec![ScalarValue('\ud834\udd1e'),\n-///                 ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n-///                 LoneSurrogate(0xDD1E),\n-///                 ScalarValue('i'), ScalarValue('c'),\n-///                 LoneSurrogate(0xD834)]);\n-/// ```\n-pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n-    Utf16Items { iter : v.iter() }\n+    run_utf8_validation_iterator(&mut v.iter()).is_ok()\n }\n \n /// Return a slice of `v` ending at (and not including) the first NUL\n@@ -1103,6 +964,7 @@ pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n /// let b: &[_] = &['a' as u16, 'b' as u16];\n /// assert_eq!(str::truncate_utf16_at_nul(&v), b);\n /// ```\n+#[deprecated = \"this function will be removed\"]\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n         // don't include the 0\n@@ -1133,6 +995,7 @@ static UTF8_CHAR_WIDTH: [u8, ..256] = [\n \n /// Given a first byte, determine how many bytes are in this UTF-8 character\n #[inline]\n+#[deprecated = \"this function has moved to libunicode\"]\n pub fn utf8_char_width(b: u8) -> uint {\n     return UTF8_CHAR_WIDTH[b as uint] as uint;\n }\n@@ -1141,6 +1004,7 @@ pub fn utf8_char_width(b: u8) -> uint {\n /// the next `char` in a string.  This can be used as a data structure\n /// for iterating over the UTF-8 bytes of a string.\n #[deriving(Copy)]\n+#[unstable = \"naming is uncertain with container conventions\"]\n pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n@@ -1159,7 +1023,7 @@ pub mod raw {\n     use ptr::RawPtr;\n     use raw::Slice;\n     use slice::SliceExt;\n-    use str::{is_utf8, StrPrelude};\n+    use str::StrExt;\n \n     /// Converts a slice of bytes to a string slice without checking\n     /// that the string contains valid UTF-8.\n@@ -1181,8 +1045,7 @@ pub mod raw {\n             curr = s.offset(len as int);\n         }\n         let v = Slice { data: s, len: len };\n-        assert!(is_utf8(::mem::transmute(v)));\n-        ::mem::transmute(v)\n+        super::from_utf8(::mem::transmute(v)).unwrap()\n     }\n \n     /// Takes a bytewise (not UTF-8) slice from a string.\n@@ -1225,7 +1088,7 @@ pub mod traits {\n     use option::Option;\n     use option::Option::Some;\n     use ops;\n-    use str::{Str, StrPrelude, eq_slice};\n+    use str::{Str, StrExt, eq_slice};\n \n     impl Ord for str {\n         #[inline]\n@@ -1291,707 +1154,70 @@ pub mod traits {\n }\n \n /// Any string that can be represented as a slice\n+#[unstable = \"Instead of taking this bound generically, this trait will be \\\n+              replaced with one of slicing syntax, deref coercions, or \\\n+              a more generic conversion trait\"]\n pub trait Str for Sized? {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a str;\n }\n \n+#[allow(deprecated)]\n impl Str for str {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str { self }\n }\n \n+#[allow(deprecated)]\n impl<'a, Sized? S> Str for &'a S where S: Str {\n     #[inline]\n     fn as_slice(&self) -> &str { Str::as_slice(*self) }\n }\n \n /// Methods for string slices\n-pub trait StrPrelude for Sized? {\n-    /// Returns true if one string contains another\n-    ///\n-    /// # Arguments\n-    ///\n-    /// - needle - The string to look for\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\"bananas\".contains(\"nana\"));\n-    /// ```\n-    fn contains(&self, needle: &str) -> bool;\n+#[allow(missing_docs)]\n+pub trait StrExt for Sized? {\n+    // NB there are no docs here are they're all located on the StrExt trait in\n+    // libcollections, not here.\n \n-    /// Returns true if a string contains a char.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// - needle - The char to look for\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\"hello\".contains_char('e'));\n-    /// ```\n+    fn contains(&self, needle: &str) -> bool;\n     fn contains_char(&self, needle: char) -> bool;\n-\n-    /// An iterator over the characters of `self`. Note, this iterates\n-    /// over Unicode code-points, not Unicode graphemes.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n-    /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n-    /// ```\n     fn chars<'a>(&'a self) -> Chars<'a>;\n-\n-    /// An iterator over the bytes of `self`\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: Vec<u8> = \"bors\".bytes().collect();\n-    /// assert_eq!(v, b\"bors\".to_vec());\n-    /// ```\n     fn bytes<'a>(&'a self) -> Bytes<'a>;\n-\n-    /// An iterator over the characters of `self` and their byte offsets.\n-    fn char_indices<'a>(&'a self) -> CharOffsets<'a>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|&: c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, vec![\"lion\", \"\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".split('X').collect();\n-    /// assert_eq!(v, vec![\"\"]);\n-    /// # }\n-    /// ```\n+    fn char_indices<'a>(&'a self) -> CharIndices<'a>;\n     fn split<'a, Sep: CharEq>(&'a self, sep: Sep) -> CharSplits<'a, Sep>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, restricted to splitting at most `count`\n-    /// times.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n-    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |&: c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n-    /// assert_eq!(v, vec![\"lion\", \"\", \"tigerXleopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn(0, 'X').collect();\n-    /// assert_eq!(v, vec![\"abcXdef\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, vec![\"\"]);\n-    /// # }\n-    /// ```\n     fn splitn<'a, Sep: CharEq>(&'a self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`.\n-    ///\n-    /// Equivalent to `split`, except that the trailing substring\n-    /// is skipped if empty (terminator semantics).\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, vec![\"A\", \"B\"]);\n-    ///\n-    /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n-    /// assert_eq!(v, vec![\"A\", \"\", \"B\", \"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').rev().collect();\n-    /// assert_eq!(v, vec![\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|&: c: char| c.is_numeric()).rev().collect();\n-    /// assert_eq!(v, vec![\"ghi\", \"def\", \"abc\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n-    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n-    /// # }\n-    /// ```\n     fn split_terminator<'a, Sep: CharEq>(&'a self, sep: Sep) -> CharSplits<'a, Sep>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, starting from the end of the string.\n-    /// Restricted to splitting at most `count` times.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n-    /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |&: c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n-    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n-    /// # }\n-    /// ```\n     fn rsplitn<'a, Sep: CharEq>(&'a self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n-\n-    /// An iterator over the start and end indices of the disjoint\n-    /// matches of `sep` within `self`.\n-    ///\n-    /// That is, each returned value `(start, end)` satisfies\n-    /// `self.slice(start, end) == sep`. For matches of `sep` within\n-    /// `self` that overlap, only the indices corresponding to the\n-    /// first match are returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: Vec<(uint, uint)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, vec![(0,3), (6,9), (12,15)]);\n-    ///\n-    /// let v: Vec<(uint, uint)> = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, vec![(1,4), (4,7)]);\n-    ///\n-    /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n-    /// ```\n     fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a>;\n-\n-    /// An iterator over the substrings of `self` separated by `sep`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, vec![\"\", \"XXX\", \"YYY\", \"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n-    /// ```\n     fn split_str<'a>(&'a self, &'a str) -> StrSplits<'a>;\n-\n-    /// An iterator over the lines of a string (subsequences separated\n-    /// by `\\n`). This does not include the empty string after a\n-    /// trailing `\\n`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n-    /// let v: Vec<&str> = four_lines.lines().collect();\n-    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    fn lines<'a>(&'a self) -> CharSplits<'a, char>;\n-\n-    /// An iterator over the lines of a string, separated by either\n-    /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n-    /// empty trailing line.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n-    /// let v: Vec<&str> = four_lines.lines_any().collect();\n-    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    fn lines_any<'a>(&'a self) -> AnyLines<'a>;\n-\n-    /// Returns the number of Unicode code points (`char`) that a\n-    /// string holds.\n-    ///\n-    /// This does not perform any normalization, and is `O(n)`, since\n-    /// UTF-8 is a variable width encoding of code points.\n-    ///\n-    /// *Warning*: The number of code points in a string does not directly\n-    /// correspond to the number of visible characters or width of the\n-    /// visible text due to composing characters, and double- and\n-    /// zero-width ones.\n-    ///\n-    /// See also `.len()` for the byte length.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// // composed forms of `\u00f6` and `\u00e9`\n-    /// let c = \"L\u00f6we \u8001\u864e L\u00e9opard\"; // German, Simplified Chinese, French\n-    /// // decomposed forms of `\u00f6` and `\u00e9`\n-    /// let d = \"Lo\\u{0308}we \u8001\u864e Le\\u{0301}opard\";\n-    ///\n-    /// assert_eq!(c.char_len(), 15);\n-    /// assert_eq!(d.char_len(), 17);\n-    ///\n-    /// assert_eq!(c.len(), 21);\n-    /// assert_eq!(d.len(), 23);\n-    ///\n-    /// // the two strings *look* the same\n-    /// println!(\"{}\", c);\n-    /// println!(\"{}\", d);\n-    /// ```\n+    fn lines<'a>(&'a self) -> Lines<'a>;\n+    fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n     fn char_len(&self) -> uint;\n-\n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Panics when `begin` and `end` do not point to valid characters\n-    /// or point beyond the last character of the string.\n-    ///\n-    /// See also `slice_to` and `slice_from` for slicing prefixes and\n-    /// suffixes of strings, and `slice_chars` for slicing based on\n-    /// code point counts.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(s.slice(0, 1), \"L\");\n-    ///\n-    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n-    ///\n-    /// // these will panic:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // s.slice(2, 3);\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // s.slice(1, 8);\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // s.slice(3, 100);\n-    /// ```\n     fn slice<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-\n-    /// Returns a slice of the string from `begin` to its end.\n-    ///\n-    /// Equivalent to `self.slice(begin, self.len())`.\n-    ///\n-    /// Panics when `begin` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_to` and `slice_chars`.\n     fn slice_from<'a>(&'a self, begin: uint) -> &'a str;\n-\n-    /// Returns a slice of the string from the beginning to byte\n-    /// `end`.\n-    ///\n-    /// Equivalent to `self.slice(0, end)`.\n-    ///\n-    /// Panics when `end` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_from` and `slice_chars`.\n     fn slice_to<'a>(&'a self, end: uint) -> &'a str;\n-\n-    /// Returns a slice of the string from the character range\n-    /// [`begin`..`end`).\n-    ///\n-    /// That is, start at the `begin`-th code point of the string and\n-    /// continue to the `end`-th code point. This does not detect or\n-    /// handle edge cases such as leaving a combining character as the\n-    /// first code point of the string.\n-    ///\n-    /// Due to the design of UTF-8, this operation is `O(end)`.\n-    /// See `slice`, `slice_to` and `slice_from` for `O(1)`\n-    /// variants that use byte indices rather than code point\n-    /// indices.\n-    ///\n-    /// Panics if `begin` > `end` or the either `begin` or `end` are\n-    /// beyond the last character of the string.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n-    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n-    /// ```\n     fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-\n-    /// Takes a bytewise (not UTF-8) slice from a string.\n-    ///\n-    /// Returns the substring from [`begin`..`end`).\n-    ///\n-    /// Caller must check both UTF-8 character boundaries and the boundaries of\n-    /// the entire slice as well.\n     unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-\n-    /// Returns true if `needle` is a prefix of the string.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\"banana\".starts_with(\"ba\"));\n-    /// ```\n     fn starts_with(&self, needle: &str) -> bool;\n-\n-    /// Returns true if `needle` is a suffix of the string.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\"banana\".ends_with(\"nana\"));\n-    /// ```\n     fn ends_with(&self, needle: &str) -> bool;\n-\n-    /// Returns a string with characters that match `to_trim` removed from the left and the right.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(|&: c: char| c.is_numeric()), \"foo1bar\");\n-    /// # }\n-    /// ```\n     fn trim_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n-\n-    /// Returns a string with leading `chars_to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\");\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|&: c: char| c.is_numeric()), \"foo1bar123\");\n-    /// # }\n-    /// ```\n     fn trim_left_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n-\n-    /// Returns a string with trailing `chars_to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|&: c: char| c.is_numeric()), \"123foo1bar\");\n-    /// # }\n-    /// ```\n     fn trim_right_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n-\n-    /// Check that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n-    ///\n-    /// The start and end of the string (when `index == self.len()`)\n-    /// are considered to be boundaries.\n-    ///\n-    /// Panics if `index` is greater than `self.len()`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert!(s.is_char_boundary(0));\n-    /// // start of `\u8001`\n-    /// assert!(s.is_char_boundary(6));\n-    /// assert!(s.is_char_boundary(s.len()));\n-    ///\n-    /// // second byte of `\u00f6`\n-    /// assert!(!s.is_char_boundary(2));\n-    ///\n-    /// // third byte of `\u8001`\n-    /// assert!(!s.is_char_boundary(8));\n-    /// ```\n     fn is_char_boundary(&self, index: uint) -> bool;\n-\n-    /// Pluck a character out of a string and return the index of the next\n-    /// character.\n-    ///\n-    /// This function can be used to iterate over the Unicode characters of a\n-    /// string.\n-    ///\n-    /// # Example\n-    ///\n-    /// This example manually iterates through the characters of a\n-    /// string; this should normally be done by `.chars()` or\n-    /// `.char_indices`.\n-    ///\n-    /// ```rust\n-    /// use std::str::CharRange;\n-    ///\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-    /// let mut i = 0u;\n-    /// while i < s.len() {\n-    ///     let CharRange {ch, next} = s.char_range_at(i);\n-    ///     println!(\"{}: {}\", i, ch);\n-    ///     i = next;\n-    /// }\n-    /// ```\n-    ///\n-    /// This outputs:\n-    ///\n-    /// ```text\n-    /// 0: \u4e2d\n-    /// 3: \u534e\n-    /// 6: V\n-    /// 7: i\n-    /// 8: \u1ec7\n-    /// 11: t\n-    /// 12:\n-    /// 13: N\n-    /// 14: a\n-    /// 15: m\n-    /// ```\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - The string\n-    /// * i - The byte offset of the char to extract\n-    ///\n-    /// # Return value\n-    ///\n-    /// A record {ch: char, next: uint} containing the char value and the byte\n-    /// index of the next Unicode character.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     fn char_range_at(&self, start: uint) -> CharRange;\n-\n-    /// Given a byte position and a str, return the previous char and its position.\n-    ///\n-    /// This function can be used to iterate over a Unicode string in reverse.\n-    ///\n-    /// Returns 0 for next index if called on start index 0.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 character.\n     fn char_range_at_reverse(&self, start: uint) -> CharRange;\n-\n-    /// Plucks the character starting at the `i`th byte of a string.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"ab\u03c0c\";\n-    /// assert_eq!(s.char_at(1), 'b');\n-    /// assert_eq!(s.char_at(2), '\u03c0');\n-    /// assert_eq!(s.char_at(4), 'c');\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     fn char_at(&self, i: uint) -> char;\n-\n-    /// Plucks the character ending at the `i`th byte of a string.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 character.\n     fn char_at_reverse(&self, i: uint) -> char;\n-\n-    /// Work with the byte buffer of a string as a byte slice.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n-    /// ```\n     fn as_bytes<'a>(&'a self) -> &'a [u8];\n-\n-    /// Returns the byte index of the first character of `self` that\n-    /// matches `search`.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find('L'), Some(0));\n-    /// assert_eq!(s.find('\u00e9'), Some(14));\n-    ///\n-    /// // the first space\n-    /// assert_eq!(s.find(|&: c: char| c.is_whitespace()), Some(5));\n-    ///\n-    /// // neither are found\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(s.find(x), None);\n-    /// # }\n-    /// ```\n     fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n-\n-    /// Returns the byte index of the last character of `self` that\n-    /// matches `search`.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![feature(unboxed_closures)]\n-    ///\n-    /// # fn main() {\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind('L'), Some(13));\n-    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n-    ///\n-    /// // the second space\n-    /// assert_eq!(s.rfind(|&: c: char| c.is_whitespace()), Some(12));\n-    ///\n-    /// // searches for an occurrence of either `1` or `2`, but neither are found\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(s.rfind(x), None);\n-    /// # }\n-    /// ```\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n-\n-    /// Returns the byte index of the first matching substring\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * `needle` - The string to search for\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the first matching substring\n-    /// or `None` if there is no match.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n-    /// assert_eq!(s.find_str(\"muffin man\"), None);\n-    /// ```\n     fn find_str(&self, &str) -> Option<uint>;\n-\n-    /// Retrieves the first character from a string slice and returns\n-    /// it. This does not allocate a new string; instead, it returns a\n-    /// slice that point one character beyond the character that was\n-    /// shifted. If the string does not contain any characters,\n-    /// None is returned instead.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let (c, s1) = s.slice_shift_char().unwrap();\n-    /// assert_eq!(c, 'L');\n-    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n-    ///\n-    /// let (c, s2) = s1.slice_shift_char().unwrap();\n-    /// assert_eq!(c, '\u00f6');\n-    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n-    /// ```\n     fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n-\n-    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n-    ///\n-    /// Panics if `inner` is not a direct slice contained within self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let string = \"a\\nb\\nc\";\n-    /// let lines: Vec<&str> = string.lines().collect();\n-    ///\n-    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n-    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n-    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n-    /// ```\n     fn subslice_offset(&self, inner: &str) -> uint;\n-\n-    /// Return an unsafe pointer to the strings buffer.\n-    ///\n-    /// The caller must ensure that the string outlives this pointer,\n-    /// and that it is not reallocated (e.g. by pushing to the\n-    /// string).\n     fn as_ptr(&self) -> *const u8;\n-\n-    /// Return an iterator of `u16` over the string encoded as UTF-16.\n-    fn utf16_units<'a>(&'a self) -> Utf16CodeUnits<'a>;\n-\n-    /// Return the number of bytes in this string\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// assert_eq!(\"foo\".len(), 3);\n-    /// assert_eq!(\"\u0192oo\".len(), 4);\n-    /// ```\n-    #[experimental = \"not triaged yet\"]\n     fn len(&self) -> uint;\n-\n-    /// Returns true if this slice contains no bytes\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// assert!(\"\".is_empty());\n-    /// ```\n-    #[inline]\n-    #[experimental = \"not triaged yet\"]\n-    fn is_empty(&self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool;\n }\n \n #[inline(never)]\n@@ -2001,7 +1227,7 @@ fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n           begin, end, s);\n }\n \n-impl StrPrelude for str {\n+impl StrExt for str {\n     #[inline]\n     fn contains(&self, needle: &str) -> bool {\n         self.find_str(needle).is_some()\n@@ -2021,12 +1247,12 @@ impl StrPrelude for str {\n     fn bytes(&self) -> Bytes {\n         fn deref(&x: &u8) -> u8 { x }\n \n-        self.as_bytes().iter().map(BytesFn(deref))\n+        Bytes { inner: self.as_bytes().iter().map(BytesFn(deref)) }\n     }\n \n     #[inline]\n-    fn char_indices(&self) -> CharOffsets {\n-        CharOffsets{front_offset: 0, iter: self.chars()}\n+    fn char_indices(&self) -> CharIndices {\n+        CharIndices { front_offset: 0, iter: self.chars() }\n     }\n \n     #[inline]\n@@ -2089,18 +1315,18 @@ impl StrPrelude for str {\n     }\n \n     #[inline]\n-    fn lines(&self) -> CharSplits<char> {\n-        self.split_terminator('\\n')\n+    fn lines(&self) -> Lines {\n+        Lines { inner: self.split_terminator('\\n') }\n     }\n \n-    fn lines_any(&self) -> AnyLines {\n+    fn lines_any(&self) -> LinesAny {\n         fn f(line: &str) -> &str {\n             let l = line.len();\n             if l > 0 && line.as_bytes()[l - 1] == b'\\r' { line.slice(0, l - 1) }\n             else { line }\n         }\n \n-        self.lines().map(f)\n+        LinesAny { inner: self.lines().map(f) }\n     }\n \n     #[inline]\n@@ -2353,12 +1579,10 @@ impl StrPrelude for str {\n     }\n \n     #[inline]\n-    fn utf16_units(&self) -> Utf16CodeUnits {\n-        Utf16CodeUnits { encoder: Utf16Encoder::new(self.chars()) }\n-    }\n+    fn len(&self) -> uint { self.repr().len }\n \n     #[inline]\n-    fn len(&self) -> uint { self.repr().len }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n #[stable]\n@@ -2367,3 +1591,29 @@ impl<'a> Default for &'a str {\n     fn default() -> &'a str { \"\" }\n }\n \n+\n+impl<'a> Iterator<&'a str> for Lines<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n+}\n+impl<'a> DoubleEndedIterator<&'a str> for Lines<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n+}\n+impl<'a> Iterator<&'a str> for LinesAny<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n+}\n+impl<'a> DoubleEndedIterator<&'a str> for LinesAny<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n+}\n+impl<'a> Iterator<u8> for Bytes<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> { self.inner.next() }\n+}\n+impl<'a> DoubleEndedIterator<u8> for Bytes<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<u8> { self.inner.next_back() }\n+}\n+impl<'a> ExactSizeIterator<u8> for Bytes<'a> {}"}, {"sha": "4a1dd121516de39193451d816287f6f411c41710", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -115,6 +115,7 @@ pub mod util {\n     pub mod ppaux;\n     pub mod nodemap;\n     pub mod snapshot_vec;\n+    pub mod lev_distance;\n }\n \n pub mod lib {"}, {"sha": "24e9883744407b9ebb698e2caa6f4f6a8278cdda", "filename": "src/librustc/util/lev_distance.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp;\n+\n+pub fn lev_distance(me: &str, t: &str) -> uint {\n+    if me.is_empty() { return t.chars().count(); }\n+    if t.is_empty() { return me.chars().count(); }\n+\n+    let mut dcol = Vec::from_fn(t.len() + 1, |x| x);\n+    let mut t_last = 0;\n+\n+    for (i, sc) in me.chars().enumerate() {\n+\n+        let mut current = i;\n+        dcol[0] = current + 1;\n+\n+        for (j, tc) in t.chars().enumerate() {\n+\n+            let next = dcol[j + 1];\n+\n+            if sc == tc {\n+                dcol[j + 1] = current;\n+            } else {\n+                dcol[j + 1] = cmp::min(current, next);\n+                dcol[j + 1] = cmp::min(dcol[j + 1], dcol[j]) + 1;\n+            }\n+\n+            current = next;\n+            t_last = j;\n+        }\n+    }\n+\n+    dcol[t_last + 1]\n+}\n+\n+#[test]\n+fn test_lev_distance() {\n+    use std::char::{ from_u32, MAX };\n+    // Test bytelength agnosticity\n+    for c in range(0u32, MAX as u32)\n+             .filter_map(|i| from_u32(i))\n+             .map(|i| String::from_char(1, i)) {\n+        assert_eq!(lev_distance(c[], c[]), 0);\n+    }\n+\n+    let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    assert_eq!(lev_distance(a, b), 1);\n+    assert_eq!(lev_distance(b, a), 1);\n+    assert_eq!(lev_distance(a, c), 2);\n+    assert_eq!(lev_distance(c, a), 2);\n+    assert_eq!(lev_distance(b, c), 1);\n+    assert_eq!(lev_distance(c, b), 1);\n+}"}, {"sha": "d4a0b49436dd7644c66a27eb622e5179b0ea9f99", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -57,6 +57,7 @@ use rustc::middle::privacy::*;\n use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::middle::ty::{CaptureModeMap, Freevar, FreevarMap, TraitMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n+use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DeclItem, DefId, Expr, ExprAgain, ExprBreak, ExprField};\n@@ -96,8 +97,8 @@ use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::uint;\n \n-mod check_unused;\n-mod record_exports;\n+// Definition mapping\n+pub type DefMap = RefCell<NodeMap<Def>>;\n \n #[deriving(Copy)]\n struct BindingInfo {\n@@ -5539,7 +5540,7 @@ impl<'a> Resolver<'a> {\n \n         let mut smallest = 0;\n         for (i, other) in maybes.iter().enumerate() {\n-            values[i] = name.lev_distance(other.get());\n+            values[i] = lev_distance(name, other.get());\n \n             if values[i] <= values[smallest] {\n                 smallest = i;"}, {"sha": "cd7d9aacc90109bb8a33d2d1f6852d37bd4a40a5", "filename": "src/libstd/error.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -78,10 +78,9 @@\n //! }\n //! ```\n \n-use option::Option;\n-use option::Option::None;\n-use kinds::Send;\n-use string::String;\n+use prelude::*;\n+\n+use str::Utf8Error;\n \n /// Base functionality for all errors in Rust.\n pub trait Error: Send {\n@@ -107,3 +106,14 @@ impl<E> FromError<E> for E {\n         err\n     }\n }\n+\n+impl Error for Utf8Error {\n+    fn description(&self) -> &str {\n+        match *self {\n+            Utf8Error::TooShort => \"invalid utf-8: not enough bytes\",\n+            Utf8Error::InvalidByte(..) => \"invalid utf-8: corrupt contents\",\n+        }\n+    }\n+\n+    fn detail(&self) -> Option<String> { Some(self.to_string()) }\n+}"}, {"sha": "a16ee982f5c06615512a13b463373c7c03c691e2", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -729,7 +729,7 @@ fn real_args() -> Vec<String> {\n         // Push it onto the list.\n         let ptr = ptr as *const u16;\n         let buf = slice::from_raw_buf(&ptr, len);\n-        let opt_s = String::from_utf16(::str::truncate_utf16_at_nul(buf));\n+        let opt_s = String::from_utf16(os_imp::truncate_utf16_at_nul(buf));\n         opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\")\n     });\n "}, {"sha": "e1016048e58c3e539c1d07a828dca874a2846668", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -31,6 +31,16 @@ use libc::types::os::arch::extra::DWORD;\n \n const BUF_BYTES : uint = 2048u;\n \n+/// Return a slice of `v` ending at (and not including) the first NUL\n+/// (0).\n+pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n+    match v.iter().position(|c| *c == 0) {\n+        // don't include the 0\n+        Some(i) => v[..i],\n+        None => v\n+    }\n+}\n+\n pub fn errno() -> uint {\n     use libc::types::os::arch::extra::DWORD;\n \n@@ -87,7 +97,7 @@ pub fn error_string(errnum: i32) -> String {\n             return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n         }\n \n-        let msg = String::from_utf16(::str::truncate_utf16_at_nul(&buf));\n+        let msg = String::from_utf16(truncate_utf16_at_nul(&buf));\n         match msg {\n             Some(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n             None => format!(\"OS Error {} (FormatMessageW() returned invalid UTF-16)\", errnum),\n@@ -294,3 +304,30 @@ pub fn page_size() -> uint {\n         return info.dwPageSize as uint;\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::truncate_utf16_at_nul;\n+\n+    #[test]\n+    fn test_truncate_utf16_at_nul() {\n+        let v = [];\n+        let b: &[u16] = &[];\n+        assert_eq!(truncate_utf16_at_nul(&v), b);\n+\n+        let v = [0, 2, 3];\n+        assert_eq!(truncate_utf16_at_nul(&v), b);\n+\n+        let v = [1, 0, 3];\n+        let b: &[u16] = &[1];\n+        assert_eq!(truncate_utf16_at_nul(&v), b);\n+\n+        let v = [1, 2, 0];\n+        let b: &[u16] = &[1, 2];\n+        assert_eq!(truncate_utf16_at_nul(&v), b);\n+\n+        let v = [1, 2, 3];\n+        let b: &[u16] = &[1, 2, 3];\n+        assert_eq!(truncate_utf16_at_nul(&v), b);\n+    }\n+}"}, {"sha": "d33362ec232952648921833ef015678deb7b2090", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -28,8 +28,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![no_std]\n-#![feature(globs)]\n-#![feature(unboxed_closures)]\n+#![feature(globs, macro_rules, slicing_syntax, unboxed_closures)]\n \n extern crate core;\n \n@@ -74,11 +73,14 @@ pub mod char {\n }\n \n pub mod str {\n-    pub use u_str::{UnicodeStrPrelude, Words, Graphemes, GraphemeIndices};\n+    pub use u_str::{UnicodeStr, Words, Graphemes, GraphemeIndices};\n+    pub use u_str::{utf8_char_width, is_utf16, Utf16Items, Utf16Item};\n+    pub use u_str::{utf16_items, Utf16Encoder};\n }\n \n-// this lets us use #[deriving(Clone)]\n+// this lets us use #[deriving(..)]\n mod std {\n     pub use core::clone;\n     pub use core::cmp;\n+    pub use core::fmt;\n }"}, {"sha": "5d7d2951628255ac1f2466368416dc1fd67724f6", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 214, "deletions": 8, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4908017d59da8694b9ceaf743baf1163c1e19086/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=4908017d59da8694b9ceaf743baf1163c1e19086", "patch": "@@ -15,24 +15,36 @@\n //! This module provides functionality to `str` that requires the Unicode methods provided by the\n //! UnicodeChar trait.\n \n-use self::GraphemeState::*;\n+use core::prelude::*;\n+\n+use core::char;\n use core::cmp;\n-use core::slice::SliceExt;\n-use core::iter::{Filter, AdditiveIterator, Iterator, IteratorExt};\n use core::iter::{DoubleEndedIterator, DoubleEndedIteratorExt};\n+use core::iter::{Filter, AdditiveIterator, Iterator, IteratorExt};\n+use core::iter::{Filter, AdditiveIterator};\n use core::kinds::Sized;\n-use core::option::Option;\n+use core::mem;\n+use core::num::Int;\n use core::option::Option::{None, Some};\n+use core::option::Option;\n+use core::slice::SliceExt;\n+use core::slice;\n use core::str::{CharSplits, StrPrelude};\n+use core::str::{CharSplits};\n+\n use u_char::UnicodeChar;\n use tables::grapheme::GraphemeCat;\n \n /// An iterator over the words of a string, separated by a sequence of whitespace\n /// FIXME: This should be opaque\n-pub type Words<'a> = Filter<&'a str, CharSplits<'a, fn(char) -> bool>, fn(&&str) -> bool>;\n+#[stable]\n+pub struct Words<'a> {\n+    inner: Filter<'a, &'a str, CharSplits<'a, |char|:'a -> bool>,\n+                  fn(&&str) -> bool>,\n+}\n \n /// Methods for Unicode string slices\n-pub trait UnicodeStrPrelude for Sized? {\n+pub trait UnicodeStr for Sized? {\n     /// Returns an iterator over the\n     /// [grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n     /// of the string.\n@@ -77,6 +89,7 @@ pub trait UnicodeStrPrelude for Sized? {\n     /// let v: Vec<&str> = some_words.words().collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n+    #[stable]\n     fn words<'a>(&'a self) -> Words<'a>;\n \n     /// Returns true if the string contains only whitespace.\n@@ -129,7 +142,7 @@ pub trait UnicodeStrPrelude for Sized? {\n     fn trim_right<'a>(&'a self) -> &'a str;\n }\n \n-impl UnicodeStrPrelude for str {\n+impl UnicodeStr for str {\n     #[inline]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n         Graphemes { string: self, extended: is_extended, cat: None, catb: None }\n@@ -145,7 +158,7 @@ impl UnicodeStrPrelude for str {\n         fn is_not_empty(s: &&str) -> bool { !s.is_empty() }\n         fn is_whitespace(c: char) -> bool { c.is_whitespace() }\n \n-        self.split(is_whitespace).filter(is_not_empty)\n+        Words { inner: self.split(is_whitespace).filter(is_not_empty) }\n     }\n \n     #[inline]\n@@ -428,3 +441,196 @@ impl<'a> DoubleEndedIterator<&'a str> for Graphemes<'a> {\n         Some(retstr)\n     }\n }\n+\n+// https://tools.ietf.org/html/rfc3629\n+static UTF8_CHAR_WIDTH: [u8, ..256] = [\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x1F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x3F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x5F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x7F\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0x9F\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0xBF\n+0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0xDF\n+3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, // 0xEF\n+4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0, // 0xFF\n+];\n+\n+/// Given a first byte, determine how many bytes are in this UTF-8 character\n+#[inline]\n+pub fn utf8_char_width(b: u8) -> uint {\n+    return UTF8_CHAR_WIDTH[b as uint] as uint;\n+}\n+\n+/// Determines if a vector of `u16` contains valid UTF-16\n+pub fn is_utf16(v: &[u16]) -> bool {\n+    let mut it = v.iter();\n+    macro_rules! next ( ($ret:expr) => {\n+            match it.next() { Some(u) => *u, None => return $ret }\n+        }\n+    )\n+    loop {\n+        let u = next!(true);\n+\n+        match char::from_u32(u as u32) {\n+            Some(_) => {}\n+            None => {\n+                let u2 = next!(false);\n+                if u < 0xD7FF || u > 0xDBFF ||\n+                    u2 < 0xDC00 || u2 > 0xDFFF { return false; }\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator that decodes UTF-16 encoded codepoints from a vector\n+/// of `u16`s.\n+#[deriving(Clone)]\n+pub struct Utf16Items<'a> {\n+    iter: slice::Items<'a, u16>\n+}\n+/// The possibilities for values decoded from a `u16` stream.\n+#[deriving(PartialEq, Eq, Clone, Show)]\n+pub enum Utf16Item {\n+    /// A valid codepoint.\n+    ScalarValue(char),\n+    /// An invalid surrogate without its pair.\n+    LoneSurrogate(u16)\n+}\n+\n+impl Copy for Utf16Item {}\n+\n+impl Utf16Item {\n+    /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n+    /// replacement character (U+FFFD).\n+    #[inline]\n+    pub fn to_char_lossy(&self) -> char {\n+        match *self {\n+            Utf16Item::ScalarValue(c) => c,\n+            Utf16Item::LoneSurrogate(_) => '\\uFFFD'\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator<Utf16Item> for Utf16Items<'a> {\n+    fn next(&mut self) -> Option<Utf16Item> {\n+        let u = match self.iter.next() {\n+            Some(u) => *u,\n+            None => return None\n+        };\n+\n+        if u < 0xD800 || 0xDFFF < u {\n+            // not a surrogate\n+            Some(Utf16Item::ScalarValue(unsafe {mem::transmute(u as u32)}))\n+        } else if u >= 0xDC00 {\n+            // a trailing surrogate\n+            Some(Utf16Item::LoneSurrogate(u))\n+        } else {\n+            // preserve state for rewinding.\n+            let old = self.iter;\n+\n+            let u2 = match self.iter.next() {\n+                Some(u2) => *u2,\n+                // eof\n+                None => return Some(Utf16Item::LoneSurrogate(u))\n+            };\n+            if u2 < 0xDC00 || u2 > 0xDFFF {\n+                // not a trailing surrogate so we're not a valid\n+                // surrogate pair, so rewind to redecode u2 next time.\n+                self.iter = old;\n+                return Some(Utf16Item::LoneSurrogate(u))\n+            }\n+\n+            // all ok, so lets decode it.\n+            let c = ((u - 0xD800) as u32 << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n+            Some(Utf16Item::ScalarValue(unsafe {mem::transmute(c)}))\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (low, high) = self.iter.size_hint();\n+        // we could be entirely valid surrogates (2 elements per\n+        // char), or entirely non-surrogates (1 element per char)\n+        (low / 2, high)\n+    }\n+}\n+\n+/// Create an iterator over the UTF-16 encoded codepoints in `v`,\n+/// returning invalid surrogates as `LoneSurrogate`s.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+/// use std::str::{ScalarValue, LoneSurrogate};\n+///\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///          0x0073, 0xDD1E, 0x0069, 0x0063,\n+///          0xD834];\n+///\n+/// assert_eq!(str::utf16_items(&v).collect::<Vec<_>>(),\n+///            vec![ScalarValue('\ud834\udd1e'),\n+///                 ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n+///                 LoneSurrogate(0xDD1E),\n+///                 ScalarValue('i'), ScalarValue('c'),\n+///                 LoneSurrogate(0xD834)]);\n+/// ```\n+pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n+    Utf16Items { iter : v.iter() }\n+}\n+\n+/// Iterator adaptor for encoding `char`s to UTF-16.\n+#[deriving(Clone)]\n+pub struct Utf16Encoder<I> {\n+    chars: I,\n+    extra: u16\n+}\n+\n+impl<I> Utf16Encoder<I> {\n+    /// Create an UTF-16 encoder from any `char` iterator.\n+    pub fn new(chars: I) -> Utf16Encoder<I> where I: Iterator<char> {\n+        Utf16Encoder { chars: chars, extra: 0 }\n+    }\n+}\n+\n+impl<I> Iterator<u16> for Utf16Encoder<I> where I: Iterator<char> {\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> {\n+        if self.extra != 0 {\n+            let tmp = self.extra;\n+            self.extra = 0;\n+            return Some(tmp);\n+        }\n+\n+        let mut buf = [0u16, ..2];\n+        self.chars.next().map(|ch| {\n+            let n = ch.encode_utf16(buf[mut]).unwrap_or(0);\n+            if n == 2 { self.extra = buf[1]; }\n+            buf[0]\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (low, high) = self.chars.size_hint();\n+        // every char gets either one u16 or two u16,\n+        // so this iterator is between 1 or 2 times as\n+        // long as the underlying iterator.\n+        (low, high.and_then(|n| n.checked_mul(2)))\n+    }\n+}\n+\n+impl<'a> Iterator<&'a str> for Words<'a> {\n+    fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n+}\n+impl<'a> DoubleEndedIterator<&'a str> for Words<'a> {\n+    fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n+}"}]}