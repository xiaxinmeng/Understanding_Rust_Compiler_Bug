{"sha": "6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNWNjYTc5ZmNhYWE4MGZiYWFhMjNiYTlmOWM4MDZmMmFlOGY0MWU=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-26T04:56:55Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-12-06T20:48:20Z"}, "message": "Use min_captures for creating UpvarSusbts::tupled_upvar_tys\n\n- final_upvar_tys now reads types from places instead of using `node_ty`\n\nCo-authored-by: Roxane Fruytier <roxane.fruytier@hotmail.com>", "tree": {"sha": "a2f6f0008aa3853260afcb34b77e7f6605cc5152", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2f6f0008aa3853260afcb34b77e7f6605cc5152"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e", "html_url": "https://github.com/rust-lang/rust/commit/6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3", "html_url": "https://github.com/rust-lang/rust/commit/76c68aa182e75bc6b47d8e05995fb7e9bc71cbb3"}], "stats": {"total": 54, "additions": 32, "deletions": 22}, "files": [{"sha": "a8d007c0be27da05ca8e9f2fe1e22f3828a67f2d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e", "patch": "@@ -624,6 +624,19 @@ impl<'tcx> TypeckResults<'tcx> {\n         LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_adjustments }\n     }\n \n+    /// For a given closure, returns the iterator of `ty::CapturedPlace`s that are captured\n+    /// by the closure.\n+    pub fn closure_min_captures_flattened(\n+        &self,\n+        closure_def_id: DefId,\n+    ) -> impl Iterator<Item = &ty::CapturedPlace<'tcx>> {\n+        self.closure_min_captures\n+            .get(&closure_def_id)\n+            .map(|closure_min_captures| closure_min_captures.values().flat_map(|v| v.iter()))\n+            .into_iter()\n+            .flatten()\n+    }\n+\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }"}, {"sha": "30b4682296c6af22488372550139cebb05061f5e", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // inference algorithm will reject it).\n \n         // Equate the type variables for the upvars with the actual types.\n-        let final_upvar_tys = self.final_upvar_tys(closure_hir_id);\n+        let final_upvar_tys = self.final_upvar_tys(closure_def_id);\n         debug!(\n             \"analyze_closure: id={:?} substs={:?} final_upvar_tys={:?}\",\n             closure_hir_id, substs, final_upvar_tys\n@@ -222,36 +222,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     // Returns a list of `Ty`s for each upvar.\n-    fn final_upvar_tys(&self, closure_id: hir::HirId) -> Vec<Ty<'tcx>> {\n+    fn final_upvar_tys(&self, closure_id: DefId) -> Vec<Ty<'tcx>> {\n         // Presently an unboxed closure type cannot \"escape\" out of a\n         // function, so we will only encounter ones that originated in the\n         // local crate or were inlined into it along with some function.\n         // This may change if abstract return types of some sort are\n         // implemented.\n         let tcx = self.tcx;\n-        let closure_def_id = tcx.hir().local_def_id(closure_id);\n \n         self.typeck_results\n             .borrow()\n-            .closure_captures\n-            .get(&closure_def_id.to_def_id())\n-            .iter()\n-            .flat_map(|upvars| {\n-                upvars.iter().map(|(&var_hir_id, _)| {\n-                    let upvar_ty = self.node_ty(var_hir_id);\n-                    let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id);\n-                    let capture = self.typeck_results.borrow().upvar_capture(upvar_id);\n-\n-                    debug!(\"var_id={:?} upvar_ty={:?} capture={:?}\", var_hir_id, upvar_ty, capture);\n-\n-                    match capture {\n-                        ty::UpvarCapture::ByValue(_) => upvar_ty,\n-                        ty::UpvarCapture::ByRef(borrow) => tcx.mk_ref(\n-                            borrow.region,\n-                            ty::TypeAndMut { ty: upvar_ty, mutbl: borrow.kind.to_mutbl_lossy() },\n-                        ),\n-                    }\n-                })\n+            .closure_min_captures_flattened(closure_id)\n+            .map(|captured_place| {\n+                let upvar_ty = captured_place.place.ty();\n+                let capture = captured_place.info.capture_kind;\n+\n+                debug!(\n+                    \"place={:?} upvar_ty={:?} capture={:?}\",\n+                    captured_place.place, upvar_ty, capture\n+                );\n+\n+                match capture {\n+                    ty::UpvarCapture::ByValue(_) => upvar_ty,\n+                    ty::UpvarCapture::ByRef(borrow) => tcx.mk_ref(\n+                        borrow.region,\n+                        ty::TypeAndMut { ty: upvar_ty, mutbl: borrow.kind.to_mutbl_lossy() },\n+                    ),\n+                }\n             })\n             .collect()\n     }"}]}