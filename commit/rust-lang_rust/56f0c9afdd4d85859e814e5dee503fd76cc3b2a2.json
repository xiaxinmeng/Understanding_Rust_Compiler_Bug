{"sha": "56f0c9afdd4d85859e814e5dee503fd76cc3b2a2", "node_id": "C_kwDOAAsO6NoAKDU2ZjBjOWFmZGQ0ZDg1ODU5ZTgxNGU1ZGVlNTAzZmQ3NmNjM2IyYTI", "commit": {"author": {"name": "surechen", "email": "chenshuo17@huawei.com", "date": "2021-09-16T08:42:36Z"}, "committer": {"name": "surechen", "email": "chenshuo17@huawei.com", "date": "2021-09-30T02:07:57Z"}, "message": "fix bug for large_enum_variants", "tree": {"sha": "4da1f5e7c52c5a096a80c6d1bb4f561fd6518c52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4da1f5e7c52c5a096a80c6d1bb4f561fd6518c52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56f0c9afdd4d85859e814e5dee503fd76cc3b2a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56f0c9afdd4d85859e814e5dee503fd76cc3b2a2", "html_url": "https://github.com/rust-lang/rust/commit/56f0c9afdd4d85859e814e5dee503fd76cc3b2a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56f0c9afdd4d85859e814e5dee503fd76cc3b2a2/comments", "author": {"login": "surechen", "id": 7249331, "node_id": "MDQ6VXNlcjcyNDkzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/7249331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/surechen", "html_url": "https://github.com/surechen", "followers_url": "https://api.github.com/users/surechen/followers", "following_url": "https://api.github.com/users/surechen/following{/other_user}", "gists_url": "https://api.github.com/users/surechen/gists{/gist_id}", "starred_url": "https://api.github.com/users/surechen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/surechen/subscriptions", "organizations_url": "https://api.github.com/users/surechen/orgs", "repos_url": "https://api.github.com/users/surechen/repos", "events_url": "https://api.github.com/users/surechen/events{/privacy}", "received_events_url": "https://api.github.com/users/surechen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "surechen", "id": 7249331, "node_id": "MDQ6VXNlcjcyNDkzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/7249331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/surechen", "html_url": "https://github.com/surechen", "followers_url": "https://api.github.com/users/surechen/followers", "following_url": "https://api.github.com/users/surechen/following{/other_user}", "gists_url": "https://api.github.com/users/surechen/gists{/gist_id}", "starred_url": "https://api.github.com/users/surechen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/surechen/subscriptions", "organizations_url": "https://api.github.com/users/surechen/orgs", "repos_url": "https://api.github.com/users/surechen/repos", "events_url": "https://api.github.com/users/surechen/events{/privacy}", "received_events_url": "https://api.github.com/users/surechen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2316f4da83a3952abca808f1f1b2c7ea0a9ee401", "url": "https://api.github.com/repos/rust-lang/rust/commits/2316f4da83a3952abca808f1f1b2c7ea0a9ee401", "html_url": "https://github.com/rust-lang/rust/commit/2316f4da83a3952abca808f1f1b2c7ea0a9ee401"}], "stats": {"total": 242, "additions": 171, "deletions": 71}, "files": [{"sha": "392166237be50eb8fd785afd57902d58c0874c24", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 98, "deletions": 63, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/56f0c9afdd4d85859e814e5dee503fd76cc3b2a2/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56f0c9afdd4d85859e814e5dee503fd76cc3b2a2/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=56f0c9afdd4d85859e814e5dee503fd76cc3b2a2", "patch": "@@ -1,13 +1,14 @@\n //! lint when there is a large size difference between variants on an enum\n \n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet_opt;\n+use clippy_utils::source::snippet_with_applicability;\n use rustc_errors::Applicability;\n-use rustc_hir::{Item, ItemKind, VariantData};\n+use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::source_map::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -58,6 +59,17 @@ impl LargeEnumVariant {\n     }\n }\n \n+struct FieldInfo {\n+    ind: usize,\n+    size: u64,\n+}\n+\n+struct VariantInfo {\n+    ind: usize,\n+    size: u64,\n+    fields_size: Vec<FieldInfo>,\n+}\n+\n impl_lint_pass!(LargeEnumVariant => [LARGE_ENUM_VARIANT]);\n \n impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n@@ -68,72 +80,95 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n         if let ItemKind::Enum(ref def, _) = item.kind {\n             let ty = cx.tcx.type_of(item.def_id);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n-\n-            let mut largest_variant: Option<(_, _)> = None;\n-            let mut second_variant: Option<(_, _)> = None;\n-\n-            for (i, variant) in adt.variants.iter().enumerate() {\n-                let size: u64 = variant\n-                    .fields\n-                    .iter()\n-                    .filter_map(|f| {\n-                        let ty = cx.tcx.type_of(f.did);\n-                        // don't count generics by filtering out everything\n-                        // that does not have a layout\n-                        cx.layout_of(ty).ok().map(|l| l.size.bytes())\n-                    })\n-                    .sum();\n-\n-                let grouped = (size, (i, variant));\n-\n-                if grouped.0 >= largest_variant.map_or(0, |x| x.0) {\n-                    second_variant = largest_variant;\n-                    largest_variant = Some(grouped);\n-                }\n+            if adt.variants.len() <= 1 {\n+                return;\n             }\n+            let mut variants_size: Vec<VariantInfo> = adt\n+                .variants\n+                .iter()\n+                .enumerate()\n+                .map(|(i, variant)| {\n+                    let mut fields_size = Vec::new();\n+                    let size: u64 = variant\n+                        .fields\n+                        .iter()\n+                        .enumerate()\n+                        .filter_map(|(i, f)| {\n+                            let ty = cx.tcx.type_of(f.did);\n+                            // don't count generics by filtering out everything\n+                            // that does not have a layout\n+                            cx.layout_of(ty).ok().map(|l| {\n+                                let size = l.size.bytes();\n+                                fields_size.push(FieldInfo { ind: i, size });\n+                                size\n+                            })\n+                        })\n+                        .sum();\n+                    VariantInfo {\n+                        ind: i,\n+                        size,\n+                        fields_size,\n+                    }\n+                })\n+                .collect();\n \n-            if let (Some(largest), Some(second)) = (largest_variant, second_variant) {\n-                let difference = largest.0 - second.0;\n+            variants_size.sort_by(|a, b| (b.size.cmp(&a.size)));\n \n-                if difference > self.maximum_size_difference_allowed {\n-                    let (i, variant) = largest.1;\n+            let mut difference = variants_size[0].size - variants_size[1].size;\n+            if difference > self.maximum_size_difference_allowed {\n+                let help_text = \"consider boxing the large fields to reduce the total size of the enum\";\n+                span_lint_and_then(\n+                    cx,\n+                    LARGE_ENUM_VARIANT,\n+                    def.variants[variants_size[0].ind].span,\n+                    \"large size difference between variants\",\n+                    |diag| {\n+                        diag.span_label(\n+                            def.variants[variants_size[0].ind].span,\n+                            &format!(\"this variant is {} bytes\", variants_size[0].size),\n+                        );\n+                        diag.span_note(\n+                            def.variants[variants_size[1].ind].span,\n+                            &format!(\"and the second-largest variant is {} bytes:\", variants_size[1].size),\n+                        );\n \n-                    let help_text = \"consider boxing the large fields to reduce the total size of the enum\";\n-                    span_lint_and_then(\n-                        cx,\n-                        LARGE_ENUM_VARIANT,\n-                        def.variants[i].span,\n-                        \"large size difference between variants\",\n-                        |diag| {\n-                            diag.span_label(\n-                                def.variants[(largest.1).0].span,\n-                                &format!(\"this variant is {} bytes\", largest.0),\n-                            );\n-                            diag.span_note(\n-                                def.variants[(second.1).0].span,\n-                                &format!(\"and the second-largest variant is {} bytes:\", second.0),\n-                            );\n-                            if variant.fields.len() == 1 {\n-                                let span = match def.variants[i].data {\n-                                    VariantData::Struct(fields, ..) | VariantData::Tuple(fields, ..) => {\n-                                        fields[0].ty.span\n-                                    },\n-                                    VariantData::Unit(..) => unreachable!(),\n-                                };\n-                                if let Some(snip) = snippet_opt(cx, span) {\n-                                    diag.span_suggestion(\n-                                        span,\n-                                        help_text,\n-                                        format!(\"Box<{}>\", snip),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                    return;\n+                        let fields = def.variants[variants_size[0].ind].data.fields();\n+                        variants_size[0].fields_size.sort_by(|a, b| (a.size.cmp(&b.size)));\n+                        let mut applicability = Applicability::MaybeIncorrect;\n+                        let sugg: Vec<(Span, String)> = variants_size[0]\n+                            .fields_size\n+                            .iter()\n+                            .rev()\n+                            .map_while(|val| {\n+                                if difference > self.maximum_size_difference_allowed {\n+                                    difference = difference.saturating_sub(val.size);\n+                                    Some((\n+                                        fields[val.ind].ty.span,\n+                                        format!(\n+                                            \"Box<{}>\",\n+                                            snippet_with_applicability(\n+                                                cx,\n+                                                fields[val.ind].ty.span,\n+                                                \"..\",\n+                                                &mut applicability\n+                                            )\n+                                            .into_owned()\n+                                        ),\n+                                    ))\n+                                } else {\n+                                    None\n                                 }\n-                            }\n-                            diag.span_help(def.variants[i].span, help_text);\n-                        },\n-                    );\n-                }\n+                            })\n+                            .collect();\n+\n+                        if !sugg.is_empty() {\n+                            diag.multipart_suggestion(help_text, sugg, Applicability::MaybeIncorrect);\n+                            return;\n+                        }\n+\n+                        diag.span_help(def.variants[variants_size[0].ind].span, help_text);\n+                    },\n+                );\n             }\n         }\n     }"}, {"sha": "b45cc849eaec42b5796e35d196f55aee7d312e46", "filename": "tests/ui/large_enum_variant.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/56f0c9afdd4d85859e814e5dee503fd76cc3b2a2/tests%2Fui%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56f0c9afdd4d85859e814e5dee503fd76cc3b2a2/tests%2Fui%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_enum_variant.rs?ref=56f0c9afdd4d85859e814e5dee503fd76cc3b2a2", "patch": "@@ -35,6 +35,7 @@ enum LargeEnum2 {\n     VariantOk(i32, u32),\n     ContainingLargeEnum(LargeEnum),\n }\n+\n enum LargeEnum3 {\n     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n     VoidVariant,\n@@ -56,6 +57,23 @@ enum LargeEnumOk {\n     LargeB([i32; 8001]),\n }\n \n+enum LargeEnum6 {\n+    A,\n+    B([u8; 255]),\n+    C([u8; 200]),\n+}\n+\n+enum LargeEnum7 {\n+    A,\n+    B([u8; 1255]),\n+    C([u8; 200]),\n+}\n+\n+enum LargeEnum8 {\n+    VariantOk(i32, u32),\n+    ContainingMoreThanOneField([i32; 8000], [i32; 2], [i32; 9500], [i32; 30]),\n+}\n+\n fn main() {\n     large_enum_variant!();\n }"}, {"sha": "899f97ce2e1e91ba4f3ce50e9cfb39ce2cd8c0b2", "filename": "tests/ui/large_enum_variant.stderr", "status": "modified", "additions": 55, "deletions": 8, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/56f0c9afdd4d85859e814e5dee503fd76cc3b2a2/tests%2Fui%2Flarge_enum_variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56f0c9afdd4d85859e814e5dee503fd76cc3b2a2/tests%2Fui%2Flarge_enum_variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_enum_variant.stderr?ref=56f0c9afdd4d85859e814e5dee503fd76cc3b2a2", "patch": "@@ -32,30 +32,45 @@ LL |     ContainingLargeEnum(Box<LargeEnum>),\n    |                         ~~~~~~~~~~~~~~\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:46:5\n+  --> $DIR/large_enum_variant.rs:40:5\n+   |\n+LL |     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this variant is 70004 bytes\n+   |\n+note: and the second-largest variant is 8 bytes:\n+  --> $DIR/large_enum_variant.rs:42:5\n+   |\n+LL |     StructLikeLittle { x: i32, y: i32 },\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider boxing the large fields to reduce the total size of the enum\n+   |\n+LL |     ContainingMoreThanOneField(i32, Box<[i32; 8000]>, Box<[i32; 9500]>),\n+   |                                     ~~~~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~\n+\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:47:5\n    |\n LL |     StructLikeLarge { x: [i32; 8000], y: i32 },\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this variant is 32004 bytes\n    |\n note: and the second-largest variant is 8 bytes:\n-  --> $DIR/large_enum_variant.rs:45:5\n+  --> $DIR/large_enum_variant.rs:46:5\n    |\n LL |     VariantOk(i32, u32),\n    |     ^^^^^^^^^^^^^^^^^^^\n help: consider boxing the large fields to reduce the total size of the enum\n-  --> $DIR/large_enum_variant.rs:46:5\n    |\n-LL |     StructLikeLarge { x: [i32; 8000], y: i32 },\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     StructLikeLarge { x: Box<[i32; 8000]>, y: i32 },\n+   |                          ~~~~~~~~~~~~~~~~\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:51:5\n+  --> $DIR/large_enum_variant.rs:52:5\n    |\n LL |     StructLikeLarge2 { x: [i32; 8000] },\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this variant is 32000 bytes\n    |\n note: and the second-largest variant is 8 bytes:\n-  --> $DIR/large_enum_variant.rs:50:5\n+  --> $DIR/large_enum_variant.rs:51:5\n    |\n LL |     VariantOk(i32, u32),\n    |     ^^^^^^^^^^^^^^^^^^^\n@@ -64,5 +79,37 @@ help: consider boxing the large fields to reduce the total size of the enum\n LL |     StructLikeLarge2 { x: Box<[i32; 8000]> },\n    |                           ~~~~~~~~~~~~~~~~\n \n-error: aborting due to 4 previous errors\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:68:5\n+   |\n+LL |     B([u8; 1255]),\n+   |     ^^^^^^^^^^^^^ this variant is 1255 bytes\n+   |\n+note: and the second-largest variant is 200 bytes:\n+  --> $DIR/large_enum_variant.rs:69:5\n+   |\n+LL |     C([u8; 200]),\n+   |     ^^^^^^^^^^^^\n+help: consider boxing the large fields to reduce the total size of the enum\n+   |\n+LL |     B(Box<[u8; 1255]>),\n+   |       ~~~~~~~~~~~~~~~\n+\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:74:5\n+   |\n+LL |     ContainingMoreThanOneField([i32; 8000], [i32; 2], [i32; 9500], [i32; 30]),\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this variant is 70128 bytes\n+   |\n+note: and the second-largest variant is 8 bytes:\n+  --> $DIR/large_enum_variant.rs:73:5\n+   |\n+LL |     VariantOk(i32, u32),\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: consider boxing the large fields to reduce the total size of the enum\n+   |\n+LL |     ContainingMoreThanOneField(Box<[i32; 8000]>, [i32; 2], Box<[i32; 9500]>, [i32; 30]),\n+   |                                ~~~~~~~~~~~~~~~~            ~~~~~~~~~~~~~~~~\n+\n+error: aborting due to 7 previous errors\n "}]}