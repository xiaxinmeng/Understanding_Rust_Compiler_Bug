{"sha": "508eec49e91ef14936800cd56ada6d674b8c6fd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwOGVlYzQ5ZTkxZWYxNDkzNjgwMGNkNTZhZGE2ZDY3NGI4YzZmZDQ=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-01-18T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-01-18T12:15:27Z"}, "message": "Combine instructions immediately\n\nNo functional changes intended", "tree": {"sha": "7a4a3e4bbf45d2a7a67afa618e4badf11f834a77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a4a3e4bbf45d2a7a67afa618e4badf11f834a77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/508eec49e91ef14936800cd56ada6d674b8c6fd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/508eec49e91ef14936800cd56ada6d674b8c6fd4", "html_url": "https://github.com/rust-lang/rust/commit/508eec49e91ef14936800cd56ada6d674b8c6fd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/508eec49e91ef14936800cd56ada6d674b8c6fd4/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9292d871c09bbfc2924dc6e7358fde3ba564d51", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9292d871c09bbfc2924dc6e7358fde3ba564d51", "html_url": "https://github.com/rust-lang/rust/commit/a9292d871c09bbfc2924dc6e7358fde3ba564d51"}], "stats": {"total": 228, "additions": 80, "deletions": 148}, "files": [{"sha": "cd2bea86ea1a73f776948382077c327900b03417", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/508eec49e91ef14936800cd56ada6d674b8c6fd4/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/508eec49e91ef14936800cd56ada6d674b8c6fd4/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=508eec49e91ef14936800cd56ada6d674b8c6fd4", "patch": "@@ -54,7 +54,7 @@ mod type_foldable;\n pub mod visit;\n \n /// Types for locals\n-type LocalDecls<'tcx> = IndexVec<Local, LocalDecl<'tcx>>;\n+pub type LocalDecls<'tcx> = IndexVec<Local, LocalDecl<'tcx>>;\n \n pub trait HasLocalDecls<'tcx> {\n     fn local_decls(&self) -> &LocalDecls<'tcx>;"}, {"sha": "74dadb25725650af345b33374b96139ddf38e646", "filename": "compiler/rustc_mir/src/transform/instcombine.rs", "status": "modified", "additions": 79, "deletions": 147, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/508eec49e91ef14936800cd56ada6d674b8c6fd4/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/508eec49e91ef14936800cd56ada6d674b8c6fd4/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs?ref=508eec49e91ef14936800cd56ada6d674b8c6fd4", "patch": "@@ -1,190 +1,122 @@\n //! Performs various peephole optimizations.\n \n use crate::transform::MirPass;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::Mutability;\n-use rustc_index::vec::Idx;\n-use rustc_middle::mir::visit::{MutVisitor, Visitor};\n use rustc_middle::mir::{\n-    BinOp, Body, Constant, Local, Location, Operand, Place, PlaceRef, ProjectionElem, Rvalue,\n+    BinOp, Body, Constant, LocalDecls, Operand, Place, ProjectionElem, Rvalue, SourceInfo,\n+    StatementKind,\n };\n use rustc_middle::ty::{self, TyCtxt};\n-use std::mem;\n \n pub struct InstCombine;\n \n impl<'tcx> MirPass<'tcx> for InstCombine {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        // First, find optimization opportunities. This is done in a pre-pass to keep the MIR\n-        // read-only so that we can do global analyses on the MIR in the process (e.g.\n-        // `Place::ty()`).\n-        let optimizations = {\n-            let mut optimization_finder = OptimizationFinder::new(body, tcx);\n-            optimization_finder.visit_body(body);\n-            optimization_finder.optimizations\n-        };\n-\n-        if !optimizations.is_empty() {\n-            // Then carry out those optimizations.\n-            MutVisitor::visit_body(&mut InstCombineVisitor { optimizations, tcx }, body);\n+        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n+        let ctx = InstCombineContext { tcx, local_decls };\n+        for block in basic_blocks.iter_mut() {\n+            for statement in block.statements.iter_mut() {\n+                match statement.kind {\n+                    StatementKind::Assign(box (_place, ref mut rvalue)) => {\n+                        ctx.combine_bool_cmp(&statement.source_info, rvalue);\n+                        ctx.combine_ref_deref(&statement.source_info, rvalue);\n+                        ctx.combine_len(&statement.source_info, rvalue);\n+                    }\n+                    _ => {}\n+                }\n+            }\n         }\n     }\n }\n \n-pub struct InstCombineVisitor<'tcx> {\n-    optimizations: OptimizationList<'tcx>,\n+struct InstCombineContext<'tcx, 'a> {\n     tcx: TyCtxt<'tcx>,\n+    local_decls: &'a LocalDecls<'tcx>,\n }\n \n-impl<'tcx> InstCombineVisitor<'tcx> {\n-    fn should_combine(&self, rvalue: &Rvalue<'tcx>, location: Location) -> bool {\n+impl<'tcx, 'a> InstCombineContext<'tcx, 'a> {\n+    fn should_combine(&self, source_info: &SourceInfo, rvalue: &Rvalue<'tcx>) -> bool {\n         self.tcx.consider_optimizing(|| {\n-            format!(\"InstCombine - Rvalue: {:?} Location: {:?}\", rvalue, location)\n+            format!(\"InstCombine - Rvalue: {:?} SourceInfo: {:?}\", rvalue, source_info)\n         })\n     }\n-}\n-\n-impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n \n-    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n-        if self.optimizations.and_stars.remove(&location) && self.should_combine(rvalue, location) {\n-            debug!(\"replacing `&*`: {:?}\", rvalue);\n-            let new_place = match rvalue {\n-                Rvalue::Ref(_, _, place) => {\n-                    if let &[ref proj_l @ .., proj_r] = place.projection.as_ref() {\n-                        place.projection = self.tcx().intern_place_elems(&[proj_r]);\n-\n-                        Place {\n-                            // Replace with dummy\n-                            local: mem::replace(&mut place.local, Local::new(0)),\n-                            projection: self.tcx().intern_place_elems(proj_l),\n-                        }\n-                    } else {\n-                        unreachable!();\n+    /// Transform boolean comparisons into logical operations.\n+    fn combine_bool_cmp(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n+        match rvalue {\n+            Rvalue::BinaryOp(op @ (BinOp::Eq | BinOp::Ne), a, b) => {\n+                let new = match (op, self.try_eval_bool(a), self.try_eval_bool(b)) {\n+                    // Transform \"Eq(a, true)\" ==> \"a\"\n+                    (BinOp::Eq, _, Some(true)) => Some(a.clone()),\n+\n+                    // Transform \"Ne(a, false)\" ==> \"a\"\n+                    (BinOp::Ne, _, Some(false)) => Some(a.clone()),\n+\n+                    // Transform \"Eq(true, b)\" ==> \"b\"\n+                    (BinOp::Eq, Some(true), _) => Some(b.clone()),\n+\n+                    // Transform \"Ne(false, b)\" ==> \"b\"\n+                    (BinOp::Ne, Some(false), _) => Some(b.clone()),\n+\n+                    // FIXME: Consider combining remaining comparisons into logical operations:\n+                    // Transform \"Eq(false, b)\" ==> \"Not(b)\"\n+                    // Transform \"Ne(true, b)\" ==> \"Not(b)\"\n+                    // Transform \"Eq(a, false)\" ==> \"Not(a)\"\n+                    // Transform \"Ne(a, true)\" ==> \"Not(a)\"\n+                    _ => None,\n+                };\n+\n+                if let Some(new) = new {\n+                    if self.should_combine(source_info, rvalue) {\n+                        *rvalue = Rvalue::Use(new);\n                     }\n                 }\n-                _ => bug!(\"Detected `&*` but didn't find `&*`!\"),\n-            };\n-            *rvalue = Rvalue::Use(Operand::Copy(new_place))\n-        }\n-\n-        if let Some(constant) = self.optimizations.arrays_lengths.remove(&location) {\n-            if self.should_combine(rvalue, location) {\n-                debug!(\"replacing `Len([_; N])`: {:?}\", rvalue);\n-                *rvalue = Rvalue::Use(Operand::Constant(box constant));\n             }\n-        }\n \n-        if let Some(operand) = self.optimizations.unneeded_equality_comparison.remove(&location) {\n-            if self.should_combine(rvalue, location) {\n-                debug!(\"replacing {:?} with {:?}\", rvalue, operand);\n-                *rvalue = Rvalue::Use(operand);\n-            }\n+            _ => {}\n         }\n-\n-        // We do not call super_rvalue as we are not interested in any other parts of the tree\n-    }\n-}\n-\n-/// Finds optimization opportunities on the MIR.\n-struct OptimizationFinder<'b, 'tcx> {\n-    body: &'b Body<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    optimizations: OptimizationList<'tcx>,\n-}\n-\n-impl OptimizationFinder<'b, 'tcx> {\n-    fn new(body: &'b Body<'tcx>, tcx: TyCtxt<'tcx>) -> OptimizationFinder<'b, 'tcx> {\n-        OptimizationFinder { body, tcx, optimizations: OptimizationList::default() }\n     }\n \n-    fn find_unneeded_equality_comparison(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        // find Ne(_place, false) or Ne(false, _place)\n-        // or   Eq(_place, true) or Eq(true, _place)\n-        if let Rvalue::BinaryOp(op, l, r) = rvalue {\n-            let const_to_find = if *op == BinOp::Ne {\n-                false\n-            } else if *op == BinOp::Eq {\n-                true\n-            } else {\n-                return;\n-            };\n-            // (const, _place)\n-            if let Some(o) = self.find_operand_in_equality_comparison_pattern(l, r, const_to_find) {\n-                self.optimizations.unneeded_equality_comparison.insert(location, o.clone());\n-            }\n-            // (_place, const)\n-            else if let Some(o) =\n-                self.find_operand_in_equality_comparison_pattern(r, l, const_to_find)\n-            {\n-                self.optimizations.unneeded_equality_comparison.insert(location, o.clone());\n-            }\n-        }\n+    fn try_eval_bool(&self, a: &Operand<'_>) -> Option<bool> {\n+        let a = a.constant()?;\n+        if a.literal.ty.is_bool() { a.literal.val.try_to_bool() } else { None }\n     }\n \n-    fn find_operand_in_equality_comparison_pattern(\n-        &self,\n-        l: &Operand<'tcx>,\n-        r: &'a Operand<'tcx>,\n-        const_to_find: bool,\n-    ) -> Option<&'a Operand<'tcx>> {\n-        let const_ = l.constant()?;\n-        if const_.literal.ty == self.tcx.types.bool\n-            && const_.literal.val.try_to_bool() == Some(const_to_find)\n-        {\n-            if r.place().is_some() {\n-                return Some(r);\n-            }\n-        }\n-\n-        None\n-    }\n-}\n-\n-impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+    /// Transform \"&(*a)\" ==> \"a\".\n+    fn combine_ref_deref(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n         if let Rvalue::Ref(_, _, place) = rvalue {\n-            if let Some((place_base, ProjectionElem::Deref)) = place.as_ref().last_projection() {\n-                // The dereferenced place must have type `&_`.\n-                let ty = place_base.ty(self.body, self.tcx).ty;\n-                if let ty::Ref(_, _, Mutability::Not) = ty.kind() {\n-                    self.optimizations.and_stars.insert(location);\n+            if let Some((base, ProjectionElem::Deref)) = place.as_ref().last_projection() {\n+                if let ty::Ref(_, _, Mutability::Not) =\n+                    base.ty(self.local_decls, self.tcx).ty.kind()\n+                {\n+                    // The dereferenced place must have type `&_`, so that we don't copy `&mut _`.\n+                } else {\n+                    return;\n                 }\n-            }\n-        }\n \n-        if let Rvalue::Len(ref place) = *rvalue {\n-            let place_ty = place.ty(&self.body.local_decls, self.tcx).ty;\n-            if let ty::Array(_, len) = place_ty.kind() {\n-                let span = self.body.source_info(location).span;\n-                let constant = Constant { span, literal: len, user_ty: None };\n-                self.optimizations.arrays_lengths.insert(location, constant);\n+                if !self.should_combine(source_info, rvalue) {\n+                    return;\n+                }\n+\n+                *rvalue = Rvalue::Use(Operand::Copy(Place {\n+                    local: base.local,\n+                    projection: self.tcx.intern_place_elems(base.projection),\n+                }));\n             }\n         }\n-\n-        self.find_unneeded_equality_comparison(rvalue, location);\n-\n-        // We do not call super_rvalue as we are not interested in any other parts of the tree\n     }\n-}\n \n-#[derive(Default)]\n-struct OptimizationList<'tcx> {\n-    and_stars: FxHashSet<Location>,\n-    arrays_lengths: FxHashMap<Location, Constant<'tcx>>,\n-    unneeded_equality_comparison: FxHashMap<Location, Operand<'tcx>>,\n-}\n+    /// Transform \"Len([_; N])\" ==> \"N\".\n+    fn combine_len(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n+        if let Rvalue::Len(ref place) = *rvalue {\n+            let place_ty = place.ty(self.local_decls, self.tcx).ty;\n+            if let ty::Array(_, len) = place_ty.kind() {\n+                if !self.should_combine(source_info, rvalue) {\n+                    return;\n+                }\n \n-impl<'tcx> OptimizationList<'tcx> {\n-    fn is_empty(&self) -> bool {\n-        match self {\n-            OptimizationList { and_stars, arrays_lengths, unneeded_equality_comparison } => {\n-                and_stars.is_empty()\n-                    && arrays_lengths.is_empty()\n-                    && unneeded_equality_comparison.is_empty()\n+                let constant = Constant { span: source_info.span, literal: len, user_ty: None };\n+                *rvalue = Rvalue::Use(Operand::Constant(box constant));\n             }\n         }\n     }"}]}