{"sha": "9b9d39e43f3d8723b36f7e4b9ecafa36203fde45", "node_id": "C_kwDOAAsO6NoAKDliOWQzOWU0M2YzZDg3MjNiMzZmN2U0YjllY2FmYTM2MjAzZmRlNDU", "commit": {"author": {"name": "Chris Denton", "email": "chris@chrisdenton.dev", "date": "2023-04-27T08:27:23Z"}, "committer": {"name": "Chris Denton", "email": "chris@chrisdenton.dev", "date": "2023-04-27T08:58:19Z"}, "message": "Abstract `MultiByteToWideChar`", "tree": {"sha": "7d09bdee80d979990e7309b8e47d3086a1d441f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d09bdee80d979990e7309b8e47d3086a1d441f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b9d39e43f3d8723b36f7e4b9ecafa36203fde45", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmRKOSsACgkQcTRy8vRW\nJ94ohQ/5AfBJomaXjdCpSpA6FG+hX6JOk5oZHRd/1j9CsvozAHJwfHJp2bZityjD\nQSyuyplpu7lNBWle/tV42isrPIZvGT6/wZKxdoZ07UupgbpezFJoN4w7V7rRp9c5\n640ky5tKLL+6s8CojBIY9x3LXqpCuw75WALRjQ8HnkR7FsR4KbNEY+NJ3YAh7ej9\nIHGNVZwknH9PAXugYqMsTzP7uRoktPLhWyN9CCgkEmd5juCUZ9PumT+1fos64sG8\nk832QrT3mR/3FmPSbIX6dtrS9aZnmWUY14jZUyD/KuJZIE2AIQ5LgfsrDzbUuYAc\nFZjA/MNVNMLbYkNQZqWAFHBOnwddCvUqljv2OldLMOLyIbGycElozSbP5rNUJl43\nQ1dZOh03qIwJyiZh2hkSiebOUfcFKWnIhu1C8Qm6RyIend7GQwK+/ukO5z4bSyKc\nUK1zSY1vjS5lJ/CZXpt5L4TBPvLCiFndb2zFHEiMTazH8FHSpPzRuXmpIJkM+dkn\n0If+A0ZcQsNJ7HfbltJx2UA4JkZvtmmgcVLpCcnwDolFSBY4NDXZ3JBOzPJjl1H/\nJwhKm778oejHTBS4SPui19LA02r1RMH2pjXVolfg/PMThgCERECDKWXq7kn9H4eL\n7g8vIn4YO1RIof7VoGxQcl+X9SkYlqtZ71qRWHtK1I30XgG8o5U=\n=WTFW\n-----END PGP SIGNATURE-----", "payload": "tree 7d09bdee80d979990e7309b8e47d3086a1d441f2\nparent 73b65746e81a31c03cbd3751966eb399073f2d9a\nauthor Chris Denton <chris@chrisdenton.dev> 1682584043 +0100\ncommitter Chris Denton <chris@chrisdenton.dev> 1682585899 +0100\n\nAbstract `MultiByteToWideChar`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9d39e43f3d8723b36f7e4b9ecafa36203fde45", "html_url": "https://github.com/rust-lang/rust/commit/9b9d39e43f3d8723b36f7e4b9ecafa36203fde45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b9d39e43f3d8723b36f7e4b9ecafa36203fde45/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73b65746e81a31c03cbd3751966eb399073f2d9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/73b65746e81a31c03cbd3751966eb399073f2d9a", "html_url": "https://github.com/rust-lang/rust/commit/73b65746e81a31c03cbd3751966eb399073f2d9a"}], "stats": {"total": 90, "additions": 57, "deletions": 33}, "files": [{"sha": "fe21986884f06fbf7f6fd301eb571e93b32d9916", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 57, "deletions": 33, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/9b9d39e43f3d8723b36f7e4b9ecafa36203fde45/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9d39e43f3d8723b36f7e4b9ecafa36203fde45/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=9b9d39e43f3d8723b36f7e4b9ecafa36203fde45", "patch": "@@ -1064,42 +1064,66 @@ fn escape_linker_output(s: &[u8], flavour: LinkerFlavor) -> String {\n     }\n     match str::from_utf8(s) {\n         Ok(s) => return s.to_owned(),\n-        Err(_) if s.len() <= i32::MAX as usize => {\n-            use windows::Win32::Globalization::{\n-                GetLocaleInfoEx, MultiByteToWideChar, CP_OEMCP, LOCALE_IUSEUTF8LEGACYOEMCP,\n-                LOCALE_NAME_SYSTEM_DEFAULT, LOCALE_RETURN_NUMBER, MB_ERR_INVALID_CHARS,\n-            };\n-            // Get the legacy system OEM code page.\n-            let code_page = unsafe {\n-                let mut cp: u32 = 0;\n-                // We're using the `LOCALE_RETURN_NUMBER` flag to return a u32.\n-                // But the API requires us to pass the data as though it's a [u16] string.\n-                let len = std::mem::size_of::<u32>() / std::mem::size_of::<u16>();\n-                let data = std::slice::from_raw_parts_mut(&mut cp as *mut u32 as *mut u16, len);\n-                let len_written = GetLocaleInfoEx(\n-                    LOCALE_NAME_SYSTEM_DEFAULT,\n-                    LOCALE_IUSEUTF8LEGACYOEMCP | LOCALE_RETURN_NUMBER,\n-                    Some(data),\n-                );\n-                if len_written as usize == len { cp } else { CP_OEMCP }\n-            };\n-            // Error if the string is not valid for the expected code page.\n-            let flags = MB_ERR_INVALID_CHARS;\n-            // Call MultiByteToWideChar twice.\n-            // First to calculate the length then to convert the string.\n-            let mut len = unsafe { MultiByteToWideChar(code_page, flags, s, None) };\n+        Err(_) => match win::locale_byte_str_to_string(s, win::oem_code_page()) {\n+            Some(s) => s,\n+            // The string is not UTF-8 and isn't valid for the OEM code page\n+            None => format!(\"Non-UTF-8 output: {}\", s.escape_ascii()),\n+        },\n+    }\n+}\n+\n+/// Wrappers around the Windows API.\n+#[cfg(windows)]\n+mod win {\n+    use windows::Win32::Globalization::{\n+        GetLocaleInfoEx, MultiByteToWideChar, CP_OEMCP, LOCALE_IUSEUTF8LEGACYOEMCP,\n+        LOCALE_NAME_SYSTEM_DEFAULT, LOCALE_RETURN_NUMBER, MB_ERR_INVALID_CHARS,\n+    };\n+\n+    /// Get the Windows system OEM code page. This is most notably the code page\n+    /// used for link.exe's output.\n+    pub fn oem_code_page() -> u32 {\n+        unsafe {\n+            let mut cp: u32 = 0;\n+            // We're using the `LOCALE_RETURN_NUMBER` flag to return a u32.\n+            // But the API requires us to pass the data as though it's a [u16] string.\n+            let len = std::mem::size_of::<u32>() / std::mem::size_of::<u16>();\n+            let data = std::slice::from_raw_parts_mut(&mut cp as *mut u32 as *mut u16, len);\n+            let len_written = GetLocaleInfoEx(\n+                LOCALE_NAME_SYSTEM_DEFAULT,\n+                LOCALE_IUSEUTF8LEGACYOEMCP | LOCALE_RETURN_NUMBER,\n+                Some(data),\n+            );\n+            if len_written as usize == len { cp } else { CP_OEMCP }\n+        }\n+    }\n+    /// Try to convert a multi-byte string to a UTF-8 string using the given code page\n+    /// The string does not need to be null terminated.\n+    ///\n+    /// This is implemented as a wrapper around `MultiByteToWideChar`.\n+    /// See <https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar>\n+    ///\n+    /// It will fail if the multi-byte string is longer than `i32::MAX` or if it contains\n+    /// any invalid bytes for the expected encoding.\n+    pub fn locale_byte_str_to_string(s: &[u8], code_page: u32) -> Option<String> {\n+        // `MultiByteToWideChar` requires a length to be a \"positive integer\".\n+        if s.len() > isize::MAX as usize {\n+            return None;\n+        }\n+        // Error if the string is not valid for the expected code page.\n+        let flags = MB_ERR_INVALID_CHARS;\n+        // Call MultiByteToWideChar twice.\n+        // First to calculate the length then to convert the string.\n+        let mut len = unsafe { MultiByteToWideChar(code_page, flags, s, None) };\n+        if len > 0 {\n+            let mut utf16 = vec![0; len as usize];\n+            len = unsafe { MultiByteToWideChar(code_page, flags, s, Some(&mut utf16)) };\n             if len > 0 {\n-                let mut utf16 = vec![0; len as usize];\n-                len = unsafe { MultiByteToWideChar(code_page, flags, s, Some(&mut utf16)) };\n-                if len > 0 {\n-                    return String::from_utf16_lossy(&utf16[..len as usize]);\n-                }\n+                return utf16.get(..len as usize).map(String::from_utf16_lossy);\n             }\n         }\n-        _ => {}\n-    };\n-    // The string is not UTF-8 and isn't valid for the OEM code page\n-    format!(\"Non-UTF-8 output: {}\", s.escape_ascii())\n+        None\n+    }\n }\n \n fn add_sanitizer_libraries(sess: &Session, crate_type: CrateType, linker: &mut dyn Linker) {"}]}