{"sha": "21922e1f48b263b39498cfeec79c1ca3f5886efe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxOTIyZTFmNDhiMjYzYjM5NDk4Y2ZlZWM3OWMxY2EzZjU4ODZlZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-21T23:00:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-21T23:00:08Z"}, "message": "Auto merge of #32062 - Marwes:unification_table_for_eq_relations, r=nikomatsakis\n\nImprove time complexity of equality relations\n\nThis PR adds a `UnificationTable` to the `TypeVariableTable` type which is used store information about variable equality instead of just storing them in a vector for later processing. By using a `UnificationTable` equality relations can be resolved in O(n) (for all realistic values of n) rather than O(n!) which can give massive speedups in certain cases (see combine as an example).\n\nLink to combine: https://github.com/Marwes/combine", "tree": {"sha": "091cf922ad764cc1bc19a2910b16d0abd82691e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/091cf922ad764cc1bc19a2910b16d0abd82691e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21922e1f48b263b39498cfeec79c1ca3f5886efe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21922e1f48b263b39498cfeec79c1ca3f5886efe", "html_url": "https://github.com/rust-lang/rust/commit/21922e1f48b263b39498cfeec79c1ca3f5886efe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21922e1f48b263b39498cfeec79c1ca3f5886efe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0168dc7c5904701983c280cb4fa0fb0c0fa692c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0168dc7c5904701983c280cb4fa0fb0c0fa692c5", "html_url": "https://github.com/rust-lang/rust/commit/0168dc7c5904701983c280cb4fa0fb0c0fa692c5"}, {"sha": "e00cdd73456a3258e317bf68f8fa3a26c9922deb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e00cdd73456a3258e317bf68f8fa3a26c9922deb", "html_url": "https://github.com/rust-lang/rust/commit/e00cdd73456a3258e317bf68f8fa3a26c9922deb"}], "stats": {"total": 225, "additions": 183, "deletions": 42}, "files": [{"sha": "485b7d2a9dd50abb24a7b730e15454098527594a", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=21922e1f48b263b39498cfeec79c1ca3f5886efe", "patch": "@@ -77,8 +77,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.type_variables.borrow().replace_if_possible(a);\n-        let b = infcx.type_variables.borrow().replace_if_possible(b);\n+        let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n+        let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n             (&ty::TyInfer(TyVar(a_id)), &ty::TyInfer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().relate_vars(a_id, BiTo, b_id);"}, {"sha": "1c2af96132559cbfd029fed2cc8e30eca249a5e7", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=21922e1f48b263b39498cfeec79c1ca3f5886efe", "patch": "@@ -210,6 +210,12 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n                 None => break,\n                 Some(e) => e,\n             };\n+            // Get the actual variable that b_vid has been inferred to\n+            let (b_vid, b_ty) = {\n+                let mut variables = self.infcx.type_variables.borrow_mut();\n+                let b_vid = variables.root_var(b_vid);\n+                (b_vid, variables.probe_root(b_vid))\n+            };\n \n             debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\",\n                    a_ty,\n@@ -219,7 +225,6 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n             // Check whether `vid` has been instantiated yet.  If not,\n             // make a generalized form of `ty` and instantiate with\n             // that.\n-            let b_ty = self.infcx.type_variables.borrow().probe(b_vid);\n             let b_ty = match b_ty {\n                 Some(t) => t, // ...already instantiated.\n                 None => {     // ...not yet instantiated:\n@@ -307,12 +312,17 @@ impl<'cx, 'tcx> ty::fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n         //  where `$1` has already been instantiated with `Box<$0>`)\n         match t.sty {\n             ty::TyInfer(ty::TyVar(vid)) => {\n+                let mut variables = self.infcx.type_variables.borrow_mut();\n+                let vid = variables.root_var(vid);\n                 if vid == self.for_vid {\n                     self.cycle_detected = true;\n                     self.tcx().types.err\n                 } else {\n-                    match self.infcx.type_variables.borrow().probe(vid) {\n-                        Some(u) => self.fold_ty(u),\n+                    match variables.probe_root(vid) {\n+                        Some(u) => {\n+                            drop(variables);\n+                            self.fold_ty(u)\n+                        }\n                         None => t,\n                     }\n                 }"}, {"sha": "92a419fec323c52caef9bd937d6e22290b465ce9", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=21922e1f48b263b39498cfeec79c1ca3f5886efe", "patch": "@@ -50,8 +50,8 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.type_variables.borrow().replace_if_possible(a);\n-        let b = infcx.type_variables.borrow().replace_if_possible(b);\n+        let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n+        let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n             (&ty::TyInfer(TyVar(a_id)), &ty::TyInfer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().relate_vars(a_id, EqTo, b_id);"}, {"sha": "b0f6d45dc53f15a20c187ceb2b0289aa5dc3c037", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=21922e1f48b263b39498cfeec79c1ca3f5886efe", "patch": "@@ -111,8 +111,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n         match t.sty {\n             ty::TyInfer(ty::TyVar(v)) => {\n+                let opt_ty = self.infcx.type_variables.borrow_mut().probe(v);\n                 self.freshen(\n-                    self.infcx.type_variables.borrow().probe(v),\n+                    opt_ty,\n                     ty::TyVar(v),\n                     ty::FreshTy)\n             }"}, {"sha": "6cb91438ec36635c5d374d86049087586a9196ca", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=21922e1f48b263b39498cfeec79c1ca3f5886efe", "patch": "@@ -434,7 +434,7 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n             self.region_vars.vars_created_since_snapshot(&snapshot.region_vars_snapshot);\n \n         let escaping_types =\n-            self.type_variables.borrow().types_escaping_snapshot(&snapshot.type_snapshot);\n+            self.type_variables.borrow_mut().types_escaping_snapshot(&snapshot.type_snapshot);\n \n         let mut escaping_region_vars = FnvHashSet();\n         for ty in &escaping_types {"}, {"sha": "6b5f2c74a69c642a8c35e9651475094d379ca5fa", "filename": "src/librustc/middle/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs?ref=21922e1f48b263b39498cfeec79c1ca3f5886efe", "patch": "@@ -60,8 +60,8 @@ pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n     }\n \n     let infcx = this.infcx();\n-    let a = infcx.type_variables.borrow().replace_if_possible(a);\n-    let b = infcx.type_variables.borrow().replace_if_possible(b);\n+    let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n+    let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n     match (&a.sty, &b.sty) {\n         (&ty::TyInfer(TyVar(..)), &ty::TyInfer(TyVar(..)))\n             if infcx.type_var_diverges(a) && infcx.type_var_diverges(b) => {"}, {"sha": "829cb763c4fdf253330dfd861d1248d1230ca898", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=21922e1f48b263b39498cfeec79c1ca3f5886efe", "patch": "@@ -663,7 +663,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let mut variables = Vec::new();\n \n         let unbound_ty_vars = self.type_variables\n-                                  .borrow()\n+                                  .borrow_mut()\n                                   .unsolved_variables()\n                                   .into_iter()\n                                   .map(|t| self.tcx.mk_var(t));\n@@ -1196,7 +1196,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // structurally), and we prevent cycles in any case,\n                 // so this recursion should always be of very limited\n                 // depth.\n-                self.type_variables.borrow()\n+                self.type_variables.borrow_mut()\n                     .probe(v)\n                     .map(|t| self.shallow_resolve(t))\n                     .unwrap_or(typ)"}, {"sha": "918a8c362da2d2e20f5fb66b2ff354dd7ac8b1e8", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=21922e1f48b263b39498cfeec79c1ca3f5886efe", "patch": "@@ -65,8 +65,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.type_variables.borrow().replace_if_possible(a);\n-        let b = infcx.type_variables.borrow().replace_if_possible(b);\n+        let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n+        let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n             (&ty::TyInfer(TyVar(a_id)), &ty::TyInfer(TyVar(b_id))) => {\n                 infcx.type_variables"}, {"sha": "fe66ea5a1ea124370e83a86e07fc1dc0f8f1320c", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 80, "deletions": 18, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=21922e1f48b263b39498cfeec79c1ca3f5886efe", "patch": "@@ -20,9 +20,11 @@ use std::marker::PhantomData;\n use std::mem;\n use std::u32;\n use rustc_data_structures::snapshot_vec as sv;\n+use rustc_data_structures::unify as ut;\n \n pub struct TypeVariableTable<'tcx> {\n     values: sv::SnapshotVec<Delegate<'tcx>>,\n+    eq_relations: ut::UnificationTable<ty::TyVid>,\n }\n \n struct TypeVariableData<'tcx> {\n@@ -50,20 +52,22 @@ pub struct Default<'tcx> {\n }\n \n pub struct Snapshot {\n-    snapshot: sv::Snapshot\n+    snapshot: sv::Snapshot,\n+    eq_snapshot: ut::Snapshot<ty::TyVid>,\n }\n \n enum UndoEntry<'tcx> {\n     // The type of the var was specified.\n     SpecifyVar(ty::TyVid, Vec<Relation>, Option<Default<'tcx>>),\n     Relate(ty::TyVid, ty::TyVid),\n+    RelateRange(ty::TyVid, usize),\n }\n \n struct Delegate<'tcx>(PhantomData<&'tcx ()>);\n \n type Relation = (RelationDir, ty::TyVid);\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n pub enum RelationDir {\n     SubtypeOf, SupertypeOf, EqTo, BiTo\n }\n@@ -81,7 +85,10 @@ impl RelationDir {\n \n impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn new() -> TypeVariableTable<'tcx> {\n-        TypeVariableTable { values: sv::SnapshotVec::new() }\n+        TypeVariableTable {\n+            values: sv::SnapshotVec::new(),\n+            eq_relations: ut::UnificationTable::new(),\n+        }\n     }\n \n     fn relations<'a>(&'a mut self, a: ty::TyVid) -> &'a mut Vec<Relation> {\n@@ -103,22 +110,48 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n     pub fn relate_vars(&mut self, a: ty::TyVid, dir: RelationDir, b: ty::TyVid) {\n+        let a = self.root_var(a);\n+        let b = self.root_var(b);\n         if a != b {\n-            self.relations(a).push((dir, b));\n-            self.relations(b).push((dir.opposite(), a));\n-            self.values.record(Relate(a, b));\n+            if dir == EqTo {\n+                // a and b must be equal which we mark in the unification table\n+                let root = self.eq_relations.union(a, b);\n+                // In addition to being equal, all relations from the variable which is no longer\n+                // the root must be added to the root so they are not forgotten as the other\n+                // variable should no longer be referenced (other than to get the root)\n+                let other = if a == root { b } else { a };\n+                let count = {\n+                    let (relations, root_relations) = if other.index < root.index {\n+                        let (pre, post) = self.values.split_at_mut(root.index as usize);\n+                        (relations(&mut pre[other.index as usize]), relations(&mut post[0]))\n+                    } else {\n+                        let (pre, post) = self.values.split_at_mut(other.index as usize);\n+                        (relations(&mut post[0]), relations(&mut pre[root.index as usize]))\n+                    };\n+                    root_relations.extend_from_slice(relations);\n+                    relations.len()\n+                };\n+                self.values.record(RelateRange(root, count));\n+            } else {\n+                self.relations(a).push((dir, b));\n+                self.relations(b).push((dir.opposite(), a));\n+                self.values.record(Relate(a, b));\n+            }\n         }\n     }\n \n     /// Instantiates `vid` with the type `ty` and then pushes an entry onto `stack` for each of the\n     /// relations of `vid` to other variables. The relations will have the form `(ty, dir, vid1)`\n     /// where `vid1` is some other variable id.\n+    ///\n+    /// Precondition: `vid` must be a root in the unification table\n     pub fn instantiate_and_push(\n         &mut self,\n         vid: ty::TyVid,\n         ty: Ty<'tcx>,\n         stack: &mut Vec<(Ty<'tcx>, RelationDir, ty::TyVid)>)\n     {\n+        debug_assert!(self.root_var(vid) == vid);\n         let old_value = {\n             let value_ptr = &mut self.values.get_mut(vid.index as usize).value;\n             mem::replace(value_ptr, Known(ty))\n@@ -140,21 +173,33 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn new_var(&mut self,\n                    diverging: bool,\n                    default: Option<Default<'tcx>>) -> ty::TyVid {\n+        self.eq_relations.new_key(());\n         let index = self.values.push(TypeVariableData {\n             value: Bounded { relations: vec![], default: default },\n             diverging: diverging\n         });\n         ty::TyVid { index: index as u32 }\n     }\n \n-    pub fn probe(&self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n+    pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n+        self.eq_relations.find(vid)\n+    }\n+\n+    pub fn probe(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n+        let vid = self.root_var(vid);\n+        self.probe_root(vid)\n+    }\n+\n+    /// Retrieves the type of `vid` given that it is currently a root in the unification table\n+    pub fn probe_root(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n+        debug_assert!(self.root_var(vid) == vid);\n         match self.values.get(vid.index as usize).value {\n             Bounded { .. } => None,\n             Known(t) => Some(t)\n         }\n     }\n \n-    pub fn replace_if_possible(&self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn replace_if_possible(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n             ty::TyInfer(ty::TyVar(v)) => {\n                 match self.probe(v) {\n@@ -167,18 +212,23 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n \n     pub fn snapshot(&mut self) -> Snapshot {\n-        Snapshot { snapshot: self.values.start_snapshot() }\n+        Snapshot {\n+            snapshot: self.values.start_snapshot(),\n+            eq_snapshot: self.eq_relations.snapshot(),\n+        }\n     }\n \n     pub fn rollback_to(&mut self, s: Snapshot) {\n         self.values.rollback_to(s.snapshot);\n+        self.eq_relations.rollback_to(s.eq_snapshot);\n     }\n \n     pub fn commit(&mut self, s: Snapshot) {\n         self.values.commit(s.snapshot);\n+        self.eq_relations.commit(s.eq_snapshot);\n     }\n \n-    pub fn types_escaping_snapshot(&self, s: &Snapshot) -> Vec<Ty<'tcx>> {\n+    pub fn types_escaping_snapshot(&mut self, s: &Snapshot) -> Vec<Ty<'tcx>> {\n         /*!\n          * Find the set of type variables that existed *before* `s`\n          * but which have only been unified since `s` started, and\n@@ -208,7 +258,10 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                     if vid.index < new_elem_threshold {\n                         // quick check to see if this variable was\n                         // created since the snapshot started or not.\n-                        let escaping_type = self.probe(vid).unwrap();\n+                        let escaping_type = match self.values.get(vid.index as usize).value {\n+                            Bounded { .. } => unreachable!(),\n+                            Known(ty) => ty,\n+                        };\n                         escaping_types.push(escaping_type);\n                     }\n                     debug!(\"SpecifyVar({:?}) new_elem_threshold={}\", vid, new_elem_threshold);\n@@ -221,13 +274,15 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         escaping_types\n     }\n \n-    pub fn unsolved_variables(&self) -> Vec<ty::TyVid> {\n-        self.values\n-            .iter()\n-            .enumerate()\n-            .filter_map(|(i, value)| match &value.value {\n-                &TypeVariableValue::Known(_) => None,\n-                &TypeVariableValue::Bounded { .. } => Some(ty::TyVid { index: i as u32 })\n+    pub fn unsolved_variables(&mut self) -> Vec<ty::TyVid> {\n+        (0..self.values.len())\n+            .filter_map(|i| {\n+                let vid = ty::TyVid { index: i as u32 };\n+                if self.probe(vid).is_some() {\n+                    None\n+                } else {\n+                    Some(vid)\n+                }\n             })\n             .collect()\n     }\n@@ -250,6 +305,13 @@ impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n                 relations(&mut (*values)[a.index as usize]).pop();\n                 relations(&mut (*values)[b.index as usize]).pop();\n             }\n+\n+            RelateRange(i, n) => {\n+                let relations = relations(&mut (*values)[i.index as usize]);\n+                for _ in 0..n {\n+                    relations.pop();\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "3f8c3fbce047a24fab1f5ce04bae107fc21cba2c", "filename": "src/librustc/middle/infer/unify_key.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs?ref=21922e1f48b263b39498cfeec79c1ca3f5886efe", "patch": "@@ -73,3 +73,10 @@ impl<'tcx> ToType<'tcx> for ast::FloatTy {\n         tcx.mk_mach_float(*self)\n     }\n }\n+\n+impl UnifyKey for ty::TyVid {\n+    type Value = ();\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> ty::TyVid { ty::TyVid { index: i } }\n+    fn tag(_: Option<ty::TyVid>) -> &'static str { \"TyVid\" }\n+}"}, {"sha": "3feea3218d0138b95100fe70211841692509f0a7", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=21922e1f48b263b39498cfeec79c1ca3f5886efe", "patch": "@@ -211,7 +211,7 @@ impl<K: UnifyKey> UnificationTable<K> {\n     /// really more of a building block. If the values associated with\n     /// your key are non-trivial, you would probably prefer to call\n     /// `unify_var_var` below.\n-    fn unify(&mut self, root_a: VarValue<K>, root_b: VarValue<K>, new_value: K::Value) {\n+    fn unify(&mut self, root_a: VarValue<K>, root_b: VarValue<K>, new_value: K::Value) -> K {\n         debug!(\"unify(root_a(id={:?}, rank={:?}), root_b(id={:?}, rank={:?}))\",\n                root_a.key(),\n                root_a.rank,\n@@ -221,26 +221,27 @@ impl<K: UnifyKey> UnificationTable<K> {\n         if root_a.rank > root_b.rank {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n-            self.redirect_root(root_a.rank, root_b, root_a, new_value);\n+            self.redirect_root(root_a.rank, root_b, root_a, new_value)\n         } else if root_a.rank < root_b.rank {\n             // b has greater rank, so a should redirect to b.\n-            self.redirect_root(root_b.rank, root_a, root_b, new_value);\n+            self.redirect_root(root_b.rank, root_a, root_b, new_value)\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n-            self.redirect_root(root_a.rank + 1, root_a, root_b, new_value);\n+            self.redirect_root(root_a.rank + 1, root_a, root_b, new_value)\n         }\n     }\n \n     fn redirect_root(&mut self,\n                      new_rank: u32,\n                      old_root: VarValue<K>,\n                      new_root: VarValue<K>,\n-                     new_value: K::Value) {\n+                     new_value: K::Value) -> K {\n         let old_root_key = old_root.key();\n         let new_root_key = new_root.key();\n         self.set(old_root_key, old_root.redirect(new_root_key));\n         self.set(new_root_key, new_root.root(new_rank, new_value));\n+        new_root_key\n     }\n }\n \n@@ -256,14 +257,16 @@ impl<K: UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n impl<'tcx, K: UnifyKey> UnificationTable<K>\n     where K::Value: Combine\n {\n-    pub fn union(&mut self, a_id: K, b_id: K) {\n+    pub fn union(&mut self, a_id: K, b_id: K) -> K {\n         let node_a = self.get(a_id);\n         let node_b = self.get(b_id);\n         let a_id = node_a.key();\n         let b_id = node_b.key();\n         if a_id != b_id {\n             let new_value = node_a.value.combine(&node_b.value);\n-            self.unify(node_a, node_b, new_value);\n+            self.unify(node_a, node_b, new_value)\n+        } else {\n+            a_id\n         }\n     }\n \n@@ -290,14 +293,14 @@ impl<'tcx, K, V> UnificationTable<K>\n     where K: UnifyKey<Value = Option<V>>,\n           V: Clone + PartialEq + Debug\n {\n-    pub fn unify_var_var(&mut self, a_id: K, b_id: K) -> Result<(), (V, V)> {\n+    pub fn unify_var_var(&mut self, a_id: K, b_id: K) -> Result<K, (V, V)> {\n         let node_a = self.get(a_id);\n         let node_b = self.get(b_id);\n         let a_id = node_a.key();\n         let b_id = node_b.key();\n \n         if a_id == b_id {\n-            return Ok(());\n+            return Ok(a_id);\n         }\n \n         let combined = {"}, {"sha": "8f6457d820a84593fe3b19a3a539d6d81c226d65", "filename": "src/test/run-pass/bench/issue-32062.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Ftest%2Frun-pass%2Fbench%2Fissue-32062.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21922e1f48b263b39498cfeec79c1ca3f5886efe/src%2Ftest%2Frun-pass%2Fbench%2Fissue-32062.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbench%2Fissue-32062.rs?ref=21922e1f48b263b39498cfeec79c1ca3f5886efe", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pretty-expanded FIXME #23616\n+\n+fn main() {\n+    let _ = test(Some(0).into_iter());\n+}\n+\n+trait Parser {\n+    type Input: Iterator;\n+    type Output;\n+    fn parse(self, input: Self::Input) -> Result<(Self::Output, Self::Input), ()>;\n+    fn chain<P>(self, p: P) -> Chain<Self, P> where Self: Sized {\n+        Chain(self, p)\n+    }\n+}\n+\n+struct Token<T>(T::Item) where T: Iterator;\n+\n+impl<T> Parser for Token<T> where T: Iterator {\n+    type Input = T;\n+    type Output = T::Item;\n+    fn parse(self, _input: Self::Input) -> Result<(Self::Output, Self::Input), ()> {\n+        Err(())\n+    }\n+}\n+\n+struct Chain<L, R>(L, R);\n+\n+impl<L, R> Parser for Chain<L, R> where L: Parser, R: Parser<Input = L::Input> {\n+    type Input = L::Input;\n+    type Output = (L::Output, R::Output);\n+    fn parse(self, _input: Self::Input) -> Result<(Self::Output, Self::Input), ()> {\n+        Err(())\n+    }\n+}\n+\n+fn test<I>(i: I) -> Result<((), I), ()> where I: Iterator<Item = i32> {\n+    Chain(Token(0), Token(1))\n+        .chain(Chain(Token(0), Token(1)))\n+        .chain(Chain(Token(0), Token(1)))\n+        .chain(Chain(Token(0), Token(1)))\n+        .chain(Chain(Token(0), Token(1)))\n+        .chain(Chain(Token(0), Token(1)))\n+        .chain(Chain(Token(0), Token(1)))\n+        .chain(Chain(Token(0), Token(1)))\n+        .chain(Chain(Token(0), Token(1)))\n+        .parse(i)\n+        .map(|(_, i)| ((), i))\n+}"}]}