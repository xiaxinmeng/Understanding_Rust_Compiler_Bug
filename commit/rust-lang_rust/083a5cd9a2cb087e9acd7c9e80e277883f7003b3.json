{"sha": "083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4M2E1Y2Q5YTJjYjA4N2U5YWNkN2M5ZTgwZTI3Nzg4M2Y3MDAzYjM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-10-26T02:09:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-26T02:09:06Z"}, "message": "Rollup merge of #78214 - estebank:match-semicolon, r=oli-obk\n\nTweak match arm semicolon removal suggestion to account for futures\n\n* Tweak and extend \"use `.await`\" suggestions\n* Suggest removal of semicolon on prior match arm\n* Account for `impl Future` when suggesting semicolon removal\n* Silence some errors when encountering `await foo()?` as can't be certain what the intent was\n\n*Thanks to https://twitter.com/a_hoverbear/status/1318960787105353728 for pointing this out!*", "tree": {"sha": "1d6b485d650276f49b81948719e3f499d6ba83a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d6b485d650276f49b81948719e3f499d6ba83a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfli/CCRBK7hj4Ov3rIwAAdHIIAGSxWJ8FxSuvpJCgH3kLBF1C\nSrIsAG8jDl410WclCHO5GeTm3i7CPuxHIpzKRx6P8nWNiJpL+JQuVvb+hgZi0ADH\nu7rTdV3QGliGnrSLcxWP1XGhj68EGH6hzPacX0GDFJuTPbmGsY1mHlGrxeqUVLO0\nMZX7C/HoFBbhAXBV/zrFHX8MADoKAuUUoYosRc397yhQL5wYW3h1UCGqtkogptK8\nR/eVE6qGDhACAXkF9ScoJI5dMIljO3asKn+op8sewvAai6a48w4z3s8hi3u716+g\nikXc+gLNaaIRu5rZKFDD3QVx3GCAL6gmFVsHtkkhNMms9UCqWMlp40Z8DgOiyZs=\n=Yf3+\n-----END PGP SIGNATURE-----\n", "payload": "tree 1d6b485d650276f49b81948719e3f499d6ba83a2\nparent 9e907d420e44cd91bf0a5ee421be26f537261a22\nparent f5d7443a6bd90b78e61b9c47e5032b5e1be1e49f\nauthor Dylan DPC <dylan.dpc@gmail.com> 1603678146 +0100\ncommitter GitHub <noreply@github.com> 1603678146 +0100\n\nRollup merge of #78214 - estebank:match-semicolon, r=oli-obk\n\nTweak match arm semicolon removal suggestion to account for futures\n\n* Tweak and extend \"use `.await`\" suggestions\n* Suggest removal of semicolon on prior match arm\n* Account for `impl Future` when suggesting semicolon removal\n* Silence some errors when encountering `await foo()?` as can't be certain what the intent was\n\n*Thanks to https://twitter.com/a_hoverbear/status/1318960787105353728 for pointing this out!*\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "html_url": "https://github.com/rust-lang/rust/commit/083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e907d420e44cd91bf0a5ee421be26f537261a22", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e907d420e44cd91bf0a5ee421be26f537261a22", "html_url": "https://github.com/rust-lang/rust/commit/9e907d420e44cd91bf0a5ee421be26f537261a22"}, {"sha": "f5d7443a6bd90b78e61b9c47e5032b5e1be1e49f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5d7443a6bd90b78e61b9c47e5032b5e1be1e49f", "html_url": "https://github.com/rust-lang/rust/commit/f5d7443a6bd90b78e61b9c47e5032b5e1be1e49f"}], "stats": {"total": 885, "additions": 567, "deletions": 318}, "files": [{"sha": "f7e4ace8fc5fcadf499d65fc81c56c58702c2aa9", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 171, "deletions": 52, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -50,10 +50,10 @@ use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n use crate::infer;\n-use crate::infer::OriginalQueryValues;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n+    StatementAsExpression,\n };\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -64,7 +64,6 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Item, ItemKind, Node};\n use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::ParamEnvAnd;\n use rustc_middle::ty::{\n     self,\n     subst::{Subst, SubstsRef},\n@@ -688,13 +687,36 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     };\n                     let msg = \"`match` arms have incompatible types\";\n                     err.span_label(outer_error_span, msg);\n-                    if let Some(sp) = semi_span {\n-                        err.span_suggestion_short(\n-                            sp,\n-                            \"consider removing this semicolon\",\n-                            String::new(),\n-                            Applicability::MachineApplicable,\n-                        );\n+                    if let Some((sp, boxed)) = semi_span {\n+                        if let (StatementAsExpression::NeedsBoxing, [.., prior_arm]) =\n+                            (boxed, &prior_arms[..])\n+                        {\n+                            err.multipart_suggestion(\n+                                \"consider removing this semicolon and boxing the expressions\",\n+                                vec![\n+                                    (prior_arm.shrink_to_lo(), \"Box::new(\".to_string()),\n+                                    (prior_arm.shrink_to_hi(), \")\".to_string()),\n+                                    (arm_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                                    (arm_span.shrink_to_hi(), \")\".to_string()),\n+                                    (sp, String::new()),\n+                                ],\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        } else if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n+                            err.span_suggestion_short(\n+                                sp,\n+                                \"consider removing this semicolon and boxing the expressions\",\n+                                String::new(),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.span_suggestion_short(\n+                                sp,\n+                                \"consider removing this semicolon\",\n+                                String::new(),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n                     }\n                     if let Some(ret_sp) = opt_suggest_box_span {\n                         // Get return type span and point to it.\n@@ -717,13 +739,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if let Some(sp) = outer {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n                 }\n-                if let Some(sp) = semicolon {\n-                    err.span_suggestion_short(\n-                        sp,\n-                        \"consider removing this semicolon\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n+                if let Some((sp, boxed)) = semicolon {\n+                    if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n+                        err.multipart_suggestion(\n+                            \"consider removing this semicolon and boxing the expression\",\n+                            vec![\n+                                (then.shrink_to_lo(), \"Box::new(\".to_string()),\n+                                (then.shrink_to_hi(), \")\".to_string()),\n+                                (else_sp.shrink_to_lo(), \"Box::new(\".to_string()),\n+                                (else_sp.shrink_to_hi(), \")\".to_string()),\n+                                (sp, String::new()),\n+                            ],\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        err.span_suggestion_short(\n+                            sp,\n+                            \"consider removing this semicolon\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n                 }\n                 if let Some(ret_sp) = opt_suggest_box_span {\n                     self.suggest_boxing_for_return_impl_trait(\n@@ -1602,6 +1638,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             Mismatch::Variable(exp_found) => Some(exp_found),\n             Mismatch::Fixed(_) => None,\n         };\n+        let exp_found = match terr {\n+            // `terr` has more accurate type information than `exp_found` in match expressions.\n+            ty::error::TypeError::Sorts(terr)\n+                if exp_found.map_or(false, |ef| terr.found == ef.found) =>\n+            {\n+                Some(*terr)\n+            }\n+            _ => exp_found,\n+        };\n+        debug!(\"exp_found {:?} terr {:?}\", exp_found, terr);\n         if let Some(exp_found) = exp_found {\n             self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n             self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n@@ -1623,6 +1669,53 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.note_error_origin(diag, cause, exp_found);\n     }\n \n+    fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+        if let ty::Opaque(def_id, substs) = ty.kind() {\n+            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n+            // Future::Output\n+            let item_def_id = self\n+                .tcx\n+                .associated_items(future_trait)\n+                .in_definition_order()\n+                .next()\n+                .unwrap()\n+                .def_id;\n+\n+            let bounds = self.tcx.explicit_item_bounds(*def_id);\n+\n+            for (predicate, _) in bounds {\n+                let predicate = predicate.subst(self.tcx, substs);\n+                if let ty::PredicateAtom::Projection(projection_predicate) =\n+                    predicate.skip_binders()\n+                {\n+                    if projection_predicate.projection_ty.item_def_id == item_def_id {\n+                        // We don't account for multiple `Future::Output = Ty` contraints.\n+                        return Some(projection_predicate.ty);\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    /// A possible error is to forget to add `.await` when using futures:\n+    ///\n+    /// ```\n+    /// async fn make_u32() -> u32 {\n+    ///     22\n+    /// }\n+    ///\n+    /// fn take_u32(x: u32) {}\n+    ///\n+    /// async fn foo() {\n+    ///     let x = make_u32();\n+    ///     take_u32(x);\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n+    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n+    /// `.await` to the tail of the expression.\n     fn suggest_await_on_expect_found(\n         &self,\n         cause: &ObligationCause<'tcx>,\n@@ -1632,50 +1725,76 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         debug!(\n             \"suggest_await_on_expect_found: exp_span={:?}, expected_ty={:?}, found_ty={:?}\",\n-            exp_span, exp_found.expected, exp_found.found\n+            exp_span, exp_found.expected, exp_found.found,\n         );\n \n-        if let ty::Opaque(def_id, _) = *exp_found.expected.kind() {\n-            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n-            // Future::Output\n-            let item_def_id = self\n-                .tcx\n-                .associated_items(future_trait)\n-                .in_definition_order()\n-                .next()\n-                .unwrap()\n-                .def_id;\n+        if let ObligationCauseCode::CompareImplMethodObligation { .. } = &cause.code {\n+            return;\n+        }\n \n-            let projection_ty = self.tcx.projection_ty_from_predicates((def_id, item_def_id));\n-            if let Some(projection_ty) = projection_ty {\n-                let projection_query = self.canonicalize_query(\n-                    &ParamEnvAnd { param_env: self.tcx.param_env(def_id), value: projection_ty },\n-                    &mut OriginalQueryValues::default(),\n-                );\n-                if let Ok(resp) = self.tcx.normalize_projection_ty(projection_query) {\n-                    let normalized_ty = resp.value.value.normalized_ty;\n-                    debug!(\"suggest_await_on_expect_found: normalized={:?}\", normalized_ty);\n-                    if ty::TyS::same_type(normalized_ty, exp_found.found) {\n-                        let span = if let ObligationCauseCode::Pattern {\n-                            span,\n-                            origin_expr: _,\n-                            root_ty: _,\n-                        } = cause.code\n-                        {\n-                            // scrutinee's span\n-                            span.unwrap_or(exp_span)\n-                        } else {\n-                            exp_span\n-                        };\n-                        diag.span_suggestion_verbose(\n-                            span.shrink_to_hi(),\n-                            \"consider awaiting on the future\",\n-                            \".await\".to_string(),\n+        match (\n+            self.get_impl_future_output_ty(exp_found.expected),\n+            self.get_impl_future_output_ty(exp_found.found),\n+        ) {\n+            (Some(exp), Some(found)) if ty::TyS::same_type(exp, found) => match &cause.code {\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then, .. }) => {\n+                    diag.multipart_suggestion(\n+                        \"consider `await`ing on both `Future`s\",\n+                        vec![\n+                            (then.shrink_to_hi(), \".await\".to_string()),\n+                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                    prior_arms,\n+                    ..\n+                }) => {\n+                    if let [.., arm_span] = &prior_arms[..] {\n+                        diag.multipart_suggestion(\n+                            \"consider `await`ing on both `Future`s\",\n+                            vec![\n+                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n+                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                            ],\n                             Applicability::MaybeIncorrect,\n                         );\n+                    } else {\n+                        diag.help(\"consider `await`ing on both `Future`s\");\n                     }\n                 }\n+                _ => {\n+                    diag.help(\"consider `await`ing on both `Future`s\");\n+                }\n+            },\n+            (_, Some(ty)) if ty::TyS::same_type(exp_found.expected, ty) => {\n+                let span = match cause.code {\n+                    // scrutinee's span\n+                    ObligationCauseCode::Pattern { span: Some(span), .. } => span,\n+                    _ => exp_span,\n+                };\n+                diag.span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    \"consider `await`ing on the `Future`\",\n+                    \".await\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            (Some(ty), _) if ty::TyS::same_type(ty, exp_found.found) => {\n+                let span = match cause.code {\n+                    // scrutinee's span\n+                    ObligationCauseCode::Pattern { span: Some(span), .. } => span,\n+                    _ => exp_span,\n+                };\n+                diag.span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    \"consider `await`ing on the `Future`\",\n+                    \".await\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n             }\n+            _ => {}\n         }\n     }\n "}, {"sha": "4deb7225dcb61db4e6cb7a1b0f28181a5c8d8f4c", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -340,11 +340,24 @@ impl ObligationCauseCode<'_> {\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(ObligationCauseCode<'_>, 32);\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum StatementAsExpression {\n+    CorrectType,\n+    NeedsBoxing,\n+}\n+\n+impl<'tcx> ty::Lift<'tcx> for StatementAsExpression {\n+    type Lifted = StatementAsExpression;\n+    fn lift_to_tcx(self, _tcx: TyCtxt<'tcx>) -> Option<StatementAsExpression> {\n+        Some(self)\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct MatchExpressionArmCause<'tcx> {\n     pub arm_span: Span,\n     pub scrut_span: Span,\n-    pub semi_span: Option<Span>,\n+    pub semi_span: Option<(Span, StatementAsExpression)>,\n     pub source: hir::MatchSource,\n     pub prior_arms: Vec<Span>,\n     pub last_ty: Ty<'tcx>,\n@@ -357,7 +370,7 @@ pub struct IfExpressionCause {\n     pub then: Span,\n     pub else_sp: Span,\n     pub outer: Option<Span>,\n-    pub semicolon: Option<Span>,\n+    pub semicolon: Option<(Span, StatementAsExpression)>,\n     pub opt_suggest_box_span: Option<Span>,\n }\n "}, {"sha": "5ec0ec0c56ad64b25d1effd7be08cd76139d08d7", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -334,26 +334,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug!(\"note_and_explain_type_err err={:?} cause={:?}\", err, cause);\n         match err {\n             Sorts(values) => {\n-                let expected_str = values.expected.sort_string(self);\n-                let found_str = values.found.sort_string(self);\n-                if expected_str == found_str && expected_str == \"closure\" {\n-                    db.note(\"no two closures, even if identical, have the same type\");\n-                    db.help(\"consider boxing your closure and/or using it as a trait object\");\n-                }\n-                if expected_str == found_str && expected_str == \"opaque type\" {\n-                    // Issue #63167\n-                    db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n-                    let e_str = values.expected.to_string();\n-                    let f_str = values.found.to_string();\n-                    if e_str == f_str && &e_str == \"impl std::future::Future\" {\n-                        // FIXME: use non-string based check.\n-                        db.help(\n-                            \"if both `Future`s have the same `Output` type, consider \\\n-                                 `.await`ing on both of them\",\n-                        );\n-                    }\n-                }\n                 match (values.expected.kind(), values.found.kind()) {\n+                    (ty::Closure(..), ty::Closure(..)) => {\n+                        db.note(\"no two closures, even if identical, have the same type\");\n+                        db.help(\"consider boxing your closure and/or using it as a trait object\");\n+                    }\n+                    (ty::Opaque(..), ty::Opaque(..)) => {\n+                        // Issue #63167\n+                        db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n+                    }\n                     (ty::Float(_), ty::Infer(ty::IntVar(_))) => {\n                         if let Ok(\n                             // Issue #53280\n@@ -382,12 +371,12 @@ impl<'tcx> TyCtxt<'tcx> {\n                         }\n                         db.note(\n                             \"a type parameter was expected, but a different one was found; \\\n-                                 you might be missing a type parameter or trait bound\",\n+                             you might be missing a type parameter or trait bound\",\n                         );\n                         db.note(\n                             \"for more information, visit \\\n-                                 https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                                 #traits-as-parameters\",\n+                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                             #traits-as-parameters\",\n                         );\n                     }\n                     (ty::Projection(_), ty::Projection(_)) => {\n@@ -471,8 +460,8 @@ impl<T> Trait<T> for X {\n                         }\n                         db.note(\n                             \"for more information, visit \\\n-                                 https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                                 #traits-as-parameters\",\n+                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                             #traits-as-parameters\",\n                         );\n                     }\n                     (ty::Param(p), ty::Closure(..) | ty::Generator(..)) => {"}, {"sha": "39e1256a578353840630c91e8fe9a18170785faa", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -1207,7 +1207,13 @@ impl<'a> Parser<'a> {\n             self.recover_await_prefix(await_sp)?\n         };\n         let sp = self.error_on_incorrect_await(lo, hi, &expr, is_question);\n-        let expr = self.mk_expr(lo.to(sp), ExprKind::Await(expr), attrs);\n+        let kind = match expr.kind {\n+            // Avoid knock-down errors as we don't know whether to interpret this as `foo().await?`\n+            // or `foo()?.await` (the very reason we went with postfix syntax \ud83d\ude05).\n+            ExprKind::Try(_) => ExprKind::Err,\n+            _ => ExprKind::Await(expr),\n+        };\n+        let expr = self.mk_expr(lo.to(sp), kind, attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n "}, {"sha": "fa837e04db35eaa4c42cb8351703ffb8d982f757", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::ty::{\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use std::fmt;\n \n@@ -2114,10 +2114,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 if self.predicate_may_hold(&try_obligation) && impls_future {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.ends_with('?') {\n-                            err.span_suggestion(\n-                                span,\n-                                \"consider using `.await` here\",\n-                                format!(\"{}.await?\", snippet.trim_end_matches('?')),\n+                            err.span_suggestion_verbose(\n+                                span.with_hi(span.hi() - BytePos(1)).shrink_to_hi(),\n+                                \"consider `await`ing on the `Future`\",\n+                                \".await\".to_string(),\n                                 Applicability::MaybeIncorrect,\n                             );\n                         }"}, {"sha": "e8eea65137ff7041757fabc4c66ccb5c0053f833", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -9,6 +9,7 @@ use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n+    StatementAsExpression,\n };\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -188,11 +189,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             } else {\n-                let (arm_span, semi_span) = if let hir::ExprKind::Block(blk, _) = &arm.body.kind {\n-                    self.find_block_span(blk, prior_arm_ty)\n-                } else {\n-                    (arm.body.span, None)\n-                };\n+                let (arm_span, semi_span) =\n+                    self.get_appropriate_arm_semicolon_removal_span(&arms, i, prior_arm_ty, arm_ty);\n                 let (span, code) = match i {\n                     // The reason for the first arm to fail is not that the match arms diverge,\n                     // but rather that there's a prior obligation that doesn't hold.\n@@ -242,6 +240,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         coercion.complete(self)\n     }\n \n+    fn get_appropriate_arm_semicolon_removal_span(\n+        &self,\n+        arms: &'tcx [hir::Arm<'tcx>],\n+        i: usize,\n+        prior_arm_ty: Option<Ty<'tcx>>,\n+        arm_ty: Ty<'tcx>,\n+    ) -> (Span, Option<(Span, StatementAsExpression)>) {\n+        let arm = &arms[i];\n+        let (arm_span, mut semi_span) = if let hir::ExprKind::Block(blk, _) = &arm.body.kind {\n+            self.find_block_span(blk, prior_arm_ty)\n+        } else {\n+            (arm.body.span, None)\n+        };\n+        if semi_span.is_none() && i > 0 {\n+            if let hir::ExprKind::Block(blk, _) = &arms[i - 1].body.kind {\n+                let (_, semi_span_prev) = self.find_block_span(blk, Some(arm_ty));\n+                semi_span = semi_span_prev;\n+            }\n+        }\n+        (arm_span, semi_span)\n+    }\n+\n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n     fn warn_arms_when_scrutinee_diverges(\n@@ -514,7 +534,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         block: &'tcx hir::Block<'tcx>,\n         expected_ty: Option<Ty<'tcx>>,\n-    ) -> (Span, Option<Span>) {\n+    ) -> (Span, Option<(Span, StatementAsExpression)>) {\n         if let Some(expr) = &block.expr {\n             (expr.span, None)\n         } else if let Some(stmt) = block.stmts.last() {"}, {"sha": "241803fab1e68b7b8b994057b45fa3386bd6cae5", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -33,7 +33,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n         self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty);\n-        self.suggest_missing_await(err, expr, expected, expr_ty);\n         self.suggest_missing_parentheses(err, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);"}, {"sha": "f87e6b607d46e5d168dd1b709301e88ce0a62bbc", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -33,7 +33,9 @@ use rustc_span::{self, BytePos, MultiSpan, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCauseCode, TraitEngine, TraitEngineExt};\n+use rustc_trait_selection::traits::{\n+    self, ObligationCauseCode, StatementAsExpression, TraitEngine, TraitEngineExt,\n+};\n \n use std::collections::hash_map::Entry;\n use std::slice;\n@@ -1061,7 +1063,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         blk: &'tcx hir::Block<'tcx>,\n         expected_ty: Ty<'tcx>,\n-    ) -> Option<Span> {\n+    ) -> Option<(Span, StatementAsExpression)> {\n         // Be helpful when the user wrote `{... expr;}` and\n         // taking the `;` off is enough to fix the error.\n         let last_stmt = blk.stmts.last()?;\n@@ -1070,13 +1072,58 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => return None,\n         };\n         let last_expr_ty = self.node_ty(last_expr.hir_id);\n-        if matches!(last_expr_ty.kind(), ty::Error(_))\n-            || self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err()\n+        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n+            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n+                debug!(\n+                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n+                    last_def_id, last_bounds, exp_def_id, exp_bounds\n+                );\n+                let last_hir_id = self.tcx.hir().local_def_id_to_hir_id(last_def_id.expect_local());\n+                let exp_hir_id = self.tcx.hir().local_def_id_to_hir_id(exp_def_id.expect_local());\n+                match (\n+                    &self.tcx.hir().expect_item(last_hir_id).kind,\n+                    &self.tcx.hir().expect_item(exp_hir_id).kind,\n+                ) {\n+                    (\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n+                    ) if last_bounds.iter().zip(exp_bounds.iter()).all(|(left, right)| {\n+                        match (left, right) {\n+                            (\n+                                hir::GenericBound::Trait(tl, ml),\n+                                hir::GenericBound::Trait(tr, mr),\n+                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n+                                && ml == mr =>\n+                            {\n+                                true\n+                            }\n+                            (\n+                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n+                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n+                            ) if langl == langr => {\n+                                // FIXME: consider the bounds!\n+                                debug!(\"{:?} {:?}\", argsl, argsr);\n+                                true\n+                            }\n+                            _ => false,\n+                        }\n+                    }) =>\n+                    {\n+                        StatementAsExpression::NeedsBoxing\n+                    }\n+                    _ => StatementAsExpression::CorrectType,\n+                }\n+            }\n+            _ => StatementAsExpression::CorrectType,\n+        };\n+        if (matches!(last_expr_ty.kind(), ty::Error(_))\n+            || self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err())\n+            && matches!(needs_box, StatementAsExpression::CorrectType)\n         {\n             return None;\n         }\n         let original_span = original_sp(last_stmt.span, blk.span);\n-        Some(original_span.with_lo(original_span.hi() - BytePos(1)))\n+        Some((original_span.with_lo(original_span.hi() - BytePos(1)), needs_box))\n     }\n \n     // Instantiates the given path, which must refer to an item with the given"}, {"sha": "a820661d8432a0d17b0ac50d9c66ed0b5eda813f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::ty::{self, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{self, MultiSpan, Span};\n-use rustc_trait_selection::traits::{self, ObligationCauseCode};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode, StatementAsExpression};\n \n use std::mem::replace;\n use std::slice;\n@@ -758,13 +758,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n-        if let Some(span_semi) = self.could_remove_semicolon(blk, expected_ty) {\n-            err.span_suggestion(\n-                span_semi,\n-                \"consider removing this semicolon\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n+        if let Some((span_semi, boxed)) = self.could_remove_semicolon(blk, expected_ty) {\n+            if let StatementAsExpression::NeedsBoxing = boxed {\n+                err.span_suggestion_verbose(\n+                    span_semi,\n+                    \"consider removing this semicolon and boxing the expression\",\n+                    String::new(),\n+                    Applicability::HasPlaceholders,\n+                );\n+            } else {\n+                err.span_suggestion_short(\n+                    span_semi,\n+                    \"consider removing this semicolon\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n         }\n     }\n "}, {"sha": "a8ad9f4fdf8af01ac6031e56ca57c1b7079a502a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -3,7 +3,6 @@ use crate::astconv::AstConv;\n \n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_span::{self, Span};\n-use rustc_trait_selection::traits;\n \n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -13,7 +12,6 @@ use rustc_hir::{ExprKind, ItemKind, Node};\n use rustc_infer::infer;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::kw;\n-use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n use std::iter;\n \n@@ -433,87 +431,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// A possible error is to forget to add `.await` when using futures:\n-    ///\n-    /// ```\n-    /// async fn make_u32() -> u32 {\n-    ///     22\n-    /// }\n-    ///\n-    /// fn take_u32(x: u32) {}\n-    ///\n-    /// async fn foo() {\n-    ///     let x = make_u32();\n-    ///     take_u32(x);\n-    /// }\n-    /// ```\n-    ///\n-    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n-    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n-    /// `.await` to the tail of the expression.\n-    pub(in super::super) fn suggest_missing_await(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n-        found: Ty<'tcx>,\n-    ) {\n-        debug!(\"suggest_missing_await: expr={:?} expected={:?}, found={:?}\", expr, expected, found);\n-        // `.await` is not permitted outside of `async` bodies, so don't bother to suggest if the\n-        // body isn't `async`.\n-        let item_id = self.tcx().hir().get_parent_node(self.body_id);\n-        if let Some(body_id) = self.tcx().hir().maybe_body_owned_by(item_id) {\n-            let body = self.tcx().hir().body(body_id);\n-            if let Some(hir::GeneratorKind::Async(_)) = body.generator_kind {\n-                let sp = expr.span;\n-                // Check for `Future` implementations by constructing a predicate to\n-                // prove: `<T as Future>::Output == U`\n-                let future_trait = self.tcx.require_lang_item(LangItem::Future, Some(sp));\n-                let item_def_id = self\n-                    .tcx\n-                    .associated_items(future_trait)\n-                    .in_definition_order()\n-                    .next()\n-                    .unwrap()\n-                    .def_id;\n-                // `<T as Future>::Output`\n-                let projection_ty = ty::ProjectionTy {\n-                    // `T`\n-                    substs: self\n-                        .tcx\n-                        .mk_substs_trait(found, self.fresh_substs_for_item(sp, item_def_id)),\n-                    // `Future::Output`\n-                    item_def_id,\n-                };\n-\n-                let predicate = ty::PredicateAtom::Projection(ty::ProjectionPredicate {\n-                    projection_ty,\n-                    ty: expected,\n-                })\n-                .potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n-                let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n-\n-                debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);\n-\n-                if self.infcx.predicate_may_hold(&obligation) {\n-                    debug!(\"suggest_missing_await: obligation held: {:?}\", obligation);\n-                    if let Ok(code) = self.sess().source_map().span_to_snippet(sp) {\n-                        err.span_suggestion(\n-                            sp,\n-                            \"consider using `.await` here\",\n-                            format!(\"{}.await\", code),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        debug!(\"suggest_missing_await: no snippet for {:?}\", sp);\n-                    }\n-                } else {\n-                    debug!(\"suggest_missing_await: obligation did not hold: {:?}\", obligation)\n-                }\n-            }\n-        }\n-    }\n-\n     pub(in super::super) fn suggest_missing_parentheses(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,"}, {"sha": "554ac673d515599a4a230ed1f04110d806116a4d", "filename": "src/test/ui/async-await/await-keyword/incorrect-syntax-suggestions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -14,7 +14,6 @@ async fn foo2() -> Result<(), ()> {\n }\n async fn foo3() -> Result<(), ()> {\n     let _ = await bar()?; //~ ERROR incorrect use of `await`\n-    //~^ ERROR the `?` operator can only be applied to values that implement `Try`\n     Ok(())\n }\n async fn foo21() -> Result<(), ()> {\n@@ -60,9 +59,7 @@ fn foo10() -> Result<(), ()> {\n     Ok(())\n }\n fn foo11() -> Result<(), ()> {\n-    let _ = await bar()?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n-    //~^ ERROR incorrect use of `await`\n-    //~| ERROR the `?` operator can only be applied to values that implement `Try`\n+    let _ = await bar()?; //~ ERROR incorrect use of `await`\n     Ok(())\n }\n fn foo12() -> Result<(), ()> {"}, {"sha": "52615df6008ffbcdbc75d7f0152d52536aa5e036", "filename": "src/test/ui/async-await/await-keyword/incorrect-syntax-suggestions.stderr", "status": "modified", "additions": 32, "deletions": 62, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -17,117 +17,117 @@ LL |     let _ = await bar()?;\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar()?.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:21:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:20:13\n    |\n LL |     let _ = await { bar() };\n    |             ^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ bar() }.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:25:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:24:13\n    |\n LL |     let _ = await(bar());\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `(bar()).await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:29:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:28:13\n    |\n LL |     let _ = await { bar() }?;\n    |             ^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ bar() }.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:33:14\n+  --> $DIR/incorrect-syntax-suggestions.rs:32:14\n    |\n LL |     let _ = (await bar())?;\n    |              ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:37:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:36:24\n    |\n LL |     let _ = bar().await();\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:41:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:40:24\n    |\n LL |     let _ = bar().await()?;\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:53:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:52:13\n    |\n LL |     let _ = await bar();\n    |             ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:58:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:57:13\n    |\n LL |     let _ = await? bar();\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await?`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:63:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:62:13\n    |\n LL |     let _ = await bar()?;\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar()?.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:69:14\n+  --> $DIR/incorrect-syntax-suggestions.rs:66:14\n    |\n LL |     let _ = (await bar())?;\n    |              ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:74:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:71:24\n    |\n LL |     let _ = bar().await();\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:79:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:76:24\n    |\n LL |     let _ = bar().await()?;\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:107:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:104:13\n    |\n LL |     let _ = await!(bar());\n    |             ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:111:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:108:13\n    |\n LL |     let _ = await!(bar())?;\n    |             ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:116:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:113:17\n    |\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:124:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:121:17\n    |\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: expected expression, found `=>`\n-  --> $DIR/incorrect-syntax-suggestions.rs:132:25\n+  --> $DIR/incorrect-syntax-suggestions.rs:129:25\n    |\n LL |     match await { await => () }\n    |                   ----- ^^ expected expression\n    |                   |\n    |                   while parsing this incorrect await expression\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:132:11\n+  --> $DIR/incorrect-syntax-suggestions.rs:129:11\n    |\n LL |     match await { await => () }\n    |           ^^^^^^^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ await => () }.await`\n \n error: expected one of `.`, `?`, `{`, or an operator, found `}`\n-  --> $DIR/incorrect-syntax-suggestions.rs:135:1\n+  --> $DIR/incorrect-syntax-suggestions.rs:132:1\n    |\n LL |     match await { await => () }\n    |     -----                      - expected one of `.`, `?`, `{`, or an operator\n@@ -138,123 +138,93 @@ LL | }\n    | ^ unexpected token\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:53:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:52:13\n    |\n LL | fn foo9() -> Result<(), ()> {\n    |    ---- this is not `async`\n LL |     let _ = await bar();\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:58:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:57:13\n    |\n LL | fn foo10() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = await? bar();\n    |             ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:63:13\n-   |\n-LL | fn foo11() -> Result<(), ()> {\n-   |    ----- this is not `async`\n-LL |     let _ = await bar()?;\n-   |             ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n-\n-error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:69:14\n+  --> $DIR/incorrect-syntax-suggestions.rs:66:14\n    |\n LL | fn foo12() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = (await bar())?;\n    |              ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:74:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:71:13\n    |\n LL | fn foo13() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await();\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:79:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:76:13\n    |\n LL | fn foo14() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await()?;\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:84:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:81:13\n    |\n LL | fn foo15() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await;\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:88:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:85:13\n    |\n LL | fn foo16() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await?;\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:93:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:90:17\n    |\n LL |     fn foo() -> Result<(), ()> {\n    |        --- this is not `async`\n LL |         let _ = bar().await?;\n    |                 ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:100:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:97:17\n    |\n LL |     let foo = || {\n    |               -- this is not `async`\n LL |         let _ = bar().await?;\n    |                 ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:116:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:113:17\n    |\n LL |     fn foo() -> Result<(), ()> {\n    |        --- this is not `async`\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:124:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:121:17\n    |\n LL |     let foo = || {\n    |               -- this is not `async`\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n-error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/incorrect-syntax-suggestions.rs:16:19\n-   |\n-LL |     let _ = await bar()?;\n-   |                   ^^^^^^\n-   |                   |\n-   |                   the `?` operator cannot be applied to type `impl Future`\n-   |                   help: consider using `.await` here: `bar().await?`\n-   |\n-   = help: the trait `Try` is not implemented for `impl Future`\n-   = note: required by `into_result`\n-\n-error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/incorrect-syntax-suggestions.rs:63:19\n-   |\n-LL |     let _ = await bar()?;\n-   |                   ^^^^^^ the `?` operator cannot be applied to type `impl Future`\n-   |\n-   = help: the trait `Try` is not implemented for `impl Future`\n-   = note: required by `into_result`\n-\n-error: aborting due to 36 previous errors\n+error: aborting due to 33 previous errors\n \n-Some errors have detailed explanations: E0277, E0728.\n-For more information about an error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0728`."}, {"sha": "14e72c2b1e7e2a757a514dc33db3aaaffb7a618c", "filename": "src/test/ui/async-await/dont-suggest-missing-await.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -9,6 +9,10 @@ LL |         take_u32(x)\n    |\n    = note:     expected type `u32`\n            found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |         take_u32(x.await)\n+   |                   ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "df54ac88acee1e427a388ee09ee974438a7b37ae", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -2,25 +2,27 @@ error[E0277]: the `?` operator can only be applied to values that implement `Try\n   --> $DIR/issue-61076.rs:42:5\n    |\n LL |     foo()?;\n-   |     ^^^^^^\n-   |     |\n-   |     the `?` operator cannot be applied to type `impl Future`\n-   |     help: consider using `.await` here: `foo().await?`\n+   |     ^^^^^^ the `?` operator cannot be applied to type `impl Future`\n    |\n    = help: the trait `Try` is not implemented for `impl Future`\n    = note: required by `into_result`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     foo().await?;\n+   |          ^^^^^^\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n   --> $DIR/issue-61076.rs:56:5\n    |\n LL |     t?;\n-   |     ^^\n-   |     |\n-   |     the `?` operator cannot be applied to type `T`\n-   |     help: consider using `.await` here: `t.await?`\n+   |     ^^ the `?` operator cannot be applied to type `T`\n    |\n    = help: the trait `Try` is not implemented for `T`\n    = note: required by `into_result`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     t.await?;\n+   |      ^^^^^^\n \n error[E0609]: no field `0` on type `impl Future`\n   --> $DIR/issue-61076.rs:58:26\n@@ -51,6 +53,10 @@ LL |         Tuple(_) => {}\n    |\n    = note: expected opaque type `impl Future`\n                    found struct `Tuple`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     match tuple().await {\n+   |                  ^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "febcd0218426199e16831bc29e3c711437d0b18a", "filename": "src/test/ui/async-await/suggest-missing-await-closure.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.fixed?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -15,8 +15,8 @@ async fn suggest_await_in_async_closure() {\n         let x = make_u32();\n         take_u32(x.await)\n         //~^ ERROR mismatched types [E0308]\n-        //~| HELP consider using `.await` here\n-        //~| SUGGESTION x.await\n+        //~| HELP consider `await`ing on the `Future`\n+        //~| SUGGESTION .await\n     };\n }\n "}, {"sha": "faabf6ee3f16f1c06e19747d209d45df389254b1", "filename": "src/test/ui/async-await/suggest-missing-await-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -15,8 +15,8 @@ async fn suggest_await_in_async_closure() {\n         let x = make_u32();\n         take_u32(x)\n         //~^ ERROR mismatched types [E0308]\n-        //~| HELP consider using `.await` here\n-        //~| SUGGESTION x.await\n+        //~| HELP consider `await`ing on the `Future`\n+        //~| SUGGESTION .await\n     };\n }\n "}, {"sha": "2151057aa7fc0a8c70f908e9ba3d4b8622db0f12", "filename": "src/test/ui/async-await/suggest-missing-await-closure.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -5,13 +5,14 @@ LL | async fn make_u32() -> u32 {\n    |                        --- the `Output` of this `async fn`'s found opaque type\n ...\n LL |         take_u32(x)\n-   |                  ^\n-   |                  |\n-   |                  expected `u32`, found opaque type\n-   |                  help: consider using `.await` here: `x.await`\n+   |                  ^ expected `u32`, found opaque type\n    |\n    = note:     expected type `u32`\n            found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |         take_u32(x.await)\n+   |                   ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "1ec59d906206eada93ce9282dfd81e12afef9517", "filename": "src/test/ui/async-await/suggest-missing-await.fixed", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9e907d420e44cd91bf0a5ee421be26f537261a22/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9e907d420e44cd91bf0a5ee421be26f537261a22/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed?ref=9e907d420e44cd91bf0a5ee421be26f537261a22", "patch": "@@ -1,30 +0,0 @@\n-// edition:2018\n-// run-rustfix\n-\n-fn take_u32(_x: u32) {}\n-\n-async fn make_u32() -> u32 {\n-    22\n-}\n-\n-#[allow(unused)]\n-async fn suggest_await_in_async_fn() {\n-    let x = make_u32();\n-    take_u32(x.await)\n-    //~^ ERROR mismatched types [E0308]\n-    //~| HELP consider using `.await` here\n-    //~| SUGGESTION x.await\n-}\n-\n-async fn dummy() {}\n-\n-#[allow(unused)]\n-async fn suggest_await_in_async_fn_return() {\n-    dummy().await;\n-    //~^ ERROR mismatched types [E0308]\n-    //~| HELP try adding a semicolon\n-    //~| HELP consider using `.await` here\n-    //~| SUGGESTION dummy().await\n-}\n-\n-fn main() {}"}, {"sha": "d629054911dac16e7326d3c307c48da7c9fa9bfb", "filename": "src/test/ui/async-await/suggest-missing-await.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -1,5 +1,4 @@\n // edition:2018\n-// run-rustfix\n \n fn take_u32(_x: u32) {}\n \n@@ -12,8 +11,8 @@ async fn suggest_await_in_async_fn() {\n     let x = make_u32();\n     take_u32(x)\n     //~^ ERROR mismatched types [E0308]\n-    //~| HELP consider using `.await` here\n-    //~| SUGGESTION x.await\n+    //~| HELP consider `await`ing on the `Future`\n+    //~| SUGGESTION .await\n }\n \n async fn dummy() {}\n@@ -23,8 +22,8 @@ async fn suggest_await_in_async_fn_return() {\n     dummy()\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP try adding a semicolon\n-    //~| HELP consider using `.await` here\n-    //~| SUGGESTION dummy().await\n+    //~| HELP consider `await`ing on the `Future`\n+    //~| SUGGESTION .await\n }\n \n fn main() {}"}, {"sha": "46615dae7e2ba3b43c48505fac9baa0e10446ddb", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -1,20 +1,21 @@\n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:13:14\n+  --> $DIR/suggest-missing-await.rs:12:14\n    |\n LL | async fn make_u32() -> u32 {\n    |                        --- the `Output` of this `async fn`'s found opaque type\n ...\n LL |     take_u32(x)\n-   |              ^\n-   |              |\n-   |              expected `u32`, found opaque type\n-   |              help: consider using `.await` here: `x.await`\n+   |              ^ expected `u32`, found opaque type\n    |\n    = note:     expected type `u32`\n            found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     take_u32(x.await)\n+   |               ^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:23:5\n+  --> $DIR/suggest-missing-await.rs:22:5\n    |\n LL | async fn dummy() {}\n    |                  - the `Output` of this `async fn`'s found opaque type\n@@ -24,14 +25,14 @@ LL |     dummy()\n    |\n    = note: expected unit type `()`\n             found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     dummy().await\n+   |            ^^^^^^\n help: try adding a semicolon\n    |\n LL |     dummy();\n    |            ^\n-help: consider using `.await` here\n-   |\n-LL |     dummy().await\n-   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5c9c549fa0779ca0c7d78350938e907b3309f6ca", "filename": "src/test/ui/suggestions/issue-72766.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fsuggestions%2Fissue-72766.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fsuggestions%2Fissue-72766.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-72766.stderr?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -2,13 +2,14 @@ error[E0277]: the `?` operator can only be applied to values that implement `Try\n   --> $DIR/issue-72766.rs:14:5\n    |\n LL |     SadGirl {}.call()?;\n-   |     ^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     the `?` operator cannot be applied to type `impl Future`\n-   |     help: consider using `.await` here: `SadGirl {}.call().await?`\n+   |     ^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `impl Future`\n    |\n    = help: the trait `Try` is not implemented for `impl Future`\n    = note: required by `into_result`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     SadGirl {}.call().await?;\n+   |                      ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b8ac030b0bbbee86be6414265964c513aceb46c3", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -0,0 +1,57 @@\n+// edition:2018\n+\n+fn dummy() -> i32 { 42 }\n+\n+fn extra_semicolon() {\n+    let _ = match true { //~ NOTE `match` arms have incompatible types\n+        true => {\n+            dummy(); //~ NOTE this is found to be\n+            //~^ HELP consider removing this semicolon\n+        }\n+        false => dummy(), //~ ERROR `match` arms have incompatible types\n+        //~^ NOTE expected `()`, found `i32`\n+    };\n+}\n+\n+async fn async_dummy() {} //~ NOTE the `Output` of this `async fn`'s found opaque type\n+async fn async_dummy2() {} //~ NOTE the `Output` of this `async fn`'s found opaque type\n+//~^ NOTE the `Output` of this `async fn`'s found opaque type\n+\n+async fn async_extra_semicolon_same() {\n+    let _ = match true { //~ NOTE `match` arms have incompatible types\n+        true => {\n+            async_dummy(); //~ NOTE this is found to be\n+            //~^ HELP consider removing this semicolon\n+        }\n+        false => async_dummy(), //~ ERROR `match` arms have incompatible types\n+        //~^ NOTE expected `()`, found opaque type\n+        //~| NOTE expected type `()`\n+        //~| HELP consider `await`ing on the `Future`\n+    };\n+}\n+\n+async fn async_extra_semicolon_different() {\n+    let _ = match true { //~ NOTE `match` arms have incompatible types\n+        true => {\n+            async_dummy(); //~ NOTE this is found to be\n+            //~^ HELP consider removing this semicolon\n+        }\n+        false => async_dummy2(), //~ ERROR `match` arms have incompatible types\n+        //~^ NOTE expected `()`, found opaque type\n+        //~| NOTE expected type `()`\n+        //~| HELP consider `await`ing on the `Future`\n+    };\n+}\n+\n+async fn async_different_futures() {\n+    let _ = match true { //~ NOTE `match` arms have incompatible types\n+        true => async_dummy(), //~ NOTE this is found to be\n+        //~| HELP consider `await`ing on both `Future`s\n+        false => async_dummy2(), //~ ERROR `match` arms have incompatible types\n+        //~^ NOTE expected opaque type, found a different opaque type\n+        //~| NOTE expected type `impl Future`\n+        //~| NOTE distinct uses of `impl Trait` result in different opaque types\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "e9803a78f94b3c3571813648083bc03542b7d64e", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.stderr", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -0,0 +1,118 @@\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/match-prev-arm-needing-semi.rs:26:18\n+   |\n+LL |   async fn async_dummy() {}\n+   |                          - the `Output` of this `async fn`'s found opaque type\n+...\n+LL |       let _ = match true {\n+   |  _____________-\n+LL | |         true => {\n+LL | |             async_dummy();\n+   | |             -------------- this is found to be of type `()`\n+LL | |\n+LL | |         }\n+LL | |         false => async_dummy(),\n+   | |                  ^^^^^^^^^^^^^ expected `()`, found opaque type\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note:     expected type `()`\n+           found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |         false => async_dummy().await,\n+   |                               ^^^^^^\n+help: consider removing this semicolon and boxing the expressions\n+   |\n+LL |             Box::new(async_dummy())\n+LL |\n+LL |         }\n+LL |         false => Box::new(async_dummy()),\n+   |\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/match-prev-arm-needing-semi.rs:39:18\n+   |\n+LL |   async fn async_dummy2() {}\n+   |                           - the `Output` of this `async fn`'s found opaque type\n+...\n+LL |       let _ = match true {\n+   |  _____________-\n+LL | |         true => {\n+LL | |             async_dummy();\n+   | |             -------------- this is found to be of type `()`\n+LL | |\n+LL | |         }\n+LL | |         false => async_dummy2(),\n+   | |                  ^^^^^^^^^^^^^^ expected `()`, found opaque type\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note:     expected type `()`\n+           found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |         false => async_dummy2().await,\n+   |                                ^^^^^^\n+help: consider removing this semicolon and boxing the expressions\n+   |\n+LL |             Box::new(async_dummy())\n+LL |\n+LL |         }\n+LL |         false => Box::new(async_dummy2()),\n+   |\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/match-prev-arm-needing-semi.rs:50:18\n+   |\n+LL |   async fn async_dummy2() {}\n+   |                           - the `Output` of this `async fn`'s found opaque type\n+...\n+LL |       let _ = match true {\n+   |  _____________-\n+LL | |         true => async_dummy(),\n+   | |                 ------------- this is found to be of type `impl Future`\n+LL | |\n+LL | |         false => async_dummy2(),\n+   | |                  ^^^^^^^^^^^^^^ expected opaque type, found a different opaque type\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note:     expected type `impl Future` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:16:24>)\n+           found opaque type `impl Future` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:17:25>)\n+   = note: distinct uses of `impl Trait` result in different opaque types\n+help: consider `await`ing on both `Future`s\n+   |\n+LL |         true => async_dummy().await,\n+LL |\n+LL |         false => async_dummy2().await,\n+   |\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/match-prev-arm-needing-semi.rs:11:18\n+   |\n+LL |       let _ = match true {\n+   |  _____________-\n+LL | |         true => {\n+LL | |             dummy();\n+   | |             --------\n+   | |             |      |\n+   | |             |      help: consider removing this semicolon\n+   | |             this is found to be of type `()`\n+LL | |\n+LL | |         }\n+LL | |         false => dummy(),\n+   | |                  ^^^^^^^ expected `()`, found `i32`\n+LL | |\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "d74076cbc9b8e1bad1564cffb12f3316214d1583", "filename": "src/test/ui/suggestions/opaque-type-error.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/083a5cd9a2cb087e9acd7c9e80e277883f7003b3/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr?ref=083a5cd9a2cb087e9acd7c9e80e277883f7003b3", "patch": "@@ -16,6 +16,12 @@ LL | |     }.await\n    = note:     expected type `impl Future` (opaque type at <$DIR/opaque-type-error.rs:8:19>)\n            found opaque type `impl Future` (opaque type at <$DIR/opaque-type-error.rs:12:19>)\n    = note: distinct uses of `impl Trait` result in different opaque types\n+help: consider `await`ing on both `Future`s\n+   |\n+LL |         thing_one().await\n+LL |     } else {\n+LL |         thing_two().await\n+   |\n \n error: aborting due to previous error\n "}]}