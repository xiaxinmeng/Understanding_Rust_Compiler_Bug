{"sha": "c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNGU5YjMzZDlkOTI1MmVhMzQzYjA4ZDRmNGE3MGM1OTg5NmUwZTk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-21T20:16:40Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-21T20:25:32Z"}, "message": "Move expr ids into the expr record type\n\nThis simplifies the tag variants a bit and makes expr_node_id\nobsolete.", "tree": {"sha": "f55177e50e14878c748c1bdf0b2a9545318c307b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f55177e50e14878c748c1bdf0b2a9545318c307b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "html_url": "https://github.com/rust-lang/rust/commit/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edf73f051270b0dadf2f6d24070cfe98be6a41e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/edf73f051270b0dadf2f6d24070cfe98be6a41e2", "html_url": "https://github.com/rust-lang/rust/commit/edf73f051270b0dadf2f6d24070cfe98be6a41e2"}], "stats": {"total": 1752, "additions": 814, "deletions": 938}, "files": [{"sha": "4c5bcf2efc34d3019d4443a694c0792e31f1aff8", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -220,61 +220,63 @@ tag spawn_dom { dom_implicit; dom_thread; }\n // FIXME: temporary\n tag seq_kind { sk_unique; sk_rc; }\n \n-type expr = spanned[expr_];\n+type expr = rec(node_id id,\n+                expr_ node,\n+                span span);\n \n tag expr_ {\n-    expr_vec(vec[@expr], mutability, seq_kind, node_id);\n-    expr_tup(vec[elt], node_id);\n-    expr_rec(vec[field], option::t[@expr], node_id);\n-    expr_call(@expr, vec[@expr], node_id);\n-    expr_self_method(ident, node_id);\n-    expr_bind(@expr, vec[option::t[@expr]], node_id);\n-    expr_spawn(spawn_dom, option::t[str], @expr, vec[@expr], node_id);\n-    expr_binary(binop, @expr, @expr, node_id);\n-    expr_unary(unop, @expr, node_id);\n-    expr_lit(@lit, node_id);\n-    expr_cast(@expr, @ty, node_id);\n-    expr_if(@expr, block, option::t[@expr], node_id);\n-    expr_while(@expr, block, node_id);\n-    expr_for(@local, @expr, block, node_id);\n-    expr_for_each(@local, @expr, block, node_id);\n-    expr_do_while(block, @expr, node_id);\n-    expr_alt(@expr, vec[arm], node_id);\n-    expr_fn(_fn, node_id);\n-    expr_block(block, node_id);\n+    expr_vec(vec[@expr], mutability, seq_kind);\n+    expr_tup(vec[elt]);\n+    expr_rec(vec[field], option::t[@expr]);\n+    expr_call(@expr, vec[@expr]);\n+    expr_self_method(ident);\n+    expr_bind(@expr, vec[option::t[@expr]]);\n+    expr_spawn(spawn_dom, option::t[str], @expr, vec[@expr]);\n+    expr_binary(binop, @expr, @expr);\n+    expr_unary(unop, @expr);\n+    expr_lit(@lit);\n+    expr_cast(@expr, @ty);\n+    expr_if(@expr, block, option::t[@expr]);\n+    expr_while(@expr, block);\n+    expr_for(@local, @expr, block);\n+    expr_for_each(@local, @expr, block);\n+    expr_do_while(block, @expr);\n+    expr_alt(@expr, vec[arm]);\n+    expr_fn(_fn);\n+    expr_block(block);\n     /*\n      * FIXME: many of these @exprs should be constrained with\n      * is_lval once we have constrained types working.\n      */\n-    expr_move(@expr, @expr, node_id);\n-    expr_assign(@expr,@expr, node_id);\n-    expr_swap(@expr, @expr, node_id);\n-    expr_assign_op(binop, @expr, @expr, node_id);\n-    expr_send(@expr, @expr, node_id);\n-    expr_recv(@expr, @expr, node_id);\n-    expr_field(@expr, ident, node_id);\n-    expr_index(@expr, @expr, node_id);\n-    expr_path(path, node_id);\n-    expr_ext(path, vec[@expr], option::t[str], @expr, node_id);\n-    expr_fail(node_id, option::t[str]);\n-    expr_break(node_id);\n-    expr_cont(node_id);\n-    expr_ret(option::t[@expr], node_id);\n-    expr_put(option::t[@expr], node_id);\n-    expr_be(@expr, node_id);\n-    expr_log(int, @expr, node_id);\n+    expr_move(@expr, @expr);\n+    expr_assign(@expr,@expr);\n+    expr_swap(@expr, @expr);\n+    expr_assign_op(binop, @expr, @expr);\n+    expr_send(@expr, @expr);\n+    expr_recv(@expr, @expr);\n+    expr_field(@expr, ident);\n+    expr_index(@expr, @expr);\n+    expr_path(path);\n+    expr_ext(path, vec[@expr], option::t[str], @expr);\n+    expr_fail(option::t[str]);\n+    expr_break;\n+    expr_cont;\n+    expr_ret(option::t[@expr]);\n+    expr_put(option::t[@expr]);\n+    expr_be(@expr);\n+    expr_log(int, @expr);\n \n     /* just an assert, no significance to typestate */\n-    expr_assert(@expr, node_id);\n+    expr_assert(@expr);\n \n     /* preds that typestate is aware of */\n-    expr_check(@expr, node_id);\n+    expr_check(@expr);\n    /* FIXME Would be nice if expr_check desugared\n       to expr_if_check. */\n-    expr_if_check(@expr, block, option::t[@expr], node_id);\n-    expr_port(node_id);\n-    expr_chan(@expr, node_id);\n-    expr_anon_obj(anon_obj, vec[ty_param], obj_def_ids, node_id);\n+    expr_if_check(@expr, block, option::t[@expr]);\n+    expr_port;\n+    expr_chan(@expr);\n+    expr_anon_obj(anon_obj, vec[ty_param], obj_def_ids);\n }\n \n type lit = spanned[lit_];\n@@ -527,15 +529,15 @@ fn is_exported(ident i, _mod m) -> bool {\n \n fn is_call_expr(@expr e) -> bool {\n     alt (e.node) {\n-        case (expr_call(_, _, _)) { ret true; }\n+        case (expr_call(_, _)) { ret true; }\n         case (_) { ret false; }\n     }\n }\n \n fn is_constraint_arg(@expr e) -> bool {\n     alt (e.node) {\n-        case (expr_lit(_, _)) { ret true; }\n-        case (expr_path(_, _)) { ret true; }\n+        case (expr_lit(_)) { ret true; }\n+        case (expr_path(_)) { ret true; }\n         case (_) { ret false; }\n     }\n }"}, {"sha": "807163dc459a22a6b94fa058213711dd92a6315b", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -77,15 +77,15 @@ fn eval_lit(ctx cx, span sp, @ast::lit lit) -> val {\n \n fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n     alt (x.node) {\n-        case (ast::expr_path(?pth, _)) {\n+        case (ast::expr_path(?pth)) {\n             if (vec::len[ident](pth.node.idents) == 1u &&\n                     vec::len[@ast::ty](pth.node.types) == 0u) {\n                 ret lookup(cx.sess, e, x.span, pth.node.idents.(0));\n             }\n             cx.sess.span_fatal(x.span, \"evaluating structured path-name\");\n         }\n-        case (ast::expr_lit(?lit, _)) { ret eval_lit(cx, x.span, lit); }\n-        case (ast::expr_unary(?op, ?a, _)) {\n+        case (ast::expr_lit(?lit)) { ret eval_lit(cx, x.span, lit); }\n+        case (ast::expr_unary(?op, ?a)) {\n             auto av = eval_expr(cx, e, a);\n             alt (op) {\n                 case (ast::not) {\n@@ -97,7 +97,7 @@ fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n                 }\n             }\n         }\n-        case (ast::expr_binary(?op, ?a, ?b, _)) {\n+        case (ast::expr_binary(?op, ?a, ?b)) {\n             auto av = eval_expr(cx, e, a);\n             auto bv = eval_expr(cx, e, b);\n             alt (op) {\n@@ -214,7 +214,7 @@ fn eval_crate_directive_expr(ctx cx, env e, @ast::expr x, str prefix,\n                              &mutable vec[@ast::view_item] view_items,\n                              &mutable vec[@ast::item] items) {\n     alt (x.node) {\n-        case (ast::expr_if(?cond, ?thn, ?elopt, _)) {\n+        case (ast::expr_if(?cond, ?thn, ?elopt)) {\n             auto cv = eval_expr(cx, e, cond);\n             if (!val_is_bool(cv)) {\n                 cx.sess.span_fatal(x.span, \"bad cond type in 'if'\");\n@@ -234,7 +234,7 @@ fn eval_crate_directive_expr(ctx cx, env e, @ast::expr x, str prefix,\n                 }\n             }\n         }\n-        case (ast::expr_alt(?v, ?arms, _)) {\n+        case (ast::expr_alt(?v, ?arms)) {\n             auto vv = eval_expr(cx, e, v);\n             for (ast::arm arm in arms) {\n                 alt (arm.pat.node) {\n@@ -259,7 +259,7 @@ fn eval_crate_directive_expr(ctx cx, env e, @ast::expr x, str prefix,\n             }\n             cx.sess.span_fatal(x.span, \"no cases matched in 'alt'\");\n         }\n-        case (ast::expr_block(?block, _)) {\n+        case (ast::expr_block(?block)) {\n             ret eval_crate_directive_block(cx, e, block, prefix, view_items,\n                                            items);\n         }"}, {"sha": "1b1e0420e100f718fdc1f9e00e6de15bcb1e377e", "filename": "src/comp/front/extenv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Ffront%2Fextenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Ffront%2Fextenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextenv.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -32,7 +32,7 @@ fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n // FIXME: duplicate code copied from extfmt:\n fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n     alt (expr.node) {\n-        case (ast::expr_lit(?l, _)) {\n+        case (ast::expr_lit(?l)) {\n             alt (l.node) {\n                 case (ast::lit_str(?s, _)) { ret s; }\n                 case (_) { cx.span_fatal(l.span, \"malformed #env call\"); }\n@@ -44,8 +44,7 @@ fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n \n fn make_new_lit(&ext_ctxt cx, common::span sp, ast::lit_ lit) -> @ast::expr {\n     auto sp_lit = @rec(node=lit, span=sp);\n-    auto expr = ast::expr_lit(sp_lit, cx.next_id());\n-    ret @rec(node=expr, span=sp);\n+    ret @rec(id=cx.next_id(), node=ast::expr_lit(sp_lit), span=sp);\n }\n \n fn make_new_str(&ext_ctxt cx, common::span sp, str s) -> @ast::expr {"}, {"sha": "f68c36974c363f8cf23e96a186716ab3b83eb347", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -35,7 +35,7 @@ fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n     auto err_msg = \"first argument to #fmt must be a string literal\";\n     alt (expr.node) {\n-        case (ast::expr_lit(?l, _)) {\n+        case (ast::expr_lit(?l)) {\n             alt (l.node) {\n                 case (ast::lit_str(?s, _)) { ret s; }\n                 case (_) { cx.span_fatal(l.span, err_msg); }\n@@ -54,8 +54,7 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n     fn make_new_lit(&ext_ctxt cx, common::span sp, ast::lit_ lit) ->\n        @ast::expr {\n         auto sp_lit = @rec(node=lit, span=sp);\n-        auto expr = ast::expr_lit(sp_lit, cx.next_id());\n-        ret @rec(node=expr, span=sp);\n+        ret @rec(id=cx.next_id(), node=ast::expr_lit(sp_lit), span=sp);\n     }\n     fn make_new_str(&ext_ctxt cx, common::span sp, str s) -> @ast::expr {\n         auto lit = ast::lit_str(s, ast::sk_rc);\n@@ -71,31 +70,27 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n     }\n     fn make_add_expr(&ext_ctxt cx, common::span sp, @ast::expr lhs,\n                      @ast::expr rhs) -> @ast::expr {\n-        auto binexpr = ast::expr_binary(ast::add, lhs, rhs, cx.next_id());\n-        ret @rec(node=binexpr, span=sp);\n+        auto binexpr = ast::expr_binary(ast::add, lhs, rhs);\n+        ret @rec(id=cx.next_id(), node=binexpr, span=sp);\n     }\n     fn make_path_expr(&ext_ctxt cx, common::span sp, vec[ast::ident] idents)\n        -> @ast::expr {\n         let vec[@ast::ty] types = [];\n         auto path = rec(idents=idents, types=types);\n         auto sp_path = rec(node=path, span=sp);\n-        auto pathexpr = ast::expr_path(sp_path, cx.next_id());\n-        auto sp_pathexpr = @rec(node=pathexpr, span=sp);\n-        ret sp_pathexpr;\n+        auto pathexpr = ast::expr_path(sp_path);\n+        ret @rec(id=cx.next_id(), node=pathexpr, span=sp);\n     }\n     fn make_vec_expr(&ext_ctxt cx, common::span sp, vec[@ast::expr] exprs) ->\n        @ast::expr {\n-        auto vecexpr =\n-            ast::expr_vec(exprs, ast::imm, ast::sk_rc, cx.next_id());\n-        auto sp_vecexpr = @rec(node=vecexpr, span=sp);\n-        ret sp_vecexpr;\n+        auto vecexpr = ast::expr_vec(exprs, ast::imm, ast::sk_rc);\n+        ret @rec(id=cx.next_id(), node=vecexpr, span=sp);\n     }\n     fn make_call(&ext_ctxt cx, common::span sp, vec[ast::ident] fn_path,\n                  vec[@ast::expr] args) -> @ast::expr {\n         auto pathexpr = make_path_expr(cx, sp, fn_path);\n-        auto callexpr = ast::expr_call(pathexpr, args, cx.next_id());\n-        auto sp_callexpr = @rec(node=callexpr, span=sp);\n-        ret sp_callexpr;\n+        auto callexpr = ast::expr_call(pathexpr, args);\n+        ret @rec(id=cx.next_id(), node=callexpr, span=sp);\n     }\n     fn make_rec_expr(&ext_ctxt cx, common::span sp,\n                      vec[tup(ast::ident, @ast::expr)] fields) -> @ast::expr {\n@@ -107,10 +102,8 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n                 rec(node=rec(mut=ast::imm, ident=ident, expr=val), span=sp);\n             astfields += [astfield];\n         }\n-        auto recexpr =\n-            ast::expr_rec(astfields, option::none[@ast::expr], cx.next_id());\n-        auto sp_recexpr = @rec(node=recexpr, span=sp);\n-        ret sp_recexpr;\n+        auto recexpr = ast::expr_rec(astfields, option::none[@ast::expr]);\n+        ret @rec(id=cx.next_id(), node=recexpr, span=sp);\n     }\n     fn make_path_vec(str ident) -> vec[str] {\n         // FIXME: #fmt can't currently be used from within std"}, {"sha": "6e8657069d3bb4309a9bb4bf95fe56efe2bc238b", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 115, "deletions": 127, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -701,33 +701,38 @@ fn parse_field(&parser p) -> ast::field {\n     ret spanned(lo, e.span.hi, rec(mut=m, ident=i, expr=e));\n }\n \n+fn mk_expr(&parser p, uint lo, uint hi, &ast::expr_ node) -> @ast::expr {\n+    ret @rec(id=p.get_id(),\n+             node=node,\n+             span=rec(lo=lo, hi=hi));\n+}\n+\n fn parse_bottom_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n     // FIXME: can only remove this sort of thing when both typestate and\n     // alt-exhaustive-match checking are co-operating.\n \n     auto lit = @spanned(lo, hi, ast::lit_nil);\n-    let ast::expr_ ex = ast::expr_lit(lit, p.get_id());\n+    let ast::expr_ ex = ast::expr_lit(lit);\n     if (p.peek() == token::LPAREN) {\n         p.bump();\n         alt (p.peek()) {\n             case (token::RPAREN) {\n                 hi = p.get_hi_pos();\n                 p.bump();\n                 auto lit = @spanned(lo, hi, ast::lit_nil);\n-                ret @spanned(lo, hi, ast::expr_lit(lit, p.get_id()));\n+                ret mk_expr(p, lo, hi, ast::expr_lit(lit));\n             }\n             case (_) {/* fall through */ }\n         }\n         auto e = parse_expr(p);\n         hi = p.get_hi_pos();\n         expect(p, token::RPAREN);\n-        ret @spanned(lo, hi, e.node);\n+        ret mk_expr(p, lo, hi, e.node);\n     } else if (p.peek() == token::LBRACE) {\n         auto blk = parse_block(p);\n-        ret @spanned(blk.span.lo, blk.span.hi,\n-                     ast::expr_block(blk, p.get_id()));\n+        ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n     } else if (eat_word(p, \"if\")) {\n         ret parse_if_expr(p);\n     } else if (eat_word(p, \"for\")) {\n@@ -752,14 +757,14 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                       parse_elt, p);\n         hi = es.span.hi;\n-        ex = ast::expr_tup(es.node, p.get_id());\n+        ex = ast::expr_tup(es.node);\n     } else if (p.peek() == token::LBRACKET) {\n         p.bump();\n         auto mut = parse_mutability(p);\n         auto es =\n             parse_seq_to_end(token::RBRACKET, some(token::COMMA), parse_expr,\n                              p);\n-        ex = ast::expr_vec(es, mut, ast::sk_rc, p.get_id());\n+        ex = ast::expr_vec(es, mut, ast::sk_rc);\n     } else if (p.peek() == token::TILDE) {\n         p.bump();\n         alt (p.peek()) {\n@@ -770,14 +775,14 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n                 auto es =\n                     parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n                                      parse_expr, p);\n-                ex = ast::expr_vec(es, mut, ast::sk_unique, p.get_id());\n+                ex = ast::expr_vec(es, mut, ast::sk_unique);\n             }\n             case (token::LIT_STR(?s)) {\n                 p.bump();\n                 auto lit =\n                     @rec(node=ast::lit_str(p.get_str(s), ast::sk_unique),\n                          span=p.get_span());\n-                ex = ast::expr_lit(lit, p.get_id());\n+                ex = ast::expr_lit(lit);\n             }\n             case (_) {\n                 p.get_session().span_unimpl(p.get_span(),\n@@ -819,7 +824,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         let ast::anon_obj ob =\n             rec(fields=fields, methods=meths, with_obj=with_obj);\n         auto odid = rec(ty=p.get_id(), ctor=p.get_id());\n-        ex = ast::expr_anon_obj(ob, ty_params, odid, p.get_id());\n+        ex = ast::expr_anon_obj(ob, ty_params, odid);\n     } else if (eat_word(p, \"rec\")) {\n         expect(p, token::LPAREN);\n         auto fields = [parse_field(p)];\n@@ -840,7 +845,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n                 fields += [parse_field(p)];\n             } else { unexpected(p, p.peek()); }\n         }\n-        ex = ast::expr_rec(fields, base, p.get_id());\n+        ex = ast::expr_rec(fields, base);\n     } else if (eat_word(p, \"bind\")) {\n         auto e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n         fn parse_expr_opt(&parser p) -> option::t[@ast::expr] {\n@@ -853,7 +858,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                       parse_expr_opt, p);\n         hi = es.span.hi;\n-        ex = ast::expr_bind(e, es.node, p.get_id());\n+        ex = ast::expr_bind(e, es.node);\n     } else if (p.peek() == token::POUND) {\n         auto ex_ext = parse_syntax_ext(p);\n         lo = ex_ext.span.lo;\n@@ -864,47 +869,47 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             case (token::LIT_STR(?s)) { msg = some(p.get_str(s)); p.bump(); }\n             case (_) { msg = none; }\n         }\n-        ex = ast::expr_fail(p.get_id(), msg);\n+        ex = ast::expr_fail(msg);\n     } else if (eat_word(p, \"log\")) {\n         auto e = parse_expr(p);\n         auto hi = e.span.hi;\n-        ex = ast::expr_log(1, e, p.get_id());\n+        ex = ast::expr_log(1, e);\n     } else if (eat_word(p, \"log_err\")) {\n         auto e = parse_expr(p);\n         auto hi = e.span.hi;\n-        ex = ast::expr_log(0, e, p.get_id());\n+        ex = ast::expr_log(0, e);\n     } else if (eat_word(p, \"assert\")) {\n         auto e = parse_expr(p);\n         auto hi = e.span.hi;\n-        ex = ast::expr_assert(e, p.get_id());\n+        ex = ast::expr_assert(e);\n     } else if (eat_word(p, \"check\")) {\n         /* Should be a predicate (pure boolean function) applied to \n            arguments that are all either slot variables or literals.\n            but the typechecker enforces that. */\n \n         auto e = parse_expr(p);\n         auto hi = e.span.hi;\n-        ex = ast::expr_check(e, p.get_id());\n+        ex = ast::expr_check(e);\n     } else if (eat_word(p, \"ret\")) {\n         alt (p.peek()) {\n-            case (token::SEMI) { ex = ast::expr_ret(none, p.get_id()); }\n+            case (token::SEMI) { ex = ast::expr_ret(none); }\n             case (_) {\n                 auto e = parse_expr(p);\n                 hi = e.span.hi;\n-                ex = ast::expr_ret(some(e), p.get_id());\n+                ex = ast::expr_ret(some(e));\n             }\n         }\n     } else if (eat_word(p, \"break\")) {\n-        ex = ast::expr_break(p.get_id());\n+        ex = ast::expr_break;\n     } else if (eat_word(p, \"cont\")) {\n-        ex = ast::expr_cont(p.get_id());\n+        ex = ast::expr_cont;\n     } else if (eat_word(p, \"put\")) {\n         alt (p.peek()) {\n-            case (token::SEMI) { ex = ast::expr_put(none, p.get_id()); }\n+            case (token::SEMI) { ex = ast::expr_put(none); }\n             case (_) {\n                 auto e = parse_expr(p);\n                 hi = e.span.hi;\n-                ex = ast::expr_put(some(e), p.get_id());\n+                ex = ast::expr_put(some(e));\n             }\n         }\n     } else if (eat_word(p, \"be\")) {\n@@ -913,19 +918,19 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         // FIXME: Is this the right place for this check?\n         if (/*check*/ast::is_call_expr(e)) {\n             hi = e.span.hi;\n-            ex = ast::expr_be(e, p.get_id());\n+            ex = ast::expr_be(e);\n         } else { p.err(\"Non-call expression in tail call\"); }\n     } else if (eat_word(p, \"port\")) {\n         expect(p, token::LPAREN);\n         expect(p, token::RPAREN);\n         hi = p.get_hi_pos();\n-        ex = ast::expr_port(p.get_id());\n+        ex = ast::expr_port;\n     } else if (eat_word(p, \"chan\")) {\n         expect(p, token::LPAREN);\n         auto e = parse_expr(p);\n         hi = e.span.hi;\n         expect(p, token::RPAREN);\n-        ex = ast::expr_chan(e, p.get_id());\n+        ex = ast::expr_chan(e);\n     } else if (eat_word(p, \"self\")) {\n         log \"parsing a self-call...\";\n         expect(p, token::DOT);\n@@ -936,19 +941,19 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                       parse_expr, p);\n         hi = es.span.hi;\n-        ex = ast::expr_call(f, es.node, p.get_id());\n+        ex = ast::expr_call(f, es.node);\n     } else if (is_ident(p.peek()) && !is_word(p, \"true\") &&\n                    !is_word(p, \"false\")) {\n         check_bad_word(p);\n         auto pth = parse_path_and_ty_param_substs(p);\n         hi = pth.span.hi;\n-        ex = ast::expr_path(pth, p.get_id());\n+        ex = ast::expr_path(pth);\n     } else {\n         auto lit = parse_lit(p);\n         hi = lit.span.hi;\n-        ex = ast::expr_lit(@lit, p.get_id());\n+        ex = ast::expr_lit(@lit);\n     }\n-    ret @spanned(lo, hi, ex);\n+    ret mk_expr(p, lo, hi, ex);\n }\n \n fn parse_syntax_ext(&parser p) -> @ast::expr {\n@@ -964,7 +969,7 @@ fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n     auto hi = es.span.hi;\n     auto ext_span = rec(lo=lo, hi=hi);\n     auto ex = expand_syntax_ext(p, ext_span, pth, es.node, none);\n-    ret @spanned(lo, hi, ex);\n+    ret mk_expr(p, lo, hi, ex);\n }\n \n /*\n@@ -982,17 +987,15 @@ fn expand_syntax_ext(&parser p, common::span sp, &ast::path path,\n         case (none) { p.err(\"unknown syntax expander: '\" + extname + \"'\"); }\n         case (some(ext::x(?ext))) {\n             auto ext_cx = ext::mk_ctxt(p);\n-            ret ast::expr_ext(path, args, body, ext(ext_cx, sp, args, body),\n-                              p.get_id());\n+            ret ast::expr_ext(path, args, body, ext(ext_cx, sp, args, body));\n         }\n     }\n }\n \n fn parse_self_method(&parser p) -> @ast::expr {\n     auto sp = p.get_span();\n     let ast::ident f_name = parse_ident(p);\n-    auto hi = p.get_span();\n-    ret @rec(node=ast::expr_self_method(f_name, p.get_id()), span=sp);\n+    ret mk_expr(p, sp.lo, sp.hi, ast::expr_self_method(f_name));\n }\n \n fn parse_dot_or_call_expr(&parser p) -> @ast::expr {\n@@ -1014,8 +1017,7 @@ fn parse_dot_or_call_expr_with(&parser p, @ast::expr e) -> @ast::expr {\n                         parse_seq(token::LPAREN, token::RPAREN,\n                                   some(token::COMMA), parse_expr, p);\n                     hi = es.span.hi;\n-                    auto e_ = ast::expr_call(e, es.node, p.get_id());\n-                    e = @spanned(lo, hi, e_);\n+                    e = mk_expr(p, lo, hi, ast::expr_call(e, es.node));\n                 }\n             }\n             case (token::DOT) {\n@@ -1024,17 +1026,15 @@ fn parse_dot_or_call_expr_with(&parser p, @ast::expr e) -> @ast::expr {\n                     case (token::IDENT(?i, _)) {\n                         hi = p.get_hi_pos();\n                         p.bump();\n-                        auto e_ =\n-                            ast::expr_field(e, p.get_str(i), p.get_id());\n-                        e = @spanned(lo, hi, e_);\n+                        e = mk_expr(p, lo, hi,\n+                                    ast::expr_field(e, p.get_str(i)));\n                     }\n                     case (token::LPAREN) {\n                         p.bump();\n                         auto ix = parse_expr(p);\n                         hi = ix.span.hi;\n                         expect(p, token::RPAREN);\n-                        auto e_ = ast::expr_index(e, ix, p.get_id());\n-                        e = @spanned(lo, hi, e_);\n+                        e = mk_expr(p, lo, hi, ast::expr_index(e, ix));\n                     }\n                     case (?t) { unexpected(p, t); }\n                 }\n@@ -1057,27 +1057,27 @@ fn parse_prefix_expr(&parser p) -> @ast::expr {\n     // alt-exhaustive-match checking are co-operating.\n \n     auto lit = @spanned(lo, lo, ast::lit_nil);\n-    let ast::expr_ ex = ast::expr_lit(lit, p.get_id());\n+    let ast::expr_ ex = ast::expr_lit(lit);\n     alt (p.peek()) {\n         case (token::NOT) {\n             p.bump();\n             auto e = parse_prefix_expr(p);\n             hi = e.span.hi;\n-            ex = ast::expr_unary(ast::not, e, p.get_id());\n+            ex = ast::expr_unary(ast::not, e);\n         }\n         case (token::BINOP(?b)) {\n             alt (b) {\n                 case (token::MINUS) {\n                     p.bump();\n                     auto e = parse_prefix_expr(p);\n                     hi = e.span.hi;\n-                    ex = ast::expr_unary(ast::neg, e, p.get_id());\n+                    ex = ast::expr_unary(ast::neg, e);\n                 }\n                 case (token::STAR) {\n                     p.bump();\n                     auto e = parse_prefix_expr(p);\n                     hi = e.span.hi;\n-                    ex = ast::expr_unary(ast::deref, e, p.get_id());\n+                    ex = ast::expr_unary(ast::deref, e);\n                 }\n                 case (_) { ret parse_dot_or_call_expr(p); }\n             }\n@@ -1087,11 +1087,11 @@ fn parse_prefix_expr(&parser p) -> @ast::expr {\n             auto m = parse_mutability(p);\n             auto e = parse_prefix_expr(p);\n             hi = e.span.hi;\n-            ex = ast::expr_unary(ast::box(m), e, p.get_id());\n+            ex = ast::expr_unary(ast::box(m), e);\n         }\n         case (_) { ret parse_dot_or_call_expr(p); }\n     }\n-    ret @spanned(lo, hi, ex);\n+    ret mk_expr(p, lo, hi, ex);\n }\n \n type op_spec = rec(token::token tok, ast::binop op, int prec);\n@@ -1135,16 +1135,16 @@ fn parse_more_binops(&parser p, @ast::expr lhs, int min_prec) -> @ast::expr {\n         if (cur.prec > min_prec && cur.tok == peeked) {\n             p.bump();\n             auto rhs = parse_more_binops(p, parse_prefix_expr(p), cur.prec);\n-            auto bin = ast::expr_binary(cur.op, lhs, rhs, p.get_id());\n-            auto span = @spanned(lhs.span.lo, rhs.span.hi, bin);\n-            ret parse_more_binops(p, span, min_prec);\n+            auto bin = mk_expr(p, lhs.span.lo, rhs.span.hi,\n+                               ast::expr_binary(cur.op, lhs, rhs));\n+            ret parse_more_binops(p, bin, min_prec);\n         }\n     }\n     if (as_prec > min_prec && eat_word(p, \"as\")) {\n         auto rhs = parse_ty(p);\n-        auto _as = ast::expr_cast(lhs, rhs, p.get_id());\n-        auto span = @spanned(lhs.span.lo, rhs.span.hi, _as);\n-        ret parse_more_binops(p, span, min_prec);\n+        auto _as = mk_expr(p, lhs.span.lo, rhs.span.hi,\n+                           ast::expr_cast(lhs, rhs));\n+        ret parse_more_binops(p, _as, min_prec);\n     }\n     ret lhs;\n }\n@@ -1156,8 +1156,7 @@ fn parse_assign_expr(&parser p) -> @ast::expr {\n         case (token::EQ) {\n             p.bump();\n             auto rhs = parse_expr(p);\n-            ret @spanned(lo, rhs.span.hi,\n-                         ast::expr_assign(lhs, rhs, p.get_id()));\n+            ret mk_expr(p, lo, rhs.span.hi, ast::expr_assign(lhs, rhs));\n         }\n         case (token::BINOPEQ(?op)) {\n             p.bump();\n@@ -1176,32 +1175,28 @@ fn parse_assign_expr(&parser p) -> @ast::expr {\n                 case (token::LSR) { aop = ast::lsr; }\n                 case (token::ASR) { aop = ast::asr; }\n             }\n-            ret @spanned(lo, rhs.span.hi,\n-                         ast::expr_assign_op(aop, lhs, rhs, p.get_id()));\n+            ret mk_expr(p, lo, rhs.span.hi,\n+                        ast::expr_assign_op(aop, lhs, rhs));\n         }\n         case (token::LARROW) {\n             p.bump();\n             auto rhs = parse_expr(p);\n-            ret @spanned(lo, rhs.span.hi,\n-                         ast::expr_move(lhs, rhs, p.get_id()));\n+            ret mk_expr(p, lo, rhs.span.hi, ast::expr_move(lhs, rhs));\n         }\n         case (token::SEND) {\n             p.bump();\n             auto rhs = parse_expr(p);\n-            ret @spanned(lo, rhs.span.hi,\n-                         ast::expr_send(lhs, rhs, p.get_id()));\n+            ret mk_expr(p, lo, rhs.span.hi, ast::expr_send(lhs, rhs));\n         }\n         case (token::RECV) {\n             p.bump();\n             auto rhs = parse_expr(p);\n-            ret @spanned(lo, rhs.span.hi,\n-                         ast::expr_recv(lhs, rhs, p.get_id()));\n+            ret mk_expr(p, lo, rhs.span.hi, ast::expr_recv(lhs, rhs));\n         }\n         case (token::DARROW) {\n             p.bump();\n             auto rhs = parse_expr(p);\n-            ret @spanned(lo, rhs.span.hi,\n-                         ast::expr_swap(lhs, rhs, p.get_id()));\n+            ret mk_expr(p, lo, rhs.span.hi, ast::expr_swap(lhs, rhs));\n         }\n         case (_) {/* fall through */ }\n     }\n@@ -1210,7 +1205,7 @@ fn parse_assign_expr(&parser p) -> @ast::expr {\n \n fn parse_if_expr_1(&parser p) -> tup(@ast::expr,\n                                      ast::block, option::t[@ast::expr],\n-                                     ast::node_id, uint, uint) {\n+                                     uint, uint) {\n     auto lo = p.get_last_lo_pos();\n     expect(p, token::LPAREN);\n     auto cond = parse_expr(p);\n@@ -1223,19 +1218,18 @@ fn parse_if_expr_1(&parser p) -> tup(@ast::expr,\n         els = some(elexpr);\n         hi = elexpr.span.hi;\n     }\n-    ret tup(cond, thn, els, p.get_id(), lo, hi);\n+    ret tup(cond, thn, els, lo, hi);\n }\n \n fn parse_if_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n     if (eat_word(p, \"check\")) {\n             auto q = parse_if_expr_1(p);\n-            ret @spanned(q._4, q._5,\n-                         ast::expr_if_check(q._0, q._1, q._2, q._3));\n+            ret mk_expr(p, q._3, q._4, ast::expr_if_check(q._0, q._1, q._2));\n     }\n     else {\n         auto q = parse_if_expr_1(p);\n-        ret @spanned(q._4, q._5, ast::expr_if(q._0, q._1, q._2, q._3));\n+        ret mk_expr(p, q._3, q._4, ast::expr_if(q._0, q._1, q._2));\n     }\n }\n \n@@ -1244,16 +1238,15 @@ fn parse_fn_expr(&parser p) -> @ast::expr {\n     auto decl = parse_fn_decl(p, ast::impure_fn);\n     auto body = parse_block(p);\n     auto _fn = rec(decl=decl, proto=ast::proto_fn, body=body);\n-    ret @spanned(lo, body.span.hi, ast::expr_fn(_fn, p.get_id()));\n+    ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn));\n }\n \n fn parse_else_expr(&parser p) -> @ast::expr {\n     if (eat_word(p, \"if\")) {\n         ret parse_if_expr(p);\n     } else {\n         auto blk = parse_block(p);\n-        ret @spanned(blk.span.lo, blk.span.hi,\n-                     ast::expr_block(blk, p.get_id()));\n+        ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n     }\n }\n \n@@ -1277,10 +1270,9 @@ fn parse_for_expr(&parser p) -> @ast::expr {\n     auto body = parse_block(p);\n     auto hi = body.span.hi;\n     if (is_each) {\n-        ret @spanned(lo, hi,\n-                     ast::expr_for_each(decl, seq, body, p.get_id()));\n+        ret mk_expr(p, lo, hi, ast::expr_for_each(decl, seq, body));\n     } else {\n-        ret @spanned(lo, hi, ast::expr_for(decl, seq, body, p.get_id()));\n+        ret mk_expr(p, lo, hi, ast::expr_for(decl, seq, body));\n     }\n }\n \n@@ -1291,7 +1283,7 @@ fn parse_while_expr(&parser p) -> @ast::expr {\n     expect(p, token::RPAREN);\n     auto body = parse_block(p);\n     auto hi = body.span.hi;\n-    ret @spanned(lo, hi, ast::expr_while(cond, body, p.get_id()));\n+    ret mk_expr(p, lo, hi, ast::expr_while(cond, body));\n }\n \n fn parse_do_while_expr(&parser p) -> @ast::expr {\n@@ -1302,7 +1294,7 @@ fn parse_do_while_expr(&parser p) -> @ast::expr {\n     auto cond = parse_expr(p);\n     expect(p, token::RPAREN);\n     auto hi = cond.span.hi;\n-    ret @spanned(lo, hi, ast::expr_do_while(body, cond, p.get_id()));\n+    ret mk_expr(p, lo, hi, ast::expr_do_while(body, cond));\n }\n \n fn parse_alt_expr(&parser p) -> @ast::expr {\n@@ -1329,8 +1321,7 @@ fn parse_alt_expr(&parser p) -> @ast::expr {\n     }\n     auto hi = p.get_hi_pos();\n     p.bump();\n-    auto expr = ast::expr_alt(discriminant, arms, p.get_id());\n-    ret @spanned(lo, hi, expr);\n+    ret mk_expr(p, lo, hi, ast::expr_alt(discriminant, arms));\n }\n \n fn parse_spawn_expr(&parser p) -> @ast::expr {\n@@ -1343,10 +1334,8 @@ fn parse_spawn_expr(&parser p) -> @ast::expr {\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                   parse_expr, p);\n     auto hi = es.span.hi;\n-    auto spawn_expr =\n-        ast::expr_spawn(ast::dom_implicit, option::none, fn_expr, es.node,\n-                        p.get_id());\n-    ret @spanned(lo, hi, spawn_expr);\n+    ret mk_expr(p, lo, hi, ast::expr_spawn\n+                (ast::dom_implicit, option::none, fn_expr, es.node));\n }\n \n fn parse_expr(&parser p) -> @ast::expr {\n@@ -1555,53 +1544,52 @@ fn stmt_to_expr(@ast::stmt stmt) -> option::t[@ast::expr] {\n fn stmt_ends_with_semi(&ast::stmt stmt) -> bool {\n     alt (stmt.node) {\n         case (ast::stmt_decl(?d, _)) {\n-            alt (d.node) {\n-                case (ast::decl_local(_)) { ret true; }\n-                case (ast::decl_item(_)) { ret false; }\n+            ret alt (d.node) {\n+                case (ast::decl_local(_)) { true }\n+                case (ast::decl_item(_)) { false }\n             }\n         }\n         case (ast::stmt_expr(?e, _)) {\n-            alt (e.node) {\n-                case (ast::expr_vec(_, _, _, _)) { ret true; }\n-                case (ast::expr_tup(_, _)) { ret true; }\n-                case (ast::expr_rec(_, _, _)) { ret true; }\n-                case (ast::expr_call(_, _, _)) { ret true; }\n-                case (ast::expr_self_method(_, _)) { ret false; }\n-                case (ast::expr_binary(_, _, _, _)) { ret true; }\n-                case (ast::expr_unary(_, _, _)) { ret true; }\n-                case (ast::expr_lit(_, _)) { ret true; }\n-                case (ast::expr_cast(_, _, _)) { ret true; }\n-                case (ast::expr_if(_, _, _, _)) { ret false; }\n-                case (ast::expr_for(_, _, _, _)) { ret false; }\n-                case (ast::expr_for_each(_, _, _, _)) { ret false; }\n-                case (ast::expr_while(_, _, _)) { ret false; }\n-                case (ast::expr_do_while(_, _, _)) { ret false; }\n-                case (ast::expr_alt(_, _, _)) { ret false; }\n-                case (ast::expr_fn(_, _)) { ret false; }\n-                case (ast::expr_block(_, _)) { ret false; }\n-                case (ast::expr_move(_, _, _)) { ret true; }\n-                case (ast::expr_assign(_, _, _)) { ret true; }\n-                case (ast::expr_swap(_, _, _)) { ret true; }\n-                case (ast::expr_assign_op(_, _, _, _)) { ret true; }\n-                case (ast::expr_send(_, _, _)) { ret true; }\n-                case (ast::expr_recv(_, _, _)) { ret true; }\n-                case (ast::expr_field(_, _, _)) { ret true; }\n-                case (ast::expr_index(_, _, _)) { ret true; }\n-                case (ast::expr_path(_, _)) { ret true; }\n-                case (ast::expr_fail(_, _)) { ret true; }\n-                case (ast::expr_break(_)) { ret true; }\n-                case (ast::expr_cont(_)) { ret true; }\n-                case (ast::expr_ret(_, _)) { ret true; }\n-                case (ast::expr_put(_, _)) { ret true; }\n-                case (ast::expr_be(_, _)) { ret true; }\n-                case (ast::expr_log(_, _, _)) { ret true; }\n-                case (ast::expr_check(_, _)) { ret true; }\n-                case (ast::expr_assert(_, _)) { ret true; }\n+            ret alt (e.node) {\n+                case (ast::expr_vec(_, _, _)) { true }\n+                case (ast::expr_tup(_)) { true }\n+                case (ast::expr_rec(_, _)) { true }\n+                case (ast::expr_call(_, _)) { true }\n+                case (ast::expr_self_method(_)) { false }\n+                case (ast::expr_binary(_, _, _)) { true }\n+                case (ast::expr_unary(_, _)) { true }\n+                case (ast::expr_lit(_)) { true }\n+                case (ast::expr_cast(_, _)) { true }\n+                case (ast::expr_if(_, _, _)) { false }\n+                case (ast::expr_for(_, _, _)) { false }\n+                case (ast::expr_for_each(_, _, _)) { false }\n+                case (ast::expr_while(_, _)) { false }\n+                case (ast::expr_do_while(_, _)) { false }\n+                case (ast::expr_alt(_, _)) { false }\n+                case (ast::expr_fn(_)) { false }\n+                case (ast::expr_block(_)) { false }\n+                case (ast::expr_move(_, _)) { true }\n+                case (ast::expr_assign(_, _)) { true }\n+                case (ast::expr_swap(_, _)) { true }\n+                case (ast::expr_assign_op(_, _, _)) { true }\n+                case (ast::expr_send(_, _)) { true }\n+                case (ast::expr_recv(_, _)) { true }\n+                case (ast::expr_field(_, _)) { true }\n+                case (ast::expr_index(_, _)) { true }\n+                case (ast::expr_path(_)) { true }\n+                case (ast::expr_fail(_)) { true }\n+                case (ast::expr_break) { true }\n+                case (ast::expr_cont) { true }\n+                case (ast::expr_ret(_)) { true }\n+                case (ast::expr_put(_)) { true }\n+                case (ast::expr_be(_)) { true }\n+                case (ast::expr_log(_, _)) { true }\n+                case (ast::expr_check(_)) { true }\n+                case (ast::expr_assert(_)) { true }\n             }\n         }\n-        case (\n-             // We should not be calling this on a cdir.\n-             ast::stmt_crate_directive(?cdir)) {\n+        // We should not be calling this on a cdir.\n+        case (ast::stmt_crate_directive(?cdir)) {\n             fail;\n         }\n     }"}, {"sha": "0fa31ec6d3c1703f3f871b1e9697a1bb35990282", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -76,18 +76,18 @@ fn visit_item(@ctx cx, &@ast::item i, &scope sc, &vt[scope] v) {\n fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n     auto handled = true;\n     alt (ex.node) {\n-        case (ast::expr_call(?f, ?args, _)) {\n+        case (ast::expr_call(?f, ?args)) {\n             check_call(*cx, f, args, sc);\n             handled = false;\n         }\n-        case (ast::expr_be(?cl, _)) {\n+        case (ast::expr_be(?cl)) {\n             check_tail_call(*cx, cl);\n             visit::visit_expr(cl, sc, v);\n         }\n-        case (ast::expr_alt(?input, ?arms, _)) {\n+        case (ast::expr_alt(?input, ?arms)) {\n             check_alt(*cx, input, arms, sc, v);\n         }\n-        case (ast::expr_put(?val, _)) {\n+        case (ast::expr_put(?val)) {\n             alt (val) {\n                 case (some(?ex)) {\n                     auto root = expr_root(*cx, ex, false);\n@@ -101,23 +101,23 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n                 case (_) { }\n             }\n         }\n-        case (ast::expr_for_each(?decl, ?call, ?block, _)) {\n+        case (ast::expr_for_each(?decl, ?call, ?block)) {\n             check_for_each(*cx, decl, call, block, sc, v);\n         }\n-        case (ast::expr_for(?decl, ?seq, ?block, _)) {\n+        case (ast::expr_for(?decl, ?seq, ?block)) {\n             check_for(*cx, decl, seq, block, sc, v);\n         }\n-        case (ast::expr_path(?pt, ?id)) {\n-            check_var(*cx, ex, pt, id, false, sc);\n+        case (ast::expr_path(?pt)) {\n+            check_var(*cx, ex, pt, ex.id, false, sc);\n             handled = false;\n         }\n-        case (ast::expr_move(?dest, ?src, _)) {\n+        case (ast::expr_move(?dest, ?src)) {\n             check_assign(cx, dest, src, sc, v);\n         }\n-        case (ast::expr_assign(?dest, ?src, _)) {\n+        case (ast::expr_assign(?dest, ?src)) {\n             check_assign(cx, dest, src, sc, v);\n         }\n-        case (ast::expr_assign_op(_, ?dest, ?src, _)) {\n+        case (ast::expr_assign_op(_, ?dest, ?src)) {\n             check_assign(cx, dest, src, sc, v);\n         }\n         case (_) { handled = false; }\n@@ -169,8 +169,8 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n     }\n     if (vec::len(unsafe_ts) > 0u) {\n         alt (f.node) {\n-            case (ast::expr_path(_, ?id)) {\n-                if (def_is_local(cx.tcx.def_map.get(id), true)) {\n+            case (ast::expr_path(_)) {\n+                if (def_is_local(cx.tcx.def_map.get(f.id), true)) {\n                     cx.tcx.sess.span_fatal(f.span,\n                                          #fmt(\"function may alias with \\\n                          argument %u, which is not immutably rooted\",\n@@ -220,16 +220,16 @@ fn check_tail_call(&ctx cx, &@ast::expr call) {\n     auto args;\n     auto f =\n         alt (call.node) {\n-            case (ast::expr_call(?f, ?args_, _)) { args = args_; f }\n+            case (ast::expr_call(?f, ?args_)) { args = args_; f }\n         };\n     auto i = 0u;\n     for (ty::arg arg_t in fty_args(cx, ty::expr_ty(*cx.tcx, f))) {\n         if (arg_t.mode != ty::mo_val) {\n             auto mut_a = arg_t.mode == ty::mo_alias(true);\n             auto ok = true;\n             alt (args.(i).node) {\n-                case (ast::expr_path(_, ?id)) {\n-                    auto def = cx.tcx.def_map.get(id);\n+                case (ast::expr_path(_)) {\n+                    auto def = cx.tcx.def_map.get(args.(i).id);\n                     auto dnum = ast::def_id_of_def(def)._1;\n                     alt (cx.local_map.find(dnum)) {\n                         case (some(arg(ast::alias(?mut)))) {\n@@ -301,7 +301,7 @@ fn check_for_each(&ctx cx, &@ast::local local, &@ast::expr call,\n                   &ast::block block, &scope sc, &vt[scope] v) {\n     visit::visit_expr(call, sc, v);\n     alt (call.node) {\n-        case (ast::expr_call(?f, ?args, _)) {\n+        case (ast::expr_call(?f, ?args)) {\n             auto data = check_call(cx, f, args, sc);\n             auto defnum = local.node.id;\n             auto new_sc =\n@@ -382,8 +382,8 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n                 &vt[scope] v) {\n     visit_expr(cx, src, sc, v);\n     alt (dest.node) {\n-        case (ast::expr_path(?p, ?id)) {\n-            auto dnum = ast::def_id_of_def(cx.tcx.def_map.get(id))._1;\n+        case (ast::expr_path(?p)) {\n+            auto dnum = ast::def_id_of_def(cx.tcx.def_map.get(dest.id))._1;\n             if (is_immutable_alias(cx, sc, dnum)) {\n                 cx.tcx.sess.span_fatal(dest.span,\n                                      \"assigning to immutable alias\");\n@@ -397,7 +397,7 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n                     r.ok = overwritten(dest.span, p);\n                 }\n             }\n-            check_var(*cx, dest, p, id, true, sc);\n+            check_var(*cx, dest, p, dest.id, true, sc);\n         }\n         case (_) {\n             auto root = expr_root(*cx, dest, false);\n@@ -496,7 +496,7 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n     let vec[deref] ds = [];\n     while (true) {\n         alt ({ ex.node }) {\n-            case (ast::expr_field(?base, ?ident, _)) {\n+            case (ast::expr_field(?base, ?ident)) {\n                 auto auto_unbox =\n                     maybe_auto_unbox(cx, ty::expr_ty(*cx.tcx, base));\n                 auto mut = false;\n@@ -519,7 +519,7 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n                 maybe_push_auto_unbox(auto_unbox.d, ds);\n                 ex = base;\n             }\n-            case (ast::expr_index(?base, _, _)) {\n+            case (ast::expr_index(?base, _)) {\n                 auto auto_unbox =\n                     maybe_auto_unbox(cx, ty::expr_ty(*cx.tcx, base));\n                 alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n@@ -539,7 +539,7 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n                 maybe_push_auto_unbox(auto_unbox.d, ds);\n                 ex = base;\n             }\n-            case (ast::expr_unary(?op, ?base, _)) {\n+            case (ast::expr_unary(?op, ?base)) {\n                 if (op == ast::deref) {\n                     auto base_t = ty::expr_ty(*cx.tcx, base);\n                     alt (ty::struct(*cx.tcx, base_t)) {\n@@ -575,8 +575,8 @@ fn inner_mut(&vec[deref] ds) -> option::t[ty::t] {\n \n fn path_def_id(&ctx cx, &@ast::expr ex) -> option::t[ast::def_id] {\n     alt (ex.node) {\n-        case (ast::expr_path(_, ?id)) {\n-            ret some(ast::def_id_of_def(cx.tcx.def_map.get(id)));\n+        case (ast::expr_path(_)) {\n+            ret some(ast::def_id_of_def(cx.tcx.def_map.get(ex.id)));\n         }\n         case (_) { ret none; }\n     }"}, {"sha": "d850404fcc6571449161a84c91a30d338f62d21b", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -42,7 +42,7 @@ fn map_native_item(&map map, &@native_item i, &() e, &vt[()] v) {\n }\n \n fn map_expr(&map map, &@expr ex, &() e, &vt[()] v) {\n-    map.insert(ty::expr_node_id(ex), node_expr(ex));\n+    map.insert(ex.id, node_expr(ex));\n     visit::visit_expr(ex, e, v);\n }\n "}, {"sha": "ac355b7c0207df37c1358f7b859962d1a1db060f", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -269,8 +269,8 @@ fn resolve_names(&@env e, &@ast::crate c) {\n     fn walk_expr(@env e, &@ast::expr exp, &scopes sc, &vt[scopes] v) {\n         visit_expr_with_scope(exp, sc, v);\n         alt (exp.node) {\n-            case (ast::expr_path(?p, ?id)) {\n-                maybe_insert(e, id,\n+            case (ast::expr_path(?p)) {\n+                maybe_insert(e, exp.id,\n                              lookup_path_strict(*e, sc, exp.span,\n                                                 p.node.idents, ns_value));\n             }\n@@ -366,13 +366,13 @@ fn visit_arm_with_scope(&ast::arm a, &scopes sc, &vt[scopes] v) {\n fn visit_expr_with_scope(&@ast::expr x, &scopes sc, &vt[scopes] v) {\n     auto new_sc =\n         alt (x.node) {\n-            case (ast::expr_for(?d, _, _, _)) {\n+            case (ast::expr_for(?d, _, _)) {\n                 cons[scope](scope_loop(d), @sc)\n             }\n-            case (ast::expr_for_each(?d, _, _, _)) {\n+            case (ast::expr_for_each(?d, _, _)) {\n                 cons[scope](scope_loop(d), @sc)\n             }\n-            case (ast::expr_fn(?f, _)) { cons(scope_fn(f.decl, []), @sc) }\n+            case (ast::expr_fn(?f)) { cons(scope_fn(f.decl, []), @sc) }\n             case (_) { sc }\n         };\n     visit::visit_expr(x, new_sc, v);"}, {"sha": "5aaa9849929c59e040a938c02091ebe08546a491", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -4077,18 +4077,20 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond, &ast::block thn,\n     alt (els) {\n         case (some(?elexpr)) {\n             alt (elexpr.node) {\n-                case (ast::expr_if(_, _, _, ?id)) {\n+                case (ast::expr_if(_, _, _)) {\n                     // Synthesize a block here to act as the else block\n                     // containing an if expression. Needed in order for the\n                     // else scope to behave like a normal block scope. A tad\n                     // ugly.\n \n                     let ast::block_ elseif_blk_ =\n-                        rec(stmts=[], expr=some[@ast::expr](elexpr), id=id);\n+                        rec(stmts=[],\n+                            expr=some[@ast::expr](elexpr),\n+                            id=elexpr.id);\n                     auto elseif_blk = rec(node=elseif_blk_, span=elexpr.span);\n                     else_res = trans_block(else_cx, elseif_blk, output);\n                 }\n-                case (ast::expr_block(?blk, _)) {\n+                case (ast::expr_block(?blk)) {\n                     // Calling trans_block directly instead of trans_expr\n                     // because trans_expr will create another scope block\n                     // context for the block, but we've already got the\n@@ -4155,8 +4157,8 @@ fn collect_upvars(&@block_ctxt cx, &ast::block bloc,\n \n     fn walk_expr(env e, &@ast::expr expr) {\n         alt (expr.node) {\n-            case (ast::expr_path(?path, ?id)) {\n-                alt (e.def_map.get(id)) {\n+            case (ast::expr_path(?path)) {\n+                alt (e.def_map.get(expr.id)) {\n                     case (ast::def_arg(?did)) {\n                         vec::push(e.refs, did._1);\n                     }\n@@ -4354,7 +4356,7 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n \n     // Step 3: Call iter passing [lliterbody, llenv], plus other args.\n     alt (seq.node) {\n-        case (ast::expr_call(?f, ?args, ?id)) {\n+        case (ast::expr_call(?f, ?args)) {\n             auto pair = alloca(cx, T_fn_pair(lcx.ccx.tn, iter_body_llty));\n             auto code_cell =\n                 cx.build.GEP(pair, [C_int(0), C_int(abi::fn_field_code)]);\n@@ -4369,7 +4371,7 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n \n             r =\n                 trans_call(cx, f, some[ValueRef](cx.build.Load(pair)), args,\n-                           id);\n+                           seq.id);\n             ret res(r.bcx, C_nil());\n         }\n     }\n@@ -4856,29 +4858,29 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base, &@ast::expr idx,\n // immediate).\n fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n     alt (e.node) {\n-        case (ast::expr_path(?p, ?id)) { ret trans_path(cx, p, id); }\n-        case (ast::expr_field(?base, ?ident, ?id)) {\n+        case (ast::expr_path(?p)) { ret trans_path(cx, p, e.id); }\n+        case (ast::expr_field(?base, ?ident)) {\n             auto r = trans_expr(cx, base);\n             auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, base);\n-            ret trans_field(r.bcx, e.span, r.val, t, ident, id);\n+            ret trans_field(r.bcx, e.span, r.val, t, ident, e.id);\n         }\n-        case (ast::expr_index(?base, ?idx, ?id)) {\n-            ret trans_index(cx, e.span, base, idx, id);\n+        case (ast::expr_index(?base, ?idx)) {\n+            ret trans_index(cx, e.span, base, idx, e.id);\n         }\n-        case (ast::expr_unary(?unop, ?base, ?id)) {\n+        case (ast::expr_unary(?unop, ?base)) {\n             assert (unop == ast::deref);\n             auto sub = trans_expr(cx, base);\n             auto val =\n                 sub.bcx.build.GEP(sub.val,\n                                   [C_int(0), C_int(abi::box_rc_field_body)]);\n             ret lval_mem(sub.bcx, val);\n         }\n-        case (ast::expr_self_method(?ident, ?id)) {\n+        case (ast::expr_self_method(?ident)) {\n             alt ({ cx.fcx.llself }) {\n                 case (some(?pair)) {\n                     auto r = pair.v;\n                     auto t = pair.t;\n-                    ret trans_field(cx, e.span, r, t, ident, id);\n+                    ret trans_field(cx, e.span, r, t, ident, e.id);\n                 }\n                 case (_) {\n                     // Shouldn't happen.\n@@ -4999,10 +5001,9 @@ fn trans_bind_thunk(&@local_ctxt cx, &span sp, &ty::t incoming_fty,\n         auto out_arg = outgoing_args.(outgoing_arg_index);\n         auto llout_arg_ty = llout_arg_tys.(outgoing_arg_index);\n         alt (arg) {\n-            case (\n-                 // Arg provided at binding time; thunk copies it from\n-                 // closure.\n-                 some(?e)) {\n+            // Arg provided at binding time; thunk copies it from\n+            // closure.\n+            case (some(?e)) {\n                 auto e_ty = ty::expr_ty(cx.ccx.tcx, e);\n                 auto bound_arg =\n                     GEP_tup_like(bcx, closure_ty, llclosure,\n@@ -5671,43 +5672,43 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n     // FIXME Fill in cx.sp\n \n     alt (e.node) {\n-        case (ast::expr_lit(?lit, ?id)) {\n-            ret res(cx, trans_lit(cx.fcx.lcx.ccx, *lit, id));\n+        case (ast::expr_lit(?lit)) {\n+            ret res(cx, trans_lit(cx.fcx.lcx.ccx, *lit, e.id));\n         }\n-        case (ast::expr_unary(?op, ?x, ?id)) {\n-            if (op != ast::deref) { ret trans_unary(cx, op, x, id); }\n+        case (ast::expr_unary(?op, ?x)) {\n+            if (op != ast::deref) { ret trans_unary(cx, op, x, e.id); }\n         }\n-        case (ast::expr_binary(?op, ?x, ?y, _)) {\n+        case (ast::expr_binary(?op, ?x, ?y)) {\n             ret trans_binary(cx, op, x, y);\n         }\n-        case (ast::expr_if(?cond, ?thn, ?els, ?id)) {\n-            ret with_out_method(bind trans_if(cx, cond, thn, els, id, _), cx,\n-                                id, output);\n+        case (ast::expr_if(?cond, ?thn, ?els)) {\n+            ret with_out_method(bind trans_if(cx, cond, thn, els, e.id, _),\n+                                cx, e.id, output);\n         }\n-        case (ast::expr_if_check(?cond, ?thn, ?els, ?ann)) {\n-            ret with_out_method(bind trans_if(cx, cond, thn, els, ann, _), cx,\n-                                ann, output);\n+        case (ast::expr_if_check(?cond, ?thn, ?els)) {\n+            ret with_out_method(bind trans_if(cx, cond, thn, els, e.id, _),\n+                                cx, e.id, output);\n         }\n-        case (ast::expr_for(?decl, ?seq, ?body, _)) {\n+        case (ast::expr_for(?decl, ?seq, ?body)) {\n             ret trans_for(cx, decl, seq, body);\n         }\n-        case (ast::expr_for_each(?decl, ?seq, ?body, _)) {\n+        case (ast::expr_for_each(?decl, ?seq, ?body)) {\n             ret trans_for_each(cx, decl, seq, body);\n         }\n-        case (ast::expr_while(?cond, ?body, _)) {\n+        case (ast::expr_while(?cond, ?body)) {\n             ret trans_while(cx, cond, body);\n         }\n-        case (ast::expr_do_while(?body, ?cond, _)) {\n+        case (ast::expr_do_while(?body, ?cond)) {\n             ret trans_do_while(cx, body, cond);\n         }\n-        case (ast::expr_alt(?expr, ?arms, ?id)) {\n-            ret with_out_method(bind trans_alt(cx, expr, arms, id, _), cx,\n-                                id, output);\n+        case (ast::expr_alt(?expr, ?arms)) {\n+            ret with_out_method(bind trans_alt(cx, expr, arms, e.id, _),\n+                                cx, e.id, output);\n         }\n-        case (ast::expr_fn(?f, ?id)) {\n+        case (ast::expr_fn(?f)) {\n             auto ccx = cx.fcx.lcx.ccx;\n             let TypeRef llfnty =\n-                alt (ty::struct(ccx.tcx, node_id_type(ccx, id))) {\n+                alt (ty::struct(ccx.tcx, node_id_type(ccx, e.id))) {\n                     case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n                         type_of_fn_full(ccx, e.span, proto, none, inputs,\n                                         output, 0u)\n@@ -5716,20 +5717,20 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n             auto sub_cx = extend_path(cx.fcx.lcx, ccx.names.next(\"anon\"));\n             auto s = mangle_internal_name_by_path(ccx, sub_cx.path);\n             auto llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfnty);\n-            trans_fn(sub_cx, e.span, f, llfn, none, [], id);\n+            trans_fn(sub_cx, e.span, f, llfn, none, [], e.id);\n             ret res(cx, create_fn_pair(ccx, s, llfnty, llfn, false));\n         }\n-        case (ast::expr_block(?blk, ?id)) {\n+        case (ast::expr_block(?blk)) {\n             auto sub_cx = new_scope_block_ctxt(cx, \"block-expr body\");\n             auto next_cx = new_sub_block_ctxt(cx, \"next\");\n             auto sub =\n-                with_out_method(bind trans_block(sub_cx, blk, _), cx, id,\n+                with_out_method(bind trans_block(sub_cx, blk, _), cx, e.id,\n                                 output);\n             cx.build.Br(sub_cx.llbb);\n             sub.bcx.build.Br(next_cx.llbb);\n             ret res(next_cx, sub.val);\n         }\n-        case (ast::expr_move(?dst, ?src, _)) {\n+        case (ast::expr_move(?dst, ?src)) {\n             auto lhs_res = trans_lval(cx, dst);\n             assert (lhs_res.is_mem);\n             // FIXME Fill in lhs_res.res.bcx.sp\n@@ -5743,7 +5744,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n                          rhs_res.res.val, t);\n             ret res(move_res.bcx, C_nil());\n         }\n-        case (ast::expr_assign(?dst, ?src, _)) {\n+        case (ast::expr_assign(?dst, ?src)) {\n             auto lhs_res = trans_lval(cx, dst);\n             assert (lhs_res.is_mem);\n             // FIXME Fill in lhs_res.res.bcx.sp\n@@ -5757,7 +5758,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n                          rhs_res.val, t);\n             ret res(copy_res.bcx, C_nil());\n         }\n-        case (ast::expr_swap(?dst, ?src, _)) {\n+        case (ast::expr_swap(?dst, ?src)) {\n             auto lhs_res = trans_lval(cx, dst);\n             assert (lhs_res.is_mem);\n             // FIXME Fill in lhs_res.res.bcx.sp\n@@ -5776,7 +5777,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n                 memmove_ty(move2_res.bcx, rhs_res.res.val, tmp_res.val, t);\n             ret res(move3_res.bcx, C_nil());\n         }\n-        case (ast::expr_assign_op(?op, ?dst, ?src, _)) {\n+        case (ast::expr_assign_op(?op, ?dst, ?src)) {\n             auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, src);\n             auto lhs_res = trans_lval(cx, dst);\n             assert (lhs_res.is_mem);\n@@ -5806,59 +5807,59 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n                 copy_val(v.bcx, DROP_EXISTING, lhs_res.res.val, v.val, t);\n             ret res(copy_res.bcx, C_nil());\n         }\n-        case (ast::expr_bind(?f, ?args, ?id)) {\n-            ret trans_bind(cx, f, args, id);\n+        case (ast::expr_bind(?f, ?args)) {\n+            ret trans_bind(cx, f, args, e.id);\n         }\n-        case (ast::expr_call(?f, ?args, ?id)) {\n-            ret trans_call(cx, f, none[ValueRef], args, id);\n+        case (ast::expr_call(?f, ?args)) {\n+            ret trans_call(cx, f, none[ValueRef], args, e.id);\n         }\n-        case (ast::expr_cast(?e, _, ?id)) { ret trans_cast(cx, e, id); }\n-        case (ast::expr_vec(?args, _, ast::sk_rc, ?id)) {\n-            ret trans_vec(cx, args, id);\n+        case (ast::expr_cast(?val, _)) { ret trans_cast(cx, val, e.id); }\n+        case (ast::expr_vec(?args, _, ast::sk_rc)) {\n+            ret trans_vec(cx, args, e.id);\n         }\n-        case (ast::expr_vec(?args, _, ast::sk_unique, ?id)) {\n-            ret trans_ivec(cx, args, id);\n+        case (ast::expr_vec(?args, _, ast::sk_unique)) {\n+            ret trans_ivec(cx, args, e.id);\n         }\n-        case (ast::expr_tup(?args, ?id)) { ret trans_tup(cx, args, id); }\n-        case (ast::expr_rec(?args, ?base, ?id)) {\n-            ret trans_rec(cx, args, base, id);\n+        case (ast::expr_tup(?args)) { ret trans_tup(cx, args, e.id); }\n+        case (ast::expr_rec(?args, ?base)) {\n+            ret trans_rec(cx, args, base, e.id);\n         }\n-        case (ast::expr_ext(_, _, _, ?expanded, _)) {\n+        case (ast::expr_ext(_, _, _, ?expanded)) {\n             ret trans_expr(cx, expanded);\n         }\n-        case (ast::expr_fail(_, ?str)) {\n+        case (ast::expr_fail(?str)) {\n             auto failmsg;\n             alt (str) {\n                 case (some(?msg)) { failmsg = msg; }\n                 case (_) { failmsg = \"explicit failure\"; }\n             }\n             ret trans_fail(cx, some(e.span), failmsg);\n         }\n-        case (ast::expr_log(?lvl, ?a, _)) { ret trans_log(lvl, cx, a); }\n-        case (ast::expr_assert(?a, _)) {\n+        case (ast::expr_log(?lvl, ?a)) { ret trans_log(lvl, cx, a); }\n+        case (ast::expr_assert(?a)) {\n             ret trans_check_expr(cx, a, \"Assertion\");\n         }\n-        case (ast::expr_check(?a, _)) {\n+        case (ast::expr_check(?a)) {\n             ret trans_check_expr(cx, a, \"Predicate\");\n         }\n-        case (ast::expr_break(?a)) { ret trans_break(e.span, cx); }\n-        case (ast::expr_cont(?a)) { ret trans_cont(e.span, cx); }\n-        case (ast::expr_ret(?e, _)) { ret trans_ret(cx, e); }\n-        case (ast::expr_put(?e, _)) { ret trans_put(cx, e); }\n-        case (ast::expr_be(?e, _)) { ret trans_be(cx, e); }\n-        case (ast::expr_port(?id)) { ret trans_port(cx, id); }\n-        case (ast::expr_chan(?e, ?id)) { ret trans_chan(cx, e, id); }\n-        case (ast::expr_send(?lhs, ?rhs, ?id)) {\n-            ret trans_send(cx, lhs, rhs, id);\n+        case (ast::expr_break) { ret trans_break(e.span, cx); }\n+        case (ast::expr_cont) { ret trans_cont(e.span, cx); }\n+        case (ast::expr_ret(?ex)) { ret trans_ret(cx, ex); }\n+        case (ast::expr_put(?ex)) { ret trans_put(cx, ex); }\n+        case (ast::expr_be(?ex)) { ret trans_be(cx, ex); }\n+        case (ast::expr_port) { ret trans_port(cx, e.id); }\n+        case (ast::expr_chan(?ex)) { ret trans_chan(cx, ex, e.id); }\n+        case (ast::expr_send(?lhs, ?rhs)) {\n+            ret trans_send(cx, lhs, rhs, e.id);\n         }\n-        case (ast::expr_recv(?lhs, ?rhs, ?id)) {\n-            ret trans_recv(cx, lhs, rhs, id);\n+        case (ast::expr_recv(?lhs, ?rhs)) {\n+            ret trans_recv(cx, lhs, rhs, e.id);\n         }\n-        case (ast::expr_spawn(?dom, ?name, ?func, ?args, ?id)) {\n-            ret trans_spawn(cx, dom, name, func, args, id);\n+        case (ast::expr_spawn(?dom, ?name, ?func, ?args)) {\n+            ret trans_spawn(cx, dom, name, func, args, e.id);\n         }\n-        case (ast::expr_anon_obj(?anon_obj, ?tps, ?odid, ?id)) {\n-            ret trans_anon_obj(cx, e.span, anon_obj, tps, odid.ctor, id);\n+        case (ast::expr_anon_obj(?anon_obj, ?tps, ?odid)) {\n+            ret trans_anon_obj(cx, e.span, anon_obj, tps, odid.ctor, e.id);\n         }\n         case (_) {\n             // The expression is an lvalue. Fall through.\n@@ -6600,8 +6601,7 @@ fn init_local(&@block_ctxt cx, &@ast::local local) -> result {\n                     // the value.\n \n                     ty =\n-                        node_id_type(cx.fcx.lcx.ccx,\n-                                      ty::expr_node_id(init.expr));\n+                        node_id_type(cx.fcx.lcx.ccx, init.expr.id);\n                     auto sub = trans_expr(bcx, init.expr);\n                     bcx = copy_val(sub.bcx, INIT, llptr, sub.val, ty).bcx;\n                 }\n@@ -6836,9 +6836,9 @@ fn trans_block(&@block_ctxt cx, &ast::block b, &out_method output) -> result {\n     }\n     fn accept_out_method(&@ast::expr expr) -> bool {\n         ret alt (expr.node) {\n-                case (ast::expr_if(_, _, _, _)) { true }\n-                case (ast::expr_alt(_, _, _)) { true }\n-                case (ast::expr_block(_, _)) { true }\n+                case (ast::expr_if(_, _, _)) { true }\n+                case (ast::expr_alt(_, _)) { true }\n+                case (ast::expr_block(_)) { true }\n                 case (_) { false }\n             };\n     }\n@@ -7506,7 +7506,7 @@ fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n // that does so later on?\n fn trans_const_expr(&@crate_ctxt cx, @ast::expr e) -> ValueRef {\n     alt (e.node) {\n-        case (ast::expr_lit(?lit, ?id)) { ret trans_lit(cx, *lit, id); }\n+        case (ast::expr_lit(?lit)) { ret trans_lit(cx, *lit, e.id); }\n         case (_) {\n             cx.sess.span_unimpl(e.span, \"consts that's not a plain literal\");\n         }"}, {"sha": "ce4976f554d677e476cddb6170f41c276d8b25d9", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -4,7 +4,6 @@ import std::option;\n import std::option::some;\n import std::option::none;\n import front::ast::*;\n-import middle::ty::expr_node_id;\n import util::common::istr;\n import util::common::uistr;\n import util::common::span;\n@@ -25,7 +24,7 @@ import aux::add_node;\n import middle::tstate::ann::empty_ann;\n \n fn collect_ids_expr(&@expr e, @mutable vec[node_id] res) {\n-    vec::push(*res, expr_node_id(e));\n+    vec::push(*res, e.id);\n }\n \n fn collect_ids_block(&block b, @mutable vec[node_id] res) {"}, {"sha": "fea8a101f9fb0ca6b7c581d6b96c70aed6a58ffb", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -10,7 +10,6 @@ import std::option::some;\n import std::option::maybe;\n import front::ast;\n import front::ast::*;\n-import middle::ty::expr_node_id;\n import util::common;\n import util::common::span;\n import util::common::respan;\n@@ -284,14 +283,14 @@ fn stmt_to_ann(&crate_ctxt ccx, &stmt s) -> ts_ann {\n /* fails if e has no annotation */\n fn expr_states(&crate_ctxt ccx, @expr e) -> pre_and_post_state {\n     log \"expr_states\";\n-    ret node_id_to_ts_ann(ccx, expr_node_id(e)).states;\n+    ret node_id_to_ts_ann(ccx, e.id).states;\n }\n \n \n /* fails if e has no annotation */\n fn expr_pp(&crate_ctxt ccx, @expr e) -> pre_and_post {\n     log \"expr_pp\";\n-    ret node_id_to_ts_ann(ccx, expr_node_id(e)).conditions;\n+    ret node_id_to_ts_ann(ccx, e.id).conditions;\n }\n \n fn stmt_pp(&crate_ctxt ccx, &stmt s) -> pre_and_post {\n@@ -461,14 +460,14 @@ fn new_crate_ctxt(ty::ctxt cx) -> crate_ctxt {\n  If it has a function type with a ! annotation,\n the answer is noreturn. */\n fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n-    alt (ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, expr_node_id(e)))) {\n+    alt (ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, e.id))) {\n         case (ty::ty_fn(_, _, _, ?cf, _)) { ret cf; }\n         case (_) { ret return; }\n     }\n }\n \n fn constraints_expr(&ty::ctxt cx, @expr e) -> vec[@ty::constr_def] {\n-    alt (ty::struct(cx, ty::node_id_to_type(cx, expr_node_id(e)))) {\n+    alt (ty::struct(cx, ty::node_id_to_type(cx, e.id))) {\n         case (ty::ty_fn(_, _, _, _, ?cs)) { ret cs; }\n         case (_) { ret []; }\n     }\n@@ -547,15 +546,15 @@ fn node_id_for_constr(ty::ctxt tcx, node_id t) -> node_id {\n \n fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n     alt (e.node) {\n-        case (expr_path(?p, _)) {\n+        case (expr_path(?p)) {\n             if (vec::len(p.node.idents) == 1u) {\n                 ret @respan(p.span, carg_ident[ident](p.node.idents.(0)));\n             } else {\n                 tcx.sess.bug(\"exprs_to_constr_args: non-local variable \" +\n                                  \"as pred arg\");\n             }\n         }\n-        case (expr_lit(?l, _)) { ret @respan(e.span, carg_lit(l)); }\n+        case (expr_lit(?l)) { ret @respan(e.span, carg_lit(l)); }\n         case (_) {\n             tcx.sess.span_fatal(e.span,\n                               \"Arguments to constrained functions must be \"\n@@ -575,11 +574,11 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n         case (\n              // FIXME change the first pattern to expr_path to test a\n              // typechecker bug\n-             expr_call(?operator, ?args, _)) {\n+             expr_call(?operator, ?args)) {\n             alt (operator.node) {\n-                case (expr_path(?p, ?id)) {\n+                case (expr_path(?p)) {\n                     ret respan(e.span,\n-                               rec(id=node_id_for_constr(tcx, id),\n+                               rec(id=node_id_for_constr(tcx, operator.id),\n                                    c=npred(p,\n                                            exprs_to_constr_args(tcx, args))));\n                 }"}, {"sha": "7e10f9deb8fb4a285767fdc9916adee25cabb322", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -35,15 +35,15 @@ fn collect_local(&ctxt cx, &@local loc) {\n \n fn collect_pred(&ctxt cx, &@expr e) {\n     alt (e.node) {\n-        case (expr_check(?e, _)) {\n-            vec::push(*cx.cs, expr_to_constr(cx.tcx, e));\n+        case (expr_check(?ch)) {\n+            vec::push(*cx.cs, expr_to_constr(cx.tcx, ch));\n         }\n-        case (expr_if_check(?e, _, _, _)) {\n-            vec::push(*cx.cs, expr_to_constr(cx.tcx, e));\n+        case (expr_if_check(?ex, _, _)) {\n+            vec::push(*cx.cs, expr_to_constr(cx.tcx, ex));\n         }\n         // If it's a call, generate appropriate instances of the\n         // call's constraints.\n-        case (expr_call(?operator, ?operands, _)) {\n+        case (expr_call(?operator, ?operands)) {\n             for (@ty::constr_def c in constraints_expr(cx.tcx, operator)) {\n                 let aux::constr ct = respan(c.span,\n                       rec(id=c.node.id._1,"}, {"sha": "8c7cb5067a7cd1b9cf85399ef5c513cb008f7ef4", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 94, "deletions": 102, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -60,7 +60,6 @@ import bitvectors::bit_num;\n import bitvectors::gen;\n import bitvectors::relax_precond_block;\n import front::ast::*;\n-import middle::ty::expr_node_id;\n import util::common::new_int_hash;\n import util::common::new_def_hash;\n import util::common::uistr;\n@@ -189,7 +188,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n             alt (chck) {\n                 case (if_check) {\n                     let aux::constr c = expr_to_constr(fcx.ccx.tcx, antec);\n-                    gen(fcx, expr_node_id(antec), c.node);\n+                    gen(fcx, antec.id, c.node);\n                 }\n                 case (_) {}\n             }\n@@ -222,7 +221,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n             alt (chck) {\n                 case (if_check) {\n                     let aux::constr c = expr_to_constr(fcx.ccx.tcx, antec);\n-                    gen(fcx, expr_node_id(antec), c.node);\n+                    gen(fcx, antec.id, c.node);\n                 }\n                 case (_) {}\n             }\n@@ -278,10 +277,10 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             \"):\";\n     log_expr(*e);\n     alt (e.node) {\n-        case (expr_call(?operator, ?operands, ?id)) {\n+        case (expr_call(?operator, ?operands)) {\n             auto args = vec::clone[@expr](operands);\n             vec::push[@expr](args, operator);\n-            find_pre_post_exprs(fcx, args, id);\n+            find_pre_post_exprs(fcx, args, e.id);\n             /* see if the call has any constraints on its type */\n \n             log \"a function: \";\n@@ -299,25 +298,25 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n \n             /* if this is a failing call, its postcondition sets everything */\n             alt (controlflow_expr(fcx.ccx, operator)) {\n-                case (noreturn) { set_postcond_false(fcx.ccx, id); }\n+                case (noreturn) { set_postcond_false(fcx.ccx, e.id); }\n                 case (_) { }\n             }\n         }\n-        case (expr_spawn(_, _, ?operator, ?operands, ?id)) {\n+        case (expr_spawn(_, _, ?operator, ?operands)) {\n             auto args = vec::clone[@expr](operands);\n             vec::push[@expr](args, operator);\n-            find_pre_post_exprs(fcx, args, id);\n+            find_pre_post_exprs(fcx, args, e.id);\n         }\n-        case (expr_vec(?args, _, _, ?id)) {\n-            find_pre_post_exprs(fcx, args, id);\n+        case (expr_vec(?args, _, _)) {\n+            find_pre_post_exprs(fcx, args, e.id);\n         }\n-        case (expr_tup(?elts, ?id)) {\n-            find_pre_post_exprs(fcx, elt_exprs(elts), id);\n+        case (expr_tup(?elts)) {\n+            find_pre_post_exprs(fcx, elt_exprs(elts), e.id);\n         }\n-        case (expr_path(?p, ?id)) {\n+        case (expr_path(?p)) {\n             auto res = expr_pp(fcx.ccx, e);\n             clear_pp(res);\n-            auto df = node_id_to_def_strict(fcx.ccx.tcx, id);\n+            auto df = node_id_to_def_strict(fcx.ccx.tcx, e.id);\n             alt (df) {\n                 case (def_local(?d_id)) {\n                     auto i =\n@@ -329,126 +328,121 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                 case (_) {/* nothing to check */ }\n             }\n         }\n-        case (expr_self_method(?v, ?id)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_log(_, ?arg, ?id)) {\n+        case (expr_self_method(?v)) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_log(_, ?arg)) {\n             find_pre_post_expr(fcx, arg);\n-            copy_pre_post(fcx.ccx, id, arg);\n+            copy_pre_post(fcx.ccx, e.id, arg);\n         }\n-        case (expr_chan(?arg, ?id)) {\n+        case (expr_chan(?arg)) {\n             find_pre_post_expr(fcx, arg);\n-            copy_pre_post(fcx.ccx, id, arg);\n+            copy_pre_post(fcx.ccx, e.id, arg);\n         }\n-        case (expr_put(?opt, ?id)) {\n+        case (expr_put(?opt)) {\n             alt (opt) {\n                 case (some(?arg)) {\n                     find_pre_post_expr(fcx, arg);\n-                    copy_pre_post(fcx.ccx, id, arg);\n+                    copy_pre_post(fcx.ccx, e.id, arg);\n                 }\n                 case (none) { clear_pp(expr_pp(fcx.ccx, e)); }\n             }\n         }\n-        case (\n-             // FIXME this was just put in here as a placeholder\n-             expr_fn(?f, ?id)) {\n-            clear_pp(expr_pp(fcx.ccx, e));\n-        }\n-        case (expr_block(?b, ?id)) {\n+        // FIXME this was just put in here as a placeholder\n+        case (expr_fn(?f)) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_block(?b)) {\n             find_pre_post_block(fcx, b);\n             auto p = block_pp(fcx.ccx, b);\n-            set_pre_and_post(fcx.ccx, id, p.precondition, p.postcondition);\n+            set_pre_and_post(fcx.ccx, e.id, p.precondition, p.postcondition);\n         }\n-        case (expr_rec(?fields, ?maybe_base, ?id)) {\n+        case (expr_rec(?fields, ?maybe_base)) {\n             auto es = field_exprs(fields);\n             vec::plus_option[@expr](es, maybe_base);\n-            find_pre_post_exprs(fcx, es, id);\n+            find_pre_post_exprs(fcx, es, e.id);\n         }\n-        case (expr_move(?lhs, ?rhs, ?id)) {\n-\n+        case (expr_move(?lhs, ?rhs)) {\n             // FIXME: this needs to deinitialize the rhs\n             alt (lhs.node) {\n-                case (expr_path(?p, ?a_lhs)) {\n-                    gen_if_local(fcx, lhs, rhs, id, a_lhs, p);\n+                case (expr_path(?p)) {\n+                    gen_if_local(fcx, lhs, rhs, e.id, lhs.id, p);\n                 }\n-                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], id); }\n+                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], e.id); }\n             }\n         }\n-        case (expr_swap(?lhs, ?rhs, ?id)) {\n+        case (expr_swap(?lhs, ?rhs)) {\n             // Both sides must already be initialized\n \n-            find_pre_post_exprs(fcx, [lhs, rhs], id);\n+            find_pre_post_exprs(fcx, [lhs, rhs], e.id);\n         }\n-        case (expr_assign(?lhs, ?rhs, ?id)) {\n+        case (expr_assign(?lhs, ?rhs)) {\n             alt (lhs.node) {\n-                case (expr_path(?p, ?a_lhs)) {\n-                    gen_if_local(fcx, lhs, rhs, id, a_lhs, p);\n+                case (expr_path(?p)) {\n+                    gen_if_local(fcx, lhs, rhs, e.id, lhs.id, p);\n                 }\n-                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], id); }\n+                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], e.id); }\n             }\n         }\n-        case (expr_recv(?lhs, ?rhs, ?id)) {\n+        case (expr_recv(?lhs, ?rhs)) {\n             alt (rhs.node) {\n-                case (expr_path(?p, ?id_rhs)) {\n-                    gen_if_local(fcx, rhs, lhs, id, id_rhs, p);\n+                case (expr_path(?p)) {\n+                    gen_if_local(fcx, rhs, lhs, e.id, rhs.id, p);\n                 }\n                 case (_) {\n                     // doesn't check that rhs is an lval, but\n                     // that's probably ok\n \n-                    find_pre_post_exprs(fcx, [lhs, rhs], id);\n+                    find_pre_post_exprs(fcx, [lhs, rhs], e.id);\n                 }\n             }\n         }\n-        case (expr_assign_op(_, ?lhs, ?rhs, ?id)) {\n+        case (expr_assign_op(_, ?lhs, ?rhs)) {\n             /* Different from expr_assign in that the lhs *must*\n                already be initialized */\n \n-            find_pre_post_exprs(fcx, [lhs, rhs], id);\n+            find_pre_post_exprs(fcx, [lhs, rhs], e.id);\n         }\n-        case (expr_lit(_, ?id)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_ret(?maybe_val, ?id)) {\n+        case (expr_lit(_)) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_ret(?maybe_val)) {\n             alt (maybe_val) {\n                 case (none) {\n-                    clear_precond(fcx.ccx, id);\n-                    set_postcond_false(fcx.ccx, id);\n+                    clear_precond(fcx.ccx, e.id);\n+                    set_postcond_false(fcx.ccx, e.id);\n                 }\n                 case (some(?ret_val)) {\n                     find_pre_post_expr(fcx, ret_val);\n-                    set_precondition(node_id_to_ts_ann(fcx.ccx, id),\n+                    set_precondition(node_id_to_ts_ann(fcx.ccx, e.id),\n                                      expr_precond(fcx.ccx, ret_val));\n-                    set_postcond_false(fcx.ccx, id);\n+                    set_postcond_false(fcx.ccx, e.id);\n                 }\n             }\n         }\n-        case (expr_be(?e, ?id)) {\n-            find_pre_post_expr(fcx, e);\n-            set_pre_and_post(fcx.ccx, id, expr_prestate(fcx.ccx, e),\n+        case (expr_be(?val)) {\n+            find_pre_post_expr(fcx, val);\n+            set_pre_and_post(fcx.ccx, e.id, expr_prestate(fcx.ccx, val),\n                              false_postcond(num_local_vars));\n         }\n-        case (expr_if(?antec, ?conseq, ?maybe_alt, ?id)) {\n-            join_then_else(fcx, antec, conseq, maybe_alt, id, plain_if);\n+        case (expr_if(?antec, ?conseq, ?maybe_alt)) {\n+            join_then_else(fcx, antec, conseq, maybe_alt, e.id, plain_if);\n         }\n-        case (expr_binary(?bop, ?l, ?r, ?id)) {\n+        case (expr_binary(?bop, ?l, ?r)) {\n             /* *unless* bop is lazy (e.g. and, or)? \n                FIXME */\n \n-            find_pre_post_exprs(fcx, [l, r], id);\n+            find_pre_post_exprs(fcx, [l, r], e.id);\n         }\n-        case (expr_send(?l, ?r, ?id)) {\n-            find_pre_post_exprs(fcx, [l, r], id);\n+        case (expr_send(?l, ?r)) {\n+            find_pre_post_exprs(fcx, [l, r], e.id);\n         }\n-        case (expr_unary(_, ?operand, ?id)) {\n+        case (expr_unary(_, ?operand)) {\n             find_pre_post_expr(fcx, operand);\n-            copy_pre_post(fcx.ccx, id, operand);\n+            copy_pre_post(fcx.ccx, e.id, operand);\n         }\n-        case (expr_cast(?operand, _, ?id)) {\n+        case (expr_cast(?operand, _)) {\n             find_pre_post_expr(fcx, operand);\n-            copy_pre_post(fcx.ccx, id, operand);\n+            copy_pre_post(fcx.ccx, e.id, operand);\n         }\n-        case (expr_while(?test, ?body, ?id)) {\n+        case (expr_while(?test, ?body)) {\n             find_pre_post_expr(fcx, test);\n             find_pre_post_block(fcx, body);\n-            log \"666\";\n-            set_pre_and_post(fcx.ccx, id,\n+            set_pre_and_post(fcx.ccx, e.id,\n                              seq_preconds(fcx,\n                                           [expr_pp(fcx.ccx, test),\n                                            block_pp(fcx.ccx, body)]),\n@@ -457,7 +451,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                                                   block_postcond(fcx.ccx,\n                                                                  body)]));\n         }\n-        case (expr_do_while(?body, ?test, ?id)) {\n+        case (expr_do_while(?body, ?test)) {\n             find_pre_post_block(fcx, body);\n             find_pre_post_expr(fcx, test);\n             auto loop_postcond =\n@@ -470,22 +464,22 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             if (has_nonlocal_exits(body)) {\n                 loop_postcond = empty_poststate(num_local_vars);\n             }\n-            set_pre_and_post(fcx.ccx, id,\n+            set_pre_and_post(fcx.ccx, e.id,\n                              seq_preconds(fcx,\n                                           [block_pp(fcx.ccx, body),\n                                            expr_pp(fcx.ccx, test)]),\n                              loop_postcond);\n         }\n-        case (expr_for(?d, ?index, ?body, ?id)) {\n-            find_pre_post_loop(fcx, d, index, body, id);\n+        case (expr_for(?d, ?index, ?body)) {\n+            find_pre_post_loop(fcx, d, index, body, e.id);\n         }\n-        case (expr_for_each(?d, ?index, ?body, ?id)) {\n-            find_pre_post_loop(fcx, d, index, body, id);\n+        case (expr_for_each(?d, ?index, ?body)) {\n+            find_pre_post_loop(fcx, d, index, body, e.id);\n         }\n-        case (expr_index(?e, ?sub, ?id)) {\n-            find_pre_post_exprs(fcx, [e, sub], id);\n+        case (expr_index(?val, ?sub)) {\n+            find_pre_post_exprs(fcx, [val, sub], e.id);\n         }\n-        case (expr_alt(?ex, ?alts, ?id)) {\n+        case (expr_alt(?ex, ?alts)) {\n             find_pre_post_expr(fcx, ex);\n             fn do_an_alt(&fn_ctxt fcx, &arm an_alt) -> pre_and_post {\n                 find_pre_post_block(fcx, an_alt.block);\n@@ -495,7 +489,6 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             auto alt_pps = vec::map[arm, pre_and_post](f, alts);\n             fn combine_pp(pre_and_post antec, fn_ctxt fcx, &pre_and_post pp,\n                           &pre_and_post next) -> pre_and_post {\n-                log \"777\";\n                 union(pp.precondition, seq_preconds(fcx, [antec, next]));\n                 intersect(pp.postcondition, next.postcondition);\n                 ret pp;\n@@ -507,54 +500,54 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             auto g = bind combine_pp(antec_pp, fcx, _, _);\n             auto alts_overall_pp =\n                 vec::foldl[pre_and_post, pre_and_post](g, e_pp, alt_pps);\n-            set_pre_and_post(fcx.ccx, id, alts_overall_pp.precondition,\n+            set_pre_and_post(fcx.ccx, e.id, alts_overall_pp.precondition,\n                              alts_overall_pp.postcondition);\n         }\n-        case (expr_field(?operator, _, ?id)) {\n+        case (expr_field(?operator, _)) {\n             find_pre_post_expr(fcx, operator);\n-            copy_pre_post(fcx.ccx, id, operator);\n+            copy_pre_post(fcx.ccx, e.id, operator);\n         }\n-        case (expr_fail(?id, _)) {\n-            set_pre_and_post(fcx.ccx, id,\n+        case (expr_fail(_)) {\n+            set_pre_and_post(fcx.ccx, e.id,\n                              /* if execution continues after fail,\n                                 then everything is true! */\n                              empty_prestate(num_local_vars),\n                              false_postcond(num_local_vars));\n         }\n-        case (expr_assert(?p, ?id)) {\n+        case (expr_assert(?p)) {\n             find_pre_post_expr(fcx, p);\n-            copy_pre_post(fcx.ccx, id, p);\n+            copy_pre_post(fcx.ccx, e.id, p);\n         }\n-        case (expr_check(?p, ?id)) {\n+        case (expr_check(?p)) {\n             find_pre_post_expr(fcx, p);\n-            copy_pre_post(fcx.ccx, id, p);\n+            copy_pre_post(fcx.ccx, e.id, p);\n             /* predicate p holds after this expression executes */\n \n             let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n-            gen(fcx, id, c.node);\n+            gen(fcx, e.id, c.node);\n         }\n-        case (expr_if_check(?p, ?conseq, ?maybe_alt, ?id)) {\n-            join_then_else(fcx, p, conseq, maybe_alt, id, if_check);\n+        case (expr_if_check(?p, ?conseq, ?maybe_alt)) {\n+            join_then_else(fcx, p, conseq, maybe_alt, e.id, if_check);\n         }\n \n-        case (expr_bind(?operator, ?maybe_args, ?id)) {\n+        case (expr_bind(?operator, ?maybe_args)) {\n             auto args = vec::cat_options[@expr](maybe_args);\n             vec::push[@expr](args, operator); /* ??? order of eval? */\n \n-            find_pre_post_exprs(fcx, args, id);\n+            find_pre_post_exprs(fcx, args, e.id);\n         }\n-        case (expr_break(?id)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_cont(?id)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_port(?id)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_ext(_, _, _, ?expanded, ?id)) {\n+        case (expr_break) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_cont) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_port) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_ext(_, _, _, ?expanded)) {\n             find_pre_post_expr(fcx, expanded);\n-            copy_pre_post(fcx.ccx, id, expanded);\n+            copy_pre_post(fcx.ccx, e.id, expanded);\n         }\n-        case (expr_anon_obj(?anon_obj, _, _, ?id)) {\n+        case (expr_anon_obj(?anon_obj, _, _)) {\n             alt (anon_obj.with_obj) {\n                 case (some(?ex)) {\n                     find_pre_post_expr(fcx, ex);\n-                    copy_pre_post(fcx.ccx, id, ex);\n+                    copy_pre_post(fcx.ccx, e.id, ex);\n                 }\n                 case (none) { clear_pp(expr_pp(fcx.ccx, e)); }\n             }\n@@ -672,8 +665,7 @@ fn find_pre_post_fn(&fn_ctxt fcx, &_fn f) {\n     // Treat the tail expression as a return statement\n     alt (f.body.node.expr) {\n         case (some(?tailexpr)) {\n-            auto tailann = expr_node_id(tailexpr);\n-            set_postcond_false(fcx.ccx, tailann);\n+            set_postcond_false(fcx.ccx, tailexpr.id);\n         }\n         case (none) {/* fallthrough */ }\n     }"}, {"sha": "2efcb672794e0e34dcae2e1f0ef1673ac6efc2e5", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 209, "deletions": 256, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -73,7 +73,6 @@ import bitvectors::gen_poststate;\n import bitvectors::kill_poststate;\n import front::ast;\n import front::ast::*;\n-import middle::ty::expr_node_id;\n import middle::ty::expr_ty;\n import middle::ty::type_is_nil;\n import middle::ty::type_is_bot;\n@@ -238,13 +237,13 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n \n     /* FIXME could get rid of some of the copy/paste */\n     alt (e.node) {\n-        case (expr_vec(?elts, _, _, ?id)) {\n-            ret find_pre_post_state_exprs(fcx, pres, id, elts);\n+        case (expr_vec(?elts, _, _)) {\n+            ret find_pre_post_state_exprs(fcx, pres, e.id, elts);\n         }\n-        case (expr_tup(?elts, ?id)) {\n-            ret find_pre_post_state_exprs(fcx, pres, id, elt_exprs(elts));\n+        case (expr_tup(?elts)) {\n+            ret find_pre_post_state_exprs(fcx, pres, e.id, elt_exprs(elts));\n         }\n-        case (expr_call(?operator, ?operands, ?id)) {\n+        case (expr_call(?operator, ?operands)) {\n             /* do the prestate for the rator */\n \n             /*            fcx.ccx.tcx.sess.span_note(operator.span, \n@@ -258,13 +257,13 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             changed =\n                 find_pre_post_state_exprs(fcx,\n                                           expr_poststate(fcx.ccx, operator),\n-                                          id, operands) || changed;\n+                                          e.id, operands) || changed;\n             /* if this is a failing call, it sets everything as initialized */\n \n             alt (controlflow_expr(fcx.ccx, operator)) {\n                 case (noreturn) {\n                     changed =\n-                        set_poststate_ann(fcx.ccx, id,\n+                        set_poststate_ann(fcx.ccx, e.id,\n                                           false_postcond(num_local_vars)) ||\n                             changed;\n                 }\n@@ -276,286 +275,253 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             */\n             ret changed;\n         }\n-        case (expr_spawn(_, _, ?operator, ?operands, ?id)) {\n+        case (expr_spawn(_, _, ?operator, ?operands)) {\n             changed = find_pre_post_state_expr(fcx, pres, operator);\n             ret find_pre_post_state_exprs(fcx,\n                                           expr_poststate(fcx.ccx, operator),\n-                                          id, operands) || changed;\n+                                          e.id, operands) || changed;\n         }\n-        case (expr_bind(?operator, ?maybe_args, ?id)) {\n+        case (expr_bind(?operator, ?maybe_args)) {\n             changed =\n                 find_pre_post_state_expr(fcx, pres, operator) || changed;\n-            ret find_pre_post_state_exprs(fcx,\n-                                          expr_poststate(fcx.ccx, operator),\n-                                          id, cat_options[@expr](maybe_args))\n-                    || changed;\n+            ret find_pre_post_state_exprs\n+                (fcx, expr_poststate(fcx.ccx, operator), e.id,\n+                 cat_options[@expr](maybe_args)) || changed;\n         }\n-        case (expr_path(_, ?id)) { ret pure_exp(fcx.ccx, id, pres); }\n-        case (expr_log(_, ?e, ?id)) {\n+        case (expr_path(_)) { ret pure_exp(fcx.ccx, e.id, pres); }\n+        case (expr_log(_, ?ex)) {\n             /* factor out the \"one exp\" pattern */\n \n-            changed = find_pre_post_state_expr(fcx, pres, e);\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-            changed =\n-                extend_poststate_ann(fcx.ccx, id, expr_poststate(fcx.ccx, e))\n-                    || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, ex);\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = extend_poststate_ann\n+                (fcx.ccx, e.id, expr_poststate(fcx.ccx, ex)) || changed;\n             ret changed;\n         }\n-        case (expr_chan(?e, ?id)) {\n-            changed = find_pre_post_state_expr(fcx, pres, e);\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-            changed =\n-                extend_poststate_ann(fcx.ccx, id, expr_poststate(fcx.ccx, e))\n-                    || changed;\n+        case (expr_chan(?ex)) {\n+            changed = find_pre_post_state_expr(fcx, pres, ex);\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = extend_poststate_ann\n+                (fcx.ccx, e.id, expr_poststate(fcx.ccx, ex)) || changed;\n             ret changed;\n         }\n-        case (expr_ext(_, _, _, ?expanded, ?id)) {\n+        case (expr_ext(_, _, _, ?expanded)) {\n             changed = find_pre_post_state_expr(fcx, pres, expanded);\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-            changed =\n-                extend_poststate_ann(fcx.ccx, id,\n-                                     expr_poststate(fcx.ccx, expanded)) ||\n-                    changed;\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = extend_poststate_ann\n+                (fcx.ccx, e.id, expr_poststate(fcx.ccx, expanded)) || changed;\n             ret changed;\n         }\n-        case (expr_put(?maybe_e, ?id)) {\n+        case (expr_put(?maybe_e)) {\n             alt (maybe_e) {\n                 case (some(?arg)) {\n                     changed = find_pre_post_state_expr(fcx, pres, arg);\n-                    changed =\n-                        extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-                    changed =\n-                        extend_poststate_ann(fcx.ccx, id,\n-                                             expr_poststate(fcx.ccx, arg)) ||\n-                            changed;\n+                    changed = extend_prestate_ann\n+                        (fcx.ccx, e.id, pres) || changed;\n+                    changed = extend_poststate_ann\n+                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, arg)) ||\n+                        changed;\n                     ret changed;\n                 }\n-                case (none) { ret pure_exp(fcx.ccx, id, pres); }\n+                case (none) { ret pure_exp(fcx.ccx, e.id, pres); }\n             }\n         }\n-        case (expr_lit(?l, ?id)) { ret pure_exp(fcx.ccx, id, pres); }\n-        case (\n-             // FIXME This was just put in here as a placeholder\n-             expr_fn(?f, ?id)) {\n-            ret pure_exp(fcx.ccx, id, pres);\n-        }\n-        case (expr_block(?b, ?id)) {\n+        case (expr_lit(?l)) { ret pure_exp(fcx.ccx, e.id, pres); }\n+        // FIXME This was just put in here as a placeholder\n+        case (expr_fn(?f)) { ret pure_exp(fcx.ccx, e.id, pres); }\n+        case (expr_block(?b)) {\n             changed = find_pre_post_state_block(fcx, pres, b) || changed;\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-            changed =\n-                extend_poststate_ann(fcx.ccx, id, block_poststate(fcx.ccx, b))\n-                    || changed;\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = extend_poststate_ann\n+                (fcx.ccx, e.id, block_poststate(fcx.ccx, b)) || changed;\n             ret changed;\n         }\n-        case (expr_rec(?fields, ?maybe_base, ?id)) {\n-            changed =\n-                find_pre_post_state_exprs(fcx, pres, id, field_exprs(fields))\n-                    || changed;\n+        case (expr_rec(?fields, ?maybe_base)) {\n+            changed = find_pre_post_state_exprs\n+                (fcx, pres, e.id, field_exprs(fields)) || changed;\n             alt (maybe_base) {\n                 case (none) {/* do nothing */ }\n                 case (some(?base)) {\n                     changed =\n                         find_pre_post_state_expr(fcx, pres, base) || changed;\n-                    changed =\n-                        extend_poststate_ann(fcx.ccx, id,\n-                                             expr_poststate(fcx.ccx, base)) ||\n-                            changed;\n+                    changed = extend_poststate_ann\n+                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, base))\n+                        || changed;\n                 }\n             }\n             ret changed;\n         }\n-        case (expr_move(?lhs, ?rhs, ?id)) {\n+        case (expr_move(?lhs, ?rhs)) {\n             // FIXME: this needs to deinitialize the rhs\n \n-            extend_prestate_ann(fcx.ccx, id, pres);\n+            extend_prestate_ann(fcx.ccx, e.id, pres);\n             alt (lhs.node) {\n-                case (expr_path(?p, ?id_lhs)) {\n+                case (expr_path(?p)) {\n                     // assignment to local var\n \n-                    changed = pure_exp(fcx.ccx, id_lhs, pres) || changed;\n-                    changed =\n-                        find_pre_post_state_expr(fcx, pres, rhs) || changed;\n-                    changed =\n-                        extend_poststate_ann(fcx.ccx, id,\n-                                             expr_poststate(fcx.ccx, rhs)) ||\n-                            changed;\n-                    changed = gen_if_local(fcx, id_lhs, id, p) || changed;\n+                    changed = pure_exp(fcx.ccx, lhs.id, pres) || changed;\n+                    changed = find_pre_post_state_expr\n+                        (fcx, pres, rhs) || changed;\n+                    changed = extend_poststate_ann\n+                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, rhs)) ||\n+                        changed;\n+                    changed = gen_if_local(fcx, lhs.id, e.id, p) || changed;\n                 }\n                 case (_) {\n                     // assignment to something that must already have been\n                     // init'd\n \n-                    changed =\n-                        find_pre_post_state_expr(fcx, pres, lhs) || changed;\n-                    changed =\n-                        find_pre_post_state_expr(fcx,\n-                                                 expr_poststate(fcx.ccx, lhs),\n-                                                 rhs) || changed;\n-                    changed =\n-                        extend_poststate_ann(fcx.ccx, id,\n-                                             expr_poststate(fcx.ccx, rhs)) ||\n-                            changed;\n+                    changed = find_pre_post_state_expr(fcx, pres, lhs)\n+                        || changed;\n+                    changed = find_pre_post_state_expr\n+                        (fcx, expr_poststate(fcx.ccx, lhs), rhs)\n+                        || changed;\n+                    changed = extend_poststate_ann\n+                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, rhs))\n+                        || changed;\n                 }\n             }\n             ret changed;\n         }\n-        case (expr_assign(?lhs, ?rhs, ?id)) {\n-            extend_prestate_ann(fcx.ccx, id, pres);\n+        case (expr_assign(?lhs, ?rhs)) {\n+            extend_prestate_ann(fcx.ccx, e.id, pres);\n             alt (lhs.node) {\n-                case (expr_path(?p, ?a_lhs)) {\n+                case (expr_path(?p)) {\n                     // assignment to local var\n \n-                    changed = pure_exp(fcx.ccx, a_lhs, pres) || changed;\n-                    changed =\n-                        find_pre_post_state_expr(fcx, pres, rhs) || changed;\n-                    changed =\n-                        extend_poststate_ann(fcx.ccx, id,\n-                                             expr_poststate(fcx.ccx, rhs)) ||\n-                            changed;\n-                    changed = gen_if_local(fcx, a_lhs, id, p) || changed;\n+                    changed = pure_exp(fcx.ccx, lhs.id, pres) || changed;\n+                    changed = find_pre_post_state_expr(fcx, pres, rhs)\n+                        || changed;\n+                    changed = extend_poststate_ann\n+                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, rhs))\n+                        || changed;\n+                    changed = gen_if_local(fcx, lhs.id, e.id, p) || changed;\n                 }\n                 case (_) {\n                     // assignment to something that must already have been\n                     // init'd\n \n-                    changed =\n-                        find_pre_post_state_expr(fcx, pres, lhs) || changed;\n-                    changed =\n-                        find_pre_post_state_expr(fcx,\n-                                                 expr_poststate(fcx.ccx, lhs),\n-                                                 rhs) || changed;\n-                    changed =\n-                        extend_poststate_ann(fcx.ccx, id,\n-                                             expr_poststate(fcx.ccx, rhs)) ||\n-                            changed;\n+                    changed = find_pre_post_state_expr(fcx, pres, lhs)\n+                        || changed;\n+                    changed = find_pre_post_state_expr\n+                        (fcx, expr_poststate(fcx.ccx, lhs), rhs) || changed;\n+                    changed = extend_poststate_ann\n+                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, rhs))\n+                        || changed;\n                 }\n             }\n             ret changed;\n         }\n-        case (expr_swap(?lhs, ?rhs, ?id)) {\n+        case (expr_swap(?lhs, ?rhs)) {\n             /* quite similar to binary -- should abstract this */\n \n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n-            changed =\n-                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs),\n-                                         rhs) || changed;\n-            changed =\n-                extend_poststate_ann(fcx.ccx, id,\n-                                     expr_poststate(fcx.ccx, rhs)) || changed;\n+            changed = find_pre_post_state_expr\n+                (fcx, expr_poststate(fcx.ccx, lhs), rhs) || changed;\n+            changed = extend_poststate_ann\n+                (fcx.ccx, e.id, expr_poststate(fcx.ccx, rhs)) || changed;\n             ret changed;\n         }\n-        case (expr_recv(?lhs, ?rhs, ?id)) {\n-            extend_prestate_ann(fcx.ccx, id, pres);\n+        case (expr_recv(?lhs, ?rhs)) {\n+            extend_prestate_ann(fcx.ccx, e.id, pres);\n             alt (rhs.node) {\n-                case (expr_path(?p, ?id_rhs)) {\n+                case (expr_path(?p)) {\n                     // receive to local var\n \n-                    changed = pure_exp(fcx.ccx, id_rhs, pres) || changed;\n-                    changed =\n-                        find_pre_post_state_expr(fcx, pres, lhs) || changed;\n-                    changed =\n-                        extend_poststate_ann(fcx.ccx, id,\n-                                             expr_poststate(fcx.ccx, lhs)) ||\n-                            changed;\n-                    changed = gen_if_local(fcx, id_rhs, id, p) || changed;\n+                    changed = pure_exp(fcx.ccx, rhs.id, pres) || changed;\n+                    changed = find_pre_post_state_expr(fcx, pres, lhs)\n+                        || changed;\n+                    changed = extend_poststate_ann\n+                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, lhs))\n+                        || changed;\n+                    changed = gen_if_local(fcx, rhs.id, e.id, p) || changed;\n                 }\n                 case (_) {\n                     // receive to something that must already have been init'd\n \n-                    changed =\n-                        find_pre_post_state_expr(fcx, pres, rhs) || changed;\n-                    changed =\n-                        find_pre_post_state_expr(fcx,\n-                                                 expr_poststate(fcx.ccx, rhs),\n-                                                 lhs) || changed;\n-                    changed =\n-                        extend_poststate_ann(fcx.ccx, id,\n-                                             expr_poststate(fcx.ccx, lhs)) ||\n-                            changed;\n+                    changed = find_pre_post_state_expr\n+                        (fcx, pres, rhs) || changed;\n+                    changed = find_pre_post_state_expr\n+                        (fcx, expr_poststate(fcx.ccx, rhs), lhs) || changed;\n+                    changed = extend_poststate_ann\n+                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, lhs))\n+                        || changed;\n                 }\n             }\n             ret changed;\n         }\n-        case (expr_ret(?maybe_ret_val, ?id)) {\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+        case (expr_ret(?maybe_ret_val)) {\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             /* normally, everything is true if execution continues after\n                a ret expression (since execution never continues locally\n                after a ret expression */\n \n-            set_poststate_ann(fcx.ccx, id, false_postcond(num_local_vars));\n+            set_poststate_ann(fcx.ccx, e.id, false_postcond(num_local_vars));\n             /* return from an always-failing function clears the return bit */\n \n             alt (fcx.enclosing.cf) {\n                 case (noreturn) {\n-                    kill_poststate(fcx, id, rec(id=fcx.id,\n-                                                c=ninit(fcx.name)));\n+                    kill_poststate(fcx, e.id, rec(id=fcx.id,\n+                                                  c=ninit(fcx.name)));\n                 }\n                 case (_) { }\n             }\n             alt (maybe_ret_val) {\n                 case (none) {/* do nothing */ }\n                 case (some(?ret_val)) {\n-                    changed =\n-                        find_pre_post_state_expr(fcx, pres, ret_val) ||\n-                            changed;\n+                    changed = find_pre_post_state_expr\n+                        (fcx, pres, ret_val) || changed;\n                 }\n             }\n             ret changed;\n         }\n-        case (expr_be(?e, ?id)) {\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-            set_poststate_ann(fcx.ccx, id, false_postcond(num_local_vars));\n-            changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+        case (expr_be(?val)) {\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            set_poststate_ann(fcx.ccx, e.id, false_postcond(num_local_vars));\n+            changed = find_pre_post_state_expr(fcx, pres, val) || changed;\n             ret changed;\n         }\n-        case (expr_if(?antec, ?conseq, ?maybe_alt, ?id)) {\n-            changed = join_then_else(fcx, antec, conseq, maybe_alt, id,\n-                                     plain_if, pres)\n+        case (expr_if(?antec, ?conseq, ?maybe_alt)) {\n+            changed = join_then_else\n+                (fcx, antec, conseq, maybe_alt, e.id, plain_if, pres)\n                 || changed;\n-\n             ret changed;\n         }\n-        case (expr_binary(?bop, ?l, ?r, ?id)) {\n+        case (expr_binary(?bop, ?l, ?r)) {\n             /* FIXME: what if bop is lazy? */\n \n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, l) || changed;\n-            changed =\n-                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r)\n-                    || changed;\n-            changed =\n-                extend_poststate_ann(fcx.ccx, id, expr_poststate(fcx.ccx, r))\n-                    || changed;\n+            changed = find_pre_post_state_expr\n+                (fcx, expr_poststate(fcx.ccx, l), r) || changed;\n+            changed = extend_poststate_ann\n+                (fcx.ccx, e.id, expr_poststate(fcx.ccx, r)) || changed;\n             ret changed;\n         }\n-        case (expr_send(?l, ?r, ?id)) {\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+        case (expr_send(?l, ?r)) {\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, l) || changed;\n-            changed =\n-                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r)\n-                    || changed;\n-            changed =\n-                extend_poststate_ann(fcx.ccx, id, expr_poststate(fcx.ccx, r))\n-                    || changed;\n+            changed = find_pre_post_state_expr\n+                (fcx, expr_poststate(fcx.ccx, l), r) || changed;\n+            changed = extend_poststate_ann\n+                (fcx.ccx, e.id, expr_poststate(fcx.ccx, r)) || changed;\n             ret changed;\n         }\n-        case (expr_assign_op(?op, ?lhs, ?rhs, ?id)) {\n+        case (expr_assign_op(?op, ?lhs, ?rhs)) {\n             /* quite similar to binary -- should abstract this */\n \n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n             changed =\n                 find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs),\n                                          rhs) || changed;\n-            changed =\n-                extend_poststate_ann(fcx.ccx, id,\n-                                     expr_poststate(fcx.ccx, rhs))\n-                    || changed;\n+            changed = extend_poststate_ann\n+                (fcx.ccx, e.id, expr_poststate(fcx.ccx, rhs)) || changed;\n             ret changed;\n         }\n-        case (expr_while(?test, ?body, ?id)) {\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+        case (expr_while(?test, ?body)) {\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             /* to handle general predicates, we need to pass in\n                 pres `intersect` (poststate(a)) \n              like: auto test_pres = intersect_postconds(pres,\n@@ -572,22 +538,17 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             /* conservative approximation: if a loop contains a break\n                or cont, we assume nothing about the poststate */\n             if (has_nonlocal_exits(body)) { \n-                changed = set_poststate_ann(fcx.ccx, id, pres) || changed;\n+                changed = set_poststate_ann(fcx.ccx, e.id, pres) || changed;\n             }\n \n-            changed =\n-                {\n-                    auto e_post = expr_poststate(fcx.ccx, test);\n-                    auto b_post = block_poststate(fcx.ccx, body);\n-                    extend_poststate_ann(fcx.ccx, id,\n-                                         intersect_postconds([e_post,\n-                                                              b_post])) ||\n-                        changed\n-                };\n-            ret changed;\n+            auto e_post = expr_poststate(fcx.ccx, test);\n+            auto b_post = block_poststate(fcx.ccx, body);\n+            ret extend_poststate_ann\n+                (fcx.ccx, e.id, intersect_postconds([e_post, b_post])) ||\n+                changed\n         }\n-        case (expr_do_while(?body, ?test, ?id)) {\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+        case (expr_do_while(?body, ?test)) {\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             auto changed0 = changed;\n             changed = find_pre_post_state_block(fcx, pres, body) || changed;\n             /* conservative approximination: if the body of the loop\n@@ -611,36 +572,36 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                                          test) || changed;\n \n             if (breaks) {\n-                set_poststate_ann(fcx.ccx, id, pres);\n+                set_poststate_ann(fcx.ccx, e.id, pres);\n             }\n             else {\n-                changed =  extend_poststate_ann(fcx.ccx, id,\n+                changed =  extend_poststate_ann(fcx.ccx, e.id,\n                                             expr_poststate(fcx.ccx, test)) ||\n                     changed;\n             }\n             ret changed;\n         }\n-        case (expr_for(?d, ?index, ?body, ?id)) {\n-            ret find_pre_post_state_loop(fcx, pres, d, index, body, id);\n+        case (expr_for(?d, ?index, ?body)) {\n+            ret find_pre_post_state_loop(fcx, pres, d, index, body, e.id);\n         }\n-        case (expr_for_each(?d, ?index, ?body, ?id)) {\n-            ret find_pre_post_state_loop(fcx, pres, d, index, body, id);\n+        case (expr_for_each(?d, ?index, ?body)) {\n+            ret find_pre_post_state_loop(fcx, pres, d, index, body, e.id);\n         }\n-        case (expr_index(?e, ?sub, ?id)) {\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-            changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+        case (expr_index(?val, ?sub)) {\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, val) || changed;\n             changed =\n-                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, e), sub)\n-                    || changed;\n+                find_pre_post_state_expr\n+                (fcx, expr_poststate(fcx.ccx, val), sub) || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, id,\n+                extend_poststate_ann(fcx.ccx, e.id,\n                                      expr_poststate(fcx.ccx, sub));\n             ret changed;\n         }\n-        case (expr_alt(?e, ?alts, ?id)) {\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-            changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n-            auto e_post = expr_poststate(fcx.ccx, e);\n+        case (expr_alt(?val, ?alts)) {\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, val) || changed;\n+            auto e_post = expr_poststate(fcx.ccx, val);\n             auto a_post;\n             if (vec::len[arm](alts) > 0u) {\n                 a_post = false_postcond(num_local_vars);\n@@ -659,85 +620,78 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n \n                 a_post = e_post;\n             }\n-            changed = extend_poststate_ann(fcx.ccx, id, a_post) || changed;\n+            changed = extend_poststate_ann(fcx.ccx, e.id, a_post) || changed;\n             ret changed;\n         }\n-        case (expr_field(?e, _, ?id)) {\n-            changed = find_pre_post_state_expr(fcx, pres, e);\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-            changed =\n-                extend_poststate_ann(fcx.ccx, id, expr_poststate(fcx.ccx, e))\n-                    || changed;\n+        case (expr_field(?val, _)) {\n+            changed = find_pre_post_state_expr(fcx, pres, val);\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = extend_poststate_ann\n+                (fcx.ccx, e.id, expr_poststate(fcx.ccx, val)) || changed;\n             ret changed;\n         }\n-        case (expr_unary(_, ?operand, ?id)) {\n+        case (expr_unary(_, ?operand)) {\n             changed = find_pre_post_state_expr(fcx, pres, operand) || changed;\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-            changed =\n-                extend_poststate_ann(fcx.ccx, id,\n-                                     expr_poststate(fcx.ccx, operand)) ||\n-                    changed;\n-            ret changed;\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            ret extend_poststate_ann\n+                (fcx.ccx, e.id, expr_poststate(fcx.ccx, operand))\n+                || changed;\n         }\n-        case (expr_cast(?operand, _, ?id)) {\n+        case (expr_cast(?operand, _)) {\n             changed = find_pre_post_state_expr(fcx, pres, operand) || changed;\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-            changed =\n-                extend_poststate_ann(fcx.ccx, id,\n-                                     expr_poststate(fcx.ccx, operand)) ||\n-                    changed;\n-            ret changed;\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            ret extend_poststate_ann\n+                (fcx.ccx, e.id, expr_poststate(fcx.ccx, operand))\n+                || changed;\n         }\n-        case (expr_fail(?id, _)) {\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+        case (expr_fail(_)) {\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             /* if execution continues after fail, then everything is true!\n                woo! */\n \n-            changed =\n-                set_poststate_ann(fcx.ccx, id, false_postcond(num_local_vars))\n-                    || changed;\n+            changed = set_poststate_ann\n+                (fcx.ccx, e.id, false_postcond(num_local_vars)) || changed;\n             ret changed;\n         }\n-        case (expr_assert(?p, ?id)) {\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+        case (expr_assert(?p)) {\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n-            changed = extend_poststate_ann(fcx.ccx, id, pres) || changed;\n+            changed = extend_poststate_ann(fcx.ccx, e.id, pres) || changed;\n             ret changed;\n         }\n-        case (expr_check(?p, ?id)) {\n-            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+        case (expr_check(?p)) {\n+            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n-            changed = extend_poststate_ann(fcx.ccx, id, pres) || changed;\n+            changed = extend_poststate_ann(fcx.ccx, e.id, pres) || changed;\n             /* predicate p holds after this expression executes */\n \n             let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n-            changed = gen_poststate(fcx, id, c.node) || changed;\n+            changed = gen_poststate(fcx, e.id, c.node) || changed;\n             ret changed;\n         }\n-        case (expr_if_check(?p, ?conseq, ?maybe_alt, ?id)) {\n-            changed = join_then_else(fcx, p, conseq, maybe_alt, id, if_check,\n-                                     pres)\n-                || changed;\n+        case (expr_if_check(?p, ?conseq, ?maybe_alt)) {\n+            changed = join_then_else\n+                (fcx, p, conseq, maybe_alt, e.id, if_check, pres) || changed;\n \n             ret changed;\n         }\n-        case (expr_break(?id)) { ret pure_exp(fcx.ccx, id, pres); }\n-        case (expr_cont(?id)) { ret pure_exp(fcx.ccx, id, pres); }\n-        case (expr_port(?id)) { ret pure_exp(fcx.ccx, id, pres); }\n-        case (expr_self_method(_, ?id)) { ret pure_exp(fcx.ccx, id, pres); }\n-        case (expr_anon_obj(?anon_obj, _, _, ?id)) {\n+        case (expr_break) { ret pure_exp(fcx.ccx, e.id, pres); }\n+        case (expr_cont) { ret pure_exp(fcx.ccx, e.id, pres); }\n+        case (expr_port) { ret pure_exp(fcx.ccx, e.id, pres); }\n+        case (expr_self_method(_)) { ret pure_exp(fcx.ccx, e.id, pres); }\n+        case (expr_anon_obj(?anon_obj, _, _)) {\n             alt (anon_obj.with_obj) {\n-                case (some(?e)) {\n-                    changed = find_pre_post_state_expr(fcx, pres, e);\n+                case (some(?wt)) {\n+                    changed = find_pre_post_state_expr(fcx, pres, wt);\n                     changed =\n-                        extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+                        extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n                     changed =\n-                        extend_poststate_ann(fcx.ccx, id,\n-                                             expr_poststate(fcx.ccx, e)) ||\n+                        extend_poststate_ann(fcx.ccx, e.id,\n+                                             expr_poststate(fcx.ccx, wt)) ||\n                             changed;\n                     ret changed;\n                 }\n-                case (none) { ret pure_exp(fcx.ccx, id, pres); }\n+                case (none) { ret pure_exp(fcx.ccx, e.id, pres); }\n             }\n         }\n     }\n@@ -816,14 +770,14 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n                 }\n             }\n         }\n-        case (stmt_expr(?e, _)) {\n-            changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+        case (stmt_expr(?ex, _)) {\n+            changed = find_pre_post_state_expr(fcx, pres, ex) || changed;\n             changed =\n                 extend_prestate(stmt_ann.states.prestate,\n-                                expr_prestate(fcx.ccx, e)) || changed;\n+                                expr_prestate(fcx.ccx, ex)) || changed;\n             changed =\n                 extend_poststate(stmt_ann.states.poststate,\n-                                 expr_poststate(fcx.ccx, e)) || changed;\n+                                 expr_poststate(fcx.ccx, ex)) || changed;\n             /*\n               log(\"Summary: stmt = \");\n               log_stmt(*s);\n@@ -896,7 +850,6 @@ fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n \n     alt (f.body.node.expr) {\n         case (some(?tailexpr)) {\n-            auto tailann = expr_node_id(tailexpr);\n             auto tailty = expr_ty(fcx.ccx.tcx, tailexpr);\n \n             // Since blocks and alts and ifs that don't have results\n@@ -906,12 +859,12 @@ fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n             if (!type_is_nil(fcx.ccx.tcx, tailty) &&\n                     !type_is_bot(fcx.ccx.tcx, tailty)) {\n                 auto p = false_postcond(num_local_vars);\n-                set_poststate_ann(fcx.ccx, tailann, p);\n+                set_poststate_ann(fcx.ccx, tailexpr.id, p);\n                 // be sure to set the block poststate to the same thing\n                 set_poststate_ann(fcx.ccx, f.body.node.id, p);\n                 alt (fcx.enclosing.cf) {\n                     case (noreturn) {\n-                        kill_poststate(fcx, tailann,\n+                        kill_poststate(fcx, tailexpr.id,\n                                        rec(id=fcx.id, c=ninit(fcx.name)));\n                     }\n                     case (_) { }"}, {"sha": "37435824fa31ffb5b727978762ac5965cf059d88", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 56, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -42,7 +42,6 @@ export ctxt;\n export decl_local_ty;\n export def_has_ty_params;\n export eq_ty;\n-export expr_node_id;\n export expr_has_ty_params;\n export expr_ty;\n export fold_ty;\n@@ -1730,53 +1729,6 @@ fn pat_ty(&ctxt cx, &@ast::pat pat) -> t {\n     ret node_id_to_monotype(cx, pat_node_id(pat));\n }\n \n-fn expr_node_id(&@ast::expr e) -> ast::node_id {\n-    ret alt (e.node) {\n-        case (ast::expr_vec(_, _, _, ?id)) { id }\n-        case (ast::expr_tup(_, ?id)) { id }\n-        case (ast::expr_rec(_, _, ?id)) { id }\n-        case (ast::expr_call(_, _, ?id)) { id }\n-        case (ast::expr_bind(_, _, ?id)) { id }\n-        case (ast::expr_binary(_, _, _, ?id)) { id }\n-        case (ast::expr_unary(_, _, ?id)) { id }\n-        case (ast::expr_lit(_, ?id)) { id }\n-        case (ast::expr_cast(_, _, ?id)) { id }\n-        case (ast::expr_if(_, _, _, ?id)) { id }\n-        case (ast::expr_if_check(_, _, _, ?id)) { id }\n-        case (ast::expr_while(_, _, ?id)) { id }\n-        case (ast::expr_for(_, _, _, ?id)) { id }\n-        case (ast::expr_for_each(_, _, _, ?id)) { id }\n-        case (ast::expr_do_while(_, _, ?id)) { id }\n-        case (ast::expr_alt(_, _, ?id)) { id }\n-        case (ast::expr_fn(_, ?id)) { id }\n-        case (ast::expr_block(_, ?id)) { id }\n-        case (ast::expr_move(_, _, ?id)) { id }\n-        case (ast::expr_assign(_, _, ?id)) { id }\n-        case (ast::expr_swap(_, _, ?id)) { id }\n-        case (ast::expr_assign_op(_, _, _, ?id)) { id }\n-        case (ast::expr_send(_, _, ?id)) { id }\n-        case (ast::expr_recv(_, _, ?id)) { id }\n-        case (ast::expr_field(_, _, ?id)) { id }\n-        case (ast::expr_index(_, _, ?id)) { id }\n-        case (ast::expr_path(_, ?id)) { id }\n-        case (ast::expr_ext(_, _, _, _, ?id)) { id }\n-        case (ast::expr_fail(?id, _)) { id }\n-        case (ast::expr_ret(_, ?id)) { id }\n-        case (ast::expr_put(_, ?id)) { id }\n-        case (ast::expr_be(_, ?id)) { id }\n-        case (ast::expr_log(_, _, ?id)) { id }\n-        case (ast::expr_assert(_, ?id)) { id }\n-        case (ast::expr_check(_, ?id)) { id }\n-        case (ast::expr_port(?id)) { id }\n-        case (ast::expr_chan(_, ?id)) { id }\n-        case (ast::expr_anon_obj(_, _, _, ?id)) { id }\n-        case (ast::expr_break(?id)) { id }\n-        case (ast::expr_cont(?id)) { id }\n-        case (ast::expr_self_method(_, ?id)) { id }\n-        case (ast::expr_spawn(_, _, _, _, ?id)) { id }\n-    }\n-}\n-\n \n // Returns the type of an expression as a monotype.\n //\n@@ -1785,16 +1737,16 @@ fn expr_node_id(&@ast::expr e) -> ast::node_id {\n // instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n fn expr_ty(&ctxt cx, &@ast::expr expr) -> t {\n-    ret node_id_to_monotype(cx, expr_node_id(expr));\n+    ret node_id_to_monotype(cx, expr.id);\n }\n \n fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr) -> tup(vec[t], t) {\n-    auto a = expr_node_id(expr);\n-    ret tup(node_id_to_type_params(cx, a), node_id_to_type(cx, a));\n+    ret tup(node_id_to_type_params(cx, expr.id),\n+            node_id_to_type(cx, expr.id));\n }\n \n fn expr_has_ty_params(&ctxt cx, &@ast::expr expr) -> bool {\n-    ret node_id_has_type_params(cx, expr_node_id(expr));\n+    ret node_id_has_type_params(cx, expr.id);\n }\n \n fn decl_local_ty(&ctxt cx, &@ast::local l) -> t {\n@@ -1873,10 +1825,10 @@ fn sort_methods(&vec[method] meths) -> vec[method] {\n \n fn is_lval(&@ast::expr expr) -> bool {\n     alt (expr.node) {\n-        case (ast::expr_field(_, _, _)) { ret true; }\n-        case (ast::expr_index(_, _, _)) { ret true; }\n-        case (ast::expr_path(_, _)) { ret true; }\n-        case (ast::expr_unary(ast::deref, _, _)) { ret true; }\n+        case (ast::expr_field(_, _)) { ret true; }\n+        case (ast::expr_index(_, _)) { ret true; }\n+        case (ast::expr_path(_)) { ret true; }\n+        case (ast::expr_unary(ast::deref, _)) { ret true; }\n         case (_) { ret false; }\n     }\n }"}, {"sha": "a77b3d4135dc90777db2e7825ce12a9acba9d5c2", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -976,7 +976,7 @@ mod writeback {\n         resolve_type_vars_for_node(fcx, s.span, ty::stmt_node_id(s));\n     }\n     fn visit_expr_pre(@fn_ctxt fcx, &@ast::expr e) {\n-        resolve_type_vars_for_node(fcx, e.span, ty::expr_node_id(e));\n+        resolve_type_vars_for_node(fcx, e.span, e.id);\n     }\n     fn visit_block_pre(@fn_ctxt fcx, &ast::block b) {\n         resolve_type_vars_for_node(fcx, b.span, b.node.id);\n@@ -1139,7 +1139,7 @@ fn replace_expr_type(&@fn_ctxt fcx, &@ast::expr expr,\n     if (ty::expr_has_ty_params(fcx.ccx.tcx, expr)) {\n         new_tps = some[vec[ty::t]](new_tyt._0);\n     } else { new_tps = none[vec[ty::t]]; }\n-    write::ty_fixup(fcx, ty::expr_node_id(expr), tup(new_tps, new_tyt._1));\n+    write::ty_fixup(fcx, expr.id, tup(new_tps, new_tyt._1));\n }\n \n \n@@ -1282,9 +1282,9 @@ fn require_pure_call(@crate_ctxt ccx, &ast::purity caller_purity,\n         case (ast::impure_fn) { ret; }\n         case (ast::pure_fn) {\n             alt (callee.node) {\n-                case (ast::expr_path(_, ?id)) {\n+                case (ast::expr_path(_)) {\n                     auto d_id;\n-                    alt (ccx.tcx.def_map.get(id)) {\n+                    alt (ccx.tcx.def_map.get(callee.id)) {\n                         case (ast::def_fn(?_d_id)) { d_id = _d_id; }\n                     }\n                     alt (get_function_purity(ccx, d_id)) {\n@@ -1425,11 +1425,11 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         /* e must be a call expr where all arguments are either\n            literals or slots */\n             alt (e.node) {\n-                case (ast::expr_call(?operator, ?operands, _)) {\n+                case (ast::expr_call(?operator, ?operands)) {\n                     alt (operator.node) {\n-                        case (ast::expr_path(?oper_name, ?id)) {\n+                        case (ast::expr_path(?oper_name)) {\n                             auto d_id;\n-                            alt (fcx.ccx.tcx.def_map.get(id)) {\n+                            alt (fcx.ccx.tcx.def_map.get(operator.id)) {\n                                 case (ast::def_fn(?_d_id)) { d_id = _d_id; }\n                             }\n                             for (@ast::expr operand in operands) {\n@@ -1440,7 +1440,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                 }\n                             }\n                             require_pure_function(fcx.ccx, d_id, e.span);\n-                         }\n+                        }\n                         case (_) {\n                             auto s = \"In a constraint, expected the \\\n                                       constraint name to be an explicit name\";\n@@ -1477,12 +1477,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         write::ty_only_fixup(fcx, id, if_t);\n     }\n \n+    auto id = expr.id;\n     alt (expr.node) {\n-        case (ast::expr_lit(?lit, ?id)) {\n+        case (ast::expr_lit(?lit)) {\n             auto typ = check_lit(fcx.ccx, lit);\n             write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_binary(?binop, ?lhs, ?rhs, ?id)) {\n+        case (ast::expr_binary(?binop, ?lhs, ?rhs)) {\n             check_expr(fcx, lhs);\n             check_expr(fcx, rhs);\n \n@@ -1505,7 +1506,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             write::ty_only_fixup(fcx, id, t);\n         }\n-        case (ast::expr_unary(?unop, ?oper, ?id)) {\n+        case (ast::expr_unary(?unop, ?oper)) {\n             check_expr(fcx, oper);\n             auto oper_t = expr_ty(fcx.ccx.tcx, oper);\n             alt (unop) {\n@@ -1538,13 +1539,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             write::ty_only_fixup(fcx, id, oper_t);\n         }\n-        case (ast::expr_path(?pth, ?old_id)) {\n+        case (ast::expr_path(?pth)) {\n             auto t = ty::mk_nil(fcx.ccx.tcx);\n-            auto defn = fcx.ccx.tcx.def_map.get(old_id);\n+            auto defn = fcx.ccx.tcx.def_map.get(id);\n             auto tpt = ty_param_count_and_ty_for_def(fcx, expr.span, defn);\n             if (ty::def_has_ty_params(defn)) {\n                 auto path_tpot = instantiate_path(fcx, pth, tpt, expr.span);\n-                write::ty_fixup(fcx, old_id, path_tpot);\n+                write::ty_fixup(fcx, id, path_tpot);\n                 ret;\n             }\n             // The definition doesn't take type parameters. If the programmer\n@@ -1555,17 +1556,17 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                           \"this kind of value does not \\\n                                            take type parameters\");\n             }\n-            write::ty_only_fixup(fcx, old_id, tpt._1);\n+            write::ty_only_fixup(fcx, id, tpt._1);\n         }\n-        case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?id)) {\n+        case (ast::expr_ext(?p, ?args, ?body, ?expanded)) {\n             check_expr(fcx, expanded);\n             auto t = expr_ty(fcx.ccx.tcx, expanded);\n             write::ty_only_fixup(fcx, id, t);\n         }\n-        case (ast::expr_fail(?id, _)) { write::bot_ty(fcx.ccx.tcx, id); }\n-        case (ast::expr_break(?id)) { write::bot_ty(fcx.ccx.tcx, id); }\n-        case (ast::expr_cont(?id)) { write::bot_ty(fcx.ccx.tcx, id); }\n-        case (ast::expr_ret(?expr_opt, ?id)) {\n+        case (ast::expr_fail(_)) { write::bot_ty(fcx.ccx.tcx, id); }\n+        case (ast::expr_break) { write::bot_ty(fcx.ccx.tcx, id); }\n+        case (ast::expr_cont) { write::bot_ty(fcx.ccx.tcx, id); }\n+        case (ast::expr_ret(?expr_opt)) {\n             alt (expr_opt) {\n                 case (none) {\n                     auto nil = ty::mk_nil(fcx.ccx.tcx);\n@@ -1584,7 +1585,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_put(?expr_opt, ?id)) {\n+        case (ast::expr_put(?expr_opt)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n             alt (expr_opt) {\n                 case (none) {\n@@ -1602,49 +1603,49 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_be(?e, ?id)) {\n+        case (ast::expr_be(?e)) {\n             // FIXME: prove instead of assert\n \n             assert (ast::is_call_expr(e));\n             check_expr(fcx, e);\n             demand::simple(fcx, e.span, fcx.ret_ty, expr_ty(fcx.ccx.tcx, e));\n             write::nil_ty(fcx.ccx.tcx, id);\n         }\n-        case (ast::expr_log(?l, ?e, ?id)) {\n+        case (ast::expr_log(?l, ?e)) {\n             auto expr_t = check_expr(fcx, e);\n             write::nil_ty(fcx.ccx.tcx, id);\n         }\n-        case (ast::expr_check(?e, ?id)) {\n+        case (ast::expr_check(?e)) {\n             check_pred_expr(fcx, e);\n             write::nil_ty(fcx.ccx.tcx, id);\n         }\n-        case (ast::expr_if_check(?cond, ?thn, ?elsopt, ?id)) {\n+        case (ast::expr_if_check(?cond, ?thn, ?elsopt)) {\n             check_pred_expr(fcx, cond);\n             check_then_else(fcx, thn, elsopt, id, expr.span);\n         }\n-        case (ast::expr_assert(?e, ?id)) {\n+        case (ast::expr_assert(?e)) {\n             check_expr(fcx, e);\n             auto ety = expr_ty(fcx.ccx.tcx, e);\n             demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx), ety);\n             write::nil_ty(fcx.ccx.tcx, id);\n         }\n-        case (ast::expr_move(?lhs, ?rhs, ?id)) {\n+        case (ast::expr_move(?lhs, ?rhs)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n             check_assignment(fcx, expr.span, lhs, rhs, id);\n         }\n-        case (ast::expr_assign(?lhs, ?rhs, ?id)) {\n+        case (ast::expr_assign(?lhs, ?rhs)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n             check_assignment(fcx, expr.span, lhs, rhs, id);\n         }\n-        case (ast::expr_swap(?lhs, ?rhs, ?id)) {\n+        case (ast::expr_swap(?lhs, ?rhs)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n             check_assignment(fcx, expr.span, lhs, rhs, id);\n         }\n-        case (ast::expr_assign_op(?op, ?lhs, ?rhs, ?id)) {\n+        case (ast::expr_assign_op(?op, ?lhs, ?rhs)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n             check_assignment(fcx, expr.span, lhs, rhs, id);\n         }\n-        case (ast::expr_send(?lhs, ?rhs, ?id)) {\n+        case (ast::expr_send(?lhs, ?rhs)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n             check_expr(fcx, lhs);\n             check_expr(fcx, rhs);\n@@ -1664,7 +1665,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             write::ty_only_fixup(fcx, id, chan_t);\n         }\n-        case (ast::expr_recv(?lhs, ?rhs, ?id)) {\n+        case (ast::expr_recv(?lhs, ?rhs)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n             check_expr(fcx, lhs);\n             check_expr(fcx, rhs);\n@@ -1673,14 +1674,14 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             demand::simple(fcx, expr.span, port_t, expr_ty(fcx.ccx.tcx, lhs));\n             write::ty_only_fixup(fcx, id, item_t);\n         }\n-        case (ast::expr_if(?cond, ?thn, ?elsopt, ?id)) {\n+        case (ast::expr_if(?cond, ?thn, ?elsopt)) {\n             check_expr(fcx, cond);\n             demand::simple(fcx, cond.span,\n                            ty::mk_bool(fcx.ccx.tcx),\n                            expr_ty(fcx.ccx.tcx, cond));\n             check_then_else(fcx, thn, elsopt, id, expr.span);\n         }\n-        case (ast::expr_for(?decl, ?seq, ?body, ?id)) {\n+        case (ast::expr_for(?decl, ?seq, ?body)) {\n             check_expr(fcx, seq);\n             auto elt_ty;\n             auto ety = expr_ty(fcx.ccx.tcx, seq);\n@@ -1701,26 +1702,26 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             check_for_or_for_each(fcx, decl, elt_ty, body, id);\n         }\n-        case (ast::expr_for_each(?decl, ?seq, ?body, ?id)) {\n+        case (ast::expr_for_each(?decl, ?seq, ?body)) {\n             check_expr(fcx, seq);\n             check_for_or_for_each(fcx, decl, expr_ty(fcx.ccx.tcx, seq), body,\n                                   id);\n         }\n-        case (ast::expr_while(?cond, ?body, ?id)) {\n+        case (ast::expr_while(?cond, ?body)) {\n             check_expr(fcx, cond);\n             check_block(fcx, body);\n             demand::simple(fcx, cond.span, ty::mk_bool(fcx.ccx.tcx),\n                            expr_ty(fcx.ccx.tcx, cond));\n             auto typ = ty::mk_nil(fcx.ccx.tcx);\n             write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_do_while(?body, ?cond, ?id)) {\n+        case (ast::expr_do_while(?body, ?cond)) {\n             check_expr(fcx, cond);\n             check_block(fcx, body);\n             auto typ = block_ty(fcx.ccx.tcx, body);\n             write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_alt(?expr, ?arms, ?id)) {\n+        case (ast::expr_alt(?expr, ?arms)) {\n             check_expr(fcx, expr);\n             // Typecheck the patterns first, so that we get types for all the\n             // bindings.\n@@ -1747,7 +1748,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             write::ty_only_fixup(fcx, id, result_ty);\n         }\n-        case (ast::expr_fn(?f, ?id)) {\n+        case (ast::expr_fn(?f)) {\n             auto cx = @rec(tcx=fcx.ccx.tcx);\n             auto convert =\n                 bind ast_ty_to_ty(cx.tcx, bind collect::getter(cx, _), _);\n@@ -1758,7 +1759,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             write::ty_only_fixup(fcx, id, fty);\n             check_fn(fcx.ccx, f.decl, f.proto, f.body, id);\n         }\n-        case (ast::expr_block(?b, ?id)) {\n+        case (ast::expr_block(?b)) {\n             check_block(fcx, b);\n             alt (b.node.expr) {\n                 case (some(?expr)) {\n@@ -1771,7 +1772,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_bind(?f, ?args, ?id)) {\n+        case (ast::expr_bind(?f, ?args)) {\n             // Call the generic checker.\n \n             check_call_or_bind(fcx, expr.span, f, args);\n@@ -1812,7 +1813,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             write::ty_only_fixup(fcx, id, t_1);\n         }\n-        case (ast::expr_call(?f, ?args, ?id)) {\n+        case (ast::expr_call(?f, ?args)) {\n             /* here we're kind of hosed, as f can be any expr\n              need to restrict it to being an explicit expr_path if we're\n             inside a pure function, and need an environment mapping from\n@@ -1834,7 +1835,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             write::ty_only_fixup(fcx, id, rt_1);\n         }\n-        case (ast::expr_self_method(?ident, ?id)) {\n+        case (ast::expr_self_method(?ident)) {\n             auto t = ty::mk_nil(fcx.ccx.tcx);\n             let ty::t this_obj_ty;\n             let option::t[obj_info] this_obj_info = get_obj_info(fcx.ccx);\n@@ -1867,7 +1868,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             write::ty_only_fixup(fcx, id, t);\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n         }\n-        case (ast::expr_spawn(_, _, ?f, ?args, ?id)) {\n+        case (ast::expr_spawn(_, _, ?f, ?args)) {\n             check_call(fcx, expr.span, f, args);\n             auto fty = expr_ty(fcx.ccx.tcx, f);\n             auto ret_ty = ty::ret_ty_of_fn_ty(fcx.ccx.tcx, fty);\n@@ -1877,7 +1878,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto typ = ty::mk_task(fcx.ccx.tcx);\n             write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_cast(?e, ?t, ?id)) {\n+        case (ast::expr_cast(?e, ?t)) {\n             check_expr(fcx, e);\n             auto t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n             // FIXME: there are more forms of cast to support, eventually.\n@@ -1893,7 +1894,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             write::ty_only_fixup(fcx, id, t_1);\n         }\n-        case (ast::expr_vec(?args, ?mut, ?kind, ?id)) {\n+        case (ast::expr_vec(?args, ?mut, ?kind)) {\n             let ty::t t;\n             if (vec::len[@ast::expr](args) == 0u) {\n                 t = next_ty_var(fcx);\n@@ -1917,7 +1918,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_tup(?elts, ?id)) {\n+        case (ast::expr_tup(?elts)) {\n             let vec[ty::mt] elts_mt = [];\n             for (ast::elt e in elts) {\n                 check_expr(fcx, e.expr);\n@@ -1927,7 +1928,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto typ = ty::mk_tup(fcx.ccx.tcx, elts_mt);\n             write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_rec(?fields, ?base, ?id)) {\n+        case (ast::expr_rec(?fields, ?base)) {\n             alt (base) {\n                 case (none) {/* no-op */ }\n                 case (some(?b_0)) { check_expr(fcx, b_0); }\n@@ -1977,7 +1978,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_field(?base, ?field, ?id)) {\n+        case (ast::expr_field(?base, ?field)) {\n             check_expr(fcx, base);\n             auto base_t = expr_ty(fcx.ccx.tcx, base);\n             base_t = strip_boxes(fcx, expr.span, base_t);\n@@ -2024,7 +2025,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_index(?base, ?idx, ?id)) {\n+        case (ast::expr_index(?base, ?idx)) {\n             check_expr(fcx, base);\n             auto base_t = expr_ty(fcx.ccx.tcx, base);\n             base_t = strip_boxes(fcx, expr.span, base_t);\n@@ -2059,12 +2060,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_port(?id)) {\n+        case (ast::expr_port) {\n             auto t = next_ty_var(fcx);\n             auto pt = ty::mk_port(fcx.ccx.tcx, t);\n             write::ty_only_fixup(fcx, id, pt);\n         }\n-        case (ast::expr_chan(?x, ?id)) {\n+        case (ast::expr_chan(?x)) {\n             check_expr(fcx, x);\n             auto port_t = expr_ty(fcx.ccx.tcx, x);\n             alt (structure_of(fcx, expr.span, port_t)) {\n@@ -2080,7 +2081,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_anon_obj(?anon_obj, ?tps, ?obj_def_ids, ?id)) {\n+        case (ast::expr_anon_obj(?anon_obj, ?tps, ?obj_def_ids)) {\n             // TODO: We probably need to do more work here to be able to\n             // handle additional methods that use 'self'\n "}, {"sha": "bf9c19702798e3a7a206c749b3aa4b260e3c7d26", "filename": "src/comp/middle/visit.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fvisit.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -254,121 +254,121 @@ fn visit_exprs[E](vec[@expr] exprs, &E e, &vt[E] v) {\n \n fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n     alt (ex.node) {\n-        case (expr_vec(?es, _, _, _)) { visit_exprs(es, e, v); }\n-        case (expr_tup(?elts, _)) {\n+        case (expr_vec(?es, _, _)) { visit_exprs(es, e, v); }\n+        case (expr_tup(?elts)) {\n             for (elt el in elts) { vt(v).visit_expr(el.expr, e, v); }\n         }\n-        case (expr_rec(?flds, ?base, _)) {\n+        case (expr_rec(?flds, ?base)) {\n             for (field f in flds) { vt(v).visit_expr(f.node.expr, e, v); }\n             visit_expr_opt(base, e, v);\n         }\n-        case (expr_call(?callee, ?args, _)) {\n+        case (expr_call(?callee, ?args)) {\n             vt(v).visit_expr(callee, e, v);\n             visit_exprs(args, e, v);\n         }\n-        case (expr_self_method(_, _)) { }\n-        case (expr_bind(?callee, ?args, _)) {\n+        case (expr_self_method(_)) { }\n+        case (expr_bind(?callee, ?args)) {\n             vt(v).visit_expr(callee, e, v);\n             for (option::t[@expr] eo in args) { visit_expr_opt(eo, e, v); }\n         }\n-        case (expr_spawn(_, _, ?callee, ?args, _)) {\n+        case (expr_spawn(_, _, ?callee, ?args)) {\n             vt(v).visit_expr(callee, e, v);\n             visit_exprs(args, e, v);\n         }\n-        case (expr_binary(_, ?a, ?b, _)) {\n+        case (expr_binary(_, ?a, ?b)) {\n             vt(v).visit_expr(a, e, v);\n             vt(v).visit_expr(b, e, v);\n         }\n-        case (expr_unary(_, ?a, _)) { vt(v).visit_expr(a, e, v); }\n-        case (expr_lit(_, _)) { }\n-        case (expr_cast(?x, ?t, _)) {\n+        case (expr_unary(_, ?a)) { vt(v).visit_expr(a, e, v); }\n+        case (expr_lit(_)) { }\n+        case (expr_cast(?x, ?t)) {\n             vt(v).visit_expr(x, e, v);\n             vt(v).visit_ty(t, e, v);\n         }\n-        case (expr_if(?x, ?b, ?eo, _)) {\n+        case (expr_if(?x, ?b, ?eo)) {\n             vt(v).visit_expr(x, e, v);\n             vt(v).visit_block(b, e, v);\n             visit_expr_opt(eo, e, v);\n         }\n-        case (expr_if_check(?x, ?b, ?eo, _)) {\n+        case (expr_if_check(?x, ?b, ?eo)) {\n             vt(v).visit_expr(x, e, v);\n             vt(v).visit_block(b, e, v);\n             visit_expr_opt(eo, e, v);\n         }\n-        case (expr_while(?x, ?b, _)) {\n+        case (expr_while(?x, ?b)) {\n             vt(v).visit_expr(x, e, v);\n             vt(v).visit_block(b, e, v);\n         }\n-        case (expr_for(?dcl, ?x, ?b, _)) {\n+        case (expr_for(?dcl, ?x, ?b)) {\n             vt(v).visit_local(dcl, e, v);\n             vt(v).visit_expr(x, e, v);\n             vt(v).visit_block(b, e, v);\n         }\n-        case (expr_for_each(?dcl, ?x, ?b, _)) {\n+        case (expr_for_each(?dcl, ?x, ?b)) {\n             vt(v).visit_local(dcl, e, v);\n             vt(v).visit_expr(x, e, v);\n             vt(v).visit_block(b, e, v);\n         }\n-        case (expr_do_while(?b, ?x, _)) {\n+        case (expr_do_while(?b, ?x)) {\n             vt(v).visit_block(b, e, v);\n             vt(v).visit_expr(x, e, v);\n         }\n-        case (expr_alt(?x, ?arms, _)) {\n+        case (expr_alt(?x, ?arms)) {\n             vt(v).visit_expr(x, e, v);\n             for (arm a in arms) { vt(v).visit_arm(a, e, v); }\n         }\n-        case (expr_fn(?f, _)) {\n+        case (expr_fn(?f)) {\n             visit_fn_decl(f.decl, e, v);\n             vt(v).visit_block(f.body, e, v);\n         }\n-        case (expr_block(?b, _)) { vt(v).visit_block(b, e, v); }\n-        case (expr_assign(?a, ?b, _)) {\n+        case (expr_block(?b)) { vt(v).visit_block(b, e, v); }\n+        case (expr_assign(?a, ?b)) {\n             vt(v).visit_expr(b, e, v);\n             vt(v).visit_expr(a, e, v);\n         }\n-        case (expr_move(?a, ?b, _)) {\n+        case (expr_move(?a, ?b)) {\n             vt(v).visit_expr(b, e, v);\n             vt(v).visit_expr(a, e, v);\n         }\n-        case (expr_swap(?a, ?b, _)) {\n+        case (expr_swap(?a, ?b)) {\n             vt(v).visit_expr(a, e, v);\n             vt(v).visit_expr(b, e, v);\n         }\n-        case (expr_assign_op(_, ?a, ?b, _)) {\n+        case (expr_assign_op(_, ?a, ?b)) {\n             vt(v).visit_expr(b, e, v);\n             vt(v).visit_expr(a, e, v);\n         }\n-        case (expr_send(?a, ?b, _)) {\n+        case (expr_send(?a, ?b)) {\n             vt(v).visit_expr(a, e, v);\n             vt(v).visit_expr(b, e, v);\n         }\n-        case (expr_recv(?a, ?b, _)) {\n+        case (expr_recv(?a, ?b)) {\n             vt(v).visit_expr(a, e, v);\n             vt(v).visit_expr(b, e, v);\n         }\n-        case (expr_field(?x, _, _)) { vt(v).visit_expr(x, e, v); }\n-        case (expr_index(?a, ?b, _)) {\n+        case (expr_field(?x, _)) { vt(v).visit_expr(x, e, v); }\n+        case (expr_index(?a, ?b)) {\n             vt(v).visit_expr(a, e, v);\n             vt(v).visit_expr(b, e, v);\n         }\n-        case (expr_path(?p, _)) {\n+        case (expr_path(?p)) {\n             for (@ty tp in p.node.types) { vt(v).visit_ty(tp, e, v); }\n         }\n-        case (expr_ext(_, _, _, ?expansion, _)) {\n+        case (expr_ext(_, _, _, ?expansion)) {\n             vt(v).visit_expr(expansion, e, v);\n         }\n-        case (expr_fail(_, _)) { }\n-        case (expr_break(_)) { }\n-        case (expr_cont(_)) { }\n-        case (expr_ret(?eo, _)) { visit_expr_opt(eo, e, v); }\n-        case (expr_put(?eo, _)) { visit_expr_opt(eo, e, v); }\n-        case (expr_be(?x, _)) { vt(v).visit_expr(x, e, v); }\n-        case (expr_log(_, ?x, _)) { vt(v).visit_expr(x, e, v); }\n-        case (expr_check(?x, _)) { vt(v).visit_expr(x, e, v); }\n-        case (expr_assert(?x, _)) { vt(v).visit_expr(x, e, v); }\n-        case (expr_port(_)) { }\n-        case (expr_chan(?x, _)) { vt(v).visit_expr(x, e, v); }\n-        case (expr_anon_obj(?anon_obj, _, _, _)) {\n+        case (expr_fail(_)) { }\n+        case (expr_break) { }\n+        case (expr_cont) { }\n+        case (expr_ret(?eo)) { visit_expr_opt(eo, e, v); }\n+        case (expr_put(?eo)) { visit_expr_opt(eo, e, v); }\n+        case (expr_be(?x)) { vt(v).visit_expr(x, e, v); }\n+        case (expr_log(_, ?x)) { vt(v).visit_expr(x, e, v); }\n+        case (expr_check(?x)) { vt(v).visit_expr(x, e, v); }\n+        case (expr_assert(?x)) { vt(v).visit_expr(x, e, v); }\n+        case (expr_port) { }\n+        case (expr_chan(?x)) { vt(v).visit_expr(x, e, v); }\n+        case (expr_anon_obj(?anon_obj, _, _)) {\n             alt (anon_obj.fields) {\n                 case (none) { }\n                 case (some(?fields)) {"}, {"sha": "aad3e9dd58f352dfc00cd6bc8d30c63b073a2f53", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -269,64 +269,64 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n     if (!v.keep_going()) { ret; }\n     v.visit_expr_pre(e);\n     alt (e.node) {\n-        case (ast::expr_vec(?es, _, _, _)) { walk_exprs(v, es); }\n-        case (ast::expr_tup(?elts, _)) {\n+        case (ast::expr_vec(?es, _, _)) { walk_exprs(v, es); }\n+        case (ast::expr_tup(?elts)) {\n             for (ast::elt e in elts) { walk_expr(v, e.expr); }\n         }\n-        case (ast::expr_rec(?flds, ?base, _)) {\n+        case (ast::expr_rec(?flds, ?base)) {\n             for (ast::field f in flds) { walk_expr(v, f.node.expr); }\n             walk_expr_opt(v, base);\n         }\n-        case (ast::expr_call(?callee, ?args, _)) {\n+        case (ast::expr_call(?callee, ?args)) {\n             walk_expr(v, callee);\n             walk_exprs(v, args);\n         }\n-        case (ast::expr_self_method(_, _)) { }\n-        case (ast::expr_bind(?callee, ?args, _)) {\n+        case (ast::expr_self_method(_)) { }\n+        case (ast::expr_bind(?callee, ?args)) {\n             walk_expr(v, callee);\n             for (option::t[@ast::expr] eo in args) { walk_expr_opt(v, eo); }\n         }\n-        case (ast::expr_spawn(_, _, ?callee, ?args, _)) {\n+        case (ast::expr_spawn(_, _, ?callee, ?args)) {\n             walk_expr(v, callee);\n             walk_exprs(v, args);\n         }\n-        case (ast::expr_binary(_, ?a, ?b, _)) {\n+        case (ast::expr_binary(_, ?a, ?b)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast::expr_unary(_, ?a, _)) { walk_expr(v, a); }\n-        case (ast::expr_lit(_, _)) { }\n-        case (ast::expr_cast(?x, ?t, _)) { walk_expr(v, x); walk_ty(v, t); }\n-        case (ast::expr_if(?x, ?b, ?eo, _)) {\n+        case (ast::expr_unary(_, ?a)) { walk_expr(v, a); }\n+        case (ast::expr_lit(_)) { }\n+        case (ast::expr_cast(?x, ?t)) { walk_expr(v, x); walk_ty(v, t); }\n+        case (ast::expr_if(?x, ?b, ?eo)) {\n             walk_expr(v, x);\n             walk_block(v, b);\n             walk_expr_opt(v, eo);\n         }\n-        case (ast::expr_if_check(?x, ?b, ?eo, _)) {\n+        case (ast::expr_if_check(?x, ?b, ?eo)) {\n             walk_expr(v, x);\n             walk_block(v, b);\n             walk_expr_opt(v, eo);\n         }\n         \n-        case (ast::expr_while(?x, ?b, _)) {\n+        case (ast::expr_while(?x, ?b)) {\n             walk_expr(v, x);\n             walk_block(v, b);\n         }\n-        case (ast::expr_for(?dcl, ?x, ?b, _)) {\n+        case (ast::expr_for(?dcl, ?x, ?b)) {\n             walk_local(v, dcl);\n             walk_expr(v, x);\n             walk_block(v, b);\n         }\n-        case (ast::expr_for_each(?dcl, ?x, ?b, _)) {\n+        case (ast::expr_for_each(?dcl, ?x, ?b)) {\n             walk_local(v, dcl);\n             walk_expr(v, x);\n             walk_block(v, b);\n         }\n-        case (ast::expr_do_while(?b, ?x, _)) {\n+        case (ast::expr_do_while(?b, ?x)) {\n             walk_block(v, b);\n             walk_expr(v, x);\n         }\n-        case (ast::expr_alt(?x, ?arms, _)) {\n+        case (ast::expr_alt(?x, ?arms)) {\n             walk_expr(v, x);\n             for (ast::arm a in arms) {\n                 walk_pat(v, a.pat);\n@@ -335,48 +335,48 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n                 v.visit_arm_post(a);\n             }\n         }\n-        case (ast::expr_fn(?f, ?a)) {\n+        case (ast::expr_fn(?f)) {\n             walk_fn_decl(v, f.decl);\n             walk_block(v, f.body);\n         }\n-        case (ast::expr_block(?b, _)) { walk_block(v, b); }\n-        case (ast::expr_assign(?a, ?b, _)) {\n+        case (ast::expr_block(?b)) { walk_block(v, b); }\n+        case (ast::expr_assign(?a, ?b)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast::expr_move(?a, ?b, _)) { walk_expr(v, a); walk_expr(v, b); }\n-        case (ast::expr_swap(?a, ?b, _)) { walk_expr(v, a); walk_expr(v, b); }\n-        case (ast::expr_assign_op(_, ?a, ?b, _)) {\n+        case (ast::expr_move(?a, ?b)) { walk_expr(v, a); walk_expr(v, b); }\n+        case (ast::expr_swap(?a, ?b)) { walk_expr(v, a); walk_expr(v, b); }\n+        case (ast::expr_assign_op(_, ?a, ?b)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast::expr_send(?a, ?b, _)) { walk_expr(v, a); walk_expr(v, b); }\n-        case (ast::expr_recv(?a, ?b, _)) { walk_expr(v, a); walk_expr(v, b); }\n-        case (ast::expr_field(?x, _, _)) { walk_expr(v, x); }\n-        case (ast::expr_index(?a, ?b, _)) {\n+        case (ast::expr_send(?a, ?b)) { walk_expr(v, a); walk_expr(v, b); }\n+        case (ast::expr_recv(?a, ?b)) { walk_expr(v, a); walk_expr(v, b); }\n+        case (ast::expr_field(?x, _)) { walk_expr(v, x); }\n+        case (ast::expr_index(?a, ?b)) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast::expr_path(?p, _)) {\n+        case (ast::expr_path(?p)) {\n             for (@ast::ty tp in p.node.types) { walk_ty(v, tp); }\n         }\n-        case (ast::expr_ext(_, ?args, ?body, ?expansion, _)) {\n+        case (ast::expr_ext(_, ?args, ?body, ?expansion)) {\n             // Only walk expansion, not args/body.\n \n             walk_expr(v, expansion);\n         }\n-        case (ast::expr_fail(_, _)) { }\n-        case (ast::expr_break(_)) { }\n-        case (ast::expr_cont(_)) { }\n-        case (ast::expr_ret(?eo, _)) { walk_expr_opt(v, eo); }\n-        case (ast::expr_put(?eo, _)) { walk_expr_opt(v, eo); }\n-        case (ast::expr_be(?x, _)) { walk_expr(v, x); }\n-        case (ast::expr_log(_, ?x, _)) { walk_expr(v, x); }\n-        case (ast::expr_check(?x, _)) { walk_expr(v, x); }\n-        case (ast::expr_assert(?x, _)) { walk_expr(v, x); }\n-        case (ast::expr_port(_)) { }\n-        case (ast::expr_chan(?x, _)) { walk_expr(v, x); }\n-        case (ast::expr_anon_obj(?anon_obj, _, _, _)) {\n+        case (ast::expr_fail(_)) { }\n+        case (ast::expr_break) { }\n+        case (ast::expr_cont) { }\n+        case (ast::expr_ret(?eo)) { walk_expr_opt(v, eo); }\n+        case (ast::expr_put(?eo)) { walk_expr_opt(v, eo); }\n+        case (ast::expr_be(?x)) { walk_expr(v, x); }\n+        case (ast::expr_log(_, ?x)) { walk_expr(v, x); }\n+        case (ast::expr_check(?x)) { walk_expr(v, x); }\n+        case (ast::expr_assert(?x)) { walk_expr(v, x); }\n+        case (ast::expr_port) { }\n+        case (ast::expr_chan(?x)) { walk_expr(v, x); }\n+        case (ast::expr_anon_obj(?anon_obj, _, _)) {\n             // Fields\n \n             let option::t[vec[ast::obj_field]] fields ="}, {"sha": "071a1ae27f99f289a54fef0f583ed8863f9d8363", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 49, "deletions": 51, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -519,9 +519,8 @@ fn print_if(&ps s, &@ast::expr test, &ast::block block,\n         alt (els) {\n             case (some(?_else)) {\n                 alt (_else.node) {\n-                    case (\n-                          // \"another else-if\"\n-                          ast::expr_if(?i, ?t, ?e, _)) {\n+                    // \"another else-if\"\n+                    case (ast::expr_if(?i, ?t, ?e)) {\n                         cbox(s, indent_unit - 1u);\n                         ibox(s, 0u);\n                         word(s.s, \" else if \");\n@@ -532,9 +531,8 @@ fn print_if(&ps s, &@ast::expr test, &ast::block block,\n                         print_block(s, t);\n                         do_else(s, e);\n                     }\n-                    case (\n-                          // \"final else\"\n-                          ast::expr_block(?b, _)) {\n+                    // \"final else\"\n+                    case (ast::expr_block(?b)) {\n                         cbox(s, indent_unit - 1u);\n                         ibox(s, 0u);\n                         word(s.s, \" else \");\n@@ -557,7 +555,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n         case (mo_identified) { popen(s); }\n     }\n     alt (expr.node) {\n-        case (ast::expr_vec(?exprs, ?mut, ?kind, _)) {\n+        case (ast::expr_vec(?exprs, ?mut, ?kind)) {\n             ibox(s, indent_unit);\n             alt (kind) {\n                 case (ast::sk_rc) { word(s.s, \"[\"); }\n@@ -568,7 +566,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             word(s.s, \"]\");\n             end(s);\n         }\n-        case (ast::expr_tup(?exprs, _)) {\n+        case (ast::expr_tup(?exprs)) {\n             fn printElt(&ps s, &ast::elt elt) {\n                 ibox(s, indent_unit);\n                 if (elt.mut == ast::mut) { word_nbsp(s, \"mutable\"); }\n@@ -581,7 +579,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             commasep_cmnt(s, inconsistent, exprs, printElt, get_span);\n             pclose(s);\n         }\n-        case (ast::expr_rec(?fields, ?wth, _)) {\n+        case (ast::expr_rec(?fields, ?wth)) {\n             fn print_field(&ps s, &ast::field field) {\n                 ibox(s, indent_unit);\n                 if (field.node.mut == ast::mut) { word_nbsp(s, \"mutable\"); }\n@@ -606,17 +604,17 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             }\n             pclose(s);\n         }\n-        case (ast::expr_call(?func, ?args, _)) {\n+        case (ast::expr_call(?func, ?args)) {\n             print_expr(s, func);\n             popen(s);\n             commasep_exprs(s, inconsistent, args);\n             pclose(s);\n         }\n-        case (ast::expr_self_method(?ident, _)) {\n+        case (ast::expr_self_method(?ident)) {\n             word(s.s, \"self.\");\n             print_ident(s, ident);\n         }\n-        case (ast::expr_bind(?func, ?args, _)) {\n+        case (ast::expr_bind(?func, ?args)) {\n             fn print_opt(&ps s, &option::t[@ast::expr] expr) {\n                 alt (expr) {\n                     case (some(?expr)) { print_expr(s, expr); }\n@@ -629,46 +627,46 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             commasep(s, inconsistent, args, print_opt);\n             pclose(s);\n         }\n-        case (ast::expr_spawn(_, _, ?e, ?es, _)) {\n+        case (ast::expr_spawn(_, _, ?e, ?es)) {\n             word_nbsp(s, \"spawn\");\n             print_expr(s, e);\n             popen(s);\n             commasep_exprs(s, inconsistent, es);\n             pclose(s);\n         }\n-        case (ast::expr_binary(?op, ?lhs, ?rhs, _)) {\n+        case (ast::expr_binary(?op, ?lhs, ?rhs)) {\n             auto prec = operator_prec(op);\n             print_maybe_parens(s, lhs, prec);\n             space(s.s);\n             word_space(s, ast::binop_to_str(op));\n             print_maybe_parens(s, rhs, prec + 1);\n         }\n-        case (ast::expr_unary(?op, ?expr, _)) {\n+        case (ast::expr_unary(?op, ?expr)) {\n             word(s.s, ast::unop_to_str(op));\n             print_maybe_parens(s, expr, front::parser::unop_prec);\n         }\n-        case (ast::expr_lit(?lit, _)) { print_literal(s, lit); }\n-        case (ast::expr_cast(?expr, ?ty, _)) {\n+        case (ast::expr_lit(?lit)) { print_literal(s, lit); }\n+        case (ast::expr_cast(?expr, ?ty)) {\n             print_maybe_parens(s, expr, front::parser::as_prec);\n             space(s.s);\n             word_space(s, \"as\");\n             print_type(s, *ty);\n         }\n-        case (ast::expr_if(?test, ?block, ?elseopt, _)) {\n+        case (ast::expr_if(?test, ?block, ?elseopt)) {\n             print_if(s, test, block, elseopt, false);\n         }\n-        case (ast::expr_if_check(?test, ?block, ?elseopt, _)) {\n+        case (ast::expr_if_check(?test, ?block, ?elseopt)) {\n             print_if(s, test, block, elseopt, true);\n         }\n-        case (ast::expr_while(?test, ?block, _)) {\n+        case (ast::expr_while(?test, ?block)) {\n             head(s, \"while\");\n             popen(s);\n             print_expr(s, test);\n             pclose(s);\n             space(s.s);\n             print_block(s, block);\n         }\n-        case (ast::expr_for(?decl, ?expr, ?block, _)) {\n+        case (ast::expr_for(?decl, ?expr, ?block)) {\n             head(s, \"for\");\n             popen(s);\n             print_for_decl(s, decl);\n@@ -679,7 +677,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             space(s.s);\n             print_block(s, block);\n         }\n-        case (ast::expr_for_each(?decl, ?expr, ?block, _)) {\n+        case (ast::expr_for_each(?decl, ?expr, ?block)) {\n             head(s, \"for each\");\n             popen(s);\n             print_for_decl(s, decl);\n@@ -690,7 +688,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             space(s.s);\n             print_block(s, block);\n         }\n-        case (ast::expr_do_while(?block, ?expr, _)) {\n+        case (ast::expr_do_while(?block, ?expr)) {\n             head(s, \"do\");\n             space(s.s);\n             print_block(s, block);\n@@ -700,7 +698,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast::expr_alt(?expr, ?arms, _)) {\n+        case (ast::expr_alt(?expr, ?arms)) {\n             head(s, \"alt\");\n             popen(s);\n             print_expr(s, expr);\n@@ -718,13 +716,13 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             }\n             bclose(s, expr.span);\n         }\n-        case (ast::expr_fn(?f, _)) {\n+        case (ast::expr_fn(?f)) {\n             head(s, \"fn\");\n             print_fn_args_and_ret(s, f.decl);\n             space(s.s);\n             print_block(s, f.body);\n         }\n-        case (ast::expr_block(?block, _)) {\n+        case (ast::expr_block(?block)) {\n             // containing cbox, will be closed by print-block at }\n \n             cbox(s, indent_unit);\n@@ -733,103 +731,103 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             ibox(s, 0u);\n             print_block(s, block);\n         }\n-        case (ast::expr_move(?lhs, ?rhs, _)) {\n+        case (ast::expr_move(?lhs, ?rhs)) {\n             print_expr(s, lhs);\n             space(s.s);\n             word_space(s, \"<-\");\n             print_expr(s, rhs);\n         }\n-        case (ast::expr_assign(?lhs, ?rhs, _)) {\n+        case (ast::expr_assign(?lhs, ?rhs)) {\n             print_expr(s, lhs);\n             space(s.s);\n             word_space(s, \"=\");\n             print_expr(s, rhs);\n         }\n-        case (ast::expr_swap(?lhs, ?rhs, _)) {\n+        case (ast::expr_swap(?lhs, ?rhs)) {\n             print_expr(s, lhs);\n             space(s.s);\n             word_space(s, \"<->\");\n             print_expr(s, rhs);\n         }\n-        case (ast::expr_assign_op(?op, ?lhs, ?rhs, _)) {\n+        case (ast::expr_assign_op(?op, ?lhs, ?rhs)) {\n             print_expr(s, lhs);\n             space(s.s);\n             word(s.s, ast::binop_to_str(op));\n             word_space(s, \"=\");\n             print_expr(s, rhs);\n         }\n-        case (ast::expr_send(?lhs, ?rhs, _)) {\n+        case (ast::expr_send(?lhs, ?rhs)) {\n             print_expr(s, lhs);\n             space(s.s);\n             word_space(s, \"<|\");\n             print_expr(s, rhs);\n         }\n-        case (ast::expr_recv(?lhs, ?rhs, _)) {\n+        case (ast::expr_recv(?lhs, ?rhs)) {\n             print_expr(s, lhs);\n             space(s.s);\n             word_space(s, \"|>\");\n             print_expr(s, rhs);\n         }\n-        case (ast::expr_field(?expr, ?id, _)) {\n+        case (ast::expr_field(?expr, ?id)) {\n             print_expr(s, expr);\n             word(s.s, \".\");\n             word(s.s, id);\n         }\n-        case (ast::expr_index(?expr, ?index, _)) {\n+        case (ast::expr_index(?expr, ?index)) {\n             print_expr(s, expr);\n             word(s.s, \".\");\n             popen(s);\n             print_expr(s, index);\n             pclose(s);\n         }\n-        case (ast::expr_path(?path, _)) { print_path(s, path); }\n-        case (ast::expr_fail(_, ?str)) {\n+        case (ast::expr_path(?path)) { print_path(s, path); }\n+        case (ast::expr_fail(?str)) {\n             word(s.s, \"fail\");\n             alt (str) {\n                 case (some(?msg)) { word(s.s, #fmt(\"\\\"%s\\\"\", msg)); }\n                 case (_) { }\n             }\n         }\n-        case (ast::expr_break(_)) { word(s.s, \"break\"); }\n-        case (ast::expr_cont(_)) { word(s.s, \"cont\"); }\n-        case (ast::expr_ret(?result, _)) {\n+        case (ast::expr_break) { word(s.s, \"break\"); }\n+        case (ast::expr_cont) { word(s.s, \"cont\"); }\n+        case (ast::expr_ret(?result)) {\n             word(s.s, \"ret\");\n             alt (result) {\n                 case (some(?expr)) { word(s.s, \" \"); print_expr(s, expr); }\n                 case (_) { }\n             }\n         }\n-        case (ast::expr_put(?result, _)) {\n+        case (ast::expr_put(?result)) {\n             word(s.s, \"put\");\n             alt (result) {\n                 case (some(?expr)) { word(s.s, \" \"); print_expr(s, expr); }\n                 case (_) { }\n             }\n         }\n-        case (ast::expr_be(?result, _)) {\n+        case (ast::expr_be(?result)) {\n             word_nbsp(s, \"be\");\n             print_expr(s, result);\n         }\n-        case (ast::expr_log(?lvl, ?expr, _)) {\n+        case (ast::expr_log(?lvl, ?expr)) {\n             alt (lvl) {\n                 case (1) { word_nbsp(s, \"log\"); }\n                 case (0) { word_nbsp(s, \"log_err\"); }\n             }\n             print_expr(s, expr);\n         }\n-        case (ast::expr_check(?expr, _)) {\n+        case (ast::expr_check(?expr)) {\n             word_nbsp(s, \"check\");\n             popen(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast::expr_assert(?expr, _)) {\n+        case (ast::expr_assert(?expr)) {\n             word_nbsp(s, \"assert\");\n             popen(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast::expr_ext(?path, ?args, ?body, _, _)) {\n+        case (ast::expr_ext(?path, ?args, ?body, _)) {\n             word(s.s, \"#\");\n             print_path(s, path);\n             if (vec::len(args) > 0u) {\n@@ -840,14 +838,14 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             // FIXME: extension 'body'\n \n         }\n-        case (ast::expr_port(_)) { word(s.s, \"port\"); popen(s); pclose(s); }\n-        case (ast::expr_chan(?expr, _)) {\n+        case (ast::expr_port) { word(s.s, \"port\"); popen(s); pclose(s); }\n+        case (ast::expr_chan(?expr)) {\n             word(s.s, \"chan\");\n             popen(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast::expr_anon_obj(_, _, _, _)) {\n+        case (ast::expr_anon_obj(_, _, _)) {\n             word(s.s, \"anon obj\");\n             // FIXME (issue #499): nicer pretty-printing of anon objs\n \n@@ -866,7 +864,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n         }\n         case (mo_identified) {\n             space(s.s);\n-            synth_comment(s, int::to_str(ty::expr_node_id(expr), 10u));\n+            synth_comment(s, int::to_str(expr.id, 10u));\n             pclose(s);\n         }\n     }\n@@ -1085,10 +1083,10 @@ fn operator_prec(ast::binop op) -> int {\n fn print_maybe_parens(&ps s, &@ast::expr expr, int outer_prec) {\n     auto add_them;\n     alt (expr.node) {\n-        case (ast::expr_binary(?op, _, _, _)) {\n+        case (ast::expr_binary(?op, _, _)) {\n             add_them = operator_prec(op) < outer_prec;\n         }\n-        case (ast::expr_cast(_, _, _)) {\n+        case (ast::expr_cast(_, _)) {\n             add_them = front::parser::as_prec < outer_prec;\n         }\n         case (_) { add_them = false; }"}, {"sha": "801dda99de4c81e3ce4bf6442d0deffcc64ff0ad", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e9b33d9d9252ea343b08d4f4a70c59896e0e9/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=c34e9b33d9d9252ea343b08d4f4a70c59896e0e9", "patch": "@@ -152,8 +152,8 @@ fn has_nonlocal_exits(&ast::block b) -> bool {\n     auto has_exits = @mutable false;\n     fn visit_expr(@mutable bool flag, &@ast::expr e) {\n         alt (e.node) {\n-            case (ast::expr_break(_)) { *flag = true; }\n-            case (ast::expr_cont(_)) { *flag = true; }\n+            case (ast::expr_break) { *flag = true; }\n+            case (ast::expr_cont) { *flag = true; }\n             case (_) { }\n         }\n     }"}]}