{"sha": "06685bacf8ba8cfbf1473ab46f0a1746bfbff58f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2Njg1YmFjZjhiYThjZmJmMTQ3M2FiNDZmMGExNzQ2YmZiZmY1OGY=", "commit": {"author": {"name": "Jihyun Yu", "email": "yjh0502@gmail.com", "date": "2013-05-22T12:01:21Z"}, "committer": {"name": "Jihyun Yu", "email": "yjh0502@gmail.com", "date": "2013-05-22T12:01:21Z"}, "message": "add smallintset", "tree": {"sha": "1fa2cf0bf2113c8847622cb59f617427745918be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fa2cf0bf2113c8847622cb59f617427745918be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06685bacf8ba8cfbf1473ab46f0a1746bfbff58f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06685bacf8ba8cfbf1473ab46f0a1746bfbff58f", "html_url": "https://github.com/rust-lang/rust/commit/06685bacf8ba8cfbf1473ab46f0a1746bfbff58f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06685bacf8ba8cfbf1473ab46f0a1746bfbff58f/comments", "author": {"login": "yjh0502", "id": 554344, "node_id": "MDQ6VXNlcjU1NDM0NA==", "avatar_url": "https://avatars.githubusercontent.com/u/554344?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yjh0502", "html_url": "https://github.com/yjh0502", "followers_url": "https://api.github.com/users/yjh0502/followers", "following_url": "https://api.github.com/users/yjh0502/following{/other_user}", "gists_url": "https://api.github.com/users/yjh0502/gists{/gist_id}", "starred_url": "https://api.github.com/users/yjh0502/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yjh0502/subscriptions", "organizations_url": "https://api.github.com/users/yjh0502/orgs", "repos_url": "https://api.github.com/users/yjh0502/repos", "events_url": "https://api.github.com/users/yjh0502/events{/privacy}", "received_events_url": "https://api.github.com/users/yjh0502/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yjh0502", "id": 554344, "node_id": "MDQ6VXNlcjU1NDM0NA==", "avatar_url": "https://avatars.githubusercontent.com/u/554344?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yjh0502", "html_url": "https://github.com/yjh0502", "followers_url": "https://api.github.com/users/yjh0502/followers", "following_url": "https://api.github.com/users/yjh0502/following{/other_user}", "gists_url": "https://api.github.com/users/yjh0502/gists{/gist_id}", "starred_url": "https://api.github.com/users/yjh0502/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yjh0502/subscriptions", "organizations_url": "https://api.github.com/users/yjh0502/orgs", "repos_url": "https://api.github.com/users/yjh0502/repos", "events_url": "https://api.github.com/users/yjh0502/events{/privacy}", "received_events_url": "https://api.github.com/users/yjh0502/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15e44381af4f6d89fc62111a8425087ccab40665", "url": "https://api.github.com/repos/rust-lang/rust/commits/15e44381af4f6d89fc62111a8425087ccab40665", "html_url": "https://github.com/rust-lang/rust/commit/15e44381af4f6d89fc62111a8425087ccab40665"}], "stats": {"total": 243, "additions": 242, "deletions": 1}, "files": [{"sha": "aa8372bab78d92c3a099a27b17ed0ac9f5ab885e", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 242, "deletions": 1, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/06685bacf8ba8cfbf1473ab46f0a1746bfbff58f/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06685bacf8ba8cfbf1473ab46f0a1746bfbff58f/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=06685bacf8ba8cfbf1473ab46f0a1746bfbff58f", "patch": "@@ -14,7 +14,8 @@\n  */\n \n use core::container::{Container, Mutable, Map, Set};\n-use core::old_iter::{BaseIter};\n+use core::old_iter::BaseIter;\n+use core::old_iter;\n use core::option::{Some, None};\n use core::util::replace;\n \n@@ -181,6 +182,87 @@ pub impl<V:Copy> SmallIntMap<V> {\n     }\n }\n \n+pub struct SmallIntSet {\n+    priv map: SmallIntMap<()>\n+}\n+\n+impl Container for SmallIntSet {\n+    /// Return the number of elements in the map\n+    fn len(&const self) -> uint {\n+        self.map.len()\n+    }\n+\n+    /// Return true if the map contains no elements\n+    fn is_empty(&const self) -> bool { self.len() == 0 }\n+}\n+\n+impl Mutable for SmallIntSet {\n+    /// Clear the map, removing all key-value pairs.\n+    fn clear(&mut self) { self.map.clear() }\n+}\n+\n+impl BaseIter<uint> for SmallIntSet {\n+    /// Visit all values in order\n+    fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n+impl Set<uint> for SmallIntSet {\n+    /// Return true if the set contains a value\n+    fn contains(&self, value: &uint) -> bool { self.map.contains_key(value) }\n+\n+    /// Add a value to the set. Return true if the value was not already\n+    /// present in the set.\n+    fn insert(&mut self, value: uint) -> bool { self.map.insert(value, ()) }\n+\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    fn remove(&mut self, value: &uint) -> bool { self.map.remove(value) }\n+\n+    /// Return true if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty uintersection.\n+    fn is_disjoint(&self, other: &SmallIntSet) -> bool {\n+        old_iter::all(self, |v| !other.contains(v))\n+    }\n+\n+    /// Return true if the set is a subset of another\n+    fn is_subset(&self, other: &SmallIntSet) -> bool {\n+        old_iter::all(self, |v| other.contains(v))\n+    }\n+\n+    /// Return true if the set is a superset of another\n+    fn is_superset(&self, other: &SmallIntSet) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    /// Visit the values representing the difference\n+    fn difference(&self, other: &SmallIntSet, f: &fn(&uint) -> bool) -> bool {\n+        self.each(|v| other.contains(v) || f(v))\n+    }\n+\n+    /// Visit the values representing the symmetric difference\n+    fn symmetric_difference(&self,\n+                            other: &SmallIntSet,\n+                            f: &fn(&uint) -> bool) -> bool {\n+        self.difference(other, f) && other.difference(self, f)\n+    }\n+\n+    /// Visit the values representing the uintersection\n+    fn intersection(&self, other: &SmallIntSet, f: &fn(&uint) -> bool) -> bool {\n+        self.each(|v| !other.contains(v) || f(v))\n+    }\n+\n+    /// Visit the values representing the union\n+    fn union(&self, other: &SmallIntSet, f: &fn(&uint) -> bool) -> bool {\n+        self.each(f) && other.each(|v| self.contains(v) || f(v))\n+    }\n+}\n+\n+pub impl SmallIntSet {\n+    /// Create an empty SmallIntSet\n+    fn new() -> SmallIntSet { SmallIntSet{map: SmallIntMap::new()} }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::SmallIntMap;\n@@ -273,3 +355,162 @@ mod tests {\n         assert_eq!(m.pop(&1), None);\n     }\n }\n+\n+#[cfg(test)]\n+mod test_set {\n+    use super::SmallIntSet;\n+\n+    #[test]\n+    fn test_disjoint() {\n+        let mut xs = SmallIntSet::new();\n+        let mut ys = SmallIntSet::new();\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(5));\n+        assert!(ys.insert(11));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(7));\n+        assert!(xs.insert(19));\n+        assert!(xs.insert(4));\n+        assert!(ys.insert(2));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(ys.insert(7));\n+        assert!(!xs.is_disjoint(&ys));\n+        assert!(!ys.is_disjoint(&xs));\n+    }\n+\n+    #[test]\n+    fn test_subset_and_superset() {\n+        let mut a = SmallIntSet::new();\n+        assert!(a.insert(0));\n+        assert!(a.insert(5));\n+        assert!(a.insert(11));\n+        assert!(a.insert(7));\n+\n+        let mut b = SmallIntSet::new();\n+        assert!(b.insert(0));\n+        assert!(b.insert(7));\n+        assert!(b.insert(19));\n+        assert!(b.insert(250));\n+        assert!(b.insert(11));\n+        assert!(b.insert(200));\n+\n+        assert!(!a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(!b.is_superset(&a));\n+\n+        assert!(b.insert(5));\n+\n+        assert!(a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(b.is_superset(&a));\n+    }\n+\n+    #[test]\n+    fn test_intersection() {\n+        let mut a = SmallIntSet::new();\n+        let mut b = SmallIntSet::new();\n+\n+        assert!(a.insert(11));\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(77));\n+        assert!(a.insert(103));\n+        assert!(a.insert(5));\n+\n+        assert!(b.insert(2));\n+        assert!(b.insert(11));\n+        assert!(b.insert(77));\n+        assert!(b.insert(5));\n+        assert!(b.insert(3));\n+\n+        let mut i = 0;\n+        let expected = [3, 5, 11, 77];\n+        for a.intersection(&b) |x| {\n+            assert!(vec::contains(expected, x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_difference() {\n+        let mut a = SmallIntSet::new();\n+        let mut b = SmallIntSet::new();\n+\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+\n+        assert!(b.insert(3));\n+        assert!(b.insert(9));\n+\n+        let mut i = 0;\n+        let expected = [1, 5, 11];\n+        for a.difference(&b) |x| {\n+            assert!(vec::contains(expected, x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_symmetric_difference() {\n+        let mut a = SmallIntSet::new();\n+        let mut b = SmallIntSet::new();\n+\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+\n+        assert!(b.insert(3));\n+        assert!(b.insert(9));\n+        assert!(b.insert(14));\n+        assert!(b.insert(22));\n+\n+        let mut i = 0;\n+        let expected = [1, 5, 11, 14, 22];\n+        for a.symmetric_difference(&b) |x| {\n+            assert!(vec::contains(expected, x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_union() {\n+        let mut a = SmallIntSet::new();\n+        let mut b = SmallIntSet::new();\n+\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+        assert!(a.insert(16));\n+        assert!(a.insert(19));\n+        assert!(a.insert(24));\n+\n+        assert!(b.insert(1));\n+        assert!(b.insert(5));\n+        assert!(b.insert(9));\n+        assert!(b.insert(13));\n+        assert!(b.insert(19));\n+\n+        let mut i = 0;\n+        let expected = [1, 3, 5, 9, 11, 13, 16, 19, 24];\n+        for a.union(&b) |x| {\n+            assert!(vec::contains(expected, x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+}"}]}