{"sha": "71f8fd5c5859fa09587486351f849277a910e4d9", "node_id": "C_kwDOAAsO6NoAKDcxZjhmZDVjNTg1OWZhMDk1ODc0ODYzNTFmODQ5Mjc3YTkxMGU0ZDk", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-09-19T12:59:52Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-09-19T13:13:34Z"}, "message": "improve infer var handling for implied bounds", "tree": {"sha": "ccb507b4f77650891254cabdb3fb6a330ddf937e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccb507b4f77650891254cabdb3fb6a330ddf937e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71f8fd5c5859fa09587486351f849277a910e4d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71f8fd5c5859fa09587486351f849277a910e4d9", "html_url": "https://github.com/rust-lang/rust/commit/71f8fd5c5859fa09587486351f849277a910e4d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71f8fd5c5859fa09587486351f849277a910e4d9/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efa717bc2d82c19c6957f362a936a6f95169d138", "url": "https://api.github.com/repos/rust-lang/rust/commits/efa717bc2d82c19c6957f362a936a6f95169d138", "html_url": "https://github.com/rust-lang/rust/commit/efa717bc2d82c19c6957f362a936a6f95169d138"}], "stats": {"total": 75, "additions": 41, "deletions": 34}, "files": [{"sha": "9922b156ebf96d0c5765f6d192a4e0be058c580a", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71f8fd5c5859fa09587486351f849277a910e4d9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f8fd5c5859fa09587486351f849277a910e4d9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=71f8fd5c5859fa09587486351f849277a910e4d9", "patch": "@@ -53,6 +53,7 @@ pub struct OutlivesEnvironment<'tcx> {\n }\n \n /// Builder of OutlivesEnvironment.\n+#[derive(Debug)]\n struct OutlivesEnvironmentBuilder<'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n     region_relation: TransitiveRelationBuilder<Region<'tcx>>,\n@@ -109,6 +110,7 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n \n impl<'a, 'tcx> OutlivesEnvironmentBuilder<'tcx> {\n     #[inline]\n+    #[instrument(level = \"debug\")]\n     fn build(self) -> OutlivesEnvironment<'tcx> {\n         OutlivesEnvironment {\n             param_env: self.param_env,"}, {"sha": "3008dfcadde9e3c7eccd56081bd06a34b7f36ee1", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71f8fd5c5859fa09587486351f849277a910e4d9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f8fd5c5859fa09587486351f849277a910e4d9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=71f8fd5c5859fa09587486351f849277a910e4d9", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'cx, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'cx, 'tcx> {\n     ///   Note that this may cause outlives obligations to be injected\n     ///   into the inference context with this body-id.\n     /// - `ty`, the type that we are supposed to assume is WF.\n-    #[instrument(level = \"debug\", skip(self, param_env, body_id))]\n+    #[instrument(level = \"debug\", skip(self, param_env, body_id), ret)]\n     fn implied_outlives_bounds(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -71,6 +71,7 @@ impl<'a, 'cx, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'cx, 'tcx> {\n         let TypeOpOutput { output, constraints, .. } = result;\n \n         if let Some(constraints) = constraints {\n+            debug!(?constraints);\n             // Instantiation may have produced new inference variables and constraints on those\n             // variables. Process these constraints.\n             let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(self.tcx);"}, {"sha": "691b79f10533dd813579d7a9afa72c76b647ce00", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/71f8fd5c5859fa09587486351f849277a910e4d9/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f8fd5c5859fa09587486351f849277a910e4d9/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=71f8fd5c5859fa09587486351f849277a910e4d9", "patch": "@@ -49,7 +49,8 @@ fn compute_implied_outlives_bounds<'tcx>(\n     let mut checked_wf_args = rustc_data_structures::fx::FxHashSet::default();\n     let mut wf_args = vec![ty.into()];\n \n-    let mut implied_bounds = vec![];\n+    let mut outlives_bounds: Vec<ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>> =\n+        vec![];\n \n     let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(tcx);\n \n@@ -65,41 +66,28 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // than the ultimate set. (Note: normally there won't be\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n+        //\n+        // FIXME(@lcnr): It's not really \"always fine\", having fewer implied\n+        // bounds can be backward incompatible, e.g. #101951 was caused by\n+        // us not dealing with inference vars in `TypeOutlives` predicates.\n         let obligations = wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, 0, arg, DUMMY_SP)\n             .unwrap_or_default();\n \n-        // N.B., all of these predicates *ought* to be easily proven\n-        // true. In fact, their correctness is (mostly) implied by\n-        // other parts of the program. However, in #42552, we had\n-        // an annoying scenario where:\n-        //\n-        // - Some `T::Foo` gets normalized, resulting in a\n-        //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n-        //   (not sure why it couldn't immediately get\n-        //   solved). This result of `_1` got cached.\n-        // - These obligations were dropped on the floor here,\n-        //   rather than being registered.\n-        // - Then later we would get a request to normalize\n-        //   `T::Foo` which would result in `_1` being used from\n-        //   the cache, but hence without the `T: Trait<Foo=_1>`\n-        //   constraint. As a result, `_1` never gets resolved,\n-        //   and we get an ICE (in dropck).\n-        //\n-        // Therefore, we register any predicates involving\n-        // inference variables. We restrict ourselves to those\n-        // involving inference variables both for efficiency and\n-        // to avoids duplicate errors that otherwise show up.\n+        // While these predicates should all be implied by other parts of\n+        // the program, they are still relevant as they may constrain\n+        // inference variables, which is necessary to add the correct\n+        // implied bounds in some cases, mostly when dealing with projections.\n         fulfill_cx.register_predicate_obligations(\n             infcx,\n             obligations.iter().filter(|o| o.predicate.has_infer_types_or_consts()).cloned(),\n         );\n \n         // From the full set of obligations, just filter down to the\n         // region relationships.\n-        implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n+        outlives_bounds.extend(obligations.into_iter().filter_map(|obligation| {\n             assert!(!obligation.has_escaping_bound_vars());\n             match obligation.predicate.kind().no_bound_vars() {\n-                None => vec![],\n+                None => None,\n                 Some(pred) => match pred {\n                     ty::PredicateKind::Trait(..)\n                     | ty::PredicateKind::Subtype(..)\n@@ -109,21 +97,18 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n-                    | ty::PredicateKind::TypeWellFormedFromEnv(..) => vec![],\n+                    | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                     ty::PredicateKind::WellFormed(arg) => {\n                         wf_args.push(arg);\n-                        vec![]\n+                        None\n                     }\n \n                     ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n-                        vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n+                        Some(ty::OutlivesPredicate(r_a.into(), r_b))\n                     }\n \n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                        let ty_a = infcx.resolve_vars_if_possible(ty_a);\n-                        let mut components = smallvec![];\n-                        push_outlives_components(tcx, ty_a, &mut components);\n-                        implied_bounds_from_components(r_b, components)\n+                        Some(ty::OutlivesPredicate(ty_a.into(), r_b))\n                     }\n                 },\n             }\n@@ -133,9 +118,27 @@ fn compute_implied_outlives_bounds<'tcx>(\n     // Ensure that those obligations that we had to solve\n     // get solved *here*.\n     match fulfill_cx.select_all_or_error(infcx).as_slice() {\n-        [] => Ok(implied_bounds),\n-        _ => Err(NoSolution),\n+        [] => (),\n+        _ => return Err(NoSolution),\n     }\n+\n+    // We lazily compute the outlives components as\n+    // `select_all_or_error` constrains inference variables.\n+    let implied_bounds = outlives_bounds\n+        .into_iter()\n+        .flat_map(|ty::OutlivesPredicate(a, r_b)| match a.unpack() {\n+            ty::GenericArgKind::Lifetime(r_a) => vec![OutlivesBound::RegionSubRegion(r_b, r_a)],\n+            ty::GenericArgKind::Type(ty_a) => {\n+                let ty_a = infcx.resolve_vars_if_possible(ty_a);\n+                let mut components = smallvec![];\n+                push_outlives_components(tcx, ty_a, &mut components);\n+                implied_bounds_from_components(r_b, components)\n+            }\n+            ty::GenericArgKind::Const(_) => unreachable!(),\n+        })\n+        .collect();\n+\n+    Ok(implied_bounds)\n }\n \n /// When we have an implied bound that `T: 'a`, we can further break"}, {"sha": "59d591acdc445ce962238e1cba3d83b84db8268b", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71f8fd5c5859fa09587486351f849277a910e4d9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f8fd5c5859fa09587486351f849277a910e4d9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=71f8fd5c5859fa09587486351f849277a910e4d9", "patch": "@@ -140,6 +140,7 @@ pub(crate) fn compare_impl_method<'tcx>(\n ///\n /// Finally we register each of these predicates as an obligation and check that\n /// they hold.\n+#[instrument(level = \"debug\", skip(tcx, impl_m_span, impl_trait_ref))]\n fn compare_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &AssocItem,"}]}