{"sha": "63f74f3771c20fceea294d2dc759ccde8a59a6cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZjc0ZjM3NzFjMjBmY2VlYTI5NGQyZGM3NTljY2RlOGE1OWE2Y2Q=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-28T00:49:00Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-28T00:49:00Z"}, "message": "Remove vestiges of \"layers\", insert skeletal do-nothing \"kind\" pass plus cached calculation of kind for each type.", "tree": {"sha": "5504c7c6b9d0acb14f69159095bf63e84f033799", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5504c7c6b9d0acb14f69159095bf63e84f033799"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63f74f3771c20fceea294d2dc759ccde8a59a6cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63f74f3771c20fceea294d2dc759ccde8a59a6cd", "html_url": "https://github.com/rust-lang/rust/commit/63f74f3771c20fceea294d2dc759ccde8a59a6cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63f74f3771c20fceea294d2dc759ccde8a59a6cd/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04611a3e56b84c9d3439d1625e61d092d860a2c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/04611a3e56b84c9d3439d1625e61d092d860a2c1", "html_url": "https://github.com/rust-lang/rust/commit/04611a3e56b84c9d3439d1625e61d092d860a2c1"}], "stats": {"total": 284, "additions": 265, "deletions": 19}, "files": [{"sha": "b267af517b485a28af588a7443846b45fb4e01d5", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63f74f3771c20fceea294d2dc759ccde8a59a6cd/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f74f3771c20fceea294d2dc759ccde8a59a6cd/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=63f74f3771c20fceea294d2dc759ccde8a59a6cd", "patch": "@@ -11,6 +11,7 @@ import front::attr;\n import middle::trans;\n import middle::resolve;\n import middle::freevars;\n+import middle::kind;\n import middle::ty;\n import middle::typeck;\n import middle::tstate::ck;\n@@ -147,6 +148,8 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n     }\n     time(time_passes, \"alias checking\",\n          bind middle::alias::check_crate(ty_cx, crate));\n+    time[()](time_passes, \"kind checking\",\n+             bind kind::check_crate(ty_cx, crate));\n     let llmod =\n         time[llvm::llvm::ModuleRef](time_passes, \"translation\",\n                                     bind trans::trans_crate(sess, crate,"}, {"sha": "1d391f80f848d7f042d9acda6b2580b0bef89c28", "filename": "src/comp/middle/kind.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/63f74f3771c20fceea294d2dc759ccde8a59a6cd/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f74f3771c20fceea294d2dc759ccde8a59a6cd/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=63f74f3771c20fceea294d2dc759ccde8a59a6cd", "patch": "@@ -0,0 +1,128 @@\n+/*\n+* Kinds are types of type.\n+*\n+* Every type has a kind. Every type parameter has a set of kind-capabilities\n+* saying which kind of type may be passed as the parameter.\n+*\n+* The kinds are based on two capabilities: copy and send. These may each be\n+* present or absent, though only three of the four combinations can actually\n+* occur:\n+*\n+*\n+*\n+*    COPY +   SEND  =  \"Unique\": no shared substructures or pins, only\n+*                                interiors and ~ boxes.\n+*\n+*    COPY + NOSEND  =  \"Shared\": structures containing @, fixed to the local\n+*                                task heap/pool.\n+*\n+*  NOCOPY + NOSEND  =  \"Pinned\": structures containing resources or\n+*                                by-alias closures as interior or\n+*                                uniquely-boxed members.\n+*\n+*  NOCOPY +   SEND  =  --      : no types are like this.\n+*\n+*\n+* Since this forms a lattice, we denote the capabilites in terms of a\n+* worst-case requirement.  That is, if your function needs to copy-and-send\n+* your T, you write fn<~T>(...). If you need to copy but not send, you write\n+* fn<@T>(...). And if you need neither -- can work with any sort of pinned\n+* data at all -- then you write fn<T>(...).\n+*\n+*\n+* Most types are unique or shared. Other possible name combinations for these\n+* two: (tree, graph; pruned, pooled; message, local; owned, common) are\n+* plausible but nothing stands out as completely pithy-and-obvious.\n+*\n+* Resources cannot be copied or sent; they're pinned. They can't be copied\n+* because it would interfere with destruction (multiple destruction?) They\n+* cannot be sent because we don't want to oblige the communication system to\n+* run destructors in some weird limbo context of messages-in-transit. It\n+* should always be ok to just free messages it's dropping.\n+*\n+* Note that obj~ and fn~ -- those that capture a unique environment -- can be\n+* sent, so satisfy ~T. So can plain obj and fn.\n+*\n+*\n+* Further notes on copying and moving; sending is accomplished by calling a\n+* move-in operator on something constrained to a unique type ~T.\n+*\n+*\n+* COPYING:\n+* --------\n+*\n+*   A copy is made any time you pass-by-value or execute the = operator in a\n+*   non-init expression.\n+*\n+*   ~ copies deep\n+*   @ copies shallow\n+*     pinned values (pinned resources, alias-closures) can't be copied\n+*     all other interiors copy shallow\n+*\n+* MOVING:\n+* -------\n+*\n+*  A move is made any time you pass-by-move (that is, with 'move' mode) or\n+*  execute the <- operator.\n+*\n+*  Anything you can copy, you can move. Move is (semantically) just\n+*  shallow-copy + deinit.  Note that: ~ moves shallow even though it copies\n+*  deep. Move is the operator that lets ~ copy shallow: by pairing it with a\n+*  deinit.\n+*\n+*/\n+\n+\n+import syntax::ast;\n+import syntax::walk;\n+\n+import ast::kind;\n+import ast::kind_unique;\n+import ast::kind_shared;\n+import ast::kind_pinned;\n+\n+fn kind_lteq(a: kind, b: kind) -> bool {\n+    alt a {\n+      kind_pinned. { true }\n+      kind_shared. { b != kind_pinned }\n+      kind_unique. { b == kind_unique }\n+    }\n+}\n+\n+fn lower_kind(a: kind, b: kind) -> kind {\n+    if kind_lteq(a, b) { a } else { b }\n+}\n+\n+fn kind_to_str(k: kind) -> str {\n+    alt k {\n+      ast::kind_pinned. { \"pinned\" }\n+      ast::kind_unique. { \"unique\" }\n+      ast::kind_shared. { \"shared\" }\n+    }\n+}\n+\n+fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n+    let t = ty::expr_ty(tcx, e);\n+    let k = ty::type_kind(tcx, t);\n+    log #fmt(\"%s type: %s\", kind_to_str(k),\n+             util::ppaux::ty_to_str(tcx, t));\n+}\n+\n+fn check_crate(tcx: &ty::ctxt, crate: &@ast::crate) {\n+    let visit =\n+        {visit_expr_pre: bind check_expr(tcx, _)\n+         with walk::default_visitor()};\n+    walk::walk_crate(visit, *crate);\n+    tcx.sess.abort_if_errors();\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "08e6447c2d0c7699ba248a3da22dfd081da76269", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 128, "deletions": 2, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/63f74f3771c20fceea294d2dc759ccde8a59a6cd/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f74f3771c20fceea294d2dc759ccde8a59a6cd/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=63f74f3771c20fceea294d2dc759ccde8a59a6cd", "patch": "@@ -152,6 +152,7 @@ export ty_fn_args;\n export type_constr;\n export type_contains_params;\n export type_contains_vars;\n+export type_kind;\n export type_err;\n export type_err_to_str;\n export type_has_dynamic_size;\n@@ -216,6 +217,7 @@ type ctxt =\n       rcache: creader_cache,\n       short_names_cache: hashmap[t, str],\n       has_pointer_cache: hashmap[t, bool],\n+      kind_cache: hashmap[t, ast::kind],\n       owns_heap_mem_cache: hashmap[t, bool],\n       ast_ty_to_ty_cache: hashmap[@ast::ty, option::t[t]]};\n \n@@ -409,6 +411,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n           rcache: mk_rcache(),\n           short_names_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n           has_pointer_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n+          kind_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n           owns_heap_mem_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n           ast_ty_to_ty_cache: map::mk_hashmap(ast::hash_ty, ast::eq_ty)};\n     populate_type_store(cx);\n@@ -981,7 +984,10 @@ fn type_has_pointers(cx: &ctxt, ty: &t) -> bool {\n       ty_native(_) {/* no-op */ }\n       ty_rec(flds) {\n         for f: field  in flds {\n-            if type_has_pointers(cx, f.mt.ty) { result = true; }\n+            if type_has_pointers(cx, f.mt.ty) {\n+                result = true;\n+                break;\n+            }\n         }\n       }\n       ty_tag(did, tps) {\n@@ -990,8 +996,12 @@ fn type_has_pointers(cx: &ctxt, ty: &t) -> bool {\n             for aty: t  in variant.args {\n                 // Perform any type parameter substitutions.\n                 let arg_ty = substitute_type_params(cx, tps, aty);\n-                if type_has_pointers(cx, arg_ty) { result = true; }\n+                if type_has_pointers(cx, arg_ty) {\n+                    result = true;\n+                    break;\n+                }\n             }\n+            if result { break; }\n         }\n       }\n       ty_res(did, inner, tps) {\n@@ -1005,6 +1015,122 @@ fn type_has_pointers(cx: &ctxt, ty: &t) -> bool {\n     ret result;\n }\n \n+fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n+    alt cx.kind_cache.find(ty) {\n+      some(result) { ret result; }\n+      none. {/* fall through */ }\n+    }\n+\n+    let result = ast::kind_unique;\n+\n+    // Insert a default in case we loop back on self recursively.\n+    cx.kind_cache.insert(ty, result);\n+\n+    alt struct(cx, ty) {\n+\n+      // Scalar types are unique-kind, no substructure.\n+      ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_uint. | ty_float.\n+      | ty_machine(_) | ty_char. | ty_native(_) {\n+        // no-op\n+      }\n+\n+      // A handful of other built-in are unique too.\n+      ty_type. | ty_istr. | ty_native_fn(_, _, _) {\n+        // no-op\n+      }\n+\n+      // Those things with refcounts-to-interior are just shared.\n+      ty_str. | ty_task. {\n+        result = kind_shared;\n+      }\n+\n+      // FIXME: obj is broken for now, since we aren't asserting\n+      // anything about its fields.\n+      ty_obj(_) { result = kind_shared; }\n+\n+      // FIXME: the environment capture mode is not fully encoded\n+      // here yet, leading to weirdness around closure.\n+      ty_fn(proto, _, _, _, _) {\n+        result = alt proto {\n+          ast::proto_block. { ast::kind_pinned }\n+          ast::proto_closure. { ast::kind_shared }\n+          _ { ast::kind_unique }\n+        }\n+      }\n+\n+      // Those with refcounts-to-inner are the lower of their\n+      // inner and shared.\n+      ty_box(mt) | ty_vec(mt) {\n+        result = kind::lower_kind(ast::kind_shared,\n+                                  type_kind(cx, mt.ty));\n+\n+      }\n+\n+      // FIXME: remove ports. Ports currently contribute 'shared'\n+      ty_port(t) {\n+        result = kind::lower_kind(ast::kind_shared,\n+                                  type_kind(cx, t));\n+      }\n+\n+      // FIXME: remove chans. Chans currently contribute only\n+      // their inner.\n+      ty_chan(t) {\n+        result = type_kind(cx, t);\n+      }\n+\n+      // Pointers and unique boxes / vecs lower to whatever they point to.\n+      ty_ptr(tm) | ty_ivec(tm) {\n+        result = type_kind(cx, tm.ty);\n+      }\n+\n+      // Records lower to the lowest of their members.\n+      ty_rec(flds) {\n+        for f: field  in flds {\n+            result = kind::lower_kind(result, type_kind(cx, f.mt.ty));\n+            if result == ast::kind_pinned { break; }\n+        }\n+      }\n+\n+      // Tags lower to the lowest of their variants.\n+      ty_tag(did, tps) {\n+        let variants = tag_variants(cx, did);\n+        for variant: variant_info  in variants {\n+            for aty: t  in variant.args {\n+                // Perform any type parameter substitutions.\n+                let arg_ty = substitute_type_params(cx, tps, aty);\n+                result = kind::lower_kind(result, type_kind(cx, arg_ty));\n+                if result == ast::kind_pinned { break; }\n+            }\n+            if result == ast::kind_pinned { break; }\n+        }\n+      }\n+\n+      // Resources are always pinned.\n+      ty_res(did, inner, tps) {\n+        result = ast::kind_pinned;\n+      }\n+\n+      ty_var(_) { fail; }\n+\n+      ty_param(_) {\n+        // FIXME: this should contribute the kind-bound of the typaram,\n+        // when those exist.\n+      }\n+\n+      ty_constr(t, _) {\n+        result = type_kind(cx, t);\n+      }\n+\n+        _ {\n+            cx.sess.bug(\"missed case: \" + ty_to_str(cx, ty));\n+        }\n+\n+    }\n+\n+    cx.kind_cache.insert(ty, result);\n+    ret result;\n+}\n+\n \n // FIXME: should we just return true for native types in\n // type_is_scalar?"}, {"sha": "da6f7e5c8531a431844e9815675b3f9f74a8839f", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63f74f3771c20fceea294d2dc759ccde8a59a6cd/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/63f74f3771c20fceea294d2dc759ccde8a59a6cd/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=63f74f3771c20fceea294d2dc759ccde8a59a6cd", "patch": "@@ -27,6 +27,7 @@ mod middle {\n     mod typeck;\n     mod check_alt;\n     mod alias;\n+    mod kind;\n     mod freevars;\n \n     mod tstate {"}, {"sha": "45be817f91a28dae8caf4012fa04ab7ed9644b71", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63f74f3771c20fceea294d2dc759ccde8a59a6cd/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f74f3771c20fceea294d2dc759ccde8a59a6cd/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=63f74f3771c20fceea294d2dc759ccde8a59a6cd", "patch": "@@ -157,7 +157,7 @@ fn pat_id_map(pat: &@pat) -> pat_id_map {\n \n tag mutability { mut; imm; maybe_mut; }\n \n-tag layer { layer_value; layer_state; layer_gc; }\n+tag kind { kind_pinned; kind_shared; kind_unique; }\n \n tag _auth { auth_unsafe; }\n "}, {"sha": "4d8fe83355966a7fcea7f2e2c4c23777636c24ea", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/63f74f3771c20fceea294d2dc759ccde8a59a6cd/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63f74f3771c20fceea294d2dc759ccde8a59a6cd/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=63f74f3771c20fceea294d2dc759ccde8a59a6cd", "patch": "@@ -483,7 +483,6 @@ fn parse_ty(p: &parser) -> @ast::ty {\n     let t: ast::ty_;\n     // FIXME: do something with this\n \n-    parse_layer(p);\n     if eat_word(p, \"bool\") {\n         t = ast::ty_bool;\n     } else if (eat_word(p, \"int\")) {\n@@ -1821,7 +1820,7 @@ fn parse_dtor(p: &parser) -> @ast::method {\n     ret @spanned(lo, f.body.span.hi, m);\n }\n \n-fn parse_item_obj(p: &parser, lyr: ast::layer, attrs: &ast::attribute[]) ->\n+fn parse_item_obj(p: &parser, attrs: &ast::attribute[]) ->\n    @ast::item {\n     let lo = p.get_last_lo_pos();\n     let ident = parse_value_ident(p);\n@@ -1844,7 +1843,7 @@ fn parse_item_obj(p: &parser, lyr: ast::layer, attrs: &ast::attribute[]) ->\n                 attrs);\n }\n \n-fn parse_item_res(p: &parser, lyr: ast::layer, attrs: &ast::attribute[]) ->\n+fn parse_item_res(p: &parser, attrs: &ast::attribute[]) ->\n    @ast::item {\n     let lo = p.get_last_lo_pos();\n     let ident = parse_value_ident(p);\n@@ -1945,7 +1944,6 @@ fn parse_item_native_fn(p: &parser, attrs: &ast::attribute[]) ->\n \n fn parse_native_item(p: &parser, attrs: &ast::attribute[]) ->\n    @ast::native_item {\n-    parse_layer(p);\n     if eat_word(p, \"type\") {\n         ret parse_item_native_type(p, attrs);\n     } else if (eat_word(p, \"fn\")) {\n@@ -2084,15 +2082,6 @@ fn parse_item_tag(p: &parser, attrs: &ast::attribute[]) -> @ast::item {\n     ret mk_item(p, lo, hi, id, ast::item_tag(variants, ty_params), attrs);\n }\n \n-fn parse_layer(p: &parser) -> ast::layer {\n-    if eat_word(p, \"state\") {\n-        ret ast::layer_state;\n-    } else if (eat_word(p, \"gc\")) {\n-        ret ast::layer_gc;\n-    } else { ret ast::layer_value; }\n-    fail;\n-}\n-\n fn parse_auth(p: &parser) -> ast::_auth {\n     if eat_word(p, \"unsafe\") {\n         ret ast::auth_unsafe;\n@@ -2122,15 +2111,14 @@ fn parse_item(p: &parser, attrs: &ast::attribute[]) -> parsed_item {\n     } else if (eat_word(p, \"native\")) {\n         ret got_item(parse_item_native_mod(p, attrs));\n     }\n-    let lyr = parse_layer(p);\n     if eat_word(p, \"type\") {\n         ret got_item(parse_item_type(p, attrs));\n     } else if (eat_word(p, \"tag\")) {\n         ret got_item(parse_item_tag(p, attrs));\n     } else if (eat_word(p, \"obj\")) {\n-        ret got_item(parse_item_obj(p, lyr, attrs));\n+        ret got_item(parse_item_obj(p, attrs));\n     } else if (eat_word(p, \"resource\")) {\n-        ret got_item(parse_item_res(p, lyr, attrs));\n+        ret got_item(parse_item_res(p, attrs));\n     } else { ret no_item; }\n }\n "}]}