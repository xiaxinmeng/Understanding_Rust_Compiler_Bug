{"sha": "d50349ba8d2baaa023eadacf7207516c83225f1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MDM0OWJhOGQyYmFhYTAyM2VhZGFjZjcyMDc1MTZjODMyMjVmMWY=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-10-06T07:25:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-06T07:25:58Z"}, "message": "Rollup merge of #76995 - LingMan:middle_matches, r=varkor\n\nReduce boilerplate with the matches! macro\n\nReplaces simple bool `match`es of the form\n\n    match $expr {\n        $pattern => true\n        _ => false\n    }\n\nand their inverse with invocations of the matches! macro.\n\nLimited to rustc_middle for now to get my feet wet.", "tree": {"sha": "dc0acb8f8054225234bcf6622251da83db4ccf28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc0acb8f8054225234bcf6622251da83db4ccf28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d50349ba8d2baaa023eadacf7207516c83225f1f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJffBwGCRBK7hj4Ov3rIwAAdHIIABIX5O9OnJegSg6LrCxuPFiR\nYp6MCdWNs7J8onK8pulUmmSuJ83WpfJks7EraZCtpKAKjEIPdhsuLQtySG4K+6Xy\nDUAXOf7CnIA2eTQIEygbpqMLncuulUhtjAO8sonlTi5MP6iJ0MIewnI6QRCuRxYn\nbTnPDrx4JCiKQFntyMdKY5fEYIB2BBOziNmmMBIhN5dQL8Vqftt+SM6N0YZo6W22\n3NuNMwJxPIS0dv2u/OaGZNEw72DCVrv1zTAkc0dRRqhrmgvszMSjyl7lnBZI8J6H\nelK+AgjX3Ag9BTmz3fwUMKNqzcELFvTZhPJvjzuJUk6JUX5MpCUJetFg1rjxSIw=\n=EyYw\n-----END PGP SIGNATURE-----\n", "payload": "tree dc0acb8f8054225234bcf6622251da83db4ccf28\nparent 97ee62cee43373e7d1c6e6e778b1f9b738523ead\nparent a6ff925f8b5598a1f6d84964525baa1d4a08fd63\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1601969158 +0900\ncommitter GitHub <noreply@github.com> 1601969158 +0900\n\nRollup merge of #76995 - LingMan:middle_matches, r=varkor\n\nReduce boilerplate with the matches! macro\n\nReplaces simple bool `match`es of the form\n\n    match $expr {\n        $pattern => true\n        _ => false\n    }\n\nand their inverse with invocations of the matches! macro.\n\nLimited to rustc_middle for now to get my feet wet.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d50349ba8d2baaa023eadacf7207516c83225f1f", "html_url": "https://github.com/rust-lang/rust/commit/d50349ba8d2baaa023eadacf7207516c83225f1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d50349ba8d2baaa023eadacf7207516c83225f1f/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97ee62cee43373e7d1c6e6e778b1f9b738523ead", "url": "https://api.github.com/repos/rust-lang/rust/commits/97ee62cee43373e7d1c6e6e778b1f9b738523ead", "html_url": "https://github.com/rust-lang/rust/commit/97ee62cee43373e7d1c6e6e778b1f9b738523ead"}, {"sha": "a6ff925f8b5598a1f6d84964525baa1d4a08fd63", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6ff925f8b5598a1f6d84964525baa1d4a08fd63", "html_url": "https://github.com/rust-lang/rust/commit/a6ff925f8b5598a1f6d84964525baa1d4a08fd63"}], "stats": {"total": 409, "additions": 140, "deletions": 269}, "files": [{"sha": "57f03c2a5cf54c54745b584ce048f0e01dc99659", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -535,15 +535,15 @@ impl<'hir> Map<'hir> {\n             Some(Node::Binding(_)) => (),\n             _ => return false,\n         }\n-        match self.find(self.get_parent_node(id)) {\n+        matches!(\n+            self.find(self.get_parent_node(id)),\n             Some(\n                 Node::Item(_)\n                 | Node::TraitItem(_)\n                 | Node::ImplItem(_)\n                 | Node::Expr(Expr { kind: ExprKind::Closure(..), .. }),\n-            ) => true,\n-            _ => false,\n-        }\n+            )\n+        )\n     }\n \n     /// Whether the expression pointed at by `hir_id` belongs to a `const` evaluation context.\n@@ -554,10 +554,10 @@ impl<'hir> Map<'hir> {\n \n     /// Whether `hir_id` corresponds to a `mod` or a crate.\n     pub fn is_hir_id_module(&self, hir_id: HirId) -> bool {\n-        match self.get_entry(hir_id).node {\n-            Node::Item(Item { kind: ItemKind::Mod(_), .. }) | Node::Crate(..) => true,\n-            _ => false,\n-        }\n+        matches!(\n+            self.get_entry(hir_id).node,\n+            Node::Item(Item { kind: ItemKind::Mod(_), .. }) | Node::Crate(..)\n+        )\n     }\n \n     /// Retrieves the `HirId` for `id`'s enclosing method, unless there's a"}, {"sha": "b5beb3babe2392625421d0129dab5dc43b7c2237", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -486,10 +486,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         // `main as fn() == main as fn()` is false, while `let x = main as fn(); x == x` is true.\n         // However, formatting code relies on function identity (see #58320), so we only do\n         // this for generic functions.  Lifetime parameters are ignored.\n-        let is_generic = instance.substs.into_iter().any(|kind| match kind.unpack() {\n-            GenericArgKind::Lifetime(_) => false,\n-            _ => true,\n-        });\n+        let is_generic = instance\n+            .substs\n+            .into_iter()\n+            .any(|kind| !matches!(kind.unpack(), GenericArgKind::Lifetime(_)));\n         if is_generic {\n             // Get a fresh ID.\n             let mut alloc_map = self.alloc_map.lock();"}, {"sha": "3751249853fdac55338d8208b024086ea1ef5801", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -445,19 +445,13 @@ impl<'tcx, Tag> Scalar<Tag> {\n     /// Do not call this method!  Dispatch based on the type instead.\n     #[inline]\n     pub fn is_bits(self) -> bool {\n-        match self {\n-            Scalar::Raw { .. } => true,\n-            _ => false,\n-        }\n+        matches!(self, Scalar::Raw { .. })\n     }\n \n     /// Do not call this method!  Dispatch based on the type instead.\n     #[inline]\n     pub fn is_ptr(self) -> bool {\n-        match self {\n-            Scalar::Ptr(_) => true,\n-            _ => false,\n-        }\n+        matches!(self, Scalar::Ptr(_))\n     }\n \n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {"}, {"sha": "da7677f802bda22fd715e2535601da15d8338d7a", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -971,67 +971,59 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// - `let x = ...`,\n     /// - or `match ... { C(x) => ... }`\n     pub fn can_be_made_mutable(&self) -> bool {\n-        match self.local_info {\n-            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                binding_mode: ty::BindingMode::BindByValue(_),\n-                opt_ty_info: _,\n-                opt_match_place: _,\n-                pat_span: _,\n-            })))) => true,\n-\n-            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(\n-                ImplicitSelfKind::Imm,\n-            )))) => true,\n-\n-            _ => false,\n-        }\n+        matches!(\n+            self.local_info,\n+            Some(box LocalInfo::User(ClearCrossCrate::Set(\n+                BindingForm::Var(VarBindingForm {\n+                    binding_mode: ty::BindingMode::BindByValue(_),\n+                    opt_ty_info: _,\n+                    opt_match_place: _,\n+                    pat_span: _,\n+                })\n+                | BindingForm::ImplicitSelf(ImplicitSelfKind::Imm),\n+            )))\n+        )\n     }\n \n     /// Returns `true` if local is definitely not a `ref ident` or\n     /// `ref mut ident` binding. (Such bindings cannot be made into\n     /// mutable bindings, but the inverse does not necessarily hold).\n     pub fn is_nonref_binding(&self) -> bool {\n-        match self.local_info {\n-            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                binding_mode: ty::BindingMode::BindByValue(_),\n-                opt_ty_info: _,\n-                opt_match_place: _,\n-                pat_span: _,\n-            })))) => true,\n-\n-            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(_)))) => true,\n-\n-            _ => false,\n-        }\n+        matches!(\n+            self.local_info,\n+            Some(box LocalInfo::User(ClearCrossCrate::Set(\n+                BindingForm::Var(VarBindingForm {\n+                    binding_mode: ty::BindingMode::BindByValue(_),\n+                    opt_ty_info: _,\n+                    opt_match_place: _,\n+                    pat_span: _,\n+                })\n+                | BindingForm::ImplicitSelf(_),\n+            )))\n+        )\n     }\n \n     /// Returns `true` if this variable is a named variable or function\n     /// parameter declared by the user.\n     #[inline]\n     pub fn is_user_variable(&self) -> bool {\n-        match self.local_info {\n-            Some(box LocalInfo::User(_)) => true,\n-            _ => false,\n-        }\n+        matches!(self.local_info, Some(box LocalInfo::User(_)))\n     }\n \n     /// Returns `true` if this is a reference to a variable bound in a `match`\n     /// expression that is used to access said variable for the guard of the\n     /// match arm.\n     pub fn is_ref_for_guard(&self) -> bool {\n-        match self.local_info {\n-            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard))) => true,\n-            _ => false,\n-        }\n+        matches!(\n+            self.local_info,\n+            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard)))\n+        )\n     }\n \n     /// Returns `Some` if this is a reference to a static item that is used to\n     /// access that static\n     pub fn is_ref_to_static(&self) -> bool {\n-        match self.local_info {\n-            Some(box LocalInfo::StaticRef { .. }) => true,\n-            _ => false,\n-        }\n+        matches!(self.local_info, Some(box LocalInfo::StaticRef { .. }))\n     }\n \n     /// Returns `Some` if this is a reference to a static item that is used to\n@@ -2164,10 +2156,7 @@ pub enum BinOp {\n impl BinOp {\n     pub fn is_checkable(self) -> bool {\n         use self::BinOp::*;\n-        match self {\n-            Add | Sub | Mul | Shl | Shr => true,\n-            _ => false,\n-        }\n+        matches!(self, Add | Sub | Mul | Shl | Shr)\n     }\n }\n "}, {"sha": "9a6bfa101899a97880eff62d4d32a6047af5b9b5", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 22, "deletions": 41, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -1164,82 +1164,63 @@ pub enum PlaceContext {\n impl PlaceContext {\n     /// Returns `true` if this place context represents a drop.\n     pub fn is_drop(&self) -> bool {\n-        match *self {\n-            PlaceContext::MutatingUse(MutatingUseContext::Drop) => true,\n-            _ => false,\n-        }\n+        matches!(self, PlaceContext::MutatingUse(MutatingUseContext::Drop))\n     }\n \n     /// Returns `true` if this place context represents a borrow.\n     pub fn is_borrow(&self) -> bool {\n-        match *self {\n+        matches!(\n+            self,\n             PlaceContext::NonMutatingUse(\n                 NonMutatingUseContext::SharedBorrow\n-                | NonMutatingUseContext::ShallowBorrow\n-                | NonMutatingUseContext::UniqueBorrow,\n-            )\n-            | PlaceContext::MutatingUse(MutatingUseContext::Borrow) => true,\n-            _ => false,\n-        }\n+                    | NonMutatingUseContext::ShallowBorrow\n+                    | NonMutatingUseContext::UniqueBorrow\n+            ) | PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n+        )\n     }\n \n     /// Returns `true` if this place context represents a storage live or storage dead marker.\n     pub fn is_storage_marker(&self) -> bool {\n-        match *self {\n-            PlaceContext::NonUse(NonUseContext::StorageLive | NonUseContext::StorageDead) => true,\n-            _ => false,\n-        }\n+        matches!(\n+            self,\n+            PlaceContext::NonUse(NonUseContext::StorageLive | NonUseContext::StorageDead)\n+        )\n     }\n \n     /// Returns `true` if this place context represents a storage live marker.\n     pub fn is_storage_live_marker(&self) -> bool {\n-        match *self {\n-            PlaceContext::NonUse(NonUseContext::StorageLive) => true,\n-            _ => false,\n-        }\n+        matches!(self, PlaceContext::NonUse(NonUseContext::StorageLive))\n     }\n \n     /// Returns `true` if this place context represents a storage dead marker.\n     pub fn is_storage_dead_marker(&self) -> bool {\n-        match *self {\n-            PlaceContext::NonUse(NonUseContext::StorageDead) => true,\n-            _ => false,\n-        }\n+        matches!(self, PlaceContext::NonUse(NonUseContext::StorageDead))\n     }\n \n     /// Returns `true` if this place context represents a use that potentially changes the value.\n     pub fn is_mutating_use(&self) -> bool {\n-        match *self {\n-            PlaceContext::MutatingUse(..) => true,\n-            _ => false,\n-        }\n+        matches!(self, PlaceContext::MutatingUse(..))\n     }\n \n     /// Returns `true` if this place context represents a use that does not change the value.\n     pub fn is_nonmutating_use(&self) -> bool {\n-        match *self {\n-            PlaceContext::NonMutatingUse(..) => true,\n-            _ => false,\n-        }\n+        matches!(self, PlaceContext::NonMutatingUse(..))\n     }\n \n     /// Returns `true` if this place context represents a use.\n     pub fn is_use(&self) -> bool {\n-        match *self {\n-            PlaceContext::NonUse(..) => false,\n-            _ => true,\n-        }\n+        !matches!(self, PlaceContext::NonUse(..))\n     }\n \n     /// Returns `true` if this place context represents an assignment statement.\n     pub fn is_place_assignment(&self) -> bool {\n-        match *self {\n+        matches!(\n+            self,\n             PlaceContext::MutatingUse(\n                 MutatingUseContext::Store\n-                | MutatingUseContext::Call\n-                | MutatingUseContext::AsmOutput,\n-            ) => true,\n-            _ => false,\n-        }\n+                    | MutatingUseContext::Call\n+                    | MutatingUseContext::AsmOutput,\n+            )\n+        )\n     }\n }"}, {"sha": "ec6010e6eecf453fec73674cc58ac576329575a2", "filename": "compiler/rustc_middle/src/traits/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -79,10 +79,7 @@ pub enum Node {\n \n impl<'tcx> Node {\n     pub fn is_from_trait(&self) -> bool {\n-        match *self {\n-            Node::Trait(..) => true,\n-            _ => false,\n-        }\n+        matches!(self, Node::Trait(..))\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node."}, {"sha": "89d0e139551226e5565e9296aa60bb2085d91b8d", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -85,10 +85,7 @@ pub struct Adjustment<'tcx> {\n \n impl Adjustment<'tcx> {\n     pub fn is_region_borrow(&self) -> bool {\n-        match self.kind {\n-            Adjust::Borrow(AutoBorrow::Ref(..)) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind, Adjust::Borrow(AutoBorrow::Ref(..)))\n     }\n }\n "}, {"sha": "e67a76f0111a099181e83b75bfc8415ea6f2b405", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -588,10 +588,7 @@ impl<'tcx> TypeckResults<'tcx> {\n             return false;\n         }\n \n-        match self.type_dependent_defs().get(expr.hir_id) {\n-            Some(Ok((DefKind::AssocFn, _))) => true,\n-            _ => false,\n-        }\n+        matches!(self.type_dependent_defs().get(expr.hir_id), Some(Ok((DefKind::AssocFn, _))))\n     }\n \n     pub fn extract_binding_mode(&self, s: &Session, id: HirId, sp: Span) -> Option<BindingMode> {"}, {"sha": "65703d04c7040439a9633106337253b27ab280f4", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -11,21 +11,16 @@ use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n impl<'tcx> TyS<'tcx> {\n     /// Similar to `TyS::is_primitive`, but also considers inferred numeric values to be primitive.\n     pub fn is_primitive_ty(&self) -> bool {\n-        match self.kind() {\n-            Bool\n-            | Char\n-            | Str\n-            | Int(_)\n-            | Uint(_)\n-            | Float(_)\n+        matches!(\n+            self.kind(),\n+            Bool | Char | Str | Int(_) | Uint(_) | Float(_)\n             | Infer(\n                 InferTy::IntVar(_)\n                 | InferTy::FloatVar(_)\n                 | InferTy::FreshIntTy(_)\n-                | InferTy::FreshFloatTy(_),\n-            ) => true,\n-            _ => false,\n-        }\n+                | InferTy::FreshFloatTy(_)\n+            )\n+        )\n     }\n \n     /// Whether the type is succinctly representable as a type instead of just referred to with a\n@@ -64,11 +59,16 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Whether the type can be safely suggested during error recovery.\n     pub fn is_suggestable(&self) -> bool {\n-        match self.kind() {\n-            Opaque(..) | FnDef(..) | FnPtr(..) | Dynamic(..) | Closure(..) | Infer(..)\n-            | Projection(..) => false,\n-            _ => true,\n-        }\n+        !matches!(\n+            self.kind(),\n+            Opaque(..)\n+                | FnDef(..)\n+                | FnPtr(..)\n+                | Dynamic(..)\n+                | Closure(..)\n+                | Infer(..)\n+                | Projection(..)\n+        )\n     }\n }\n "}, {"sha": "f8e8c209d373d0965aec3374ba81b5ce46028d21", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -184,10 +184,10 @@ impl<'tcx> InstanceDef<'tcx> {\n             ty::InstanceDef::DropGlue(_, Some(_)) => return false,\n             _ => return true,\n         };\n-        match tcx.def_key(def_id).disambiguated_data.data {\n-            DefPathData::Ctor | DefPathData::ClosureExpr => true,\n-            _ => false,\n-        }\n+        matches!(\n+            tcx.def_key(def_id).disambiguated_data.data,\n+            DefPathData::Ctor | DefPathData::ClosureExpr\n+        )\n     }\n \n     /// Returns `true` if the machine code for this instance is instantiated in"}, {"sha": "f6f71d002a88a2164e468934542bd24115fe30b4", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -2610,10 +2610,7 @@ where\n             target.target_os == \"linux\" && target.arch == \"sparc64\" && target_env_gnu_like;\n         let linux_powerpc_gnu_like =\n             target.target_os == \"linux\" && target.arch == \"powerpc\" && target_env_gnu_like;\n-        let rust_abi = match sig.abi {\n-            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => true,\n-            _ => false,\n-        };\n+        let rust_abi = matches!(sig.abi, RustIntrinsic | PlatformIntrinsic | Rust | RustCall);\n \n         // Handle safe Rust thin and fat pointers.\n         let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,"}, {"sha": "5f5efd5fa775326c8bf9d66ea38c42f4360e839a", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -2681,15 +2681,15 @@ impl<'tcx> ClosureKind {\n     /// Returns `true` if a type that impls this closure kind\n     /// must also implement `other`.\n     pub fn extends(self, other: ty::ClosureKind) -> bool {\n-        match (self, other) {\n-            (ClosureKind::Fn, ClosureKind::Fn) => true,\n-            (ClosureKind::Fn, ClosureKind::FnMut) => true,\n-            (ClosureKind::Fn, ClosureKind::FnOnce) => true,\n-            (ClosureKind::FnMut, ClosureKind::FnMut) => true,\n-            (ClosureKind::FnMut, ClosureKind::FnOnce) => true,\n-            (ClosureKind::FnOnce, ClosureKind::FnOnce) => true,\n-            _ => false,\n-        }\n+        matches!(\n+            (self, other),\n+            (ClosureKind::Fn, ClosureKind::Fn)\n+                | (ClosureKind::Fn, ClosureKind::FnMut)\n+                | (ClosureKind::Fn, ClosureKind::FnOnce)\n+                | (ClosureKind::FnMut, ClosureKind::FnMut)\n+                | (ClosureKind::FnMut, ClosureKind::FnOnce)\n+                | (ClosureKind::FnOnce, ClosureKind::FnOnce)\n+        )\n     }\n \n     /// Returns the representative scalar type for this closure kind.\n@@ -2815,15 +2815,15 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn opt_associated_item(self, def_id: DefId) -> Option<&'tcx AssocItem> {\n         let is_associated_item = if let Some(def_id) = def_id.as_local() {\n-            match self.hir().get(self.hir().local_def_id_to_hir_id(def_id)) {\n-                Node::TraitItem(_) | Node::ImplItem(_) => true,\n-                _ => false,\n-            }\n+            matches!(\n+                self.hir().get(self.hir().local_def_id_to_hir_id(def_id)),\n+                Node::TraitItem(_) | Node::ImplItem(_)\n+            )\n         } else {\n-            match self.def_kind(def_id) {\n-                DefKind::AssocConst | DefKind::AssocFn | DefKind::AssocTy => true,\n-                _ => false,\n-            }\n+            matches!(\n+                self.def_kind(def_id),\n+                DefKind::AssocConst | DefKind::AssocFn | DefKind::AssocTy\n+            )\n         };\n \n         is_associated_item.then(|| self.associated_item(def_id))"}, {"sha": "5cba451ea6e3c7071462b48b41da5d637c73a8f7", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 32, "deletions": 113, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d50349ba8d2baaa023eadacf7207516c83225f1f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=d50349ba8d2baaa023eadacf7207516c83225f1f", "patch": "@@ -1763,10 +1763,7 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_never(&self) -> bool {\n-        match self.kind() {\n-            Never => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Never)\n     }\n \n     /// Checks whether a type is definitely uninhabited. This is\n@@ -1823,34 +1820,22 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_adt(&self) -> bool {\n-        match self.kind() {\n-            Adt(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Adt(..))\n     }\n \n     #[inline]\n     pub fn is_ref(&self) -> bool {\n-        match self.kind() {\n-            Ref(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Ref(..))\n     }\n \n     #[inline]\n     pub fn is_ty_var(&self) -> bool {\n-        match self.kind() {\n-            Infer(TyVar(_)) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Infer(TyVar(_)))\n     }\n \n     #[inline]\n     pub fn is_ty_infer(&self) -> bool {\n-        match self.kind() {\n-            Infer(_) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Infer(_))\n     }\n \n     #[inline]\n@@ -1880,20 +1865,14 @@ impl<'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_slice(&self) -> bool {\n         match self.kind() {\n-            RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => match ty.kind() {\n-                Slice(_) | Str => true,\n-                _ => false,\n-            },\n+            RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => matches!(ty.kind(), Slice(_) | Str),\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_array(&self) -> bool {\n-        match self.kind() {\n-            Array(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Array(..))\n     }\n \n     #[inline]\n@@ -1940,27 +1919,21 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_region_ptr(&self) -> bool {\n-        match self.kind() {\n-            Ref(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Ref(..))\n     }\n \n     #[inline]\n     pub fn is_mutable_ptr(&self) -> bool {\n-        match self.kind() {\n+        matches!(\n+            self.kind(),\n             RawPtr(TypeAndMut { mutbl: hir::Mutability::Mut, .. })\n-            | Ref(_, _, hir::Mutability::Mut) => true,\n-            _ => false,\n-        }\n+                | Ref(_, _, hir::Mutability::Mut)\n+        )\n     }\n \n     #[inline]\n     pub fn is_unsafe_ptr(&self) -> bool {\n-        match self.kind() {\n-            RawPtr(_) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), RawPtr(_))\n     }\n \n     /// Tests if this is any kind of primitive pointer type (reference, raw pointer, fn pointer).\n@@ -1990,35 +1963,22 @@ impl<'tcx> TyS<'tcx> {\n     /// contents are abstract to rustc.)\n     #[inline]\n     pub fn is_scalar(&self) -> bool {\n-        match self.kind() {\n-            Bool\n-            | Char\n-            | Int(_)\n-            | Float(_)\n-            | Uint(_)\n+        matches!(\n+            self.kind(),\n+            Bool | Char | Int(_) | Float(_) | Uint(_) | FnDef(..) | FnPtr(_) | RawPtr(_)\n             | Infer(IntVar(_) | FloatVar(_))\n-            | FnDef(..)\n-            | FnPtr(_)\n-            | RawPtr(_) => true,\n-            _ => false,\n-        }\n+        )\n     }\n \n     /// Returns `true` if this type is a floating point type.\n     #[inline]\n     pub fn is_floating_point(&self) -> bool {\n-        match self.kind() {\n-            Float(_) | Infer(FloatVar(_)) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Float(_) | Infer(FloatVar(_)))\n     }\n \n     #[inline]\n     pub fn is_trait(&self) -> bool {\n-        match self.kind() {\n-            Dynamic(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Dynamic(..))\n     }\n \n     #[inline]\n@@ -2031,52 +1991,32 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_closure(&self) -> bool {\n-        match self.kind() {\n-            Closure(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Closure(..))\n     }\n \n     #[inline]\n     pub fn is_generator(&self) -> bool {\n-        match self.kind() {\n-            Generator(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Generator(..))\n     }\n \n     #[inline]\n     pub fn is_integral(&self) -> bool {\n-        match self.kind() {\n-            Infer(IntVar(_)) | Int(_) | Uint(_) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Infer(IntVar(_)) | Int(_) | Uint(_))\n     }\n \n     #[inline]\n     pub fn is_fresh_ty(&self) -> bool {\n-        match self.kind() {\n-            Infer(FreshTy(_)) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Infer(FreshTy(_)))\n     }\n \n     #[inline]\n     pub fn is_fresh(&self) -> bool {\n-        match self.kind() {\n-            Infer(FreshTy(_)) => true,\n-            Infer(FreshIntTy(_)) => true,\n-            Infer(FreshFloatTy(_)) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Infer(FreshTy(_) | FreshIntTy(_) | FreshFloatTy(_)))\n     }\n \n     #[inline]\n     pub fn is_char(&self) -> bool {\n-        match self.kind() {\n-            Char => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Char)\n     }\n \n     #[inline]\n@@ -2086,34 +2026,22 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_signed(&self) -> bool {\n-        match self.kind() {\n-            Int(_) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Int(_))\n     }\n \n     #[inline]\n     pub fn is_ptr_sized_integral(&self) -> bool {\n-        match self.kind() {\n-            Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize))\n     }\n \n     #[inline]\n     pub fn is_machine(&self) -> bool {\n-        match self.kind() {\n-            Int(..) | Uint(..) | Float(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Int(..) | Uint(..) | Float(..))\n     }\n \n     #[inline]\n     pub fn has_concrete_skeleton(&self) -> bool {\n-        match self.kind() {\n-            Param(_) | Infer(_) | Error(_) => false,\n-            _ => true,\n-        }\n+        !matches!(self.kind(), Param(_) | Infer(_) | Error(_))\n     }\n \n     /// Returns the type and mutability of `*ty`.\n@@ -2156,26 +2084,17 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_fn(&self) -> bool {\n-        match self.kind() {\n-            FnDef(..) | FnPtr(_) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), FnDef(..) | FnPtr(_))\n     }\n \n     #[inline]\n     pub fn is_fn_ptr(&self) -> bool {\n-        match self.kind() {\n-            FnPtr(_) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), FnPtr(_))\n     }\n \n     #[inline]\n     pub fn is_impl_trait(&self) -> bool {\n-        match self.kind() {\n-            Opaque(..) => true,\n-            _ => false,\n-        }\n+        matches!(self.kind(), Opaque(..))\n     }\n \n     #[inline]"}]}