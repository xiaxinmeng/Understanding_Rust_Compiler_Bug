{"sha": "aad53cb6e298192cc75cd5769a1b997a3457666c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhZDUzY2I2ZTI5ODE5MmNjNzVjZDU3NjlhMWI5OTdhMzQ1NzY2NmM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-07-27T02:19:33Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-07-28T06:41:09Z"}, "message": "cleanup .map and .map_err", "tree": {"sha": "6201272c79bc45f6a4cc38f0c0e9ebfbae23e55f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6201272c79bc45f6a4cc38f0c0e9ebfbae23e55f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aad53cb6e298192cc75cd5769a1b997a3457666c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aad53cb6e298192cc75cd5769a1b997a3457666c", "html_url": "https://github.com/rust-lang/rust/commit/aad53cb6e298192cc75cd5769a1b997a3457666c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aad53cb6e298192cc75cd5769a1b997a3457666c/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9dc1de4c9e84a5b8625ff1f066b3f05c39531d9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dc1de4c9e84a5b8625ff1f066b3f05c39531d9d", "html_url": "https://github.com/rust-lang/rust/commit/9dc1de4c9e84a5b8625ff1f066b3f05c39531d9d"}], "stats": {"total": 73, "additions": 33, "deletions": 40}, "files": [{"sha": "8e44a42e038ab1545a7fed9b0bc93c20fc43b5b9", "filename": "src/libstd/result.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/aad53cb6e298192cc75cd5769a1b997a3457666c/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad53cb6e298192cc75cd5769a1b997a3457666c/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=aad53cb6e298192cc75cd5769a1b997a3457666c", "patch": "@@ -46,45 +46,10 @@ pub fn to_either<T:Clone,U:Clone>(res: &Result<U, T>)\n     }\n }\n \n-/**\n- * Call a function based on a previous result\n- *\n- * If `res` is `ok` then the value is extracted and passed to `op` whereupon\n- * `op`s result is wrapped in `ok` and returned. if `res` is `err` then it is\n- * immediately returned.  This function can be used to compose the results of\n- * two functions.\n- *\n- * Example:\n- *\n- *     let res = map(read_file(file)) { |buf|\n- *         parse_bytes(buf)\n- *     }\n- */\n-#[inline]\n-pub fn map<T, E: Clone, U: Clone>(res: &Result<T, E>, op: &fn(&T) -> U)\n-  -> Result<U, E> {\n-    match *res {\n-      Ok(ref t) => Ok(op(t)),\n-      Err(ref e) => Err((*e).clone())\n-    }\n-}\n \n-/**\n- * Call a function based on a previous result\n- *\n- * If `res` is `err` then the value is extracted and passed to `op` whereupon\n- * `op`s result is wrapped in an `err` and returned. if `res` is `ok` then it\n- * is immediately returned.  This function can be used to pass through a\n- * successful result while handling an error.\n- */\n-#[inline]\n-pub fn map_err<T:Clone,E,F:Clone>(res: &Result<T, E>, op: &fn(&E) -> F)\n-  -> Result<T, F> {\n-    match *res {\n-      Ok(ref t) => Ok((*t).clone()),\n-      Err(ref e) => Err(op(e))\n-    }\n-}\n+\n+\n+\n \n impl<T, E> Result<T, E> {\n     /**\n@@ -229,9 +194,20 @@ impl<T:Clone,E> Result<T, E> {\n         }\n     }\n \n+    /**\n+    * Call a function based on a previous result\n+    *\n+    * If `*self` is `err` then the value is extracted and passed to `op` whereupon\n+    * `op`s result is wrapped in an `err` and returned. if `*self` is `ok` then it\n+    * is immediately returned.  This function can be used to pass through a\n+    * successful result while handling an error.\n+    */\n     #[inline]\n     pub fn map_err<F:Clone>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n-        map_err(self, op)\n+        match *self {\n+            Ok(ref t) => Ok(t.clone()),\n+            Err(ref e) => Err(op(e))\n+        }\n     }\n }\n \n@@ -251,9 +227,26 @@ impl<T, E:Clone> Result<T, E> {\n         }\n     }\n \n+    /**\n+    * Call a function based on a previous result\n+    *\n+    * If `res` is `ok` then the value is extracted and passed to `op` whereupon\n+    * `op`s result is wrapped in `ok` and returned. if `res` is `err` then it is\n+    * immediately returned.  This function can be used to compose the results of\n+    * two functions.\n+    *\n+    * Example:\n+    *\n+    *     let res = map(read_file(file)) { |buf|\n+    *         parse_bytes(buf)\n+    *     }\n+    */\n     #[inline]\n     pub fn map<U:Clone>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n-        map(self, op)\n+        match *self {\n+            Ok(ref t) => Ok(op(t)),\n+            Err(ref e) => Err(e.clone())\n+        }\n     }\n }\n "}]}