{"sha": "d360091e799b14a81ced54a67bc67ae0b0bc3afe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNjAwOTFlNzk5YjE0YTgxY2VkNTRhNjdiYzY3YWUwYjBiYzNhZmU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-11-08T21:54:31Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-04-21T10:28:24Z"}, "message": "Add suggestion for & coercions", "tree": {"sha": "af2d840ba6963a32c3c9a93d21a648d730de97b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af2d840ba6963a32c3c9a93d21a648d730de97b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d360091e799b14a81ced54a67bc67ae0b0bc3afe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d360091e799b14a81ced54a67bc67ae0b0bc3afe", "html_url": "https://github.com/rust-lang/rust/commit/d360091e799b14a81ced54a67bc67ae0b0bc3afe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d360091e799b14a81ced54a67bc67ae0b0bc3afe/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "968ae7babecfc6c62ef9699ff052d9ab00411848", "url": "https://api.github.com/repos/rust-lang/rust/commits/968ae7babecfc6c62ef9699ff052d9ab00411848", "html_url": "https://github.com/rust-lang/rust/commit/968ae7babecfc6c62ef9699ff052d9ab00411848"}], "stats": {"total": 77, "additions": 70, "deletions": 7}, "files": [{"sha": "2933f35abfb6a9260eef9fb0cc76dc5e51ab2692", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 70, "deletions": 7, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d360091e799b14a81ced54a67bc67ae0b0bc3afe/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d360091e799b14a81ced54a67bc67ae0b0bc3afe/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d360091e799b14a81ced54a67bc67ae0b0bc3afe", "patch": "@@ -11,8 +11,9 @@\n \n use check::FnCtxt;\n use rustc::ty::Ty;\n-use rustc::infer::{InferOk};\n+use rustc::infer::{InferOk, TypeOrigin};\n use rustc::traits::ObligationCause;\n+use rustc::ty;\n \n use syntax::ast;\n use syntax_pos::{self, Span};\n@@ -80,12 +81,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Err(e) = self.try_coerce(expr, checked_ty, self.diverges.get(), expected) {\n             let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n-            let mode = probe::Mode::MethodCall;\n-            let suggestions = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n-                                                         mode,\n-                                                         expected,\n-                                                         checked_ty,\n-                                                         ast::DUMMY_NODE_ID);\n+            let suggestions = if let Some(suggestions) = self.check_ref(expr,\n+                                                                        checked_ty,\n+                                                                        expected) {\n+                suggestions\n+            } else {\n+                let mode = probe::Mode::MethodCall;\n+                self.probe_for_return_type(syntax_pos::DUMMY_SP,\n+                                           mode,\n+                                           expected,\n+                                           checked_ty,\n+                                           ast::DUMMY_NODE_ID)\n+            }\n             let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n             if suggestions.len() > 0 {\n                 err.help(&format!(\"here are some functions which \\\n@@ -140,4 +147,60 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => false,\n         }\n     }\n+\n+    /// This function is used to determine potential \"simple\" improvements or users' errors and\n+    /// provide them useful help. For example:\n+    ///\n+    /// ```\n+    /// fn some_fn(s: &str) {}\n+    ///\n+    /// let x = \"hey!\".to_owned();\n+    /// some_fn(x); // error\n+    /// ```\n+    ///\n+    /// No need to find every potential function which could make a coercion to transform a\n+    /// `String` into a `&str` since a `&` would do the trick!\n+    ///\n+    /// In addition of this check, it also checks between references mutability state. If the\n+    /// expected is mutable but the provided isn't, maybe we could just say \"Hey, try with\n+    /// `&mut`!\".\n+    fn check_ref(&self,\n+                 expr: &hir::Expr,\n+                 checked_ty: Ty<'tcx>,\n+                 expected: Ty<'tcx>)\n+                 -> Option<String> {\n+        match (&expected.sty, &checked_ty.sty) {\n+            (&ty::TyRef(_, _), &ty::TyRef(_, _)) => None,\n+            (&ty::TyRef(_, mutability), _) => {\n+                // Check if it can work when put into a ref. For example:\n+                //\n+                // ```\n+                // fn bar(x: &mut i32) {}\n+                //\n+                // let x = 0u32;\n+                // bar(&x); // error, expected &mut\n+                // ```\n+                let ref_ty = match mutability.mutbl {\n+                    hir::Mutability::MutMutable => self.tcx.mk_mut_ref(\n+                                                       self.tcx.mk_region(ty::ReStatic),\n+                                                       checked_ty),\n+                    hir::Mutability::MutImmutable => self.tcx.mk_imm_ref(\n+                                                       self.tcx.mk_region(ty::ReStatic),\n+                                                       checked_ty),\n+                };\n+                if self.try_coerce(expr, ref_ty, expected).is_ok() {\n+                    if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+                        return Some(format!(\"try with `{}{}`\",\n+                                            match mutability.mutbl {\n+                                                hir::Mutability::MutMutable => \"&mut \",\n+                                                hir::Mutability::MutImmutable => \"&\",\n+                                            },\n+                                            &src));\n+                    }\n+                }\n+                None\n+            }\n+            _ => None,\n+        }\n+    }\n }"}]}