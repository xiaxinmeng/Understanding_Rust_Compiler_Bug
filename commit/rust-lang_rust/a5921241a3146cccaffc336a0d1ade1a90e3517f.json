{"sha": "a5921241a3146cccaffc336a0d1ade1a90e3517f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1OTIxMjQxYTMxNDZjY2NhZmZjMzM2YTBkMWFkZTFhOTBlMzUxN2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-12T15:22:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-12T15:22:06Z"}, "message": "auto merge of #18028 : gereeter/rust/slimmer-btree-node, r=Gankro\n\n...ated buffer.\r\n\r\nBefore:\r\n\r\n    test btree::map::bench::find_rand_100                      ... bench:        29 ns/iter (+/- 2)\r\n    test btree::map::bench::find_rand_10_000                   ... bench:        83 ns/iter (+/- 6)\r\n    test btree::map::bench::find_seq_100                       ... bench:        30 ns/iter (+/- 1)\r\n    test btree::map::bench::find_seq_10_000                    ... bench:        50 ns/iter (+/- 3)\r\n    test btree::map::bench::insert_rand_100                    ... bench:       186 ns/iter (+/- 30)\r\n    test btree::map::bench::insert_rand_10_000                 ... bench:       377 ns/iter (+/- 8)\r\n    test btree::map::bench::insert_seq_100                     ... bench:       299 ns/iter (+/- 10)\r\n    test btree::map::bench::insert_seq_10_000                  ... bench:       368 ns/iter (+/- 12)\r\n    test btree::map::bench::iter_1000                          ... bench:     20956 ns/iter (+/- 479)\r\n    test btree::map::bench::iter_100000                        ... bench:   2060899 ns/iter (+/- 44325)\r\n    test btree::map::bench::iter_20                            ... bench:       560 ns/iter (+/- 63)\r\n\r\nAfter:\r\n\r\n    test btree::map::bench::find_rand_100                      ... bench:        28 ns/iter (+/- 2)\r\n    test btree::map::bench::find_rand_10_000                   ... bench:        74 ns/iter (+/- 3)\r\n    test btree::map::bench::find_seq_100                       ... bench:        31 ns/iter (+/- 0)\r\n    test btree::map::bench::find_seq_10_000                    ... bench:        46 ns/iter (+/- 0)\r\n    test btree::map::bench::insert_rand_100                    ... bench:       141 ns/iter (+/- 1)\r\n    test btree::map::bench::insert_rand_10_000                 ... bench:       273 ns/iter (+/- 12)\r\n    test btree::map::bench::insert_seq_100                     ... bench:       255 ns/iter (+/- 17)\r\n    test btree::map::bench::insert_seq_10_000                  ... bench:       340 ns/iter (+/- 3)\r\n    test btree::map::bench::iter_1000                          ... bench:     21193 ns/iter (+/- 1958)\r\n    test btree::map::bench::iter_100000                        ... bench:   2203599 ns/iter (+/- 100491)\r\n    test btree::map::bench::iter_20                            ... bench:       614 ns/iter (+/- 110)\r\n\r\nThis code could probably be a fair bit cleaner, but it works.\r\n\r\nPart of #18009.", "tree": {"sha": "8f06e3b12c90d52b6c0f65782e48d78376cdbb3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f06e3b12c90d52b6c0f65782e48d78376cdbb3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5921241a3146cccaffc336a0d1ade1a90e3517f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5921241a3146cccaffc336a0d1ade1a90e3517f", "html_url": "https://github.com/rust-lang/rust/commit/a5921241a3146cccaffc336a0d1ade1a90e3517f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5921241a3146cccaffc336a0d1ade1a90e3517f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ea38750e92e199654968aa4dbb3462de71f7b50", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ea38750e92e199654968aa4dbb3462de71f7b50", "html_url": "https://github.com/rust-lang/rust/commit/2ea38750e92e199654968aa4dbb3462de71f7b50"}, {"sha": "130fb0821096987dbb67f0ec81cece71165b9eac", "url": "https://api.github.com/repos/rust-lang/rust/commits/130fb0821096987dbb67f0ec81cece71165b9eac", "html_url": "https://github.com/rust-lang/rust/commit/130fb0821096987dbb67f0ec81cece71165b9eac"}], "stats": {"total": 1969, "additions": 1476, "deletions": 493}, "files": [{"sha": "f0a4902bb9235baa53f8143d3a0b007c48e4546e", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 275, "deletions": 193, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/a5921241a3146cccaffc336a0d1ade1a90e3517f/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5921241a3146cccaffc336a0d1ade1a90e3517f/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=a5921241a3146cccaffc336a0d1ade1a90e3517f", "patch": "@@ -29,6 +29,8 @@ use core::fmt::Show;\n \n use ring_buf::RingBuf;\n \n+use self::Continuation::{Continue, Finished};\n+\n // FIXME(conventions): implement bounded iterators\n \n /// A map based on a B-Tree.\n@@ -121,12 +123,12 @@ pub enum Entry<'a, K:'a, V:'a> {\n /// A vacant Entry.\n pub struct VacantEntry<'a, K:'a, V:'a> {\n     key: K,\n-    stack: stack::SearchStack<'a, K, V>,\n+    stack: stack::VacantSearchStack<'a, K, V>,\n }\n \n /// An occupied Entry.\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n-    stack: stack::SearchStack<'a, K, V>,\n+    stack: stack::OccupiedSearchStack<'a, K, V>,\n }\n \n impl<K: Ord, V> BTreeMap<K, V> {\n@@ -202,9 +204,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n-            match cur_node.search(key) {\n-                Found(i) => return cur_node.val(i),\n-                GoDown(i) => match cur_node.edge(i) {\n+            match Node::search(cur_node, key) {\n+                Found(handle) => return Some(handle.into_kv().1),\n+                GoDown(handle) => match handle.into_edge() {\n                     None => return None,\n                     Some(next_node) => {\n                         cur_node = next_node;\n@@ -266,9 +268,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut temp_node = &mut self.root;\n         loop {\n             let cur_node = temp_node;\n-            match cur_node.search(key) {\n-                Found(i) => return cur_node.val_mut(i),\n-                GoDown(i) => match cur_node.edge_mut(i) {\n+            match Node::search(cur_node, key) {\n+                Found(handle) => return Some(handle.into_kv_mut().1),\n+                GoDown(handle) => match handle.into_edge_mut() {\n                     None => return None,\n                     Some(next_node) => {\n                         temp_node = next_node;\n@@ -328,7 +330,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn insert(&mut self, key: K, mut value: V) -> Option<V> {\n+    pub fn insert(&mut self, mut key: K, mut value: V) -> Option<V> {\n         // This is a stack of rawptrs to nodes paired with indices, respectively\n         // representing the nodes and edges of our search path. We have to store rawptrs\n         // because as far as Rust is concerned, we can mutate aliased data with such a\n@@ -347,30 +349,39 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut stack = stack::PartialSearchStack::new(self);\n \n         loop {\n-            // Same basic logic as found in `find`, but with PartialSearchStack mediating the\n-            // actual nodes for us\n-            match stack.next().search(&key) {\n-                Found(i) => unsafe {\n-                    // Perfect match, swap the values and return the old one\n-                    let next = stack.into_next();\n-                    mem::swap(next.unsafe_val_mut(i), &mut value);\n-                    return Some(value);\n-                },\n-                GoDown(i) => {\n-                    // We need to keep searching, try to get the search stack\n-                    // to go down further\n-                    stack = match stack.push(i) {\n-                        stack::Done(new_stack) => {\n-                            // We've reached a leaf, perform the insertion here\n-                            new_stack.insert(key, value);\n-                            return None;\n-                        }\n-                        stack::Grew(new_stack) => {\n-                            // We've found the subtree to insert this key/value pair in,\n-                            // keep searching\n-                            new_stack\n-                        }\n-                    };\n+            let result = stack.with(move |pusher, node| {\n+                // Same basic logic as found in `find`, but with PartialSearchStack mediating the\n+                // actual nodes for us\n+                match Node::search(node, &key) {\n+                    Found(mut handle) => {\n+                        // Perfect match, swap the values and return the old one\n+                        mem::swap(handle.val_mut(), &mut value);\n+                        return Finished(Some(value));\n+                    },\n+                    GoDown(handle) => {\n+                        // We need to keep searching, try to get the search stack\n+                        // to go down further\n+                        match pusher.push(handle) {\n+                            stack::Done(new_stack) => {\n+                                // We've reached a leaf, perform the insertion here\n+                                new_stack.insert(key, value);\n+                                return Finished(None);\n+                            }\n+                            stack::Grew(new_stack) => {\n+                                // We've found the subtree to insert this key/value pair in,\n+                                // keep searching\n+                                return Continue((new_stack, key, value));\n+                            }\n+                        };\n+                    }\n+                }\n+            });\n+            match result {\n+                Finished(ret) => { return ret; },\n+                Continue((new_stack, renewed_key, renewed_val)) => {\n+                    stack = new_stack;\n+                    key = renewed_key;\n+                    value = renewed_val;\n                 }\n             }\n         }\n@@ -438,36 +449,71 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n-            match stack.next().search(key) {\n-                Found(i) => {\n-                    // Perfect match. Terminate the stack here, and remove the entry\n-                    return Some(stack.seal(i).remove());\n-                },\n-                GoDown(i) => {\n-                    // We need to keep searching, try to go down the next edge\n-                    stack = match stack.push(i) {\n-                        stack::Done(_) => return None, // We're at a leaf; the key isn't in here\n-                        stack::Grew(new_stack) => {\n-                            new_stack\n-                        }\n-                    };\n+            let result = stack.with(move |pusher, node| {\n+                match Node::search(node, key) {\n+                    Found(handle) => {\n+                        // Perfect match. Terminate the stack here, and remove the entry\n+                        return Finished(Some(pusher.seal(handle).remove()));\n+                    },\n+                    GoDown(handle) => {\n+                        // We need to keep searching, try to go down the next edge\n+                        match pusher.push(handle) {\n+                            // We're at a leaf; the key isn't in here\n+                            stack::Done(_) => return Finished(None),\n+                            stack::Grew(new_stack) => return Continue(new_stack)\n+                        };\n+                    }\n                 }\n+            });\n+            match result {\n+                Finished(ret) => return ret,\n+                Continue(new_stack) => stack = new_stack\n             }\n         }\n     }\n }\n \n+/// A helper enum useful for deciding whether to continue a loop since we can't\n+/// return from a closure\n+enum Continuation<A, B> {\n+    Continue(A),\n+    Finished(B)\n+}\n+\n /// The stack module provides a safe interface for constructing and manipulating a stack of ptrs\n /// to nodes. By using this module much better safety guarantees can be made, and more search\n /// boilerplate gets cut out.\n mod stack {\n     pub use self::PushResult::*;\n     use core::prelude::*;\n+    use core::kinds::marker;\n+    use core::mem;\n     use super::BTreeMap;\n     use super::super::node::*;\n     use vec::Vec;\n \n-    type StackItem<K, V> = (*mut Node<K, V>, uint);\n+    /// A generic mutable reference, identical to `&mut` except for the fact that its lifetime\n+    /// parameter is invariant. This means that wherever an `IdRef` is expected, only an `IdRef`\n+    /// with the exact requested lifetime can be used. This is in contrast to normal references,\n+    /// where `&'static` can be used in any function expecting any lifetime reference.\n+    pub struct IdRef<'id, T: 'id> {\n+        inner: &'id mut T,\n+        marker: marker::InvariantLifetime<'id>\n+    }\n+\n+    impl<'id, T> Deref<T> for IdRef<'id, T> {\n+        fn deref(&self) -> &T {\n+            &*self.inner\n+        }\n+    }\n+\n+    impl<'id, T> DerefMut<T> for IdRef<'id, T> {\n+        fn deref_mut(&mut self) -> &mut T {\n+            &mut *self.inner\n+        }\n+    }\n+\n+    type StackItem<K, V> = EdgeNodeHandle<*mut Node<K, V>>;\n     type Stack<K, V> = Vec<StackItem<K, V>>;\n \n     /// A PartialSearchStack handles the construction of a search stack.\n@@ -477,20 +523,37 @@ mod stack {\n         next: *mut Node<K, V>,\n     }\n \n-    /// A SearchStack represents a full path to an element of interest. It provides methods\n+    /// An OccupiedSearchStack represents a full path to an element of interest. It provides methods\n     /// for manipulating the element at the top of its stack.\n-    pub struct SearchStack<'a, K:'a, V:'a> {\n+    pub struct OccupiedSearchStack<'a, K:'a, V:'a> {\n+        map: &'a mut BTreeMap<K, V>,\n+        stack: Stack<K, V>,\n+        top: KVNodeHandle<*mut Node<K, V>>,\n+    }\n+\n+    /// A VacantSearchStack represents a full path to a spot for a new element of interest. It\n+    /// provides a method inserting an element at the top of its stack.\n+    pub struct VacantSearchStack<'a, K:'a, V:'a> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n-        top: StackItem<K, V>,\n+        top: EdgeNodeHandle<*mut Node<K, V>>,\n+    }\n+\n+    /// A `PartialSearchStack` that doesn't hold a a reference to the next node, and is just\n+    /// just waiting for a `Handle` to that next node to be pushed. See `PartialSearchStack::with`\n+    /// for more details.\n+    pub struct Pusher<'id, 'a, K:'a, V:'a> {\n+        map: &'a mut BTreeMap<K, V>,\n+        stack: Stack<K, V>,\n+        marker: marker::InvariantLifetime<'id>\n     }\n \n     /// The result of asking a PartialSearchStack to push another node onto itself. Either it\n     /// Grew, in which case it's still Partial, or it found its last node was actually a leaf, in\n     /// which case it seals itself and yields a complete SearchStack.\n     pub enum PushResult<'a, K:'a, V:'a> {\n         Grew(PartialSearchStack<'a, K, V>),\n-        Done(SearchStack<'a, K, V>),\n+        Done(VacantSearchStack<'a, K, V>),\n     }\n \n     impl<'a, K, V> PartialSearchStack<'a, K, V> {\n@@ -506,130 +569,92 @@ mod stack {\n             }\n         }\n \n+        /// Breaks up the stack into a `Pusher` and the next `Node`, allowing the given closure\n+        /// to interact with, search, and finally push the `Node` onto the stack. The passed in\n+        /// closure must be polymorphic on the `'id` lifetime parameter, as this statically\n+        /// ensures that only `Handle`s from the correct `Node` can be pushed.\n+        ///\n+        /// The reason this works is that the `Pusher` has an `'id` parameter, and will only accept\n+        /// handles with the same `'id`. The closure could only get references with that lifetime\n+        /// through its arguments or through some other `IdRef` that it has lying around. However,\n+        /// no other `IdRef` could possibly work - because the `'id` is held in an invariant\n+        /// parameter, it would need to have precisely the correct lifetime, which would mean that\n+        /// at least one of the calls to `with` wouldn't be properly polymorphic, wanting a\n+        /// specific lifetime instead of the one that `with` chooses to give it.\n+        ///\n+        /// See also Haskell's `ST` monad, which uses a similar trick.\n+        pub fn with<T, F: for<'id> FnOnce(Pusher<'id, 'a, K, V>,\n+                                          IdRef<'id, Node<K, V>>) -> T>(self, closure: F) -> T {\n+            let pusher = Pusher {\n+                map: self.map,\n+                stack: self.stack,\n+                marker: marker::InvariantLifetime\n+            };\n+            let node = IdRef {\n+                inner: unsafe { &mut *self.next },\n+                marker: marker::InvariantLifetime\n+            };\n+\n+            closure(pusher, node)\n+        }\n+    }\n+\n+    impl<'id, 'a, K, V> Pusher<'id, 'a, K, V> {\n         /// Pushes the requested child of the stack's current top on top of the stack. If the child\n-        /// exists, then a new PartialSearchStack is yielded. Otherwise, a full SearchStack is\n+        /// exists, then a new PartialSearchStack is yielded. Otherwise, a VacantSearchStack is\n         /// yielded.\n-        pub fn push(self, edge: uint) -> PushResult<'a, K, V> {\n-            let map = self.map;\n-            let mut stack = self.stack;\n-            let next_ptr = self.next;\n-            let next_node = unsafe {\n-                &mut *next_ptr\n-            };\n-            let to_insert = (next_ptr, edge);\n-            match next_node.edge_mut(edge) {\n-                None => Done(SearchStack {\n-                    map: map,\n-                    stack: stack,\n-                    top: to_insert,\n-                }),\n+        pub fn push(mut self, mut edge: EdgeNodeHandle<IdRef<'id, Node<K, V>>>)\n+                    -> PushResult<'a, K, V> {\n+            let to_insert = edge.as_raw();\n+            match edge.edge_mut() {\n+                None => {\n+                    Done(VacantSearchStack {\n+                        map: self.map,\n+                        stack: self.stack,\n+                        top: to_insert,\n+                    })\n+                },\n                 Some(node) => {\n-                    stack.push(to_insert);\n+                    self.stack.push(to_insert);\n                     Grew(PartialSearchStack {\n-                        map: map,\n-                        stack: stack,\n+                        map: self.map,\n+                        stack: self.stack,\n                         next: node as *mut _,\n                     })\n                 },\n             }\n         }\n \n-        /// Converts the stack into a mutable reference to its top.\n-        pub fn into_next(self) -> &'a mut Node<K, V> {\n-            unsafe {\n-                &mut *self.next\n-            }\n-        }\n-\n-        /// Gets the top of the stack.\n-        pub fn next(&self) -> &Node<K, V> {\n-            unsafe {\n-                &*self.next\n-            }\n-        }\n-\n-        /// Converts the PartialSearchStack into a SearchStack.\n-        pub fn seal(self, index: uint) -> SearchStack<'a, K, V> {\n-            SearchStack {\n+        /// Converts the PartialSearchStack into an OccupiedSearchStack.\n+        pub fn seal(self, mut node: KVNodeHandle<IdRef<'id, Node<K, V>>>)\n+                    -> OccupiedSearchStack<'a, K, V> {\n+            OccupiedSearchStack {\n                 map: self.map,\n                 stack: self.stack,\n-                top: (self.next as *mut _, index),\n+                top: node.as_raw(),\n             }\n         }\n     }\n \n-    impl<'a, K, V> SearchStack<'a, K, V> {\n+    impl<'a, K, V> OccupiedSearchStack<'a, K, V> {\n         /// Gets a reference to the value the stack points to.\n         pub fn peek(&self) -> &V {\n-            let (node_ptr, index) = self.top;\n-            unsafe {\n-                (*node_ptr).val(index).unwrap()\n-            }\n+            unsafe { self.top.from_raw().into_kv().1 }\n         }\n \n         /// Gets a mutable reference to the value the stack points to.\n         pub fn peek_mut(&mut self) -> &mut V {\n-            let (node_ptr, index) = self.top;\n-            unsafe {\n-                (*node_ptr).val_mut(index).unwrap()\n-            }\n+            unsafe { self.top.from_raw_mut().into_kv_mut().1 }\n         }\n \n         /// Converts the stack into a mutable reference to the value it points to, with a lifetime\n         /// tied to the original tree.\n-        pub fn into_top(self) -> &'a mut V {\n-            let (node_ptr, index) = self.top;\n+        pub fn into_top(mut self) -> &'a mut V {\n             unsafe {\n-                (*node_ptr).val_mut(index).unwrap()\n-            }\n-        }\n-\n-        /// Inserts the key and value into the top element in the stack, and if that node has to\n-        /// split recursively inserts the split contents into the next element stack until\n-        /// splits stop.\n-        ///\n-        /// Assumes that the stack represents a search path from the root to a leaf.\n-        ///\n-        /// An &mut V is returned to the inserted value, for callers that want a reference to this.\n-        pub fn insert(self, key: K, val: V) -> &'a mut V {\n-            unsafe {\n-                let map = self.map;\n-                map.length += 1;\n-\n-                let mut stack = self.stack;\n-                // Insert the key and value into the leaf at the top of the stack\n-                let (node, index) = self.top;\n-                let (mut insertion, inserted_ptr) = {\n-                    (*node).insert_as_leaf(index, key, val)\n-                };\n-\n-                loop {\n-                    match insertion {\n-                        Fit => {\n-                            // The last insertion went off without a hitch, no splits! We can stop\n-                            // inserting now.\n-                            return &mut *inserted_ptr;\n-                        }\n-                        Split(key, val, right) => match stack.pop() {\n-                            // The last insertion triggered a split, so get the next element on the\n-                            // stack to recursively insert the split node into.\n-                            None => {\n-                                // The stack was empty; we've split the root, and need to make a\n-                                // a new one. This is done in-place because we can't move the\n-                                // root out of a reference to the tree.\n-                                Node::make_internal_root(&mut map.root, map.b, key, val, right);\n-\n-                                map.depth += 1;\n-                                return &mut *inserted_ptr;\n-                            }\n-                            Some((node, index)) => {\n-                                // The stack wasn't empty, do the insertion and recurse\n-                                insertion = (*node).insert_as_internal(index, key, val, right);\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                }\n+                mem::copy_mut_lifetime(\n+                    self.map,\n+                    self.top.from_raw_mut().val_mut()\n+                )\n             }\n         }\n \n@@ -651,10 +676,8 @@ mod stack {\n             // Then, note if the leaf is underfull, and promptly forget the leaf and its ptr\n             // to avoid ownership issues.\n             let (value, mut underflow) = unsafe {\n-                let (leaf_ptr, index) = self.top;\n-                let leaf = &mut *leaf_ptr;\n-                let (_key, value) = leaf.remove_as_leaf(index);\n-                let underflow = leaf.is_underfull();\n+                let (_, value) = self.top.from_raw_mut().remove_as_leaf();\n+                let underflow = self.top.from_raw().node().is_underfull();\n                 (value, underflow)\n             };\n \n@@ -668,17 +691,16 @@ mod stack {\n                             // We've emptied out the root, so make its only child the new root.\n                             // If it's a leaf, we just let it become empty.\n                             map.depth -= 1;\n-                            map.root = map.root.pop_edge().unwrap();\n+                            map.root.into_edge();\n                         }\n                         return value;\n                     }\n-                    Some((parent_ptr, index)) => {\n+                    Some(mut handle) => {\n                         if underflow {\n                             // Underflow! Handle it!\n                             unsafe {\n-                                let parent = &mut *parent_ptr;\n-                                parent.handle_underflow(index);\n-                                underflow = parent.is_underfull();\n+                                handle.from_raw_mut().handle_underflow();\n+                                underflow = handle.from_raw().node().is_underfull();\n                             }\n                         } else {\n                             // All done!\n@@ -697,36 +719,87 @@ mod stack {\n         /// become swapped.\n         fn leafify(&mut self) {\n             unsafe {\n-                let (node_ptr, index) = self.top;\n-                // First, get ptrs to the found key-value pair\n-                let node = &mut *node_ptr;\n-                let (key_ptr, val_ptr) = {\n-                    (node.unsafe_key_mut(index) as *mut _,\n-                     node.unsafe_val_mut(index) as *mut _)\n-                };\n+                let mut top_raw = self.top;\n+                let mut top = top_raw.from_raw_mut();\n+\n+                let key_ptr = top.key_mut() as *mut _;\n+                let val_ptr = top.val_mut() as *mut _;\n \n                 // Try to go into the right subtree of the found key to find its successor\n-                match node.edge_mut(index + 1) {\n+                let mut right_edge = top.right_edge();\n+                let right_edge_raw = right_edge.as_raw();\n+                match right_edge.edge_mut() {\n                     None => {\n                         // We're a proper leaf stack, nothing to do\n                     }\n                     Some(mut temp_node) => {\n                         //We're not a proper leaf stack, let's get to work.\n-                        self.stack.push((node_ptr, index + 1));\n+                        self.stack.push(right_edge_raw);\n                         loop {\n                             // Walk into the smallest subtree of this node\n                             let node = temp_node;\n-                            let node_ptr = node as *mut _;\n \n                             if node.is_leaf() {\n                                 // This node is a leaf, do the swap and return\n-                                self.top = (node_ptr, 0);\n-                                node.unsafe_swap(0, &mut *key_ptr, &mut *val_ptr);\n+                                let mut handle = node.kv_handle(0);\n+                                self.top = handle.as_raw();\n+                                mem::swap(handle.key_mut(), &mut *key_ptr);\n+                                mem::swap(handle.val_mut(), &mut *val_ptr);\n                                 break;\n                             } else {\n                                 // This node is internal, go deeper\n-                                self.stack.push((node_ptr, 0));\n-                                temp_node = node.unsafe_edge_mut(0);\n+                                let mut handle = node.edge_handle(0);\n+                                self.stack.push(handle.as_raw());\n+                                temp_node = handle.into_edge_mut().unwrap();\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    impl<'a, K, V> VacantSearchStack<'a, K, V> {\n+        /// Inserts the key and value into the top element in the stack, and if that node has to\n+        /// split recursively inserts the split contents into the next element stack until\n+        /// splits stop.\n+        ///\n+        /// Assumes that the stack represents a search path from the root to a leaf.\n+        ///\n+        /// An &mut V is returned to the inserted value, for callers that want a reference to this.\n+        pub fn insert(mut self, key: K, val: V) -> &'a mut V {\n+            unsafe {\n+                self.map.length += 1;\n+\n+                // Insert the key and value into the leaf at the top of the stack\n+                let (mut insertion, inserted_ptr) = self.top.from_raw_mut()\n+                                                        .insert_as_leaf(key, val);\n+\n+                loop {\n+                    match insertion {\n+                        Fit => {\n+                            // The last insertion went off without a hitch, no splits! We can stop\n+                            // inserting now.\n+                            return &mut *inserted_ptr;\n+                        }\n+                        Split(key, val, right) => match self.stack.pop() {\n+                            // The last insertion triggered a split, so get the next element on the\n+                            // stack to recursively insert the split node into.\n+                            None => {\n+                                // The stack was empty; we've split the root, and need to make a\n+                                // a new one. This is done in-place because we can't move the\n+                                // root out of a reference to the tree.\n+                                Node::make_internal_root(&mut self.map.root, self.map.b,\n+                                                         key, val, right);\n+\n+                                self.map.depth += 1;\n+                                return &mut *inserted_ptr;\n+                            }\n+                            Some(mut handle) => {\n+                                // The stack wasn't empty, do the insertion and recurse\n+                                insertion = handle.from_raw_mut()\n+                                                  .insert_as_internal(key, val, right);\n+                                continue;\n                             }\n                         }\n                     }\n@@ -1156,31 +1229,40 @@ impl<K, V> BTreeMap<K, V> {\n \n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V> {\n+    pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n         // same basic logic of `swap` and `pop`, blended together\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n-            match stack.next().search(&key) {\n-                Found(i) => {\n-                    // Perfect match\n-                    return Occupied(OccupiedEntry {\n-                        stack: stack.seal(i)\n-                    });\n-                },\n-                GoDown(i) => {\n-                    stack = match stack.push(i) {\n-                        stack::Done(new_stack) => {\n-                            // Not in the tree, but we've found where it goes\n-                            return Vacant(VacantEntry {\n-                                stack: new_stack,\n-                                key: key,\n-                            });\n-                        }\n-                        stack::Grew(new_stack) => {\n-                            // We've found the subtree this key must go in\n-                            new_stack\n-                        }\n-                    };\n+            let result = stack.with(move |pusher, node| {\n+                match Node::search(node, &key) {\n+                    Found(handle) => {\n+                        // Perfect match\n+                        return Finished(Occupied(OccupiedEntry {\n+                            stack: pusher.seal(handle)\n+                        }));\n+                    },\n+                    GoDown(handle) => {\n+                        match pusher.push(handle) {\n+                            stack::Done(new_stack) => {\n+                                // Not in the tree, but we've found where it goes\n+                                return Finished(Vacant(VacantEntry {\n+                                    stack: new_stack,\n+                                    key: key,\n+                                }));\n+                            }\n+                            stack::Grew(new_stack) => {\n+                                // We've found the subtree this key must go in\n+                                return Continue((new_stack, key));\n+                            }\n+                        };\n+                    }\n+                }\n+            });\n+            match result {\n+                Finished(finished) => return finished,\n+                Continue((new_stack, renewed_key)) => {\n+                    stack = new_stack;\n+                    key = renewed_key;\n                 }\n             }\n         }"}, {"sha": "ae23f38c92913ef1e6a378cdb72de863f86da5c8", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1199, "deletions": 300, "changes": 1499, "blob_url": "https://github.com/rust-lang/rust/blob/a5921241a3146cccaffc336a0d1ade1a90e3517f/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5921241a3146cccaffc336a0d1ade1a90e3517f/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=a5921241a3146cccaffc336a0d1ade1a90e3517f", "patch": "@@ -17,12 +17,11 @@ pub use self::TraversalItem::*;\n \n use core::prelude::*;\n \n-use core::{slice, mem, ptr};\n+use core::{slice, mem, ptr, cmp, num, raw};\n+use core::kinds::marker;\n use core::iter::Zip;\n use core::borrow::BorrowFrom;\n-\n-use vec;\n-use vec::Vec;\n+use alloc::heap;\n \n /// Represents the result of an Insertion: either the item fit, or the node had to split\n pub enum InsertionResult<K, V> {\n@@ -33,86 +32,516 @@ pub enum InsertionResult<K, V> {\n }\n \n /// Represents the result of a search for a key in a single node\n-pub enum SearchResult {\n+pub enum SearchResult<NodeRef> {\n     /// The element was found at the given index\n-    Found(uint),\n+    Found(KVNodeHandle<NodeRef>),\n     /// The element wasn't found, but if it's anywhere, it must be beyond this edge\n-    GoDown(uint),\n+    GoDown(EdgeNodeHandle<NodeRef>),\n }\n \n /// A B-Tree Node. We keep keys/edges/values separate to optimize searching for keys.\n-#[deriving(Clone)]\n+#[unsafe_no_drop_flag]\n pub struct Node<K, V> {\n-    // FIXME(Gankro): This representation is super safe and easy to reason about, but painfully\n-    // inefficient. As three Vecs, each node consists of *9* words: (ptr, cap, size) * 3. In\n-    // theory, if we take full control of allocation like HashMap's RawTable does,\n-    // and restrict leaves to max size 256 (not unreasonable for a btree node) we can cut\n-    // this down to just (ptr, cap: u8, size: u8, is_leaf: bool). With generic\n-    // integer arguments, cap can even move into the type, reducing this just to\n-    // (ptr, size, is_leaf). This could also have cache benefits for very small nodes, as keys\n-    // could bleed into edges and vals.\n+    // To avoid the need for multiple allocations, we allocate a single buffer with enough space\n+    // for `capacity` keys, `capacity` values, and (in internal nodes) `capacity + 1` edges.\n+    // Despite this, we store three separate pointers to the three \"chunks\" of the buffer because\n+    // the performance drops significantly if the locations of the vals and edges need to be\n+    // recalculated upon access.\n     //\n-    // However doing this would require a fair amount of code to reimplement all\n-    // the Vec logic and iterators. It would also use *way* more unsafe code, which sucks and is\n-    // hard. For now, we accept this cost in the name of correctness and simplicity.\n+    // These will never be null during normal usage of a `Node`. However, to avoid the need for a\n+    // drop flag, `Node::drop` zeroes `keys`, signaling that the `Node` has already been cleaned\n+    // up.\n+    keys: *mut K,\n+    vals: *mut V,\n+\n+    // In leaf nodes, this will be null, and no space will be allocated for edges.\n+    edges: *mut Node<K, V>,\n+\n+    // At any given time, there will be `_len` keys, `_len` values, and (in an internal node)\n+    // `_len + 1` edges. In a leaf node, there will never be any edges.\n     //\n-    // As a compromise, keys and vals could be merged into one Vec<(K, V)>, which would shave\n-    // off 3 words, but possibly hurt our cache efficiency during search, which only cares about\n-    // keys. This would also avoid the Zip we use in our iterator implementations. This is\n-    // probably worth investigating.\n+    // Note: instead of accessing this field directly, please call the `len()` method, which should\n+    // be more stable in the face of representation changes.\n+    _len: uint,\n+\n+    // FIXME(gereeter) It shouldn't be necessary to store the capacity in every node, as it should\n+    // be constant throughout the tree. Once a solution to this is found, it might be possible to\n+    // also pass down the offsets into the buffer that vals and edges are stored at, removing the\n+    // need for those two pointers.\n     //\n-    // Note that this space waste is especially tragic since we store the Nodes by value in their\n-    // parent's edges Vec, so unoccupied spaces in the edges Vec are quite large, and we have\n-    // to shift around a lot more bits during insertion/removal.\n+    // Note: instead of accessing this field directly, please call the `capacity()` method, which\n+    // should be more stable in the face of representation changes.\n+    _capacity: uint,\n+}\n+\n+/// Rounds up to a multiple of a power of two. Returns the closest multiple\n+/// of `target_alignment` that is higher or equal to `unrounded`.\n+///\n+/// # Panics\n+///\n+/// Fails if `target_alignment` is not a power of two.\n+#[inline]\n+fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint {\n+    assert!(num::UnsignedInt::is_power_of_two(target_alignment));\n+    (unrounded + target_alignment - 1) & !(target_alignment - 1)\n+}\n+\n+#[test]\n+fn test_rounding() {\n+    assert_eq!(round_up_to_next(0, 4), 0);\n+    assert_eq!(round_up_to_next(1, 4), 4);\n+    assert_eq!(round_up_to_next(2, 4), 4);\n+    assert_eq!(round_up_to_next(3, 4), 4);\n+    assert_eq!(round_up_to_next(4, 4), 4);\n+    assert_eq!(round_up_to_next(5, 4), 8);\n+}\n+\n+// Returns a tuple of (val_offset, edge_offset),\n+// from the start of a mallocated array.\n+#[inline]\n+fn calculate_offsets(keys_size: uint,\n+                     vals_size: uint, vals_align: uint,\n+                     edges_align: uint)\n+                     -> (uint, uint) {\n+    let vals_offset = round_up_to_next(keys_size, vals_align);\n+    let end_of_vals = vals_offset + vals_size;\n+\n+    let edges_offset = round_up_to_next(end_of_vals, edges_align);\n+\n+    (vals_offset, edges_offset)\n+}\n+\n+// Returns a tuple of (minimum required alignment, array_size),\n+// from the start of a mallocated array.\n+#[inline]\n+fn calculate_allocation(keys_size: uint, keys_align: uint,\n+                        vals_size: uint, vals_align: uint,\n+                        edges_size: uint, edges_align: uint)\n+                        -> (uint, uint) {\n+    let (_, edges_offset) = calculate_offsets(keys_size,\n+                                              vals_size, vals_align,\n+                                                         edges_align);\n+    let end_of_edges = edges_offset + edges_size;\n+\n+    let min_align = cmp::max(keys_align, cmp::max(vals_align, edges_align));\n+\n+    (min_align, end_of_edges)\n+}\n+\n+#[test]\n+fn test_offset_calculation() {\n+    assert_eq!(calculate_allocation(128, 8, 15, 1, 4, 4), (8, 148));\n+    assert_eq!(calculate_allocation(3, 1, 2, 1, 1, 1), (1, 6));\n+    assert_eq!(calculate_allocation(6, 2, 12, 4, 24, 8), (8, 48));\n+    assert_eq!(calculate_offsets(128, 15, 1, 4), (128, 144));\n+    assert_eq!(calculate_offsets(3, 2, 1, 1), (3, 5));\n+    assert_eq!(calculate_offsets(6, 12, 4, 8), (8, 24));\n+}\n+\n+fn calculate_allocation_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, uint) {\n+    let (keys_size, keys_align) = (capacity * mem::size_of::<K>(), mem::min_align_of::<K>());\n+    let (vals_size, vals_align) = (capacity * mem::size_of::<V>(), mem::min_align_of::<V>());\n+    let (edges_size, edges_align) = if is_leaf {\n+        (0, 1)\n+    } else {\n+        ((capacity + 1) * mem::size_of::<Node<K, V>>(), mem::min_align_of::<Node<K, V>>())\n+    };\n+\n+    calculate_allocation(\n+            keys_size, keys_align,\n+            vals_size, vals_align,\n+            edges_size, edges_align\n+    )\n+}\n+\n+fn calculate_offsets_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, uint) {\n+    let keys_size = capacity * mem::size_of::<K>();\n+    let vals_size = capacity * mem::size_of::<V>();\n+    let vals_align = mem::min_align_of::<V>();\n+    let edges_align = if is_leaf {\n+        1\n+    } else {\n+        mem::min_align_of::<Node<K, V>>()\n+    };\n+\n+    calculate_offsets(\n+            keys_size,\n+            vals_size, vals_align,\n+                       edges_align\n+    )\n+}\n+\n+/// An iterator over a slice that owns the elements of the slice but not the allocation.\n+struct RawItems<T> {\n+    head: *const T,\n+    tail: *const T,\n+    marker: marker::NoCopy\n+}\n+\n+impl<T> RawItems<T> {\n+    unsafe fn from_slice(slice: &[T]) -> RawItems<T> {\n+        RawItems::from_parts(slice.as_ptr(), slice.len())\n+    }\n+\n+    unsafe fn from_parts(ptr: *const T, len: uint) -> RawItems<T> {\n+        if mem::size_of::<T>() == 0 {\n+            RawItems {\n+                head: ptr,\n+                tail: (ptr as uint + len) as *const T,\n+                marker: marker::NoCopy\n+            }\n+        } else {\n+            RawItems {\n+                head: ptr,\n+                tail: ptr.offset(len as int),\n+                marker: marker::NoCopy\n+            }\n+        }\n+    }\n+\n+    unsafe fn push(&mut self, val: T) {\n+        ptr::write(self.tail as *mut T, val);\n+\n+        if mem::size_of::<T>() == 0 {\n+            self.tail = (self.tail as uint + 1) as *const T;\n+        } else {\n+            self.tail = self.tail.offset(1);\n+        }\n+    }\n+}\n+\n+impl<T> Iterator<T> for RawItems<T> {\n+    fn next(&mut self) -> Option<T> {\n+        if self.head == self.tail {\n+            None\n+        } else {\n+            unsafe {\n+                let ret = Some(ptr::read(self.head));\n+\n+                if mem::size_of::<T>() == 0 {\n+                    self.head = (self.head as uint + 1) as *const T;\n+                } else {\n+                    self.head = self.head.offset(1);\n+                }\n+\n+                ret\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> DoubleEndedIterator<T> for RawItems<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        if self.head == self.tail {\n+            None\n+        } else {\n+            unsafe {\n+                if mem::size_of::<T>() == 0 {\n+                    self.tail = (self.tail as uint - 1) as *const T;\n+                } else {\n+                    self.tail = self.tail.offset(-1);\n+                }\n+\n+                Some(ptr::read(self.tail))\n+            }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for RawItems<T> {\n+    fn drop(&mut self) {\n+        for _ in *self {}\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<K, V> Drop for Node<K, V> {\n+    fn drop(&mut self) {\n+        if self.keys.is_null() {\n+            // We have already cleaned up this node.\n+            return;\n+        }\n+\n+        // Do the actual cleanup.\n+        unsafe {\n+            drop(RawItems::from_slice(self.keys()));\n+            drop(RawItems::from_slice(self.vals()));\n+            drop(RawItems::from_slice(self.edges()));\n+\n+            self.destroy();\n+        }\n+\n+        self.keys = ptr::null_mut();\n+    }\n+}\n+\n+impl<K, V> Node<K, V> {\n+    /// Make a new internal node. The caller must initialize the result to fix the invariant that\n+    /// there are `len() + 1` edges.\n+    unsafe fn new_internal(capacity: uint) -> Node<K, V> {\n+        let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, false);\n+\n+        let buffer = heap::allocate(size, alignment);\n+        if buffer.is_null() { ::alloc::oom(); }\n+\n+        let (vals_offset, edges_offset) = calculate_offsets_generic::<K, V>(capacity, false);\n+\n+        Node {\n+            keys: buffer as *mut K,\n+            vals: buffer.offset(vals_offset as int) as *mut V,\n+            edges: buffer.offset(edges_offset as int) as *mut Node<K, V>,\n+            _len: 0,\n+            _capacity: capacity,\n+        }\n+    }\n+\n+    /// Make a new leaf node\n+    fn new_leaf(capacity: uint) -> Node<K, V> {\n+        let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, true);\n+\n+        let buffer = unsafe { heap::allocate(size, alignment) };\n+        if buffer.is_null() { ::alloc::oom(); }\n+\n+        let (vals_offset, _) = calculate_offsets_generic::<K, V>(capacity, true);\n+\n+        Node {\n+            keys: buffer as *mut K,\n+            vals: unsafe { buffer.offset(vals_offset as int) as *mut V },\n+            edges: ptr::null_mut(),\n+            _len: 0,\n+            _capacity: capacity,\n+        }\n+    }\n+\n+    unsafe fn destroy(&mut self) {\n+        let (alignment, size) =\n+                calculate_allocation_generic::<K, V>(self.capacity(), self.is_leaf());\n+        heap::deallocate(self.keys as *mut u8, size, alignment);\n+    }\n+\n+    #[inline]\n+    pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) {\n+        unsafe {(\n+            mem::transmute(raw::Slice {\n+                data: self.keys as *const K,\n+                len: self.len()\n+            }),\n+            mem::transmute(raw::Slice {\n+                data: self.vals as *const V,\n+                len: self.len()\n+            })\n+        )}\n+    }\n+\n+    #[inline]\n+    pub fn as_slices_mut<'a>(&'a mut self) -> (&'a mut [K], &'a mut [V]) {\n+        unsafe { mem::transmute(self.as_slices()) }\n+    }\n+\n+    #[inline]\n+    pub fn as_slices_internal<'a>(&'a self) -> (&'a [K], &'a [V], &'a [Node<K, V>]) {\n+        let (keys, vals) = self.as_slices();\n+        let edges: &[_] = if self.is_leaf() {\n+            &[]\n+        } else {\n+            unsafe {\n+                mem::transmute(raw::Slice {\n+                    data: self.edges as *const Node<K, V>,\n+                    len: self.len() + 1\n+                })\n+            }\n+        };\n+        (keys, vals, edges)\n+    }\n+\n+    #[inline]\n+    pub fn as_slices_internal_mut<'a>(&'a mut self) -> (&'a mut [K], &'a mut [V],\n+                                                        &'a mut [Node<K, V>]) {\n+        unsafe { mem::transmute(self.as_slices_internal()) }\n+    }\n \n-    keys: Vec<K>,\n-    edges: Vec<Node<K, V>>,\n-    vals: Vec<V>,\n+    #[inline]\n+    pub fn keys<'a>(&'a self) -> &'a [K] {\n+        self.as_slices().0\n+    }\n+\n+    #[inline]\n+    pub fn keys_mut<'a>(&'a mut self) -> &'a mut [K] {\n+        self.as_slices_mut().0\n+    }\n+\n+    #[inline]\n+    pub fn vals<'a>(&'a self) -> &'a [V] {\n+        self.as_slices().1\n+    }\n+\n+    #[inline]\n+    pub fn vals_mut<'a>(&'a mut self) -> &'a mut [V] {\n+        self.as_slices_mut().1\n+    }\n+\n+    #[inline]\n+    pub fn edges<'a>(&'a self) -> &'a [Node<K, V>] {\n+        self.as_slices_internal().2\n+    }\n+\n+    #[inline]\n+    pub fn edges_mut<'a>(&'a mut self) -> &'a mut [Node<K, V>] {\n+        self.as_slices_internal_mut().2\n+    }\n+}\n+\n+// FIXME(gereeter) Write an efficient clone_from\n+impl<K: Clone, V: Clone> Clone for Node<K, V> {\n+    fn clone(&self) -> Node<K, V> {\n+        let mut ret = if self.is_leaf() {\n+            Node::new_leaf(self.capacity())\n+        } else {\n+            unsafe { Node::new_internal(self.capacity()) }\n+        };\n+\n+        unsafe {\n+            // For failure safety\n+            let mut keys = RawItems::from_parts(ret.keys().as_ptr(), 0);\n+            let mut vals = RawItems::from_parts(ret.vals().as_ptr(), 0);\n+            let mut edges = RawItems::from_parts(ret.edges().as_ptr(), 0);\n+\n+            for key in self.keys().iter() {\n+                keys.push(key.clone())\n+            }\n+            for val in self.vals().iter() {\n+                vals.push(val.clone())\n+            }\n+            for edge in self.edges().iter() {\n+                edges.push(edge.clone())\n+            }\n+\n+            mem::forget(keys);\n+            mem::forget(vals);\n+            mem::forget(edges);\n+\n+            ret._len = self.len();\n+        }\n+\n+        ret\n+    }\n+}\n+\n+/// A reference to a key/value pair in the middle of a `Node`. Methods are provided for removing\n+/// the pair and accessing the pair and the adjacent edges.\n+///\n+/// This handle is generic, and can take any sort of reference to a `Node`. The reason for this is\n+/// two-fold. First of all, it reduces the amount of repetitive code, implementing functions that\n+/// don't need mutability on both mutable and immutable references. Secondly and more importantly,\n+/// this allows users of the `Handle` API to associate metadata with the reference. This is used in\n+/// `BTreeMap` to give `Node`s temporary \"IDs\" that persist to when the `Node` is used in a\n+/// `Handle`.\n+///\n+/// # A note on safety\n+///\n+/// Unfortunately, the extra power afforded by being generic also means that safety can technically\n+/// be broken. For sensible implementations of `Deref` and `DerefMut`, these handles are perfectly\n+/// safe. As long as repeatedly calling `.deref()` results in the same Node being returned each\n+/// time, everything should work fine. However, if the `Deref` implementation swaps in multiple\n+/// different nodes, then the indices that are assumed to be in bounds suddenly stop being so. For\n+/// example:\n+///\n+/// ```rust,ignore\n+/// struct Nasty<'a> {\n+///     first: &'a Node<uint, uint>,\n+///     second: &'a Node<uint, uint>,\n+///     flag: &'a Cell<bool>,\n+/// }\n+///\n+/// impl<'a> Deref<Node<uint, uint>> for Nasty<'a> {\n+///     fn deref(&self) -> &Node<uint, uint> {\n+///         if self.flag.get() {\n+///             &*self.second\n+///         } else {\n+///             &*self.first\n+///         }\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let flag = Cell::new(false);\n+///     let mut small_node = Node::make_leaf_root(3);\n+///     let mut large_node = Node::make_leaf_root(100);\n+///\n+///     for i in range(0, 100) {\n+///         // Insert to the end\n+///         large_node.edge_handle(i).insert_as_leaf(i, i);\n+///     }\n+///\n+///     let nasty = Nasty {\n+///         first: &large_node,\n+///         second: &small_node,\n+///         flag: &flag\n+///     }\n+///\n+///     // The handle points at index 75.\n+///     let handle = Node::search(nasty, 75);\n+///\n+///     // Now the handle still points at index 75, but on the small node, which has no index 75.\n+///     flag.set(true);\n+///\n+///     println!(\"Uninitialized memory: {}\", handle.into_kv());\n+/// }\n+/// ```\n+#[deriving(Copy)]\n+pub struct KVNodeHandle<NodeRef> {\n+    node: NodeRef,\n+    index: uint\n+}\n+\n+/// A reference to an edge in the middle of a `Node`. Methods are provided for inserting stuff into\n+/// the space, handling underflow, and accessing the pointed-to edge.\n+///\n+/// Please see the notes on `KVNodeHandle` about the generic parameter and safety concerns.\n+#[deriving(Copy)]\n+pub struct EdgeNodeHandle<NodeRef> {\n+    node: NodeRef,\n+    index: uint\n }\n \n impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search<Sized? Q>(&self, key: &Q) -> SearchResult where Q: BorrowFrom<K> + Ord {\n+    pub fn search<Sized? Q, NodeRef: Deref<Node<K, V>>>(node: NodeRef, key: &Q)\n+                  -> SearchResult<NodeRef> where Q: BorrowFrom<K> + Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for uints.\n-        self.search_linear(key)\n+        let (found, index) = node.search_linear(key);\n+        if found {\n+            Found(KVNodeHandle {\n+                node: node,\n+                index: index\n+            })\n+        } else {\n+            GoDown(EdgeNodeHandle {\n+                node: node,\n+                index: index\n+            })\n+        }\n     }\n \n-    fn search_linear<Sized? Q>(&self, key: &Q) -> SearchResult where Q: BorrowFrom<K> + Ord {\n-        for (i, k) in self.keys.iter().enumerate() {\n+    fn search_linear<Sized? Q>(&self, key: &Q) -> (bool, uint) where Q: BorrowFrom<K> + Ord {\n+        for (i, k) in self.keys().iter().enumerate() {\n             match key.cmp(BorrowFrom::borrow_from(k)) {\n                 Greater => {},\n-                Equal => return Found(i),\n-                Less => return GoDown(i),\n+                Equal => return (true, i),\n+                Less => return (false, i),\n             }\n         }\n-        GoDown(self.len())\n+        (false, self.len())\n     }\n }\n \n // Public interface\n impl <K, V> Node<K, V> {\n-    /// Make a new internal node\n-    pub fn new_internal(capacity: uint) -> Node<K, V> {\n-        Node {\n-            keys: Vec::with_capacity(capacity),\n-            vals: Vec::with_capacity(capacity),\n-            edges: Vec::with_capacity(capacity + 1),\n-        }\n-    }\n-\n-    /// Make a new leaf node\n-    pub fn new_leaf(capacity: uint) -> Node<K, V> {\n-        Node {\n-            keys: Vec::with_capacity(capacity),\n-            vals: Vec::with_capacity(capacity),\n-            edges: Vec::new(),\n-        }\n-    }\n-\n     /// Make a leaf root from scratch\n     pub fn make_leaf_root(b: uint) -> Node<K, V> {\n         Node::new_leaf(capacity_from_b(b))\n@@ -121,28 +550,29 @@ impl <K, V> Node<K, V> {\n     /// Make an internal root and swap it with an old root\n     pub fn make_internal_root(left_and_out: &mut Node<K,V>, b: uint, key: K, value: V,\n             right: Node<K,V>) {\n-        let mut node = Node::new_internal(capacity_from_b(b));\n-        mem::swap(left_and_out, &mut node);\n-        left_and_out.keys.push(key);\n-        left_and_out.vals.push(value);\n-        left_and_out.edges.push(node);\n-        left_and_out.edges.push(right);\n+        let node = mem::replace(left_and_out, unsafe { Node::new_internal(capacity_from_b(b)) });\n+        left_and_out._len = 1;\n+        unsafe {\n+            ptr::write(left_and_out.keys_mut().unsafe_mut(0), key);\n+            ptr::write(left_and_out.vals_mut().unsafe_mut(0), value);\n+            ptr::write(left_and_out.edges_mut().unsafe_mut(0), node);\n+            ptr::write(left_and_out.edges_mut().unsafe_mut(1), right);\n+        }\n     }\n \n-\n     /// How many key-value pairs the node contains\n     pub fn len(&self) -> uint {\n-        self.keys.len()\n+        self._len\n     }\n \n     /// How many key-value pairs the node can fit\n     pub fn capacity(&self) -> uint {\n-        self.keys.capacity()\n+        self._capacity\n     }\n \n     /// If the node has any children\n     pub fn is_leaf(&self) -> bool {\n-        self.edges.is_empty()\n+        self.edges.is_null()\n     }\n \n     /// if the node has too few elements\n@@ -154,336 +584,725 @@ impl <K, V> Node<K, V> {\n     pub fn is_full(&self) -> bool {\n         self.len() == self.capacity()\n     }\n+}\n \n-    /// Swap the given key-value pair with the key-value pair stored in the node's index,\n-    /// without checking bounds.\n-    pub unsafe fn unsafe_swap(&mut self, index: uint, key: &mut K, val: &mut V) {\n-        mem::swap(self.keys.unsafe_mut(index), key);\n-        mem::swap(self.vals.unsafe_mut(index), val);\n-    }\n-\n-    /// Get the node's key mutably without any bounds checks.\n-    pub unsafe fn unsafe_key_mut(&mut self, index: uint) -> &mut K {\n-        self.keys.unsafe_mut(index)\n-    }\n-\n-    /// Get the node's value at the given index\n-    pub fn val(&self, index: uint) -> Option<&V> {\n-        self.vals.get(index)\n-    }\n-\n-    /// Get the node's value at the given index\n-    pub fn val_mut(&mut self, index: uint) -> Option<&mut V> {\n-        self.vals.get_mut(index)\n-    }\n-\n-    /// Get the node's value mutably without any bounds checks.\n-    pub unsafe fn unsafe_val_mut(&mut self, index: uint) -> &mut V {\n-        self.vals.unsafe_mut(index)\n+impl<'a, K: 'a, V: 'a> EdgeNodeHandle<&'a Node<K, V>> {\n+    /// Turns the handle into a reference to the edge it points at. This is necessary because the\n+    /// returned pointer has a larger lifetime than what would be returned by `edge` or `edge_mut`,\n+    /// making it more suitable for moving down a chain of nodes.\n+    ///\n+    /// Returns `None` if called on an edge in a leaf node.\n+    pub fn into_edge(self) -> Option<&'a Node<K, V>> {\n+        if self.node.is_leaf() {\n+            None\n+        } else {\n+            unsafe {\n+                Some(self.node.edges().unsafe_get(self.index))\n+            }\n+        }\n     }\n+}\n \n-    /// Get the node's edge at the given index\n-    pub fn edge(&self, index: uint) -> Option<&Node<K,V>> {\n-        self.edges.get(index)\n+impl<'a, K: 'a, V: 'a> EdgeNodeHandle<&'a mut Node<K, V>> {\n+    /// Turns the handle into a mutable reference to the edge it points at. This is necessary\n+    /// because the returned pointer has a larger lifetime than what would be returned by\n+    /// `edge_mut`, making it more suitable for moving down a chain of nodes.\n+    ///\n+    /// Returns `None` if called on an edge in a leaf node.\n+    pub fn into_edge_mut(self) -> Option<&'a mut Node<K, V>> {\n+        if self.node.is_leaf() {\n+            None\n+        } else {\n+            unsafe {\n+                Some(self.node.edges_mut().unsafe_mut(self.index))\n+            }\n+        }\n     }\n+}\n \n-    /// Get the node's edge mutably at the given index\n-    pub fn edge_mut(&mut self, index: uint) -> Option<&mut Node<K,V>> {\n-        self.edges.get_mut(index)\n+impl<K, V, NodeRef: Deref<Node<K, V>>> EdgeNodeHandle<NodeRef> {\n+    /// Returns a reference to the node that contains the pointed-to edge. This is very different\n+    /// from `edge` and `edge_mut` because those return children of the node returned by `node`.\n+    pub fn node(&self) -> &Node<K, V> {\n+        &*self.node\n     }\n \n-    /// Get the node's edge mutably without any bounds checks.\n-    pub unsafe fn unsafe_edge_mut(&mut self, index: uint) -> &mut Node<K,V> {\n-        self.edges.unsafe_mut(index)\n-    }\n+    // This doesn't exist because there are no uses for it,\n+    // but is fine to add, analagous to edge_mut.\n+    //\n+    // /// Returns a reference to the edge pointed-to by this handle. This should not be\n+    // /// confused with `node`, which references the parent node of what is returned here.\n+    // ///\n+    // /// Returns `None` when called on an edge in a leaf node.\n+    // pub fn edge(&self) -> Option<&Node<K, V>>\n+}\n \n-    /// Pop an edge off the end of the node\n-    pub fn pop_edge(&mut self) -> Option<Node<K,V>> {\n-        self.edges.pop()\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> EdgeNodeHandle<NodeRef> {\n+    /// Returns a mutable reference to the edge pointed-to by this handle. This should not be\n+    /// confused with `node`, which references the parent node of what is returned here.\n+    ///\n+    /// Returns `None` when called on an edge in a leaf node.\n+    pub fn edge_mut(&mut self) -> Option<&mut Node<K, V>> {\n+        if self.node.is_leaf() {\n+            None\n+        } else {\n+            unsafe { Some(self.node.edges_mut().unsafe_mut(self.index)) }\n+        }\n     }\n \n-    /// Try to insert this key-value pair at the given index in this internal node\n+    /// Tries to insert this key-value pair at the given index in this leaf node\n     /// If the node is full, we have to split it.\n     ///\n     /// Returns a *mut V to the inserted value, because the caller may want this when\n     /// they're done mutating the tree, but we don't want to borrow anything for now.\n-    pub fn insert_as_leaf(&mut self, index: uint, key: K, value: V) ->\n+    pub fn insert_as_leaf(mut self, key: K, value: V) ->\n             (InsertionResult<K, V>, *mut V) {\n-        if !self.is_full() {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(self.node.is_leaf(),\n+                      \"insert_as_leaf must only be called on leaf nodes\");\n+\n+        if !self.node.is_full() {\n             // The element can fit, just insert it\n-            self.insert_fit_as_leaf(index, key, value);\n-            (Fit, unsafe { self.unsafe_val_mut(index) as *mut _ })\n+            (Fit, unsafe { self.node.insert_kv(self.index, key, value) as *mut _ })\n         } else {\n             // The element can't fit, this node is full. Split it into two nodes.\n-            let (new_key, new_val, mut new_right) = self.split();\n-            let left_len = self.len();\n-\n-            let ptr = if index <= left_len {\n-                self.insert_fit_as_leaf(index, key, value);\n-                unsafe { self.unsafe_val_mut(index) as *mut _ }\n-            } else {\n-                new_right.insert_fit_as_leaf(index - left_len - 1, key, value);\n-                unsafe { new_right.unsafe_val_mut(index - left_len - 1) as *mut _ }\n-            };\n+            let (new_key, new_val, mut new_right) = self.node.split();\n+            let left_len = self.node.len();\n+\n+            let ptr = unsafe {\n+                if self.index <= left_len {\n+                    self.node.insert_kv(self.index, key, value)\n+                } else {\n+                    // We need to subtract 1 because in splitting we took out new_key and new_val.\n+                    // Just being in the right node means we are past left_len k/v pairs in the\n+                    // left node and 1 k/v pair in the parent node.\n+                    new_right.insert_kv(self.index - left_len - 1, key, value)\n+                }\n+            } as *mut _;\n \n             (Split(new_key, new_val, new_right), ptr)\n         }\n     }\n \n-    /// Try to insert this key-value pair at the given index in this internal node\n+    /// Tries to insert this key-value pair at the given index in this internal node\n     /// If the node is full, we have to split it.\n-    pub fn insert_as_internal(&mut self, index: uint, key: K, value: V, right: Node<K, V>)\n+    pub fn insert_as_internal(mut self, key: K, value: V, right: Node<K, V>)\n             -> InsertionResult<K, V> {\n-        if !self.is_full() {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(!self.node.is_leaf(),\n+                      \"insert_as_internal must only be called on internal nodes\");\n+\n+        if !self.node.is_full() {\n             // The element can fit, just insert it\n-            self.insert_fit_as_internal(index, key, value, right);\n+            unsafe {\n+                self.node.insert_kv(self.index, key, value);\n+                self.node.insert_edge(self.index + 1, right); // +1 to insert to the right\n+            }\n             Fit\n         } else {\n             // The element can't fit, this node is full. Split it into two nodes.\n-            let (new_key, new_val, mut new_right) = self.split();\n-            let left_len = self.len();\n-\n-            if index <= left_len {\n-                self.insert_fit_as_internal(index, key, value, right);\n+            let (new_key, new_val, mut new_right) = self.node.split();\n+            let left_len = self.node.len();\n+\n+            if self.index <= left_len {\n+                unsafe {\n+                    self.node.insert_kv(self.index, key, value);\n+                    self.node.insert_edge(self.index + 1, right); // +1 to insert to the right\n+                }\n             } else {\n-                new_right.insert_fit_as_internal(index - left_len - 1, key, value, right);\n+                unsafe {\n+                    // The -1 here is for the same reason as in insert_as_internal - because we\n+                    // split, there are actually left_len + 1 k/v pairs before the right node, with\n+                    // the extra 1 being put in the parent.\n+                    new_right.insert_kv(self.index - left_len - 1, key, value);\n+                    new_right.insert_edge(self.index - left_len, right);\n+                }\n             }\n \n             Split(new_key, new_val, new_right)\n         }\n     }\n \n-    /// Remove the key-value pair at the given index\n-    pub fn remove_as_leaf(&mut self, index: uint) -> (K, V) {\n-        match (self.keys.remove(index), self.vals.remove(index)) {\n-            (Some(k), Some(v)) => (k, v),\n-            _ => unreachable!(),\n-        }\n-    }\n-\n     /// Handle an underflow in this node's child. We favour handling \"to the left\" because we know\n     /// we're empty, but our neighbour can be full. Handling to the left means when we choose to\n     /// steal, we pop off the end of our neighbour (always fast) and \"unshift\" ourselves\n     /// (always slow, but at least faster since we know we're half-empty).\n     /// Handling \"to the right\" reverses these roles. Of course, we merge whenever possible\n     /// because we want dense nodes, and merging is about equal work regardless of direction.\n-    pub fn handle_underflow(&mut self, underflowed_child_index: uint) {\n-        assert!(underflowed_child_index <= self.len());\n+    pub fn handle_underflow(mut self) {\n         unsafe {\n-            if underflowed_child_index > 0 {\n-                self.handle_underflow_to_left(underflowed_child_index);\n+            if self.index > 0 {\n+                self.handle_underflow_to_left();\n             } else {\n-                self.handle_underflow_to_right(underflowed_child_index);\n+                self.handle_underflow_to_right();\n             }\n         }\n     }\n \n-    pub fn iter<'a>(&'a self) -> Traversal<'a, K, V> {\n-        let is_leaf = self.is_leaf();\n-        Traversal {\n-            elems: self.keys.iter().zip(self.vals.iter()),\n-            edges: self.edges.iter(),\n-            head_is_edge: true,\n-            tail_is_edge: true,\n-            has_edges: !is_leaf,\n+    /// Gets the handle pointing to the key/value pair just to the left of the pointed-to edge.\n+    /// This is unsafe because the handle might point to the first edge in the node, which has no\n+    /// pair to its left.\n+    unsafe fn left_kv<'a>(&'a mut self) -> KVNodeHandle<&'a mut Node<K, V>> {\n+        KVNodeHandle {\n+            node: &mut *self.node,\n+            index: self.index - 1\n         }\n     }\n \n-    pub fn iter_mut<'a>(&'a mut self) -> MutTraversal<'a, K, V> {\n-        let is_leaf = self.is_leaf();\n-        MutTraversal {\n-            elems: self.keys.iter().zip(self.vals.iter_mut()),\n-            edges: self.edges.iter_mut(),\n-            head_is_edge: true,\n-            tail_is_edge: true,\n-            has_edges: !is_leaf,\n+    /// Gets the handle pointing to the key/value pair just to the right of the pointed-to edge.\n+    /// This is unsafe because the handle might point to the last edge in the node, which has no\n+    /// pair to its right.\n+    unsafe fn right_kv<'a>(&'a mut self) -> KVNodeHandle<&'a mut Node<K, V>> {\n+        KVNodeHandle {\n+            node: &mut *self.node,\n+            index: self.index\n         }\n     }\n \n-    pub fn into_iter(self) -> MoveTraversal<K, V> {\n-        let is_leaf = self.is_leaf();\n-        MoveTraversal {\n-            elems: self.keys.into_iter().zip(self.vals.into_iter()),\n-            edges: self.edges.into_iter(),\n-            head_is_edge: true,\n-            tail_is_edge: true,\n-            has_edges: !is_leaf,\n+    /// Right is underflowed. Tries to steal from left,\n+    /// but merges left and right if left is low too.\n+    unsafe fn handle_underflow_to_left(&mut self) {\n+        let left_len = self.node.edges()[self.index - 1].len();\n+        if left_len > min_load_from_capacity(self.node.capacity()) {\n+            self.left_kv().steal_rightward();\n+        } else {\n+            self.left_kv().merge_children();\n+        }\n+    }\n+\n+    /// Left is underflowed. Tries to steal from the right,\n+    /// but merges left and right if right is low too.\n+    unsafe fn handle_underflow_to_right(&mut self) {\n+        let right_len = self.node.edges()[self.index + 1].len();\n+        if right_len > min_load_from_capacity(self.node.capacity()) {\n+            self.right_kv().steal_leftward();\n+        } else {\n+            self.right_kv().merge_children();\n+        }\n+    }\n+\n+    /// Converts a handle into one that stores the same information using a raw pointer. This can\n+    /// be useful in conjunction with `from_raw` in the cases in which the type system is\n+    /// insufficient for determining the lifetimes of the nodes.\n+    pub fn as_raw(&mut self) -> EdgeNodeHandle<*mut Node<K, V>> {\n+        EdgeNodeHandle {\n+            node: &mut *self.node as *mut _,\n+            index: self.index\n         }\n     }\n }\n \n-// Private implementation details\n-impl<K, V> Node<K, V> {\n-    /// Make a node from its raw components\n-    fn from_vecs(keys: Vec<K>, vals: Vec<V>, edges: Vec<Node<K, V>>) -> Node<K, V> {\n-        Node {\n-            keys: keys,\n-            vals: vals,\n-            edges: edges,\n+impl<K, V> EdgeNodeHandle<*mut Node<K, V>> {\n+    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n+    /// stored with a reference. This is an unsafe inverse of `as_raw`, and together they allow\n+    /// unsafely extending the lifetime of the reference to the `Node`.\n+    pub unsafe fn from_raw<'a>(&'a self) -> EdgeNodeHandle<&'a Node<K, V>> {\n+        EdgeNodeHandle {\n+            node: &*self.node,\n+            index: self.index\n         }\n     }\n \n-    /// We have somehow verified that this key-value pair will fit in this internal node,\n-    /// so insert under that assumption.\n-    fn insert_fit_as_leaf(&mut self, index: uint, key: K, val: V) {\n-        self.keys.insert(index, key);\n-        self.vals.insert(index, val);\n+    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n+    /// stored with a mutable reference. This is an unsafe inverse of `as_raw`, and together they\n+    /// allow unsafely extending the lifetime of the reference to the `Node`.\n+    pub unsafe fn from_raw_mut<'a>(&'a mut self) -> EdgeNodeHandle<&'a mut Node<K, V>> {\n+        EdgeNodeHandle {\n+            node: &mut *self.node,\n+            index: self.index\n+        }\n     }\n+}\n \n-    /// We have somehow verified that this key-value pair will fit in this internal node,\n-    /// so insert under that assumption\n-    fn insert_fit_as_internal(&mut self, index: uint, key: K, val: V, right: Node<K, V>) {\n-        self.keys.insert(index, key);\n-        self.vals.insert(index, val);\n-        self.edges.insert(index + 1, right);\n+impl<'a, K: 'a, V: 'a> KVNodeHandle<&'a Node<K, V>> {\n+    /// Turns the handle into references to the key and value it points at. This is necessary\n+    /// because the returned pointers have larger lifetimes than what would be returned by `key`\n+    /// or `val`.\n+    pub fn into_kv(self) -> (&'a K, &'a V) {\n+        let (keys, vals) = self.node.as_slices();\n+        unsafe {\n+            (\n+                keys.unsafe_get(self.index),\n+                vals.unsafe_get(self.index)\n+            )\n+        }\n     }\n+}\n \n-    /// Node is full, so split it into two nodes, and yield the middle-most key-value pair\n-    /// because we have one too many, and our parent now has one too few\n-    fn split(&mut self) -> (K, V, Node<K, V>) {\n-        let r_keys = split(&mut self.keys);\n-        let r_vals = split(&mut self.vals);\n-        let r_edges = if self.edges.is_empty() {\n-            Vec::new()\n-        } else {\n-            split(&mut self.edges)\n-        };\n+impl<'a, K: 'a, V: 'a> KVNodeHandle<&'a mut Node<K, V>> {\n+    /// Turns the handle into mutable references to the key and value it points at. This is\n+    /// necessary because the returned pointers have larger lifetimes than what would be returned\n+    /// by `key_mut` or `val_mut`.\n+    pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n+        let (keys, vals) = self.node.as_slices_mut();\n+        unsafe {\n+            (\n+                keys.unsafe_mut(self.index),\n+                vals.unsafe_mut(self.index)\n+            )\n+        }\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a> KVNodeHandle<NodeRef> {\n+    /// Returns a reference to the node that contains the pointed-to key/value pair.\n+    pub fn node(&'a self) -> &'a Node<K, V> {\n+        &*self.node\n+    }\n \n-        let right = Node::from_vecs(r_keys, r_vals, r_edges);\n-        // Pop it\n-        let key = self.keys.pop().unwrap();\n-        let val = self.vals.pop().unwrap();\n+    // These are fine to include, but are currently unneeded.\n+    //\n+    // /// Returns a reference to the key pointed-to by this handle. This doesn't return a\n+    // /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n+    // /// handle.\n+    // pub fn key(&'a self) -> &'a K {\n+    //     unsafe { self.node.keys().unsafe_get(self.index) }\n+    // }\n+    //\n+    // /// Returns a reference to the value pointed-to by this handle. This doesn't return a\n+    // /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n+    // /// handle.\n+    // pub fn val(&'a self) -> &'a V {\n+    //     unsafe { self.node.vals().unsafe_get(self.index) }\n+    // }\n+}\n \n-        (key, val, right)\n+impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a> KVNodeHandle<NodeRef> {\n+    /// Returns a mutable reference to the key pointed-to by this handle. This doesn't return a\n+    /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n+    /// handle.\n+    pub fn key_mut(&'a mut self) -> &'a mut K {\n+        unsafe { self.node.keys_mut().unsafe_mut(self.index) }\n     }\n \n-    /// Right is underflowed. Try to steal from left,\n-    /// but merge left and right if left is low too.\n-    unsafe fn handle_underflow_to_left(&mut self, underflowed_child_index: uint) {\n-        let left_len = self.edges[underflowed_child_index - 1].len();\n-        if left_len > min_load_from_capacity(self.capacity()) {\n-            self.steal_to_left(underflowed_child_index);\n-        } else {\n-            self.merge_children(underflowed_child_index - 1);\n+    /// Returns a mutable reference to the value pointed-to by this handle. This doesn't return a\n+    /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n+    /// handle.\n+    pub fn val_mut(&'a mut self) -> &'a mut V {\n+        unsafe { self.node.vals_mut().unsafe_mut(self.index) }\n+    }\n+}\n+\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> KVNodeHandle<NodeRef> {\n+    /// Gets the handle pointing to the edge immediately to the left of the key/value pair pointed\n+    /// to by this handle.\n+    pub fn left_edge<'a>(&'a mut self) -> EdgeNodeHandle<&'a mut Node<K, V>> {\n+        EdgeNodeHandle {\n+            node: &mut *self.node,\n+            index: self.index\n         }\n     }\n \n-    /// Left is underflowed. Try to steal from the right,\n-    /// but merge left and right if right is low too.\n-    unsafe fn handle_underflow_to_right(&mut self, underflowed_child_index: uint) {\n-        let right_len = self.edges[underflowed_child_index + 1].len();\n-        if right_len > min_load_from_capacity(self.capacity()) {\n-            self.steal_to_right(underflowed_child_index);\n-        } else {\n-            self.merge_children(underflowed_child_index);\n+    /// Gets the handle pointing to the edge immediately to the right of the key/value pair pointed\n+    /// to by this handle.\n+    pub fn right_edge<'a>(&'a mut self) -> EdgeNodeHandle<&'a mut Node<K, V>> {\n+        EdgeNodeHandle {\n+            node: &mut *self.node,\n+            index: self.index + 1\n+        }\n+    }\n+\n+    /// Removes the key/value pair at the handle's location.\n+    ///\n+    /// # Panics (in debug build)\n+    ///\n+    /// Panics if the node containing the pair is not a leaf node.\n+    pub fn remove_as_leaf(mut self) -> (K, V) {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(self.node.is_leaf(), \"remove_as_leaf must only be called on leaf nodes\");\n+        unsafe { self.node.remove_kv(self.index) }\n+    }\n+\n+    /// Converts a handle into one that stores the same information using a raw pointer. This can\n+    /// be useful in conjunction with `from_raw` in the cases in which the type system is\n+    /// insufficient for determining the lifetimes of the nodes.\n+    pub fn as_raw(&mut self) -> KVNodeHandle<*mut Node<K, V>> {\n+        KVNodeHandle {\n+            node: &mut *self.node as *mut _,\n+            index: self.index\n         }\n     }\n \n     /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" right.\n-    unsafe fn steal_to_left(&mut self, underflowed_child_index: uint) {\n+    unsafe fn steal_rightward(&mut self) {\n         // Take the biggest stuff off left\n         let (mut key, mut val, edge) = {\n-            let left = self.unsafe_edge_mut(underflowed_child_index - 1);\n-            match (left.keys.pop(), left.vals.pop(), left.edges.pop()) {\n-                (Some(k), Some(v), e) => (k, v, e),\n-                _ => unreachable!(),\n-            }\n+            let mut left_handle = self.left_edge();\n+            let left = left_handle.edge_mut().unwrap();\n+            let (key, val) = left.pop_kv();\n+            let edge = if left.is_leaf() {\n+                None\n+            } else {\n+                Some(left.pop_edge())\n+            };\n+\n+            (key, val, edge)\n         };\n \n         // Swap the parent's separating key-value pair with left's\n-        self.unsafe_swap(underflowed_child_index - 1, &mut key, &mut val);\n+        mem::swap(&mut key, self.key_mut());\n+        mem::swap(&mut val, self.val_mut());\n \n         // Put them at the start of right\n-        {\n-            let right = self.unsafe_edge_mut(underflowed_child_index);\n-            right.keys.insert(0, key);\n-            right.vals.insert(0, val);\n-            match edge {\n-                None => {}\n-                Some(e) => right.edges.insert(0, e)\n-            }\n+        let mut right_handle = self.right_edge();\n+        let right = right_handle.edge_mut().unwrap();\n+        right.insert_kv(0, key, val);\n+        match edge {\n+            Some(edge) => right.insert_edge(0, edge),\n+            None => {}\n         }\n     }\n \n     /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" left.\n-    unsafe fn steal_to_right(&mut self, underflowed_child_index: uint) {\n+    unsafe fn steal_leftward(&mut self) {\n         // Take the smallest stuff off right\n         let (mut key, mut val, edge) = {\n-            let right = self.unsafe_edge_mut(underflowed_child_index + 1);\n-            match (right.keys.remove(0), right.vals.remove(0), right.edges.remove(0)) {\n-                (Some(k), Some(v), e) => (k, v, e),\n-                _ => unreachable!(),\n-            }\n+            let mut right_handle = self.right_edge();\n+            let right = right_handle.edge_mut().unwrap();\n+            let (key, val) = right.remove_kv(0);\n+            let edge = if right.is_leaf() {\n+                None\n+            } else {\n+                Some(right.remove_edge(0))\n+            };\n+\n+            (key, val, edge)\n         };\n \n         // Swap the parent's separating key-value pair with right's\n-        self.unsafe_swap(underflowed_child_index, &mut key, &mut val);\n+        mem::swap(&mut key, self.key_mut());\n+        mem::swap(&mut val, self.val_mut());\n \n         // Put them at the end of left\n-        {\n-            let left = self.unsafe_edge_mut(underflowed_child_index);\n-            left.keys.push(key);\n-            left.vals.push(val);\n-            match edge {\n-                None => {}\n-                Some(e) => left.edges.push(e)\n-            }\n+        let mut left_handle = self.left_edge();\n+        let left = left_handle.edge_mut().unwrap();\n+        left.push_kv(key, val);\n+        match edge {\n+            Some(edge) => left.push_edge(edge),\n+            None => {}\n         }\n     }\n \n-    /// Merge! Left and right will be smooshed into one node, along with the key-value\n+    /// Merge! Smooshes left and right into one node, along with the key-value\n     /// pair that separated them in their parent.\n-    unsafe fn merge_children(&mut self, left_index: uint) {\n+    unsafe fn merge_children(mut self) {\n         // Permanently remove right's index, and the key-value pair that separates\n         // left and right\n-        let (key, val, right) = {\n-            match (self.keys.remove(left_index),\n-                self.vals.remove(left_index),\n-                self.edges.remove(left_index + 1)) {\n-                (Some(k), Some(v), Some(e)) => (k, v, e),\n-                _ => unreachable!(),\n-            }\n-        };\n+        let (key, val) = self.node.remove_kv(self.index);\n+        let right = self.node.remove_edge(self.index + 1);\n \n         // Give left right's stuff.\n-        let left = self.unsafe_edge_mut(left_index);\n-        left.absorb(key, val, right);\n+        self.left_edge().edge_mut().unwrap()\n+            .absorb(key, val, right);\n     }\n+}\n \n-    /// Take all the values from right, separated by the given key and value\n-    fn absorb(&mut self, key: K, val: V, right: Node<K, V>) {\n-        // Just as a sanity check, make sure we can fit this guy in\n-        debug_assert!(self.len() + right.len() <= self.capacity())\n+impl<K, V> KVNodeHandle<*mut Node<K, V>> {\n+    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n+    /// stored with a reference. This is an unsafe inverse of `as_raw`, and together they allow\n+    /// unsafely extending the lifetime of the reference to the `Node`.\n+    pub unsafe fn from_raw<'a>(&'a self) -> KVNodeHandle<&'a Node<K, V>> {\n+        KVNodeHandle {\n+            node: &*self.node,\n+            index: self.index\n+        }\n+    }\n \n-        self.keys.push(key);\n-        self.vals.push(val);\n-        self.keys.extend(right.keys.into_iter());\n-        self.vals.extend(right.vals.into_iter());\n-        self.edges.extend(right.edges.into_iter());\n+    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n+    /// stored with a mutable reference. This is an unsafe inverse of `as_raw`, and together they\n+    /// allow unsafely extending the lifetime of the reference to the `Node`.\n+    pub unsafe fn from_raw_mut<'a>(&'a mut self) -> KVNodeHandle<&'a mut Node<K, V>> {\n+        KVNodeHandle {\n+            node: &mut *self.node,\n+            index: self.index\n+        }\n     }\n }\n \n-/// Takes a Vec, and splits half the elements into a new one.\n-fn split<T>(left: &mut Vec<T>) -> Vec<T> {\n-    // This function is intended to be called on a full Vec of size 2B - 1 (keys, values),\n-    // or 2B (edges). In the former case, left should get B elements, and right should get\n-    // B - 1. In the latter case, both should get B. Therefore, we can just always take the last\n-    // size / 2 elements from left, and put them on right. This also ensures this method is\n-    // safe, even if the Vec isn't full. Just uninteresting for our purposes.\n-    let len = left.len();\n-    let right_len = len / 2;\n-    let left_len = len - right_len;\n-    let mut right = Vec::with_capacity(left.capacity());\n-    unsafe {\n-        let left_ptr = left.unsafe_get(left_len) as *const _;\n-        let right_ptr = right.as_mut_ptr();\n-        ptr::copy_nonoverlapping_memory(right_ptr, left_ptr, right_len);\n-        left.set_len(left_len);\n-        right.set_len(right_len);\n+impl<K, V> Node<K, V> {\n+    /// Returns the mutable handle pointing to the key/value pair at a given index.\n+    ///\n+    /// # Panics (in debug build)\n+    ///\n+    /// Panics if the given index is out of bounds.\n+    pub fn kv_handle(&mut self, index: uint) -> KVNodeHandle<&mut Node<K, V>> {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(index < self.len(), \"kv_handle index out of bounds\");\n+        KVNodeHandle {\n+            node: self,\n+            index: index\n+        }\n+    }\n+\n+    /// Returns the mutable handle pointing to the edge at a given index.\n+    ///\n+    /// # Panics (in debug build)\n+    ///\n+    /// Panics if the given index is out of bounds.\n+    pub fn edge_handle(&mut self, index: uint) -> EdgeNodeHandle<&mut Node<K, V>> {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(index <= self.len(), \"edge_handle index out of bounds\");\n+        EdgeNodeHandle {\n+            node: self,\n+            index: index\n+        }\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> Traversal<'a, K, V> {\n+        let is_leaf = self.is_leaf();\n+        let (keys, vals, edges) = self.as_slices_internal();\n+        Traversal {\n+            inner: ElemsAndEdges(\n+                keys.iter().zip(vals.iter()),\n+                edges.iter()\n+            ),\n+            head_is_edge: true,\n+            tail_is_edge: true,\n+            has_edges: !is_leaf,\n+        }\n+    }\n+\n+    pub fn iter_mut<'a>(&'a mut self) -> MutTraversal<'a, K, V> {\n+        let is_leaf = self.is_leaf();\n+        let (keys, vals, edges) = self.as_slices_internal_mut();\n+        MutTraversal {\n+            inner: ElemsAndEdges(\n+                keys.iter().zip(vals.iter_mut()),\n+                edges.iter_mut()\n+            ),\n+            head_is_edge: true,\n+            tail_is_edge: true,\n+            has_edges: !is_leaf,\n+        }\n+    }\n+\n+    pub fn into_iter(self) -> MoveTraversal<K, V> {\n+        unsafe {\n+            let ret = MoveTraversal {\n+                inner: MoveTraversalImpl {\n+                    keys: RawItems::from_slice(self.keys()),\n+                    vals: RawItems::from_slice(self.vals()),\n+                    edges: RawItems::from_slice(self.edges()),\n+\n+                    ptr: self.keys as *mut u8,\n+                    capacity: self.capacity(),\n+                    is_leaf: self.is_leaf()\n+                },\n+                head_is_edge: true,\n+                tail_is_edge: true,\n+                has_edges: !self.is_leaf(),\n+            };\n+            mem::forget(self);\n+            ret\n+        }\n+    }\n+\n+    /// When a node has no keys or values and only a single edge, extract that edge.\n+    pub fn into_edge(&mut self) {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(self.len() == 0);\n+        debug_assert!(!self.is_leaf());\n+\n+        unsafe {\n+            let ret = ptr::read(self.edges().unsafe_get(0));\n+            self.destroy();\n+            ptr::write(self, ret);\n+        }\n+    }\n+}\n+\n+// Vector functions (all unchecked)\n+impl<K, V> Node<K, V> {\n+    // This must be followed by push_edge on an internal node.\n+    #[inline]\n+    unsafe fn push_kv(&mut self, key: K, val: V) {\n+        let len = self.len();\n+\n+        ptr::write(self.keys_mut().unsafe_mut(len), key);\n+        ptr::write(self.vals_mut().unsafe_mut(len), val);\n+\n+        self._len += 1;\n+    }\n+\n+    // This can only be called immediately after a call to push_kv.\n+    #[inline]\n+    unsafe fn push_edge(&mut self, edge: Node<K, V>) {\n+        let len = self.len();\n+\n+        ptr::write(self.edges_mut().unsafe_mut(len), edge);\n+    }\n+\n+    // This must be followed by insert_edge on an internal node.\n+    #[inline]\n+    unsafe fn insert_kv(&mut self, index: uint, key: K, val: V) -> &mut V {\n+        ptr::copy_memory(\n+            self.keys_mut().as_mut_ptr().offset(index as int + 1),\n+            self.keys().as_ptr().offset(index as int),\n+            self.len() - index\n+        );\n+        ptr::copy_memory(\n+            self.vals_mut().as_mut_ptr().offset(index as int + 1),\n+            self.vals().as_ptr().offset(index as int),\n+            self.len() - index\n+        );\n+\n+        ptr::write(self.keys_mut().unsafe_mut(index), key);\n+        ptr::write(self.vals_mut().unsafe_mut(index), val);\n+\n+        self._len += 1;\n+\n+        self.vals_mut().unsafe_mut(index)\n+    }\n+\n+    // This can only be called immediately after a call to insert_kv.\n+    #[inline]\n+    unsafe fn insert_edge(&mut self, index: uint, edge: Node<K, V>) {\n+        ptr::copy_memory(\n+            self.edges_mut().as_mut_ptr().offset(index as int + 1),\n+            self.edges().as_ptr().offset(index as int),\n+            self.len() - index\n+        );\n+        ptr::write(self.edges_mut().unsafe_mut(index), edge);\n+    }\n+\n+    // This must be followed by pop_edge on an internal node.\n+    #[inline]\n+    unsafe fn pop_kv(&mut self) -> (K, V) {\n+        let key = ptr::read(self.keys().unsafe_get(self.len() - 1));\n+        let val = ptr::read(self.vals().unsafe_get(self.len() - 1));\n+\n+        self._len -= 1;\n+\n+        (key, val)\n+    }\n+\n+    // This can only be called immediately after a call to pop_kv.\n+    #[inline]\n+    unsafe fn pop_edge(&mut self) -> Node<K, V> {\n+        let edge = ptr::read(self.edges().unsafe_get(self.len() + 1));\n+\n+        edge\n+    }\n+\n+    // This must be followed by remove_edge on an internal node.\n+    #[inline]\n+    unsafe fn remove_kv(&mut self, index: uint) -> (K, V) {\n+        let key = ptr::read(self.keys().unsafe_get(index));\n+        let val = ptr::read(self.vals().unsafe_get(index));\n+\n+        ptr::copy_memory(\n+            self.keys_mut().as_mut_ptr().offset(index as int),\n+            self.keys().as_ptr().offset(index as int + 1),\n+            self.len() - index - 1\n+        );\n+        ptr::copy_memory(\n+            self.vals_mut().as_mut_ptr().offset(index as int),\n+            self.vals().as_ptr().offset(index as int + 1),\n+            self.len() - index - 1\n+        );\n+\n+        self._len -= 1;\n+\n+        (key, val)\n+    }\n+\n+    // This can only be called immediately after a call to remove_kv.\n+    #[inline]\n+    unsafe fn remove_edge(&mut self, index: uint) -> Node<K, V> {\n+        let edge = ptr::read(self.edges().unsafe_get(index));\n+\n+        ptr::copy_memory(\n+            self.edges_mut().as_mut_ptr().offset(index as int),\n+            self.edges().as_ptr().offset(index as int + 1),\n+            self.len() - index + 1\n+        );\n+\n+        edge\n+    }\n+}\n+\n+// Private implementation details\n+impl<K, V> Node<K, V> {\n+    /// Node is full, so split it into two nodes, and yield the middle-most key-value pair\n+    /// because we have one too many, and our parent now has one too few\n+    fn split(&mut self) -> (K, V, Node<K, V>) {\n+        // Necessary for correctness, but in a private funtion\n+        debug_assert!(self.len() > 0);\n+\n+        let mut right = if self.is_leaf() {\n+            Node::new_leaf(self.capacity())\n+        } else {\n+            unsafe { Node::new_internal(self.capacity()) }\n+        };\n+\n+        unsafe {\n+            right._len = self.len() / 2;\n+            let right_offset = self.len() - right.len();\n+            ptr::copy_nonoverlapping_memory(\n+                right.keys_mut().as_mut_ptr(),\n+                self.keys().as_ptr().offset(right_offset as int),\n+                right.len()\n+            );\n+            ptr::copy_nonoverlapping_memory(\n+                right.vals_mut().as_mut_ptr(),\n+                self.vals().as_ptr().offset(right_offset as int),\n+                right.len()\n+            );\n+            if !self.is_leaf() {\n+                ptr::copy_nonoverlapping_memory(\n+                    right.edges_mut().as_mut_ptr(),\n+                    self.edges().as_ptr().offset(right_offset as int),\n+                    right.len() + 1\n+                );\n+            }\n+\n+            let key = ptr::read(self.keys().unsafe_get(right_offset - 1));\n+            let val = ptr::read(self.vals().unsafe_get(right_offset - 1));\n+\n+            self._len = right_offset - 1;\n+\n+            (key, val, right)\n+        }\n+    }\n+\n+    /// Take all the values from right, seperated by the given key and value\n+    fn absorb(&mut self, key: K, val: V, mut right: Node<K, V>) {\n+        // Necessary for correctness, but in a private function\n+        // Just as a sanity check, make sure we can fit this guy in\n+        debug_assert!(self.len() + right.len() <= self.capacity());\n+        debug_assert!(self.is_leaf() == right.is_leaf());\n+\n+        unsafe {\n+            let old_len = self.len();\n+            self._len += right.len() + 1;\n+\n+            ptr::write(self.keys_mut().unsafe_mut(old_len), key);\n+            ptr::write(self.vals_mut().unsafe_mut(old_len), val);\n+\n+            ptr::copy_nonoverlapping_memory(\n+                self.keys_mut().as_mut_ptr().offset(old_len as int + 1),\n+                right.keys().as_ptr(),\n+                right.len()\n+            );\n+            ptr::copy_nonoverlapping_memory(\n+                self.vals_mut().as_mut_ptr().offset(old_len as int + 1),\n+                right.vals().as_ptr(),\n+                right.len()\n+            );\n+            if !self.is_leaf() {\n+                ptr::copy_nonoverlapping_memory(\n+                    self.edges_mut().as_mut_ptr().offset(old_len as int + 1),\n+                    right.edges().as_ptr(),\n+                    right.len() + 1\n+                );\n+            }\n+\n+            right.destroy();\n+            mem::forget(right);\n+        }\n     }\n-    right\n }\n \n /// Get the capacity of a node from the order of the parent B-Tree\n@@ -497,10 +1316,89 @@ fn min_load_from_capacity(cap: uint) -> uint {\n     cap / 2\n }\n \n+/// A trait for pairs of `Iterator`s, one over edges and the other over key/value pairs. This is\n+/// necessary, as the `MoveTraversalImpl` needs to have a destructor that deallocates the `Node`,\n+/// and a pair of `Iterator`s would require two independent destructors.\n+trait TraversalImpl<K, V, E> {\n+    fn next_kv(&mut self) -> Option<(K, V)>;\n+    fn next_kv_back(&mut self) -> Option<(K, V)>;\n+\n+    fn next_edge(&mut self) -> Option<E>;\n+    fn next_edge_back(&mut self) -> Option<E>;\n+}\n+\n+/// A `TraversalImpl` that actually is backed by two iterators. This works in the non-moving case,\n+/// as no deallocation needs to be done.\n+struct ElemsAndEdges<Elems, Edges>(Elems, Edges);\n+\n+impl<K, V, E, Elems: DoubleEndedIterator<(K, V)>, Edges: DoubleEndedIterator<E>>\n+        TraversalImpl<K, V, E> for ElemsAndEdges<Elems, Edges> {\n+\n+    fn next_kv(&mut self) -> Option<(K, V)> { self.0.next() }\n+    fn next_kv_back(&mut self) -> Option<(K, V)> { self.0.next_back() }\n+\n+    fn next_edge(&mut self) -> Option<E> { self.1.next() }\n+    fn next_edge_back(&mut self) -> Option<E> { self.1.next_back() }\n+}\n+\n+/// A `TraversalImpl` taking a `Node` by value.\n+struct MoveTraversalImpl<K, V> {\n+    keys: RawItems<K>,\n+    vals: RawItems<V>,\n+    edges: RawItems<Node<K, V>>,\n+\n+    // For deallocation when we are done iterating.\n+    ptr: *mut u8,\n+    capacity: uint,\n+    is_leaf: bool\n+}\n+\n+impl<K, V> TraversalImpl<K, V, Node<K, V>> for MoveTraversalImpl<K, V> {\n+    fn next_kv(&mut self) -> Option<(K, V)> {\n+        match (self.keys.next(), self.vals.next()) {\n+            (Some(k), Some(v)) => Some((k, v)),\n+            _ => None\n+        }\n+    }\n+\n+    fn next_kv_back(&mut self) -> Option<(K, V)> {\n+        match (self.keys.next_back(), self.vals.next_back()) {\n+            (Some(k), Some(v)) => Some((k, v)),\n+            _ => None\n+        }\n+    }\n+\n+    fn next_edge(&mut self) -> Option<Node<K, V>> {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(!self.is_leaf);\n+        self.edges.next()\n+    }\n+\n+    fn next_edge_back(&mut self) -> Option<Node<K, V>> {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(!self.is_leaf);\n+        self.edges.next_back()\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<K, V> Drop for MoveTraversalImpl<K, V> {\n+    fn drop(&mut self) {\n+        // We need to cleanup the stored values manually, as the RawItems destructor would run\n+        // after our deallocation.\n+        for _ in self.keys {}\n+        for _ in self.vals {}\n+        for _ in self.edges {}\n+\n+        let (alignment, size) =\n+                calculate_allocation_generic::<K, V>(self.capacity, self.is_leaf);\n+        unsafe { heap::deallocate(self.ptr, size, alignment) };\n+    }\n+}\n+\n /// An abstraction over all the different kinds of traversals a node supports\n-struct AbsTraversal<Elems, Edges> {\n-    elems: Elems,\n-    edges: Edges,\n+struct AbsTraversal<Impl> {\n+    inner: Impl,\n     head_is_edge: bool,\n     tail_is_edge: bool,\n     has_edges: bool,\n@@ -513,44 +1411,45 @@ pub enum TraversalItem<K, V, E> {\n }\n \n /// A traversal over a node's entries and edges\n-pub type Traversal<'a, K, V> = AbsTraversal<Zip<slice::Items<'a, K>, slice::Items<'a, V>>,\n-                                            slice::Items<'a, Node<K, V>>>;\n+pub type Traversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Items<'a, K>,\n+                                                              slice::Items<'a, V>>,\n+                                                              slice::Items<'a, Node<K, V>>>>;\n \n /// A mutable traversal over a node's entries and edges\n-pub type MutTraversal<'a, K, V> = AbsTraversal<Zip<slice::Items<'a, K>, slice::MutItems<'a, V>>,\n-                                               slice::MutItems<'a, Node<K, V>>>;\n+pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Items<'a, K>,\n+                                                                 slice::MutItems<'a, V>>,\n+                                                                 slice::MutItems<'a, Node<K, V>>>>;\n \n /// An owning traversal over a node's entries and edges\n-pub type MoveTraversal<K, V> = AbsTraversal<Zip<vec::MoveItems<K>, vec::MoveItems<V>>,\n-                                                vec::MoveItems<Node<K, V>>>;\n+pub type MoveTraversal<K, V> = AbsTraversal<MoveTraversalImpl<K, V>>;\n \n \n-impl<K, V, E, Elems: Iterator<(K, V)>, Edges: Iterator<E>>\n-        Iterator<TraversalItem<K, V, E>> for AbsTraversal<Elems, Edges> {\n+impl<K, V, E, Impl: TraversalImpl<K, V, E>>\n+        Iterator<TraversalItem<K, V, E>> for AbsTraversal<Impl> {\n \n     fn next(&mut self) -> Option<TraversalItem<K, V, E>> {\n         let head_is_edge = self.head_is_edge;\n         self.head_is_edge = !head_is_edge;\n \n         if head_is_edge && self.has_edges {\n-            self.edges.next().map(|node| Edge(node))\n+            self.inner.next_edge().map(|node| Edge(node))\n         } else {\n-            self.elems.next().map(|(k, v)| Elem(k, v))\n+            self.inner.next_kv().map(|(k, v)| Elem(k, v))\n         }\n     }\n }\n \n-impl<K, V, E, Elems: DoubleEndedIterator<(K, V)>, Edges: DoubleEndedIterator<E>>\n-        DoubleEndedIterator<TraversalItem<K, V, E>> for AbsTraversal<Elems, Edges> {\n+impl<K, V, E, Impl: TraversalImpl<K, V, E>>\n+        DoubleEndedIterator<TraversalItem<K, V, E>> for AbsTraversal<Impl> {\n \n     fn next_back(&mut self) -> Option<TraversalItem<K, V, E>> {\n         let tail_is_edge = self.tail_is_edge;\n         self.tail_is_edge = !tail_is_edge;\n \n         if tail_is_edge && self.has_edges {\n-            self.edges.next_back().map(|node| Edge(node))\n+            self.inner.next_edge_back().map(|node| Edge(node))\n         } else {\n-            self.elems.next_back().map(|(k, v)| Elem(k, v))\n+            self.inner.next_kv_back().map(|(k, v)| Elem(k, v))\n         }\n     }\n }"}, {"sha": "039bbcd2b70205a410d5d64f61d89269ab38dd07", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5921241a3146cccaffc336a0d1ade1a90e3517f/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5921241a3146cccaffc336a0d1ade1a90e3517f/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=a5921241a3146cccaffc336a0d1ade1a90e3517f", "patch": "@@ -24,6 +24,7 @@\n #![allow(unknown_features)]\n #![feature(macro_rules, default_type_params, phase, globs)]\n #![feature(unsafe_destructor, import_shadowing, slicing_syntax)]\n+#![feature(tuple_indexing, unboxed_closures)]\n #![no_std]\n \n #[phase(plugin, link)] extern crate core;\n@@ -114,5 +115,6 @@ mod std {\n     pub use core::option;   // necessary for panic!()\n     pub use core::clone;    // deriving(Clone)\n     pub use core::cmp;      // deriving(Eq, Ord, etc.)\n+    pub use core::kinds;    // deriving(Copy)\n     pub use hash;           // deriving(Hash)\n }"}]}