{"sha": "209b2be09fcaff937480d1fbbe8b31646e361c7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwOWIyYmUwOWZjYWZmOTM3NDgwZDFmYmJlOGIzMTY0NmUzNjFjN2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-07T04:01:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-07T04:01:26Z"}, "message": "Auto merge of #70164 - eddyb:walk-generic-arg, r=nikomatsakis\n\nty/walk: iterate `GenericArg`s instead of `Ty`s.\n\nBefore this PR, `Ty::walk` only iterated over `Ty`s, but that's becoming an increasing problem with `const` generics, as `ty::Const`s in `Substs` are missed by it.\n\nBy working with `GenericArg` instead, we can handle both `Ty`s and `ty::Const`s, but also `ty::Region`s, which used to require ad-hoc mechanisms such as `push_regions`.\n\nI've also removed `TraitRef::input_types`, as it's both long obsolete, and easy to misuse.", "tree": {"sha": "94f4edf2efe2129f98902e825bb2cc220e7d0697", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94f4edf2efe2129f98902e825bb2cc220e7d0697"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/209b2be09fcaff937480d1fbbe8b31646e361c7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/209b2be09fcaff937480d1fbbe8b31646e361c7a", "html_url": "https://github.com/rust-lang/rust/commit/209b2be09fcaff937480d1fbbe8b31646e361c7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/209b2be09fcaff937480d1fbbe8b31646e361c7a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc", "html_url": "https://github.com/rust-lang/rust/commit/bf1f2eedda4fa02b7c9347dd849ed73ddd43dedc"}, {"sha": "626abc797704009e4683be5d95dbeb9417999c82", "url": "https://api.github.com/repos/rust-lang/rust/commits/626abc797704009e4683be5d95dbeb9417999c82", "html_url": "https://github.com/rust-lang/rust/commit/626abc797704009e4683be5d95dbeb9417999c82"}], "stats": {"total": 1221, "additions": 618, "deletions": 603}, "files": [{"sha": "bb6e5700ccad4944bb7885e286d87a3b8787b9ec", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 64, "deletions": 49, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -7,52 +7,59 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Body, Expr, ExprKind, FnRetTy, HirId, Local, Pat};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::print::Print;\n-use rustc_middle::ty::{self, DefIdTree, Infer, Ty, TyVar};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n+use rustc_middle::ty::{self, DefIdTree, Ty};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n use std::borrow::Cow;\n \n-struct FindLocalByTypeVisitor<'a, 'tcx> {\n+struct FindHirNodeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    target_ty: Ty<'tcx>,\n-    hir_map: Map<'tcx>,\n+    target: GenericArg<'tcx>,\n+    found_node_ty: Option<Ty<'tcx>>,\n     found_local_pattern: Option<&'tcx Pat<'tcx>>,\n     found_arg_pattern: Option<&'tcx Pat<'tcx>>,\n-    found_ty: Option<Ty<'tcx>>,\n-    found_closure: Option<&'tcx ExprKind<'tcx>>,\n+    found_closure: Option<&'tcx Expr<'tcx>>,\n     found_method_call: Option<&'tcx Expr<'tcx>>,\n }\n \n-impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target_ty: Ty<'tcx>, hir_map: Map<'tcx>) -> Self {\n+impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n+    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target: GenericArg<'tcx>) -> Self {\n         Self {\n             infcx,\n-            target_ty,\n-            hir_map,\n+            target,\n+            found_node_ty: None,\n             found_local_pattern: None,\n             found_arg_pattern: None,\n-            found_ty: None,\n             found_closure: None,\n             found_method_call: None,\n         }\n     }\n \n-    fn node_matches_type(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n+    fn node_ty_contains_target(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n         let ty_opt =\n             self.infcx.in_progress_tables.and_then(|tables| tables.borrow().node_type_opt(hir_id));\n         match ty_opt {\n             Some(ty) => {\n                 let ty = self.infcx.resolve_vars_if_possible(&ty);\n-                if ty.walk().any(|inner_ty| {\n-                    inner_ty == self.target_ty\n-                        || match (&inner_ty.kind, &self.target_ty.kind) {\n-                            (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => self\n-                                .infcx\n-                                .inner\n-                                .borrow_mut()\n-                                .type_variables\n-                                .sub_unified(a_vid, b_vid),\n+                if ty.walk().any(|inner| {\n+                    inner == self.target\n+                        || match (inner.unpack(), self.target.unpack()) {\n+                            (GenericArgKind::Type(inner_ty), GenericArgKind::Type(target_ty)) => {\n+                                match (&inner_ty.kind, &target_ty.kind) {\n+                                    (\n+                                        &ty::Infer(ty::TyVar(a_vid)),\n+                                        &ty::Infer(ty::TyVar(b_vid)),\n+                                    ) => self\n+                                        .infcx\n+                                        .inner\n+                                        .borrow_mut()\n+                                        .type_variables\n+                                        .sub_unified(a_vid, b_vid),\n+                                    _ => false,\n+                                }\n+                            }\n                             _ => false,\n                         }\n                 }) {\n@@ -66,36 +73,39 @@ impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.hir_map)\n+        NestedVisitorMap::OnlyBodies(self.infcx.tcx.hir())\n     }\n \n     fn visit_local(&mut self, local: &'tcx Local<'tcx>) {\n-        if let (None, Some(ty)) = (self.found_local_pattern, self.node_matches_type(local.hir_id)) {\n+        if let (None, Some(ty)) =\n+            (self.found_local_pattern, self.node_ty_contains_target(local.hir_id))\n+        {\n             self.found_local_pattern = Some(&*local.pat);\n-            self.found_ty = Some(ty);\n+            self.found_node_ty = Some(ty);\n         }\n         intravisit::walk_local(self, local);\n     }\n \n     fn visit_body(&mut self, body: &'tcx Body<'tcx>) {\n         for param in body.params {\n-            if let (None, Some(ty)) = (self.found_arg_pattern, self.node_matches_type(param.hir_id))\n+            if let (None, Some(ty)) =\n+                (self.found_arg_pattern, self.node_ty_contains_target(param.hir_id))\n             {\n                 self.found_arg_pattern = Some(&*param.pat);\n-                self.found_ty = Some(ty);\n+                self.found_node_ty = Some(ty);\n             }\n         }\n         intravisit::walk_body(self, body);\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if self.node_matches_type(expr.hir_id).is_some() {\n+        if self.node_ty_contains_target(expr.hir_id).is_some() {\n             match expr.kind {\n-                ExprKind::Closure(..) => self.found_closure = Some(&expr.kind),\n+                ExprKind::Closure(..) => self.found_closure = Some(&expr),\n                 ExprKind::MethodCall(..) => self.found_method_call = Some(&expr),\n                 _ => {}\n             }\n@@ -213,6 +223,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         (s, None, ty.prefix_string(), None, None)\n     }\n \n+    // FIXME(eddyb) generalize all of this to handle `ty::Const` inference variables as well.\n     pub fn need_type_info_err(\n         &self,\n         body_id: Option<hir::BodyId>,\n@@ -223,7 +234,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let (name, name_sp, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n \n-        let mut local_visitor = FindLocalByTypeVisitor::new(&self, ty, self.tcx.hir());\n+        let mut local_visitor = FindHirNodeVisitor::new(&self, ty.into());\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -276,7 +287,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings)\n         };\n \n-        let ty_msg = match local_visitor.found_ty {\n+        let ty_msg = match local_visitor.found_node_ty {\n             Some(ty::TyS { kind: ty::Closure(_, substs), .. }) => {\n                 let fn_sig = substs.as_closure().sig();\n                 let args = closure_args(&fn_sig);\n@@ -310,28 +321,32 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             error_code,\n         );\n \n-        let suffix = match local_visitor.found_ty {\n+        let suffix = match local_visitor.found_node_ty {\n             Some(ty::TyS { kind: ty::Closure(_, substs), .. }) => {\n                 let fn_sig = substs.as_closure().sig();\n                 let ret = fn_sig.output().skip_binder().to_string();\n \n-                if let Some(ExprKind::Closure(_, decl, body_id, ..)) = local_visitor.found_closure {\n-                    if let Some(body) = self.tcx.hir().krate().bodies.get(body_id) {\n-                        closure_return_type_suggestion(\n-                            span,\n-                            &mut err,\n-                            &decl.output,\n-                            &body,\n-                            &descr,\n-                            &name,\n-                            &ret,\n-                            parent_name,\n-                            parent_descr,\n-                        );\n-                        // We don't want to give the other suggestions when the problem is the\n-                        // closure return type.\n-                        return err;\n-                    }\n+                let closure_decl_and_body_id =\n+                    local_visitor.found_closure.and_then(|closure| match &closure.kind {\n+                        ExprKind::Closure(_, decl, body_id, ..) => Some((decl, *body_id)),\n+                        _ => None,\n+                    });\n+\n+                if let Some((decl, body_id)) = closure_decl_and_body_id {\n+                    closure_return_type_suggestion(\n+                        span,\n+                        &mut err,\n+                        &decl.output,\n+                        self.tcx.hir().body(body_id),\n+                        &descr,\n+                        &name,\n+                        &ret,\n+                        parent_name,\n+                        parent_descr,\n+                    );\n+                    // We don't want to give the other suggestions when the problem is the\n+                    // closure return type.\n+                    return err;\n                 }\n \n                 // This shouldn't be reachable, but just in case we leave a reasonable fallback."}, {"sha": "ed967f7ab3a0bac8c146e996bacb3eb345bebf28", "filename": "src/librustc_infer/infer/outlives/verify.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -3,11 +3,9 @@ use crate::infer::{GenericKind, VerifyBound};\n use crate::traits;\n use rustc_data_structures::captures::Captures;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n-use smallvec::smallvec;\n-\n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n /// obligation into a series of `'a: 'b` constraints and \"verifys\", as\n /// described on the module comment. The final constraints are emitted\n@@ -44,7 +42,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         match ty.kind {\n             ty::Param(p) => self.param_bound(p),\n             ty::Projection(data) => self.projection_bound(data),\n-            _ => self.recursive_type_bound(ty),\n+            _ => self.recursive_bound(ty.into()),\n         }\n     }\n \n@@ -144,25 +142,33 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n \n         // see the extensive comment in projection_must_outlive\n         let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-        let recursive_bound = self.recursive_type_bound(ty);\n+        let recursive_bound = self.recursive_bound(ty.into());\n \n         VerifyBound::AnyBound(env_bounds.chain(trait_bounds).collect()).or(recursive_bound)\n     }\n \n-    fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        let mut bounds = ty.walk_shallow().map(|subty| self.type_bound(subty)).collect::<Vec<_>>();\n-\n-        let mut regions = smallvec![];\n-        ty.push_regions(&mut regions);\n-        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n-        bounds.push(VerifyBound::AllBounds(\n-            regions.into_iter().map(|r| VerifyBound::OutlivedBy(r)).collect(),\n-        ));\n-\n-        // remove bounds that must hold, since they are not interesting\n-        bounds.retain(|b| !b.must_hold());\n+    fn recursive_bound(&self, parent: GenericArg<'tcx>) -> VerifyBound<'tcx> {\n+        let mut bounds = parent\n+            .walk_shallow()\n+            .filter_map(|child| match child.unpack() {\n+                GenericArgKind::Type(ty) => Some(self.type_bound(ty)),\n+                GenericArgKind::Lifetime(lt) => {\n+                    // Ignore late-bound regions.\n+                    if !lt.is_late_bound() { Some(VerifyBound::OutlivedBy(lt)) } else { None }\n+                }\n+                GenericArgKind::Const(_) => Some(self.recursive_bound(child)),\n+            })\n+            .filter(|bound| {\n+                // Remove bounds that must hold, since they are not interesting.\n+                !bound.must_hold()\n+            });\n \n-        if bounds.len() == 1 { bounds.pop().unwrap() } else { VerifyBound::AllBounds(bounds) }\n+        match (bounds.next(), bounds.next()) {\n+            (Some(first), None) => first,\n+            (first, second) => {\n+                VerifyBound::AllBounds(first.into_iter().chain(second).chain(bounds).collect())\n+            }\n+        }\n     }\n \n     /// Searches the environment for where-clauses like `G: 'a` where"}, {"sha": "84cf2258ac223a51ec0eb1f5494aaf59705ac477", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -36,6 +36,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{GenericParamKind, PatKind};\n use rustc_hir::{HirIdSet, Node};\n use rustc_middle::lint::LintDiagnosticBuilder;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_span::edition::Edition;\n@@ -104,11 +105,13 @@ declare_lint_pass!(BoxPointers => [BOX_POINTERS]);\n \n impl BoxPointers {\n     fn check_heap_type(&self, cx: &LateContext<'_, '_>, span: Span, ty: Ty<'_>) {\n-        for leaf_ty in ty.walk() {\n-            if leaf_ty.is_box() {\n-                cx.struct_span_lint(BOX_POINTERS, span, |lint| {\n-                    lint.build(&format!(\"type uses owned (Box type) pointers: {}\", ty)).emit()\n-                });\n+        for leaf in ty.walk() {\n+            if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n+                if leaf_ty.is_box() {\n+                    cx.struct_span_lint(BOX_POINTERS, span, |lint| {\n+                        lint.build(&format!(\"type uses owned (Box type) pointers: {}\", ty)).emit()\n+                    });\n+                }\n             }\n         }\n     }"}, {"sha": "7b23460eb6e4c06e8797b817f26bce7d3b017b46", "filename": "src/librustc_middle/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_middle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_middle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffold.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -263,20 +263,6 @@ where\n // Region folder\n \n impl<'tcx> TyCtxt<'tcx> {\n-    /// Collects the free and escaping regions in `value` into `region_set`. Returns\n-    /// whether any late-bound regions were skipped\n-    pub fn collect_regions<T>(self, value: &T, region_set: &mut FxHashSet<ty::Region<'tcx>>) -> bool\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let mut have_bound_regions = false;\n-        self.fold_regions(value, &mut have_bound_regions, |r, d| {\n-            region_set.insert(self.mk_region(r.shifted_out_to_binder(d)));\n-            r\n-        });\n-        have_bound_regions\n-    }\n-\n     /// Folds the escaping and free regions in `value` using `f`, and\n     /// sets `skipped_regions` to true if any late-bound region was found\n     /// and skipped."}, {"sha": "1870856150f50a4342cb15c228ab5c3677d7728a", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -19,7 +19,6 @@ use crate::traits::{self, Reveal};\n use crate::ty;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::{Discr, IntTypeExt};\n-use crate::ty::walk::TypeWalker;\n use rustc_ast::ast::{self, Ident, Name};\n use rustc_ast::node_id::{NodeId, NodeMap, NodeSet};\n use rustc_attr as attr;\n@@ -1366,10 +1365,6 @@ impl<'tcx> TraitPredicate<'tcx> {\n         self.trait_ref.def_id\n     }\n \n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n-        self.trait_ref.input_types()\n-    }\n-\n     pub fn self_ty(&self) -> Ty<'tcx> {\n         self.trait_ref.self_ty()\n     }\n@@ -1519,77 +1514,7 @@ impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     }\n }\n \n-// A custom iterator used by `Predicate::walk_tys`.\n-enum WalkTysIter<'tcx, I, J, K>\n-where\n-    I: Iterator<Item = Ty<'tcx>>,\n-    J: Iterator<Item = Ty<'tcx>>,\n-    K: Iterator<Item = Ty<'tcx>>,\n-{\n-    None,\n-    One(Ty<'tcx>),\n-    Two(Ty<'tcx>, Ty<'tcx>),\n-    Types(I),\n-    InputTypes(J),\n-    ProjectionTypes(K),\n-}\n-\n-impl<'tcx, I, J, K> Iterator for WalkTysIter<'tcx, I, J, K>\n-where\n-    I: Iterator<Item = Ty<'tcx>>,\n-    J: Iterator<Item = Ty<'tcx>>,\n-    K: Iterator<Item = Ty<'tcx>>,\n-{\n-    type Item = Ty<'tcx>;\n-\n-    fn next(&mut self) -> Option<Ty<'tcx>> {\n-        match *self {\n-            WalkTysIter::None => None,\n-            WalkTysIter::One(item) => {\n-                *self = WalkTysIter::None;\n-                Some(item)\n-            }\n-            WalkTysIter::Two(item1, item2) => {\n-                *self = WalkTysIter::One(item2);\n-                Some(item1)\n-            }\n-            WalkTysIter::Types(ref mut iter) => iter.next(),\n-            WalkTysIter::InputTypes(ref mut iter) => iter.next(),\n-            WalkTysIter::ProjectionTypes(ref mut iter) => iter.next(),\n-        }\n-    }\n-}\n-\n impl<'tcx> Predicate<'tcx> {\n-    /// Iterates over the types in this predicate. Note that in all\n-    /// cases this is skipping over a binder, so late-bound regions\n-    /// with depth 0 are bound by the predicate.\n-    pub fn walk_tys(&'a self) -> impl Iterator<Item = Ty<'tcx>> + 'a {\n-        match *self {\n-            ty::Predicate::Trait(ref data, _) => {\n-                WalkTysIter::InputTypes(data.skip_binder().input_types())\n-            }\n-            ty::Predicate::Subtype(binder) => {\n-                let SubtypePredicate { a, b, a_is_expected: _ } = binder.skip_binder();\n-                WalkTysIter::Two(a, b)\n-            }\n-            ty::Predicate::TypeOutlives(binder) => WalkTysIter::One(binder.skip_binder().0),\n-            ty::Predicate::RegionOutlives(..) => WalkTysIter::None,\n-            ty::Predicate::Projection(ref data) => {\n-                let inner = data.skip_binder();\n-                WalkTysIter::ProjectionTypes(\n-                    inner.projection_ty.substs.types().chain(Some(inner.ty)),\n-                )\n-            }\n-            ty::Predicate::WellFormed(data) => WalkTysIter::One(data),\n-            ty::Predicate::ObjectSafe(_trait_def_id) => WalkTysIter::None,\n-            ty::Predicate::ClosureKind(_closure_def_id, closure_substs, _kind) => {\n-                WalkTysIter::Types(closure_substs.types())\n-            }\n-            ty::Predicate::ConstEvaluatable(_, substs) => WalkTysIter::Types(substs.types()),\n-        }\n-    }\n-\n     pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {\n         match *self {\n             Predicate::Trait(ref t, _) => Some(t.to_poly_trait_ref()),\n@@ -2686,46 +2611,6 @@ impl<'tcx> ClosureKind {\n     }\n }\n \n-impl<'tcx> TyS<'tcx> {\n-    /// Iterator that walks `self` and any types reachable from\n-    /// `self`, in depth-first order. Note that just walks the types\n-    /// that appear in `self`, it does not descend into the fields of\n-    /// structs or variants. For example:\n-    ///\n-    /// ```notrust\n-    /// isize => { isize }\n-    /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n-    /// [isize] => { [isize], isize }\n-    /// ```\n-    pub fn walk(&'tcx self) -> TypeWalker<'tcx> {\n-        TypeWalker::new(self)\n-    }\n-\n-    /// Iterator that walks the immediate children of `self`. Hence\n-    /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n-    /// (but not `i32`, like `walk`).\n-    pub fn walk_shallow(&'tcx self) -> smallvec::IntoIter<walk::TypeWalkerArray<'tcx>> {\n-        walk::walk_shallow(self)\n-    }\n-\n-    /// Walks `ty` and any types appearing within `ty`, invoking the\n-    /// callback `f` on each type. If the callback returns `false`, then the\n-    /// children of the current type are ignored.\n-    ///\n-    /// Note: prefer `ty.walk()` where possible.\n-    pub fn maybe_walk<F>(&'tcx self, mut f: F)\n-    where\n-        F: FnMut(Ty<'tcx>) -> bool,\n-    {\n-        let mut walker = self.walk();\n-        while let Some(ty) = walker.next() {\n-            if !f(ty) {\n-                walker.skip_current_subtree();\n-            }\n-        }\n-    }\n-}\n-\n impl BorrowKind {\n     pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n         match m {"}, {"sha": "950539fbb0a169fec21e652bcf7bfc22a6f565e9", "filename": "src/librustc_middle/ty/outlives.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Foutlives.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -2,6 +2,7 @@\n // refers to rules defined in RFC 1214 (`OutlivesFooBar`), so see that\n // RFC for reference.\n \n+use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use smallvec::SmallVec;\n \n@@ -107,8 +108,9 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                     // fallback case: hard code\n                     // OutlivesProjectionComponents.  Continue walking\n                     // through and constrain Pi.\n-                    let subcomponents = capture_components(tcx, ty);\n-                    out.push(Component::EscapingProjection(subcomponents));\n+                    let mut subcomponents = smallvec![];\n+                    compute_components_recursive(tcx, ty.into(), &mut subcomponents);\n+                    out.push(Component::EscapingProjection(subcomponents.into_iter().collect()));\n                 }\n             }\n \n@@ -153,26 +155,30 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                 // \"bound regions list\".  In our representation, no such\n                 // list is maintained explicitly, because bound regions\n                 // themselves can be readily identified.\n-\n-                push_region_constraints(ty, out);\n-                for subty in ty.walk_shallow() {\n-                    compute_components(tcx, subty, out);\n-                }\n+                compute_components_recursive(tcx, ty.into(), out);\n             }\n         }\n }\n \n-fn capture_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Vec<Component<'tcx>> {\n-    let mut temp = smallvec![];\n-    push_region_constraints(ty, &mut temp);\n-    for subty in ty.walk_shallow() {\n-        compute_components(tcx, subty, &mut temp);\n+fn compute_components_recursive(\n+    tcx: TyCtxt<'tcx>,\n+    parent: GenericArg<'tcx>,\n+    out: &mut SmallVec<[Component<'tcx>; 4]>,\n+) {\n+    for child in parent.walk_shallow() {\n+        match child.unpack() {\n+            GenericArgKind::Type(ty) => {\n+                compute_components(tcx, ty, out);\n+            }\n+            GenericArgKind::Lifetime(lt) => {\n+                // Ignore late-bound regions.\n+                if !lt.is_late_bound() {\n+                    out.push(Component::Region(lt));\n+                }\n+            }\n+            GenericArgKind::Const(_) => {\n+                compute_components_recursive(tcx, child, out);\n+            }\n+        }\n     }\n-    temp.into_iter().collect()\n-}\n-\n-fn push_region_constraints<'tcx>(ty: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n-    let mut regions = smallvec![];\n-    ty.push_regions(&mut regions);\n-    out.extend(regions.iter().filter(|&r| !r.is_late_bound()).map(|r| Component::Region(r)));\n }"}, {"sha": "f09327886872ceb4ba4c5e196fcc7ed867e09803", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -25,7 +25,6 @@ use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_target::abi::{Size, VariantIdx};\n use rustc_target::spec::abi;\n-use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::marker::PhantomData;\n@@ -755,14 +754,6 @@ impl<'tcx> TraitRef<'tcx> {\n         self.substs.type_at(0)\n     }\n \n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n-        // Select only the \"input types\" from a trait-reference. For\n-        // now this is all the types that appear in the\n-        // trait-reference, but it should eventually exclude\n-        // associated types.\n-        self.substs.types()\n-    }\n-\n     pub fn from_method(\n         tcx: TyCtxt<'tcx>,\n         trait_id: DefId,\n@@ -806,14 +797,6 @@ pub struct ExistentialTraitRef<'tcx> {\n }\n \n impl<'tcx> ExistentialTraitRef<'tcx> {\n-    pub fn input_types<'b>(&'b self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'b {\n-        // Select only the \"input types\" from a trait-reference. For\n-        // now this is all the types that appear in the\n-        // trait-reference, but it should eventually exclude\n-        // associated types.\n-        self.substs.types()\n-    }\n-\n     pub fn erase_self_ty(\n         tcx: TyCtxt<'tcx>,\n         trait_ref: ty::TraitRef<'tcx>,\n@@ -2152,31 +2135,6 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Pushes onto `out` the regions directly referenced from this type (but not\n-    /// types reachable from this type via `walk_tys`). This ignores late-bound\n-    /// regions binders.\n-    pub fn push_regions(&self, out: &mut SmallVec<[ty::Region<'tcx>; 4]>) {\n-        match self.kind {\n-            Ref(region, _, _) => {\n-                out.push(region);\n-            }\n-            Dynamic(ref obj, region) => {\n-                out.push(region);\n-                if let Some(principal) = obj.principal() {\n-                    out.extend(principal.skip_binder().substs.regions());\n-                }\n-            }\n-            Adt(_, substs) | Opaque(_, substs) => out.extend(substs.regions()),\n-            Closure(_, ref substs) | Generator(_, ref substs, _) => out.extend(substs.regions()),\n-            Projection(ref data) | UnnormalizedProjection(ref data) => {\n-                out.extend(data.substs.regions())\n-            }\n-            FnDef(..) | FnPtr(_) | GeneratorWitness(..) | Bool | Char | Int(_) | Uint(_)\n-            | Float(_) | Str | Array(..) | Slice(_) | RawPtr(_) | Never | Tuple(..)\n-            | Foreign(..) | Param(_) | Bound(..) | Placeholder(..) | Infer(_) | Error => {}\n-        }\n-    }\n-\n     /// When we create a closure, we record its kind (i.e., what trait\n     /// it implements) into its `ClosureSubsts` using a type\n     /// parameter. This is kind of a phantom type, except that the"}, {"sha": "c7a317f39ad71a7f0db83246871ec77681950e6f", "filename": "src/librustc_middle/ty/walk.rs", "status": "modified", "additions": 131, "deletions": 88, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fwalk.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -1,25 +1,25 @@\n //! An iterator over the type substructure.\n //! WARNING: this does not keep track of the region depth.\n \n-use crate::ty::{self, Ty};\n+use crate::ty;\n+use crate::ty::subst::{GenericArg, GenericArgKind};\n use smallvec::{self, SmallVec};\n \n // The TypeWalker's stack is hot enough that it's worth going to some effort to\n // avoid heap allocations.\n-pub type TypeWalkerArray<'tcx> = [Ty<'tcx>; 8];\n-pub type TypeWalkerStack<'tcx> = SmallVec<TypeWalkerArray<'tcx>>;\n+type TypeWalkerStack<'tcx> = SmallVec<[GenericArg<'tcx>; 8]>;\n \n pub struct TypeWalker<'tcx> {\n     stack: TypeWalkerStack<'tcx>,\n     last_subtree: usize,\n }\n \n impl<'tcx> TypeWalker<'tcx> {\n-    pub fn new(ty: Ty<'tcx>) -> TypeWalker<'tcx> {\n-        TypeWalker { stack: smallvec![ty], last_subtree: 1 }\n+    pub fn new(root: GenericArg<'tcx>) -> TypeWalker<'tcx> {\n+        TypeWalker { stack: smallvec![root], last_subtree: 1 }\n     }\n \n-    /// Skips the subtree of types corresponding to the last type\n+    /// Skips the subtree corresponding to the last type\n     /// returned by `next()`.\n     ///\n     /// Example: Imagine you are walking `Foo<Bar<int>, usize>`.\n@@ -37,102 +37,145 @@ impl<'tcx> TypeWalker<'tcx> {\n }\n \n impl<'tcx> Iterator for TypeWalker<'tcx> {\n-    type Item = Ty<'tcx>;\n+    type Item = GenericArg<'tcx>;\n \n-    fn next(&mut self) -> Option<Ty<'tcx>> {\n+    fn next(&mut self) -> Option<GenericArg<'tcx>> {\n         debug!(\"next(): stack={:?}\", self.stack);\n-        match self.stack.pop() {\n-            None => None,\n-            Some(ty) => {\n-                self.last_subtree = self.stack.len();\n-                push_subtypes(&mut self.stack, ty);\n-                debug!(\"next: stack={:?}\", self.stack);\n-                Some(ty)\n-            }\n-        }\n+        let next = self.stack.pop()?;\n+        self.last_subtree = self.stack.len();\n+        push_inner(&mut self.stack, next);\n+        debug!(\"next: stack={:?}\", self.stack);\n+        Some(next)\n     }\n }\n \n-pub fn walk_shallow(ty: Ty<'_>) -> smallvec::IntoIter<TypeWalkerArray<'_>> {\n-    let mut stack = SmallVec::new();\n-    push_subtypes(&mut stack, ty);\n-    stack.into_iter()\n+impl GenericArg<'tcx> {\n+    /// Iterator that walks `self` and any types reachable from\n+    /// `self`, in depth-first order. Note that just walks the types\n+    /// that appear in `self`, it does not descend into the fields of\n+    /// structs or variants. For example:\n+    ///\n+    /// ```notrust\n+    /// isize => { isize }\n+    /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n+    /// [isize] => { [isize], isize }\n+    /// ```\n+    pub fn walk(self) -> TypeWalker<'tcx> {\n+        TypeWalker::new(self)\n+    }\n+\n+    /// Iterator that walks the immediate children of `self`. Hence\n+    /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n+    /// (but not `i32`, like `walk`).\n+    pub fn walk_shallow(self) -> impl Iterator<Item = GenericArg<'tcx>> {\n+        let mut stack = SmallVec::new();\n+        push_inner(&mut stack, self);\n+        stack.into_iter()\n+    }\n }\n \n-// We push types on the stack in reverse order so as to\n+impl<'tcx> super::TyS<'tcx> {\n+    /// Iterator that walks `self` and any types reachable from\n+    /// `self`, in depth-first order. Note that just walks the types\n+    /// that appear in `self`, it does not descend into the fields of\n+    /// structs or variants. For example:\n+    ///\n+    /// ```notrust\n+    /// isize => { isize }\n+    /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n+    /// [isize] => { [isize], isize }\n+    /// ```\n+    pub fn walk(&'tcx self) -> TypeWalker<'tcx> {\n+        TypeWalker::new(self.into())\n+    }\n+}\n+\n+// We push `GenericArg`s on the stack in reverse order so as to\n // maintain a pre-order traversal. As of the time of this\n // writing, the fact that the traversal is pre-order is not\n // known to be significant to any code, but it seems like the\n // natural order one would expect (basically, the order of the\n // types as they are written).\n-fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n-    match parent_ty.kind {\n-        ty::Bool\n-        | ty::Char\n-        | ty::Int(_)\n-        | ty::Uint(_)\n-        | ty::Float(_)\n-        | ty::Str\n-        | ty::Infer(_)\n-        | ty::Param(_)\n-        | ty::Never\n-        | ty::Error\n-        | ty::Placeholder(..)\n-        | ty::Bound(..)\n-        | ty::Foreign(..) => {}\n-        ty::Array(ty, len) => {\n-            if let ty::ConstKind::Unevaluated(_, substs, promoted) = len.val {\n-                assert!(promoted.is_none());\n-                stack.extend(substs.types().rev());\n+fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>) {\n+    match parent.unpack() {\n+        GenericArgKind::Type(parent_ty) => match parent_ty.kind {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Str\n+            | ty::Infer(_)\n+            | ty::Param(_)\n+            | ty::Never\n+            | ty::Error\n+            | ty::Placeholder(..)\n+            | ty::Bound(..)\n+            | ty::Foreign(..) => {}\n+\n+            ty::Array(ty, len) => {\n+                stack.push(len.into());\n+                stack.push(ty.into());\n             }\n-            stack.push(len.ty);\n-            stack.push(ty);\n-        }\n-        ty::Slice(ty) => {\n-            stack.push(ty);\n-        }\n-        ty::RawPtr(ref mt) => {\n-            stack.push(mt.ty);\n-        }\n-        ty::Ref(_, ty, _) => {\n-            stack.push(ty);\n-        }\n-        ty::Projection(ref data) | ty::UnnormalizedProjection(ref data) => {\n-            stack.extend(data.substs.types().rev());\n-        }\n-        ty::Dynamic(ref obj, ..) => {\n-            stack.extend(obj.iter().rev().flat_map(|predicate| {\n-                let (substs, opt_ty) = match *predicate.skip_binder() {\n-                    ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n-                    ty::ExistentialPredicate::Projection(p) => (p.substs, Some(p.ty)),\n-                    ty::ExistentialPredicate::AutoTrait(_) =>\n-                    // Empty iterator\n-                    {\n-                        (ty::InternalSubsts::empty(), None)\n-                    }\n-                };\n+            ty::Slice(ty) => {\n+                stack.push(ty.into());\n+            }\n+            ty::RawPtr(mt) => {\n+                stack.push(mt.ty.into());\n+            }\n+            ty::Ref(lt, ty, _) => {\n+                stack.push(ty.into());\n+                stack.push(lt.into());\n+            }\n+            ty::Projection(data) | ty::UnnormalizedProjection(data) => {\n+                stack.extend(data.substs.iter().copied().rev());\n+            }\n+            ty::Dynamic(obj, lt) => {\n+                stack.push(lt.into());\n+                stack.extend(obj.iter().rev().flat_map(|predicate| {\n+                    let (substs, opt_ty) = match *predicate.skip_binder() {\n+                        ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n+                        ty::ExistentialPredicate::Projection(p) => (p.substs, Some(p.ty)),\n+                        ty::ExistentialPredicate::AutoTrait(_) =>\n+                        // Empty iterator\n+                        {\n+                            (ty::InternalSubsts::empty(), None)\n+                        }\n+                    };\n \n-                substs.types().rev().chain(opt_ty)\n-            }));\n-        }\n-        ty::Adt(_, substs) | ty::Opaque(_, substs) => {\n-            stack.extend(substs.types().rev());\n-        }\n-        ty::Closure(_, ref substs) | ty::Generator(_, ref substs, _) => {\n-            stack.extend(substs.types().rev());\n-        }\n-        ty::GeneratorWitness(ts) => {\n-            stack.extend(ts.skip_binder().iter().cloned().rev());\n-        }\n-        ty::Tuple(..) => {\n-            stack.extend(parent_ty.tuple_fields().rev());\n-        }\n-        ty::FnDef(_, substs) => {\n-            stack.extend(substs.types().rev());\n-        }\n-        ty::FnPtr(sig) => {\n-            stack.push(sig.skip_binder().output());\n-            stack.extend(sig.skip_binder().inputs().iter().cloned().rev());\n+                    substs.iter().copied().rev().chain(opt_ty.map(|ty| ty.into()))\n+                }));\n+            }\n+            ty::Adt(_, substs)\n+            | ty::Opaque(_, substs)\n+            | ty::Closure(_, substs)\n+            | ty::Generator(_, substs, _)\n+            | ty::Tuple(substs)\n+            | ty::FnDef(_, substs) => {\n+                stack.extend(substs.iter().copied().rev());\n+            }\n+            ty::GeneratorWitness(ts) => {\n+                stack.extend(ts.skip_binder().iter().cloned().rev().map(|ty| ty.into()));\n+            }\n+            ty::FnPtr(sig) => {\n+                stack.push(sig.skip_binder().output().into());\n+                stack.extend(sig.skip_binder().inputs().iter().cloned().rev().map(|ty| ty.into()));\n+            }\n+        },\n+        GenericArgKind::Lifetime(_) => {}\n+        GenericArgKind::Const(parent_ct) => {\n+            stack.push(parent_ct.ty.into());\n+            match parent_ct.val {\n+                ty::ConstKind::Infer(_)\n+                | ty::ConstKind::Param(_)\n+                | ty::ConstKind::Placeholder(_)\n+                | ty::ConstKind::Bound(..)\n+                | ty::ConstKind::Value(_) => {}\n+\n+                ty::ConstKind::Unevaluated(_, substs, _) => {\n+                    stack.extend(substs.iter().copied().rev());\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "d8ceda96a25e1d4984188e94f38ea13870000b03", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -191,7 +191,7 @@ use rustc_middle::mir::visit::Visitor as MirVisitor;\n use rustc_middle::mir::{self, Local, Location};\n use rustc_middle::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc_middle::ty::print::obsolete::DefPathBasedNames;\n-use rustc_middle::ty::subst::InternalSubsts;\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, GenericParamDefKind, Instance, Ty, TyCtxt, TypeFoldable};\n use rustc_session::config::EntryFnType;\n use smallvec::SmallVec;\n@@ -442,9 +442,16 @@ fn check_recursion_limit<'tcx>(\n }\n \n fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n-    let type_length = instance.substs.types().flat_map(|ty| ty.walk()).count();\n-    let const_length = instance.substs.consts().flat_map(|ct| ct.ty.walk()).count();\n-    debug!(\" => type length={}, const length={}\", type_length, const_length);\n+    let type_length = instance\n+        .substs\n+        .iter()\n+        .flat_map(|&arg| arg.walk())\n+        .filter(|arg| match arg.unpack() {\n+            GenericArgKind::Type(_) | GenericArgKind::Const(_) => true,\n+            GenericArgKind::Lifetime(_) => false,\n+        })\n+        .count();\n+    debug!(\" => type length={}\", type_length);\n \n     // Rust code can easily create exponentially-long types using only a\n     // polynomial recursion depth. Even with the default recursion\n@@ -453,11 +460,7 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n     //\n     // Bail out in these cases to avoid that bad user experience.\n     let type_length_limit = *tcx.sess.type_length_limit.get();\n-    // We include the const length in the type length, as it's better\n-    // to be overly conservative.\n-    // FIXME(const_generics): we should instead uniformly walk through `substs`,\n-    // ignoring lifetimes.\n-    if type_length + const_length > type_length_limit {\n+    if type_length > type_length_limit {\n         // The instance name is already known to be too long for rustc.\n         // Show only the first and last 32 characters to avoid blasting\n         // the user's terminal with thousands of lines of type-name."}, {"sha": "8f7a1b948e3fd8f5a48ffc84c57ac1351937dd12", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -2,6 +2,7 @@ use rustc_attr as attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::*;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, adjustment::PointerCast, Predicate, Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n@@ -92,7 +93,15 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n }\n \n fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n-    for ty in ty.walk() {\n+    for arg in ty.walk() {\n+        let ty = match arg.unpack() {\n+            GenericArgKind::Type(ty) => ty,\n+\n+            // No constraints on lifetimes or constants, except potentially\n+            // constants' types, but `walk` will get to them as well.\n+            GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => continue,\n+        };\n+\n         match ty.kind {\n             ty::Ref(_, _, hir::Mutability::Mut) => {\n                 if !feature_allowed(tcx, fn_def_id, sym::const_mut_refs) {"}, {"sha": "f1311382c544771278c6adcbb34b33f1c301e7d9", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "modified", "additions": 57, "deletions": 22, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -14,6 +14,7 @@ use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n+use std::iter;\n \n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n@@ -378,26 +379,36 @@ fn orphan_check_trait_ref<'tcx>(\n         ty: Ty<'tcx>,\n         in_crate: InCrate,\n     ) -> Vec<Ty<'tcx>> {\n-        if fundamental_ty(ty) && ty_is_non_local(ty, in_crate).is_some() {\n-            ty.walk_shallow().flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate)).collect()\n-        } else {\n-            vec![ty]\n+        // FIXME(eddyb) figure out if this is redundant with `ty_is_non_local`,\n+        // or maybe if this should be calling `ty_is_non_local_constructor`.\n+        if ty_is_non_local(tcx, ty, in_crate).is_some() {\n+            if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n+                return inner_tys\n+                    .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n+                    .collect();\n+            }\n         }\n+\n+        vec![ty]\n     }\n \n     let mut non_local_spans = vec![];\n-    for (i, input_ty) in\n-        trait_ref.input_types().flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate)).enumerate()\n+    for (i, input_ty) in trait_ref\n+        .substs\n+        .types()\n+        .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n+        .enumerate()\n     {\n         debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n-        let non_local_tys = ty_is_non_local(input_ty, in_crate);\n+        let non_local_tys = ty_is_non_local(tcx, input_ty, in_crate);\n         if non_local_tys.is_none() {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n             return Ok(());\n         } else if let ty::Param(_) = input_ty.kind {\n             debug!(\"orphan_check_trait_ref: uncovered ty: `{:?}`\", input_ty);\n             let local_type = trait_ref\n-                .input_types()\n+                .substs\n+                .types()\n                 .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n                 .find(|ty| ty_is_non_local_constructor(ty, in_crate).is_none());\n \n@@ -416,30 +427,53 @@ fn orphan_check_trait_ref<'tcx>(\n     Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n }\n \n-fn ty_is_non_local<'t>(ty: Ty<'t>, in_crate: InCrate) -> Option<Vec<Ty<'t>>> {\n+fn ty_is_non_local(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, in_crate: InCrate) -> Option<Vec<Ty<'tcx>>> {\n     match ty_is_non_local_constructor(ty, in_crate) {\n         Some(ty) => {\n-            if !fundamental_ty(ty) {\n-                Some(vec![ty])\n-            } else {\n-                let tys: Vec<_> = ty\n-                    .walk_shallow()\n-                    .filter_map(|t| ty_is_non_local(t, in_crate))\n-                    .flat_map(|i| i)\n+            if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n+                let tys: Vec<_> = inner_tys\n+                    .filter_map(|ty| ty_is_non_local(tcx, ty, in_crate))\n+                    .flatten()\n                     .collect();\n                 if tys.is_empty() { None } else { Some(tys) }\n+            } else {\n+                Some(vec![ty])\n             }\n         }\n         None => None,\n     }\n }\n \n-fn fundamental_ty(ty: Ty<'_>) -> bool {\n-    match ty.kind {\n-        ty::Ref(..) => true,\n-        ty::Adt(def, _) => def.is_fundamental(),\n-        _ => false,\n-    }\n+/// For `#[fundamental]` ADTs and `&T` / `&mut T`, returns `Some` with the\n+/// type parameters of the ADT, or `T`, respectively. For non-fundamental\n+/// types, returns `None`.\n+fn fundamental_ty_inner_tys(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<impl Iterator<Item = Ty<'tcx>>> {\n+    let (first_ty, rest_tys) = match ty.kind {\n+        ty::Ref(_, ty, _) => (ty, ty::subst::InternalSubsts::empty().types()),\n+        ty::Adt(def, substs) if def.is_fundamental() => {\n+            let mut types = substs.types();\n+\n+            // FIXME(eddyb) actually validate `#[fundamental]` up-front.\n+            match types.next() {\n+                None => {\n+                    tcx.sess.span_err(\n+                        tcx.def_span(def.did),\n+                        \"`#[fundamental]` requires at least one type parameter\",\n+                    );\n+\n+                    return None;\n+                }\n+\n+                Some(first_ty) => (first_ty, types),\n+            }\n+        }\n+        _ => return None,\n+    };\n+\n+    Some(iter::once(first_ty).chain(rest_tys))\n }\n \n fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n@@ -451,6 +485,7 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n     }\n }\n \n+// FIXME(eddyb) this can just return `bool` as it always returns `Some(ty)` or `None`.\n fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>> {\n     debug!(\"ty_is_non_local_constructor({:?})\", ty);\n "}, {"sha": "49a4b96f8b7a1ca9563630214548b0899dd51992", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -536,18 +536,17 @@ fn trait_ref_type_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> Vec<TyOrConstInferVar<'tcx>> {\n-    trait_ref\n+    selcx\n+        .infcx()\n+        .resolve_vars_if_possible(&trait_ref)\n         .skip_binder() // ok b/c this check doesn't care about regions\n-        // FIXME(eddyb) walk over `GenericArg` to support const infer vars.\n-        .input_types()\n-        .map(|ty| selcx.infcx().resolve_vars_if_possible(&ty))\n-        // FIXME(eddyb) try using `maybe_walk` to skip *all* subtrees that\n-        // don't contain inference variables, not just the outermost level.\n-        // FIXME(eddyb) use `has_infer_types_or_const`.\n-        .filter(|ty| ty.has_infer_types())\n-        .flat_map(|ty| ty.walk())\n-        // FIXME(eddyb) use `TyOrConstInferVar::maybe_from_generic_arg`.\n-        .filter_map(TyOrConstInferVar::maybe_from_ty)\n+        .substs\n+        .iter()\n+        // FIXME(eddyb) try using `skip_current_subtree` to skip everything that\n+        // doesn't contain inference variables, not just the outermost level.\n+        .filter(|arg| arg.has_infer_types_or_consts())\n+        .flat_map(|arg| arg.walk())\n+        .filter_map(TyOrConstInferVar::maybe_from_generic_arg)\n         .collect()\n }\n "}, {"sha": "d9a5b68dc1eb9d84c5ae2d9b8f7ecbc8acabf72b", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -16,7 +16,7 @@ use crate::traits::{self, Obligation, ObligationCause};\n use rustc_errors::{Applicability, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n use rustc_span::symbol::Symbol;\n@@ -234,7 +234,7 @@ fn predicates_reference_self(\n         tcx.predicates_of(trait_def_id)\n     };\n     let self_ty = tcx.types.self_param;\n-    let has_self_ty = |t: Ty<'_>| t.walk().any(|t| t == self_ty);\n+    let has_self_ty = |arg: &GenericArg<'_>| arg.walk().any(|arg| arg == self_ty.into());\n     predicates\n         .predicates\n         .iter()\n@@ -243,7 +243,7 @@ fn predicates_reference_self(\n             match predicate {\n                 ty::Predicate::Trait(ref data, _) => {\n                     // In the case of a trait predicate, we can skip the \"self\" type.\n-                    if data.skip_binder().input_types().skip(1).any(has_self_ty) {\n+                    if data.skip_binder().trait_ref.substs[1..].iter().any(has_self_ty) {\n                         Some(sp)\n                     } else {\n                         None\n@@ -262,12 +262,8 @@ fn predicates_reference_self(\n                     //\n                     // This is ALT2 in issue #56288, see that for discussion of the\n                     // possible alternatives.\n-                    if data\n-                        .skip_binder()\n-                        .projection_ty\n-                        .trait_ref(tcx)\n-                        .input_types()\n-                        .skip(1)\n+                    if data.skip_binder().projection_ty.trait_ref(tcx).substs[1..]\n+                        .iter()\n                         .any(has_self_ty)\n                     {\n                         Some(sp)\n@@ -725,19 +721,17 @@ fn contains_illegal_self_type_reference<'tcx>(\n     // without knowing what `Self` is.\n \n     let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n-    let mut error = false;\n     let self_ty = tcx.types.self_param;\n-    ty.maybe_walk(|ty| {\n-        match ty.kind {\n-            ty::Param(_) => {\n-                if ty == self_ty {\n-                    error = true;\n-                }\n \n-                false // no contained types to walk\n-            }\n+    let mut walker = ty.walk();\n+    while let Some(arg) = walker.next() {\n+        if arg == self_ty.into() {\n+            return true;\n+        }\n \n-            ty::Projection(ref data) => {\n+        // Special-case projections (everything else is walked normally).\n+        if let GenericArgKind::Type(ty) = arg.unpack() {\n+            if let ty::Projection(ref data) = ty.kind {\n                 // This is a projected type `<Foo as SomeTrait>::X`.\n \n                 // Compute supertraits of current trait lazily.\n@@ -759,17 +753,18 @@ fn contains_illegal_self_type_reference<'tcx>(\n                     supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n \n                 if is_supertrait_of_current_trait {\n-                    false // do not walk contained types, do not report error, do collect $200\n-                } else {\n-                    true // DO walk contained types, POSSIBLY reporting an error\n+                    // Do not walk contained types, do not report error, do collect $200.\n+                    walker.skip_current_subtree();\n                 }\n-            }\n \n-            _ => true, // walk contained types, if any\n+                // DO walk contained types, POSSIBLY reporting an error.\n+            }\n         }\n-    });\n \n-    error\n+        // Walk contained types, if any.\n+    }\n+\n+    false\n }\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {"}, {"sha": "84c264f06db287848cc04016ee396d32d56c0e17", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 75, "deletions": 50, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -44,7 +44,7 @@ use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::subst::{Subst, SubstsRef};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n use rustc_middle::ty::{\n     self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n@@ -652,7 +652,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        // In intercrate mode, whenever any of the types are unbound,\n+        // In intercrate mode, whenever any of the generics are unbound,\n         // there can always be an impl. Even if there are no impls in\n         // this crate, perhaps the type would be unified with\n         // something from another crate that does provide an impl.\n@@ -677,7 +677,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n         let unbound_input_types =\n-            stack.fresh_trait_ref.skip_binder().input_types().any(|ty| ty.is_fresh());\n+            stack.fresh_trait_ref.skip_binder().substs.types().any(|ty| ty.is_fresh());\n         // This check was an imperfect workaround for a bug in the old\n         // intercrate mode; it should be removed when that goes away.\n         if unbound_input_types && self.intercrate {\n@@ -1242,9 +1242,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         result: &SelectionResult<'tcx, SelectionCandidate<'tcx>>,\n     ) -> bool {\n         match result {\n-            Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => {\n-                !trait_ref.skip_binder().input_types().any(|t| t.walk().any(|t_| t_.is_ty_infer()))\n-            }\n+            Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => !trait_ref.has_local_value(),\n             _ => true,\n         }\n     }\n@@ -3048,68 +3046,79 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             // `Struct<T>` -> `Struct<U>`\n             (&ty::Adt(def, substs_a), &ty::Adt(_, substs_b)) => {\n-                let fields =\n-                    def.all_fields().map(|field| tcx.type_of(field.did)).collect::<Vec<_>>();\n-\n-                // The last field of the structure has to exist and contain type parameters.\n-                let field = if let Some(&field) = fields.last() {\n-                    field\n-                } else {\n-                    return Err(Unimplemented);\n+                let maybe_unsizing_param_idx = |arg: GenericArg<'tcx>| match arg.unpack() {\n+                    GenericArgKind::Type(ty) => match ty.kind {\n+                        ty::Param(p) => Some(p.index),\n+                        _ => None,\n+                    },\n+\n+                    // Lifetimes aren't allowed to change during unsizing.\n+                    GenericArgKind::Lifetime(_) => None,\n+\n+                    GenericArgKind::Const(ct) => match ct.val {\n+                        ty::ConstKind::Param(p) => Some(p.index),\n+                        _ => None,\n+                    },\n                 };\n-                let mut ty_params = GrowableBitSet::new_empty();\n+\n+                // The last field of the structure has to exist and contain type/const parameters.\n+                let (tail_field, prefix_fields) =\n+                    def.non_enum_variant().fields.split_last().ok_or(Unimplemented)?;\n+                let tail_field_ty = tcx.type_of(tail_field.did);\n+\n+                let mut unsizing_params = GrowableBitSet::new_empty();\n                 let mut found = false;\n-                for ty in field.walk() {\n-                    if let ty::Param(p) = ty.kind {\n-                        ty_params.insert(p.index as usize);\n+                for arg in tail_field_ty.walk() {\n+                    if let Some(i) = maybe_unsizing_param_idx(arg) {\n+                        unsizing_params.insert(i);\n                         found = true;\n                     }\n                 }\n                 if !found {\n                     return Err(Unimplemented);\n                 }\n \n-                // Replace type parameters used in unsizing with\n-                // Error and ensure they do not affect any other fields.\n-                // This could be checked after type collection for any struct\n-                // with a potentially unsized trailing field.\n-                let params = substs_a\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, &k)| if ty_params.contains(i) { tcx.types.err.into() } else { k });\n-                let substs = tcx.mk_substs(params);\n-                for &ty in fields.split_last().unwrap().1 {\n-                    if ty.subst(tcx, substs).references_error() {\n-                        return Err(Unimplemented);\n+                // Ensure none of the other fields mention the parameters used\n+                // in unsizing.\n+                // FIXME(eddyb) cache this (including computing `unsizing_params`)\n+                // by putting it in a query; it would only need the `DefId` as it\n+                // looks at declared field types, not anything substituted.\n+                for field in prefix_fields {\n+                    for arg in tcx.type_of(field.did).walk() {\n+                        if let Some(i) = maybe_unsizing_param_idx(arg) {\n+                            if unsizing_params.contains(i) {\n+                                return Err(Unimplemented);\n+                            }\n+                        }\n                     }\n                 }\n \n-                // Extract `Field<T>` and `Field<U>` from `Struct<T>` and `Struct<U>`.\n-                let inner_source = field.subst(tcx, substs_a);\n-                let inner_target = field.subst(tcx, substs_b);\n+                // Extract `TailField<T>` and `TailField<U>` from `Struct<T>` and `Struct<U>`.\n+                let source_tail = tail_field_ty.subst(tcx, substs_a);\n+                let target_tail = tail_field_ty.subst(tcx, substs_b);\n \n                 // Check that the source struct with the target's\n-                // unsized parameters is equal to the target.\n-                let params = substs_a.iter().enumerate().map(|(i, &k)| {\n-                    if ty_params.contains(i) { substs_b.type_at(i).into() } else { k }\n-                });\n-                let new_struct = tcx.mk_adt(def, tcx.mk_substs(params));\n+                // unsizing parameters is equal to the target.\n+                let substs = tcx.mk_substs(substs_a.iter().enumerate().map(|(i, &k)| {\n+                    if unsizing_params.contains(i as u32) { substs_b[i] } else { k }\n+                }));\n+                let new_struct = tcx.mk_adt(def, substs);\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n                     .eq(target, new_struct)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n-                // Construct the nested `Field<T>: Unsize<Field<U>>` predicate.\n+                // Construct the nested `TailField<T>: Unsize<TailField<U>>` predicate.\n                 nested.push(predicate_for_trait_def(\n                     tcx,\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.predicate.def_id(),\n                     obligation.recursion_depth + 1,\n-                    inner_source,\n-                    &[inner_target.into()],\n+                    source_tail,\n+                    &[target_tail.into()],\n                 ));\n             }\n \n@@ -3253,15 +3262,31 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // substitution if we find that any of the input types, when\n         // simplified, do not match.\n \n-        obligation.predicate.skip_binder().input_types().zip(impl_trait_ref.input_types()).any(\n-            |(obligation_ty, impl_ty)| {\n-                let simplified_obligation_ty =\n-                    fast_reject::simplify_type(self.tcx(), obligation_ty, true);\n-                let simplified_impl_ty = fast_reject::simplify_type(self.tcx(), impl_ty, false);\n-\n-                simplified_obligation_ty.is_some()\n-                    && simplified_impl_ty.is_some()\n-                    && simplified_obligation_ty != simplified_impl_ty\n+        obligation.predicate.skip_binder().trait_ref.substs.iter().zip(impl_trait_ref.substs).any(\n+            |(obligation_arg, impl_arg)| {\n+                match (obligation_arg.unpack(), impl_arg.unpack()) {\n+                    (GenericArgKind::Type(obligation_ty), GenericArgKind::Type(impl_ty)) => {\n+                        let simplified_obligation_ty =\n+                            fast_reject::simplify_type(self.tcx(), obligation_ty, true);\n+                        let simplified_impl_ty =\n+                            fast_reject::simplify_type(self.tcx(), impl_ty, false);\n+\n+                        simplified_obligation_ty.is_some()\n+                            && simplified_impl_ty.is_some()\n+                            && simplified_obligation_ty != simplified_impl_ty\n+                    }\n+                    (GenericArgKind::Lifetime(_), GenericArgKind::Lifetime(_)) => {\n+                        // Lifetimes can never cause a rejection.\n+                        false\n+                    }\n+                    (GenericArgKind::Const(_), GenericArgKind::Const(_)) => {\n+                        // Conservatively ignore consts (i.e. assume they might\n+                        // unify later) until we have `fast_reject` support for\n+                        // them (if we'll ever need it, even).\n+                        false\n+                    }\n+                    _ => unreachable!(),\n+                }\n             },\n         )\n     }"}, {"sha": "6b38749e1e70ab4afb7d5a3f344401849a5d7240", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -4,7 +4,7 @@ use crate::traits::{self, AssocTypeBoundData};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items;\n-use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n@@ -391,9 +391,21 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     /// is WF. Returns false if `ty0` is an unresolved type variable,\n     /// in which case we are not able to simplify at all.\n     fn compute(&mut self, ty0: Ty<'tcx>) -> bool {\n-        let mut subtys = ty0.walk();\n+        let mut walker = ty0.walk();\n         let param_env = self.param_env;\n-        while let Some(ty) = subtys.next() {\n+        while let Some(arg) = walker.next() {\n+            let ty = match arg.unpack() {\n+                GenericArgKind::Type(ty) => ty,\n+\n+                // No WF constraints for lifetimes being present, any outlives\n+                // obligations are handled by the parent (e.g. `ty::Ref`).\n+                GenericArgKind::Lifetime(_) => continue,\n+\n+                // FIXME(eddyb) this is wrong and needs to be replaced\n+                // (see https://github.com/rust-lang/rust/pull/70107).\n+                GenericArgKind::Const(_) => continue,\n+            };\n+\n             match ty.kind {\n                 ty::Bool\n                 | ty::Char\n@@ -417,6 +429,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n                 ty::Array(subty, len) => {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n+                    // FIXME(eddyb) handle `GenericArgKind::Const` above instead.\n                     self.compute_array_len(*len);\n                 }\n \n@@ -433,7 +446,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 }\n \n                 ty::Projection(data) => {\n-                    subtys.skip_current_subtree(); // subtree handled by compute_projection\n+                    walker.skip_current_subtree(); // subtree handled by compute_projection\n                     self.compute_projection(data);\n                 }\n \n@@ -504,7 +517,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // are not directly inspecting closure types\n                     // anyway, except via auto trait matching (which\n                     // only inspects the upvar types).\n-                    subtys.skip_current_subtree(); // subtree handled by compute_projection\n+                    walker.skip_current_subtree(); // subtree handled by compute_projection\n                     for upvar_ty in substs.as_closure().upvar_tys() {\n                         self.compute(upvar_ty);\n                     }"}, {"sha": "612ab9b70ebc9d061735a80ab8b2e70121b459bc", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -3,6 +3,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::traits::{\n     Clause, Clauses, DomainGoal, Environment, FromEnv, ProgramClause, ProgramClauseCategory,\n };\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n struct ClauseVisitor<'a, 'tcx> {\n@@ -210,22 +211,23 @@ crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n         _ => NodeKind::Other,\n     };\n \n-    let mut input_tys = FxHashSet::default();\n+    // FIXME(eddyb) isn't the unordered nature of this a hazard?\n+    let mut inputs = FxHashSet::default();\n \n     match node_kind {\n         // In a trait impl, we assume that the header trait ref and all its\n         // constituents are well-formed.\n         NodeKind::TraitImpl => {\n             let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n \n-            input_tys.extend(trait_ref.input_types().flat_map(|ty| ty.walk()));\n+            inputs.extend(trait_ref.substs.iter().flat_map(|&arg| arg.walk()));\n         }\n \n         // In an inherent impl, we assume that the receiver type and all its\n         // constituents are well-formed.\n         NodeKind::InherentImpl => {\n             let self_ty = tcx.type_of(def_id);\n-            input_tys.extend(self_ty.walk());\n+            inputs.extend(self_ty.walk());\n         }\n \n         // In an fn, we assume that the arguments and all their constituents are\n@@ -234,16 +236,27 @@ crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n             let fn_sig = tcx.fn_sig(def_id);\n             let fn_sig = tcx.liberate_late_bound_regions(def_id, &fn_sig);\n \n-            input_tys.extend(fn_sig.inputs().iter().flat_map(|ty| ty.walk()));\n+            inputs.extend(fn_sig.inputs().iter().flat_map(|ty| ty.walk()));\n         }\n \n         NodeKind::Other => (),\n     }\n \n     let clauses = clauses.chain(\n-        input_tys\n+        inputs\n             .into_iter()\n-            .map(|ty| DomainGoal::FromEnv(FromEnv::Ty(ty)))\n+            .filter_map(|arg| {\n+                match arg.unpack() {\n+                    GenericArgKind::Type(ty) => Some(FromEnv::Ty(ty)),\n+\n+                    // FIXME(eddyb) no WF conditions from lifetimes?\n+                    GenericArgKind::Lifetime(_) => None,\n+\n+                    // FIXME(eddyb) support const generics in Chalk\n+                    GenericArgKind::Const(_) => None,\n+                }\n+            })\n+            .map(DomainGoal::FromEnv)\n             .map(|domain_goal| domain_goal.into_program_clause())\n             .map(Clause::Implies),\n     );"}, {"sha": "ed7ec1c3b10da39e99e72279d0e68aa86fd02265", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -737,8 +737,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let default_needs_object_self = |param: &ty::GenericParamDef| {\n             if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n                 if is_object && has_default {\n+                    let default_ty = tcx.at(span).type_of(param.def_id);\n                     let self_param = tcx.types.self_param;\n-                    if tcx.at(span).type_of(param.def_id).walk().any(|ty| ty == self_param) {\n+                    if default_ty.walk().any(|arg| arg == self_param.into()) {\n                         // There is no suitable inference default for a type parameter\n                         // that references self, in an object type.\n                         return true;\n@@ -1617,7 +1618,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ty::Predicate::Projection(pred) => {\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n-                        let references_self = pred.skip_binder().ty.walk().any(|t| t == dummy_self);\n+                        let references_self =\n+                            pred.skip_binder().ty.walk().any(|arg| arg == dummy_self.into());\n \n                         // If the projection output contains `Self`, force the user to\n                         // elaborate it explicitly to avoid a lot of complexity."}, {"sha": "ff3493eb6de6d642aa24cc0cddc79c91e0ef00ae", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -563,30 +563,30 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         while !queue.is_empty() {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let trait_ref = match obligation.predicate {\n-                ty::Predicate::Trait(ref tr, _) if traits.contains(&tr.def_id()) => {\n-                    if unsize_did == tr.def_id() {\n-                        let sty = &tr.skip_binder().input_types().nth(1).unwrap().kind;\n-                        if let ty::Tuple(..) = sty {\n+            let trait_pred = match obligation.predicate {\n+                ty::Predicate::Trait(trait_pred, _) if traits.contains(&trait_pred.def_id()) => {\n+                    if unsize_did == trait_pred.def_id() {\n+                        let unsize_ty = trait_pred.skip_binder().trait_ref.substs[1].expect_ty();\n+                        if let ty::Tuple(..) = unsize_ty.kind {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n                             has_unsized_tuple_coercion = true;\n                         }\n                     }\n-                    *tr\n+                    trait_pred\n                 }\n                 _ => {\n                     coercion.obligations.push(obligation);\n                     continue;\n                 }\n             };\n-            match selcx.select(&obligation.with(trait_ref)) {\n+            match selcx.select(&obligation.with(trait_pred)) {\n                 // Uncertain or unimplemented.\n                 Ok(None) => {\n-                    if trait_ref.def_id() == unsize_did {\n-                        let trait_ref = self.resolve_vars_if_possible(&trait_ref);\n-                        let self_ty = trait_ref.skip_binder().self_ty();\n-                        let unsize_ty = trait_ref.skip_binder().input_types().nth(1).unwrap();\n-                        debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_ref);\n+                    if trait_pred.def_id() == unsize_did {\n+                        let trait_pred = self.resolve_vars_if_possible(&trait_pred);\n+                        let self_ty = trait_pred.skip_binder().self_ty();\n+                        let unsize_ty = trait_pred.skip_binder().trait_ref.substs[1].expect_ty();\n+                        debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_pred);\n                         match (&self_ty.kind, &unsize_ty.kind) {\n                             (ty::Infer(ty::TyVar(v)), ty::Dynamic(..))\n                                 if self.type_var_is_sized(*v) =>"}, {"sha": "eebc34d3db8eac479cb53d146339214d8c6aceb0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -102,6 +102,7 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items;\n use rustc_hir::{ExprKind, GenericArg, HirIdMap, Item, ItemKind, Node, PatKind, QPath};\n+use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n@@ -1767,7 +1768,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n             let pty_ty = tcx.type_of(def_id);\n             let generics = tcx.generics_of(def_id);\n-            check_bounds_are_used(tcx, &generics, pty_ty);\n+            check_type_params_are_used(tcx, &generics, pty_ty);\n         }\n         hir::ItemKind::ForeignMod(ref m) => {\n             check_abi(tcx, it.span, m.abi);\n@@ -4139,20 +4140,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // `FulfillmentError`.\n                 let mut referenced_in = final_arg_types\n                     .iter()\n-                    .map(|(i, checked_ty, _)| (i, checked_ty))\n-                    .chain(final_arg_types.iter().map(|(i, _, coerced_ty)| (i, coerced_ty)))\n+                    .map(|&(i, checked_ty, _)| (i, checked_ty))\n+                    .chain(final_arg_types.iter().map(|&(i, _, coerced_ty)| (i, coerced_ty)))\n                     .flat_map(|(i, ty)| {\n-                        let ty = self.resolve_vars_if_possible(ty);\n+                        let ty = self.resolve_vars_if_possible(&ty);\n                         // We walk the argument type because the argument's type could have\n                         // been `Option<T>`, but the `FulfillmentError` references `T`.\n-                        ty.walk()\n-                            .filter(|&ty| ty == predicate.skip_binder().self_ty())\n-                            .map(move |_| *i)\n+                        if ty.walk().any(|arg| arg == predicate.skip_binder().self_ty().into()) {\n+                            Some(i)\n+                        } else {\n+                            None\n+                        }\n                     })\n                     .collect::<Vec<_>>();\n \n                 // Both checked and coerced types could have matched, thus we need to remove\n                 // duplicates.\n+                referenced_in.sort();\n                 referenced_in.dedup();\n \n                 if let (Some(ref_in), None) = (referenced_in.pop(), referenced_in.pop()) {\n@@ -5744,43 +5748,47 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_bounds_are_used<'tcx>(tcx: TyCtxt<'tcx>, generics: &ty::Generics, ty: Ty<'tcx>) {\n-    let own_counts = generics.own_counts();\n-    debug!(\n-        \"check_bounds_are_used(n_tys={}, n_cts={}, ty={:?})\",\n-        own_counts.types, own_counts.consts, ty\n-    );\n+fn check_type_params_are_used<'tcx>(tcx: TyCtxt<'tcx>, generics: &ty::Generics, ty: Ty<'tcx>) {\n+    debug!(\"check_type_params_are_used(generics={:?}, ty={:?})\", generics, ty);\n+\n+    assert_eq!(generics.parent, None);\n \n-    if own_counts.types == 0 {\n+    if generics.own_counts().types == 0 {\n         return;\n     }\n \n-    // Make a vector of booleans initially `false`; set to `true` when used.\n-    let mut types_used = vec![false; own_counts.types];\n+    let mut params_used = BitSet::new_empty(generics.params.len());\n \n-    for leaf_ty in ty.walk() {\n-        if let ty::Param(ty::ParamTy { index, .. }) = leaf_ty.kind {\n-            debug!(\"found use of ty param num {}\", index);\n-            types_used[index as usize - own_counts.lifetimes] = true;\n-        } else if let ty::Error = leaf_ty.kind {\n-            // If there is already another error, do not emit\n-            // an error for not using a type parameter.\n-            assert!(tcx.sess.has_errors());\n-            return;\n+    if ty.references_error() {\n+        // If there is already another error, do not emit\n+        // an error for not using a type parameter.\n+        assert!(tcx.sess.has_errors());\n+        return;\n+    }\n+\n+    for leaf in ty.walk() {\n+        if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n+            if let ty::Param(param) = leaf_ty.kind {\n+                debug!(\"found use of ty param {:?}\", param);\n+                params_used.insert(param.index);\n+            }\n         }\n     }\n \n-    let types = generics.params.iter().filter(|param| match param.kind {\n-        ty::GenericParamDefKind::Type { .. } => true,\n-        _ => false,\n-    });\n-    for (&used, param) in types_used.iter().zip(types) {\n-        if !used {\n-            let id = tcx.hir().as_local_hir_id(param.def_id).unwrap();\n-            let span = tcx.hir().span(id);\n-            struct_span_err!(tcx.sess, span, E0091, \"type parameter `{}` is unused\", param.name)\n+    for param in &generics.params {\n+        if !params_used.contains(param.index) {\n+            if let ty::GenericParamDefKind::Type { .. } = param.kind {\n+                let span = tcx.def_span(param.def_id);\n+                struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0091,\n+                    \"type parameter `{}` is unused\",\n+                    param.name,\n+                )\n                 .span_label(span, \"unused type parameter\")\n                 .emit();\n+            }\n         }\n     }\n }"}, {"sha": "2abca30246905ebd28504c4da8f8092db519072b", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -119,7 +119,15 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n     required_predicates: &mut RequiredPredicates<'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n ) {\n-    for ty in field_ty.walk() {\n+    for arg in field_ty.walk() {\n+        let ty = match arg.unpack() {\n+            GenericArgKind::Type(ty) => ty,\n+\n+            // No predicates from lifetimes or constants, except potentially\n+            // constants' types, but `walk` will get to them as well.\n+            GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => continue,\n+        };\n+\n         match ty.kind {\n             // The field is of type &'a T which means that we will have\n             // a predicate requirement of T: 'a (T outlives 'a).\n@@ -303,7 +311,7 @@ pub fn check_explicit_predicates<'tcx>(\n         // 'b`.\n         if let Some(self_ty) = ignored_self_ty {\n             if let GenericArgKind::Type(ty) = outlives_predicate.0.unpack() {\n-                if ty.walk().any(|ty| ty == self_ty) {\n+                if ty.walk().any(|arg| arg == self_ty.into()) {\n                     debug!(\"skipping self ty = {:?}\", &ty);\n                     continue;\n                 }"}, {"sha": "eb8aec708a63993bc284b491e0b43dda6fdee84f", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -315,25 +315,28 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         pred: ty::Predicate<'tcx>,\n     ) -> FxHashSet<GenericParamDef> {\n-        pred.walk_tys()\n-            .flat_map(|t| {\n-                let mut regions = FxHashSet::default();\n-                tcx.collect_regions(&t, &mut regions);\n-\n-                regions.into_iter().flat_map(|r| {\n-                    match r {\n-                        // We only care about late bound regions, as we need to add them\n-                        // to the 'for<>' section\n-                        &ty::ReLateBound(_, ty::BoundRegion::BrNamed(_, name)) => {\n-                            Some(GenericParamDef {\n-                                name: name.to_string(),\n-                                kind: GenericParamDefKind::Lifetime,\n-                            })\n-                        }\n-                        &ty::ReVar(_) | &ty::ReEarlyBound(_) | &ty::ReStatic => None,\n-                        _ => panic!(\"Unexpected region type {:?}\", r),\n-                    }\n-                })\n+        let regions = match pred {\n+            ty::Predicate::Trait(poly_trait_pred, _) => {\n+                tcx.collect_referenced_late_bound_regions(&poly_trait_pred)\n+            }\n+            ty::Predicate::Projection(poly_proj_pred) => {\n+                tcx.collect_referenced_late_bound_regions(&poly_proj_pred)\n+            }\n+            _ => return FxHashSet::default(),\n+        };\n+\n+        regions\n+            .into_iter()\n+            .filter_map(|br| {\n+                match br {\n+                    // We only care about named late bound regions, as we need to add them\n+                    // to the 'for<>' section\n+                    ty::BrNamed(_, name) => Some(GenericParamDef {\n+                        name: name.to_string(),\n+                        kind: GenericParamDefKind::Lifetime,\n+                    }),\n+                    _ => None,\n+                }\n             })\n             .collect()\n     }"}, {"sha": "5c35dc5513266482dd4e63878e23ed637c601b3c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -84,15 +84,6 @@ impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n     }\n }\n \n-impl<T, U> Clean<U> for ty::Binder<T>\n-where\n-    T: Clean<U>,\n-{\n-    fn clean(&self, cx: &DocContext<'_>) -> U {\n-        self.skip_binder().clean(cx)\n-    }\n-}\n-\n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext<'_>) -> ExternalCrate {\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n@@ -305,59 +296,66 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n     }\n }\n \n-impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>) {\n-    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n-        let (trait_ref, ref bounds) = *self;\n+impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n+    fn clean(&self, cx: &DocContext<'_>) -> Type {\n+        let (trait_ref, bounds) = *self;\n         inline::record_extern_fqn(cx, trait_ref.def_id, TypeKind::Trait);\n         let path = external_path(\n             cx,\n             cx.tcx.item_name(trait_ref.def_id),\n             Some(trait_ref.def_id),\n             true,\n-            bounds.clone(),\n+            bounds.to_vec(),\n             trait_ref.substs,\n         );\n \n         debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n \n+        ResolvedPath { path, param_names: None, did: trait_ref.def_id, is_generic: false }\n+    }\n+}\n+\n+impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n+    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n+        GenericBound::TraitBound(\n+            PolyTrait { trait_: (*self, &[][..]).clean(cx), generic_params: vec![] },\n+            hir::TraitBoundModifier::None,\n+        )\n+    }\n+}\n+\n+impl Clean<GenericBound> for (ty::PolyTraitRef<'_>, &[TypeBinding]) {\n+    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n+        let (poly_trait_ref, bounds) = *self;\n+        let poly_trait_ref = poly_trait_ref.lift_to_tcx(cx.tcx).unwrap();\n+\n         // collect any late bound regions\n-        let mut late_bounds = vec![];\n-        for ty_s in trait_ref.input_types().skip(1) {\n-            if let ty::Tuple(ts) = ty_s.kind {\n-                for &ty_s in ts {\n-                    if let ty::Ref(ref reg, _, _) = ty_s.expect_ty().kind {\n-                        if let &ty::RegionKind::ReLateBound(..) = *reg {\n-                            debug!(\"  hit an ReLateBound {:?}\", reg);\n-                            if let Some(Lifetime(name)) = reg.clean(cx) {\n-                                late_bounds.push(GenericParamDef {\n-                                    name,\n-                                    kind: GenericParamDefKind::Lifetime,\n-                                });\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+        let late_bound_regions: Vec<_> = cx\n+            .tcx\n+            .collect_referenced_late_bound_regions(&poly_trait_ref)\n+            .into_iter()\n+            .filter_map(|br| match br {\n+                ty::BrNamed(_, name) => Some(GenericParamDef {\n+                    name: name.to_string(),\n+                    kind: GenericParamDefKind::Lifetime,\n+                }),\n+                _ => None,\n+            })\n+            .collect();\n \n         GenericBound::TraitBound(\n             PolyTrait {\n-                trait_: ResolvedPath {\n-                    path,\n-                    param_names: None,\n-                    did: trait_ref.def_id,\n-                    is_generic: false,\n-                },\n-                generic_params: late_bounds,\n+                trait_: (*poly_trait_ref.skip_binder(), bounds).clean(cx),\n+                generic_params: late_bound_regions,\n             },\n             hir::TraitBoundModifier::None,\n         )\n     }\n }\n \n-impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n+impl<'tcx> Clean<GenericBound> for ty::PolyTraitRef<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n-        (self, vec![]).clean(cx)\n+        (*self, &[][..]).clean(cx)\n     }\n }\n \n@@ -495,16 +493,17 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     }\n }\n \n-impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n+impl<'a> Clean<WherePredicate> for ty::PolyTraitPredicate<'a> {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n+        let poly_trait_ref = self.map_bound(|pred| pred.trait_ref);\n         WherePredicate::BoundPredicate {\n-            ty: self.trait_ref.self_ty().clean(cx),\n-            bounds: vec![self.trait_ref.clean(cx)],\n+            ty: poly_trait_ref.self_ty().clean(cx),\n+            bounds: vec![poly_trait_ref.clean(cx)],\n         }\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n+impl<'tcx> Clean<WherePredicate> for ty::PolySubtypePredicate<'tcx> {\n     fn clean(&self, _cx: &DocContext<'_>) -> WherePredicate {\n         panic!(\n             \"subtype predicates are an internal rustc artifact \\\n@@ -514,10 +513,10 @@ impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n }\n \n impl<'tcx> Clean<Option<WherePredicate>>\n-    for ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n+    for ty::PolyOutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        let ty::OutlivesPredicate(ref a, ref b) = *self;\n+        let ty::OutlivesPredicate(a, b) = self.skip_binder();\n \n         if let (ty::ReEmpty(_), ty::ReEmpty(_)) = (a, b) {\n             return None;\n@@ -530,9 +529,9 @@ impl<'tcx> Clean<Option<WherePredicate>>\n     }\n }\n \n-impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n+impl<'tcx> Clean<Option<WherePredicate>> for ty::PolyOutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n+        let ty::OutlivesPredicate(ty, lt) = self.skip_binder();\n \n         if let ty::ReEmpty(_) = lt {\n             return None;\n@@ -545,9 +544,10 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n+impl<'tcx> Clean<WherePredicate> for ty::PolyProjectionPredicate<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n-        WherePredicate::EqPredicate { lhs: self.projection_ty.clean(cx), rhs: self.ty.clean(cx) }\n+        let ty::ProjectionPredicate { projection_ty, ty } = *self.skip_binder();\n+        WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: ty.clean(cx) }\n     }\n }\n \n@@ -1674,7 +1674,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             }\n                         }\n \n-                        let bounds = bounds\n+                        let bounds: Vec<_> = bounds\n                             .predicates\n                             .iter()\n                             .filter_map(|pred| {\n@@ -1703,7 +1703,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             })\n                             .collect();\n \n-                        Some((trait_ref.skip_binder(), bounds).clean(cx))\n+                        Some((trait_ref, &bounds[..]).clean(cx))\n                     })\n                     .collect::<Vec<_>>();\n                 bounds.extend(regions);"}, {"sha": "bc1e18b657f3163e4a137ac2283a6af23848c304", "filename": "src/test/ui/coherence/impl-foreign-for-locally-defined-fundamental.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-locally-defined-fundamental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209b2be09fcaff937480d1fbbe8b31646e361c7a/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-locally-defined-fundamental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-locally-defined-fundamental.rs?ref=209b2be09fcaff937480d1fbbe8b31646e361c7a", "patch": "@@ -8,8 +8,8 @@ extern crate coherence_lib as lib;\n use lib::*;\n \n #[fundamental]\n-struct Local;\n+struct Local<T>(T);\n \n-impl Remote for Local {}\n+impl Remote for Local<()> {}\n \n fn main() {}"}]}