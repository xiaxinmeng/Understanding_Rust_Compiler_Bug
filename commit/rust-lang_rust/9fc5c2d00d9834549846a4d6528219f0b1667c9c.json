{"sha": "9fc5c2d00d9834549846a4d6528219f0b1667c9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYzVjMmQwMGQ5ODM0NTQ5ODQ2YTRkNjUyODIxOWYwYjE2NjdjOWM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-17T02:05:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-17T02:05:12Z"}, "message": "Rollup merge of #69870 - petrochenkov:cfgacc, r=matthewjasper\n\nexpand: Implement something similar to `#[cfg(accessible(path))]`\n\ncc https://github.com/rust-lang/rust/issues/64797\n\nThe feature is implemented as a `#[cfg_accessible(path)]` attribute macro rather than as `#[cfg(accessible(path))]` because it needs to wait until `path` becomes resolvable, and `cfg` cannot wait, but macros can wait.\n\nLater we can think about desugaring or not desugaring `#[cfg(accessible(path))]` into `#[cfg_accessible(path)]`.\n\nThis implementation is also incomplete in the sense that it never returns \"false\" from `cfg_accessible(path)`, it requires some tweaks to resolve, which is not quite ready to answer queries like this during early resolution.\n\nHowever, the most important part of this PR is not `cfg_accessible` itself, but expansion infrastructure for retrying expansions.\nBefore this PR we could say \"we cannot resolve this macro path, let's try it later\", with this PR we can say \"we cannot expand this macro, let's try it later\" as well.\n\nThis is a pre-requisite for\n- turning `#[derive(...)]` into a regular attribute macro,\n- properly supporting eager expansion for macros that cannot yet be resolved like\n    ```\n    fn main() {\n        println!(not_available_yet!());\n    }\n\n    macro_rules! make_available {\n        () => { #[macro_export] macro_rules! not_available_yet { () => { \"Hello world!\" } }}\n    }\n\n    make_available!();\n    ```", "tree": {"sha": "95941f1505e358bce663dfcb8a6dd4ae62ae28b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95941f1505e358bce663dfcb8a6dd4ae62ae28b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fc5c2d00d9834549846a4d6528219f0b1667c9c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJecDBYCRBK7hj4Ov3rIwAAdHIIAB4BLz2NUuar6p9PvDj3AF0I\n1Rfs58k0lHCjHTX+3ledTI1Jjt39CCW1b4K5fvK+8GS1sVMV7C0+gR4RtDfKAMUw\n6Ry1dI5Y0rwGWmn7V1Mm97iMjsgh0Zxow6YanpIMmtxTKjJOH5VViDhilrEn6sYf\n5cVZq19mDB/lTUNOlfx8li4GXQLskBdg0yErsh8I5s10j+MAYg8yNsZo3dwT5ys9\nGxJrjvkiYbwfdRwgG9qGk29HcxICYwu+8MBHAKvyrOR/ASQxS0/Lra9VQ5ZY8vr2\nC5wCI9/kRbvziXcJpuuWbzarZ29mjAlEFgY41bYl5DjbY13dUg0wTp84Bqb8Eao=\n=WGSK\n-----END PGP SIGNATURE-----\n", "payload": "tree 95941f1505e358bce663dfcb8a6dd4ae62ae28b8\nparent b691145bd4678fc13250792ea1be8f5656f2b66c\nparent 2e6528961c44a4f3841fd319af71f1d1a6af029c\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584410712 +0100\ncommitter GitHub <noreply@github.com> 1584410712 +0100\n\nRollup merge of #69870 - petrochenkov:cfgacc, r=matthewjasper\n\nexpand: Implement something similar to `#[cfg(accessible(path))]`\n\ncc https://github.com/rust-lang/rust/issues/64797\n\nThe feature is implemented as a `#[cfg_accessible(path)]` attribute macro rather than as `#[cfg(accessible(path))]` because it needs to wait until `path` becomes resolvable, and `cfg` cannot wait, but macros can wait.\n\nLater we can think about desugaring or not desugaring `#[cfg(accessible(path))]` into `#[cfg_accessible(path)]`.\n\nThis implementation is also incomplete in the sense that it never returns \"false\" from `cfg_accessible(path)`, it requires some tweaks to resolve, which is not quite ready to answer queries like this during early resolution.\n\nHowever, the most important part of this PR is not `cfg_accessible` itself, but expansion infrastructure for retrying expansions.\nBefore this PR we could say \"we cannot resolve this macro path, let's try it later\", with this PR we can say \"we cannot expand this macro, let's try it later\" as well.\n\nThis is a pre-requisite for\n- turning `#[derive(...)]` into a regular attribute macro,\n- properly supporting eager expansion for macros that cannot yet be resolved like\n    ```\n    fn main() {\n        println!(not_available_yet!());\n    }\n\n    macro_rules! make_available {\n        () => { #[macro_export] macro_rules! not_available_yet { () => { \"Hello world!\" } }}\n    }\n\n    make_available!();\n    ```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fc5c2d00d9834549846a4d6528219f0b1667c9c", "html_url": "https://github.com/rust-lang/rust/commit/9fc5c2d00d9834549846a4d6528219f0b1667c9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fc5c2d00d9834549846a4d6528219f0b1667c9c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b691145bd4678fc13250792ea1be8f5656f2b66c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b691145bd4678fc13250792ea1be8f5656f2b66c", "html_url": "https://github.com/rust-lang/rust/commit/b691145bd4678fc13250792ea1be8f5656f2b66c"}, {"sha": "2e6528961c44a4f3841fd319af71f1d1a6af029c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e6528961c44a4f3841fd319af71f1d1a6af029c", "html_url": "https://github.com/rust-lang/rust/commit/2e6528961c44a4f3841fd319af71f1d1a6af029c"}], "stats": {"total": 510, "additions": 439, "deletions": 71}, "files": [{"sha": "a0873fe6b625d2158457805239dabeea915ad5e8", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -1404,6 +1404,18 @@ pub(crate) mod builtin {\n         /* compiler built-in */\n     }\n \n+    /// Keeps the item it's applied to if the passed path is accessible, and removes it otherwise.\n+    #[cfg(not(bootstrap))]\n+    #[unstable(\n+        feature = \"cfg_accessible\",\n+        issue = \"64797\",\n+        reason = \"`cfg_accessible` is not fully implemented\"\n+    )]\n+    #[rustc_builtin_macro]\n+    pub macro cfg_accessible($item:item) {\n+        /* compiler built-in */\n+    }\n+\n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "c91370b2719929bef21884c043872fd08623fd9e", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -67,3 +67,12 @@ pub use crate::{\n pub use crate::macros::builtin::{\n     bench, global_allocator, test, test_case, RustcDecodable, RustcEncodable,\n };\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(\n+    feature = \"cfg_accessible\",\n+    issue = \"64797\",\n+    reason = \"`cfg_accessible` is not fully implemented\"\n+)]\n+#[doc(no_inline)]\n+pub use crate::macros::builtin::cfg_accessible;"}, {"sha": "3607a4d0d15b6238d09033a5fbec15b66671e43d", "filename": "src/librustc_builtin_macros/cfg_accessible.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_builtin_macros%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_builtin_macros%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fcfg_accessible.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -0,0 +1,54 @@\n+//! Implementation of the `#[cfg_accessible(path)]` attribute macro.\n+\n+use rustc_ast::ast;\n+use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n+use rustc_feature::AttributeTemplate;\n+use rustc_parse::validate_attr;\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+\n+crate struct Expander;\n+\n+fn validate_input<'a>(ecx: &mut ExtCtxt<'_>, mi: &'a ast::MetaItem) -> Option<&'a ast::Path> {\n+    match mi.meta_item_list() {\n+        None => {}\n+        Some([]) => ecx.span_err(mi.span, \"`cfg_accessible` path is not specified\"),\n+        Some([_, .., l]) => ecx.span_err(l.span(), \"multiple `cfg_accessible` paths are specified\"),\n+        Some([nmi]) => match nmi.meta_item() {\n+            None => ecx.span_err(nmi.span(), \"`cfg_accessible` path cannot be a literal\"),\n+            Some(mi) => {\n+                if !mi.is_word() {\n+                    ecx.span_err(mi.span, \"`cfg_accessible` path cannot accept arguments\");\n+                }\n+                return Some(&mi.path);\n+            }\n+        },\n+    }\n+    None\n+}\n+\n+impl MultiItemModifier for Expander {\n+    fn expand(\n+        &self,\n+        ecx: &mut ExtCtxt<'_>,\n+        _span: Span,\n+        meta_item: &ast::MetaItem,\n+        item: Annotatable,\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n+        let template = AttributeTemplate { list: Some(\"path\"), ..Default::default() };\n+        let attr = &ecx.attribute(meta_item.clone());\n+        validate_attr::check_builtin_attribute(ecx.parse_sess, attr, sym::cfg_accessible, template);\n+\n+        let path = match validate_input(ecx, meta_item) {\n+            Some(path) => path,\n+            None => return ExpandResult::Ready(Vec::new()),\n+        };\n+\n+        let failure_msg = \"cannot determine whether the path is accessible or not\";\n+        match ecx.resolver.cfg_accessible(ecx.current_expansion.id, path) {\n+            Ok(true) => ExpandResult::Ready(vec![item]),\n+            Ok(false) => ExpandResult::Ready(Vec::new()),\n+            Err(_) => ExpandResult::Retry(item, failure_msg.into()),\n+        }\n+    }\n+}"}, {"sha": "b5ad67abf620106daefcee76e66de633e7b77017", "filename": "src/librustc_builtin_macros/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_ast::ast::{self, ItemKind, MetaItem};\n use rustc_ast::ptr::P;\n-use rustc_expand::base::{Annotatable, ExtCtxt, MultiItemModifier};\n+use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n@@ -48,13 +48,13 @@ impl MultiItemModifier for BuiltinDerive {\n         span: Span,\n         meta_item: &MetaItem,\n         item: Annotatable,\n-    ) -> Vec<Annotatable> {\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         // FIXME: Built-in derives often forget to give spans contexts,\n         // so we are doing it here in a centralized way.\n         let span = ecx.with_def_site_ctxt(span);\n         let mut items = Vec::new();\n         (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a));\n-        items\n+        ExpandResult::Ready(items)\n     }\n }\n "}, {"sha": "26a59c6b1bedb6be72ee9a87741d1360c83be0ca", "filename": "src/librustc_builtin_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_builtin_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_builtin_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Flib.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -22,6 +22,7 @@ use rustc_span::symbol::sym;\n mod asm;\n mod assert;\n mod cfg;\n+mod cfg_accessible;\n mod compile_error;\n mod concat;\n mod concat_idents;\n@@ -85,6 +86,7 @@ pub fn register_builtin_macros(resolver: &mut dyn Resolver, edition: Edition) {\n \n     register_attr! {\n         bench: test::expand_bench,\n+        cfg_accessible: cfg_accessible::Expander,\n         global_allocator: global_allocator::expand,\n         test: test::expand_test,\n         test_case: test::expand_test_case,"}, {"sha": "b486eadd1a8bee4fcfff332e61255dfb3777c6c8", "filename": "src/librustc_builtin_macros/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_builtin_macros%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_builtin_macros%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Futil.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -6,7 +6,7 @@ use rustc_span::Symbol;\n \n pub fn check_builtin_macro_attribute(ecx: &ExtCtxt<'_>, meta_item: &MetaItem, name: Symbol) {\n     // All the built-in macro attributes are \"words\" at the moment.\n-    let template = AttributeTemplate::only_word();\n+    let template = AttributeTemplate { word: true, ..Default::default() };\n     let attr = ecx.attribute(meta_item.clone());\n     validate_attr::check_builtin_attribute(ecx.parse_sess, &attr, name, template);\n }"}, {"sha": "f5f2a5ed43f2c66207e6ebba755d6ee2e78f84a3", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -258,37 +258,39 @@ impl Annotatable {\n     }\n }\n \n-// `meta_item` is the annotation, and `item` is the item being modified.\n-// FIXME Decorators should follow the same pattern too.\n+/// Result of an expansion that may need to be retried.\n+/// Consider using this for non-`MultiItemModifier` expanders as well.\n+pub enum ExpandResult<T, U> {\n+    /// Expansion produced a result (possibly dummy).\n+    Ready(T),\n+    /// Expansion could not produce a result and needs to be retried.\n+    /// The string is an explanation that will be printed if we are stuck in an infinite retry loop.\n+    Retry(U, String),\n+}\n+\n+// `meta_item` is the attribute, and `item` is the item being modified.\n pub trait MultiItemModifier {\n     fn expand(\n         &self,\n         ecx: &mut ExtCtxt<'_>,\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n-    ) -> Vec<Annotatable>;\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable>;\n }\n \n-impl<F, T> MultiItemModifier for F\n+impl<F> MultiItemModifier for F\n where\n-    F: Fn(&mut ExtCtxt<'_>, Span, &ast::MetaItem, Annotatable) -> T,\n-    T: Into<Vec<Annotatable>>,\n+    F: Fn(&mut ExtCtxt<'_>, Span, &ast::MetaItem, Annotatable) -> Vec<Annotatable>,\n {\n     fn expand(\n         &self,\n         ecx: &mut ExtCtxt<'_>,\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n-    ) -> Vec<Annotatable> {\n-        (*self)(ecx, span, meta_item, item).into()\n-    }\n-}\n-\n-impl Into<Vec<Annotatable>> for Annotatable {\n-    fn into(self) -> Vec<Annotatable> {\n-        vec![self]\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n+        ExpandResult::Ready(self(ecx, span, meta_item, item))\n     }\n }\n \n@@ -895,6 +897,7 @@ pub trait Resolver {\n \n     fn has_derive_copy(&self, expn_id: ExpnId) -> bool;\n     fn add_derive_copy(&mut self, expn_id: ExpnId);\n+    fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n }\n \n #[derive(Clone)]"}, {"sha": "4d0548f3f868ad412583534ecb87baa48d11a6c0", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 103, "deletions": 42, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -408,7 +408,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n-            let invoc = if let Some(invoc) = invocations.pop() {\n+            let (invoc, res) = if let Some(invoc) = invocations.pop() {\n                 invoc\n             } else {\n                 self.resolve_imports();\n@@ -420,30 +420,51 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 continue;\n             };\n \n-            let eager_expansion_root =\n-                if self.monotonic { invoc.expansion_data.id } else { orig_expansion_data.id };\n-            let res = match self.cx.resolver.resolve_macro_invocation(\n-                &invoc,\n-                eager_expansion_root,\n-                force,\n-            ) {\n-                Ok(res) => res,\n-                Err(Indeterminate) => {\n-                    undetermined_invocations.push(invoc);\n-                    continue;\n+            let res = match res {\n+                Some(res) => res,\n+                None => {\n+                    let eager_expansion_root = if self.monotonic {\n+                        invoc.expansion_data.id\n+                    } else {\n+                        orig_expansion_data.id\n+                    };\n+                    match self.cx.resolver.resolve_macro_invocation(\n+                        &invoc,\n+                        eager_expansion_root,\n+                        force,\n+                    ) {\n+                        Ok(res) => res,\n+                        Err(Indeterminate) => {\n+                            // Cannot resolve, will retry this invocation later.\n+                            undetermined_invocations.push((invoc, None));\n+                            continue;\n+                        }\n+                    }\n                 }\n             };\n \n-            progress = true;\n             let ExpansionData { depth, id: expn_id, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n \n             // FIXME(jseyfried): Refactor out the following logic\n             let (expanded_fragment, new_invocations) = match res {\n-                InvocationRes::Single(ext) => {\n-                    let fragment = self.expand_invoc(invoc, &ext.kind);\n-                    self.collect_invocations(fragment, &[])\n-                }\n+                InvocationRes::Single(ext) => match self.expand_invoc(invoc, &ext.kind) {\n+                    ExpandResult::Ready(fragment) => self.collect_invocations(fragment, &[]),\n+                    ExpandResult::Retry(invoc, explanation) => {\n+                        if force {\n+                            // We are stuck, stop retrying and produce a dummy fragment.\n+                            let span = invoc.span();\n+                            self.cx.span_err(span, &explanation);\n+                            let fragment = invoc.fragment_kind.dummy(span);\n+                            self.collect_invocations(fragment, &[])\n+                        } else {\n+                            // Cannot expand, will retry this invocation later.\n+                            undetermined_invocations\n+                                .push((invoc, Some(InvocationRes::Single(ext))));\n+                            continue;\n+                        }\n+                    }\n+                },\n                 InvocationRes::DeriveContainer(_exts) => {\n                     // FIXME: Consider using the derive resolutions (`_exts`) immediately,\n                     // instead of enqueuing the derives to be resolved again later.\n@@ -463,21 +484,25 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     for path in derives {\n                         let expn_id = ExpnId::fresh(None);\n                         derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n-                        invocations.push(Invocation {\n-                            kind: InvocationKind::Derive { path, item: item.clone() },\n-                            fragment_kind: invoc.fragment_kind,\n-                            expansion_data: ExpansionData {\n-                                id: expn_id,\n-                                ..invoc.expansion_data.clone()\n+                        invocations.push((\n+                            Invocation {\n+                                kind: InvocationKind::Derive { path, item: item.clone() },\n+                                fragment_kind: invoc.fragment_kind,\n+                                expansion_data: ExpansionData {\n+                                    id: expn_id,\n+                                    ..invoc.expansion_data.clone()\n+                                },\n                             },\n-                        });\n+                            None,\n+                        ));\n                     }\n                     let fragment =\n                         invoc.fragment_kind.expect_from_annotatables(::std::iter::once(item));\n                     self.collect_invocations(fragment, &derive_placeholders)\n                 }\n             };\n \n+            progress = true;\n             if expanded_fragments.len() < depth {\n                 expanded_fragments.push(Vec::new());\n             }\n@@ -535,7 +560,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         &mut self,\n         mut fragment: AstFragment,\n         extra_placeholders: &[NodeId],\n-    ) -> (AstFragment, Vec<Invocation>) {\n+    ) -> (AstFragment, Vec<(Invocation, Option<InvocationRes>)>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n         self.cx.resolver.resolve_dollar_crates();\n \n@@ -635,13 +660,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         self.cx.trace_macros_diag();\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtensionKind) -> AstFragment {\n+    fn expand_invoc(\n+        &mut self,\n+        invoc: Invocation,\n+        ext: &SyntaxExtensionKind,\n+    ) -> ExpandResult<AstFragment, Invocation> {\n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n             self.error_recursion_limit_reached();\n         }\n \n         let (fragment_kind, span) = (invoc.fragment_kind, invoc.span());\n-        match invoc.kind {\n+        ExpandResult::Ready(match invoc.kind {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n                     self.gate_proc_macro_expansion_kind(span, fragment_kind);\n@@ -663,7 +692,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 _ => unreachable!(),\n             },\n-            InvocationKind::Attr { attr, mut item, .. } => match ext {\n+            InvocationKind::Attr { attr, mut item, derives, after_derive } => match ext {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n@@ -679,8 +708,25 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n                     match validate_attr::parse_meta(self.cx.parse_sess, &attr) {\n                         Ok(meta) => {\n-                            let item = expander.expand(self.cx, span, &meta, item);\n-                            fragment_kind.expect_from_annotatables(item)\n+                            let items = match expander.expand(self.cx, span, &meta, item) {\n+                                ExpandResult::Ready(items) => items,\n+                                ExpandResult::Retry(item, explanation) => {\n+                                    // Reassemble the original invocation for retrying.\n+                                    return ExpandResult::Retry(\n+                                        Invocation {\n+                                            kind: InvocationKind::Attr {\n+                                                attr,\n+                                                item,\n+                                                derives,\n+                                                after_derive,\n+                                            },\n+                                            ..invoc\n+                                        },\n+                                        explanation,\n+                                    );\n+                                }\n+                            };\n+                            fragment_kind.expect_from_annotatables(items)\n                         }\n                         Err(mut err) => {\n                             err.emit();\n@@ -702,19 +748,31 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Derive(expander)\n                 | SyntaxExtensionKind::LegacyDerive(expander) => {\n                     if !item.derive_allowed() {\n-                        return fragment_kind.dummy(span);\n+                        return ExpandResult::Ready(fragment_kind.dummy(span));\n                     }\n                     if let SyntaxExtensionKind::Derive(..) = ext {\n                         self.gate_proc_macro_input(&item);\n                     }\n                     let meta = ast::MetaItem { kind: ast::MetaItemKind::Word, span, path };\n-                    let items = expander.expand(self.cx, span, &meta, item);\n+                    let items = match expander.expand(self.cx, span, &meta, item) {\n+                        ExpandResult::Ready(items) => items,\n+                        ExpandResult::Retry(item, explanation) => {\n+                            // Reassemble the original invocation for retrying.\n+                            return ExpandResult::Retry(\n+                                Invocation {\n+                                    kind: InvocationKind::Derive { path: meta.path, item },\n+                                    ..invoc\n+                                },\n+                                explanation,\n+                            );\n+                        }\n+                    };\n                     fragment_kind.expect_from_annotatables(items)\n                 }\n                 _ => unreachable!(),\n             },\n             InvocationKind::DeriveContainer { .. } => unreachable!(),\n-        }\n+        })\n     }\n \n     fn gate_proc_macro_attr_item(&self, span: Span, item: &Annotatable) {\n@@ -933,7 +991,7 @@ pub fn ensure_complete_parse<'a>(\n struct InvocationCollector<'a, 'b> {\n     cx: &'a mut ExtCtxt<'b>,\n     cfg: StripUnconfigured<'a>,\n-    invocations: Vec<Invocation>,\n+    invocations: Vec<(Invocation, Option<InvocationRes>)>,\n     monotonic: bool,\n }\n \n@@ -955,15 +1013,18 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         };\n         let expn_id = ExpnId::fresh(expn_data);\n         let vis = kind.placeholder_visibility();\n-        self.invocations.push(Invocation {\n-            kind,\n-            fragment_kind,\n-            expansion_data: ExpansionData {\n-                id: expn_id,\n-                depth: self.cx.current_expansion.depth + 1,\n-                ..self.cx.current_expansion.clone()\n+        self.invocations.push((\n+            Invocation {\n+                kind,\n+                fragment_kind,\n+                expansion_data: ExpansionData {\n+                    id: expn_id,\n+                    depth: self.cx.current_expansion.depth + 1,\n+                    ..self.cx.current_expansion.clone()\n+                },\n             },\n-        });\n+            None,\n+        ));\n         placeholder(fragment_kind, NodeId::placeholder_from_expn_id(expn_id), vis)\n     }\n "}, {"sha": "cb9afa4cd4f0287c324cc0129d9476e66873c233", "filename": "src/librustc_expand/proc_macro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -79,7 +79,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         span: Span,\n         _meta_item: &ast::MetaItem,\n         item: Annotatable,\n-    ) -> Vec<Annotatable> {\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let item = match item {\n             Annotatable::Arm(..)\n             | Annotatable::Field(..)\n@@ -99,7 +99,7 @@ impl MultiItemModifier for ProcMacroDerive {\n                     \"proc-macro derives may only be \\\n                                     applied to a struct, enum, or union\",\n                 );\n-                return Vec::new();\n+                return ExpandResult::Ready(Vec::new());\n             }\n         };\n         match item.kind {\n@@ -110,7 +110,7 @@ impl MultiItemModifier for ProcMacroDerive {\n                     \"proc-macro derives may only be \\\n                                     applied to a struct, enum, or union\",\n                 );\n-                return Vec::new();\n+                return ExpandResult::Ready(Vec::new());\n             }\n         }\n \n@@ -158,7 +158,7 @@ impl MultiItemModifier for ProcMacroDerive {\n             FatalError.raise();\n         }\n \n-        items\n+        ExpandResult::Ready(items)\n     }\n }\n "}, {"sha": "eaebdd9fb95a25f77f299cafc586ca463c415905", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -85,19 +85,13 @@ impl AttributeGate {\n \n /// A template that the attribute input must match.\n /// Only top-level shape (`#[attr]` vs `#[attr(...)]` vs `#[attr = ...]`) is considered now.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Default)]\n pub struct AttributeTemplate {\n     pub word: bool,\n     pub list: Option<&'static str>,\n     pub name_value_str: Option<&'static str>,\n }\n \n-impl AttributeTemplate {\n-    pub fn only_word() -> Self {\n-        Self { word: true, list: None, name_value_str: None }\n-    }\n-}\n-\n /// A convenience macro for constructing attribute templates.\n /// E.g., `template!(Word, List: \"description\")` means that the attribute\n /// supports forms `#[attr]` and `#[attr(description)]`."}, {"sha": "6c2a9cd8b10d99c4f1a5157b491284937d26312d", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -345,6 +345,42 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn add_derive_copy(&mut self, expn_id: ExpnId) {\n         self.containers_deriving_copy.insert(expn_id);\n     }\n+\n+    // The function that implements the resolution logic of `#[cfg_accessible(path)]`.\n+    // Returns true if the path can certainly be resolved in one of three namespaces,\n+    // returns false if the path certainly cannot be resolved in any of the three namespaces.\n+    // Returns `Indeterminate` if we cannot give a certain answer yet.\n+    fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate> {\n+        let span = path.span;\n+        let path = &Segment::from_path(path);\n+        let parent_scope = self.invocation_parent_scopes[&expn_id];\n+\n+        let mut indeterminate = false;\n+        for ns in [TypeNS, ValueNS, MacroNS].iter().copied() {\n+            match self.resolve_path(path, Some(ns), &parent_scope, false, span, CrateLint::No) {\n+                PathResult::Module(ModuleOrUniformRoot::Module(_)) => return Ok(true),\n+                PathResult::NonModule(partial_res) if partial_res.unresolved_segments() == 0 => {\n+                    return Ok(true);\n+                }\n+                PathResult::Indeterminate => indeterminate = true,\n+                // FIXME: `resolve_path` is not ready to report partially resolved paths\n+                // correctly, so we just report an error if the path was reported as unresolved.\n+                // This needs to be fixed for `cfg_accessible` to be useful.\n+                PathResult::NonModule(..) | PathResult::Failed { .. } => {}\n+                PathResult::Module(_) => panic!(\"unexpected path resolution\"),\n+            }\n+        }\n+\n+        if indeterminate {\n+            return Err(Indeterminate);\n+        }\n+\n+        self.session\n+            .struct_span_err(span, \"not sure whether the path is accessible or not\")\n+            .span_note(span, \"`cfg_accessible` is not fully implemented\")\n+            .emit();\n+        Ok(false)\n+    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "f349f88b8942880a75948a5eca7b6dbea98351c9", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -182,6 +182,7 @@ symbols! {\n         caller_location,\n         cdylib,\n         cfg,\n+        cfg_accessible,\n         cfg_attr,\n         cfg_attr_multi,\n         cfg_doctest,"}, {"sha": "1f122b02b6a29b1398c4df5b301f615256db5894", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -240,6 +240,7 @@\n #![feature(atomic_mut_ptr)]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n+#![cfg_attr(not(bootstrap), feature(cfg_accessible))]\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n #![feature(char_error_internals)]"}, {"sha": "6712f5ba5808c4f14c361a34021cf92d8c33adf3", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -53,6 +53,15 @@ pub use core::prelude::v1::{\n     PartialEq, PartialOrd, RustcDecodable, RustcEncodable,\n };\n \n+#[cfg(not(bootstrap))]\n+#[unstable(\n+    feature = \"cfg_accessible\",\n+    issue = \"64797\",\n+    reason = \"`cfg_accessible` is not fully implemented\"\n+)]\n+#[doc(hidden)]\n+pub use core::prelude::v1::cfg_accessible;\n+\n // The file so far is equivalent to src/libcore/prelude/v1.rs,\n // and below to src/liballoc/prelude.rs.\n // Those files are duplicated rather than using glob imports"}, {"sha": "c51c908a4262e2cd49d6b32a8ef7fef9704c72aa", "filename": "src/test/ui/conditional-compilation/cfg_accessible-input-validation.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-input-validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-input-validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-input-validation.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -0,0 +1,24 @@\n+#![feature(cfg_accessible)]\n+\n+#[cfg_accessible] //~ ERROR malformed `cfg_accessible` attribute input\n+struct S1;\n+\n+#[cfg_accessible = \"value\"] //~ ERROR malformed `cfg_accessible` attribute input\n+struct S2;\n+\n+#[cfg_accessible()] //~ ERROR `cfg_accessible` path is not specified\n+struct S3;\n+\n+#[cfg_accessible(std, core)] //~ ERROR multiple `cfg_accessible` paths are specified\n+struct S4;\n+\n+#[cfg_accessible(\"std\")] //~ ERROR `cfg_accessible` path cannot be a literal\n+struct S5;\n+\n+#[cfg_accessible(std = \"value\")] //~ ERROR `cfg_accessible` path cannot accept arguments\n+struct S6;\n+\n+#[cfg_accessible(std(value))] //~ ERROR `cfg_accessible` path cannot accept arguments\n+struct S7;\n+\n+fn main() {}"}, {"sha": "86706c766356ea651094422e992e72abaf14bd72", "filename": "src/test/ui/conditional-compilation/cfg_accessible-input-validation.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-input-validation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-input-validation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-input-validation.stderr?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -0,0 +1,44 @@\n+error: malformed `cfg_accessible` attribute input\n+  --> $DIR/cfg_accessible-input-validation.rs:3:1\n+   |\n+LL | #[cfg_accessible]\n+   | ^^^^^^^^^^^^^^^^^ help: must be of the form: `#[cfg_accessible(path)]`\n+\n+error: malformed `cfg_accessible` attribute input\n+  --> $DIR/cfg_accessible-input-validation.rs:6:1\n+   |\n+LL | #[cfg_accessible = \"value\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[cfg_accessible(path)]`\n+\n+error: `cfg_accessible` path is not specified\n+  --> $DIR/cfg_accessible-input-validation.rs:9:1\n+   |\n+LL | #[cfg_accessible()]\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: multiple `cfg_accessible` paths are specified\n+  --> $DIR/cfg_accessible-input-validation.rs:12:23\n+   |\n+LL | #[cfg_accessible(std, core)]\n+   |                       ^^^^\n+\n+error: `cfg_accessible` path cannot be a literal\n+  --> $DIR/cfg_accessible-input-validation.rs:15:18\n+   |\n+LL | #[cfg_accessible(\"std\")]\n+   |                  ^^^^^\n+\n+error: `cfg_accessible` path cannot accept arguments\n+  --> $DIR/cfg_accessible-input-validation.rs:18:18\n+   |\n+LL | #[cfg_accessible(std = \"value\")]\n+   |                  ^^^^^^^^^^^^^\n+\n+error: `cfg_accessible` path cannot accept arguments\n+  --> $DIR/cfg_accessible-input-validation.rs:21:18\n+   |\n+LL | #[cfg_accessible(std(value))]\n+   |                  ^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "8bc93fa324378391446dee53883b51c7e4b39ecc", "filename": "src/test/ui/conditional-compilation/cfg_accessible-stuck.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -0,0 +1,9 @@\n+#![feature(cfg_accessible)]\n+\n+#[cfg_accessible(Z)] //~ ERROR cannot determine whether the path is accessible or not\n+struct S;\n+\n+#[cfg_accessible(S)] //~ ERROR cannot determine whether the path is accessible or not\n+struct Z;\n+\n+fn main() {}"}, {"sha": "9641441a819b0cb0d2d38ff35d80698a5bb7e15e", "filename": "src/test/ui/conditional-compilation/cfg_accessible-stuck.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -0,0 +1,14 @@\n+error: cannot determine whether the path is accessible or not\n+  --> $DIR/cfg_accessible-stuck.rs:6:1\n+   |\n+LL | #[cfg_accessible(S)]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot determine whether the path is accessible or not\n+  --> $DIR/cfg_accessible-stuck.rs:3:1\n+   |\n+LL | #[cfg_accessible(Z)]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "e9247e67a2a26638675fa241f5f169604e879faa", "filename": "src/test/ui/conditional-compilation/cfg_accessible-unstable.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-unstable.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -0,0 +1,2 @@\n+#[cfg_accessible(std)] //~ ERROR use of unstable library feature 'cfg_accessible'\n+fn main() {}"}, {"sha": "2f55b9559c78fdefa3dbe2da6db01e1cd1bbb7af", "filename": "src/test/ui/conditional-compilation/cfg_accessible-unstable.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-unstable.stderr?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: use of unstable library feature 'cfg_accessible': `cfg_accessible` is not fully implemented\n+  --> $DIR/cfg_accessible-unstable.rs:1:3\n+   |\n+LL | #[cfg_accessible(std)]\n+   |   ^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #64797 <https://github.com/rust-lang/rust/issues/64797> for more information\n+   = help: add `#![feature(cfg_accessible)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "07b0be5b1ae2606e37576b693db30c9ad125f09a", "filename": "src/test/ui/conditional-compilation/cfg_accessible.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible.rs?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -0,0 +1,43 @@\n+#![feature(cfg_accessible)]\n+\n+mod m {\n+    pub struct ExistingPublic;\n+    struct ExistingPrivate;\n+}\n+\n+#[cfg_accessible(m::ExistingPublic)]\n+struct ExistingPublic;\n+\n+// FIXME: Not implemented yet.\n+#[cfg_accessible(m::ExistingPrivate)] //~ ERROR not sure whether the path is accessible or not\n+struct ExistingPrivate;\n+\n+// FIXME: Not implemented yet.\n+#[cfg_accessible(m::NonExistent)] //~ ERROR not sure whether the path is accessible or not\n+struct ExistingPrivate;\n+\n+#[cfg_accessible(n::AccessibleExpanded)] // OK, `cfg_accessible` can wait and retry.\n+struct AccessibleExpanded;\n+\n+macro_rules! generate_accessible_expanded {\n+    () => {\n+        mod n {\n+            pub struct AccessibleExpanded;\n+        }\n+    };\n+}\n+\n+generate_accessible_expanded!();\n+\n+struct S {\n+    field: u8,\n+}\n+\n+// FIXME: Not implemented yet.\n+#[cfg_accessible(S::field)] //~ ERROR not sure whether the path is accessible or not\n+struct Field;\n+\n+fn main() {\n+    ExistingPublic;\n+    AccessibleExpanded;\n+}"}, {"sha": "167765cd66ee6d045cdce7d7bc23b88e7e7ea0a8", "filename": "src/test/ui/conditional-compilation/cfg_accessible.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fc5c2d00d9834549846a4d6528219f0b1667c9c/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible.stderr?ref=9fc5c2d00d9834549846a4d6528219f0b1667c9c", "patch": "@@ -0,0 +1,38 @@\n+error: not sure whether the path is accessible or not\n+  --> $DIR/cfg_accessible.rs:12:18\n+   |\n+LL | #[cfg_accessible(m::ExistingPrivate)]\n+   |                  ^^^^^^^^^^^^^^^^^^\n+   |\n+note: `cfg_accessible` is not fully implemented\n+  --> $DIR/cfg_accessible.rs:12:18\n+   |\n+LL | #[cfg_accessible(m::ExistingPrivate)]\n+   |                  ^^^^^^^^^^^^^^^^^^\n+\n+error: not sure whether the path is accessible or not\n+  --> $DIR/cfg_accessible.rs:16:18\n+   |\n+LL | #[cfg_accessible(m::NonExistent)]\n+   |                  ^^^^^^^^^^^^^^\n+   |\n+note: `cfg_accessible` is not fully implemented\n+  --> $DIR/cfg_accessible.rs:16:18\n+   |\n+LL | #[cfg_accessible(m::NonExistent)]\n+   |                  ^^^^^^^^^^^^^^\n+\n+error: not sure whether the path is accessible or not\n+  --> $DIR/cfg_accessible.rs:37:18\n+   |\n+LL | #[cfg_accessible(S::field)]\n+   |                  ^^^^^^^^\n+   |\n+note: `cfg_accessible` is not fully implemented\n+  --> $DIR/cfg_accessible.rs:37:18\n+   |\n+LL | #[cfg_accessible(S::field)]\n+   |                  ^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}]}