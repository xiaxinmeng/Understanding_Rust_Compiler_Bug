{"sha": "82ae9682ca3f41f982b881c377a12bb081fead93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyYWU5NjgyY2EzZjQxZjk4MmI4ODFjMzc3YTEyYmIwODFmZWFkOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-25T23:09:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-25T23:09:06Z"}, "message": "Auto merge of #44297 - laumann:suggest-misspelt-methods, r=arielb1\n\nAdd suggestions for misspelled method names\n\nUse the syntax::util::lev_distance module to provide suggestions when a\nnamed method cannot be found.\n\nPart of #30197", "tree": {"sha": "49de6a93c98b032171f1c0ef0bed237940025511", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49de6a93c98b032171f1c0ef0bed237940025511"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82ae9682ca3f41f982b881c377a12bb081fead93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82ae9682ca3f41f982b881c377a12bb081fead93", "html_url": "https://github.com/rust-lang/rust/commit/82ae9682ca3f41f982b881c377a12bb081fead93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82ae9682ca3f41f982b881c377a12bb081fead93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c476ce462333fccd89ce3ed8c290998db874653", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c476ce462333fccd89ce3ed8c290998db874653", "html_url": "https://github.com/rust-lang/rust/commit/6c476ce462333fccd89ce3ed8c290998db874653"}, {"sha": "4963394f86719f3315239a900e557982a829adae", "url": "https://api.github.com/repos/rust-lang/rust/commits/4963394f86719f3315239a900e557982a829adae", "html_url": "https://github.com/rust-lang/rust/commit/4963394f86719f3315239a900e557982a829adae"}], "stats": {"total": 168, "additions": 158, "deletions": 10}, "files": [{"sha": "4ee0b4cb46f1b87df51343cd7b2e5414d5d515e0", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82ae9682ca3f41f982b881c377a12bb081fead93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82ae9682ca3f41f982b881c377a12bb081fead93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=82ae9682ca3f41f982b881c377a12bb081fead93", "patch": "@@ -70,19 +70,22 @@ pub struct NoMatchData<'tcx> {\n     pub static_candidates: Vec<CandidateSource>,\n     pub unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n     pub out_of_scope_traits: Vec<DefId>,\n+    pub lev_candidate: Option<ty::AssociatedItem>,\n     pub mode: probe::Mode,\n }\n \n impl<'tcx> NoMatchData<'tcx> {\n     pub fn new(static_candidates: Vec<CandidateSource>,\n                unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n                out_of_scope_traits: Vec<DefId>,\n+               lev_candidate: Option<ty::AssociatedItem>,\n                mode: probe::Mode)\n                -> Self {\n         NoMatchData {\n             static_candidates,\n             unsatisfied_predicates,\n             out_of_scope_traits,\n+            lev_candidate,\n             mode,\n         }\n     }"}, {"sha": "a3b196f99d629ba7ed01368da62ea73f319f37e3", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 76, "deletions": 10, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/82ae9682ca3f41f982b881c377a12bb081fead93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82ae9682ca3f41f982b881c377a12bb081fead93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=82ae9682ca3f41f982b881c377a12bb081fead93", "patch": "@@ -23,11 +23,13 @@ use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use rustc::infer::{self, InferOk};\n use syntax::ast;\n+use syntax::util::lev_distance::{lev_distance, find_best_match_for_name};\n use syntax_pos::Span;\n use rustc::hir;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n+use std::cmp::max;\n \n use self::CandidateKind::*;\n pub use self::PickKind::*;\n@@ -51,6 +53,10 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// used for error reporting\n     static_candidates: Vec<CandidateSource>,\n \n+    /// When probing for names, include names that are close to the\n+    /// requested name (by Levensthein distance)\n+    allow_similar_names: bool,\n+\n     /// Some(candidate) if there is a private candidate\n     private_candidate: Option<Def>,\n \n@@ -242,6 +248,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n                                                                      Vec::new(),\n                                                                      Vec::new(),\n+                                                                     None,\n                                                                      mode)))\n                 }\n             }\n@@ -261,7 +268,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // that we create during the probe process are removed later\n         self.probe(|_| {\n             let mut probe_cx =\n-                ProbeContext::new(self, span, mode, method_name, return_type, steps);\n+                ProbeContext::new(self, span, mode, method_name, return_type, Rc::new(steps));\n \n             probe_cx.assemble_inherent_candidates();\n             match scope {\n@@ -333,7 +340,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n            mode: Mode,\n            method_name: Option<ast::Name>,\n            return_type: Option<Ty<'tcx>>,\n-           steps: Vec<CandidateStep<'tcx>>)\n+           steps: Rc<Vec<CandidateStep<'tcx>>>)\n            -> ProbeContext<'a, 'gcx, 'tcx> {\n         ProbeContext {\n             fcx,\n@@ -344,8 +351,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: FxHashSet(),\n-            steps: Rc::new(steps),\n+            steps: steps,\n             static_candidates: Vec::new(),\n+            allow_similar_names: false,\n             private_candidate: None,\n             unsatisfied_predicates: Vec::new(),\n         }\n@@ -798,10 +806,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         if let Some(def) = private_candidate {\n             return Err(MethodError::PrivateMatch(def, out_of_scope_traits));\n         }\n+        let lev_candidate = self.probe_for_lev_candidate()?;\n \n         Err(MethodError::NoMatch(NoMatchData::new(static_candidates,\n                                                   unsatisfied_predicates,\n                                                   out_of_scope_traits,\n+                                                  lev_candidate,\n                                                   self.mode)))\n     }\n \n@@ -913,11 +923,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         debug!(\"applicable_candidates: {:?}\", applicable_candidates);\n \n         if applicable_candidates.len() > 1 {\n-            match self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n-                Some(pick) => {\n-                    return Some(Ok(pick));\n-                }\n-                None => {}\n+            if let Some(pick) = self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n+                return Some(Ok(pick));\n             }\n         }\n \n@@ -1126,6 +1133,54 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         })\n     }\n \n+    /// Similarly to `probe_for_return_type`, this method attempts to find the best matching\n+    /// candidate method where the method name may have been misspelt. Similarly to other\n+    /// Levenshtein based suggestions, we provide at most one such suggestion.\n+    fn probe_for_lev_candidate(&mut self) -> Result<Option<ty::AssociatedItem>, MethodError<'tcx>> {\n+        debug!(\"Probing for method names similar to {:?}\",\n+               self.method_name);\n+\n+        let steps = self.steps.clone();\n+        self.probe(|_| {\n+            let mut pcx = ProbeContext::new(self.fcx, self.span, self.mode, self.method_name,\n+                                            self.return_type, steps);\n+            pcx.allow_similar_names = true;\n+            pcx.assemble_inherent_candidates();\n+            pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)?;\n+\n+            let method_names = pcx.candidate_method_names();\n+            pcx.allow_similar_names = false;\n+            let applicable_close_candidates: Vec<ty::AssociatedItem> = method_names\n+                .iter()\n+                .filter_map(|&method_name| {\n+                    pcx.reset();\n+                    pcx.method_name = Some(method_name);\n+                    pcx.assemble_inherent_candidates();\n+                    pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)\n+                        .ok().map_or(None, |_| {\n+                            pcx.pick_core()\n+                                .and_then(|pick| pick.ok())\n+                                .and_then(|pick| Some(pick.item))\n+                        })\n+                })\n+               .collect();\n+\n+            if applicable_close_candidates.is_empty() {\n+                Ok(None)\n+            } else {\n+                let best_name = {\n+                    let names = applicable_close_candidates.iter().map(|cand| &cand.name);\n+                    find_best_match_for_name(names,\n+                                             &self.method_name.unwrap().as_str(),\n+                                             None)\n+                }.unwrap();\n+                Ok(applicable_close_candidates\n+                   .into_iter()\n+                   .find(|method| method.name == best_name))\n+            }\n+        })\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n     fn has_applicable_self(&self, item: &ty::AssociatedItem) -> bool {\n@@ -1253,10 +1308,21 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.tcx.erase_late_bound_regions(value)\n     }\n \n-    /// Find the method with the appropriate name (or return type, as the case may be).\n+    /// Find the method with the appropriate name (or return type, as the case may be). If\n+    /// `allow_similar_names` is set, find methods with close-matching names.\n     fn impl_or_trait_item(&self, def_id: DefId) -> Vec<ty::AssociatedItem> {\n         if let Some(name) = self.method_name {\n-            self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n+            if self.allow_similar_names {\n+                let max_dist = max(name.as_str().len(), 3) / 3;\n+                self.tcx.associated_items(def_id)\n+                    .filter(|x| {\n+                        let dist = lev_distance(&*name.as_str(), &x.name.as_str());\n+                        dist > 0 && dist <= max_dist\n+                    })\n+                    .collect()\n+            } else {\n+                self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n+            }\n         } else {\n             self.tcx.associated_items(def_id).collect()\n         }"}, {"sha": "90c5297b399859cdd140381552c0b98d05cb0650", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82ae9682ca3f41f982b881c377a12bb081fead93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82ae9682ca3f41f982b881c377a12bb081fead93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=82ae9682ca3f41f982b881c377a12bb081fead93", "patch": "@@ -164,6 +164,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             MethodError::NoMatch(NoMatchData { static_candidates: static_sources,\n                                                unsatisfied_predicates,\n                                                out_of_scope_traits,\n+                                               lev_candidate,\n                                                mode,\n                                                .. }) => {\n                 let tcx = self.tcx;\n@@ -282,6 +283,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                               item_name,\n                                               rcvr_expr,\n                                               out_of_scope_traits);\n+\n+                if let Some(lev_candidate) = lev_candidate {\n+                    err.help(&format!(\"did you mean `{}`?\", lev_candidate.name));\n+                }\n                 err.emit();\n             }\n "}, {"sha": "e3f0df6fb5f1a6996b8fbe75b58de77215e66292", "filename": "src/test/ui/block-result/issue-3563.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82ae9682ca3f41f982b881c377a12bb081fead93/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82ae9682ca3f41f982b881c377a12bb081fead93/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr?ref=82ae9682ca3f41f982b881c377a12bb081fead93", "patch": "@@ -3,6 +3,8 @@ error[E0599]: no method named `b` found for type `&Self` in the current scope\n    |\n 13 |         || self.b()\n    |                 ^\n+   |\n+   = help: did you mean `a`?\n \n error[E0308]: mismatched types\n   --> $DIR/issue-3563.rs:13:9"}, {"sha": "b02881dc7eee03c98e9917c0a63d9d26cf54a20e", "filename": "src/test/ui/suggestions/suggest-methods.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/82ae9682ca3f41f982b881c377a12bb081fead93/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82ae9682ca3f41f982b881c377a12bb081fead93/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.rs?ref=82ae9682ca3f41f982b881c377a12bb081fead93", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(self) {}\n+    fn baz(&self, x: f64) {}\n+}\n+\n+trait FooT {\n+    fn bag(&self);\n+}\n+\n+impl FooT for Foo {\n+    fn bag(&self) {}\n+}\n+\n+fn main() {\n+    let f = Foo;\n+    f.bat(1.0);\n+\n+    let s = \"foo\".to_string();\n+    let _ = s.is_emtpy();\n+\n+    // Generates a warning for `count_zeros()`. `count_ones()` is also a close\n+    // match, but the former is closer.\n+    let _ = 63u32.count_eos();\n+\n+    // Does not generate a warning\n+    let _ = 63u32.count_o();\n+\n+}"}, {"sha": "41beb73b1bc3578789bfd22a85d90ded6cf006fa", "filename": "src/test/ui/suggestions/suggest-methods.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82ae9682ca3f41f982b881c377a12bb081fead93/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82ae9682ca3f41f982b881c377a12bb081fead93/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.stderr?ref=82ae9682ca3f41f982b881c377a12bb081fead93", "patch": "@@ -0,0 +1,32 @@\n+error[E0599]: no method named `bat` found for type `Foo` in the current scope\n+  --> $DIR/suggest-methods.rs:28:7\n+   |\n+28 |     f.bat(1.0);\n+   |       ^^^\n+   |\n+   = help: did you mean `bar`?\n+\n+error[E0599]: no method named `is_emtpy` found for type `std::string::String` in the current scope\n+  --> $DIR/suggest-methods.rs:31:15\n+   |\n+31 |     let _ = s.is_emtpy();\n+   |               ^^^^^^^^\n+   |\n+   = help: did you mean `is_empty`?\n+\n+error[E0599]: no method named `count_eos` found for type `u32` in the current scope\n+  --> $DIR/suggest-methods.rs:35:19\n+   |\n+35 |     let _ = 63u32.count_eos();\n+   |                   ^^^^^^^^^\n+   |\n+   = help: did you mean `count_zeros`?\n+\n+error[E0599]: no method named `count_o` found for type `u32` in the current scope\n+  --> $DIR/suggest-methods.rs:38:19\n+   |\n+38 |     let _ = 63u32.count_o();\n+   |                   ^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}]}