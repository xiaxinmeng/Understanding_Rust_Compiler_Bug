{"sha": "cb7a12757b9f9214c2b5f38437bf6c717f83eca5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiN2ExMjc1N2I5ZjkyMTRjMmI1ZjM4NDM3YmY2YzcxN2Y4M2VjYTU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-18T17:59:57Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-18T17:59:57Z"}, "message": "Rollup merge of #24542 - michaelsproul:rollup, r=alexcrichton\n\nI did a manual merge of all the extended error PRs as we were getting merge conflicts yesterday. I think this is preferable to merging separately as I ended up having to manually merge @nham and @GuillaumeGomez's commits.\r\n\r\nRollup of #24458, #24482 and #24488.\r\n\r\n#24482 and #24488 were already re-approved, and would need to be cancelled if this is merged instead.", "tree": {"sha": "0b00d1548a63cc00d341f6e2cfa22f00944eb743", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b00d1548a63cc00d341f6e2cfa22f00944eb743"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb7a12757b9f9214c2b5f38437bf6c717f83eca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb7a12757b9f9214c2b5f38437bf6c717f83eca5", "html_url": "https://github.com/rust-lang/rust/commit/cb7a12757b9f9214c2b5f38437bf6c717f83eca5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb7a12757b9f9214c2b5f38437bf6c717f83eca5/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93d8ba29066c8c81185e54a6d686d18165faa6e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/93d8ba29066c8c81185e54a6d686d18165faa6e8", "html_url": "https://github.com/rust-lang/rust/commit/93d8ba29066c8c81185e54a6d686d18165faa6e8"}, {"sha": "50f75f3e2a4b8cb5451acb15f8d469a222dafbf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/50f75f3e2a4b8cb5451acb15f8d469a222dafbf4", "html_url": "https://github.com/rust-lang/rust/commit/50f75f3e2a4b8cb5451acb15f8d469a222dafbf4"}], "stats": {"total": 136, "additions": 117, "deletions": 19}, "files": [{"sha": "306d2cd102fdb8f2456acbf068d3d27b9a041d8f", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 96, "deletions": 19, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/cb7a12757b9f9214c2b5f38437bf6c717f83eca5/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7a12757b9f9214c2b5f38437bf6c717f83eca5/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=cb7a12757b9f9214c2b5f38437bf6c717f83eca5", "patch": "@@ -55,15 +55,17 @@ underscore `_` wildcard pattern can be added after all other patterns to match\n \n // FIXME: Remove duplication here?\n E0005: r##\"\n-Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n-name will be extracted in all cases. If you encounter this error you probably need\n-to use a `match` or `if let` to deal with the possibility of failure.\n+Patterns used to bind names must be irrefutable, that is, they must guarantee\n+that a name will be extracted in all cases. If you encounter this error you\n+probably need to use a `match` or `if let` to deal with the possibility of\n+failure.\n \"##,\n \n E0006: r##\"\n-Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n-name will be extracted in all cases. If you encounter this error you probably need\n-to use a `match` or `if let` to deal with the possibility of failure.\n+Patterns used to bind names must be irrefutable, that is, they must guarantee\n+that a name will be extracted in all cases. If you encounter this error you\n+probably need to use a `match` or `if let` to deal with the possibility of\n+failure.\n \"##,\n \n E0007: r##\"\n@@ -112,6 +114,65 @@ reference when using guards or refactor the entire expression, perhaps by\n putting the condition inside the body of the arm.\n \"##,\n \n+E0009: r##\"\n+In a pattern, all values that don't implement the `Copy` trait have to be bound\n+the same way. The goal here is to avoid binding simultaneously by-move and\n+by-ref.\n+\n+This limitation may be removed in a future version of Rust.\n+\n+Wrong example:\n+\n+```\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {},\n+    None => panic!()\n+}\n+```\n+\n+You have two solutions:\n+1. Bind the pattern's values the same way:\n+\n+```\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((ref y, ref z)) => {},\n+    // or Some((y, z)) => {}\n+    None => panic!()\n+}\n+```\n+\n+2. Implement the `Copy` trait for the X structure (however, please\n+keep in mind that the first solution should be preferred!):\n+\n+```\n+#[derive(Clone, Copy)]\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {},\n+    None => panic!()\n+}\n+```\n+\"##,\n+\n+E0015: r##\"\n+The only function calls allowed in static or constant expressions are enum\n+variant constructors or struct constructors (for unit or tuple structs). This\n+is because Rust currently does not support compile-time function execution.\n+\"##,\n+\n+E0020: r##\"\n+This error indicates that an attempt was made to divide by zero (or take the\n+remainder of a zero divisor) in a static or constant expression.\n+\"##,\n+\n E0152: r##\"\n Lang items are already implemented in the standard library. Unless you are\n writing a free-standing application (e.g. a kernel), you do not need to provide\n@@ -217,6 +278,26 @@ use Method::*;\n enum Method { GET, POST }\n \"##,\n \n+E0267: r##\"\n+This error indicates the use of loop keyword (break or continue) inside a\n+closure but outside of any loop. Break and continue can be used as normal\n+inside closures as long as they are also contained within a loop. To halt the\n+execution of a closure you should instead use a return statement.\n+\"##,\n+\n+E0268: r##\"\n+This error indicates the use of loop keyword (break or continue) outside of a\n+loop. Without a loop to break out of or continue in, no sensible action can be\n+taken.\n+\"##,\n+\n+E0296: r##\"\n+This error indicates that the given recursion limit could not be parsed. Ensure\n+that the value provided is a positive integer between quotes, like so:\n+\n+#![recursion_limit=\"1000\"]\n+\"##,\n+\n E0297: r##\"\n Patterns used to bind names must be irrefutable. That is, they must guarantee\n that a name will be extracted in all cases. Instead of pattern matching the\n@@ -277,21 +358,23 @@ In certain cases it is possible for sub-bindings to violate memory safety.\n Updates to the borrow checker in a future version of Rust may remove this\n restriction, but for now patterns must be rewritten without sub-bindings.\n \n-// Code like this...\n-match Some(5) {\n-    ref op_num @ Some(num) => ...\n+// Before.\n+match Some(\"hi\".to_string()) {\n+    ref op_string_ref @ Some(ref s) => ...\n     None => ...\n }\n \n-// ... should be updated to code like this.\n-match Some(5) {\n-    Some(num) => {\n-        let op_num = &Some(num);\n+// After.\n+match Some(\"hi\".to_string()) {\n+    Some(ref s) => {\n+        let op_string_ref = &Some(&s);\n         ...\n     }\n     None => ...\n }\n \n+The `op_string_ref` binding has type &Option<&String> in both cases.\n+\n See also https://github.com/rust-lang/rust/issues/14587\n \"##,\n \n@@ -308,18 +391,15 @@ a compile-time constant.\n }\n \n register_diagnostics! {\n-    E0009,\n     E0010,\n     E0011,\n     E0012,\n     E0013,\n     E0014,\n-    E0015,\n     E0016,\n     E0017,\n     E0018,\n     E0019,\n-    E0020,\n     E0022,\n     E0079, // enum variant: expected signed integer constant\n     E0080, // enum variant: constant evaluation error\n@@ -338,8 +418,6 @@ register_diagnostics! {\n     E0264, // unknown external lang item\n     E0265, // recursive constant\n     E0266, // expected item\n-    E0267, // thing inside of a closure\n-    E0268, // thing outside of a loop\n     E0269, // not all control paths return a value\n     E0270, // computation may converge in a function marked as diverging\n     E0271, // type mismatch resolving\n@@ -357,7 +435,6 @@ register_diagnostics! {\n     E0283, // cannot resolve type\n     E0284, // cannot resolve type\n     E0285, // overflow evaluation builtin bounds\n-    E0296, // malformed recursion limit attribute\n     E0298, // mismatched types between arms\n     E0299, // mismatched types between arms\n     E0300, // unexpanded macro"}, {"sha": "6fcf39f0b174bf5ec4b57626740b707fc4fe9029", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb7a12757b9f9214c2b5f38437bf6c717f83eca5/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7a12757b9f9214c2b5f38437bf6c717f83eca5/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=cb7a12757b9f9214c2b5f38437bf6c717f83eca5", "patch": "@@ -20,6 +20,9 @@ use parse::token;\n use ptr::P;\n use util::small_vector::SmallVector;\n \n+// Maximum width of any line in an extended error description (inclusive).\n+const MAX_DESCRIPTION_WIDTH: usize = 80;\n+\n thread_local! {\n     static REGISTERED_DIAGNOSTICS: RefCell<BTreeMap<Name, Option<Name>>> = {\n         RefCell::new(BTreeMap::new())\n@@ -92,6 +95,24 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         }\n         _ => unreachable!()\n     };\n+    // Check that the description starts and ends with a newline and doesn't\n+    // overflow the maximum line width.\n+    description.map(|raw_msg| {\n+        let msg = raw_msg.as_str();\n+        if !msg.starts_with(\"\\n\") || !msg.ends_with(\"\\n\") {\n+            ecx.span_err(span, &format!(\n+                \"description for error code {} doesn't start and end with a newline\",\n+                token::get_ident(*code)\n+            ));\n+        }\n+        if msg.lines().any(|line| line.len() > MAX_DESCRIPTION_WIDTH) {\n+            ecx.span_err(span, &format!(\n+                \"description for error code {} contains a line longer than {} characters\",\n+                token::get_ident(*code), MAX_DESCRIPTION_WIDTH\n+            ));\n+        }\n+        raw_msg\n+    });\n     with_registered_diagnostics(|diagnostics| {\n         if diagnostics.insert(code.name, description).is_some() {\n             ecx.span_err(span, &format!("}]}