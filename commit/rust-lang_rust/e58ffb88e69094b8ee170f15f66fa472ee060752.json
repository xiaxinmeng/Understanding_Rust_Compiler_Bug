{"sha": "e58ffb88e69094b8ee170f15f66fa472ee060752", "node_id": "C_kwDOAAsO6NoAKGU1OGZmYjg4ZTY5MDk0YjhlZTE3MGYxNWY2NmZhNDcyZWUwNjA3NTI", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-10-27T14:48:06Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-11-21T14:16:09Z"}, "message": "Fix Clippy with changed for loop desugar", "tree": {"sha": "ffcc47a0f4099384cc012bb0f7e806f408c6d5ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffcc47a0f4099384cc012bb0f7e806f408c6d5ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e58ffb88e69094b8ee170f15f66fa472ee060752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e58ffb88e69094b8ee170f15f66fa472ee060752", "html_url": "https://github.com/rust-lang/rust/commit/e58ffb88e69094b8ee170f15f66fa472ee060752", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e58ffb88e69094b8ee170f15f66fa472ee060752/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb6268026206e6596b4754fdedf8f53a0e632273", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb6268026206e6596b4754fdedf8f53a0e632273", "html_url": "https://github.com/rust-lang/rust/commit/cb6268026206e6596b4754fdedf8f53a0e632273"}], "stats": {"total": 230, "additions": 90, "deletions": 140}, "files": [{"sha": "6f213d7a699030e9852bae7f6ca30c70df28eda2", "filename": "clippy_lints/src/loops/explicit_counter_loop.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=e58ffb88e69094b8ee170f15f66fa472ee060752", "patch": "@@ -1,6 +1,4 @@\n-use super::{\n-    get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor, EXPLICIT_COUNTER_LOOP,\n-};\n+use super::{make_iterator_snippet, IncrementVisitor, InitializeVisitor, EXPLICIT_COUNTER_LOOP};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{get_enclosing_block, is_integer_const};\n@@ -37,12 +35,10 @@ pub(super) fn check<'tcx>(\n                 then {\n                     let mut applicability = Applicability::MachineApplicable;\n \n-                    let for_span = get_span_of_entire_for_loop(expr);\n-\n                     span_lint_and_sugg(\n                         cx,\n                         EXPLICIT_COUNTER_LOOP,\n-                        for_span.with_hi(arg.span.hi()),\n+                        expr.span.with_hi(arg.span.hi()),\n                         &format!(\"the variable `{}` is used as a loop counter\", name),\n                         \"consider using\",\n                         format!("}, {"sha": "2362b4b20670f842b2cacebc17bdcfc02729a0a8", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=e58ffb88e69094b8ee170f15f66fa472ee060752", "patch": "@@ -1,4 +1,4 @@\n-use super::{get_span_of_entire_for_loop, IncrementVisitor, InitializeVisitor, MANUAL_MEMCPY};\n+use super::{IncrementVisitor, InitializeVisitor, MANUAL_MEMCPY};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n@@ -86,7 +86,7 @@ pub(super) fn check<'tcx>(\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_MEMCPY,\n-                    get_span_of_entire_for_loop(expr),\n+                    expr.span,\n                     \"it looks like you're manually copying between slices\",\n                     \"try replacing the loop by\",\n                     big_sugg,"}, {"sha": "fd4881b29474f95b36a7df6c8eb30171010ae362", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=e58ffb88e69094b8ee170f15f66fa472ee060752", "patch": "@@ -23,7 +23,7 @@ use rustc_hir::{Expr, ExprKind, LoopSource, Pat};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use utils::{get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n+use utils::{make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -566,14 +566,25 @@ declare_lint_pass!(Loops => [\n impl<'tcx> LateLintPass<'tcx> for Loops {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(higher::ForLoop { pat, arg, body, span }) = higher::ForLoop::hir(expr) {\n+        let for_loop = higher::ForLoop::hir(expr);\n+        if let Some(higher::ForLoop {\n+            pat,\n+            arg,\n+            body,\n+            loop_id,\n+            span,\n+        }) = for_loop\n+        {\n             // we don't want to check expanded macros\n             // this check is not at the top of the function\n             // since higher::for_loop expressions are marked as expansions\n             if body.span.from_expansion() {\n                 return;\n             }\n             check_for_loop(cx, pat, arg, body, expr, span);\n+            if let ExprKind::Block(block, _) = body.kind {\n+                never_loop::check(cx, block, loop_id, span, for_loop.as_ref());\n+            }\n         }\n \n         // we don't want to check expanded macros\n@@ -582,7 +593,9 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         }\n \n         // check for never_loop\n-        never_loop::check(cx, expr);\n+        if let ExprKind::Loop(block, ..) = expr.kind {\n+            never_loop::check(cx, block, expr.hir_id, expr.span, None);\n+        }\n \n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")"}, {"sha": "86b7d6d989acc75fd6fc3dde238947886588aa51", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=e58ffb88e69094b8ee170f15f66fa472ee060752", "patch": "@@ -4,35 +4,41 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, Node, Pat, Stmt, StmtKind};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, Pat, Stmt, StmtKind};\n use rustc_lint::LateContext;\n+use rustc_span::Span;\n use std::iter::{once, Iterator};\n \n-pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Loop(block, _, source, _) = expr.kind {\n-        match never_loop_block(block, expr.hir_id) {\n-            NeverLoopResult::AlwaysBreak => {\n-                span_lint_and_then(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\", |diag| {\n-                    if_chain! {\n-                        if source == LoopSource::ForLoop;\n-                        if let Some((_, Node::Expr(parent_match))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n-                        if let Some(ForLoop { arg: iterator, pat, span: for_span, .. }) = ForLoop::hir(parent_match);\n-                        then {\n-                            // Suggests using an `if let` instead. This is `Unspecified` because the\n-                            // loop may (probably) contain `break` statements which would be invalid\n-                            // in an `if let`.\n-                            diag.span_suggestion_verbose(\n-                                for_span.with_hi(iterator.span.hi()),\n-                                \"if you need the first element of the iterator, try writing\",\n-                                for_to_if_let_sugg(cx, iterator, pat),\n-                                Applicability::Unspecified,\n-                            );\n-                        }\n-                    };\n-                });\n-            },\n-            NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n-        }\n+pub(super) fn check(\n+    cx: &LateContext<'tcx>,\n+    block: &'tcx Block<'_>,\n+    loop_id: HirId,\n+    span: Span,\n+    for_loop: Option<&ForLoop<'_>>,\n+) {\n+    match never_loop_block(block, loop_id) {\n+        NeverLoopResult::AlwaysBreak => {\n+            span_lint_and_then(cx, NEVER_LOOP, span, \"this loop never actually loops\", |diag| {\n+                if let Some(ForLoop {\n+                    arg: iterator,\n+                    pat,\n+                    span: for_span,\n+                    ..\n+                }) = for_loop\n+                {\n+                    // Suggests using an `if let` instead. This is `Unspecified` because the\n+                    // loop may (probably) contain `break` statements which would be invalid\n+                    // in an `if let`.\n+                    diag.span_suggestion_verbose(\n+                        for_span.with_hi(iterator.span.hi()),\n+                        \"if you need the first element of the iterator, try writing\",\n+                        for_to_if_let_sugg(cx, iterator, pat),\n+                        Applicability::Unspecified,\n+                    );\n+                }\n+            });\n+        },\n+        NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n     }\n }\n "}, {"sha": "e39605f3e7d621d79ede824a4c62b37603e1b8b7", "filename": "clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=e58ffb88e69094b8ee170f15f66fa472ee060752", "patch": "@@ -1,4 +1,4 @@\n-use super::{get_span_of_entire_for_loop, SINGLE_ELEMENT_LOOP};\n+use super::SINGLE_ELEMENT_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::single_segment_path;\n use clippy_utils::source::{indent_of, snippet};\n@@ -30,7 +30,6 @@ pub(super) fn check<'tcx>(\n         if !block.stmts.is_empty();\n \n         then {\n-            let for_span = get_span_of_entire_for_loop(expr);\n             let mut block_str = snippet(cx, block.span, \"..\").into_owned();\n             block_str.remove(0);\n             block_str.pop();\n@@ -39,7 +38,7 @@ pub(super) fn check<'tcx>(\n             span_lint_and_sugg(\n                 cx,\n                 SINGLE_ELEMENT_LOOP,\n-                for_span,\n+                expr.span,\n                 \"for loop over a single element\",\n                 \"try\",\n                 format!(\"{{\\n{}let {} = &{};{}}}\", \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0)), target.name, list_item_name, block_str),"}, {"sha": "c3939a66c6accdced10229bdc3612975b71c03cf", "filename": "clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Futils.rs?ref=e58ffb88e69094b8ee170f15f66fa472ee060752", "patch": "@@ -7,7 +7,6 @@ use rustc_hir::HirIdMap;\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, Symbol};\n use std::iter::Iterator;\n \n@@ -300,17 +299,6 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n     }\n }\n \n-// this function assumes the given expression is a `for` loop.\n-pub(super) fn get_span_of_entire_for_loop(expr: &Expr<'_>) -> Span {\n-    // for some reason this is the only way to get the `Span`\n-    // of the entire `for` loop\n-    if let ExprKind::Match(_, arms, _) = &expr.kind {\n-        arms[0].body.span\n-    } else {\n-        unreachable!()\n-    }\n-}\n-\n /// If `arg` was the argument to a `for` loop, return the \"cleanest\" way of writing the\n /// actual `Iterator` that the loop uses.\n pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {"}, {"sha": "78183add9cc7c465b14b369158ae186afa7231dd", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=e58ffb88e69094b8ee170f15f66fa472ee060752", "patch": "@@ -20,8 +20,8 @@ use rustc_span::symbol::sym;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    expr_path_res, get_item_name, get_parent_expr, higher, in_constant, is_diag_trait_item, is_integer_const,\n-    iter_input_pats, last_path_segment, match_any_def_paths, paths, unsext, SpanlessEq,\n+    expr_path_res, get_item_name, get_parent_expr, in_constant, is_diag_trait_item, is_integer_const, iter_input_pats,\n+    last_path_segment, match_any_def_paths, paths, unsext, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -312,7 +312,6 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             if let StmtKind::Local(local) = stmt.kind;\n             if let PatKind::Binding(an, .., name, None) = local.pat.kind;\n             if let Some(init) = local.init;\n-            if !higher::is_from_for_desugar(local);\n             if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut;\n             then {\n                 // use the macro callsite when the init span (but not the whole local span)"}, {"sha": "b25a6e3375bb4176b3d45f610e633a8f9ce1086b", "filename": "clippy_lints/src/unit_types/let_unit_value.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs?ref=e58ffb88e69094b8ee170f15f66fa472ee060752", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::higher;\n use clippy_utils::source::snippet_with_macro_callsite;\n use rustc_errors::Applicability;\n use rustc_hir::{Stmt, StmtKind};\n@@ -14,9 +13,6 @@ pub(super) fn check(cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n             if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n                 return;\n             }\n-            if higher::is_from_for_desugar(local) {\n-                return;\n-            }\n             span_lint_and_then(\n                 cx,\n                 LET_UNIT_VALUE,"}, {"sha": "7297265d08cfbf214db556486f3d96289454b521", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 15, "deletions": 47, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58ffb88e69094b8ee170f15f66fa472ee060752/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=e58ffb88e69094b8ee170f15f66fa472ee060752", "patch": "@@ -22,31 +22,31 @@ pub struct ForLoop<'tcx> {\n     pub arg: &'tcx hir::Expr<'tcx>,\n     /// `for` loop body\n     pub body: &'tcx hir::Expr<'tcx>,\n+    /// Compare this against `hir::Destination.target`\n+    pub loop_id: HirId,\n     /// entire `for` loop span\n     pub span: Span,\n }\n \n impl<'tcx> ForLoop<'tcx> {\n-    #[inline]\n     /// Parses a desugared `for` loop\n     pub fn hir(expr: &Expr<'tcx>) -> Option<Self> {\n         if_chain! {\n-            if let hir::ExprKind::Match(iterexpr, arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-            if let Some(first_arm) = arms.get(0);\n-            if let hir::ExprKind::Call(_, iterargs) = iterexpr.kind;\n-            if let Some(first_arg) = iterargs.get(0);\n-            if iterargs.len() == 1 && arms.len() == 1 && first_arm.guard.is_none();\n-            if let hir::ExprKind::Loop(block, ..) = first_arm.body.kind;\n-            if block.expr.is_none();\n-            if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n-            if let hir::StmtKind::Local(local) = let_stmt.kind;\n-            if let hir::StmtKind::Expr(body_expr) = body.kind;\n+            if let hir::ExprKind::DropTemps(e) = expr.kind;\n+            if let hir::ExprKind::Match(iterexpr, [arm], hir::MatchSource::ForLoopDesugar) = e.kind;\n+            if let hir::ExprKind::Call(_, [arg]) = iterexpr.kind;\n+            if let hir::ExprKind::Loop(block, ..) = arm.body.kind;\n+            if let [stmt] = &*block.stmts;\n+            if let hir::StmtKind::Expr(e) = stmt.kind;\n+            if let hir::ExprKind::Match(_, [_, some_arm], _) = e.kind;\n+            if let hir::PatKind::Struct(_, [field], _) = some_arm.pat.kind;\n             then {\n                 return Some(Self {\n-                    pat: &*local.pat,\n-                    arg: first_arg,\n-                    body: body_expr,\n-                    span: first_arm.span\n+                    pat: field.pat,\n+                    arg,\n+                    body: some_arm.body,\n+                    loop_id: arm.body.hir_id,\n+                    span: expr.span.ctxt().outer_expn_data().call_site,\n                 });\n             }\n         }\n@@ -678,38 +678,6 @@ impl<'tcx> FormatArgsArg<'tcx> {\n     }\n }\n \n-/// Checks if a `let` statement is from a `for` loop desugaring.\n-pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n-    // This will detect plain for-loops without an actual variable binding:\n-    //\n-    // ```\n-    // for x in some_vec {\n-    //     // do stuff\n-    // }\n-    // ```\n-    if_chain! {\n-        if let Some(expr) = local.init;\n-        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-        then {\n-            return true;\n-        }\n-    }\n-\n-    // This detects a variable binding in for loop to avoid `let_unit_value`\n-    // lint (see issue #1964).\n-    //\n-    // ```\n-    // for _ in vec![()] {\n-    //     // anything\n-    // }\n-    // ```\n-    if let hir::LocalSource::ForLoopDesugar = local.source {\n-        return true;\n-    }\n-\n-    false\n-}\n-\n /// A parsed `panic!` expansion\n pub struct PanicExpn<'tcx> {\n     /// Span of `panic!(..)`"}, {"sha": "4d0e13c833fd768a7b0086769476aa1382d1c825", "filename": "tests/ui/author/for_loop.stdout", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e58ffb88e69094b8ee170f15f66fa472ee060752/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e58ffb88e69094b8ee170f15f66fa472ee060752/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Ffor_loop.stdout?ref=e58ffb88e69094b8ee170f15f66fa472ee060752", "patch": "@@ -11,11 +11,8 @@ if_chain! {\n     // unimplemented: field checks\n     if arms.len() == 1;\n     if let ExprKind::Loop(ref body, ref label, LoopSource::ForLoop) = arms[0].body.kind;\n-    if body.stmts.len() == 4;\n-    if let StmtKind::Local(ref local) = body.stmts[0].kind;\n-    if let PatKind::Binding(BindingAnnotation::Mutable, _, name, None) = local.pat.kind;\n-    if name.as_str() == \"__next\";\n-    if let StmtKind::Expr(ref e, _) = body.stmts[1].kind\n+    if body.stmts.len() == 1;\n+    if let StmtKind::Expr(ref e, _) = body.stmts[0].kind\n     if let ExprKind::Match(ref expr2, ref arms1, MatchSource::ForLoopDesugar) = e.kind;\n     if let ExprKind::Call(ref func1, ref args1) = expr2.kind;\n     if let ExprKind::Path(ref path2) = func1.kind;\n@@ -25,39 +22,27 @@ if_chain! {\n     if let ExprKind::Path(ref path3) = inner.kind;\n     if match_qpath(path3, &[\"iter\"]);\n     if arms1.len() == 2;\n-    if let ExprKind::Assign(ref target, ref value, ref _span) = arms1[0].body.kind;\n-    if let ExprKind::Path(ref path4) = target.kind;\n-    if match_qpath(path4, &[\"__next\"]);\n-    if let ExprKind::Path(ref path5) = value.kind;\n-    if match_qpath(path5, &[\"val\"]);\n-    if let PatKind::Struct(ref path6, ref fields1, false) = arms1[0].pat.kind;\n-    if matches!(path6, QPath::LangItem(LangItem::OptionSome, _));\n-    if fields1.len() == 1;\n-    // unimplemented: field checks\n-    if let ExprKind::Break(ref destination, None) = arms1[1].body.kind;\n-    if let PatKind::Struct(ref path7, ref fields2, false) = arms1[1].pat.kind;\n-    if matches!(path7, QPath::LangItem(LangItem::OptionNone, _));\n-    if fields2.len() == 0;\n+    if let ExprKind::Break(ref destination, None) = arms1[0].body.kind;\n+    if let PatKind::Struct(ref path4, ref fields1, false) = arms1[0].pat.kind;\n+    if matches!(path4, QPath::LangItem(LangItem::OptionNone, _));\n+    if fields1.len() == 0;\n     // unimplemented: field checks\n-    if let StmtKind::Local(ref local1) = body.stmts[2].kind;\n-    if let Some(ref init) = local1.init;\n-    if let ExprKind::Path(ref path8) = init.kind;\n-    if match_qpath(path8, &[\"__next\"]);\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local1.pat.kind;\n-    if name1.as_str() == \"y\";\n-    if let StmtKind::Expr(ref e1, _) = body.stmts[3].kind\n-    if let ExprKind::Block(ref block) = e1.kind;\n+    if let ExprKind::Block(ref block) = arms1[1].body.kind;\n     if block.stmts.len() == 1;\n-    if let StmtKind::Local(ref local2) = block.stmts[0].kind;\n-    if let Some(ref init1) = local2.init;\n-    if let ExprKind::Path(ref path9) = init1.kind;\n-    if match_qpath(path9, &[\"y\"]);\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name2, None) = local2.pat.kind;\n-    if name2.as_str() == \"z\";\n+    if let StmtKind::Local(ref local) = block.stmts[0].kind;\n+    if let Some(ref init) = local.init;\n+    if let ExprKind::Path(ref path5) = init.kind;\n+    if match_qpath(path5, &[\"y\"]);\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.kind;\n+    if name.as_str() == \"z\";\n     if block.expr.is_none();\n+    if let PatKind::Struct(ref path6, ref fields2, false) = arms1[1].pat.kind;\n+    if matches!(path6, QPath::LangItem(LangItem::OptionSome, _));\n+    if fields2.len() == 1;\n+    // unimplemented: field checks\n     if body.expr.is_none();\n-    if let PatKind::Binding(BindingAnnotation::Mutable, _, name3, None) = arms[0].pat.kind;\n-    if name3.as_str() == \"iter\";\n+    if let PatKind::Binding(BindingAnnotation::Mutable, _, name1, None) = arms[0].pat.kind;\n+    if name1.as_str() == \"iter\";\n     then {\n         // report your lint here\n     }"}]}