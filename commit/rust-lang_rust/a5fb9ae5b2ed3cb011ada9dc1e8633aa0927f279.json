{"sha": "a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZmI5YWU1YjJlZDNjYjAxMWFkYTlkYzFlODYzM2FhMDkyN2YyNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-25T19:42:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-25T19:42:22Z"}, "message": "Auto merge of #70404 - Dylan-DPC:rollup-iikcm6r, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #70226 (use checked casts and arithmetic in Miri engine)\n - #70319 (correctly normalize constants)\n - #70352 (Add long error explanation for E0710 )\n - #70366 (Implement Fuse with Option)\n - #70379 (fix incorrect type name in doc comments)\n\nFailed merges:\n\n - #70375 (avoid catching InterpError)\n\nr? @ghost", "tree": {"sha": "6155b34bb2805bc3c582b8b869e815d674d8349c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6155b34bb2805bc3c582b8b869e815d674d8349c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "html_url": "https://github.com/rust-lang/rust/commit/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8", "html_url": "https://github.com/rust-lang/rust/commit/3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8"}, {"sha": "9a9cb2d372b4e41248bf20765da306cb0c92f74a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a9cb2d372b4e41248bf20765da306cb0c92f74a", "html_url": "https://github.com/rust-lang/rust/commit/9a9cb2d372b4e41248bf20765da306cb0c92f74a"}], "stats": {"total": 1403, "additions": 825, "deletions": 578}, "files": [{"sha": "a60ca64ec87c87042331e8cb78e1bfb250d6c350", "filename": "src/libcore/iter/adapters/fuse.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -0,0 +1,342 @@\n+use crate::intrinsics;\n+use crate::iter::{\n+    DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedRandomAccess,\n+};\n+use crate::ops::Try;\n+\n+/// An iterator that yields `None` forever after the underlying iterator\n+/// yields `None` once.\n+///\n+/// This `struct` is created by the [`fuse`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`fuse`]: trait.Iterator.html#method.fuse\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Fuse<I> {\n+    // NOTE: for `I: FusedIterator`, this is always assumed `Some`!\n+    iter: Option<I>,\n+}\n+impl<I> Fuse<I> {\n+    pub(in crate::iter) fn new(iter: I) -> Fuse<I> {\n+        Fuse { iter: Some(iter) }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Fuse<I> where I: Iterator {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Fuse<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        let next = self.iter.as_mut()?.next();\n+        if next.is_none() {\n+            self.iter = None;\n+        }\n+        next\n+    }\n+\n+    #[inline]\n+    default fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        let nth = self.iter.as_mut()?.nth(n);\n+        if nth.is_none() {\n+            self.iter = None;\n+        }\n+        nth\n+    }\n+\n+    #[inline]\n+    default fn last(self) -> Option<I::Item> {\n+        self.iter?.last()\n+    }\n+\n+    #[inline]\n+    default fn count(self) -> usize {\n+        self.iter.map_or(0, I::count)\n+    }\n+\n+    #[inline]\n+    default fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.as_ref().map_or((0, Some(0)), I::size_hint)\n+    }\n+\n+    #[inline]\n+    default fn try_fold<Acc, Fold, R>(&mut self, mut acc: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        if let Some(ref mut iter) = self.iter {\n+            acc = iter.try_fold(acc, fold)?;\n+            self.iter = None;\n+        }\n+        Try::from_ok(acc)\n+    }\n+\n+    #[inline]\n+    default fn fold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if let Some(iter) = self.iter {\n+            acc = iter.fold(acc, fold);\n+        }\n+        acc\n+    }\n+\n+    #[inline]\n+    default fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        let found = self.iter.as_mut()?.find(predicate);\n+        if found.is_none() {\n+            self.iter = None;\n+        }\n+        found\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Fuse<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    #[inline]\n+    default fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        let next = self.iter.as_mut()?.next_back();\n+        if next.is_none() {\n+            self.iter = None;\n+        }\n+        next\n+    }\n+\n+    #[inline]\n+    default fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        let nth = self.iter.as_mut()?.nth_back(n);\n+        if nth.is_none() {\n+            self.iter = None;\n+        }\n+        nth\n+    }\n+\n+    #[inline]\n+    default fn try_rfold<Acc, Fold, R>(&mut self, mut acc: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        if let Some(ref mut iter) = self.iter {\n+            acc = iter.try_rfold(acc, fold)?;\n+            self.iter = None;\n+        }\n+        Try::from_ok(acc)\n+    }\n+\n+    #[inline]\n+    default fn rfold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if let Some(iter) = self.iter {\n+            acc = iter.rfold(acc, fold);\n+        }\n+        acc\n+    }\n+\n+    #[inline]\n+    default fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        let found = self.iter.as_mut()?.rfind(predicate);\n+        if found.is_none() {\n+            self.iter = None;\n+        }\n+        found\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Fuse<I>\n+where\n+    I: ExactSizeIterator,\n+{\n+    default fn len(&self) -> usize {\n+        self.iter.as_ref().map_or(0, I::len)\n+    }\n+\n+    default fn is_empty(&self) -> bool {\n+        self.iter.as_ref().map_or(true, I::is_empty)\n+    }\n+}\n+\n+// NOTE: for `I: FusedIterator`, we assume that the iterator is always `Some`\n+impl<I: FusedIterator> Fuse<I> {\n+    #[inline(always)]\n+    fn as_inner(&self) -> &I {\n+        match self.iter {\n+            Some(ref iter) => iter,\n+            // SAFETY: the specialized iterator never sets `None`\n+            None => unsafe { intrinsics::unreachable() },\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn as_inner_mut(&mut self) -> &mut I {\n+        match self.iter {\n+            Some(ref mut iter) => iter,\n+            // SAFETY: the specialized iterator never sets `None`\n+            None => unsafe { intrinsics::unreachable() },\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn into_inner(self) -> I {\n+        match self.iter {\n+            Some(iter) => iter,\n+            // SAFETY: the specialized iterator never sets `None`\n+            None => unsafe { intrinsics::unreachable() },\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> Iterator for Fuse<I>\n+where\n+    I: FusedIterator,\n+{\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.as_inner_mut().next()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        self.as_inner_mut().nth(n)\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<I::Item> {\n+        self.into_inner().last()\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.into_inner().count()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.as_inner().size_hint()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.as_inner_mut().try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.into_inner().fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        self.as_inner_mut().find(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> DoubleEndedIterator for Fuse<I>\n+where\n+    I: DoubleEndedIterator + FusedIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.as_inner_mut().next_back()\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        self.as_inner_mut().nth_back(n)\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.as_inner_mut().try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.into_inner().rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        self.as_inner_mut().rfind(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Fuse<I>\n+where\n+    I: ExactSizeIterator + FusedIterator,\n+{\n+    fn len(&self) -> usize {\n+        self.as_inner().len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.as_inner().is_empty()\n+    }\n+}\n+\n+unsafe impl<I> TrustedRandomAccess for Fuse<I>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n+        match self.iter {\n+            Some(ref mut iter) => iter.get_unchecked(i),\n+            // SAFETY: the caller asserts there is an item at `i`, so we're not exhausted.\n+            None => intrinsics::unreachable(),\n+        }\n+    }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}"}, {"sha": "16738543eb3af57139ace44e1edd8bb4871e308e", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 2, "deletions": 255, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -9,11 +9,13 @@ use super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, Tru\n \n mod chain;\n mod flatten;\n+mod fuse;\n mod zip;\n \n pub use self::chain::Chain;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::flatten::{FlatMap, Flatten};\n+pub use self::fuse::Fuse;\n pub(crate) use self::zip::TrustedRandomAccess;\n pub use self::zip::Zip;\n \n@@ -2238,261 +2240,6 @@ where\n     }\n }\n \n-/// An iterator that yields `None` forever after the underlying iterator\n-/// yields `None` once.\n-///\n-/// This `struct` is created by the [`fuse`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`fuse`]: trait.Iterator.html#method.fuse\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Fuse<I> {\n-    iter: I,\n-    done: bool,\n-}\n-impl<I> Fuse<I> {\n-    pub(super) fn new(iter: I) -> Fuse<I> {\n-        Fuse { iter, done: false }\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Fuse<I> where I: Iterator {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Fuse<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            let next = self.iter.next();\n-            self.done = next.is_none();\n-            next\n-        }\n-    }\n-\n-    #[inline]\n-    default fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            let nth = self.iter.nth(n);\n-            self.done = nth.is_none();\n-            nth\n-        }\n-    }\n-\n-    #[inline]\n-    default fn last(self) -> Option<I::Item> {\n-        if self.done { None } else { self.iter.last() }\n-    }\n-\n-    #[inline]\n-    default fn count(self) -> usize {\n-        if self.done { 0 } else { self.iter.count() }\n-    }\n-\n-    #[inline]\n-    default fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.done { (0, Some(0)) } else { self.iter.size_hint() }\n-    }\n-\n-    #[inline]\n-    default fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        if self.done {\n-            Try::from_ok(init)\n-        } else {\n-            let acc = self.iter.try_fold(init, fold)?;\n-            self.done = true;\n-            Try::from_ok(acc)\n-        }\n-    }\n-\n-    #[inline]\n-    default fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.done { init } else { self.iter.fold(init, fold) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Fuse<I>\n-where\n-    I: DoubleEndedIterator,\n-{\n-    #[inline]\n-    default fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            let next = self.iter.next_back();\n-            self.done = next.is_none();\n-            next\n-        }\n-    }\n-\n-    #[inline]\n-    default fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n-        if self.done {\n-            None\n-        } else {\n-            let nth = self.iter.nth_back(n);\n-            self.done = nth.is_none();\n-            nth\n-        }\n-    }\n-\n-    #[inline]\n-    default fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        if self.done {\n-            Try::from_ok(init)\n-        } else {\n-            let acc = self.iter.try_rfold(init, fold)?;\n-            self.done = true;\n-            Try::from_ok(acc)\n-        }\n-    }\n-\n-    #[inline]\n-    default fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.done { init } else { self.iter.rfold(init, fold) }\n-    }\n-}\n-\n-unsafe impl<I> TrustedRandomAccess for Fuse<I>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n-        self.iter.get_unchecked(i)\n-    }\n-\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> Iterator for Fuse<I>\n-where\n-    I: FusedIterator,\n-{\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        self.iter.next()\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        self.iter.nth(n)\n-    }\n-\n-    #[inline]\n-    fn last(self) -> Option<I::Item> {\n-        self.iter.last()\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> DoubleEndedIterator for Fuse<I>\n-where\n-    I: DoubleEndedIterator + FusedIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n-        self.iter.next_back()\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n-        self.iter.nth_back(n)\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Fuse<I>\n-where\n-    I: ExactSizeIterator,\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n /// An iterator that calls a function with a reference to each element before\n /// yielding it.\n ///"}, {"sha": "f4a4aab844c1475cc9d30cdbf2d48e0fe493a722", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -57,7 +57,7 @@ use crate::traits::query::{\n     CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n };\n-use crate::ty::subst::SubstsRef;\n+use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n \n use rustc_data_structures::fingerprint::Fingerprint;"}, {"sha": "26b9e1be2f5d4542d1896f3e77fe6098356c3b1e", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,18 +1,20 @@\n //! The virtual memory representation of the MIR interpreter.\n \n+use std::borrow::Cow;\n+use std::convert::TryFrom;\n+use std::iter;\n+use std::ops::{Deref, DerefMut, Range};\n+\n+use rustc_ast::ast::Mutability;\n+use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_target::abi::HasDataLayout;\n+\n use super::{\n     read_target_uint, write_target_uint, AllocId, InterpResult, Pointer, Scalar, ScalarMaybeUndef,\n };\n \n use crate::ty::layout::{Align, Size};\n \n-use rustc_ast::ast::Mutability;\n-use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_target::abi::HasDataLayout;\n-use std::borrow::Cow;\n-use std::iter;\n-use std::ops::{Deref, DerefMut, Range};\n-\n // NOTE: When adding new fields, make sure to adjust the `Snapshot` impl in\n // `src/librustc_mir/interpret/snapshot.rs`.\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n@@ -90,7 +92,7 @@ impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align) -> Self {\n         let bytes = slice.into().into_owned();\n-        let size = Size::from_bytes(bytes.len() as u64);\n+        let size = Size::from_bytes(bytes.len());\n         Self {\n             bytes,\n             relocations: Relocations::new(),\n@@ -107,9 +109,8 @@ impl<Tag> Allocation<Tag> {\n     }\n \n     pub fn undef(size: Size, align: Align) -> Self {\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n         Allocation {\n-            bytes: vec![0; size.bytes() as usize],\n+            bytes: vec![0; size.bytes_usize()],\n             relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size, false),\n             size,\n@@ -152,7 +153,7 @@ impl Allocation<(), ()> {\n /// Raw accessors. Provide access to otherwise private bytes.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     pub fn len(&self) -> usize {\n-        self.size.bytes() as usize\n+        self.size.bytes_usize()\n     }\n \n     /// Looks at a slice which may describe undefined bytes or describe a relocation. This differs\n@@ -183,20 +184,15 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     #[inline]\n     fn check_bounds(&self, offset: Size, size: Size) -> Range<usize> {\n         let end = offset + size; // This does overflow checking.\n-        assert_eq!(\n-            end.bytes() as usize as u64,\n-            end.bytes(),\n-            \"cannot handle this access on this host architecture\"\n-        );\n-        let end = end.bytes() as usize;\n+        let end = usize::try_from(end.bytes()).expect(\"access too big for this host architecture\");\n         assert!(\n             end <= self.len(),\n             \"Out-of-bounds access at offset {}, size {} in allocation of size {}\",\n             offset.bytes(),\n             size.bytes(),\n             self.len()\n         );\n-        (offset.bytes() as usize)..end\n+        offset.bytes_usize()..end\n     }\n \n     /// The last argument controls whether we error out when there are undefined\n@@ -294,11 +290,10 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n     ) -> InterpResult<'tcx, &[u8]> {\n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n+        let offset = ptr.offset.bytes_usize();\n         Ok(match self.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n-                let size_with_null = Size::from_bytes((size + 1) as u64);\n+                let size_with_null = Size::from_bytes(size) + Size::from_bytes(1);\n                 // Go through `get_bytes` for checks and AllocationExtra hooks.\n                 // We read the null, so we include it in the request, but we want it removed\n                 // from the result, so we do subslicing.\n@@ -343,7 +338,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let (lower, upper) = src.size_hint();\n         let len = upper.expect(\"can only write bounded iterators\");\n         assert_eq!(lower, len, \"can only write iterators with a precise length\");\n-        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(len as u64))?;\n+        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(len))?;\n         // `zip` would stop when the first iterator ends; we want to definitely\n         // cover all of `bytes`.\n         for dest in bytes {\n@@ -386,7 +381,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         } else {\n             match self.relocations.get(&ptr.offset) {\n                 Some(&(tag, alloc_id)) => {\n-                    let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits as u64), tag);\n+                    let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits), tag);\n                     return Ok(ScalarMaybeUndef::Scalar(ptr.into()));\n                 }\n                 None => {}\n@@ -433,7 +428,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         };\n \n         let bytes = match val.to_bits_or_ptr(type_size, cx) {\n-            Err(val) => val.offset.bytes() as u128,\n+            Err(val) => u128::from(val.offset.bytes()),\n             Ok(data) => data,\n         };\n \n@@ -524,7 +519,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n             )\n         };\n         let start = ptr.offset;\n-        let end = start + size;\n+        let end = start + size; // `Size` addition\n \n         // Mark parts of the outermost relocations as undefined if they partially fall outside the\n         // given range.\n@@ -563,7 +558,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     #[inline]\n     fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         self.undef_mask\n-            .is_range_defined(ptr.offset, ptr.offset + size)\n+            .is_range_defined(ptr.offset, ptr.offset + size) // `Size` addition\n             .or_else(|idx| throw_ub!(InvalidUndefBytes(Some(Pointer::new(ptr.alloc_id, idx)))))\n     }\n \n@@ -643,7 +638,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         if defined.ranges.len() <= 1 {\n             self.undef_mask.set_range_inbounds(\n                 dest.offset,\n-                dest.offset + size * repeat,\n+                dest.offset + size * repeat, // `Size` operations\n                 defined.initial,\n             );\n             return;\n@@ -721,10 +716,10 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         for i in 0..length {\n             new_relocations.extend(relocations.iter().map(|&(offset, reloc)| {\n                 // compute offset for current repetition\n-                let dest_offset = dest.offset + (i * size);\n+                let dest_offset = dest.offset + size * i; // `Size` operations\n                 (\n                     // shift offsets from source allocation to destination allocation\n-                    offset + dest_offset - src.offset,\n+                    (offset + dest_offset) - src.offset, // `Size` operations\n                     reloc,\n                 )\n             }));\n@@ -861,18 +856,18 @@ impl UndefMask {\n         if amount.bytes() == 0 {\n             return;\n         }\n-        let unused_trailing_bits = self.blocks.len() as u64 * Self::BLOCK_SIZE - self.len.bytes();\n+        let unused_trailing_bits =\n+            u64::try_from(self.blocks.len()).unwrap() * Self::BLOCK_SIZE - self.len.bytes();\n         if amount.bytes() > unused_trailing_bits {\n             let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n-            assert_eq!(additional_blocks as usize as u64, additional_blocks);\n             self.blocks.extend(\n                 // FIXME(oli-obk): optimize this by repeating `new_state as Block`.\n-                iter::repeat(0).take(additional_blocks as usize),\n+                iter::repeat(0).take(usize::try_from(additional_blocks).unwrap()),\n             );\n         }\n         let start = self.len;\n         self.len += amount;\n-        self.set_range_inbounds(start, start + amount, new_state);\n+        self.set_range_inbounds(start, start + amount, new_state); // `Size` operation\n     }\n }\n \n@@ -881,7 +876,5 @@ fn bit_index(bits: Size) -> (usize, usize) {\n     let bits = bits.bytes();\n     let a = bits / UndefMask::BLOCK_SIZE;\n     let b = bits % UndefMask::BLOCK_SIZE;\n-    assert_eq!(a as usize as u64, a);\n-    assert_eq!(b as usize as u64, b);\n-    (a as usize, b as usize)\n+    (usize::try_from(a).unwrap(), usize::try_from(b).unwrap())\n }"}, {"sha": "10c3a06da081063be927307c4606c897325c08b2", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -95,6 +95,27 @@ mod pointer;\n mod queries;\n mod value;\n \n+use std::convert::TryFrom;\n+use std::fmt;\n+use std::io;\n+use std::num::NonZeroU32;\n+use std::sync::atomic::{AtomicU32, Ordering};\n+\n+use byteorder::{BigEndian, LittleEndian, ReadBytesExt, WriteBytesExt};\n+use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::{HashMapExt, Lock};\n+use rustc_data_structures::tiny_list::TinyList;\n+use rustc_hir::def_id::DefId;\n+use rustc_macros::HashStable;\n+use rustc_serialize::{Decodable, Encodable, Encoder};\n+\n+use crate::mir;\n+use crate::ty::codec::TyDecoder;\n+use crate::ty::layout::{self, Size};\n+use crate::ty::subst::GenericArgKind;\n+use crate::ty::{self, Instance, Ty, TyCtxt};\n+\n pub use self::error::{\n     struct_error, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled, FrameInfo,\n     InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n@@ -107,24 +128,6 @@ pub use self::allocation::{Allocation, AllocationExtra, Relocations, UndefMask};\n \n pub use self::pointer::{CheckInAllocMsg, Pointer, PointerArithmetic};\n \n-use crate::mir;\n-use crate::ty::codec::TyDecoder;\n-use crate::ty::layout::{self, Size};\n-use crate::ty::subst::GenericArgKind;\n-use crate::ty::{self, Instance, Ty, TyCtxt};\n-use byteorder::{BigEndian, LittleEndian, ReadBytesExt, WriteBytesExt};\n-use rustc_ast::ast::LitKind;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::{HashMapExt, Lock};\n-use rustc_data_structures::tiny_list::TinyList;\n-use rustc_hir::def_id::DefId;\n-use rustc_macros::HashStable;\n-use rustc_serialize::{Decodable, Encodable, Encoder};\n-use std::fmt;\n-use std::io;\n-use std::num::NonZeroU32;\n-use std::sync::atomic::{AtomicU32, Ordering};\n-\n /// Uniquely identifies one of the following:\n /// - A constant\n /// - A static\n@@ -264,8 +267,8 @@ impl<'s> AllocDecodingSession<'s> {\n         D: TyDecoder<'tcx>,\n     {\n         // Read the index of the allocation.\n-        let idx = decoder.read_u32()? as usize;\n-        let pos = self.state.data_offsets[idx] as usize;\n+        let idx = usize::try_from(decoder.read_u32()?).unwrap();\n+        let pos = usize::try_from(self.state.data_offsets[idx]).unwrap();\n \n         // Decode the `AllocDiscriminant` now so that we know if we have to reserve an\n         // `AllocId`."}, {"sha": "3f841cfb3300326addce2ef4de00ed112433a5db", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -62,9 +62,9 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     /// This should be called by all the other methods before returning!\n     #[inline]\n     fn truncate_to_ptr(&self, (val, over): (u64, bool)) -> (u64, bool) {\n-        let val = val as u128;\n+        let val = u128::from(val);\n         let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n-        ((val % max_ptr_plus_1) as u64, over || val >= max_ptr_plus_1)\n+        (u64::try_from(val % max_ptr_plus_1).unwrap(), over || val >= max_ptr_plus_1)\n     }\n \n     #[inline]\n@@ -73,17 +73,16 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n         self.truncate_to_ptr(res)\n     }\n \n-    // Overflow checking only works properly on the range from -u64 to +u64.\n     #[inline]\n-    fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n-        // FIXME: is it possible to over/underflow here?\n+    fn overflowing_signed_offset(&self, val: u64, i: i64) -> (u64, bool) {\n         if i < 0 {\n             // Trickery to ensure that `i64::MIN` works fine: compute `n = -i`.\n             // This formula only works for true negative values; it overflows for zero!\n             let n = u64::MAX - (i as u64) + 1;\n             let res = val.overflowing_sub(n);\n             self.truncate_to_ptr(res)\n         } else {\n+            // `i >= 0`, so the cast is safe.\n             self.overflowing_offset(val, i as u64)\n         }\n     }\n@@ -96,7 +95,7 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n \n     #[inline]\n     fn signed_offset<'tcx>(&self, val: u64, i: i64) -> InterpResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n+        let (res, over) = self.overflowing_signed_offset(val, i);\n         if over { throw_ub!(PointerArithOverflow) } else { Ok(res) }\n     }\n }\n@@ -189,14 +188,14 @@ impl<'tcx, Tag> Pointer<Tag> {\n     }\n \n     #[inline]\n-    pub fn overflowing_signed_offset(self, i: i128, cx: &impl HasDataLayout) -> (Self, bool) {\n+    pub fn overflowing_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n         (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n     }\n \n     #[inline(always)]\n     pub fn wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n-        self.overflowing_signed_offset(i128::from(i), cx).0\n+        self.overflowing_signed_offset(i, cx).0\n     }\n \n     #[inline(always)]"}, {"sha": "706cf1cd09a79048898f42c97586f78f9630a55d", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 54, "deletions": 52, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,9 +1,12 @@\n+use std::convert::TryFrom;\n+use std::fmt;\n+\n use rustc_apfloat::{\n     ieee::{Double, Single},\n     Float,\n };\n use rustc_macros::HashStable;\n-use std::fmt;\n+use rustc_target::abi::TargetDataLayout;\n \n use crate::ty::{\n     layout::{HasDataLayout, Size},\n@@ -156,7 +159,7 @@ impl Scalar<()> {\n     #[inline(always)]\n     fn check_data(data: u128, size: u8) {\n         debug_assert_eq!(\n-            truncate(data, Size::from_bytes(size as u64)),\n+            truncate(data, Size::from_bytes(u64::from(size))),\n             data,\n             \"Scalar value {:#x} exceeds size of {} bytes\",\n             data,\n@@ -198,55 +201,54 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Scalar::Raw { data: 0, size: 0 }\n     }\n \n-    #[inline]\n-    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n-        let dl = cx.data_layout();\n+    #[inline(always)]\n+    fn ptr_op(\n+        self,\n+        dl: &TargetDataLayout,\n+        f_int: impl FnOnce(u64) -> InterpResult<'tcx, u64>,\n+        f_ptr: impl FnOnce(Pointer<Tag>) -> InterpResult<'tcx, Pointer<Tag>>,\n+    ) -> InterpResult<'tcx, Self> {\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Ok(Scalar::Raw { data: dl.offset(data as u64, i.bytes())? as u128, size })\n+                assert_eq!(u64::from(size), dl.pointer_size.bytes());\n+                Ok(Scalar::Raw { data: u128::from(f_int(u64::try_from(data).unwrap())?), size })\n             }\n-            Scalar::Ptr(ptr) => ptr.offset(i, dl).map(Scalar::Ptr),\n+            Scalar::Ptr(ptr) => Ok(Scalar::Ptr(f_ptr(ptr)?)),\n         }\n     }\n \n+    #[inline]\n+    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n+        let dl = cx.data_layout();\n+        self.ptr_op(dl, |int| dl.offset(int, i.bytes()), |ptr| ptr.offset(i, dl))\n+    }\n+\n     #[inline]\n     pub fn ptr_wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n         let dl = cx.data_layout();\n-        match self {\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Scalar::Raw { data: dl.overflowing_offset(data as u64, i.bytes()).0 as u128, size }\n-            }\n-            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_offset(i, dl)),\n-        }\n+        self.ptr_op(\n+            dl,\n+            |int| Ok(dl.overflowing_offset(int, i.bytes()).0),\n+            |ptr| Ok(ptr.wrapping_offset(i, dl)),\n+        )\n+        .unwrap()\n     }\n \n     #[inline]\n     pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n         let dl = cx.data_layout();\n-        match self {\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, dl.pointer_size().bytes());\n-                Ok(Scalar::Raw { data: dl.signed_offset(data as u64, i)? as u128, size })\n-            }\n-            Scalar::Ptr(ptr) => ptr.signed_offset(i, dl).map(Scalar::Ptr),\n-        }\n+        self.ptr_op(dl, |int| dl.signed_offset(int, i), |ptr| ptr.signed_offset(i, dl))\n     }\n \n     #[inline]\n     pub fn ptr_wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n         let dl = cx.data_layout();\n-        match self {\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Scalar::Raw {\n-                    data: dl.overflowing_signed_offset(data as u64, i128::from(i)).0 as u128,\n-                    size,\n-                }\n-            }\n-            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_signed_offset(i, dl)),\n-        }\n+        self.ptr_op(\n+            dl,\n+            |int| Ok(dl.overflowing_signed_offset(int, i).0),\n+            |ptr| Ok(ptr.wrapping_signed_offset(i, dl)),\n+        )\n+        .unwrap()\n     }\n \n     #[inline]\n@@ -281,25 +283,25 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn from_u8(i: u8) -> Self {\n         // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i as u128, size: 1 }\n+        Scalar::Raw { data: i.into(), size: 1 }\n     }\n \n     #[inline]\n     pub fn from_u16(i: u16) -> Self {\n         // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i as u128, size: 2 }\n+        Scalar::Raw { data: i.into(), size: 2 }\n     }\n \n     #[inline]\n     pub fn from_u32(i: u32) -> Self {\n         // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i as u128, size: 4 }\n+        Scalar::Raw { data: i.into(), size: 4 }\n     }\n \n     #[inline]\n     pub fn from_u64(i: u64) -> Self {\n         // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i as u128, size: 8 }\n+        Scalar::Raw { data: i.into(), size: 8 }\n     }\n \n     #[inline]\n@@ -376,7 +378,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(target_size.bytes(), size as u64);\n+                assert_eq!(target_size.bytes(), u64::from(size));\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }\n@@ -394,7 +396,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(target_size.bytes(), size as u64);\n+                assert_eq!(target_size.bytes(), u64::from(size));\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }\n@@ -458,27 +460,27 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     /// Converts the scalar to produce an `u8`. Fails if the scalar is a pointer.\n     pub fn to_u8(self) -> InterpResult<'static, u8> {\n-        self.to_unsigned_with_bit_width(8).map(|v| v as u8)\n+        self.to_unsigned_with_bit_width(8).map(|v| u8::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `u16`. Fails if the scalar is a pointer.\n     pub fn to_u16(self) -> InterpResult<'static, u16> {\n-        self.to_unsigned_with_bit_width(16).map(|v| v as u16)\n+        self.to_unsigned_with_bit_width(16).map(|v| u16::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `u32`. Fails if the scalar is a pointer.\n     pub fn to_u32(self) -> InterpResult<'static, u32> {\n-        self.to_unsigned_with_bit_width(32).map(|v| v as u32)\n+        self.to_unsigned_with_bit_width(32).map(|v| u32::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `u64`. Fails if the scalar is a pointer.\n     pub fn to_u64(self) -> InterpResult<'static, u64> {\n-        self.to_unsigned_with_bit_width(64).map(|v| v as u64)\n+        self.to_unsigned_with_bit_width(64).map(|v| u64::try_from(v).unwrap())\n     }\n \n     pub fn to_machine_usize(self, cx: &impl HasDataLayout) -> InterpResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n-        Ok(b as u64)\n+        Ok(u64::try_from(b).unwrap())\n     }\n \n     #[inline]\n@@ -490,41 +492,41 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     /// Converts the scalar to produce an `i8`. Fails if the scalar is a pointer.\n     pub fn to_i8(self) -> InterpResult<'static, i8> {\n-        self.to_signed_with_bit_width(8).map(|v| v as i8)\n+        self.to_signed_with_bit_width(8).map(|v| i8::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i16`. Fails if the scalar is a pointer.\n     pub fn to_i16(self) -> InterpResult<'static, i16> {\n-        self.to_signed_with_bit_width(16).map(|v| v as i16)\n+        self.to_signed_with_bit_width(16).map(|v| i16::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i32`. Fails if the scalar is a pointer.\n     pub fn to_i32(self) -> InterpResult<'static, i32> {\n-        self.to_signed_with_bit_width(32).map(|v| v as i32)\n+        self.to_signed_with_bit_width(32).map(|v| i32::try_from(v).unwrap())\n     }\n \n     /// Converts the scalar to produce an `i64`. Fails if the scalar is a pointer.\n     pub fn to_i64(self) -> InterpResult<'static, i64> {\n-        self.to_signed_with_bit_width(64).map(|v| v as i64)\n+        self.to_signed_with_bit_width(64).map(|v| i64::try_from(v).unwrap())\n     }\n \n     pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'static, i64> {\n         let sz = cx.data_layout().pointer_size;\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n-        Ok(b as i64)\n+        Ok(i64::try_from(b).unwrap())\n     }\n \n     #[inline]\n     pub fn to_f32(self) -> InterpResult<'static, Single> {\n         // Going through `u32` to check size and truncation.\n-        Ok(Single::from_bits(self.to_u32()? as u128))\n+        Ok(Single::from_bits(self.to_u32()?.into()))\n     }\n \n     #[inline]\n     pub fn to_f64(self) -> InterpResult<'static, Double> {\n         // Going through `u64` to check size and truncation.\n-        Ok(Double::from_bits(self.to_u64()? as u128))\n+        Ok(Double::from_bits(self.to_u64()?.into()))\n     }\n }\n \n@@ -671,8 +673,8 @@ pub fn get_slice_bytes<'tcx>(cx: &impl HasDataLayout, val: ConstValue<'tcx>) ->\n         data.get_bytes(\n             cx,\n             // invent a pointer, only the offset is relevant anyway\n-            Pointer::new(AllocId(0), Size::from_bytes(start as u64)),\n-            Size::from_bytes(len as u64),\n+            Pointer::new(AllocId(0), Size::from_bytes(start)),\n+            Size::from_bytes(len),\n         )\n         .unwrap_or_else(|err| bug!(\"const slice is invalid: {:?}\", err))\n     } else {"}, {"sha": "1cc5c6e6f4ae7c48c62e75eda5b0be000d6068c6", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -9,7 +9,7 @@ use crate::traits::query::{\n };\n use crate::ty::query::queries;\n use crate::ty::query::QueryDescription;\n-use crate::ty::subst::SubstsRef;\n+use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n \n@@ -1114,10 +1114,10 @@ rustc_queries! {\n         }\n \n         /// Do not call this query directly: invoke `normalize_erasing_regions` instead.\n-        query normalize_ty_after_erasing_regions(\n-            goal: ParamEnvAnd<'tcx, Ty<'tcx>>\n-        ) -> Ty<'tcx> {\n-            desc { \"normalizing `{:?}`\", goal }\n+        query normalize_generic_arg_after_erasing_regions(\n+            goal: ParamEnvAnd<'tcx, GenericArg<'tcx>>\n+        ) -> GenericArg<'tcx> {\n+            desc { \"normalizing `{}`\", goal.value }\n         }\n \n         query implied_outlives_bounds("}, {"sha": "b1fb02a67b3ff3a8447747960d2c2224990524e7", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -273,6 +273,20 @@ impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n         t.super_visit_with(self)\n     }\n \n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        match c.val {\n+            ty::ConstKind::Bound(debruijn, bound_var) if debruijn == self.binder_index => {\n+                self.types.insert(\n+                    bound_var.as_u32(),\n+                    Symbol::intern(&format!(\"^{}\", bound_var.as_u32())),\n+                );\n+            }\n+            _ => (),\n+        }\n+\n+        c.super_visit_with(self)\n+    }\n+\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         match r {\n             ty::ReLateBound(index, br) if *index == self.binder_index => match br {"}, {"sha": "3f4f2407f1e6e2fc9e9b9ebd160f2d04b78035a3", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -978,17 +978,27 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // ignore the inputs to a projection, as they may not appear\n         // in the normalized form\n         if self.just_constrained {\n-            match t.kind {\n-                ty::Projection(..) | ty::Opaque(..) => {\n-                    return false;\n-                }\n-                _ => {}\n+            if let ty::Projection(..) | ty::Opaque(..) = t.kind {\n+                return false;\n             }\n         }\n \n         t.super_visit_with(self)\n     }\n \n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        // if we are only looking for \"constrained\" region, we have to\n+        // ignore the inputs of an unevaluated const, as they may not appear\n+        // in the normalized form\n+        if self.just_constrained {\n+            if let ty::ConstKind::Unevaluated(..) = c.val {\n+                return false;\n+            }\n+        }\n+\n+        c.super_visit_with(self)\n+    }\n+\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         if let ty::ReLateBound(debruijn, br) = *r {\n             if debruijn == self.current_index {"}, {"sha": "2f0a57c59eb14abc0d8672ca7b9ee5f19be510ce", "filename": "src/librustc/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fnormalize_erasing_regions.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -4,8 +4,8 @@\n //!\n //! The methods in this file use a `TypeFolder` to recursively process\n //! contents, invoking the underlying\n-//! `normalize_ty_after_erasing_regions` query for each type found\n-//! within. (This underlying query is what is cached.)\n+//! `normalize_generic_arg_after_erasing_regions` query for each type\n+//! or constant found within. (This underlying query is what is cached.)\n \n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::ty::subst::{Subst, SubstsRef};\n@@ -94,6 +94,12 @@ impl TypeFolder<'tcx> for NormalizeAfterErasingRegionsFolder<'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.tcx.normalize_ty_after_erasing_regions(self.param_env.and(ty))\n+        let arg = self.param_env.and(ty.into());\n+        self.tcx.normalize_generic_arg_after_erasing_regions(arg).expect_ty()\n+    }\n+\n+    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        let arg = self.param_env.and(c.into());\n+        self.tcx.normalize_generic_arg_after_erasing_regions(arg).expect_const()\n     }\n }"}, {"sha": "b1626d95eb3e88bd25fa3ced6e717bc5e19ec08b", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -981,7 +981,7 @@ pub trait PrettyPrinter<'tcx>:\n                     .alloc_map\n                     .lock()\n                     .unwrap_memory(ptr.alloc_id)\n-                    .get_bytes(&self.tcx(), ptr, Size::from_bytes(*data as u64))\n+                    .get_bytes(&self.tcx(), ptr, Size::from_bytes(*data))\n                     .unwrap();\n                 p!(pretty_print_byte_str(byte_str));\n             }\n@@ -1169,7 +1169,7 @@ pub trait PrettyPrinter<'tcx>:\n             (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {\n                 let n = n.val.try_to_bits(self.tcx().data_layout.pointer_size).unwrap();\n                 // cast is ok because we already checked for pointer size (32 or 64 bit) above\n-                let n = Size::from_bytes(n as u64);\n+                let n = Size::from_bytes(n);\n                 let ptr = Pointer::new(AllocId(0), offset);\n \n                 let byte_str = alloc.get_bytes(&self.tcx(), ptr, n).unwrap();"}, {"sha": "6be1f04efca2b5366a58cfc3de30e51447cebae0", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -5,7 +5,7 @@ use crate::mir;\n use crate::traits;\n use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::query::caches::DefaultCacheSelector;\n-use crate::ty::subst::SubstsRef;\n+use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_span::symbol::Symbol;\n@@ -194,6 +194,17 @@ impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for GenericArg<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl<'tcx> Key for &'tcx ty::Const<'tcx> {\n     type CacheSelector = DefaultCacheSelector;\n "}, {"sha": "c75e0d95e8fdfa01b6b484e5b4efc3ae880376d2", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -31,7 +31,7 @@ use crate::traits::specialization_graph;\n use crate::traits::Clauses;\n use crate::traits::{self, Vtable};\n use crate::ty::steal::Steal;\n-use crate::ty::subst::SubstsRef;\n+use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use crate::util::common::ErrorReported;"}, {"sha": "0f4485a705046dff5d33017a6fd09b8edb99d338", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -128,6 +128,14 @@ impl<'tcx> GenericArg<'tcx> {\n             _ => bug!(\"expected a type, but found another kind\"),\n         }\n     }\n+\n+    /// Unpack the `GenericArg` as a const when it is known certainly to be a const.\n+    pub fn expect_const(self) -> &'tcx ty::Const<'tcx> {\n+        match self.unpack() {\n+            GenericArgKind::Const(c) => c,\n+            _ => bug!(\"expected a const, but found another kind\"),\n+        }\n+    }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for GenericArg<'a> {"}, {"sha": "3e7fb0e73bffee6a5caefaf9e80fe2c359248dae", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1614,7 +1614,7 @@ impl FloatTy {\n         }\n     }\n \n-    pub fn bit_width(self) -> usize {\n+    pub fn bit_width(self) -> u64 {\n         match self {\n             FloatTy::F32 => 32,\n             FloatTy::F64 => 64,\n@@ -1663,7 +1663,7 @@ impl IntTy {\n         format!(\"{}{}\", val as u128, self.name_str())\n     }\n \n-    pub fn bit_width(&self) -> Option<usize> {\n+    pub fn bit_width(&self) -> Option<u64> {\n         Some(match *self {\n             IntTy::Isize => return None,\n             IntTy::I8 => 8,\n@@ -1725,7 +1725,7 @@ impl UintTy {\n         format!(\"{}{}\", val, self.name_str())\n     }\n \n-    pub fn bit_width(&self) -> Option<usize> {\n+    pub fn bit_width(&self) -> Option<u64> {\n         Some(match *self {\n             UintTy::Usize => return None,\n             UintTy::U8 => 8,"}, {"sha": "bc25b9496d9b59905368f59efa2125809374e280", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1172,8 +1172,8 @@ fn generic_simd_intrinsic(\n         let m_len = match in_ty.kind {\n             // Note that this `.unwrap()` crashes for isize/usize, that's sort\n             // of intentional as there's not currently a use case for that.\n-            ty::Int(i) => i.bit_width().unwrap() as u64,\n-            ty::Uint(i) => i.bit_width().unwrap() as u64,\n+            ty::Int(i) => i.bit_width().unwrap(),\n+            ty::Uint(i) => i.bit_width().unwrap(),\n             _ => return_error!(\"`{}` is not an integral type\", in_ty),\n         };\n         require_simd!(arg_tys[1], \"argument\");\n@@ -1354,20 +1354,18 @@ fn generic_simd_intrinsic(\n         // trailing bits.\n         let expected_int_bits = in_len.max(8);\n         match ret_ty.kind {\n-            ty::Uint(i) if i.bit_width() == Some(expected_int_bits as usize) => (),\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => (),\n             _ => return_error!(\"bitmask `{}`, expected `u{}`\", ret_ty, expected_int_bits),\n         }\n \n         // Integer vector <i{in_bitwidth} x in_len>:\n         let (i_xn, in_elem_bitwidth) = match in_elem.kind {\n-            ty::Int(i) => (\n-                args[0].immediate(),\n-                i.bit_width().unwrap_or(bx.data_layout().pointer_size.bits() as _),\n-            ),\n-            ty::Uint(i) => (\n-                args[0].immediate(),\n-                i.bit_width().unwrap_or(bx.data_layout().pointer_size.bits() as _),\n-            ),\n+            ty::Int(i) => {\n+                (args[0].immediate(), i.bit_width().unwrap_or(bx.data_layout().pointer_size.bits()))\n+            }\n+            ty::Uint(i) => {\n+                (args[0].immediate(), i.bit_width().unwrap_or(bx.data_layout().pointer_size.bits()))\n+            }\n             _ => return_error!(\n                 \"vector argument `{}`'s element type `{}`, expected integer element type\",\n                 in_ty,\n@@ -1378,16 +1376,16 @@ fn generic_simd_intrinsic(\n         // Shift the MSB to the right by \"in_elem_bitwidth - 1\" into the first bit position.\n         let shift_indices =\n             vec![\n-                bx.cx.const_int(bx.type_ix(in_elem_bitwidth as _), (in_elem_bitwidth - 1) as _);\n+                bx.cx.const_int(bx.type_ix(in_elem_bitwidth), (in_elem_bitwidth - 1) as _);\n                 in_len as _\n             ];\n         let i_xn_msb = bx.lshr(i_xn, bx.const_vector(shift_indices.as_slice()));\n         // Truncate vector to an <i1 x N>\n-        let i1xn = bx.trunc(i_xn_msb, bx.type_vector(bx.type_i1(), in_len as _));\n+        let i1xn = bx.trunc(i_xn_msb, bx.type_vector(bx.type_i1(), in_len));\n         // Bitcast <i1 x N> to iN:\n-        let i_ = bx.bitcast(i1xn, bx.type_ix(in_len as _));\n+        let i_ = bx.bitcast(i1xn, bx.type_ix(in_len));\n         // Zero-extend iN to the bitmask type:\n-        return Ok(bx.zext(i_, bx.type_ix(expected_int_bits as _)));\n+        return Ok(bx.zext(i_, bx.type_ix(expected_int_bits)));\n     }\n \n     fn simd_simple_float_intrinsic(\n@@ -2099,7 +2097,7 @@ fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, boo\n     match ty.kind {\n         ty::Int(t) => Some((\n             match t {\n-                ast::IntTy::Isize => cx.tcx.sess.target.ptr_width as u64,\n+                ast::IntTy::Isize => u64::from(cx.tcx.sess.target.ptr_width),\n                 ast::IntTy::I8 => 8,\n                 ast::IntTy::I16 => 16,\n                 ast::IntTy::I32 => 32,\n@@ -2110,7 +2108,7 @@ fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, boo\n         )),\n         ty::Uint(t) => Some((\n             match t {\n-                ast::UintTy::Usize => cx.tcx.sess.target.ptr_width as u64,\n+                ast::UintTy::Usize => u64::from(cx.tcx.sess.target.ptr_width),\n                 ast::UintTy::U8 => 8,\n                 ast::UintTy::U16 => 16,\n                 ast::UintTy::U32 => 32,\n@@ -2127,7 +2125,7 @@ fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, boo\n // Returns None if the type is not a float\n fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n     match ty.kind {\n-        ty::Float(t) => Some(t.bit_width() as u64),\n+        ty::Float(t) => Some(t.bit_width()),\n         _ => None,\n     }\n }"}, {"sha": "5bb30d03d9f8d6997682daddb126c74aa2ba41fc", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 };\n                 let a = Scalar::from(Pointer::new(\n                     bx.tcx().alloc_map.lock().create_memory_alloc(data),\n-                    Size::from_bytes(start as u64),\n+                    Size::from_bytes(start),\n                 ));\n                 let a_llval = bx.scalar_to_backend(\n                     a,"}, {"sha": "86da425060efabfc5984ff5340a83b514b6a15d1", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -393,6 +393,7 @@ E0701: include_str!(\"./error_codes/E0701.md\"),\n E0704: include_str!(\"./error_codes/E0704.md\"),\n E0705: include_str!(\"./error_codes/E0705.md\"),\n E0706: include_str!(\"./error_codes/E0706.md\"),\n+E0710: include_str!(\"./error_codes/E0710.md\"),\n E0712: include_str!(\"./error_codes/E0712.md\"),\n E0713: include_str!(\"./error_codes/E0713.md\"),\n E0714: include_str!(\"./error_codes/E0714.md\"),\n@@ -604,7 +605,6 @@ E0748: include_str!(\"./error_codes/E0748.md\"),\n     E0708, // `async` non-`move` closures with parameters are not currently\n            // supported\n //  E0709, // multiple different lifetimes used in arguments of `async fn`\n-    E0710, // an unknown tool name found in scoped lint\n     E0711, // a feature has been declared with conflicting stability attributes\n     E0717, // rustc_promotable without stability attribute\n //  E0721, // `await` keyword"}, {"sha": "d9cefe2a6da7264ecf73217b820d20fa44977fd1", "filename": "src/librustc_error_codes/error_codes/E0710.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_error_codes%2Ferror_codes%2FE0710.md", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_error_codes%2Ferror_codes%2FE0710.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0710.md?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -0,0 +1,34 @@\n+An unknown tool name found in scoped lint\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0710\n+#[allow(clipp::filter_map)] // error!`\n+fn main() {\n+    // business logic\n+}\n+```\n+\n+```compile_fail,E0710\n+#[warn(clipp::filter_map)] // error!`\n+fn main() {\n+    // business logic\n+}\n+```\n+\n+Please verify you didn't misspell the tool's name or that you didn't\n+forget to import it in you project:\n+\n+```\n+#[allow(clippy::filter_map)] // ok!\n+fn main() {\n+    // business logic\n+}\n+```\n+\n+```\n+#[warn(clippy::filter_map)] // ok!\n+fn main() {\n+    // business logic\n+}\n+```"}, {"sha": "6e7e6f9d34526277f6c6a68cf87f776d62602497", "filename": "src/librustc_mir/const_eval/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,5 +1,7 @@\n // Not in interpret to make sure we do not use private implementation details\n \n+use std::convert::TryFrom;\n+\n use rustc::mir;\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::{self, TyCtxt};\n@@ -37,7 +39,7 @@ pub(crate) fn const_field<'tcx>(\n         Some(variant) => ecx.operand_downcast(op, variant).unwrap(),\n     };\n     // then project\n-    let field = ecx.operand_field(down, field.index() as u64).unwrap();\n+    let field = ecx.operand_field(down, field.index()).unwrap();\n     // and finally move back to the const world, always normalizing because\n     // this is not called for statics.\n     op_to_const(&ecx, field)\n@@ -68,10 +70,11 @@ pub(crate) fn destructure_const<'tcx>(\n \n     let variant = ecx.read_discriminant(op).unwrap().1;\n \n+    // We go to `usize` as we cannot allocate anything bigger anyway.\n     let field_count = match val.ty.kind {\n-        ty::Array(_, len) => len.eval_usize(tcx, param_env),\n-        ty::Adt(def, _) => def.variants[variant].fields.len() as u64,\n-        ty::Tuple(substs) => substs.len() as u64,\n+        ty::Array(_, len) => usize::try_from(len.eval_usize(tcx, param_env)).unwrap(),\n+        ty::Adt(def, _) => def.variants[variant].fields.len(),\n+        ty::Tuple(substs) => substs.len(),\n         _ => bug!(\"cannot destructure constant {:?}\", val),\n     };\n "}, {"sha": "f7327825ca4b76be26a6a59975bd46b5b57f0f6c", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,3 +1,5 @@\n+use std::convert::TryFrom;\n+\n use rustc::ty::adjustment::PointerCast;\n use rustc::ty::layout::{self, Size, TyLayout};\n use rustc::ty::{self, Ty, TypeAndMut, TypeFoldable};\n@@ -206,8 +208,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Char => {\n                 // `u8` to `char` cast\n-                assert_eq!(v as u8 as u128, v);\n-                Ok(Scalar::from_uint(v, Size::from_bytes(4)))\n+                Ok(Scalar::from_uint(u8::try_from(v).unwrap(), Size::from_bytes(4)))\n             }\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n@@ -227,16 +228,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match dest_ty.kind {\n             // float -> uint\n             Uint(t) => {\n-                let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits() as usize);\n-                let v = f.to_u128(width).value;\n+                let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits());\n+                let v = f.to_u128(usize::try_from(width).unwrap()).value;\n                 // This should already fit the bit width\n-                Ok(Scalar::from_uint(v, Size::from_bits(width as u64)))\n+                Ok(Scalar::from_uint(v, Size::from_bits(width)))\n             }\n             // float -> int\n             Int(t) => {\n-                let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits() as usize);\n-                let v = f.to_i128(width).value;\n-                Ok(Scalar::from_int(v, Size::from_bits(width as u64)))\n+                let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits());\n+                let v = f.to_i128(usize::try_from(width).unwrap()).value;\n+                Ok(Scalar::from_int(v, Size::from_bits(width)))\n             }\n             // float -> f32\n             Float(FloatTy::F32) => Ok(Scalar::from_f32(f.convert(&mut false).value)),\n@@ -319,11 +320,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n                 for i in 0..src.layout.fields.count() {\n-                    let dst_field = self.place_field(dest, i as u64)?;\n+                    let dst_field = self.place_field(dest, i)?;\n                     if dst_field.layout.is_zst() {\n                         continue;\n                     }\n-                    let src_field = self.operand_field(src, i as u64)?;\n+                    let src_field = self.operand_field(src, i)?;\n                     if src_field.layout.ty == dst_field.layout.ty {\n                         self.copy_op(src_field, dst_field)?;\n                     } else {"}, {"sha": "c2baabf4233ce6157c59faddb0ea07e56cf8295e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -413,6 +413,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // and it also rounds up to alignment, which we want to avoid,\n                 // as the unsized field's alignment could be smaller.\n                 assert!(!layout.ty.is_simd());\n+                assert!(layout.fields.count() > 0);\n                 trace!(\"DST layout: {:?}\", layout);\n \n                 let sized_size = layout.fields.offset(layout.fields.count() - 1);\n@@ -452,7 +453,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // here. But this is where the add would go.)\n \n                 // Return the sum of sizes and max of aligns.\n-                let size = sized_size + unsized_size;\n+                let size = sized_size + unsized_size; // `Size` addition\n \n                 // Choose max of two known alignments (combined value must\n                 // be aligned according to more restrictive of the two)."}, {"sha": "e5f89b10e76ed722432828219f46cac5ebeefad4", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -29,11 +29,11 @@ fn numeric_intrinsic<'tcx, Tag>(\n         Primitive::Int(integer, _) => integer.size(),\n         _ => bug!(\"invalid `{}` argument: {:?}\", name, bits),\n     };\n-    let extra = 128 - size.bits() as u128;\n+    let extra = 128 - u128::from(size.bits());\n     let bits_out = match name {\n-        sym::ctpop => bits.count_ones() as u128,\n-        sym::ctlz => bits.leading_zeros() as u128 - extra,\n-        sym::cttz => (bits << extra).trailing_zeros() as u128 - extra,\n+        sym::ctpop => u128::from(bits.count_ones()),\n+        sym::ctlz => u128::from(bits.leading_zeros()) - extra,\n+        sym::cttz => u128::from((bits << extra).trailing_zeros()) - extra,\n         sym::bswap => (bits << extra).swap_bytes(),\n         sym::bitreverse => (bits << extra).reverse_bits(),\n         _ => bug!(\"not a numeric intrinsic: {}\", name),\n@@ -261,7 +261,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let val_bits = self.force_bits(val, layout.size)?;\n                 let raw_shift = self.read_scalar(args[1])?.not_undef()?;\n                 let raw_shift_bits = self.force_bits(raw_shift, layout.size)?;\n-                let width_bits = layout.size.bits() as u128;\n+                let width_bits = u128::from(layout.size.bits());\n                 let shift_bits = raw_shift_bits % width_bits;\n                 let inv_shift_bits = (width_bits - shift_bits) % width_bits;\n                 let result_bits = if intrinsic_name == sym::rotate_left {\n@@ -350,8 +350,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 );\n \n                 for i in 0..len {\n-                    let place = self.place_field(dest, i)?;\n-                    let value = if i == index { elem } else { self.operand_field(input, i)? };\n+                    let place = self.place_index(dest, i)?;\n+                    let value = if i == index { elem } else { self.operand_index(input, i)? };\n                     self.copy_op(value, place)?;\n                 }\n             }\n@@ -370,7 +370,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     \"Return type `{}` must match vector element type `{}`\",\n                     dest.layout.ty, e_ty\n                 );\n-                self.copy_op(self.operand_field(args[0], index)?, dest)?;\n+                self.copy_op(self.operand_index(args[0], index)?, dest)?;\n             }\n             _ => return Ok(false),\n         }"}, {"sha": "01f9cdea0f0d3a7ff22f6599213bd175a67dd1fb", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,3 +1,5 @@\n+use std::convert::TryFrom;\n+\n use rustc::middle::lang_items::PanicLocationLangItem;\n use rustc::ty::subst::Subst;\n use rustc_span::{Span, Symbol};\n@@ -59,8 +61,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         (\n             Symbol::intern(&caller.file.name.to_string()),\n-            caller.line as u32,\n-            caller.col_display as u32 + 1,\n+            u32::try_from(caller.line).unwrap(),\n+            u32::try_from(caller.col_display).unwrap().checked_add(1).unwrap(),\n         )\n     }\n "}, {"sha": "8437399752e2947c3cd9114062c9f8de5abea813", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -8,6 +8,7 @@\n \n use std::borrow::Cow;\n use std::collections::VecDeque;\n+use std::convert::TryFrom;\n use std::ptr;\n \n use rustc::ty::layout::{Align, HasDataLayout, Size, TargetDataLayout};\n@@ -346,7 +347,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         };\n         Ok(match normalized.to_bits_or_ptr(self.pointer_size(), self) {\n             Ok(bits) => {\n-                let bits = bits as u64; // it's ptr-sized\n+                let bits = u64::try_from(bits).unwrap(); // it's ptr-sized\n                 assert!(size.bytes() == 0);\n                 // Must be non-NULL.\n                 if bits == 0 {\n@@ -473,7 +474,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     /// Gives raw access to the `Allocation`, without bounds or alignment checks.\n-    /// Use the higher-level, `PlaceTy`- and `OpTy`-based APIs in `InterpCtx` instead!\n+    /// Use the higher-level, `PlaceTy`- and `OpTy`-based APIs in `InterpCx` instead!\n     pub fn get_raw(\n         &self,\n         id: AllocId,\n@@ -510,7 +511,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     /// Gives raw mutable access to the `Allocation`, without bounds or alignment checks.\n-    /// Use the higher-level, `PlaceTy`- and `OpTy`-based APIs in `InterpCtx` instead!\n+    /// Use the higher-level, `PlaceTy`- and `OpTy`-based APIs in `InterpCx` instead!\n     pub fn get_raw_mut(\n         &mut self,\n         id: AllocId,\n@@ -667,7 +668,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n             if alloc.undef_mask().is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n                 // this `as usize` is fine, since `i` came from a `usize`\n-                let i = i.bytes() as usize;\n+                let i = i.bytes_usize();\n \n                 // Checked definedness (and thus range) and relocations. This access also doesn't\n                 // influence interpreter execution but is only for debugging.\n@@ -692,8 +693,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             let mut pos = Size::ZERO;\n             let relocation_width = (self.pointer_size().bytes() - 1) * 3;\n             for (i, target_id) in relocations {\n-                // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n-                write!(msg, \"{:1$}\", \"\", ((i - pos) * 3).bytes() as usize).unwrap();\n+                write!(msg, \"{:1$}\", \"\", ((i - pos) * 3).bytes_usize()).unwrap();\n                 let target = format!(\"({})\", target_id);\n                 // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n                 write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", target, relocation_width as usize).unwrap();\n@@ -834,8 +834,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         src: impl IntoIterator<Item = u8>,\n     ) -> InterpResult<'tcx> {\n         let src = src.into_iter();\n-        let size = Size::from_bytes(src.size_hint().0 as u64);\n-        // `write_bytes` checks that this lower bound matches the upper bound matches reality.\n+        let size = Size::from_bytes(src.size_hint().0);\n+        // `write_bytes` checks that this lower bound `size` matches the upper bound and reality.\n         let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access\n@@ -874,14 +874,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         let tcx = self.tcx.tcx;\n \n-        // The bits have to be saved locally before writing to dest in case src and dest overlap.\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-\n         // This checks relocation edges on the src.\n         let src_bytes =\n             self.get_raw(src.alloc_id)?.get_bytes_with_undef_and_ptr(&tcx, src, size)?.as_ptr();\n         let dest_bytes =\n-            self.get_raw_mut(dest.alloc_id)?.get_bytes_mut(&tcx, dest, size * length)?;\n+            self.get_raw_mut(dest.alloc_id)?.get_bytes_mut(&tcx, dest, size * length)?; // `Size` multiplication\n \n         // If `dest_bytes` is empty we just optimize to not run anything for zsts.\n         // See #67539\n@@ -902,7 +899,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // touched if the bytes stay undef for the whole interpreter execution. On contemporary\n             // operating system this can avoid physically allocating the page.\n             let dest_alloc = self.get_raw_mut(dest.alloc_id)?;\n-            dest_alloc.mark_definedness(dest, size * length, false);\n+            dest_alloc.mark_definedness(dest, size * length, false); // `Size` multiplication\n             dest_alloc.mark_relocation_range(relocations);\n             return Ok(());\n         }\n@@ -913,9 +910,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // The pointers above remain valid even if the `HashMap` table is moved around because they\n         // point into the `Vec` storing the bytes.\n         unsafe {\n-            assert_eq!(size.bytes() as usize as u64, size.bytes());\n             if src.alloc_id == dest.alloc_id {\n                 if nonoverlapping {\n+                    // `Size` additions\n                     if (src.offset <= dest.offset && src.offset + size > dest.offset)\n                         || (dest.offset <= src.offset && dest.offset + size > src.offset)\n                     {\n@@ -926,16 +923,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 for i in 0..length {\n                     ptr::copy(\n                         src_bytes,\n-                        dest_bytes.offset((size.bytes() * i) as isize),\n-                        size.bytes() as usize,\n+                        dest_bytes.add((size * i).bytes_usize()), // `Size` multiplication\n+                        size.bytes_usize(),\n                     );\n                 }\n             } else {\n                 for i in 0..length {\n                     ptr::copy_nonoverlapping(\n                         src_bytes,\n-                        dest_bytes.offset((size.bytes() * i) as isize),\n-                        size.bytes() as usize,\n+                        dest_bytes.add((size * i).bytes_usize()), // `Size` multiplication\n+                        size.bytes_usize(),\n                     );\n                 }\n             }\n@@ -975,7 +972,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, u128> {\n         match scalar.to_bits_or_ptr(size, self) {\n             Ok(bits) => Ok(bits),\n-            Err(ptr) => Ok(M::ptr_to_int(&self, ptr)? as u128),\n+            Err(ptr) => Ok(M::ptr_to_int(&self, ptr)?.into()),\n         }\n     }\n }"}, {"sha": "409c958ac39fd67dc645768d7ec311b3e2b90829", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,7 +1,7 @@\n //! Functions concerning immediate values and operands, and reading from operands.\n //! All high-level functions to read from memory work on operands as sources.\n \n-use std::convert::{TryFrom, TryInto};\n+use std::convert::TryFrom;\n \n use super::{InterpCx, MPlaceTy, Machine, MemPlace, Place, PlaceTy};\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n@@ -341,7 +341,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     // Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(&self, mplace: MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n-        let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n+        let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len))?;\n         let str = ::std::str::from_utf8(bytes)\n             .map_err(|err| err_ub_format!(\"this string is not valid UTF-8: {}\", err))?;\n         Ok(str)\n@@ -351,7 +351,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn operand_field(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n-        field: u64,\n+        field: usize,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base = match op.try_as_mplace(self) {\n             Ok(mplace) => {\n@@ -362,7 +362,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Err(value) => value,\n         };\n \n-        let field = field.try_into().unwrap();\n         let field_layout = op.layout.field(self, field)?;\n         if field_layout.is_zst() {\n             let immediate = Scalar::zst().into();\n@@ -384,6 +383,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout })\n     }\n \n+    pub fn operand_index(\n+        &self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+        index: u64,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        if let Ok(index) = usize::try_from(index) {\n+            // We can just treat this as a field.\n+            self.operand_field(op, index)\n+        } else {\n+            // Indexing into a big array. This must be an mplace.\n+            let mplace = op.assert_mem_place(self);\n+            Ok(self.mplace_index(mplace, index)?.into())\n+        }\n+    }\n+\n     pub fn operand_downcast(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n@@ -406,7 +420,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) => self.operand_field(base, field.index() as u64)?,\n+            Field(field, _) => self.operand_field(base, field.index())?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n@@ -556,11 +570,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // where none should happen.\n                 let ptr = Pointer::new(\n                     self.tcx.alloc_map.lock().create_memory_alloc(data),\n-                    Size::from_bytes(start as u64), // offset: `start`\n+                    Size::from_bytes(start), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice(\n                     self.tag_global_base_pointer(ptr).into(),\n-                    (end - start) as u64, // len: `end - start`\n+                    u64::try_from(end.checked_sub(start).unwrap()).unwrap(), // len: `end - start`\n                     self,\n                 ))\n             }\n@@ -581,7 +595,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     .layout\n                     .ty\n                     .discriminant_for_variant(*self.tcx, index)\n-                    .map_or(index.as_u32() as u128, |discr| discr.val);\n+                    .map_or(u128::from(index.as_u32()), |discr| discr.val);\n                 return Ok((discr_val, index));\n             }\n             layout::Variants::Multiple {\n@@ -593,7 +607,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         // read raw discriminant value\n-        let discr_op = self.operand_field(rval, discr_index as u64)?;\n+        let discr_op = self.operand_field(rval, discr_index)?;\n         let discr_val = self.read_immediate(discr_op)?;\n         let raw_discr = discr_val.to_scalar_or_undef();\n         trace!(\"discr value: {:?}\", raw_discr);\n@@ -657,7 +671,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         if !ptr_valid {\n                             throw_ub!(InvalidDiscriminant(raw_discr.erase_tag().into()))\n                         }\n-                        (dataful_variant.as_u32() as u128, dataful_variant)\n+                        (u128::from(dataful_variant.as_u32()), dataful_variant)\n                     }\n                     Ok(raw_discr) => {\n                         // We need to use machine arithmetic to get the relative variant idx:\n@@ -686,7 +700,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                 .expect(\"tagged layout for non adt\")\n                                 .variants\n                                 .len();\n-                            assert!((variant_index as usize) < variants_len);\n+                            assert!(usize::try_from(variant_index).unwrap() < variants_len);\n                             (u128::from(variant_index), VariantIdx::from_u32(variant_index))\n                         } else {\n                             (u128::from(dataful_variant.as_u32()), dataful_variant)"}, {"sha": "cb0aaa4d40d3ee5b790d5d1ad4280d039f07a29b", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,3 +1,5 @@\n+use std::convert::TryFrom;\n+\n use rustc::mir;\n use rustc::mir::interpret::{InterpResult, Scalar};\n use rustc::ty::{\n@@ -130,28 +132,27 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Shift ops can have an RHS with a different numeric type.\n         if bin_op == Shl || bin_op == Shr {\n             let signed = left_layout.abi.is_signed();\n-            let mut oflo = (r as u32 as u128) != r;\n-            let mut r = r as u32;\n-            let size = left_layout.size;\n-            oflo |= r >= size.bits() as u32;\n-            r %= size.bits() as u32;\n+            let size = u128::from(left_layout.size.bits());\n+            let overflow = r >= size;\n+            let r = r % size; // mask to type size\n+            let r = u32::try_from(r).unwrap(); // we masked so this will always fit\n             let result = if signed {\n                 let l = self.sign_extend(l, left_layout) as i128;\n                 let result = match bin_op {\n-                    Shl => l << r,\n-                    Shr => l >> r,\n+                    Shl => l.checked_shl(r).unwrap(),\n+                    Shr => l.checked_shr(r).unwrap(),\n                     _ => bug!(\"it has already been checked that this is a shift op\"),\n                 };\n                 result as u128\n             } else {\n                 match bin_op {\n-                    Shl => l << r,\n-                    Shr => l >> r,\n+                    Shl => l.checked_shl(r).unwrap(),\n+                    Shr => l.checked_shr(r).unwrap(),\n                     _ => bug!(\"it has already been checked that this is a shift op\"),\n                 }\n             };\n             let truncated = self.truncate(result, left_layout);\n-            return Ok((Scalar::from_uint(truncated, size), oflo, left_layout.ty));\n+            return Ok((Scalar::from_uint(truncated, left_layout.size), overflow, left_layout.ty));\n         }\n \n         // For the remaining ops, the types must be the same on both sides\n@@ -193,7 +194,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 _ => None,\n             };\n             if let Some(op) = op {\n-                let l128 = self.sign_extend(l, left_layout) as i128;\n                 let r = self.sign_extend(r, right_layout) as i128;\n                 // We need a special check for overflowing remainder:\n                 // \"int_min % -1\" overflows and returns 0, but after casting things to a larger int\n@@ -206,8 +206,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     _ => {}\n                 }\n+                let l = self.sign_extend(l, left_layout) as i128;\n \n-                let (result, oflo) = op(l128, r);\n+                let (result, oflo) = op(l, r);\n                 // This may be out-of-bounds for the result type, so we have to truncate ourselves.\n                 // If that truncation loses any information, we have an overflow.\n                 let result = result as u128;"}, {"sha": "5cf267c257d84d2b03b29e556c022c69e19ad72d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 67, "deletions": 51, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -385,43 +385,20 @@ where\n         Ok(place)\n     }\n \n-    /// Offset a pointer to project to a field. Unlike `place_field`, this is always\n-    /// possible without allocating, so it can take `&self`. Also return the field's layout.\n+    /// Offset a pointer to project to a field of a struct/union. Unlike `place_field`, this is\n+    /// always possible without allocating, so it can take `&self`. Also return the field's layout.\n     /// This supports both struct and array fields.\n+    ///\n+    /// This also works for arrays, but then the `usize` index type is restricting.\n+    /// For indexing into arrays, use `mplace_index`.\n     #[inline(always)]\n     pub fn mplace_field(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n-        field: u64,\n+        field: usize,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        // Not using the layout method because we want to compute on u64\n-        let offset = match base.layout.fields {\n-            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                offsets[usize::try_from(field).unwrap()]\n-            }\n-            layout::FieldPlacement::Array { stride, .. } => {\n-                let len = base.len(self)?;\n-                if field >= len {\n-                    // This can only be reached in ConstProp and non-rustc-MIR.\n-                    throw_ub!(BoundsCheckFailed { len, index: field });\n-                }\n-                stride * field\n-            }\n-            layout::FieldPlacement::Union(count) => {\n-                assert!(\n-                    field < count as u64,\n-                    \"Tried to access field {} of union {:#?} with {} fields\",\n-                    field,\n-                    base.layout,\n-                    count\n-                );\n-                // Offset is always 0\n-                Size::from_bytes(0)\n-            }\n-        };\n-        // the only way conversion can fail if is this is an array (otherwise we already panicked\n-        // above). In that case, all fields are equal.\n-        let field_layout = base.layout.field(self, usize::try_from(field).unwrap_or(0))?;\n+        let offset = base.layout.fields.offset(field);\n+        let field_layout = base.layout.field(self, field)?;\n \n         // Offset may need adjustment for unsized fields.\n         let (meta, offset) = if field_layout.is_unsized() {\n@@ -451,6 +428,32 @@ where\n         base.offset(offset, meta, field_layout, self)\n     }\n \n+    /// Index into an array.\n+    #[inline(always)]\n+    pub fn mplace_index(\n+        &self,\n+        base: MPlaceTy<'tcx, M::PointerTag>,\n+        index: u64,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        // Not using the layout method because we want to compute on u64\n+        match base.layout.fields {\n+            layout::FieldPlacement::Array { stride, .. } => {\n+                let len = base.len(self)?;\n+                if index >= len {\n+                    // This can only be reached in ConstProp and non-rustc-MIR.\n+                    throw_ub!(BoundsCheckFailed { len, index });\n+                }\n+                let offset = stride * index; // `Size` multiplication\n+                // All fields have the same layout.\n+                let field_layout = base.layout.field(self, 0)?;\n+\n+                assert!(!field_layout.is_unsized());\n+                base.offset(offset, MemPlaceMeta::None, field_layout, self)\n+            }\n+            _ => bug!(\"`mplace_index` called on non-array type {:?}\", base.layout.ty),\n+        }\n+    }\n+\n     // Iterates over all fields of an array. Much more efficient than doing the\n     // same by repeatedly calling `mplace_array`.\n     pub(super) fn mplace_array_fields(\n@@ -465,7 +468,8 @@ where\n         };\n         let layout = base.layout.field(self, 0)?;\n         let dl = &self.tcx.data_layout;\n-        Ok((0..len).map(move |i| base.offset(i * stride, MemPlaceMeta::None, layout, dl)))\n+        // `Size` multiplication\n+        Ok((0..len).map(move |i| base.offset(stride * i, MemPlaceMeta::None, layout, dl)))\n     }\n \n     fn mplace_subslice(\n@@ -477,24 +481,24 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let actual_to = if from_end {\n-            if from + to > len {\n+            if from.checked_add(to).map_or(true, |to| to > len) {\n                 // This can only be reached in ConstProp and non-rustc-MIR.\n-                throw_ub!(BoundsCheckFailed { len: len as u64, index: from as u64 + to as u64 });\n+                throw_ub!(BoundsCheckFailed { len: len, index: from.saturating_add(to) });\n             }\n-            len - to\n+            len.checked_sub(to).unwrap()\n         } else {\n             to\n         };\n \n         // Not using layout method because that works with usize, and does not work with slices\n         // (that have count 0 in their layout).\n         let from_offset = match base.layout.fields {\n-            layout::FieldPlacement::Array { stride, .. } => stride * from,\n+            layout::FieldPlacement::Array { stride, .. } => stride * from, // `Size` multiplication is checked\n             _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n         };\n \n         // Compute meta and new layout\n-        let inner_len = actual_to - from;\n+        let inner_len = actual_to.checked_sub(from).unwrap();\n         let (meta, ty) = match base.layout.ty.kind {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n@@ -527,34 +531,37 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) => self.mplace_field(base, field.index() as u64)?,\n+            Field(field, _) => self.mplace_field(base, field.index())?,\n             Downcast(_, variant) => self.mplace_downcast(base, variant)?,\n             Deref => self.deref_operand(base.into())?,\n \n             Index(local) => {\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n                 let n = self.access_local(self.frame(), local, Some(layout))?;\n                 let n = self.read_scalar(n)?;\n-                let n = self.force_bits(n.not_undef()?, self.tcx.data_layout.pointer_size)?;\n-                self.mplace_field(base, u64::try_from(n).unwrap())?\n+                let n = u64::try_from(\n+                    self.force_bits(n.not_undef()?, self.tcx.data_layout.pointer_size)?,\n+                )\n+                .unwrap();\n+                self.mplace_index(base, n)?\n             }\n \n             ConstantIndex { offset, min_length, from_end } => {\n                 let n = base.len(self)?;\n-                if n < min_length as u64 {\n+                if n < u64::from(min_length) {\n                     // This can only be reached in ConstProp and non-rustc-MIR.\n-                    throw_ub!(BoundsCheckFailed { len: min_length as u64, index: n as u64 });\n+                    throw_ub!(BoundsCheckFailed { len: min_length.into(), index: n.into() });\n                 }\n \n                 let index = if from_end {\n-                    assert!(0 < offset && offset - 1 < min_length);\n-                    n - u64::from(offset)\n+                    assert!(0 < offset && offset <= min_length);\n+                    n.checked_sub(u64::from(offset)).unwrap()\n                 } else {\n                     assert!(offset < min_length);\n                     u64::from(offset)\n                 };\n \n-                self.mplace_field(base, index)?\n+                self.mplace_index(base, index)?\n             }\n \n             Subslice { from, to, from_end } => {\n@@ -570,14 +577,23 @@ where\n     pub fn place_field(\n         &mut self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n-        field: u64,\n+        field: usize,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // FIXME: We could try to be smarter and avoid allocation for fields that span the\n         // entire place.\n         let mplace = self.force_allocation(base)?;\n         Ok(self.mplace_field(mplace, field)?.into())\n     }\n \n+    pub fn place_index(\n+        &mut self,\n+        base: PlaceTy<'tcx, M::PointerTag>,\n+        index: u64,\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+        let mplace = self.force_allocation(base)?;\n+        Ok(self.mplace_index(mplace, index)?.into())\n+    }\n+\n     pub fn place_downcast(\n         &self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n@@ -603,7 +619,7 @@ where\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {\n-            Field(field, _) => self.place_field(base, field.index() as u64)?,\n+            Field(field, _) => self.place_field(base, field.index())?,\n             Downcast(_, variant) => self.place_downcast(base, variant)?,\n             Deref => self.deref_operand(self.place_to_op(base)?)?.into(),\n             // For the other variants, we have to force an allocation.\n@@ -723,7 +739,7 @@ where\n                 ),\n                 Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Raw { size, .. })) => {\n                     assert_eq!(\n-                        Size::from_bytes(size.into()),\n+                        Size::from_bytes(size),\n                         dest.layout.size,\n                         \"Size mismatch when writing bits\"\n                     )\n@@ -1028,7 +1044,7 @@ where\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate_bytes(str.as_bytes(), kind);\n-        let meta = Scalar::from_uint(str.len() as u128, self.pointer_size());\n+        let meta = Scalar::from_uint(u128::try_from(str.len()).unwrap(), self.pointer_size());\n         let mplace = MemPlace {\n             ptr: ptr.into(),\n             align: Align::from_bytes(1).unwrap(),\n@@ -1072,7 +1088,7 @@ where\n                 let size = discr_layout.value.size(self);\n                 let discr_val = truncate(discr_val, size);\n \n-                let discr_dest = self.place_field(dest, discr_index as u64)?;\n+                let discr_dest = self.place_field(dest, discr_index)?;\n                 self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;\n             }\n             layout::Variants::Multiple {\n@@ -1103,7 +1119,7 @@ where\n                         niche_start_val,\n                     )?;\n                     // Write result.\n-                    let niche_dest = self.place_field(dest, discr_index as u64)?;\n+                    let niche_dest = self.place_field(dest, discr_index)?;\n                     self.write_immediate(*discr_val, niche_dest)?;\n                 }\n             }"}, {"sha": "6ec11d42f52d2176933dc8653f2264a0d94172f0", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -192,7 +192,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Ignore zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n-                        let field_dest = self.place_field(dest, field_index as u64)?;\n+                        let field_dest = self.place_field(dest, field_index)?;\n                         self.copy_op(op, field_dest)?;\n                     }\n                 }"}, {"sha": "5ce5ba31a0987ddfaec960a952312be4e6c7b549", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,4 +1,5 @@\n use std::borrow::Cow;\n+use std::convert::TryFrom;\n \n use rustc::ty::layout::{self, LayoutOf, TyLayout};\n use rustc::ty::Instance;\n@@ -29,6 +30,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 trace!(\"SwitchInt({:?})\", *discr);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n+                assert!(targets.len() > 0);\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, &const_int) in values.iter().enumerate() {\n@@ -307,7 +309,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                     .map(|&a| Ok(a))\n                                     .chain(\n                                         (0..untuple_arg.layout.fields.count())\n-                                            .map(|i| self.operand_field(untuple_arg, i as u64)),\n+                                            .map(|i| self.operand_field(untuple_arg, i)),\n                                     )\n                                     .collect::<InterpResult<'_, Vec<OpTy<'tcx, M::PointerTag>>>>(\n                                     )?,\n@@ -330,7 +332,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         if Some(local) == body.spread_arg {\n                             // Must be a tuple\n                             for i in 0..dest.layout.fields.count() {\n-                                let dest = self.place_field(dest, i as u64)?;\n+                                let dest = self.place_field(dest, i)?;\n                                 self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n                             }\n                         } else {\n@@ -392,7 +394,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 // Find and consult vtable\n                 let vtable = receiver_place.vtable();\n-                let drop_fn = self.get_vtable_slot(vtable, idx)?;\n+                let drop_fn = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want"}, {"sha": "1e63766b85d42b065004ad6bef4d531f2e182d58", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,9 +1,11 @@\n-use super::{FnVal, InterpCx, Machine, MemoryKind};\n+use std::convert::TryFrom;\n \n use rustc::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n use rustc::ty::layout::{Align, HasDataLayout, LayoutOf, Size};\n use rustc::ty::{self, Instance, Ty, TypeFoldable};\n \n+use super::{FnVal, InterpCx, Machine, MemoryKind};\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n@@ -54,7 +56,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n         // /////////////////////////////////////////////////////////////////////////////////////////\n         let vtable = self.memory.allocate(\n-            ptr_size * (3 + methods.len() as u64),\n+            ptr_size * u64::try_from(methods.len()).unwrap().checked_add(3).unwrap(),\n             ptr_align,\n             MemoryKind::Vtable,\n         );\n@@ -103,11 +105,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn get_vtable_slot(\n         &self,\n         vtable: Scalar<M::PointerTag>,\n-        idx: usize,\n+        idx: u64,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr_size = self.pointer_size();\n         // Skip over the 'drop_ptr', 'size', and 'align' fields.\n-        let vtable_slot = vtable.ptr_offset(ptr_size * (idx as u64 + 3), self)?;\n+        let vtable_slot = vtable.ptr_offset(ptr_size * idx.checked_add(3).unwrap(), self)?;\n         let vtable_slot = self\n             .memory\n             .check_ptr_access(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n@@ -169,10 +171,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .expect(\"cannot be a ZST\");\n         let alloc = self.memory.get_raw(vtable.alloc_id)?;\n         let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?)?.not_undef()?;\n-        let size = self.force_bits(size, pointer_size)? as u64;\n+        let size = u64::try_from(self.force_bits(size, pointer_size)?).unwrap();\n         let align =\n             alloc.read_ptr_sized(self, vtable.offset(pointer_size * 2, self)?)?.not_undef()?;\n-        let align = self.force_bits(align, pointer_size)? as u64;\n+        let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n \n         if size >= self.tcx.data_layout().obj_size_bound() {\n             throw_ub_format!("}, {"sha": "a355a22748010c951fcb755706e25725beb83dd8", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -4,6 +4,7 @@\n //! That's useful because it means other passes (e.g. promotion) can rely on `const`s\n //! to be const-safe.\n \n+use std::convert::TryFrom;\n use std::fmt::Write;\n use std::ops::RangeInclusive;\n \n@@ -746,7 +747,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n                 // This is the element type size.\n                 let layout = self.ecx.layout_of(tys)?;\n-                // This is the size in bytes of the whole array.\n+                // This is the size in bytes of the whole array. (This checks for overflow.)\n                 let size = layout.size * len;\n                 // Size is not 0, get a pointer.\n                 let ptr = self.ecx.force_ptr(mplace.ptr)?;\n@@ -777,7 +778,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                 // Some byte was undefined, determine which\n                                 // element that byte belongs to so we can\n                                 // provide an index.\n-                                let i = (ptr.offset.bytes() / layout.size.bytes()) as usize;\n+                                let i = usize::try_from(ptr.offset.bytes() / layout.size.bytes())\n+                                    .unwrap();\n                                 self.path.push(PathElem::ArrayElem(i));\n \n                                 throw_validation_failure!(\"undefined bytes\", self.path)"}, {"sha": "e8a7626406413682e307711179cf35bfe8e289e5", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -28,7 +28,8 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     ) -> InterpResult<'tcx, Self>;\n \n     /// Projects to the n-th field.\n-    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: u64) -> InterpResult<'tcx, Self>;\n+    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: usize)\n+    -> InterpResult<'tcx, Self>;\n }\n \n // Operands and memory-places are both values.\n@@ -62,7 +63,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n     }\n \n     #[inline(always)]\n-    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: u64) -> InterpResult<'tcx, Self> {\n+    fn project_field(\n+        self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self> {\n         ecx.operand_field(self, field)\n     }\n }\n@@ -96,7 +101,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx,\n     }\n \n     #[inline(always)]\n-    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: u64) -> InterpResult<'tcx, Self> {\n+    fn project_field(\n+        self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_field(self, field)\n     }\n }\n@@ -206,7 +215,7 @@ macro_rules! make_value_visitor {\n                         // errors: Projecting to a field needs access to `ecx`.\n                         let fields: Vec<InterpResult<'tcx, Self::V>> =\n                             (0..offsets.len()).map(|i| {\n-                                v.project_field(self.ecx(), i as u64)\n+                                v.project_field(self.ecx(), i)\n                             })\n                             .collect();\n                         self.visit_aggregate(v, fields.into_iter())?;"}, {"sha": "76fcbf326fa788803ac06893ca838ad8b97e7377", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1920,8 +1920,8 @@ fn slice_pat_covered_by_const<'tcx>(\n         }\n         (ConstValue::Slice { data, start, end }, ty::Slice(t)) => {\n             assert_eq!(*t, tcx.types.u8);\n-            let ptr = Pointer::new(AllocId(0), Size::from_bytes(start as u64));\n-            data.get_bytes(&tcx, ptr, Size::from_bytes((end - start) as u64)).unwrap()\n+            let ptr = Pointer::new(AllocId(0), Size::from_bytes(start));\n+            data.get_bytes(&tcx, ptr, Size::from_bytes(end - start)).unwrap()\n         }\n         // FIXME(oli-obk): create a way to extract fat pointers from ByRef\n         (_, ty::Slice(_)) => return Ok(false),\n@@ -2375,7 +2375,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                 ty::Slice(t) => {\n                     match value.val {\n                         ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => {\n-                            let offset = Size::from_bytes(start as u64);\n+                            let offset = Size::from_bytes(start);\n                             let n = (end - start) as u64;\n                             (Cow::Borrowed(data), offset, n, t)\n                         }"}, {"sha": "b3d75143c56392bf633d50f7cb2d0d3d44721579", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -150,7 +150,7 @@ pub struct PerfStats {\n     /// Total number of values canonicalized queries constructed.\n     pub queries_canonicalized: AtomicUsize,\n     /// Number of times this query is invoked.\n-    pub normalize_ty_after_erasing_regions: AtomicUsize,\n+    pub normalize_generic_arg_after_erasing_regions: AtomicUsize,\n     /// Number of times this query is invoked.\n     pub normalize_projection_ty: AtomicUsize,\n }\n@@ -707,8 +707,8 @@ impl Session {\n             self.perf_stats.queries_canonicalized.load(Ordering::Relaxed)\n         );\n         println!(\n-            \"normalize_ty_after_erasing_regions:            {}\",\n-            self.perf_stats.normalize_ty_after_erasing_regions.load(Ordering::Relaxed)\n+            \"normalize_generic_arg_after_erasing_regions:   {}\",\n+            self.perf_stats.normalize_generic_arg_after_erasing_regions.load(Ordering::Relaxed)\n         );\n         println!(\n             \"normalize_projection_ty:                       {}\",\n@@ -1080,7 +1080,7 @@ fn build_session_(\n             symbol_hash_time: Lock::new(Duration::from_secs(0)),\n             decode_def_path_tables_time: Lock::new(Duration::from_secs(0)),\n             queries_canonicalized: AtomicUsize::new(0),\n-            normalize_ty_after_erasing_regions: AtomicUsize::new(0),\n+            normalize_generic_arg_after_erasing_regions: AtomicUsize::new(0),\n             normalize_projection_ty: AtomicUsize::new(0),\n         },\n         code_stats: Default::default(),"}, {"sha": "74d9817d2779bd709008ae25fef4f13c53842833", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -3,6 +3,7 @@ pub use Primitive::*;\n \n use crate::spec::Target;\n \n+use std::convert::{TryFrom, TryInto};\n use std::ops::{Add, AddAssign, Deref, Mul, Range, RangeInclusive, Sub};\n \n use rustc_index::vec::{Idx, IndexVec};\n@@ -240,31 +241,42 @@ pub struct Size {\n }\n \n impl Size {\n-    pub const ZERO: Size = Self::from_bytes(0);\n+    pub const ZERO: Size = Size { raw: 0 };\n \n     #[inline]\n-    pub fn from_bits(bits: u64) -> Size {\n+    pub fn from_bits(bits: impl TryInto<u64>) -> Size {\n+        let bits = bits.try_into().ok().unwrap();\n         // Avoid potential overflow from `bits + 7`.\n         Size::from_bytes(bits / 8 + ((bits % 8) + 7) / 8)\n     }\n \n     #[inline]\n-    pub const fn from_bytes(bytes: u64) -> Size {\n-        Size { raw: bytes }\n+    pub fn from_bytes(bytes: impl TryInto<u64>) -> Size {\n+        Size { raw: bytes.try_into().ok().unwrap() }\n     }\n \n     #[inline]\n     pub fn bytes(self) -> u64 {\n         self.raw\n     }\n \n+    #[inline]\n+    pub fn bytes_usize(self) -> usize {\n+        self.bytes().try_into().unwrap()\n+    }\n+\n     #[inline]\n     pub fn bits(self) -> u64 {\n         self.bytes().checked_mul(8).unwrap_or_else(|| {\n             panic!(\"Size::bits: {} bytes in bits doesn't fit in u64\", self.bytes())\n         })\n     }\n \n+    #[inline]\n+    pub fn bits_usize(self) -> usize {\n+        self.bits().try_into().unwrap()\n+    }\n+\n     #[inline]\n     pub fn align_to(self, align: Align) -> Size {\n         let mask = align.bytes() - 1;\n@@ -665,7 +677,7 @@ impl FieldPlacement {\n                 Size::ZERO\n             }\n             FieldPlacement::Array { stride, count } => {\n-                let i = i as u64;\n+                let i = u64::try_from(i).unwrap();\n                 assert!(i < count);\n                 stride * i\n             }"}, {"sha": "badd94a5ed9341e86f82e440bd83ecc4a71db10d", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -387,6 +387,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     }\n \n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        let constant = constant.super_fold_with(self);\n         constant.eval(self.selcx.tcx(), self.param_env)\n     }\n }"}, {"sha": "77128bc8c8ab4fcac138a8c2b20b3d8a567f3e77", "filename": "src/librustc_trait_selection/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -191,6 +191,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n     }\n \n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        let constant = constant.super_fold_with(self);\n         constant.eval(self.infcx.tcx, self.param_env)\n     }\n }"}, {"sha": "065cf38eb249075a3c9ac3b2407c6dbcc5d5aaa0", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,23 +1,24 @@\n use rustc::traits::query::NoSolution;\n use rustc::ty::query::Providers;\n-use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use rustc::ty::subst::GenericArg;\n+use rustc::ty::{self, ParamEnvAnd, TyCtxt};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use rustc_trait_selection::traits::{Normalized, ObligationCause};\n use std::sync::atomic::Ordering;\n \n crate fn provide(p: &mut Providers<'_>) {\n-    *p = Providers { normalize_ty_after_erasing_regions, ..*p };\n+    *p = Providers { normalize_generic_arg_after_erasing_regions, ..*p };\n }\n \n-fn normalize_ty_after_erasing_regions<'tcx>(\n+fn normalize_generic_arg_after_erasing_regions<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    goal: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-) -> Ty<'tcx> {\n-    debug!(\"normalize_ty_after_erasing_regions(goal={:#?})\", goal);\n+    goal: ParamEnvAnd<'tcx, GenericArg<'tcx>>,\n+) -> GenericArg<'tcx> {\n+    debug!(\"normalize_generic_arg_after_erasing_regions(goal={:#?})\", goal);\n \n     let ParamEnvAnd { param_env, value } = goal;\n-    tcx.sess.perf_stats.normalize_ty_after_erasing_regions.fetch_add(1, Ordering::Relaxed);\n+    tcx.sess.perf_stats.normalize_generic_arg_after_erasing_regions.fetch_add(1, Ordering::Relaxed);\n     tcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::dummy();\n         match infcx.at(&cause, param_env).normalize(&value) {"}, {"sha": "fcb7b4c4fe69d5721f5af5ceb707c43a9ba9ed20", "filename": "src/test/mir-opt/inline/inline-into-box-place.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,6 +1,7 @@\n // ignore-tidy-linelength\n // ignore-wasm32-bare compiled with panic=abort by default\n // compile-flags: -Z mir-opt-level=3\n+// only-64bit FIXME: the mir representation of RawVec depends on ptr size\n #![feature(box_syntax)]\n \n fn main() {\n@@ -55,7 +56,7 @@ fn main() {\n //   StorageLive(_2);\n //   _2 = Box(std::vec::Vec<u32>);\n //   _4 = &mut (*_2);\n-//   ((*_4).0: alloc::raw_vec::RawVec<u32>) = const alloc::raw_vec::RawVec::<u32>::NEW;\n+//   ((*_4).0: alloc::raw_vec::RawVec<u32>) = const ByRef { alloc: Allocation { bytes: [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [65535], len: Size { raw: 16 } }, size: Size { raw: 16 }, align: Align { pow2: 3 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }: alloc::raw_vec::RawVec::<u32>;\n //   ((*_4).1: usize) = const 0usize;\n //   _1 = move _2;\n //   StorageDead(_2);"}, {"sha": "9fb1bbebc96100847ee3e47bcf85f6c4c376743e", "filename": "src/test/ui/associated-const/defaults-cyclic-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Ftest%2Fui%2Fassociated-const%2Fdefaults-cyclic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Ftest%2Fui%2Fassociated-const%2Fdefaults-cyclic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fdefaults-cyclic-fail.rs?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,9 +1,9 @@\n // build-fail\n+//~^ ERROR cycle detected when normalizing `<() as Tr>::A`\n \n // Cyclic assoc. const defaults don't error unless *used*\n trait Tr {\n     const A: u8 = Self::B;\n-    //~^ ERROR cycle detected when const-evaluating + checking `Tr::A`\n \n     const B: u8 = Self::A;\n }"}, {"sha": "6b2fbe5be4e30f69b867b6377841e201f934bc09", "filename": "src/test/ui/associated-const/defaults-cyclic-fail.stderr", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Ftest%2Fui%2Fassociated-const%2Fdefaults-cyclic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Ftest%2Fui%2Fassociated-const%2Fdefaults-cyclic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fdefaults-cyclic-fail.stderr?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -1,30 +1,42 @@\n-error[E0391]: cycle detected when const-evaluating + checking `Tr::A`\n-  --> $DIR/defaults-cyclic-fail.rs:5:5\n+error[E0391]: cycle detected when normalizing `<() as Tr>::A`\n+   |\n+note: ...which requires const-evaluating + checking `Tr::A`...\n+  --> $DIR/defaults-cyclic-fail.rs:6:5\n    |\n LL |     const A: u8 = Self::B;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating + checking `Tr::A`...\n+  --> $DIR/defaults-cyclic-fail.rs:6:5\n    |\n+LL |     const A: u8 = Self::B;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating `Tr::A`...\n-  --> $DIR/defaults-cyclic-fail.rs:5:19\n+  --> $DIR/defaults-cyclic-fail.rs:6:5\n    |\n LL |     const A: u8 = Self::B;\n-   |                   ^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires normalizing `<() as Tr>::B`...\n+note: ...which requires const-evaluating + checking `Tr::B`...\n+  --> $DIR/defaults-cyclic-fail.rs:8:5\n+   |\n+LL |     const B: u8 = Self::A;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `Tr::B`...\n   --> $DIR/defaults-cyclic-fail.rs:8:5\n    |\n LL |     const B: u8 = Self::A;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating `Tr::B`...\n-  --> $DIR/defaults-cyclic-fail.rs:8:19\n+  --> $DIR/defaults-cyclic-fail.rs:8:5\n    |\n LL |     const B: u8 = Self::A;\n-   |                   ^^^^^^^\n-   = note: ...which again requires const-evaluating + checking `Tr::A`, completing the cycle\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires normalizing `<() as Tr>::A`, completing the cycle\n note: cycle used when const-evaluating `main`\n-  --> $DIR/defaults-cyclic-fail.rs:16:16\n+  --> $DIR/defaults-cyclic-fail.rs:14:1\n    |\n-LL |     assert_eq!(<() as Tr>::A, 0);\n-   |                ^^^^^^^^^^^^^\n+LL | fn main() {\n+   | ^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "aac3622c6de408f16603ccb1290392be09f39299", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -25,7 +25,7 @@ note: ...which requires const-evaluating + checking `std::intrinsics::size_of`..\n LL |     pub fn size_of<T>() -> usize;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires computing layout of `Foo`...\n-   = note: ...which requires normalizing `ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: All, def_id: None }, value: [u8; _] }`...\n+   = note: ...which requires normalizing `[u8; _]`...\n    = note: ...which again requires const-evaluating + checking `Foo::bytes::{{constant}}#0`, completing the cycle\n note: cycle used when processing `Foo`\n   --> $DIR/const-size_of-cycle.rs:7:1"}, {"sha": "1bcd7fd735de8132d45738886492876928cebe53", "filename": "src/test/ui/tool_lints.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Ftest%2Fui%2Ftool_lints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Ftest%2Fui%2Ftool_lints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool_lints.stderr?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -18,3 +18,4 @@ LL | #[warn(foo::bar)]\n \n error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0710`."}, {"sha": "414816d229cdb5a0f051a44904bc27c49981d10b", "filename": "src/test/ui/unknown-lint-tool-name.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Ftest%2Fui%2Funknown-lint-tool-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279/src%2Ftest%2Fui%2Funknown-lint-tool-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funknown-lint-tool-name.stderr?ref=a5fb9ae5b2ed3cb011ada9dc1e8633aa0927f279", "patch": "@@ -36,3 +36,4 @@ LL | #[allow(foo::bar)]\n \n error: aborting due to 6 previous errors\n \n+For more information about this error, try `rustc --explain E0710`."}]}