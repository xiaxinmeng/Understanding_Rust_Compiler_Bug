{"sha": "4f4160ee3bd4ca0779821c24240af525d07d859a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNDE2MGVlM2JkNGNhMDc3OTgyMWMyNDI0MGFmNTI1ZDA3ZDg1OWE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-01T14:29:54Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-02T03:44:30Z"}, "message": "Factor out auto_serialize2's impls from each other.", "tree": {"sha": "6a8d54e47810de9785a2bd969ffe9b2ca64c2464", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a8d54e47810de9785a2bd969ffe9b2ca64c2464"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f4160ee3bd4ca0779821c24240af525d07d859a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4160ee3bd4ca0779821c24240af525d07d859a", "html_url": "https://github.com/rust-lang/rust/commit/4f4160ee3bd4ca0779821c24240af525d07d859a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f4160ee3bd4ca0779821c24240af525d07d859a/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c46b6f9efbbb00706a62d86a9afc4fd59bc13c12", "url": "https://api.github.com/repos/rust-lang/rust/commits/c46b6f9efbbb00706a62d86a9afc4fd59bc13c12", "html_url": "https://github.com/rust-lang/rust/commit/c46b6f9efbbb00706a62d86a9afc4fd59bc13c12"}], "stats": {"total": 181, "additions": 114, "deletions": 67}, "files": [{"sha": "426873ce3476902a44f2953a129a4f143e97ba89", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "modified", "additions": 114, "deletions": 67, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/4f4160ee3bd4ca0779821c24240af525d07d859a/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4160ee3bd4ca0779821c24240af525d07d859a/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=4f4160ee3bd4ca0779821c24240af525d07d859a", "patch": "@@ -99,22 +99,61 @@ fn expand(cx: ext_ctxt,\n     do vec::flat_map(in_items) |item| {\n         match item.node {\n             ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n-                vec::append(\n-                    ~[filter_attrs(*item)],\n-                    mk_rec_impl(cx, item.span, item.ident, fields, tps)\n-                )\n+                let ser_impl = mk_rec_ser_impl(\n+                    cx,\n+                    item.span,\n+                    item.ident,\n+                    fields,\n+                    tps\n+                );\n+\n+                let deser_impl = mk_rec_deser_impl(\n+                    cx,\n+                    item.span,\n+                    item.ident,\n+                    fields,\n+                    tps\n+                );\n+\n+                ~[filter_attrs(*item), ser_impl, deser_impl]\n             },\n             ast::item_class(@{ fields, _}, tps) => {\n-                vec::append(\n-                    ~[filter_attrs(*item)],\n-                    mk_struct_impl(cx, item.span, item.ident, fields, tps)\n-                )\n+                let ser_impl = mk_struct_ser_impl(\n+                    cx,\n+                    item.span,\n+                    item.ident,\n+                    fields,\n+                    tps\n+                );\n+\n+                let deser_impl = mk_struct_deser_impl(\n+                    cx,\n+                    item.span,\n+                    item.ident,\n+                    fields,\n+                    tps\n+                );\n+\n+                ~[filter_attrs(*item), ser_impl, deser_impl]\n             },\n             ast::item_enum(enum_def, tps) => {\n-                vec::append(\n-                    ~[filter_attrs(*item)],\n-                    mk_enum_impl(cx, item.span, item.ident, enum_def, tps)\n-                )\n+                let ser_impl = mk_enum_ser_impl(\n+                    cx,\n+                    item.span,\n+                    item.ident,\n+                    enum_def,\n+                    tps\n+                );\n+\n+                let deser_impl = mk_enum_deser_impl(\n+                    cx,\n+                    item.span,\n+                    item.ident,\n+                    enum_def,\n+                    tps\n+                );\n+\n+                ~[filter_attrs(*item), ser_impl, deser_impl]\n             },\n             _ => {\n                 cx.span_err(span, ~\"#[auto_serialize2] can only be applied \\\n@@ -396,30 +435,40 @@ fn mk_deser_method(\n     }\n }\n \n-fn mk_rec_impl(\n+fn mk_rec_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     fields: ~[ast::ty_field],\n     tps: ~[ast::ty_param]\n-) -> ~[@ast::item] {\n-    let fields = mk_rec_fields(fields);\n-    let ser_fields = mk_ser_fields(cx, span, fields);\n-    let deser_fields = mk_deser_fields(cx, span, fields);\n+) -> @ast::item {\n+    let fields = mk_ser_fields(cx, span, mk_rec_fields(fields));\n \n-    // ast for `__s.emit_rec(|| $(ser_fields))`\n-    let ser_body = cx.expr_call(\n+    // ast for `__s.emit_rec(|| $(fields))`\n+    let body = cx.expr_call(\n         span,\n         cx.expr_field(\n             span,\n             cx.expr_var(span, ~\"__s\"),\n             cx.ident_of(~\"emit_rec\")\n         ),\n-        ~[cx.lambda_stmts(span, ser_fields)]\n+        ~[cx.lambda_stmts(span, fields)]\n     );\n \n-    // ast for `read_rec(|| $(deser_fields))`\n-    let deser_body = cx.expr_call(\n+    mk_ser_impl(cx, span, ident, tps, body)\n+}\n+\n+fn mk_rec_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[ast::ty_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_deser_fields(cx, span, mk_rec_fields(fields));\n+\n+    // ast for `read_rec(|| $(fields))`\n+    let body = cx.expr_call(\n         span,\n         cx.expr_field(\n             span,\n@@ -430,30 +479,25 @@ fn mk_rec_impl(\n             cx.lambda_expr(\n                 cx.expr(\n                     span,\n-                    ast::expr_rec(deser_fields, None)\n+                    ast::expr_rec(fields, None)\n                 )\n             )\n         ]\n     );\n \n-    ~[\n-        mk_ser_impl(cx, span, ident, tps, ser_body),\n-        mk_deser_impl(cx, span, ident, tps, deser_body),\n-    ]\n+    mk_deser_impl(cx, span, ident, tps, body)\n }\n \n-fn mk_struct_impl(\n+fn mk_struct_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     fields: ~[@ast::struct_field],\n     tps: ~[ast::ty_param]\n-) -> ~[@ast::item] {\n-    let fields = mk_struct_fields(fields);\n-    let ser_fields = mk_ser_fields(cx, span, fields);\n-    let deser_fields = mk_deser_fields(cx, span, fields);\n+) -> @ast::item {\n+    let fields = mk_ser_fields(cx, span, mk_struct_fields(fields));\n \n-    // ast for `__s.emit_struct($(name), || $(ser_fields))`\n+    // ast for `__s.emit_struct($(name), || $(fields))`\n     let ser_body = cx.expr_call(\n         span,\n         cx.expr_field(\n@@ -463,12 +507,24 @@ fn mk_struct_impl(\n         ),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n-            cx.lambda_stmts(span, ser_fields),\n+            cx.lambda_stmts(span, fields),\n         ]\n     );\n \n-    // ast for `read_struct($(name), || $(deser_fields))`\n-    let deser_body = cx.expr_call(\n+    mk_ser_impl(cx, span, ident, tps, ser_body)\n+}\n+\n+fn mk_struct_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[@ast::struct_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_deser_fields(cx, span, mk_struct_fields(fields));\n+\n+    // ast for `read_struct($(name), || $(fields))`\n+    let body = cx.expr_call(\n         span,\n         cx.expr_field(\n             span,\n@@ -478,23 +534,19 @@ fn mk_struct_impl(\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n             cx.lambda_expr(\n-                span,\n                 cx.expr(\n                     span,\n                     ast::expr_struct(\n                         cx.path(span, ~[ident]),\n-                        deser_fields\n+                        fields,\n                         None\n                     )\n                 )\n             ),\n         ]\n-    )\n+    );\n \n-    ~[\n-        mk_ser_impl(cx, span, ident, tps, ser_body),\n-        mk_deser_impl(cx, span, ident, tps, deser_body),\n-    ]\n+    mk_deser_impl(cx, span, ident, tps, body)\n }\n \n // Records and structs don't have the same fields types, but they share enough\n@@ -576,10 +628,9 @@ fn mk_ser_fields(\n fn mk_deser_fields(\n     cx: ext_ctxt,\n     span: span,\n-    fields: ~[{ span: span, ident: ast::ident, mutbl: ast::mutability }],\n-    f: fn(~[ast::field]) -> @ast::expr\n-) -> @ast::expr {\n-    let fields = do fields.mapi |idx, field| {\n+    fields: ~[{ span: span, ident: ast::ident, mutbl: ast::mutability }]\n+) -> ~[ast::field] {\n+    do fields.mapi |idx, field| {\n         // ast for `|| std::serialization2::deserialize(__d)`\n         let expr_lambda = cx.lambda(\n             cx.expr_blk(\n@@ -614,45 +665,41 @@ fn mk_deser_fields(\n             node: { mutbl: field.mutbl, ident: field.ident, expr: expr },\n             span: span,\n         }\n-    };\n-\n-    // ast for `__d.read_rec(|| $(fields_expr))`\n-    cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_rec\")\n-        ),\n-        ~[cx.lambda_expr(f(fields))]\n-    )\n+    }\n }\n \n-fn mk_enum_impl(\n+fn mk_enum_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     enum_def: ast::enum_def,\n     tps: ~[ast::ty_param]\n-) -> ~[@ast::item] {\n-    let ser_body = mk_enum_ser_body(\n+) -> @ast::item {\n+    let body = mk_enum_ser_body(\n         cx,\n         span,\n         ident,\n         enum_def.variants\n     );\n \n-    let deser_body = mk_enum_deser_body(\n+    mk_ser_impl(cx, span, ident, tps, body)\n+}\n+\n+fn mk_enum_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    enum_def: ast::enum_def,\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let body = mk_enum_deser_body(\n         cx,\n         span,\n         ident,\n         enum_def.variants\n     );\n \n-    ~[\n-        mk_ser_impl(cx, span, ident, tps, ser_body),\n-        mk_deser_impl(cx, span, ident, tps, deser_body),\n-    ]\n+    mk_deser_impl(cx, span, ident, tps, body)\n }\n \n fn ser_variant("}]}