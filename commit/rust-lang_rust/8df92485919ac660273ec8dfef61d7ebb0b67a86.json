{"sha": "8df92485919ac660273ec8dfef61d7ebb0b67a86", "node_id": "C_kwDOAAsO6NoAKDhkZjkyNDg1OTE5YWM2NjAyNzNlYzhkZmVmNjFkN2ViYjBiNjdhODY", "commit": {"author": {"name": "pierwill", "email": "pierwill@users.noreply.github.com", "date": "2021-10-30T15:11:50Z"}, "committer": {"name": "pierwill", "email": "pierwill@users.noreply.github.com", "date": "2021-12-22T16:50:57Z"}, "message": "Remove `PartialOrd` and `Ord` from `LocalDefId`\n\nImplement `Ord`, `PartialOrd` for SpanData", "tree": {"sha": "16e5160a3d450ffa9d16eff61383ebc96f7d2dbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16e5160a3d450ffa9d16eff61383ebc96f7d2dbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8df92485919ac660273ec8dfef61d7ebb0b67a86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8df92485919ac660273ec8dfef61d7ebb0b67a86", "html_url": "https://github.com/rust-lang/rust/commit/8df92485919ac660273ec8dfef61d7ebb0b67a86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8df92485919ac660273ec8dfef61d7ebb0b67a86/comments", "author": {"login": "pierwill", "id": 19642016, "node_id": "MDQ6VXNlcjE5NjQyMDE2", "avatar_url": "https://avatars.githubusercontent.com/u/19642016?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pierwill", "html_url": "https://github.com/pierwill", "followers_url": "https://api.github.com/users/pierwill/followers", "following_url": "https://api.github.com/users/pierwill/following{/other_user}", "gists_url": "https://api.github.com/users/pierwill/gists{/gist_id}", "starred_url": "https://api.github.com/users/pierwill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pierwill/subscriptions", "organizations_url": "https://api.github.com/users/pierwill/orgs", "repos_url": "https://api.github.com/users/pierwill/repos", "events_url": "https://api.github.com/users/pierwill/events{/privacy}", "received_events_url": "https://api.github.com/users/pierwill/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pierwill", "id": 19642016, "node_id": "MDQ6VXNlcjE5NjQyMDE2", "avatar_url": "https://avatars.githubusercontent.com/u/19642016?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pierwill", "html_url": "https://github.com/pierwill", "followers_url": "https://api.github.com/users/pierwill/followers", "following_url": "https://api.github.com/users/pierwill/following{/other_user}", "gists_url": "https://api.github.com/users/pierwill/gists{/gist_id}", "starred_url": "https://api.github.com/users/pierwill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pierwill/subscriptions", "organizations_url": "https://api.github.com/users/pierwill/orgs", "repos_url": "https://api.github.com/users/pierwill/repos", "events_url": "https://api.github.com/users/pierwill/events{/privacy}", "received_events_url": "https://api.github.com/users/pierwill/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e100ec5bc7cd768ec17d75448b29c9ab4a39272b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e100ec5bc7cd768ec17d75448b29c9ab4a39272b", "html_url": "https://github.com/rust-lang/rust/commit/e100ec5bc7cd768ec17d75448b29c9ab4a39272b"}], "stats": {"total": 96, "additions": 72, "deletions": 24}, "files": [{"sha": "826d0fe9ab40e690df56c80dec894af0272f4414", "filename": "compiler/rustc_data_structures/src/graph/vec_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs?ref=8df92485919ac660273ec8dfef61d7ebb0b67a86", "patch": "@@ -20,7 +20,7 @@ pub struct VecGraph<N: Idx> {\n impl<N: Idx> VecGraph<N> {\n     pub fn new(num_nodes: usize, mut edge_pairs: Vec<(N, N)>) -> Self {\n         // Sort the edges by the source -- this is important.\n-        edge_pairs.sort();\n+        edge_pairs.sort_by_key(|&edge_pairs| (edge_pairs.0.index(), edge_pairs.1.index()));\n \n         let num_edges = edge_pairs.len();\n "}, {"sha": "d813c887eee9a9a91e3617cf2176141eff249cc0", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=8df92485919ac660273ec8dfef61d7ebb0b67a86", "patch": "@@ -101,7 +101,11 @@ impl DefPathTable {\n pub struct Definitions {\n     table: DefPathTable,\n \n-    // FIXME(eddyb) ideally all `LocalDefId`s would be HIR owners.\n+    /// Only [`LocalDefId`]s for items and item-like are HIR owners.\n+    /// The associated `HirId` has a `local_id` of `0`.\n+    /// Generic parameters and closures are also assigned a `LocalDefId` but are not HIR owners.\n+    /// Their `HirId`s are defined by their position while lowering the enclosing owner.\n+    // FIXME(cjgillot) Some `LocalDefId`s from `use` items are dropped during lowering and lack a `HirId`.\n     pub(super) def_id_to_hir_id: IndexVec<LocalDefId, Option<hir::HirId>>,\n     /// The reverse mapping of `def_id_to_hir_id`.\n     pub(super) hir_id_to_def_id: FxHashMap<hir::HirId, LocalDefId>,"}, {"sha": "69572807e7c9d6cf87853dfa842bbe52849dec64", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=8df92485919ac660273ec8dfef61d7ebb0b67a86", "patch": "@@ -1203,7 +1203,7 @@ pub enum UnsafeSource {\n     UserProvided,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n pub struct BodyId {\n     pub hir_id: HirId,\n }\n@@ -1980,7 +1980,7 @@ pub struct FnSig<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the hir-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug)]\n pub struct TraitItemId {\n     pub def_id: LocalDefId,\n }\n@@ -2043,7 +2043,7 @@ pub enum TraitItemKind<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the hir-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug)]\n pub struct ImplItemId {\n     pub def_id: LocalDefId,\n }\n@@ -2644,7 +2644,7 @@ impl<'hir> VariantData<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the hir-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, Hash)]\n pub struct ItemId {\n     pub def_id: LocalDefId,\n }\n@@ -2883,7 +2883,7 @@ pub enum AssocItemKind {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the hir-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug)]\n pub struct ForeignItemId {\n     pub def_id: LocalDefId,\n }"}, {"sha": "1482a96cae3165b289c2a4a31ea8fde86ed1f8c6", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=8df92485919ac660273ec8dfef61d7ebb0b67a86", "patch": "@@ -11,7 +11,7 @@ use std::fmt;\n /// the `local_id` part of the `HirId` changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n #[derive(Encodable, Decodable)]\n pub struct HirId {\n     pub owner: LocalDefId,\n@@ -32,6 +32,10 @@ impl HirId {\n     pub fn make_owner(owner: LocalDefId) -> Self {\n         Self { owner, local_id: ItemLocalId::from_u32(0) }\n     }\n+\n+    pub fn index(self) -> (usize, usize) {\n+        (rustc_index::vec::Idx::index(self.owner), rustc_index::vec::Idx::index(self.local_id))\n+    }\n }\n \n impl fmt::Display for HirId {\n@@ -40,6 +44,18 @@ impl fmt::Display for HirId {\n     }\n }\n \n+impl Ord for HirId {\n+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+        (self.index()).cmp(&(other.index()))\n+    }\n+}\n+\n+impl PartialOrd for HirId {\n+    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n+        Some(self.cmp(&other))\n+    }\n+}\n+\n rustc_data_structures::define_id_collections!(HirIdMap, HirIdSet, HirId);\n rustc_data_structures::define_id_collections!(ItemLocalMap, ItemLocalSet, ItemLocalId);\n "}, {"sha": "e2f2324f4a8fb7f307d20f7b9ee2ace0fd88fc4a", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=8df92485919ac660273ec8dfef61d7ebb0b67a86", "patch": "@@ -675,7 +675,7 @@ impl<T: Idx> SparseBitSet<T> {\n \n     fn insert(&mut self, elem: T) -> bool {\n         assert!(elem.index() < self.domain_size);\n-        let changed = if let Some(i) = self.elems.iter().position(|&e| e >= elem) {\n+        let changed = if let Some(i) = self.elems.iter().position(|&e| e.index() >= elem.index()) {\n             if self.elems[i] == elem {\n                 // `elem` is already in the set.\n                 false"}, {"sha": "e3c6528b21885672f9baef1206070a04450a43d8", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=8df92485919ac660273ec8dfef61d7ebb0b67a86", "patch": "@@ -12,7 +12,7 @@ use std::vec;\n /// Represents some newtyped `usize` wrapper.\n ///\n /// Purpose: avoid mixing indexes for different bitvector domains.\n-pub trait Idx: Copy + 'static + Ord + Debug + Hash {\n+pub trait Idx: Copy + 'static + Eq + PartialEq + Debug + Hash {\n     fn new(idx: usize) -> Self;\n \n     fn index(self) -> usize;"}, {"sha": "eeb907d01148b7454f38027997f8b71228dadf27", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=8df92485919ac660273ec8dfef61d7ebb0b67a86", "patch": "@@ -1306,7 +1306,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             })\n             .collect::<Vec<_>>();\n         // Sort everything to ensure a stable order for diagnotics.\n-        keys_and_jobs.sort_by_key(|&(def_id, _, _)| def_id);\n+        keys_and_jobs.sort_by_key(|&(def_id, _, _)| def_id.index());\n         for (def_id, encode_const, encode_opt) in keys_and_jobs.into_iter() {\n             debug_assert!(encode_const || encode_opt);\n "}, {"sha": "1422537cd50609dfe37719ecd0d2c11ca0440b7e", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=8df92485919ac660273ec8dfef61d7ebb0b67a86", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc_hir::{HirId, ItemId};\n+use rustc_hir::ItemId;\n use rustc_query_system::ich::{NodeIdHashingMode, StableHashingContext};\n use rustc_session::config::OptLevel;\n use rustc_span::source_map::Span;\n@@ -355,7 +355,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n         #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-        pub struct ItemSortKey<'tcx>(Option<HirId>, SymbolName<'tcx>);\n+        pub struct ItemSortKey<'tcx>(Option<usize>, SymbolName<'tcx>);\n \n         fn item_sort_key<'tcx>(tcx: TyCtxt<'tcx>, item: MonoItem<'tcx>) -> ItemSortKey<'tcx> {\n             ItemSortKey(\n@@ -366,10 +366,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             // instances into account. The others don't matter for\n                             // the codegen tests and can even make item order\n                             // unstable.\n-                            InstanceDef::Item(def) => def\n-                                .did\n-                                .as_local()\n-                                .map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id)),\n+                            InstanceDef::Item(def) => Some(def.did.index.as_usize()),\n                             InstanceDef::VtableShim(..)\n                             | InstanceDef::ReifyShim(..)\n                             | InstanceDef::Intrinsic(..)\n@@ -380,10 +377,10 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             | InstanceDef::CloneShim(..) => None,\n                         }\n                     }\n-                    MonoItem::Static(def_id) => {\n-                        def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n+                    MonoItem::Static(def_id) => Some(def_id.index.as_usize()),\n+                    MonoItem::GlobalAsm(item_id) => {\n+                        Some(item_id.def_id.to_def_id().index.as_usize())\n                     }\n-                    MonoItem::GlobalAsm(item_id) => Some(item_id.hir_id()),\n                 },\n                 item.symbol_name(tcx),\n             )"}, {"sha": "04011552e31edc61cc5bb17852dd76f26787d722", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=8df92485919ac660273ec8dfef61d7ebb0b67a86", "patch": "@@ -20,7 +20,7 @@ pub type SimplifiedType = SimplifiedTypeGen<DefId>;\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, TyEncodable, TyDecodable)]\n pub enum SimplifiedTypeGen<D>\n where\n-    D: Copy + Debug + Ord + Eq,\n+    D: Copy + Debug + Eq,\n {\n     BoolSimplifiedType,\n     CharSimplifiedType,"}, {"sha": "e1f30fef44f99ebecfda746406e1f2b10af6d570", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=8df92485919ac660273ec8dfef61d7ebb0b67a86", "patch": "@@ -212,7 +212,8 @@ impl<'tcx> Inliner<'tcx> {\n             // a lower `HirId` than the callee. This ensures that the callee will\n             // not inline us. This trick only works without incremental compilation.\n             // So don't do it if that is enabled.\n-            if !self.tcx.dep_graph.is_fully_enabled() && self.hir_id < callee_hir_id {\n+            if !self.tcx.dep_graph.is_fully_enabled() && self.hir_id.index() < callee_hir_id.index()\n+            {\n                 return Ok(());\n             }\n "}, {"sha": "d15befbf28730f17a7da2e09bf5367f15d3ff728", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=8df92485919ac660273ec8dfef61d7ebb0b67a86", "patch": "@@ -322,7 +322,7 @@ rustc_data_structures::define_id_collections!(DefIdMap, DefIdSet, DefId);\n /// few cases where we know that only DefIds from the local crate are expected\n /// and a DefId from a different crate would signify a bug somewhere. This\n /// is when LocalDefId comes in handy.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct LocalDefId {\n     pub local_def_index: DefIndex,\n }"}, {"sha": "3bbf2a0e45666f8339d9889e466899fac892a67c", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df92485919ac660273ec8dfef61d7ebb0b67a86/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=8df92485919ac660273ec8dfef61d7ebb0b67a86", "patch": "@@ -424,7 +424,7 @@ impl FileName {\n /// `SpanData` is public because `Span` uses a thread-local interner and can't be\n /// sent to other threads, but some pieces of performance infra run in a separate thread.\n /// Using `Span` is generally preferred.\n-#[derive(Clone, Copy, Hash, PartialEq, Eq, Ord, PartialOrd)]\n+#[derive(Clone, Copy, Hash, PartialEq, Eq)]\n pub struct SpanData {\n     pub lo: BytePos,\n     pub hi: BytePos,\n@@ -434,6 +434,36 @@ pub struct SpanData {\n     pub parent: Option<LocalDefId>,\n }\n \n+// Order spans by position in the file.\n+impl Ord for SpanData {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        let SpanData {\n+            lo: s_lo,\n+            hi: s_hi,\n+            ctxt: s_ctxt,\n+            // `LocalDefId` does not implement `Ord`.\n+            // The other fields are enough to determine in-file order.\n+            parent: _,\n+        } = self;\n+        let SpanData {\n+            lo: o_lo,\n+            hi: o_hi,\n+            ctxt: o_ctxt,\n+            // `LocalDefId` does not implement `Ord`.\n+            // The other fields are enough to determine in-file order.\n+            parent: _,\n+        } = other;\n+\n+        (s_lo, s_hi, s_ctxt).cmp(&(o_lo, o_hi, o_ctxt))\n+    }\n+}\n+\n+impl PartialOrd for SpanData {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n impl SpanData {\n     #[inline]\n     pub fn span(&self) -> Span {"}]}